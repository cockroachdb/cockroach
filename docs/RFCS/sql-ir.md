- Feature Name: Intermediate Representation (IR)
- Status: draft
- Start Date: 2016-10-18
- Authors: knz
- RFC PR: (PR # after acceptance of initial draft)
- Cockroach Issue: (one or more # from the issue tracker)

# Summary

This RFC introduces an intermediate representation for the SQL used by
CockroachDB.

# Motivation

Primary motivations:

- to encode the query of non-materialized views.
- to enable more straightforward definitions for query optimization algorithms.
- to transfer filter expressions across the wire when spawning distSQL processors.

Side concerns that influence the design:

- robustness against function renames across cockroachdb versions.
  The representation of functions must capture the product version.

- robustness against db/table/column/view renames.
  The representation of these things must capture the internal ID.

Non-constraints:

- The IR needs not be pretty-printable back to valid SQL. In the few
  cases where something needs to produce SQL syntax back to a user
  (e.g. SHOW CREATE), the IR node can keep a copy of the string in
  original syntax before encoding in the IR.

# Detailed design

Overview:

1. the IR is formally defined in a type specification language. See
   below for details/draft.
2. a (new) tool translates the IR definition into:
   - Go structs/protobufs suitable for serialization.
   - accessor methods.
   - walk (visitor) recursion.
   - match methods meant to ease pattern matching (see below for details)
   - pretty printer (optionally scanner if need be).
3. when applicable, the structs generated by (2) coincide in name and
   field structure with the AST nodes already present in CockroachDB, so
   as to enable smooth(er) integration in the existing codebase.
4. the existing code can be evolved to use the IR:
   - DEFAULT expressions in table schemas.
   - foreign key constraints.
   - view definitions.
   - EXPLAIN.

## Formal specification

We want to define the IR in a high(er)-level language (HLL) that eases the
definition of complex type hierarchies.
This HLL must support sum and product types, probably parameterized types too.

(NB: We may want it to support record types too for readability, but from
a theoretical perspective record types are just glorified product types.)

This RFC proposes to use a subset of ML as IR definition HLL.
A draft of the definition for the proposed IR is presented in appendix below.

## IR elements

The IR contains node types for expressions, as expected.
Salient aspects of expressions:
- column references are initially (just after parsing from SQL)
  unresolved names, but collapse into integer column references during semantic analysis.
- SQL's "IN" has two IR encodings, depending on whether one of the operands is a subquery.

The bulk of what makes SQL special is the IR for "table expressions".
Salient features:
- the IR contains a node for the entire SelectClause, but this is only meant
  as transient node to be normalized into a tree of other tableexprs.
- the IR for table expressions reifies the operators from relational
  algebra: Join Filter, Render, Sort, etc.
- Insert, Update, Delete, Explain and Show are also table expressions in the IR.

The IR gives only minimal lip service to "statements". Because most of
the interesting semantics of "statements" are table expressions in the
IR, there is only one statement "Do" that says "run the plan for this
table expression and return its results". Every other statement can be
expressed as a composition of Do and some table expression. Some examples
are given in comments in the draft below.

## Match functions

In other languages with pattern matching (eg. Rust, ML, Haskell, and
C++ to some extent) one can make nifty operations based on tree
patterns. For example:

```ocaml
  match expr with 
  | BinOp(Gt, a, b)              -> BinOp(Lt, b, a)
  | Unop(Not, BinOp(GtEq, a, b)) -> BinOp(Lt, a, b)
```

The idea of these match operators is that there is a *pattern* on the
left hand side which is used as conditional; if the input item matches
the pattern, the item it is *deconstructed* and names inside the
pattern are bound to the matching sub-part of the input item in the
scope of the right hand side.

This is really a good feature to have in general! And we can "emulate" this
with Go given sufficient support from a tool to generate the missing pieces.

What we could want to write in go:

```go
oexpr := match(iexpr, 
	"BinOp(Gt, a, b)",              func(a, b Expr) Expr { return BinOp{Lt, b, a} },
	"UnOp(Not, BinOp(GtEq, a, b))", func(a, b Expr) Expr { return BinOp{Lt, a, b} },
	)
```

How to get this to work?

A tool would scan the source file and produce a separate file with the following definitions:
```go
var matchers := map[string]matcher

func match1(iexpr Expr, actionfn func(...interface{})) {
  if t, ok := iexpr.(*BinOp) ; ok {
    if _, ok := t.op.(*Gt); ok {
	  actionfn(t.left, r.right)
   }
  } 
}

func caller1(items ...interface{}, resultfn interface{}) interface{} {
   resultfn_real := resultfn.(func (Expr, Expr) Expr)
   return resultfn_real(items[0].(Expr), items[1].(Expr))
}

func init() {
  matchers["BinOp(Gt, a, b)"] = matcher{match1, caller1}
  matchers["UnOp(Not, BinOp(GtEq, a, b))"] = {match2, caller2}
}
```

Then the common implementation of `match` will look up the functions
in the global array `matchers` and Do The Right Thing (TM).

Note this is slow but is assuming that we don't want a Go
preprocessor. With a preprocessor, the "call" to the match function
could be replaced by the explicit conditionals and kill the overhead.

# Drawbacks

This is a semi-large refactoring of the existing code.

# Alternatives

None knowns.

# Unresolved questions

- Expression tree can contain nodes with Go values (expecially
  timestamps, dates). What to do with those with respect to
  serialization?

# Appendix: draft IR definition

```ocaml
(* How to read these type definitions: *)

(* this is a comment *)

(* this defines "ident" to be an alias for "string" *)
type ident = string

(* this defines "intpair" to be the type of a tuple of two integers: *)
type intpair = int * int

(* this defines "i2list" to be the type of a list of zero or more
     int pairs: *)
type i2list = intpair list 
(* equivalent to: "type i2list = (int * int) list" *)

(* this defines "namedpair" to be the type of a record containing a
     "left" and "right" integer: *)
type namedintpair = { left  : int
                    ; right : int
                    }
(* Note: the main definitions below do not (yet) use record syntax.
   We may add them later when the generator tool is ready for them. *)

(* this defines "smallbinop" to be the type containing only the two
   values "Plus" and "Minus" (variant/union/sum type): *)
type smallbinop = Plus | Minus
(* alternate syntax: *)
type smallbinop_alt = | Plus | Minus

(* this defines "smallexpr" to be the type of expression trees that can
   express integer values and binary operations on them: *)
type smallexpr =
  | IntVal of int
  | BinOp of smallbinop * smallexpr * smallexpr
(* the syntax "of" says that the variant name on the left becomes a
   variant with the value type on the right. Note that a type can
   refer to itself. *)

(* this defines two recursive types *)
type ifstmt = { cond  : smallexpr
              ; sthen : smallstmt (* refers to smallstmt below *)
              ; selse : smallstmt
              }
 and smallstmt =  (* note the "and" keyword *)
   | Seq of smallstmt list
   | If of ifstmt (* refers to ifstmt above *)

(* You're done understanding the syntax! Now on to our SQL AST types. *)

(**********************************************************************)
(**********************************************************************)

(* The following abstract type can represent every SQL type. *)
type ty =
  | Int | Bool | Float | Timestamp | Date | Interval
  | Bytes of int (* int specifies the max width in bytes, 0 for no max *)
  | String of int (* int specifies the max width in characters, 0 for no max *)
  | CollatedString of string (* string specifies the collation format *)
  | Decimal of int * int (* precision/scale, 0 for no restriction *)
  | TupleTy of ty list
  (* We don't fully support arrays yet, but we will. *)
  | ArrayTy of ty
  (* We don't support records yet, but we will. *)
  | RecordTy of (string * ty) list
  (* TableTy is not commonly understood to
     be part of SQL, but it makes typing of subqueries *much* easier. *)
  | TableTy of (ty * string) list
  | NullTy (* not sure this belongs. I think it can be removed *)

(* This type represents operators that compute a new value from left
   and right operands. Used by "expr" below. *)
type binop =
  (* Boolean operators *)
  | And | Or
  (* Arithmetic: + - / // % *)
  | Plus | Minus | Mult | Div | FloorDiv | Mod
  (* Binary arithmetic: & | ^ << >> *)
  | BitAnd | BitOr | BitXor | LeftShift | RightShift
  (* String: || *)
  | Concat

(* This type represents operators that compute a new value from a
   single operand. Used by "expr" below. *)
type unop =
  (* Boolean negation *)
  | Not
  (* Unary negation: - *)
  | Neg
  (* Binary complement: ~ *)
  | Compl

(* The type "cmpop" represents operators that compare two values.
   It is separate from "binop" above because comparisons have
   in common that they all return booleans. *)
type casei = bool
type cmpop =
  | Eq                   (* =   -- does not match NULL *)
  | Is                   (* IS  -- matches NULL *)
  | Lt                   (* < *)
  | In                   (* IN  -- used for tuples only after normalization;
                            see InExpr for subqueries below. *)
  | Like of casei        (* LIKE / ILIKE *)
  | RegMatch of casei    (* ~ / ~* *)
  (* The following are syntactic sugar; sorta.
     They disappear soon after parsing, to simplify intermediate transforms,
     and then re-introduced when instantiating table scan filters since
     the expanded form can expose more intelligent scan orders. *)
  | Neq                  (* a <> b       === NOT(a = b) *)
  | IsNot                (* a IS NOT b   === NOT(a IS b) *)
  | LtEq                 (* a <= b       === NOT(b < a) *)
  | GtEq                 (* a >= b       === NOT(a < b) *)
  | Gt                   (* a > b        === b < a *)
  | NotIn                (* a NOT IN b   === NOT(a IN b) *)
  | NotRegMatch of casei (* a !~ b       === NOT(a ~ b) *)
  | NotLike of casei     (* a NOT LIKE b === NOT(a LIKE b) *)

(* Type of type names in expressions: *)
type tyexpr =
  | UnresolvedTypeName of ident
  | UnresolvedTupleTy of tyexpr list
  | UnresolvedArrayTy of tyexpr
type tyref =
  (* When it has just been parsed *)
  | UnresolvedType of tyexpr
  (* After type name resolution *)
  | Ty of ty

(* Type of aggregation: *)
type agg = All | Distinct

(* Name parts in unresolved names: *)
type namepart =
  | Name of ident
  | Star
  | Index of expr

(* Table name: *)
and tref =
  (* When it has just been parsed *)
  | UnresolvedTableName of namepart list
  (* After name resolution, it contains the DB ID + table ID. *)
  | TRef of int * int

(* Column reference: *)
and cref =
  (* When it has just been parsed *)
  | UnresolvedColumnName of namepart list
  (* After name resolution, it contains the index of the column at the
     current query level. *)
  | CRef of int

(* Database reference: *)
and dref =
  (* When it has just been parsed *)
  | UnresolvedDBName of namepart list
  (* After name resolution, it contains the DB ID. *)
  | DRef of int

(* Function reference: *)
and fref =
  (* When it has just been parsed *)
  | UnresolvedFuncName of namepart list
  (* After name resolution, it contains the CockroachDB version and
     function name.  We need both for forward-compatibility.  *)
  | FRef of ident * ident 

(* Expressions *)
and expr =
  (* NULL *)
  | NullVal
  (* Literals. *)
  | IntVal of string (* before type checking, evaporates afterwards *)
  | DecVal of string (* before type checking, evaporates afterwards *)
  | DInt of int | DFloat of float (* ... some more omitted here ... *)
  | DString of string | DBytes of string
  | DCollatedString of string * string
  (* Compound expressions. *)
  | Tuple of expr list
  | Array of expr list
  (* Special value DEFAULT. *)
  | DefaultVal
  (* Placeholders for PREPARE/EXECUTE. *)
  | Placeholder of string
  (* A reference to a column in the "current row". *)
  | ColRef of cref
  (* Arithmetic and comparisons. *)
  | BinOp of binop * expr * expr
  | UnOp of unop * expr
  | CmpOp of cmpop * expr * expr
  (* Conditionals. *)
  | If of expr * expr * expr
  | Case of expr * (expr * expr) list * expr
  | IsOf of expr * tyref list   (* <E> IS OF (<T>, <T>, ...) *)
  | NullIf of expr * expr
  | Coalesce of expr list
  (* Function call. *)
  | Call of fref * expr list
  (* Aggregate function. *)
  | Agg of fref * agg * expr list
  (* Cast: <E>::<T>  but also things like TIMESTAMP '....' *)
  | Cast of tyref * expr
  (* CockroachDB's special <E>:::<T> to help typing. *)
  | AnnotateType of tyref * expr (* evaporates after type checking *)
  (* <E> IN <Subquery> *)
  | InTable of expr * tableexpr
  (* EXISTS(<Subquery>) *)
  | Exists of tableexpr

(* "Select clause": something that can return a table. Can be typed
   using TableTy above. *)
and tableexpr =
  | Values    of expr list list
  (* Table composition. *)
  | Union     of tableeexpr * tableeexpr
  | Intersect of tableeexpr * tableeexpr
  | Except    of tableeexpr * tableeexpr
  (* SelectClause evaporates after normalization
   into the nodes below it. *)
  | SelectClause of   isdistinct
                      * render list
                      * tableexpr             (*FROM*)
                      * expr option           (*WHERE*)
                      * expr list             (*GROUP BY*)
                      * expr option           (*HAVING*)
                      * window                (*WINDOW*)
                      * (expr * sortdir) list (*ORDER BY*)
                      * expr                  (*LIMIT*)
  | Join     of jointype * joinpred * tableexpr * tableexpr
  | Distinct of tableexpr
  | Filter   of tableexpr * where
  | GroupAgg of tableexpr * int list * expr list (* the ints refer to the grouping columns *)
  | Render   of tableexpr * expr list
  | Window   of tableexpr * window
  | Sort     of tableexpr * (int * sortdir) list (* the ints refer to the sorting columns *)
  (* Statements returning rows. *)
  | Insert   of tref * cref list * tableeexpr * onconflict
  | Update   of tref * assign list
  | Delete   of tref * where
  | Explain  of tableexpr
  | Show (* ...parameters omitted... *)
  (* Alias and RenameColumns may be used during name resolution. Probably transient. *)
  | Alias of tableexpr * ident
  | RenameColumns of tableexpr * ident list
  (* With clauses: WITH a AS (subquery) ... also probably evaporates after name resolution. *)
  | With of tableexpr * ident * tableexpr

and isdistinct = bool
and render =
  NormalExpr of expr * ident option
| RenderStar
and assign = cref list * expr
and sortdir = Asc | Desc
and joinpred = AlwaysTrue | Natural | Using of ident list | On of expr
and jointype = Inner | OuterLeft | OuterRight | OuterFull | Cross
and window = (ident * ident * expr list * expr list) list
and onconflict =
  | Error (* normal insert *)
  | DoNothing
  | Rewrite of  cref list * assign list * where

(* Top-level statements. *)
and stmt =
(* Do(T) means run the clause T (see above for clause types) and return
   all its results. *)
(* For example SELECT is encoded as Do(SelectClause). *)
| Do tableexpr

(* DoAndCount(T) means run the clause T and return the count of its results. *)
(* For example INSERT/UPDATE/DELETE is initially encoded as DoAndCount(<Clause>). *)
(* DoAndCount(T) then disappears during normalization into Do(GroupAgg(T, *, COUNT( * ))). *)
| DoAndCount tableexpr 

(* DoAndReturn(T, E...) is syntactic sugar for, and is normalized to,
   Do(Render(T, E...)).  *)
(* For example INSERT/UPDATE/DELETE...RETURNING are initially encoded as DoAndReturn. *)
| DoAndReturn tableexpr * render list

                               (* < some more stmt types omitted here ... > *)
```
