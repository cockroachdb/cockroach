- Feature Name: Cascading Referential Integrity Constraints
- Status: draft
- Start Date: 2017-26-17
- Authors: Bram Gruneir
- RFC PR:
- Cockroach Issue:

# Summary

Being able to cascade deletes through foreign key references is a very common activity and part of the SQL standard. This RFC proposes to add in the `ON DELETE action` and `ON UPDATE action` keywords when defining the foreign key references on a `CREATE TABLE` or `ALTER TABLE` command.

This RFC proposes the addition of the following optional actions to referential integrity constraints within a `CREATE TABLE`'s `REFERENCES` and `FOREIGN KEY` columns:

- `ON DELETE CASCADE`
- `ON UPDATE CASCADE`
- `ON DELETE SET DEFAULT`
- `ON UPDATE SET DEFAULT`
- `ON DELETE SET NULL`
- `ON UPDATE SET NULL`

While not essential, these actions, specifically `ON DELETE CASCADE`, have been requested multiple times by both the community and potential customers.

The addition of these optional actions it will unlock more ORM functionality as cascade is a very common option when defining foreign key references and bring us closer to parity with Postgres.

## Not Covered

Note that this RFC will only be tangentially discussing deferring or disabling the enforcement of foreign key constraints. So what is not covered includes all of the deferrable options on constraints: `DEFERRED NOT DEFERRABLE`, `DEFERRED INITIALLY IMMEDIATE`, `DEFERRED INITIALLY DEFERRED`. This rfc also excludes setting the transaction to defer certain constraints and not using the commands `SET CONSTRAINTS ALL/some_named_constraint DEFERRED` or `SET CONSTRAINTS ALL/some_named_constraint IMMEDIATE`.

Futhermore, this RFC will not be covering different techniques for matching composite foreign keys using the `MATCH` keyword. However, there will be some discussion around these concepts as they will have an impact in the future if we choose to implement them.

At this time there is no plan to allow multiple tables to be referenced by the same key while this is allowed in postgres. An example of how this works is shared in the reference-level explanation.

# Motivation

While cascading referential integrity constraints are in the SQL standard, they are not essential as they can be seen as shortcuts to writing longer SQL transactions.  However, they have been an often requested feature and are quite often used ORMs. What is clear, is that the addition of these options will unlock new customer opportunities for us.

# Guide-level explanation

## What is a table constraint?

A table constraint is a check on a table that ensures that all rows in that table must pass before being committed. These can include simple checks, such as ensuring a value is greater than zero, to more complex ones such as ensuring the value in a column is unique.  See [here](https://www.cockroachlabs.com/docs/stable/constraints.html) for our docs on the subject. The constraints we're specifically interested in for this RFC are foreign keys references.

## What is a referential integrity constraint?

A referential integrity constraint is the technical term for a foreign key constraint. They require that the key in a column is present in another table. [Here](https://www.cockroachlabs.com/docs/stable/foreign-key.html) are our docs about them.

## How do cascading referential integrity constraints work?

When updating or deleting a row in a table that has been used as a foreign key in another table, it is also important to update the table that's referencing this key. When declaring a foreign key constraint, it is possible to specify what action should occur when the referenced key is altered or deleted.

## What are `ON DELETE` and `ON UPDATE` actions?

There are optional actions that will occur when a the referenced foreign key is removed `ON DELETE` or when the key is updated `ON UPDATE`. All foreign key relationships already have default actions for both of these, and that is `NO ACTION`.

## What are all the available actions?

### `NO ACTION`

If the foreign key being removed is still referenced in another table, fail the transaction. This is a poorly named, but must be read as what action should be taken when the reference is changed. If the referenced foreign key is changed, perform *no action* and fail the transaction.

### `RESTRICT`

`RESTRICT` is exactly the same as `NO ACTION` in our current implementation. When used in Postgres, it always eagerly checks and fails if there is any row referencing the foreign key that was updated or deleted. Unlike `NO ACTION` which waits until the end of the transaction if constraint checks have been deferred. This action has been added and stored in the ForeignKeyReference for future use for when we opt to add the ability to defer constraint checking.

### `CASCADE`

This is the most common use case. When the `CASCADE` action is specified, if the referenced foreign key is deleted or altered, than respectively delete the row or alter the key in the referencing table. The name cascade comes from the fact that the change made on the referenced table cascades into the referencing table. It is not uncommon for cascading deletes to walk though numerous tables.

### `SET NULL`

When the referencing key is deleted or altered this option sets the foreign key reference column to null. Note that this will not work on columns that also the the `NOT NULL` constraint.

### `SET DEFAULT`

When the referencing key is deleted or altered this option sets the foreign key referencing column to the default value for the column. If the default for the column is null, then this is the equivalent `SET NULL`.  Note that if this default is not null, then there must still be a referenced key that the default must match.

## Why would one want to defer the checking of constraints?

Deferring constraints delays the checking and enforcement of the constraints until the end of a transaction instead of eagerly failing when violated. The most commonly sited use case is cyclical foreign keys references but there are a number of instances where this can be very helpful to defer constraint checking.

[Here](https://begriffs.com/posts/2017-08-27-deferrable-sql-constraints.html) is an excellent source that explains the different ways that Postgres handles deferrable constraints, the most common use cases for deferring and the pros and cons of doing so.

While we are not going to be deferring constraints at this time, we need be aware that this will be something that we most likely will be adding in the near future.

## What is a composite foreign key?

A composite foreign key is a referential integrity constraint that is created from more than one source column on another table. We do support composite foreign keys and all added operations will need to take foreign key matching into account.

## What are the different matching options for composite foreign keys?

- `MATCH FULL` considers a foreign key as valid if every foreign key column is null or if all foreign key columns are not null and match the referenced table.
- `MATCH PARTIAL` is valid if at least one Foreign key column is null and the rest of the not null columns match those of the referenced tables or all foreign key columns are not null and match the referenced table.
- `MATCH SIMPLE` considers a foreign key valid if all columns are not null and match the referenced key exactly or if one of the foreign key values is null.

We currently only offer `MATCH FULL`, while Postgres' and SQL Server's default is `MATCH SIMPLE`. There are no plans to support the other match types at this time. However, the addition of the other composite key matching types will affect when to trigger an `ON DELETE` actions.

# Reference-level explanation

## Survey of other databases

All major databases support the `ON DELETE action` and `ON UPDATE action` options. But there are some minor differences in which options they allow. This section also includes the differences for the `MATCH` options and `DEFERRED`/`IMMEDIATE` constraint checking as they may be useful in the future.

### Postgres

Postgres is by far the most nuanced allowing more options than the others.
Postgres supports 5 different actions:

- `CASCADE`: delete or update the reference  when the referenced key is removed
- `SET NULL`: set the foreign key to null if the key is deleted or updated.
- `SET DEFAULT`: set the foreign key to its default value if the key is deleted or updated.
- `RESTRICT`: immediately fail if there are any existing references to the key being updated or deleted.
- `NO ACTION`: The default option. Fail if there are any existing references to the key being updated or deleted, but allow this check to be deferred until the end of the transaction.

Postgres also offers two options around matching:

- `MATCH FULL`: No part of a foreign key can be null, unless they are all null.
- `MATCH SIMPLE`: The default behaviour. Nulls are allowed.

Postgres also offers deferred constraint checking using the `DEFERRED` and `IMMEDIATE` keywords.

[Here](https://www.postgresql.org/docs/current/static/ddl-constraints.html#ddl-constraints-fk) is the main reference for Postgres.

### Transact-SQL (MS SQL Server)

MS SQL Server offers a similar set of options to Postgres, but does not offer the `RESTRICT` action. However, since they do not offer a `DEFERRED` at all, `NO ACTION` is the equivalent of `RESTRICT`. To get around this restrictive mode, the suggested work around is to allow the columns to be null.

Futhermore, the cascading of the referential integrity constraints is also limited to a single instance of each table and there can be no loops. See [this article](https://technet.microsoft.com/en-us/library/ms186973(v=sql.105).aspx) for more info.

MS SQL Server has full support for all types composite key matching.

[Here](https://docs.microsoft.com/en-us/sql/t-sql/statements/create-table-transact-sql) is main reference for SQL Server.

### MYSQL

MYSQL actually offers all the actions that postgres does, but `NO ACTION` is an alias for `RESTRICT`. There is no option to defer the checking of the constraints and the `DEFERRED` and `IMMEDIATE` keywords are not valid. If one wants to make adjustments and work around the constraints, the system variable [foreign_key_checks](https://dev.mysql.com/doc/refman/5.7/en/server-system-variables.html#sysvar_foreign_key_checks) can be set to `0` which turns off constraint checking within a session. But it is important to note that turning it back on by setting it to `1` does not then go back and check the constraints of the altered rows.

For composite keys, there is only a single matching option which is the equivalent of Postgres' `MATCH SIMPLE`. Including the `MATCH` keyword is accepted but based on the documentation broken and will potentially nullify any cascading action.

[Here](https://dev.mysql.com/doc/refman/5.7/en/create-table-foreign-keys.html) is the main reference for MYSQL.

### PL-SQL (Oracle)

Oracle only allows 3 options for cascading. The default value, which is specifically not specifying any action, is the equivalent to `NO ACTION`. It also has `SET NULL` and `CASCADE`. Oracle has a full suite of options for deferring constraint checking, including the keywords `DEFERRED` and `IMMEDIATE`. It also has the option to permanently disable a constraint using the `DISABLE` keyword. More details on disabling can be found [here](http://docs.oracle.com/database/122/SQLRF/constraint.htm#GUID-1055EA97-BA6F-4764-A15F-1024FD5B6DFE__I1002349).

Oracle offer three levels of composite key matching:

- `MATCH FULL` Partially null foreign keys are not permitted. Either all components of the foreign key must be null, or the combination of values contained in the foreign key must appear as the primary or unique key value of a single row of the referenced table.
- `MATCH PARTIAL` Partially null composite foreign keys are permitted. Either all components of the foreign key must be null, or the combination of non-null values contained in the foreign key must appear in the corresponding portion of the primary or unique key value of a single row in the referenced table.
- `MATCH NONE` Partially null composite foreign keys are permitted. If any column of a composite foreign key is null, then the non-null portions of the key do not have to match any corresponding portion of a parent key.

[Here](http://docs.oracle.com/database/122/SQLRF/constraint.htm#GUID-1055EA97-BA6F-4764-A15F-1024FD5B6DFE__I1002118) is the main reference for Oracle.

## Foreign Keys References from Multiple Tables

We don't currently support foreign key references from multiple tables, but it would be possible to add this at some point in the future. Postgres does support them.

To further elucidate the point, instead of describing a foreign key reference from one table to another, it is possible to add a reference to the same keys in multiple tables. To see how this works, consider the following:

Table A has an id column.
Table B contains a foreign key reference to table_a.id. Let's call it table_b.a_id.
Table C contains a foreign key reference to table_a.id. Let's also call it table_c.a_id.
Table D contains a foreign key reference to both table_b.a_id and table_c.a_id.

This means that to enter a value into table d, it must exist in both tables b and c. If it is only one, the constraint will be violated.

## Detailed design

This RFC proposes to add in all the missing functionality and keywords from Postgres to allow for cascading referential integrity constraints.

### Proposed Keywords

Here is a detailed list of all of the proposed foreign key reference actions:

- `ON DELETE CASCADE` When a referenced foreign key is deleted, all rows referencing that key are deleted. If there are other alterations to the row, such as a `SET NULL` or `SET DEFAULT`, the delete with take precedence.

- `ON UPDATE CASCADE` When a referenced foreign key is updated, update the columns of all rows referencing that key to the new value.

- `ON DELETE SET DEFAULT` When a referenced foreign key is deleted, set the columns of all rows referencing that key to the default value for that column. If the default value for the column is null, this will have the same effect as `ON DELETE SET NULL`. The default value must still conform with all other constraints, such as `UNIQUE`.

- `ON UPDATE SET DEFAULT` When a referenced foreign key is updated, set the columns of all rows referencing that key to the default value for that column. If the default value for the column is null, this will have the same effect as `ON UPDATE SET NULL`. The default value must still conform with all other constraints, such as `UNIQUE`.

- `ON DELETE SET NULL` When a referenced foreign key is deleted, set the columns of all rows referencing that key to null. The column must allow nulls or this update will still fail.

- `ON UPDATE SET NULL` When a referenced foreign key is updated, set the columns of all rows referencing that key to null. The column must allow nulls or this update will still fail.

Please note that all foreign key references can have both an `ON DELETE` and an `ON UPDATE` and that their actions are not required to be the same.

### Examples

For all examples, the error codes generated are a combination of both Cockroach and Postgres errors. They will be refined during implementation.

#### Basic examples

For all of the following examples, assume we have the following setup:

```SQL
CREATE TABLE a (
  id INT PRIMARY KEY
);

INSERT INTO a (id) VALUES (0), (1), (2), (3), (4), (5), (6), (7), (8);

CREATE TABLE b (
  delete_restrict INT NOT NULL REFERENCES a ON DELETE RESTRICT
 ,update_restrict INT NOT NULL REFERENCES a ON UPDATE RESTRICT
 ,delete_cascade INT NOT NULL REFERENCES a ON DELETE CASCADE
 ,update_cascade INT NOT NULL REFERENCES a ON UPDATE CASCADE
 ,delete_null INT REFERENCES a ON DELETE SET NULL
 ,update_null INT REFERENCES a ON UPDATE SET NULL
 ,delete_default INT DEFAULT 0 REFERENCES a ON DELETE SET DEFAULT
 ,update_default INT DEFAULT 0 REFERENCES a ON DELETE SET DEFAULT
);

INSERT INTO b VALUES (1, 2, 3, 4, 5, 6, 7, 8);
```

And we expect:

```SQL
SELECT * FROM b;
+-----------------+-----------------+----------------+----------------+-------------+-------------+----------------+----------------+
| delete_restrict | update_restrict | delete_cascade | update_cascade | delete_null | update_null | delete_default | update_default |
+-----------------+-----------------+----------------+----------------+-------------+-------------+----------------+----------------+
|               1 |               2 |              3 |              4 |           5 |           6 |              7 |              8 |
+-----------------+-----------------+----------------+----------------+-------------+-------------+----------------+----------------+
(1 row)
```

##### `ON DELETE NO ACTION` or `ON DELETE RESTRICT`

When we try to delete a referenced key that does not specify a delete action or specifies it to `RESTRICT`, the operation fails.

```SQL
DELETE FROM a WHERE id = 1;
pq: foreign key violation: values [1] in columns [id] referenced in table "b"

SELECT * FROM b;
+-----------------+-----------------+----------------+----------------+-------------+-------------+----------------+----------------+
| delete_restrict | update_restrict | delete_cascade | update_cascade | delete_null | update_null | delete_default | update_default |
+-----------------+-----------------+----------------+----------------+-------------+-------------+----------------+----------------+
|               1 |               2 |              3 |              4 |           5 |           6 |              7 |              8 |
+-----------------+-----------------+----------------+----------------+-------------+-------------+----------------+----------------+
(1 row)
```

##### `ON UPDATE NO ACTION` or `ON UPDATE RESTRICT`

When we try to update a referenced key that does not specify an update action or specifies it to `RESTRICT`, the operation fails.

```SQL
UPDATE a SET id = 7 WHERE id = 1;
pq: foreign key violation: values [1] in columns [id] referenced in table "b"

SELECT * FROM b;
+-----------------+-----------------+----------------+----------------+-------------+-------------+----------------+----------------+
| delete_restrict | update_restrict | delete_cascade | update_cascade | delete_null | update_null | delete_default | update_default |
+-----------------+-----------------+----------------+----------------+-------------+-------------+----------------+----------------+
|               1 |               2 |              3 |              4 |           5 |           6 |              7 |              8 |
+-----------------+-----------------+----------------+----------------+-------------+-------------+----------------+----------------+
(1 row)
```

##### `ON DELETE CASCADE`

When the reference key is deleted, we remove a referenced key and the referencing row is deleted.

```SQL
DELETE FROM a WHERE id = 3;

SELECT * FROM b;
+-----------------+-----------------+----------------+----------------+-------------+-------------+----------------+----------------+
| delete_restrict | update_restrict | delete_cascade | update_cascade | delete_null | update_null | delete_default | update_default |
+-----------------+-----------------+----------------+----------------+-------------+-------------+----------------+----------------+
+-----------------+-----------------+----------------+----------------+-------------+-------------+----------------+----------------+
(0 rows)
```

##### `ON UPDATE CASCADE`

When the referenced key is updated, the referencing key is updated to the same value.

```SQL
UPDATE a SET id = 100 WHERE id = 4;

SELECT * FROM b;
+-----------------+-----------------+----------------+----------------+-------------+-------------+----------------+----------------+
| delete_restrict | update_restrict | delete_cascade | update_cascade | delete_null | update_null | delete_default | update_default |
+-----------------+-----------------+----------------+----------------+-------------+-------------+----------------+----------------+
|               1 |               2 |              3 |            100 |           5 |           6 |              7 |              8 |
+-----------------+-----------------+----------------+----------------+-------------+-------------+----------------+----------------+
(1 row)
```

##### `ON DELETE SET NULL`

When the referenced key is deleted, the referencing key is set to null.

```SQL
DELETE FROM a WHERE id = 5;

SELECT * FROM b;
+-----------------+-----------------+----------------+----------------+-------------+-------------+----------------+----------------+
| delete_restrict | update_restrict | delete_cascade | update_cascade | delete_null | update_null | delete_default | update_default |
+-----------------+-----------------+----------------+----------------+-------------+-------------+----------------+----------------+
|               1 |               2 |              3 |              4 | NULL        |           6 |              7 |              8 |
+-----------------+-----------------+----------------+----------------+-------------+-------------+----------------+----------------+
(1 row)
```

##### `ON UPDATE SET NULL`

When the referenced key is updated, the referencing key is set to null.

```SQL
UPDATE a SET id = 100 WHERE id = 6;

SELECT * FROM b;
+-----------------+-----------------+----------------+----------------+-------------+-------------+----------------+----------------+
| delete_restrict | update_restrict | delete_cascade | update_cascade | delete_null | update_null | delete_default | update_default |
+-----------------+-----------------+----------------+----------------+-------------+-------------+----------------+----------------+
|               1 |               2 |              3 |              4 |           5 | NULL        |              7 |              8 |
+-----------------+-----------------+----------------+----------------+-------------+-------------+----------------+----------------+
(1 row)
```

##### `ON DELETE SET DEFAULT`

When the referenced key is deleted, the referencing key is set to the default value for that column.

```SQL
DELETE FROM a WHERE id = 7;

SELECT * FROM b;
+-----------------+-----------------+----------------+----------------+-------------+-------------+----------------+----------------+
| delete_restrict | update_restrict | delete_cascade | update_cascade | delete_null | update_null | delete_default | update_default |
+-----------------+-----------------+----------------+----------------+-------------+-------------+----------------+----------------+
|               1 |               2 |              3 |              4 |           6 |           6 |              0 |              8 |
+-----------------+-----------------+----------------+----------------+-------------+-------------+----------------+----------------+
(1 row)
```

##### `ON UPDATE SET DEFAULT`

When the referenced key is updated, the referencing key is set to the default value for that column.

```SQL
UPDATE a SET id = 100 WHERE id = 8;

SELECT * FROM b;
+-----------------+-----------------+----------------+----------------+-------------+-------------+----------------+----------------+
| delete_restrict | update_restrict | delete_cascade | update_cascade | delete_null | update_null | delete_default | update_default |
+-----------------+-----------------+----------------+----------------+-------------+-------------+----------------+----------------+
|               1 |               2 |              3 |              4 |           5 |           6 |              7 |              0 |
+-----------------+-----------------+----------------+----------------+-------------+-------------+----------------+----------------+
(1 row)
```

##### Edge Case: `ON UPDATE/DELETE SET DEFAULT` default does not exist

When the referenced key is updated or deleted and should be set to the default, but that default value does not exist, the operation should fail.

```SQL
DELETE FROM a WHERE id = 0;

DELETE FROM a where id = 7;
pq: foreign key violation: Key (delete_default)=(0) is not present in table "a";

UPDATE a SET id = 100 WHERE id = 8;
pq: foreign key violation: Key (delete_default)=(0) is not present in table "a";
```

##### Edge Case: `NOT NULL` and `ON UPDATE/DELETE SET NULL`

We do not currently allow the altering of constraints so this can be checked at the time of the creation of the constraint.

```SQL
CREATE TABLE c (
  delete_not_nullable INT NOT NULL REFERENCES a ON DELETE SET NULL
);
pg: cannot create a constraint for column "delete_not_nullable" to ON DELETE SET NULL that also has a NOT NULL constraint.

CREATE TABLE c (
  update_not_nullable INT NOT NULL REFERENCES a ON UPDATE SET NULL
);
pg: cannot create a constraint for column "update_not_nullable" to ON UPDATE SET NULL that also has a NOT NULL constraint.
```

##### Edge Case: `ON UPDATE CASCADE` violates another constraint

In this example, the second constraint on table c means that the cascading update of the id will violate that new constraint. In essence, by adding the new constraint on the column in table c that has a `ON UPDATE CASCADE`, it is also de facto adding that constraint on table a for any keys that have already been referenced.

```SQL
CREATE TABLE c (
  update_check INT REFERENCES a ON UPDATE CASCADE
 ,CONSTRAINT update_check CHECK (update_check < 100)
);
INSERT INTO c VALUES (1);
SELECT * FROM c;
+--------------+
| update_check |
+--------------+
|            1 |
+--------------+
(1 row)

UPDATE a SET id = 100 WHERE id = 1;
pg:  update or delete on table "a" violates foreign key constraint "b_delete_restrict_fkey" on table "b"
detail:  Key (id)=(1) is still referenced from table "b".
```

##### Edge Case: `ON UPDATE/DELETE SET NULL` violates another constraint

In a similar case, the `ON UPDATE SET NULL` or `ON DELETE SET NULL` can block updates to original table.

```SQL
CREATE TABLE c (
  update_unique INT UNIQUE REFERENCES a ON UPDATE SET NULL
 ,delete_unique INT UNIQUE REFERENCES a ON DELETE SET NULL
);
INSERT INTO c VALUES (1,1), (null, null);
SELECT * FROM c;
+---------------+---------------+
| update_unique | delete_unique +
+---------------+---------------+
|             1 |             1 |
+---------------+---------------+
| NULL          | NULL          |
+---------------+---------------+
(2 rows)

UPDATE a SET id = 100 WHERE id = 1;
pg:  update or delete on table "a" violates foreign key constraint "b_delete_restrict_fkey" on table "b"
detail:  Key (id)=(1) is still referenced from table "b".

DELETE FROM a WHERE id = 1;
pg:  update or delete on table "a" violates foreign key constraint "c_update_unique_fkey" on table "c"
detail:  Key (id)=(1) is still referenced from table "c".
```

#### Cascading Example

Here are the two canonical examples of cascading referential integrity constraints.

##### Cascading `ON DELETE CASCADE`

When a row in table a is deleted, all rows referencing that row in table b are deleted. Then all rows referencing the deleted row in table b are deleted.

```SQL
CREATE TABLE a (
  id INT PRIMARY KEY
);
INSERT INTO a VALUES (1);

CREATE TABLE b (
  id INT PRIMARY KEY
 ,a_id INT REFERENCES a ON DELETE CASCADE
);
INSERT INTO b VALUES (1,1);

CREATE TABLE c (
  b_id INT REFERENCES b ON DELETE CASCADE
);
INSERT INTO c VALUES (1);

SELECT * FROM a;
+----+
| id |
+----+
|  1 |
+----+
(1 row)

SELECT * FROM b;
+----+------+
| id | a_id |
+----+------+
|  1 |    1 |
+----+------+
(1 row)

SELECT * FROM c;
+------+
| b_id |
+------+
|    1 |
+------+
(1 row)

DELETE FROM a WHERE id = 1;

SELECT * FROM a;
+----+
| id |
+----+
+----+
(0 rows)

SELECT * FROM b;
+----+------+
| id | a_id |
+----+------+
+----+------+
(0 rows)

SELECT * FROM c;
+--------+
| b_a_id |
+--------+
+--------+
(0 rows)
```

##### Cascading `ON UPDATE CASCADE`

When the key is updated in table a, its new value is cascaded to table b. Which in turn gets cascaded to table c.

```SQL
CREATE TABLE a (
  id INT PRIMARY KEY
);
INSERT INTO a VALUES (1);

CREATE TABLE b (
 a_id INT PRIMARY KEY REFERENCES a ON UPDATE CASCADE
);
INSERT INTO b VALUES (1);

CREATE TABLE c (
  b_a_id INT REFERENCES b ON UPDATE CASCADE
);
INSERT INTO c VALUES (1);

SELECT * FROM a
  INNER JOIN b ON a.id = b.a_id
  INNER JOIN c ON b.a_id = c.b_a_id;
+----+------+--------+
| id | a_id | b_a_id |
+----+------+--------+
|  1 |    1 |      1 |
+----+------+--------+
(1 row)

UPDATE a SET id = 2 WHERE id = 1;

SELECT * FROM a
  INNER JOIN b ON a.id = b.a_id
  INNER JOIN c ON b.a_id = c.b_a_id;
+----+------+--------+
| id | a_id | b_a_id |
+----+------+--------+
|  2 |    2 |      2 |
+----+------+--------+
(1 row)
```

#### `DELETE` competes with another action

This is a bit of a contrived example, but it is possible to have two competing foreign key constraints that affect the same row. In the case where a `DELETE` competes with a `SET NULL`, `SET DEFAULT` or `UPDATE CASCADE`, the delete will always win. This can start to get quite convoluted and is an example where deferring the constraint checking to the end might be beneficial.

```SQL
CREATE TABLE a (
  id INT PRIMARY KEY
);
INSERT INTO a VALUES (1), (2);
CREATE TABLE b (
  a_id INT PRIMARY KEY REFERENCES a ON DELETE CASCADE
);
INSERT INTO b VALUES (1);
CREATE TABLE c (
  a_id INT PRIMARY KEY DEFAULT 2 REFERENCES a ON DELETE SET DEFAULT
);
INSERT INTO c VALUES (1);
CREATE TABLE d (
  b_a_id INT REFERENCES b ON DELETE CASCADE
 ,c_a_id INT REFERENCES c ON UPDATE CASCADE
);
INSERT INTO d VALUES (1,1);

SELECT * FROM a;
+----+
| id |
+----+
|  1 |
+----+
|  2 |
+----+
(2 rows)

SELECT * FROM b;
+------+
| a_id |
+------+
|    1 |
+------+
(1 row)

SELECT * FROM c;
+------+
| a_id |
+------+
|    1 |
+------+
(1 row)

SELECT * FROM d;
+--------+--------+
| b_a_id | c_a_id |
+--------+--------+
|      1 |      1 |
+--------+--------+
(1 row)

DELETE FROM a WHERE id = 1;

SELECT * FROM a;
+----+
| id |
+----+
|  2 |
+----+
(1 row)

SELECT * FROM b;
+------+
| a_id |
+------+
+------+
(0 rows)

SELECT * FROM c;
+------+
| a_id |
+------+
|    2 |
+------+
(1 row)

SELECT * FROM d;
+--------+--------+
| b_a_id | c_a_id |
+--------+--------+
+--------+--------+
(0 rows)
```

#### Self-Referential Cascading Deletes

Without going into the circular referencing which would required deferring, it is still possible to get self-referential tables that can cascade deletes between rows.

```SQL
CREATE TABLE a (
  id INT PRIMARY KEY
 ,other_id INT REFERENCES a ON DELETE CASCADE
);
INSERT INTO a VALUES (1, NULL), (2, 1), (3, 1), (4, 1);

SELECT * FROM a;
+----+----------+
| id | other_id |
+----+----------+
|  1 | NULL     |
|  2 |        1 |
|  3 |        1 |
|  4 |        1 |
+----+----------+
(4 rows)

DELETE FROM a WHERE id = 1;

SELECT * FROM a;
+----+----------+
| id | other_id |
+----+----------+
+----+----------+
(0 rows)
```

### Changes required

Almost all of the changes will be in `fk.go` and will need to take into consideration the possibility that we will be adding in deferrable constraints in the future. This does break the general pragmatic rule of *code for what you need today not for what you will need tomorrow*. So the suggestion here is not to alter the design, but to be cognizant of the implications of deferrable.

Most of the implementation details will be decided during the execution phase, but there are two main options.

The first option is to just walk the tree and execute each cascading action immediately. Following up on any cascade as it occurs. This should be relatively easy implement, but may take a long time to fail when there is a constraint violation. It also may also double write on conflicts, but those are an exceptionally rare occurrences.

The second is to pre-determine all cascading actions into one collection while walking the tree, than execute them. This adds the advantage of being able to deal with conflicts quickly and to fail without having to perform the actual writes. Also, it may allow the batching of multiple writes when there are multiple writes to the same table.

### Plan of Engineering

The plan will be to implement the new actions in order of importance, which is roughly:

1. `ON DELETE CASCADE`
1. `ON UPDATE CASCADE`
1. `ON DELETE SET NULL`
1. `ON UPDATE SET NULL`
1. `ON DELETE SET DEFAULT`
1. `ON UPDATE SET DEFAULT`

`ON DELETE CASCADE` is the most common and should help with ORM compatibility and is the most requested so it is placed at the top of the list.

### Testing

All of the above examples and some more complex ones will be added in a logic test style manner.

## Drawbacks

Without adding in deferrable at this time, there will be some work that must be done when deferrable constraints and transaction settings are added.

## Future Work

- A `SHOW RELATIONS` sql command that would output the full graph of relations for a table would be quite helpful.

## Rationale and Alternatives

Not supporting cascade is not really an option, but supporting Postgres' full range of cascading is not a requirement.  The most common use cases do not require self-referencing and circular cascading of the constraints. There is no requirement to add deferrable constraints and we may never do so.

So the alternatives here are to follow MySQL or SQL Server's style of dealing with cascading referential integrity constraints.

### MySQL

If we implement MySQL's deferred style, this would greatly simplify the engineering by not having to ever defer constraint enforcement, but instead turn it off temporarily. This seems compelling but would allow the database state to become quite broken. MySQL gets around this by never checking constraints that aren't updated but this seems lazy and may cause strange failures in the long run. If we do choose this alternative, it would be imperative that we also add a command to check the constraints after turning the constraint checking back on. And we would also have to have some type of warning if we were to allow turning off constraint checking outside the scope of a session.

### SQL Server

A different approach that would also not include deferring of constraints and would actually scope this project down significantly would be to follow SQL Server's rule that all cascading constraints must form a tree of tables and not a graph. So there can be no loop backs and does not allow self-referential tables. The self-referencing example above would no longer be valid.

However, in lieu of the deferring of constraints, it is commonly suggested that the use of common table expressions (CTE) should be used in its place.  And that they are sufficient when dealing with self-referencing or circular dependencies. CTEs are a significantly larger project than adding in deferrable constraints and thus it may be a long time before we are able to support those interesting by still rare cases.

## Unresolved questions

- Do we want to limit the amount of cascading?
- Should we implement deferring of constraints? When would be the right time to do so?
- Is there a reasonable use case for constraints from multiple tables that can't be covered with other constraints?
