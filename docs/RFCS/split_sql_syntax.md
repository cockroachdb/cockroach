- Feature Name: SQL Syntax for splitting tables
- Status: draft/in-progress/completed/rejected/obsolete
- Start Date: 2017-03-14
- Authors: Radu Berinde
- RFC PR: (PR # after acceptance of initial draft)
- Cockroach Issue: #13665

# Summary

This RFC proposes new syntax for introducing table splits via SQL.

# Motivation

The main motivation is to allow setting up tests, benchmarks, and reproducible
testbeds, especially for DistSQL. One set of some sample tests that we want to
be able to set up directly from logic tests are in
[TestDistSQLPlanner](https://github.com/cockroachdb/cockroach/blob/cc5ba57/pkg/sql/distsql_physical_planner_test.go#L75).
These tests need to split tables in a specific way, and they need to reprogram
the replicas and range leaders of each split.

The secondary motivation is for backup/restore, which needs to introduce a
specific set of key splits. Currently this is done by custom code which works as
follows: the keys are sorted; a split is introduced on the middle key, then
the splits to the left and respectively to the right are processed recursively
(in parallel). We want the new syntax to implement this algorithm so that
backup/restore can use it. Note that in this case, we already have the split keys
(as opposed to primary key values). In addition to backup/restore, there are
more usecases for pre-spliting ranges (for benchmarks, importing, etc).

We currently have the `ALTER TABLE/INDEX SPLIT AT` statement which allows
introducing a table or index split at specific column values. The main drawback
is that it cannot be used *programmatically*: each split must be in its own
statement; we cannot generate (e.g. via a `SELECT`) a set of values where to
split. We want to write tests like the one linked above without hardcoding each
split in the test file; and we want to be able to easily change the test table
sizes. In addition, the `SPLIT AT` statments don't support control of
replication.


# Detailed design

Three new pieces of SQL syntax are proposed.

### 1. `key_prefix` function ###

The `key_prefix` function is a function that takes a table name (optionally with
an index) and a set of column values for a prefix of the primary key (or index
columns) and returns the corresponding key (as `BYTES`). Example:

```sql
CREATE TABLE t (
  k1 INT,
  k2 INT,
  v INT,
  w INT,
  PRIMARY KEY(k1, k2),
  INDEX vw (v, w)
)

SELECT key_prefix('t', 1, 2)     -- returns /t/primary/1/2
SELECT key_prefix('db.t', 3)     -- returns /t/primary/3
SELECT key_prefix('t@vw', 4, 5)  -- returns /t/vw/4/5
SELECT key_prefix('t@vw', 1)     -- returns /t/vw/1
```

#### `pretty_key` function ####

For debugging/testing purposes, we will also need a `pretty_key` function that
takes a `BYTES` key generated by `key_prefix` and returns a pretty-printed string.

### 2. `KVSPLIT` statement ###

`KVSPLIT <select_clause>`

The `KVSPLIT` statement takes a select clause that produces a single column of
`BYTES` keys and executes the splits. Examples:

```sql
KVSPLIT VALUES ('..'), ('..')
KVSPLIT SELECT key_prefix('t', 1, 2)
KVSPLIT SELECT key_prefix('t', i*10) FROM GENERATE_SERIES(1, 5) AS x(i)
```

`KVSPLIT` is implemented as follows:
 - the input keys are sorted;
 - a split is performed of the middle key; recursively the left and right sets
   are split in parallel;
 - a queue or semaphore can be used to limit the amount of split operations that
   happen at the same time.

The order in which we perform splits matters for achieving parallelism: if we
execute the splits in order, we can only do one split at a time because every
split runs on an existing range.


### 3. `KVRELOCATE` statement ###

`KVRELOCATE <select_clause>`

The `KVRELOCATE` statement takes a select clause that returns two columns: a
`BYTES` key column, and a `STRING` relocation string. The string is a comma
separated list of node-ids; for each row, the range that contains the key is
reprogrammed to have replicas on the given nodes. The first node in the list
is made the lease holder. Examples:

```sql
KVRELOCATE VALUES ('..', '1'), ('..', '2,3')
KVRELOCATE SELECT key_prefix('t', 1, 2), '5,6,7'
KVRELOCATE SELECT key_prefix('t', i*10), (1+i%3)::STRING FROM GENERATE_SERIES(1, 5) AS x(i)
```

TODO: a better, more extensive format? more flexibility in specifying targets
(e.g. zones)?

TODO: a `KVINSPECT` statement (or some system table) that returns information
about the ranges between two keys?

## `SPLIT AT` ##

The `ALTER TABLE/INDEX SPLIT AT` functionality can be provided using the new
syntax. This variant can remain (perhaps temporarily) as an alias (though the
implementation would rely on the new code).

# Drawbacks

# Alternatives

One alternative considered was to also use a function for the splitting
functionality, e.g. `SELECT split_at(..)`. The problem is that it forces the
splits to happen sequentially; we cannot implement the algorithm mentioned above
(used by backup/restore). One way around this would be to introduce `split_at`
as an *aggregation* function (akin to `sum`).

An alternative to the `KVSPLIT/KVRELOCATE` statements is to insert in special
system "tables", which would trigger custom "insertion" code. This would be
functionally equivalent; the difference is mainly syntactic.

# Unresolved questions
