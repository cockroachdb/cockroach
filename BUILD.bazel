load("@bazel_gazelle//:def.bzl", "gazelle")

# The following directives inform gazelle how to auto-generate BUILD.bazel
# files throughout the repo. By including them here, we can run gazelle using
# `bazel run //:gazelle` instead of invoking gazelle directly.
#
# NB: Be sure to re-generate BUILD.bazel files if any of the directives below
# are changed.

# Define the gazelle prefix and what the autogenerated BUILD files should be
# named as.
#
# gazelle:prefix github.com/cockroachdb/cockroach
# gazelle:build_file_name BUILD.bazel

# We disable protobuf generation for our dependencies
#
# gazelle:proto disable_global

# Gazelle is unable to resolve this specific package.
#
# TODO(irfansharif): I'm not sure why this is. Is it because it's a proto only
# package?
#
# gazelle:resolve go github.com/grpc-ecosystem/grpc-gateway/internal //vendor/github.com/grpc-ecosystem/grpc-gateway/internal

# We exclude two of our C dependencies that are already bazel-ified, lest we
# overwrite those build files. We also ignore all checked-in autogenerated
# files (they'll get autogenerated on the fly through bazel).
#
# gazelle:exclude c-deps/googletest
# gazelle:exclude c-deps/protobuf
# gazelle:exclude **/zcgo_flags.go
# gazelle:exclude **/zcgo_flags_*.go
# gazelle:exclude **/*.og.go
# gazelle:exclude **/*.eg.go
# gazelle:exclude pkg/sql/parser/sql.go
# gazelle:exclude pkg/sql/opt/rule_name_string.go

# TODO(irfansharif): Today we let bazel take over the vendor directory and
# define each vendored dependency as a bazel target. We should be able to have
# bazel ignore all of vendor/ and create those dependencies on the fly.
# Deleting the vendor directory and running `bazel run //:gazelle` shows what
# that would look like (though that doesn't quite work yet).

# TODO(irfansharif): Document a few usage patterns for bazel and how to
# understand all the autogen stuff. Probably as a tech note. Here are a few
# short hands I've used so far:
#
#   bazel test //pkg/kv/kvserver/concurrency/...
#   bazel build //pkg/sql/opt
#   bazel build //pkg/sql/opt:all
#   bazel build //pkg/sql/colexec:gen-exec
#   bazel build //pkg/cmd/cockroach-short
#   bazel build //:libjemalloc
#   bazel query //pkg/sql/colexec:all
#   bazel run //:gazelle
#   bazel run //pkg/cmd/cockroach-short -- demo
#   bazel run //pkg/sql/opt/optgen/cmd/langgen -- -h
#   bazel run //:gazelle -- update-repos -from_file=go.mod -to_macro=DEPS.bzl%go_deps
#
# The //<stuff> names can also be fully qualified using @cockroach, and that
# appears in certain parts of the codebase/elsewhere. Specifically it'll look
# like:
#
#   bazel build @cockroach//pkg/cmd/cockroach-short
#
# TODO(irfansharif): We should probably define shorthands for the more common
# ones from up above.

# TODO(irfansharif): The way we currently generate code through bazel, that
# code is only available within the bazel sandbox. Bazel ignores all
# the pre-generated code that is already checked into the codebase (through
# `make generate`/etc.)through the exclude directives above. It's generating
# everything on the fly.
#
# As we move towards bazel, we'll want to introduce a mechanism that implants
# the generated code within the sandbox placing them "back into" the
# appropriate packages. This is to ensure we don't break existing IDEs and code
# editors which rely on files existing in the same package itself (as opposed
# to the sandbox). This way we could continue checking in auto-generated code.
# We should provide a bazel alternative for `make generate` that does this very
# same thing. See [1], this is a long standing issue for folks using using Go,
# bazel, and autogenerated code.
#
# [1]: https://github.com/bazelbuild/rules_go/issues/512.

gazelle(
    name = "gazelle",
    prefix = "github.com/cockroachdb/cockroach",
)

# Load the components that lets us use cmake/make in third party deps.
load("@rules_foreign_cc//tools/build_defs:cmake.bzl", "cmake_external")
load("@rules_foreign_cc//tools/build_defs:configure.bzl", "configure_make")

# TODO(irfansharif): All the cmake cache entries below were cargo-culted from
# the Makefile. We may need to programatically set them depending on the
# machine bazel is being run on. For now the only tested variant are Macbooks.

# Define the build target for libsnappy.
cmake_external(
    name = "libsnappy",
    cache_entries = {
        "CMAKE_BUILD_TYPE": "Release",
        "CMAKE_TARGET_MESSAGES": "OFF",
    },
    lib_source = "@snappy//:all",
    static_libraries = ["libsnappy.a"],
    visibility = ["//visibility:public"],
    alwayslink = True,
)

# Define the build target for libcryptopp.
cmake_external(
    name = "libcryptopp",
    cache_entries = {
        "CMAKE_BUILD_TYPE": "Release",
        "CMAKE_TARGET_MESSAGES": "OFF",
    },
    lib_source = "@cryptopp//:all",
    static_libraries = ["libcryptopp.a"],
    visibility = ["//visibility:public"],
)

# Define the build target for libjemalloc.
configure_make(
    name = "libjemalloc",
    autoconf = True,
    configure_env_vars = {
        "AR": "",
    },
    configure_in_place = True,
    configure_options = [
        "--enable-prof",
    ],
    lib_source = "@jemalloc//:all",
    make_commands = [
        "make build_lib_static",
        "mkdir -p libjemalloc/lib",
        "cp lib/libjemalloc.a libjemalloc/lib",
        "cp -r include libjemalloc",
    ],
    static_libraries = ["libjemalloc.a"],
    visibility = ["//visibility:public"],
)

# Define the build targets for libprotobuf and protoc.
cmake_external(
    name = "libprotobuf",
    binaries = ["protoc"],
    cache_entries = {
        "CMAKE_BUILD_TYPE": "Release",
        "CMAKE_TARGET_MESSAGES": "OFF",
        "protobuf_BUILD_TESTS": "OFF",
    },
    lib_source = "@protobuf//:all",
    static_libraries = ["libprotobuf.a"],
    visibility = ["//visibility:public"],
    working_directory = "cmake",
)

# Define the build target for libproj.
cmake_external(
    name = "libproj",
    cache_entries = {
        "CMAKE_BUILD_TYPE": "Release",
        "BUILD_LIBPROJ_SHARED": "OFF",
    },
    lib_source = "@proj//:all",
    static_libraries = ["libproj.a"],
    visibility = ["//visibility:public"],
)

# TODO(irfansharif): libgeos has not been worked out yet. We'll need to
# similarly ensure the lib/libgeos.so and lib/libegeos_c.so are in the right
# place.

# Define the build target for libroach. It depends on a few other libraries,
# which we list out in deps. It also depends on a few source trees to be
# checked out relative to the build directory, and we specify those through
# tools_deps. In our cmake cache entries, we point to where cmake should expect
# to find generated static library archives for its c-dependencies.
#
# Bazel also expects the library archive and the include headers to be placed
# in a certain path, so we fix it all up accordingly within make_commands.
cmake_external(
    name = "libroach",
    cache_entries = {
        "CMAKE_TARGET_MESSAGES": "OFF",
        "CMAKE_BUILD_TYPE": "Release",
        "CRYPTOPP_LIB": "$EXT_BUILD_DEPS/libcryptopp/lib/libcryptopp.a",
        "JEMALLOC_LIB": "$EXT_BUILD_DEPS/libjemalloc/lib/libjemalloc.a",
        "PROTOBUF_LIB": "$EXT_BUILD_DEPS/libprotobuf/lib/libprotobuf.a",
        "ROCKSDB_LIB": "$EXT_BUILD_DEPS/librocksdb/lib/librocksdb.a",
        "SNAPPY_LIB": "$EXT_BUILD_DEPS/libsnappy/lib/libsnappy.a",
    },
    lib_source = "@libroach//:all",
    make_commands = [
        "make roach",
        "mkdir -p libroach/lib",
        "cp libroach.a libroach/lib/libroach.a",
        "cp -r $EXT_BUILD_ROOT/external/libroach/include libroach",
    ],
    static_libraries = ["libroach.a"],
    tools_deps = [
        "@googletest//:all",
        "@rocksdb//:all",
        "@protobuf//:all",
        "@libroach//:all",
    ],
    visibility = ["//visibility:public"],
    deps = [
        ":libcryptopp",
        ":libjemalloc",
        ":libprotobuf",
        ":librocksdb",
        ":libsnappy",
    ],
)

# Define the build target for libroachccl. Look towards the definition for for
# libroach above to make sense of it.
cmake_external(
    name = "libroachccl",
    cache_entries = {
        "CMAKE_TARGET_MESSAGES": "OFF",
        "CMAKE_BUILD_TYPE": "Release",
        "CRYPTOPP_LIB": "$EXT_BUILD_DEPS/libcryptopp/lib/libcryptopp.a",
        "JEMALLOC_LIB": "$EXT_BUILD_DEPS/libjemalloc/lib/libjemalloc.a",
        "PROTOBUF_LIB": "$EXT_BUILD_DEPS/libprotobuf/lib/libprotobuf.a",
        "ROCKSDB_LIB": "$EXT_BUILD_DEPS/librocksdb/lib/librocksdb.a",
        "SNAPPY_LIB": "$EXT_BUILD_DEPS/libsnappy/lib/libsnappy.a",
    },
    lib_source = "@libroach//:all",
    make_commands = [
        "make roachccl",
        "mkdir -p libroachccl/lib",
        "cp libroachccl.a libroachccl/lib/libroachccl.a",
        "cp -r $EXT_BUILD_ROOT/external/libroach/ccl/include libroachccl",
    ],
    static_libraries = ["libroachccl.a"],
    tools_deps = [
        "@googletest//:all",
        "@rocksdb//:all",
        "@protobuf//:all",
        "@libroach//:all",
        "@cryptopp//:all",
    ],
    visibility = ["//visibility:public"],
    deps = [
        ":libcryptopp",
        ":libjemalloc",
        ":libprotobuf",
        ":librocksdb",
        ":libsnappy",
    ],
)

# Define the build target for librocksdb. Look towards the definition for for
# libroach above to make sense of it.
cmake_external(
    name = "librocksdb",
    cache_entries = {
        "CMAKE_TARGET_MESSAGES": "OFF",
        "WITH_GFLAGS": "OFF",
        "SNAPPY_LIBRARIES": "$EXT_BUILD_DEPS/libsnappy/lib/libsnappy.a",
        "SNAPPY_INCLUDE_DIR": "$EXT_BUILD_DEPS/libsnappy/include",
        "WITH_SNAPPY": "ON",
        "JEMALLOC_LIBRARIES": "$EXT_BUILD_DEPS/libjemalloc/lib/libjemalloc.a",
        "JEMALLOC_INCLUDE_DIR": "$EXT_BUILD_DEPS/libjemalloc/include",
        "WITH_JEMALLOC": "ON",
        "CMAKE_BUILD_TYPE": "Release",
        "USE_RTTI": "1",
        "FAIL_ON_WARNINGS": "0",
    },
    env_vars = {
        "CFLAGS": " -msse3",
        "CXXFLAGS": " -msse3",
        # TODO(irfansharif): We've had to tell the C++ toolchain to use a
        # different `ar` variant from the one it defaults to using. It's also
        # sufficient to tell it to use "/usr/bin/ar" instead. I've forgotten
        # why we needed this, and why the default doesn't work. The default
        # version doesn't support certain parameters that are used when running
        # cmake. Probably merits further digging.
        #
        # See https://docs.bazel.build/versions/master/be/make-variables.html.
        "AR": "",
    },
    lib_source = "@rocksdb//:all",
    make_commands = [
        "make rocksdb",
        "mkdir -p librocksdb/lib",
        "cp librocksdb.a librocksdb/lib/librocksdb.a",
        "cp -r $EXT_BUILD_ROOT/external/rocksdb/include librocksdb",
    ],
    static_libraries = ["librocksdb.a"],
    visibility = ["//visibility:public"],
    deps = [
        ":libjemalloc",
        ":libsnappy",
    ],
)

# Define the build target for kerberos.
#
# TODO(irfansharif): Kerboros is not used for anything other than Linux.
# The following has not been tested as yet.
configure_make(
    name = "libkrb5",
    autoreconf = True,
    configure_command = "src/configure",
    configure_env_vars = {
        "CPFLAGS": "",
        "CXXFLAGS": "",
    },
    configure_options = [
        "--enable-static",
        "--disable-shared",
    ] + select({
        "//conditions:default": ["AR=/usr/bin/ar"],
    }),
    lib_source = "@krb5//:all",
    make_commands = [
        "make",
        "mkdir -p libkrb5/lib",
        "cp libkrb5/libgssapi_krb5.a libkrb5/lib",
    ],
    static_libraries = ["libgssapi_krb5.a"],
    visibility = ["//visibility:public"],
)
