// Copyright 2020-2021 Buf Technologies, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Code generated by protoc-gen-twirp v8.1.0, DO NOT EDIT.
// source: buf/alpha/registry/v1alpha1/team.proto

package registryv1alpha1

import context "context"
import fmt "fmt"
import http "net/http"
import ioutil "io/ioutil"
import json "encoding/json"
import strconv "strconv"
import strings "strings"

import protojson "google.golang.org/protobuf/encoding/protojson"
import proto "google.golang.org/protobuf/proto"
import twirp "github.com/twitchtv/twirp"
import ctxsetters "github.com/twitchtv/twirp/ctxsetters"

// Version compatibility assertion.
// If the constant is not defined in the package, that likely means
// the package needs to be updated to work with this generated code.
// See https://twitchtv.github.io/twirp/docs/version_matrix.html
const _ = twirp.TwirpPackageMinVersion_8_1_0

// =====================
// TeamService Interface
// =====================

// TeamService is the Team service.
// All methods on the Team service require authentication.
type TeamService interface {
	// GetTeam gets a team by ID.
	GetTeam(context.Context, *GetTeamRequest) (*GetTeamResponse, error)

	// GetTeamByName gets a team by the combination of its name and organization.
	GetTeamByName(context.Context, *GetTeamByNameRequest) (*GetTeamByNameResponse, error)

	// ListOrganizationTeams lists all teams belonging to an organization.
	ListOrganizationTeams(context.Context, *ListOrganizationTeamsRequest) (*ListOrganizationTeamsResponse, error)

	// CreateTeam creates a new team within an organization.
	CreateTeam(context.Context, *CreateTeamRequest) (*CreateTeamResponse, error)

	// CreateTeamByName creates a new team within an organization, looking up the organization by name.
	CreateTeamByName(context.Context, *CreateTeamByNameRequest) (*CreateTeamByNameResponse, error)

	// UpdateTeamName updates a team's name.
	UpdateTeamName(context.Context, *UpdateTeamNameRequest) (*UpdateTeamNameResponse, error)

	// AddUserToTeam adds a user to a team by their respective IDs.
	AddUserToTeam(context.Context, *AddUserToTeamRequest) (*AddUserToTeamResponse, error)

	// AddUserToTeamByName adds a user to a team, looking up the entities by user, team, and organization names.
	AddUserToTeamByName(context.Context, *AddUserToTeamByNameRequest) (*AddUserToTeamByNameResponse, error)

	// RemoveUserFromTeam removes a user from a team by their respective IDs.
	RemoveUserFromTeam(context.Context, *RemoveUserFromTeamRequest) (*RemoveUserFromTeamResponse, error)

	// RemoveUserFromTeamByName removes a user from a team, looking up the entities by user, team, and organization names.
	RemoveUserFromTeamByName(context.Context, *RemoveUserFromTeamByNameRequest) (*RemoveUserFromTeamByNameResponse, error)

	// DeleteTeam deletes a team by ID.
	DeleteTeam(context.Context, *DeleteTeamRequest) (*DeleteTeamResponse, error)

	// DeleteTeamByName deletes a team by the combination of its name and organization.
	DeleteTeamByName(context.Context, *DeleteTeamByNameRequest) (*DeleteTeamByNameResponse, error)

	// AddTeamOrganizationScope adds an organization scope to a team by ID.
	AddTeamOrganizationScope(context.Context, *AddTeamOrganizationScopeRequest) (*AddTeamOrganizationScopeResponse, error)

	// AddTeamOrganizationScopeByName adds an organization scope to a team by name.
	AddTeamOrganizationScopeByName(context.Context, *AddTeamOrganizationScopeByNameRequest) (*AddTeamOrganizationScopeByNameResponse, error)

	// RemoveTeamOrganizationScope removes an organization scope from a team by ID.
	RemoveTeamOrganizationScope(context.Context, *RemoveTeamOrganizationScopeRequest) (*RemoveTeamOrganizationScopeResponse, error)

	// RemoveTeamOrganizationScopeByName removes an organization scope from a team by name.
	RemoveTeamOrganizationScopeByName(context.Context, *RemoveTeamOrganizationScopeByNameRequest) (*RemoveTeamOrganizationScopeByNameResponse, error)

	// AddTeamBaseRepositoryScope adds a base repository scope to a team by ID.
	AddTeamBaseRepositoryScope(context.Context, *AddTeamBaseRepositoryScopeRequest) (*AddTeamBaseRepositoryScopeResponse, error)

	// AddTeamBaseRepositoryScopeByName adds a base repository scope to a team by name.
	AddTeamBaseRepositoryScopeByName(context.Context, *AddTeamBaseRepositoryScopeByNameRequest) (*AddTeamBaseRepositoryScopeByNameResponse, error)

	// RemoveTeamBaseRepositoryScope removes a base repository scope from a team by ID.
	RemoveTeamBaseRepositoryScope(context.Context, *RemoveTeamBaseRepositoryScopeRequest) (*RemoveTeamBaseRepositoryScopeResponse, error)

	// RemoveTeamBaseRepositoryScopeByName removes a base repository scope from a team by name.
	RemoveTeamBaseRepositoryScopeByName(context.Context, *RemoveTeamBaseRepositoryScopeByNameRequest) (*RemoveTeamBaseRepositoryScopeByNameResponse, error)

	// AddTeamRepositoryScope adds a repository scope for a specific repository to a team by ID.
	AddTeamRepositoryScope(context.Context, *AddTeamRepositoryScopeRequest) (*AddTeamRepositoryScopeResponse, error)

	// AddTeamRepositoryScopeByName adds a repository scope for a specific repository to a team by name.
	AddTeamRepositoryScopeByName(context.Context, *AddTeamRepositoryScopeByNameRequest) (*AddTeamRepositoryScopeByNameResponse, error)

	// RemoveTeamRepositoryScope removes a repository scope for a specific repository from a team by ID.
	RemoveTeamRepositoryScope(context.Context, *RemoveTeamRepositoryScopeRequest) (*RemoveTeamRepositoryScopeResponse, error)

	// RemoveTeamRepositoryScopeByName removes a repository scope for a specific repository from a team by name.
	RemoveTeamRepositoryScopeByName(context.Context, *RemoveTeamRepositoryScopeByNameRequest) (*RemoveTeamRepositoryScopeByNameResponse, error)
}

// ===========================
// TeamService Protobuf Client
// ===========================

type teamServiceProtobufClient struct {
	client      HTTPClient
	urls        [24]string
	interceptor twirp.Interceptor
	opts        twirp.ClientOptions
}

// NewTeamServiceProtobufClient creates a Protobuf client that implements the TeamService interface.
// It communicates using Protobuf and can be configured with a custom HTTPClient.
func NewTeamServiceProtobufClient(baseURL string, client HTTPClient, opts ...twirp.ClientOption) TeamService {
	if c, ok := client.(*http.Client); ok {
		client = withoutRedirects(c)
	}

	clientOpts := twirp.ClientOptions{}
	for _, o := range opts {
		o(&clientOpts)
	}

	// Using ReadOpt allows backwards and forwads compatibility with new options in the future
	literalURLs := false
	_ = clientOpts.ReadOpt("literalURLs", &literalURLs)
	var pathPrefix string
	if ok := clientOpts.ReadOpt("pathPrefix", &pathPrefix); !ok {
		pathPrefix = "/twirp" // default prefix
	}

	// Build method URLs: <baseURL>[<prefix>]/<package>.<Service>/<Method>
	serviceURL := sanitizeBaseURL(baseURL)
	serviceURL += baseServicePath(pathPrefix, "buf.alpha.registry.v1alpha1", "TeamService")
	urls := [24]string{
		serviceURL + "GetTeam",
		serviceURL + "GetTeamByName",
		serviceURL + "ListOrganizationTeams",
		serviceURL + "CreateTeam",
		serviceURL + "CreateTeamByName",
		serviceURL + "UpdateTeamName",
		serviceURL + "AddUserToTeam",
		serviceURL + "AddUserToTeamByName",
		serviceURL + "RemoveUserFromTeam",
		serviceURL + "RemoveUserFromTeamByName",
		serviceURL + "DeleteTeam",
		serviceURL + "DeleteTeamByName",
		serviceURL + "AddTeamOrganizationScope",
		serviceURL + "AddTeamOrganizationScopeByName",
		serviceURL + "RemoveTeamOrganizationScope",
		serviceURL + "RemoveTeamOrganizationScopeByName",
		serviceURL + "AddTeamBaseRepositoryScope",
		serviceURL + "AddTeamBaseRepositoryScopeByName",
		serviceURL + "RemoveTeamBaseRepositoryScope",
		serviceURL + "RemoveTeamBaseRepositoryScopeByName",
		serviceURL + "AddTeamRepositoryScope",
		serviceURL + "AddTeamRepositoryScopeByName",
		serviceURL + "RemoveTeamRepositoryScope",
		serviceURL + "RemoveTeamRepositoryScopeByName",
	}

	return &teamServiceProtobufClient{
		client:      client,
		urls:        urls,
		interceptor: twirp.ChainInterceptors(clientOpts.Interceptors...),
		opts:        clientOpts,
	}
}

func (c *teamServiceProtobufClient) GetTeam(ctx context.Context, in *GetTeamRequest) (*GetTeamResponse, error) {
	ctx = ctxsetters.WithPackageName(ctx, "buf.alpha.registry.v1alpha1")
	ctx = ctxsetters.WithServiceName(ctx, "TeamService")
	ctx = ctxsetters.WithMethodName(ctx, "GetTeam")
	caller := c.callGetTeam
	if c.interceptor != nil {
		caller = func(ctx context.Context, req *GetTeamRequest) (*GetTeamResponse, error) {
			resp, err := c.interceptor(
				func(ctx context.Context, req interface{}) (interface{}, error) {
					typedReq, ok := req.(*GetTeamRequest)
					if !ok {
						return nil, twirp.InternalError("failed type assertion req.(*GetTeamRequest) when calling interceptor")
					}
					return c.callGetTeam(ctx, typedReq)
				},
			)(ctx, req)
			if resp != nil {
				typedResp, ok := resp.(*GetTeamResponse)
				if !ok {
					return nil, twirp.InternalError("failed type assertion resp.(*GetTeamResponse) when calling interceptor")
				}
				return typedResp, err
			}
			return nil, err
		}
	}
	return caller(ctx, in)
}

func (c *teamServiceProtobufClient) callGetTeam(ctx context.Context, in *GetTeamRequest) (*GetTeamResponse, error) {
	out := new(GetTeamResponse)
	ctx, err := doProtobufRequest(ctx, c.client, c.opts.Hooks, c.urls[0], in, out)
	if err != nil {
		twerr, ok := err.(twirp.Error)
		if !ok {
			twerr = twirp.InternalErrorWith(err)
		}
		callClientError(ctx, c.opts.Hooks, twerr)
		return nil, err
	}

	callClientResponseReceived(ctx, c.opts.Hooks)

	return out, nil
}

func (c *teamServiceProtobufClient) GetTeamByName(ctx context.Context, in *GetTeamByNameRequest) (*GetTeamByNameResponse, error) {
	ctx = ctxsetters.WithPackageName(ctx, "buf.alpha.registry.v1alpha1")
	ctx = ctxsetters.WithServiceName(ctx, "TeamService")
	ctx = ctxsetters.WithMethodName(ctx, "GetTeamByName")
	caller := c.callGetTeamByName
	if c.interceptor != nil {
		caller = func(ctx context.Context, req *GetTeamByNameRequest) (*GetTeamByNameResponse, error) {
			resp, err := c.interceptor(
				func(ctx context.Context, req interface{}) (interface{}, error) {
					typedReq, ok := req.(*GetTeamByNameRequest)
					if !ok {
						return nil, twirp.InternalError("failed type assertion req.(*GetTeamByNameRequest) when calling interceptor")
					}
					return c.callGetTeamByName(ctx, typedReq)
				},
			)(ctx, req)
			if resp != nil {
				typedResp, ok := resp.(*GetTeamByNameResponse)
				if !ok {
					return nil, twirp.InternalError("failed type assertion resp.(*GetTeamByNameResponse) when calling interceptor")
				}
				return typedResp, err
			}
			return nil, err
		}
	}
	return caller(ctx, in)
}

func (c *teamServiceProtobufClient) callGetTeamByName(ctx context.Context, in *GetTeamByNameRequest) (*GetTeamByNameResponse, error) {
	out := new(GetTeamByNameResponse)
	ctx, err := doProtobufRequest(ctx, c.client, c.opts.Hooks, c.urls[1], in, out)
	if err != nil {
		twerr, ok := err.(twirp.Error)
		if !ok {
			twerr = twirp.InternalErrorWith(err)
		}
		callClientError(ctx, c.opts.Hooks, twerr)
		return nil, err
	}

	callClientResponseReceived(ctx, c.opts.Hooks)

	return out, nil
}

func (c *teamServiceProtobufClient) ListOrganizationTeams(ctx context.Context, in *ListOrganizationTeamsRequest) (*ListOrganizationTeamsResponse, error) {
	ctx = ctxsetters.WithPackageName(ctx, "buf.alpha.registry.v1alpha1")
	ctx = ctxsetters.WithServiceName(ctx, "TeamService")
	ctx = ctxsetters.WithMethodName(ctx, "ListOrganizationTeams")
	caller := c.callListOrganizationTeams
	if c.interceptor != nil {
		caller = func(ctx context.Context, req *ListOrganizationTeamsRequest) (*ListOrganizationTeamsResponse, error) {
			resp, err := c.interceptor(
				func(ctx context.Context, req interface{}) (interface{}, error) {
					typedReq, ok := req.(*ListOrganizationTeamsRequest)
					if !ok {
						return nil, twirp.InternalError("failed type assertion req.(*ListOrganizationTeamsRequest) when calling interceptor")
					}
					return c.callListOrganizationTeams(ctx, typedReq)
				},
			)(ctx, req)
			if resp != nil {
				typedResp, ok := resp.(*ListOrganizationTeamsResponse)
				if !ok {
					return nil, twirp.InternalError("failed type assertion resp.(*ListOrganizationTeamsResponse) when calling interceptor")
				}
				return typedResp, err
			}
			return nil, err
		}
	}
	return caller(ctx, in)
}

func (c *teamServiceProtobufClient) callListOrganizationTeams(ctx context.Context, in *ListOrganizationTeamsRequest) (*ListOrganizationTeamsResponse, error) {
	out := new(ListOrganizationTeamsResponse)
	ctx, err := doProtobufRequest(ctx, c.client, c.opts.Hooks, c.urls[2], in, out)
	if err != nil {
		twerr, ok := err.(twirp.Error)
		if !ok {
			twerr = twirp.InternalErrorWith(err)
		}
		callClientError(ctx, c.opts.Hooks, twerr)
		return nil, err
	}

	callClientResponseReceived(ctx, c.opts.Hooks)

	return out, nil
}

func (c *teamServiceProtobufClient) CreateTeam(ctx context.Context, in *CreateTeamRequest) (*CreateTeamResponse, error) {
	ctx = ctxsetters.WithPackageName(ctx, "buf.alpha.registry.v1alpha1")
	ctx = ctxsetters.WithServiceName(ctx, "TeamService")
	ctx = ctxsetters.WithMethodName(ctx, "CreateTeam")
	caller := c.callCreateTeam
	if c.interceptor != nil {
		caller = func(ctx context.Context, req *CreateTeamRequest) (*CreateTeamResponse, error) {
			resp, err := c.interceptor(
				func(ctx context.Context, req interface{}) (interface{}, error) {
					typedReq, ok := req.(*CreateTeamRequest)
					if !ok {
						return nil, twirp.InternalError("failed type assertion req.(*CreateTeamRequest) when calling interceptor")
					}
					return c.callCreateTeam(ctx, typedReq)
				},
			)(ctx, req)
			if resp != nil {
				typedResp, ok := resp.(*CreateTeamResponse)
				if !ok {
					return nil, twirp.InternalError("failed type assertion resp.(*CreateTeamResponse) when calling interceptor")
				}
				return typedResp, err
			}
			return nil, err
		}
	}
	return caller(ctx, in)
}

func (c *teamServiceProtobufClient) callCreateTeam(ctx context.Context, in *CreateTeamRequest) (*CreateTeamResponse, error) {
	out := new(CreateTeamResponse)
	ctx, err := doProtobufRequest(ctx, c.client, c.opts.Hooks, c.urls[3], in, out)
	if err != nil {
		twerr, ok := err.(twirp.Error)
		if !ok {
			twerr = twirp.InternalErrorWith(err)
		}
		callClientError(ctx, c.opts.Hooks, twerr)
		return nil, err
	}

	callClientResponseReceived(ctx, c.opts.Hooks)

	return out, nil
}

func (c *teamServiceProtobufClient) CreateTeamByName(ctx context.Context, in *CreateTeamByNameRequest) (*CreateTeamByNameResponse, error) {
	ctx = ctxsetters.WithPackageName(ctx, "buf.alpha.registry.v1alpha1")
	ctx = ctxsetters.WithServiceName(ctx, "TeamService")
	ctx = ctxsetters.WithMethodName(ctx, "CreateTeamByName")
	caller := c.callCreateTeamByName
	if c.interceptor != nil {
		caller = func(ctx context.Context, req *CreateTeamByNameRequest) (*CreateTeamByNameResponse, error) {
			resp, err := c.interceptor(
				func(ctx context.Context, req interface{}) (interface{}, error) {
					typedReq, ok := req.(*CreateTeamByNameRequest)
					if !ok {
						return nil, twirp.InternalError("failed type assertion req.(*CreateTeamByNameRequest) when calling interceptor")
					}
					return c.callCreateTeamByName(ctx, typedReq)
				},
			)(ctx, req)
			if resp != nil {
				typedResp, ok := resp.(*CreateTeamByNameResponse)
				if !ok {
					return nil, twirp.InternalError("failed type assertion resp.(*CreateTeamByNameResponse) when calling interceptor")
				}
				return typedResp, err
			}
			return nil, err
		}
	}
	return caller(ctx, in)
}

func (c *teamServiceProtobufClient) callCreateTeamByName(ctx context.Context, in *CreateTeamByNameRequest) (*CreateTeamByNameResponse, error) {
	out := new(CreateTeamByNameResponse)
	ctx, err := doProtobufRequest(ctx, c.client, c.opts.Hooks, c.urls[4], in, out)
	if err != nil {
		twerr, ok := err.(twirp.Error)
		if !ok {
			twerr = twirp.InternalErrorWith(err)
		}
		callClientError(ctx, c.opts.Hooks, twerr)
		return nil, err
	}

	callClientResponseReceived(ctx, c.opts.Hooks)

	return out, nil
}

func (c *teamServiceProtobufClient) UpdateTeamName(ctx context.Context, in *UpdateTeamNameRequest) (*UpdateTeamNameResponse, error) {
	ctx = ctxsetters.WithPackageName(ctx, "buf.alpha.registry.v1alpha1")
	ctx = ctxsetters.WithServiceName(ctx, "TeamService")
	ctx = ctxsetters.WithMethodName(ctx, "UpdateTeamName")
	caller := c.callUpdateTeamName
	if c.interceptor != nil {
		caller = func(ctx context.Context, req *UpdateTeamNameRequest) (*UpdateTeamNameResponse, error) {
			resp, err := c.interceptor(
				func(ctx context.Context, req interface{}) (interface{}, error) {
					typedReq, ok := req.(*UpdateTeamNameRequest)
					if !ok {
						return nil, twirp.InternalError("failed type assertion req.(*UpdateTeamNameRequest) when calling interceptor")
					}
					return c.callUpdateTeamName(ctx, typedReq)
				},
			)(ctx, req)
			if resp != nil {
				typedResp, ok := resp.(*UpdateTeamNameResponse)
				if !ok {
					return nil, twirp.InternalError("failed type assertion resp.(*UpdateTeamNameResponse) when calling interceptor")
				}
				return typedResp, err
			}
			return nil, err
		}
	}
	return caller(ctx, in)
}

func (c *teamServiceProtobufClient) callUpdateTeamName(ctx context.Context, in *UpdateTeamNameRequest) (*UpdateTeamNameResponse, error) {
	out := new(UpdateTeamNameResponse)
	ctx, err := doProtobufRequest(ctx, c.client, c.opts.Hooks, c.urls[5], in, out)
	if err != nil {
		twerr, ok := err.(twirp.Error)
		if !ok {
			twerr = twirp.InternalErrorWith(err)
		}
		callClientError(ctx, c.opts.Hooks, twerr)
		return nil, err
	}

	callClientResponseReceived(ctx, c.opts.Hooks)

	return out, nil
}

func (c *teamServiceProtobufClient) AddUserToTeam(ctx context.Context, in *AddUserToTeamRequest) (*AddUserToTeamResponse, error) {
	ctx = ctxsetters.WithPackageName(ctx, "buf.alpha.registry.v1alpha1")
	ctx = ctxsetters.WithServiceName(ctx, "TeamService")
	ctx = ctxsetters.WithMethodName(ctx, "AddUserToTeam")
	caller := c.callAddUserToTeam
	if c.interceptor != nil {
		caller = func(ctx context.Context, req *AddUserToTeamRequest) (*AddUserToTeamResponse, error) {
			resp, err := c.interceptor(
				func(ctx context.Context, req interface{}) (interface{}, error) {
					typedReq, ok := req.(*AddUserToTeamRequest)
					if !ok {
						return nil, twirp.InternalError("failed type assertion req.(*AddUserToTeamRequest) when calling interceptor")
					}
					return c.callAddUserToTeam(ctx, typedReq)
				},
			)(ctx, req)
			if resp != nil {
				typedResp, ok := resp.(*AddUserToTeamResponse)
				if !ok {
					return nil, twirp.InternalError("failed type assertion resp.(*AddUserToTeamResponse) when calling interceptor")
				}
				return typedResp, err
			}
			return nil, err
		}
	}
	return caller(ctx, in)
}

func (c *teamServiceProtobufClient) callAddUserToTeam(ctx context.Context, in *AddUserToTeamRequest) (*AddUserToTeamResponse, error) {
	out := new(AddUserToTeamResponse)
	ctx, err := doProtobufRequest(ctx, c.client, c.opts.Hooks, c.urls[6], in, out)
	if err != nil {
		twerr, ok := err.(twirp.Error)
		if !ok {
			twerr = twirp.InternalErrorWith(err)
		}
		callClientError(ctx, c.opts.Hooks, twerr)
		return nil, err
	}

	callClientResponseReceived(ctx, c.opts.Hooks)

	return out, nil
}

func (c *teamServiceProtobufClient) AddUserToTeamByName(ctx context.Context, in *AddUserToTeamByNameRequest) (*AddUserToTeamByNameResponse, error) {
	ctx = ctxsetters.WithPackageName(ctx, "buf.alpha.registry.v1alpha1")
	ctx = ctxsetters.WithServiceName(ctx, "TeamService")
	ctx = ctxsetters.WithMethodName(ctx, "AddUserToTeamByName")
	caller := c.callAddUserToTeamByName
	if c.interceptor != nil {
		caller = func(ctx context.Context, req *AddUserToTeamByNameRequest) (*AddUserToTeamByNameResponse, error) {
			resp, err := c.interceptor(
				func(ctx context.Context, req interface{}) (interface{}, error) {
					typedReq, ok := req.(*AddUserToTeamByNameRequest)
					if !ok {
						return nil, twirp.InternalError("failed type assertion req.(*AddUserToTeamByNameRequest) when calling interceptor")
					}
					return c.callAddUserToTeamByName(ctx, typedReq)
				},
			)(ctx, req)
			if resp != nil {
				typedResp, ok := resp.(*AddUserToTeamByNameResponse)
				if !ok {
					return nil, twirp.InternalError("failed type assertion resp.(*AddUserToTeamByNameResponse) when calling interceptor")
				}
				return typedResp, err
			}
			return nil, err
		}
	}
	return caller(ctx, in)
}

func (c *teamServiceProtobufClient) callAddUserToTeamByName(ctx context.Context, in *AddUserToTeamByNameRequest) (*AddUserToTeamByNameResponse, error) {
	out := new(AddUserToTeamByNameResponse)
	ctx, err := doProtobufRequest(ctx, c.client, c.opts.Hooks, c.urls[7], in, out)
	if err != nil {
		twerr, ok := err.(twirp.Error)
		if !ok {
			twerr = twirp.InternalErrorWith(err)
		}
		callClientError(ctx, c.opts.Hooks, twerr)
		return nil, err
	}

	callClientResponseReceived(ctx, c.opts.Hooks)

	return out, nil
}

func (c *teamServiceProtobufClient) RemoveUserFromTeam(ctx context.Context, in *RemoveUserFromTeamRequest) (*RemoveUserFromTeamResponse, error) {
	ctx = ctxsetters.WithPackageName(ctx, "buf.alpha.registry.v1alpha1")
	ctx = ctxsetters.WithServiceName(ctx, "TeamService")
	ctx = ctxsetters.WithMethodName(ctx, "RemoveUserFromTeam")
	caller := c.callRemoveUserFromTeam
	if c.interceptor != nil {
		caller = func(ctx context.Context, req *RemoveUserFromTeamRequest) (*RemoveUserFromTeamResponse, error) {
			resp, err := c.interceptor(
				func(ctx context.Context, req interface{}) (interface{}, error) {
					typedReq, ok := req.(*RemoveUserFromTeamRequest)
					if !ok {
						return nil, twirp.InternalError("failed type assertion req.(*RemoveUserFromTeamRequest) when calling interceptor")
					}
					return c.callRemoveUserFromTeam(ctx, typedReq)
				},
			)(ctx, req)
			if resp != nil {
				typedResp, ok := resp.(*RemoveUserFromTeamResponse)
				if !ok {
					return nil, twirp.InternalError("failed type assertion resp.(*RemoveUserFromTeamResponse) when calling interceptor")
				}
				return typedResp, err
			}
			return nil, err
		}
	}
	return caller(ctx, in)
}

func (c *teamServiceProtobufClient) callRemoveUserFromTeam(ctx context.Context, in *RemoveUserFromTeamRequest) (*RemoveUserFromTeamResponse, error) {
	out := new(RemoveUserFromTeamResponse)
	ctx, err := doProtobufRequest(ctx, c.client, c.opts.Hooks, c.urls[8], in, out)
	if err != nil {
		twerr, ok := err.(twirp.Error)
		if !ok {
			twerr = twirp.InternalErrorWith(err)
		}
		callClientError(ctx, c.opts.Hooks, twerr)
		return nil, err
	}

	callClientResponseReceived(ctx, c.opts.Hooks)

	return out, nil
}

func (c *teamServiceProtobufClient) RemoveUserFromTeamByName(ctx context.Context, in *RemoveUserFromTeamByNameRequest) (*RemoveUserFromTeamByNameResponse, error) {
	ctx = ctxsetters.WithPackageName(ctx, "buf.alpha.registry.v1alpha1")
	ctx = ctxsetters.WithServiceName(ctx, "TeamService")
	ctx = ctxsetters.WithMethodName(ctx, "RemoveUserFromTeamByName")
	caller := c.callRemoveUserFromTeamByName
	if c.interceptor != nil {
		caller = func(ctx context.Context, req *RemoveUserFromTeamByNameRequest) (*RemoveUserFromTeamByNameResponse, error) {
			resp, err := c.interceptor(
				func(ctx context.Context, req interface{}) (interface{}, error) {
					typedReq, ok := req.(*RemoveUserFromTeamByNameRequest)
					if !ok {
						return nil, twirp.InternalError("failed type assertion req.(*RemoveUserFromTeamByNameRequest) when calling interceptor")
					}
					return c.callRemoveUserFromTeamByName(ctx, typedReq)
				},
			)(ctx, req)
			if resp != nil {
				typedResp, ok := resp.(*RemoveUserFromTeamByNameResponse)
				if !ok {
					return nil, twirp.InternalError("failed type assertion resp.(*RemoveUserFromTeamByNameResponse) when calling interceptor")
				}
				return typedResp, err
			}
			return nil, err
		}
	}
	return caller(ctx, in)
}

func (c *teamServiceProtobufClient) callRemoveUserFromTeamByName(ctx context.Context, in *RemoveUserFromTeamByNameRequest) (*RemoveUserFromTeamByNameResponse, error) {
	out := new(RemoveUserFromTeamByNameResponse)
	ctx, err := doProtobufRequest(ctx, c.client, c.opts.Hooks, c.urls[9], in, out)
	if err != nil {
		twerr, ok := err.(twirp.Error)
		if !ok {
			twerr = twirp.InternalErrorWith(err)
		}
		callClientError(ctx, c.opts.Hooks, twerr)
		return nil, err
	}

	callClientResponseReceived(ctx, c.opts.Hooks)

	return out, nil
}

func (c *teamServiceProtobufClient) DeleteTeam(ctx context.Context, in *DeleteTeamRequest) (*DeleteTeamResponse, error) {
	ctx = ctxsetters.WithPackageName(ctx, "buf.alpha.registry.v1alpha1")
	ctx = ctxsetters.WithServiceName(ctx, "TeamService")
	ctx = ctxsetters.WithMethodName(ctx, "DeleteTeam")
	caller := c.callDeleteTeam
	if c.interceptor != nil {
		caller = func(ctx context.Context, req *DeleteTeamRequest) (*DeleteTeamResponse, error) {
			resp, err := c.interceptor(
				func(ctx context.Context, req interface{}) (interface{}, error) {
					typedReq, ok := req.(*DeleteTeamRequest)
					if !ok {
						return nil, twirp.InternalError("failed type assertion req.(*DeleteTeamRequest) when calling interceptor")
					}
					return c.callDeleteTeam(ctx, typedReq)
				},
			)(ctx, req)
			if resp != nil {
				typedResp, ok := resp.(*DeleteTeamResponse)
				if !ok {
					return nil, twirp.InternalError("failed type assertion resp.(*DeleteTeamResponse) when calling interceptor")
				}
				return typedResp, err
			}
			return nil, err
		}
	}
	return caller(ctx, in)
}

func (c *teamServiceProtobufClient) callDeleteTeam(ctx context.Context, in *DeleteTeamRequest) (*DeleteTeamResponse, error) {
	out := new(DeleteTeamResponse)
	ctx, err := doProtobufRequest(ctx, c.client, c.opts.Hooks, c.urls[10], in, out)
	if err != nil {
		twerr, ok := err.(twirp.Error)
		if !ok {
			twerr = twirp.InternalErrorWith(err)
		}
		callClientError(ctx, c.opts.Hooks, twerr)
		return nil, err
	}

	callClientResponseReceived(ctx, c.opts.Hooks)

	return out, nil
}

func (c *teamServiceProtobufClient) DeleteTeamByName(ctx context.Context, in *DeleteTeamByNameRequest) (*DeleteTeamByNameResponse, error) {
	ctx = ctxsetters.WithPackageName(ctx, "buf.alpha.registry.v1alpha1")
	ctx = ctxsetters.WithServiceName(ctx, "TeamService")
	ctx = ctxsetters.WithMethodName(ctx, "DeleteTeamByName")
	caller := c.callDeleteTeamByName
	if c.interceptor != nil {
		caller = func(ctx context.Context, req *DeleteTeamByNameRequest) (*DeleteTeamByNameResponse, error) {
			resp, err := c.interceptor(
				func(ctx context.Context, req interface{}) (interface{}, error) {
					typedReq, ok := req.(*DeleteTeamByNameRequest)
					if !ok {
						return nil, twirp.InternalError("failed type assertion req.(*DeleteTeamByNameRequest) when calling interceptor")
					}
					return c.callDeleteTeamByName(ctx, typedReq)
				},
			)(ctx, req)
			if resp != nil {
				typedResp, ok := resp.(*DeleteTeamByNameResponse)
				if !ok {
					return nil, twirp.InternalError("failed type assertion resp.(*DeleteTeamByNameResponse) when calling interceptor")
				}
				return typedResp, err
			}
			return nil, err
		}
	}
	return caller(ctx, in)
}

func (c *teamServiceProtobufClient) callDeleteTeamByName(ctx context.Context, in *DeleteTeamByNameRequest) (*DeleteTeamByNameResponse, error) {
	out := new(DeleteTeamByNameResponse)
	ctx, err := doProtobufRequest(ctx, c.client, c.opts.Hooks, c.urls[11], in, out)
	if err != nil {
		twerr, ok := err.(twirp.Error)
		if !ok {
			twerr = twirp.InternalErrorWith(err)
		}
		callClientError(ctx, c.opts.Hooks, twerr)
		return nil, err
	}

	callClientResponseReceived(ctx, c.opts.Hooks)

	return out, nil
}

func (c *teamServiceProtobufClient) AddTeamOrganizationScope(ctx context.Context, in *AddTeamOrganizationScopeRequest) (*AddTeamOrganizationScopeResponse, error) {
	ctx = ctxsetters.WithPackageName(ctx, "buf.alpha.registry.v1alpha1")
	ctx = ctxsetters.WithServiceName(ctx, "TeamService")
	ctx = ctxsetters.WithMethodName(ctx, "AddTeamOrganizationScope")
	caller := c.callAddTeamOrganizationScope
	if c.interceptor != nil {
		caller = func(ctx context.Context, req *AddTeamOrganizationScopeRequest) (*AddTeamOrganizationScopeResponse, error) {
			resp, err := c.interceptor(
				func(ctx context.Context, req interface{}) (interface{}, error) {
					typedReq, ok := req.(*AddTeamOrganizationScopeRequest)
					if !ok {
						return nil, twirp.InternalError("failed type assertion req.(*AddTeamOrganizationScopeRequest) when calling interceptor")
					}
					return c.callAddTeamOrganizationScope(ctx, typedReq)
				},
			)(ctx, req)
			if resp != nil {
				typedResp, ok := resp.(*AddTeamOrganizationScopeResponse)
				if !ok {
					return nil, twirp.InternalError("failed type assertion resp.(*AddTeamOrganizationScopeResponse) when calling interceptor")
				}
				return typedResp, err
			}
			return nil, err
		}
	}
	return caller(ctx, in)
}

func (c *teamServiceProtobufClient) callAddTeamOrganizationScope(ctx context.Context, in *AddTeamOrganizationScopeRequest) (*AddTeamOrganizationScopeResponse, error) {
	out := new(AddTeamOrganizationScopeResponse)
	ctx, err := doProtobufRequest(ctx, c.client, c.opts.Hooks, c.urls[12], in, out)
	if err != nil {
		twerr, ok := err.(twirp.Error)
		if !ok {
			twerr = twirp.InternalErrorWith(err)
		}
		callClientError(ctx, c.opts.Hooks, twerr)
		return nil, err
	}

	callClientResponseReceived(ctx, c.opts.Hooks)

	return out, nil
}

func (c *teamServiceProtobufClient) AddTeamOrganizationScopeByName(ctx context.Context, in *AddTeamOrganizationScopeByNameRequest) (*AddTeamOrganizationScopeByNameResponse, error) {
	ctx = ctxsetters.WithPackageName(ctx, "buf.alpha.registry.v1alpha1")
	ctx = ctxsetters.WithServiceName(ctx, "TeamService")
	ctx = ctxsetters.WithMethodName(ctx, "AddTeamOrganizationScopeByName")
	caller := c.callAddTeamOrganizationScopeByName
	if c.interceptor != nil {
		caller = func(ctx context.Context, req *AddTeamOrganizationScopeByNameRequest) (*AddTeamOrganizationScopeByNameResponse, error) {
			resp, err := c.interceptor(
				func(ctx context.Context, req interface{}) (interface{}, error) {
					typedReq, ok := req.(*AddTeamOrganizationScopeByNameRequest)
					if !ok {
						return nil, twirp.InternalError("failed type assertion req.(*AddTeamOrganizationScopeByNameRequest) when calling interceptor")
					}
					return c.callAddTeamOrganizationScopeByName(ctx, typedReq)
				},
			)(ctx, req)
			if resp != nil {
				typedResp, ok := resp.(*AddTeamOrganizationScopeByNameResponse)
				if !ok {
					return nil, twirp.InternalError("failed type assertion resp.(*AddTeamOrganizationScopeByNameResponse) when calling interceptor")
				}
				return typedResp, err
			}
			return nil, err
		}
	}
	return caller(ctx, in)
}

func (c *teamServiceProtobufClient) callAddTeamOrganizationScopeByName(ctx context.Context, in *AddTeamOrganizationScopeByNameRequest) (*AddTeamOrganizationScopeByNameResponse, error) {
	out := new(AddTeamOrganizationScopeByNameResponse)
	ctx, err := doProtobufRequest(ctx, c.client, c.opts.Hooks, c.urls[13], in, out)
	if err != nil {
		twerr, ok := err.(twirp.Error)
		if !ok {
			twerr = twirp.InternalErrorWith(err)
		}
		callClientError(ctx, c.opts.Hooks, twerr)
		return nil, err
	}

	callClientResponseReceived(ctx, c.opts.Hooks)

	return out, nil
}

func (c *teamServiceProtobufClient) RemoveTeamOrganizationScope(ctx context.Context, in *RemoveTeamOrganizationScopeRequest) (*RemoveTeamOrganizationScopeResponse, error) {
	ctx = ctxsetters.WithPackageName(ctx, "buf.alpha.registry.v1alpha1")
	ctx = ctxsetters.WithServiceName(ctx, "TeamService")
	ctx = ctxsetters.WithMethodName(ctx, "RemoveTeamOrganizationScope")
	caller := c.callRemoveTeamOrganizationScope
	if c.interceptor != nil {
		caller = func(ctx context.Context, req *RemoveTeamOrganizationScopeRequest) (*RemoveTeamOrganizationScopeResponse, error) {
			resp, err := c.interceptor(
				func(ctx context.Context, req interface{}) (interface{}, error) {
					typedReq, ok := req.(*RemoveTeamOrganizationScopeRequest)
					if !ok {
						return nil, twirp.InternalError("failed type assertion req.(*RemoveTeamOrganizationScopeRequest) when calling interceptor")
					}
					return c.callRemoveTeamOrganizationScope(ctx, typedReq)
				},
			)(ctx, req)
			if resp != nil {
				typedResp, ok := resp.(*RemoveTeamOrganizationScopeResponse)
				if !ok {
					return nil, twirp.InternalError("failed type assertion resp.(*RemoveTeamOrganizationScopeResponse) when calling interceptor")
				}
				return typedResp, err
			}
			return nil, err
		}
	}
	return caller(ctx, in)
}

func (c *teamServiceProtobufClient) callRemoveTeamOrganizationScope(ctx context.Context, in *RemoveTeamOrganizationScopeRequest) (*RemoveTeamOrganizationScopeResponse, error) {
	out := new(RemoveTeamOrganizationScopeResponse)
	ctx, err := doProtobufRequest(ctx, c.client, c.opts.Hooks, c.urls[14], in, out)
	if err != nil {
		twerr, ok := err.(twirp.Error)
		if !ok {
			twerr = twirp.InternalErrorWith(err)
		}
		callClientError(ctx, c.opts.Hooks, twerr)
		return nil, err
	}

	callClientResponseReceived(ctx, c.opts.Hooks)

	return out, nil
}

func (c *teamServiceProtobufClient) RemoveTeamOrganizationScopeByName(ctx context.Context, in *RemoveTeamOrganizationScopeByNameRequest) (*RemoveTeamOrganizationScopeByNameResponse, error) {
	ctx = ctxsetters.WithPackageName(ctx, "buf.alpha.registry.v1alpha1")
	ctx = ctxsetters.WithServiceName(ctx, "TeamService")
	ctx = ctxsetters.WithMethodName(ctx, "RemoveTeamOrganizationScopeByName")
	caller := c.callRemoveTeamOrganizationScopeByName
	if c.interceptor != nil {
		caller = func(ctx context.Context, req *RemoveTeamOrganizationScopeByNameRequest) (*RemoveTeamOrganizationScopeByNameResponse, error) {
			resp, err := c.interceptor(
				func(ctx context.Context, req interface{}) (interface{}, error) {
					typedReq, ok := req.(*RemoveTeamOrganizationScopeByNameRequest)
					if !ok {
						return nil, twirp.InternalError("failed type assertion req.(*RemoveTeamOrganizationScopeByNameRequest) when calling interceptor")
					}
					return c.callRemoveTeamOrganizationScopeByName(ctx, typedReq)
				},
			)(ctx, req)
			if resp != nil {
				typedResp, ok := resp.(*RemoveTeamOrganizationScopeByNameResponse)
				if !ok {
					return nil, twirp.InternalError("failed type assertion resp.(*RemoveTeamOrganizationScopeByNameResponse) when calling interceptor")
				}
				return typedResp, err
			}
			return nil, err
		}
	}
	return caller(ctx, in)
}

func (c *teamServiceProtobufClient) callRemoveTeamOrganizationScopeByName(ctx context.Context, in *RemoveTeamOrganizationScopeByNameRequest) (*RemoveTeamOrganizationScopeByNameResponse, error) {
	out := new(RemoveTeamOrganizationScopeByNameResponse)
	ctx, err := doProtobufRequest(ctx, c.client, c.opts.Hooks, c.urls[15], in, out)
	if err != nil {
		twerr, ok := err.(twirp.Error)
		if !ok {
			twerr = twirp.InternalErrorWith(err)
		}
		callClientError(ctx, c.opts.Hooks, twerr)
		return nil, err
	}

	callClientResponseReceived(ctx, c.opts.Hooks)

	return out, nil
}

func (c *teamServiceProtobufClient) AddTeamBaseRepositoryScope(ctx context.Context, in *AddTeamBaseRepositoryScopeRequest) (*AddTeamBaseRepositoryScopeResponse, error) {
	ctx = ctxsetters.WithPackageName(ctx, "buf.alpha.registry.v1alpha1")
	ctx = ctxsetters.WithServiceName(ctx, "TeamService")
	ctx = ctxsetters.WithMethodName(ctx, "AddTeamBaseRepositoryScope")
	caller := c.callAddTeamBaseRepositoryScope
	if c.interceptor != nil {
		caller = func(ctx context.Context, req *AddTeamBaseRepositoryScopeRequest) (*AddTeamBaseRepositoryScopeResponse, error) {
			resp, err := c.interceptor(
				func(ctx context.Context, req interface{}) (interface{}, error) {
					typedReq, ok := req.(*AddTeamBaseRepositoryScopeRequest)
					if !ok {
						return nil, twirp.InternalError("failed type assertion req.(*AddTeamBaseRepositoryScopeRequest) when calling interceptor")
					}
					return c.callAddTeamBaseRepositoryScope(ctx, typedReq)
				},
			)(ctx, req)
			if resp != nil {
				typedResp, ok := resp.(*AddTeamBaseRepositoryScopeResponse)
				if !ok {
					return nil, twirp.InternalError("failed type assertion resp.(*AddTeamBaseRepositoryScopeResponse) when calling interceptor")
				}
				return typedResp, err
			}
			return nil, err
		}
	}
	return caller(ctx, in)
}

func (c *teamServiceProtobufClient) callAddTeamBaseRepositoryScope(ctx context.Context, in *AddTeamBaseRepositoryScopeRequest) (*AddTeamBaseRepositoryScopeResponse, error) {
	out := new(AddTeamBaseRepositoryScopeResponse)
	ctx, err := doProtobufRequest(ctx, c.client, c.opts.Hooks, c.urls[16], in, out)
	if err != nil {
		twerr, ok := err.(twirp.Error)
		if !ok {
			twerr = twirp.InternalErrorWith(err)
		}
		callClientError(ctx, c.opts.Hooks, twerr)
		return nil, err
	}

	callClientResponseReceived(ctx, c.opts.Hooks)

	return out, nil
}

func (c *teamServiceProtobufClient) AddTeamBaseRepositoryScopeByName(ctx context.Context, in *AddTeamBaseRepositoryScopeByNameRequest) (*AddTeamBaseRepositoryScopeByNameResponse, error) {
	ctx = ctxsetters.WithPackageName(ctx, "buf.alpha.registry.v1alpha1")
	ctx = ctxsetters.WithServiceName(ctx, "TeamService")
	ctx = ctxsetters.WithMethodName(ctx, "AddTeamBaseRepositoryScopeByName")
	caller := c.callAddTeamBaseRepositoryScopeByName
	if c.interceptor != nil {
		caller = func(ctx context.Context, req *AddTeamBaseRepositoryScopeByNameRequest) (*AddTeamBaseRepositoryScopeByNameResponse, error) {
			resp, err := c.interceptor(
				func(ctx context.Context, req interface{}) (interface{}, error) {
					typedReq, ok := req.(*AddTeamBaseRepositoryScopeByNameRequest)
					if !ok {
						return nil, twirp.InternalError("failed type assertion req.(*AddTeamBaseRepositoryScopeByNameRequest) when calling interceptor")
					}
					return c.callAddTeamBaseRepositoryScopeByName(ctx, typedReq)
				},
			)(ctx, req)
			if resp != nil {
				typedResp, ok := resp.(*AddTeamBaseRepositoryScopeByNameResponse)
				if !ok {
					return nil, twirp.InternalError("failed type assertion resp.(*AddTeamBaseRepositoryScopeByNameResponse) when calling interceptor")
				}
				return typedResp, err
			}
			return nil, err
		}
	}
	return caller(ctx, in)
}

func (c *teamServiceProtobufClient) callAddTeamBaseRepositoryScopeByName(ctx context.Context, in *AddTeamBaseRepositoryScopeByNameRequest) (*AddTeamBaseRepositoryScopeByNameResponse, error) {
	out := new(AddTeamBaseRepositoryScopeByNameResponse)
	ctx, err := doProtobufRequest(ctx, c.client, c.opts.Hooks, c.urls[17], in, out)
	if err != nil {
		twerr, ok := err.(twirp.Error)
		if !ok {
			twerr = twirp.InternalErrorWith(err)
		}
		callClientError(ctx, c.opts.Hooks, twerr)
		return nil, err
	}

	callClientResponseReceived(ctx, c.opts.Hooks)

	return out, nil
}

func (c *teamServiceProtobufClient) RemoveTeamBaseRepositoryScope(ctx context.Context, in *RemoveTeamBaseRepositoryScopeRequest) (*RemoveTeamBaseRepositoryScopeResponse, error) {
	ctx = ctxsetters.WithPackageName(ctx, "buf.alpha.registry.v1alpha1")
	ctx = ctxsetters.WithServiceName(ctx, "TeamService")
	ctx = ctxsetters.WithMethodName(ctx, "RemoveTeamBaseRepositoryScope")
	caller := c.callRemoveTeamBaseRepositoryScope
	if c.interceptor != nil {
		caller = func(ctx context.Context, req *RemoveTeamBaseRepositoryScopeRequest) (*RemoveTeamBaseRepositoryScopeResponse, error) {
			resp, err := c.interceptor(
				func(ctx context.Context, req interface{}) (interface{}, error) {
					typedReq, ok := req.(*RemoveTeamBaseRepositoryScopeRequest)
					if !ok {
						return nil, twirp.InternalError("failed type assertion req.(*RemoveTeamBaseRepositoryScopeRequest) when calling interceptor")
					}
					return c.callRemoveTeamBaseRepositoryScope(ctx, typedReq)
				},
			)(ctx, req)
			if resp != nil {
				typedResp, ok := resp.(*RemoveTeamBaseRepositoryScopeResponse)
				if !ok {
					return nil, twirp.InternalError("failed type assertion resp.(*RemoveTeamBaseRepositoryScopeResponse) when calling interceptor")
				}
				return typedResp, err
			}
			return nil, err
		}
	}
	return caller(ctx, in)
}

func (c *teamServiceProtobufClient) callRemoveTeamBaseRepositoryScope(ctx context.Context, in *RemoveTeamBaseRepositoryScopeRequest) (*RemoveTeamBaseRepositoryScopeResponse, error) {
	out := new(RemoveTeamBaseRepositoryScopeResponse)
	ctx, err := doProtobufRequest(ctx, c.client, c.opts.Hooks, c.urls[18], in, out)
	if err != nil {
		twerr, ok := err.(twirp.Error)
		if !ok {
			twerr = twirp.InternalErrorWith(err)
		}
		callClientError(ctx, c.opts.Hooks, twerr)
		return nil, err
	}

	callClientResponseReceived(ctx, c.opts.Hooks)

	return out, nil
}

func (c *teamServiceProtobufClient) RemoveTeamBaseRepositoryScopeByName(ctx context.Context, in *RemoveTeamBaseRepositoryScopeByNameRequest) (*RemoveTeamBaseRepositoryScopeByNameResponse, error) {
	ctx = ctxsetters.WithPackageName(ctx, "buf.alpha.registry.v1alpha1")
	ctx = ctxsetters.WithServiceName(ctx, "TeamService")
	ctx = ctxsetters.WithMethodName(ctx, "RemoveTeamBaseRepositoryScopeByName")
	caller := c.callRemoveTeamBaseRepositoryScopeByName
	if c.interceptor != nil {
		caller = func(ctx context.Context, req *RemoveTeamBaseRepositoryScopeByNameRequest) (*RemoveTeamBaseRepositoryScopeByNameResponse, error) {
			resp, err := c.interceptor(
				func(ctx context.Context, req interface{}) (interface{}, error) {
					typedReq, ok := req.(*RemoveTeamBaseRepositoryScopeByNameRequest)
					if !ok {
						return nil, twirp.InternalError("failed type assertion req.(*RemoveTeamBaseRepositoryScopeByNameRequest) when calling interceptor")
					}
					return c.callRemoveTeamBaseRepositoryScopeByName(ctx, typedReq)
				},
			)(ctx, req)
			if resp != nil {
				typedResp, ok := resp.(*RemoveTeamBaseRepositoryScopeByNameResponse)
				if !ok {
					return nil, twirp.InternalError("failed type assertion resp.(*RemoveTeamBaseRepositoryScopeByNameResponse) when calling interceptor")
				}
				return typedResp, err
			}
			return nil, err
		}
	}
	return caller(ctx, in)
}

func (c *teamServiceProtobufClient) callRemoveTeamBaseRepositoryScopeByName(ctx context.Context, in *RemoveTeamBaseRepositoryScopeByNameRequest) (*RemoveTeamBaseRepositoryScopeByNameResponse, error) {
	out := new(RemoveTeamBaseRepositoryScopeByNameResponse)
	ctx, err := doProtobufRequest(ctx, c.client, c.opts.Hooks, c.urls[19], in, out)
	if err != nil {
		twerr, ok := err.(twirp.Error)
		if !ok {
			twerr = twirp.InternalErrorWith(err)
		}
		callClientError(ctx, c.opts.Hooks, twerr)
		return nil, err
	}

	callClientResponseReceived(ctx, c.opts.Hooks)

	return out, nil
}

func (c *teamServiceProtobufClient) AddTeamRepositoryScope(ctx context.Context, in *AddTeamRepositoryScopeRequest) (*AddTeamRepositoryScopeResponse, error) {
	ctx = ctxsetters.WithPackageName(ctx, "buf.alpha.registry.v1alpha1")
	ctx = ctxsetters.WithServiceName(ctx, "TeamService")
	ctx = ctxsetters.WithMethodName(ctx, "AddTeamRepositoryScope")
	caller := c.callAddTeamRepositoryScope
	if c.interceptor != nil {
		caller = func(ctx context.Context, req *AddTeamRepositoryScopeRequest) (*AddTeamRepositoryScopeResponse, error) {
			resp, err := c.interceptor(
				func(ctx context.Context, req interface{}) (interface{}, error) {
					typedReq, ok := req.(*AddTeamRepositoryScopeRequest)
					if !ok {
						return nil, twirp.InternalError("failed type assertion req.(*AddTeamRepositoryScopeRequest) when calling interceptor")
					}
					return c.callAddTeamRepositoryScope(ctx, typedReq)
				},
			)(ctx, req)
			if resp != nil {
				typedResp, ok := resp.(*AddTeamRepositoryScopeResponse)
				if !ok {
					return nil, twirp.InternalError("failed type assertion resp.(*AddTeamRepositoryScopeResponse) when calling interceptor")
				}
				return typedResp, err
			}
			return nil, err
		}
	}
	return caller(ctx, in)
}

func (c *teamServiceProtobufClient) callAddTeamRepositoryScope(ctx context.Context, in *AddTeamRepositoryScopeRequest) (*AddTeamRepositoryScopeResponse, error) {
	out := new(AddTeamRepositoryScopeResponse)
	ctx, err := doProtobufRequest(ctx, c.client, c.opts.Hooks, c.urls[20], in, out)
	if err != nil {
		twerr, ok := err.(twirp.Error)
		if !ok {
			twerr = twirp.InternalErrorWith(err)
		}
		callClientError(ctx, c.opts.Hooks, twerr)
		return nil, err
	}

	callClientResponseReceived(ctx, c.opts.Hooks)

	return out, nil
}

func (c *teamServiceProtobufClient) AddTeamRepositoryScopeByName(ctx context.Context, in *AddTeamRepositoryScopeByNameRequest) (*AddTeamRepositoryScopeByNameResponse, error) {
	ctx = ctxsetters.WithPackageName(ctx, "buf.alpha.registry.v1alpha1")
	ctx = ctxsetters.WithServiceName(ctx, "TeamService")
	ctx = ctxsetters.WithMethodName(ctx, "AddTeamRepositoryScopeByName")
	caller := c.callAddTeamRepositoryScopeByName
	if c.interceptor != nil {
		caller = func(ctx context.Context, req *AddTeamRepositoryScopeByNameRequest) (*AddTeamRepositoryScopeByNameResponse, error) {
			resp, err := c.interceptor(
				func(ctx context.Context, req interface{}) (interface{}, error) {
					typedReq, ok := req.(*AddTeamRepositoryScopeByNameRequest)
					if !ok {
						return nil, twirp.InternalError("failed type assertion req.(*AddTeamRepositoryScopeByNameRequest) when calling interceptor")
					}
					return c.callAddTeamRepositoryScopeByName(ctx, typedReq)
				},
			)(ctx, req)
			if resp != nil {
				typedResp, ok := resp.(*AddTeamRepositoryScopeByNameResponse)
				if !ok {
					return nil, twirp.InternalError("failed type assertion resp.(*AddTeamRepositoryScopeByNameResponse) when calling interceptor")
				}
				return typedResp, err
			}
			return nil, err
		}
	}
	return caller(ctx, in)
}

func (c *teamServiceProtobufClient) callAddTeamRepositoryScopeByName(ctx context.Context, in *AddTeamRepositoryScopeByNameRequest) (*AddTeamRepositoryScopeByNameResponse, error) {
	out := new(AddTeamRepositoryScopeByNameResponse)
	ctx, err := doProtobufRequest(ctx, c.client, c.opts.Hooks, c.urls[21], in, out)
	if err != nil {
		twerr, ok := err.(twirp.Error)
		if !ok {
			twerr = twirp.InternalErrorWith(err)
		}
		callClientError(ctx, c.opts.Hooks, twerr)
		return nil, err
	}

	callClientResponseReceived(ctx, c.opts.Hooks)

	return out, nil
}

func (c *teamServiceProtobufClient) RemoveTeamRepositoryScope(ctx context.Context, in *RemoveTeamRepositoryScopeRequest) (*RemoveTeamRepositoryScopeResponse, error) {
	ctx = ctxsetters.WithPackageName(ctx, "buf.alpha.registry.v1alpha1")
	ctx = ctxsetters.WithServiceName(ctx, "TeamService")
	ctx = ctxsetters.WithMethodName(ctx, "RemoveTeamRepositoryScope")
	caller := c.callRemoveTeamRepositoryScope
	if c.interceptor != nil {
		caller = func(ctx context.Context, req *RemoveTeamRepositoryScopeRequest) (*RemoveTeamRepositoryScopeResponse, error) {
			resp, err := c.interceptor(
				func(ctx context.Context, req interface{}) (interface{}, error) {
					typedReq, ok := req.(*RemoveTeamRepositoryScopeRequest)
					if !ok {
						return nil, twirp.InternalError("failed type assertion req.(*RemoveTeamRepositoryScopeRequest) when calling interceptor")
					}
					return c.callRemoveTeamRepositoryScope(ctx, typedReq)
				},
			)(ctx, req)
			if resp != nil {
				typedResp, ok := resp.(*RemoveTeamRepositoryScopeResponse)
				if !ok {
					return nil, twirp.InternalError("failed type assertion resp.(*RemoveTeamRepositoryScopeResponse) when calling interceptor")
				}
				return typedResp, err
			}
			return nil, err
		}
	}
	return caller(ctx, in)
}

func (c *teamServiceProtobufClient) callRemoveTeamRepositoryScope(ctx context.Context, in *RemoveTeamRepositoryScopeRequest) (*RemoveTeamRepositoryScopeResponse, error) {
	out := new(RemoveTeamRepositoryScopeResponse)
	ctx, err := doProtobufRequest(ctx, c.client, c.opts.Hooks, c.urls[22], in, out)
	if err != nil {
		twerr, ok := err.(twirp.Error)
		if !ok {
			twerr = twirp.InternalErrorWith(err)
		}
		callClientError(ctx, c.opts.Hooks, twerr)
		return nil, err
	}

	callClientResponseReceived(ctx, c.opts.Hooks)

	return out, nil
}

func (c *teamServiceProtobufClient) RemoveTeamRepositoryScopeByName(ctx context.Context, in *RemoveTeamRepositoryScopeByNameRequest) (*RemoveTeamRepositoryScopeByNameResponse, error) {
	ctx = ctxsetters.WithPackageName(ctx, "buf.alpha.registry.v1alpha1")
	ctx = ctxsetters.WithServiceName(ctx, "TeamService")
	ctx = ctxsetters.WithMethodName(ctx, "RemoveTeamRepositoryScopeByName")
	caller := c.callRemoveTeamRepositoryScopeByName
	if c.interceptor != nil {
		caller = func(ctx context.Context, req *RemoveTeamRepositoryScopeByNameRequest) (*RemoveTeamRepositoryScopeByNameResponse, error) {
			resp, err := c.interceptor(
				func(ctx context.Context, req interface{}) (interface{}, error) {
					typedReq, ok := req.(*RemoveTeamRepositoryScopeByNameRequest)
					if !ok {
						return nil, twirp.InternalError("failed type assertion req.(*RemoveTeamRepositoryScopeByNameRequest) when calling interceptor")
					}
					return c.callRemoveTeamRepositoryScopeByName(ctx, typedReq)
				},
			)(ctx, req)
			if resp != nil {
				typedResp, ok := resp.(*RemoveTeamRepositoryScopeByNameResponse)
				if !ok {
					return nil, twirp.InternalError("failed type assertion resp.(*RemoveTeamRepositoryScopeByNameResponse) when calling interceptor")
				}
				return typedResp, err
			}
			return nil, err
		}
	}
	return caller(ctx, in)
}

func (c *teamServiceProtobufClient) callRemoveTeamRepositoryScopeByName(ctx context.Context, in *RemoveTeamRepositoryScopeByNameRequest) (*RemoveTeamRepositoryScopeByNameResponse, error) {
	out := new(RemoveTeamRepositoryScopeByNameResponse)
	ctx, err := doProtobufRequest(ctx, c.client, c.opts.Hooks, c.urls[23], in, out)
	if err != nil {
		twerr, ok := err.(twirp.Error)
		if !ok {
			twerr = twirp.InternalErrorWith(err)
		}
		callClientError(ctx, c.opts.Hooks, twerr)
		return nil, err
	}

	callClientResponseReceived(ctx, c.opts.Hooks)

	return out, nil
}

// =======================
// TeamService JSON Client
// =======================

type teamServiceJSONClient struct {
	client      HTTPClient
	urls        [24]string
	interceptor twirp.Interceptor
	opts        twirp.ClientOptions
}

// NewTeamServiceJSONClient creates a JSON client that implements the TeamService interface.
// It communicates using JSON and can be configured with a custom HTTPClient.
func NewTeamServiceJSONClient(baseURL string, client HTTPClient, opts ...twirp.ClientOption) TeamService {
	if c, ok := client.(*http.Client); ok {
		client = withoutRedirects(c)
	}

	clientOpts := twirp.ClientOptions{}
	for _, o := range opts {
		o(&clientOpts)
	}

	// Using ReadOpt allows backwards and forwads compatibility with new options in the future
	literalURLs := false
	_ = clientOpts.ReadOpt("literalURLs", &literalURLs)
	var pathPrefix string
	if ok := clientOpts.ReadOpt("pathPrefix", &pathPrefix); !ok {
		pathPrefix = "/twirp" // default prefix
	}

	// Build method URLs: <baseURL>[<prefix>]/<package>.<Service>/<Method>
	serviceURL := sanitizeBaseURL(baseURL)
	serviceURL += baseServicePath(pathPrefix, "buf.alpha.registry.v1alpha1", "TeamService")
	urls := [24]string{
		serviceURL + "GetTeam",
		serviceURL + "GetTeamByName",
		serviceURL + "ListOrganizationTeams",
		serviceURL + "CreateTeam",
		serviceURL + "CreateTeamByName",
		serviceURL + "UpdateTeamName",
		serviceURL + "AddUserToTeam",
		serviceURL + "AddUserToTeamByName",
		serviceURL + "RemoveUserFromTeam",
		serviceURL + "RemoveUserFromTeamByName",
		serviceURL + "DeleteTeam",
		serviceURL + "DeleteTeamByName",
		serviceURL + "AddTeamOrganizationScope",
		serviceURL + "AddTeamOrganizationScopeByName",
		serviceURL + "RemoveTeamOrganizationScope",
		serviceURL + "RemoveTeamOrganizationScopeByName",
		serviceURL + "AddTeamBaseRepositoryScope",
		serviceURL + "AddTeamBaseRepositoryScopeByName",
		serviceURL + "RemoveTeamBaseRepositoryScope",
		serviceURL + "RemoveTeamBaseRepositoryScopeByName",
		serviceURL + "AddTeamRepositoryScope",
		serviceURL + "AddTeamRepositoryScopeByName",
		serviceURL + "RemoveTeamRepositoryScope",
		serviceURL + "RemoveTeamRepositoryScopeByName",
	}

	return &teamServiceJSONClient{
		client:      client,
		urls:        urls,
		interceptor: twirp.ChainInterceptors(clientOpts.Interceptors...),
		opts:        clientOpts,
	}
}

func (c *teamServiceJSONClient) GetTeam(ctx context.Context, in *GetTeamRequest) (*GetTeamResponse, error) {
	ctx = ctxsetters.WithPackageName(ctx, "buf.alpha.registry.v1alpha1")
	ctx = ctxsetters.WithServiceName(ctx, "TeamService")
	ctx = ctxsetters.WithMethodName(ctx, "GetTeam")
	caller := c.callGetTeam
	if c.interceptor != nil {
		caller = func(ctx context.Context, req *GetTeamRequest) (*GetTeamResponse, error) {
			resp, err := c.interceptor(
				func(ctx context.Context, req interface{}) (interface{}, error) {
					typedReq, ok := req.(*GetTeamRequest)
					if !ok {
						return nil, twirp.InternalError("failed type assertion req.(*GetTeamRequest) when calling interceptor")
					}
					return c.callGetTeam(ctx, typedReq)
				},
			)(ctx, req)
			if resp != nil {
				typedResp, ok := resp.(*GetTeamResponse)
				if !ok {
					return nil, twirp.InternalError("failed type assertion resp.(*GetTeamResponse) when calling interceptor")
				}
				return typedResp, err
			}
			return nil, err
		}
	}
	return caller(ctx, in)
}

func (c *teamServiceJSONClient) callGetTeam(ctx context.Context, in *GetTeamRequest) (*GetTeamResponse, error) {
	out := new(GetTeamResponse)
	ctx, err := doJSONRequest(ctx, c.client, c.opts.Hooks, c.urls[0], in, out)
	if err != nil {
		twerr, ok := err.(twirp.Error)
		if !ok {
			twerr = twirp.InternalErrorWith(err)
		}
		callClientError(ctx, c.opts.Hooks, twerr)
		return nil, err
	}

	callClientResponseReceived(ctx, c.opts.Hooks)

	return out, nil
}

func (c *teamServiceJSONClient) GetTeamByName(ctx context.Context, in *GetTeamByNameRequest) (*GetTeamByNameResponse, error) {
	ctx = ctxsetters.WithPackageName(ctx, "buf.alpha.registry.v1alpha1")
	ctx = ctxsetters.WithServiceName(ctx, "TeamService")
	ctx = ctxsetters.WithMethodName(ctx, "GetTeamByName")
	caller := c.callGetTeamByName
	if c.interceptor != nil {
		caller = func(ctx context.Context, req *GetTeamByNameRequest) (*GetTeamByNameResponse, error) {
			resp, err := c.interceptor(
				func(ctx context.Context, req interface{}) (interface{}, error) {
					typedReq, ok := req.(*GetTeamByNameRequest)
					if !ok {
						return nil, twirp.InternalError("failed type assertion req.(*GetTeamByNameRequest) when calling interceptor")
					}
					return c.callGetTeamByName(ctx, typedReq)
				},
			)(ctx, req)
			if resp != nil {
				typedResp, ok := resp.(*GetTeamByNameResponse)
				if !ok {
					return nil, twirp.InternalError("failed type assertion resp.(*GetTeamByNameResponse) when calling interceptor")
				}
				return typedResp, err
			}
			return nil, err
		}
	}
	return caller(ctx, in)
}

func (c *teamServiceJSONClient) callGetTeamByName(ctx context.Context, in *GetTeamByNameRequest) (*GetTeamByNameResponse, error) {
	out := new(GetTeamByNameResponse)
	ctx, err := doJSONRequest(ctx, c.client, c.opts.Hooks, c.urls[1], in, out)
	if err != nil {
		twerr, ok := err.(twirp.Error)
		if !ok {
			twerr = twirp.InternalErrorWith(err)
		}
		callClientError(ctx, c.opts.Hooks, twerr)
		return nil, err
	}

	callClientResponseReceived(ctx, c.opts.Hooks)

	return out, nil
}

func (c *teamServiceJSONClient) ListOrganizationTeams(ctx context.Context, in *ListOrganizationTeamsRequest) (*ListOrganizationTeamsResponse, error) {
	ctx = ctxsetters.WithPackageName(ctx, "buf.alpha.registry.v1alpha1")
	ctx = ctxsetters.WithServiceName(ctx, "TeamService")
	ctx = ctxsetters.WithMethodName(ctx, "ListOrganizationTeams")
	caller := c.callListOrganizationTeams
	if c.interceptor != nil {
		caller = func(ctx context.Context, req *ListOrganizationTeamsRequest) (*ListOrganizationTeamsResponse, error) {
			resp, err := c.interceptor(
				func(ctx context.Context, req interface{}) (interface{}, error) {
					typedReq, ok := req.(*ListOrganizationTeamsRequest)
					if !ok {
						return nil, twirp.InternalError("failed type assertion req.(*ListOrganizationTeamsRequest) when calling interceptor")
					}
					return c.callListOrganizationTeams(ctx, typedReq)
				},
			)(ctx, req)
			if resp != nil {
				typedResp, ok := resp.(*ListOrganizationTeamsResponse)
				if !ok {
					return nil, twirp.InternalError("failed type assertion resp.(*ListOrganizationTeamsResponse) when calling interceptor")
				}
				return typedResp, err
			}
			return nil, err
		}
	}
	return caller(ctx, in)
}

func (c *teamServiceJSONClient) callListOrganizationTeams(ctx context.Context, in *ListOrganizationTeamsRequest) (*ListOrganizationTeamsResponse, error) {
	out := new(ListOrganizationTeamsResponse)
	ctx, err := doJSONRequest(ctx, c.client, c.opts.Hooks, c.urls[2], in, out)
	if err != nil {
		twerr, ok := err.(twirp.Error)
		if !ok {
			twerr = twirp.InternalErrorWith(err)
		}
		callClientError(ctx, c.opts.Hooks, twerr)
		return nil, err
	}

	callClientResponseReceived(ctx, c.opts.Hooks)

	return out, nil
}

func (c *teamServiceJSONClient) CreateTeam(ctx context.Context, in *CreateTeamRequest) (*CreateTeamResponse, error) {
	ctx = ctxsetters.WithPackageName(ctx, "buf.alpha.registry.v1alpha1")
	ctx = ctxsetters.WithServiceName(ctx, "TeamService")
	ctx = ctxsetters.WithMethodName(ctx, "CreateTeam")
	caller := c.callCreateTeam
	if c.interceptor != nil {
		caller = func(ctx context.Context, req *CreateTeamRequest) (*CreateTeamResponse, error) {
			resp, err := c.interceptor(
				func(ctx context.Context, req interface{}) (interface{}, error) {
					typedReq, ok := req.(*CreateTeamRequest)
					if !ok {
						return nil, twirp.InternalError("failed type assertion req.(*CreateTeamRequest) when calling interceptor")
					}
					return c.callCreateTeam(ctx, typedReq)
				},
			)(ctx, req)
			if resp != nil {
				typedResp, ok := resp.(*CreateTeamResponse)
				if !ok {
					return nil, twirp.InternalError("failed type assertion resp.(*CreateTeamResponse) when calling interceptor")
				}
				return typedResp, err
			}
			return nil, err
		}
	}
	return caller(ctx, in)
}

func (c *teamServiceJSONClient) callCreateTeam(ctx context.Context, in *CreateTeamRequest) (*CreateTeamResponse, error) {
	out := new(CreateTeamResponse)
	ctx, err := doJSONRequest(ctx, c.client, c.opts.Hooks, c.urls[3], in, out)
	if err != nil {
		twerr, ok := err.(twirp.Error)
		if !ok {
			twerr = twirp.InternalErrorWith(err)
		}
		callClientError(ctx, c.opts.Hooks, twerr)
		return nil, err
	}

	callClientResponseReceived(ctx, c.opts.Hooks)

	return out, nil
}

func (c *teamServiceJSONClient) CreateTeamByName(ctx context.Context, in *CreateTeamByNameRequest) (*CreateTeamByNameResponse, error) {
	ctx = ctxsetters.WithPackageName(ctx, "buf.alpha.registry.v1alpha1")
	ctx = ctxsetters.WithServiceName(ctx, "TeamService")
	ctx = ctxsetters.WithMethodName(ctx, "CreateTeamByName")
	caller := c.callCreateTeamByName
	if c.interceptor != nil {
		caller = func(ctx context.Context, req *CreateTeamByNameRequest) (*CreateTeamByNameResponse, error) {
			resp, err := c.interceptor(
				func(ctx context.Context, req interface{}) (interface{}, error) {
					typedReq, ok := req.(*CreateTeamByNameRequest)
					if !ok {
						return nil, twirp.InternalError("failed type assertion req.(*CreateTeamByNameRequest) when calling interceptor")
					}
					return c.callCreateTeamByName(ctx, typedReq)
				},
			)(ctx, req)
			if resp != nil {
				typedResp, ok := resp.(*CreateTeamByNameResponse)
				if !ok {
					return nil, twirp.InternalError("failed type assertion resp.(*CreateTeamByNameResponse) when calling interceptor")
				}
				return typedResp, err
			}
			return nil, err
		}
	}
	return caller(ctx, in)
}

func (c *teamServiceJSONClient) callCreateTeamByName(ctx context.Context, in *CreateTeamByNameRequest) (*CreateTeamByNameResponse, error) {
	out := new(CreateTeamByNameResponse)
	ctx, err := doJSONRequest(ctx, c.client, c.opts.Hooks, c.urls[4], in, out)
	if err != nil {
		twerr, ok := err.(twirp.Error)
		if !ok {
			twerr = twirp.InternalErrorWith(err)
		}
		callClientError(ctx, c.opts.Hooks, twerr)
		return nil, err
	}

	callClientResponseReceived(ctx, c.opts.Hooks)

	return out, nil
}

func (c *teamServiceJSONClient) UpdateTeamName(ctx context.Context, in *UpdateTeamNameRequest) (*UpdateTeamNameResponse, error) {
	ctx = ctxsetters.WithPackageName(ctx, "buf.alpha.registry.v1alpha1")
	ctx = ctxsetters.WithServiceName(ctx, "TeamService")
	ctx = ctxsetters.WithMethodName(ctx, "UpdateTeamName")
	caller := c.callUpdateTeamName
	if c.interceptor != nil {
		caller = func(ctx context.Context, req *UpdateTeamNameRequest) (*UpdateTeamNameResponse, error) {
			resp, err := c.interceptor(
				func(ctx context.Context, req interface{}) (interface{}, error) {
					typedReq, ok := req.(*UpdateTeamNameRequest)
					if !ok {
						return nil, twirp.InternalError("failed type assertion req.(*UpdateTeamNameRequest) when calling interceptor")
					}
					return c.callUpdateTeamName(ctx, typedReq)
				},
			)(ctx, req)
			if resp != nil {
				typedResp, ok := resp.(*UpdateTeamNameResponse)
				if !ok {
					return nil, twirp.InternalError("failed type assertion resp.(*UpdateTeamNameResponse) when calling interceptor")
				}
				return typedResp, err
			}
			return nil, err
		}
	}
	return caller(ctx, in)
}

func (c *teamServiceJSONClient) callUpdateTeamName(ctx context.Context, in *UpdateTeamNameRequest) (*UpdateTeamNameResponse, error) {
	out := new(UpdateTeamNameResponse)
	ctx, err := doJSONRequest(ctx, c.client, c.opts.Hooks, c.urls[5], in, out)
	if err != nil {
		twerr, ok := err.(twirp.Error)
		if !ok {
			twerr = twirp.InternalErrorWith(err)
		}
		callClientError(ctx, c.opts.Hooks, twerr)
		return nil, err
	}

	callClientResponseReceived(ctx, c.opts.Hooks)

	return out, nil
}

func (c *teamServiceJSONClient) AddUserToTeam(ctx context.Context, in *AddUserToTeamRequest) (*AddUserToTeamResponse, error) {
	ctx = ctxsetters.WithPackageName(ctx, "buf.alpha.registry.v1alpha1")
	ctx = ctxsetters.WithServiceName(ctx, "TeamService")
	ctx = ctxsetters.WithMethodName(ctx, "AddUserToTeam")
	caller := c.callAddUserToTeam
	if c.interceptor != nil {
		caller = func(ctx context.Context, req *AddUserToTeamRequest) (*AddUserToTeamResponse, error) {
			resp, err := c.interceptor(
				func(ctx context.Context, req interface{}) (interface{}, error) {
					typedReq, ok := req.(*AddUserToTeamRequest)
					if !ok {
						return nil, twirp.InternalError("failed type assertion req.(*AddUserToTeamRequest) when calling interceptor")
					}
					return c.callAddUserToTeam(ctx, typedReq)
				},
			)(ctx, req)
			if resp != nil {
				typedResp, ok := resp.(*AddUserToTeamResponse)
				if !ok {
					return nil, twirp.InternalError("failed type assertion resp.(*AddUserToTeamResponse) when calling interceptor")
				}
				return typedResp, err
			}
			return nil, err
		}
	}
	return caller(ctx, in)
}

func (c *teamServiceJSONClient) callAddUserToTeam(ctx context.Context, in *AddUserToTeamRequest) (*AddUserToTeamResponse, error) {
	out := new(AddUserToTeamResponse)
	ctx, err := doJSONRequest(ctx, c.client, c.opts.Hooks, c.urls[6], in, out)
	if err != nil {
		twerr, ok := err.(twirp.Error)
		if !ok {
			twerr = twirp.InternalErrorWith(err)
		}
		callClientError(ctx, c.opts.Hooks, twerr)
		return nil, err
	}

	callClientResponseReceived(ctx, c.opts.Hooks)

	return out, nil
}

func (c *teamServiceJSONClient) AddUserToTeamByName(ctx context.Context, in *AddUserToTeamByNameRequest) (*AddUserToTeamByNameResponse, error) {
	ctx = ctxsetters.WithPackageName(ctx, "buf.alpha.registry.v1alpha1")
	ctx = ctxsetters.WithServiceName(ctx, "TeamService")
	ctx = ctxsetters.WithMethodName(ctx, "AddUserToTeamByName")
	caller := c.callAddUserToTeamByName
	if c.interceptor != nil {
		caller = func(ctx context.Context, req *AddUserToTeamByNameRequest) (*AddUserToTeamByNameResponse, error) {
			resp, err := c.interceptor(
				func(ctx context.Context, req interface{}) (interface{}, error) {
					typedReq, ok := req.(*AddUserToTeamByNameRequest)
					if !ok {
						return nil, twirp.InternalError("failed type assertion req.(*AddUserToTeamByNameRequest) when calling interceptor")
					}
					return c.callAddUserToTeamByName(ctx, typedReq)
				},
			)(ctx, req)
			if resp != nil {
				typedResp, ok := resp.(*AddUserToTeamByNameResponse)
				if !ok {
					return nil, twirp.InternalError("failed type assertion resp.(*AddUserToTeamByNameResponse) when calling interceptor")
				}
				return typedResp, err
			}
			return nil, err
		}
	}
	return caller(ctx, in)
}

func (c *teamServiceJSONClient) callAddUserToTeamByName(ctx context.Context, in *AddUserToTeamByNameRequest) (*AddUserToTeamByNameResponse, error) {
	out := new(AddUserToTeamByNameResponse)
	ctx, err := doJSONRequest(ctx, c.client, c.opts.Hooks, c.urls[7], in, out)
	if err != nil {
		twerr, ok := err.(twirp.Error)
		if !ok {
			twerr = twirp.InternalErrorWith(err)
		}
		callClientError(ctx, c.opts.Hooks, twerr)
		return nil, err
	}

	callClientResponseReceived(ctx, c.opts.Hooks)

	return out, nil
}

func (c *teamServiceJSONClient) RemoveUserFromTeam(ctx context.Context, in *RemoveUserFromTeamRequest) (*RemoveUserFromTeamResponse, error) {
	ctx = ctxsetters.WithPackageName(ctx, "buf.alpha.registry.v1alpha1")
	ctx = ctxsetters.WithServiceName(ctx, "TeamService")
	ctx = ctxsetters.WithMethodName(ctx, "RemoveUserFromTeam")
	caller := c.callRemoveUserFromTeam
	if c.interceptor != nil {
		caller = func(ctx context.Context, req *RemoveUserFromTeamRequest) (*RemoveUserFromTeamResponse, error) {
			resp, err := c.interceptor(
				func(ctx context.Context, req interface{}) (interface{}, error) {
					typedReq, ok := req.(*RemoveUserFromTeamRequest)
					if !ok {
						return nil, twirp.InternalError("failed type assertion req.(*RemoveUserFromTeamRequest) when calling interceptor")
					}
					return c.callRemoveUserFromTeam(ctx, typedReq)
				},
			)(ctx, req)
			if resp != nil {
				typedResp, ok := resp.(*RemoveUserFromTeamResponse)
				if !ok {
					return nil, twirp.InternalError("failed type assertion resp.(*RemoveUserFromTeamResponse) when calling interceptor")
				}
				return typedResp, err
			}
			return nil, err
		}
	}
	return caller(ctx, in)
}

func (c *teamServiceJSONClient) callRemoveUserFromTeam(ctx context.Context, in *RemoveUserFromTeamRequest) (*RemoveUserFromTeamResponse, error) {
	out := new(RemoveUserFromTeamResponse)
	ctx, err := doJSONRequest(ctx, c.client, c.opts.Hooks, c.urls[8], in, out)
	if err != nil {
		twerr, ok := err.(twirp.Error)
		if !ok {
			twerr = twirp.InternalErrorWith(err)
		}
		callClientError(ctx, c.opts.Hooks, twerr)
		return nil, err
	}

	callClientResponseReceived(ctx, c.opts.Hooks)

	return out, nil
}

func (c *teamServiceJSONClient) RemoveUserFromTeamByName(ctx context.Context, in *RemoveUserFromTeamByNameRequest) (*RemoveUserFromTeamByNameResponse, error) {
	ctx = ctxsetters.WithPackageName(ctx, "buf.alpha.registry.v1alpha1")
	ctx = ctxsetters.WithServiceName(ctx, "TeamService")
	ctx = ctxsetters.WithMethodName(ctx, "RemoveUserFromTeamByName")
	caller := c.callRemoveUserFromTeamByName
	if c.interceptor != nil {
		caller = func(ctx context.Context, req *RemoveUserFromTeamByNameRequest) (*RemoveUserFromTeamByNameResponse, error) {
			resp, err := c.interceptor(
				func(ctx context.Context, req interface{}) (interface{}, error) {
					typedReq, ok := req.(*RemoveUserFromTeamByNameRequest)
					if !ok {
						return nil, twirp.InternalError("failed type assertion req.(*RemoveUserFromTeamByNameRequest) when calling interceptor")
					}
					return c.callRemoveUserFromTeamByName(ctx, typedReq)
				},
			)(ctx, req)
			if resp != nil {
				typedResp, ok := resp.(*RemoveUserFromTeamByNameResponse)
				if !ok {
					return nil, twirp.InternalError("failed type assertion resp.(*RemoveUserFromTeamByNameResponse) when calling interceptor")
				}
				return typedResp, err
			}
			return nil, err
		}
	}
	return caller(ctx, in)
}

func (c *teamServiceJSONClient) callRemoveUserFromTeamByName(ctx context.Context, in *RemoveUserFromTeamByNameRequest) (*RemoveUserFromTeamByNameResponse, error) {
	out := new(RemoveUserFromTeamByNameResponse)
	ctx, err := doJSONRequest(ctx, c.client, c.opts.Hooks, c.urls[9], in, out)
	if err != nil {
		twerr, ok := err.(twirp.Error)
		if !ok {
			twerr = twirp.InternalErrorWith(err)
		}
		callClientError(ctx, c.opts.Hooks, twerr)
		return nil, err
	}

	callClientResponseReceived(ctx, c.opts.Hooks)

	return out, nil
}

func (c *teamServiceJSONClient) DeleteTeam(ctx context.Context, in *DeleteTeamRequest) (*DeleteTeamResponse, error) {
	ctx = ctxsetters.WithPackageName(ctx, "buf.alpha.registry.v1alpha1")
	ctx = ctxsetters.WithServiceName(ctx, "TeamService")
	ctx = ctxsetters.WithMethodName(ctx, "DeleteTeam")
	caller := c.callDeleteTeam
	if c.interceptor != nil {
		caller = func(ctx context.Context, req *DeleteTeamRequest) (*DeleteTeamResponse, error) {
			resp, err := c.interceptor(
				func(ctx context.Context, req interface{}) (interface{}, error) {
					typedReq, ok := req.(*DeleteTeamRequest)
					if !ok {
						return nil, twirp.InternalError("failed type assertion req.(*DeleteTeamRequest) when calling interceptor")
					}
					return c.callDeleteTeam(ctx, typedReq)
				},
			)(ctx, req)
			if resp != nil {
				typedResp, ok := resp.(*DeleteTeamResponse)
				if !ok {
					return nil, twirp.InternalError("failed type assertion resp.(*DeleteTeamResponse) when calling interceptor")
				}
				return typedResp, err
			}
			return nil, err
		}
	}
	return caller(ctx, in)
}

func (c *teamServiceJSONClient) callDeleteTeam(ctx context.Context, in *DeleteTeamRequest) (*DeleteTeamResponse, error) {
	out := new(DeleteTeamResponse)
	ctx, err := doJSONRequest(ctx, c.client, c.opts.Hooks, c.urls[10], in, out)
	if err != nil {
		twerr, ok := err.(twirp.Error)
		if !ok {
			twerr = twirp.InternalErrorWith(err)
		}
		callClientError(ctx, c.opts.Hooks, twerr)
		return nil, err
	}

	callClientResponseReceived(ctx, c.opts.Hooks)

	return out, nil
}

func (c *teamServiceJSONClient) DeleteTeamByName(ctx context.Context, in *DeleteTeamByNameRequest) (*DeleteTeamByNameResponse, error) {
	ctx = ctxsetters.WithPackageName(ctx, "buf.alpha.registry.v1alpha1")
	ctx = ctxsetters.WithServiceName(ctx, "TeamService")
	ctx = ctxsetters.WithMethodName(ctx, "DeleteTeamByName")
	caller := c.callDeleteTeamByName
	if c.interceptor != nil {
		caller = func(ctx context.Context, req *DeleteTeamByNameRequest) (*DeleteTeamByNameResponse, error) {
			resp, err := c.interceptor(
				func(ctx context.Context, req interface{}) (interface{}, error) {
					typedReq, ok := req.(*DeleteTeamByNameRequest)
					if !ok {
						return nil, twirp.InternalError("failed type assertion req.(*DeleteTeamByNameRequest) when calling interceptor")
					}
					return c.callDeleteTeamByName(ctx, typedReq)
				},
			)(ctx, req)
			if resp != nil {
				typedResp, ok := resp.(*DeleteTeamByNameResponse)
				if !ok {
					return nil, twirp.InternalError("failed type assertion resp.(*DeleteTeamByNameResponse) when calling interceptor")
				}
				return typedResp, err
			}
			return nil, err
		}
	}
	return caller(ctx, in)
}

func (c *teamServiceJSONClient) callDeleteTeamByName(ctx context.Context, in *DeleteTeamByNameRequest) (*DeleteTeamByNameResponse, error) {
	out := new(DeleteTeamByNameResponse)
	ctx, err := doJSONRequest(ctx, c.client, c.opts.Hooks, c.urls[11], in, out)
	if err != nil {
		twerr, ok := err.(twirp.Error)
		if !ok {
			twerr = twirp.InternalErrorWith(err)
		}
		callClientError(ctx, c.opts.Hooks, twerr)
		return nil, err
	}

	callClientResponseReceived(ctx, c.opts.Hooks)

	return out, nil
}

func (c *teamServiceJSONClient) AddTeamOrganizationScope(ctx context.Context, in *AddTeamOrganizationScopeRequest) (*AddTeamOrganizationScopeResponse, error) {
	ctx = ctxsetters.WithPackageName(ctx, "buf.alpha.registry.v1alpha1")
	ctx = ctxsetters.WithServiceName(ctx, "TeamService")
	ctx = ctxsetters.WithMethodName(ctx, "AddTeamOrganizationScope")
	caller := c.callAddTeamOrganizationScope
	if c.interceptor != nil {
		caller = func(ctx context.Context, req *AddTeamOrganizationScopeRequest) (*AddTeamOrganizationScopeResponse, error) {
			resp, err := c.interceptor(
				func(ctx context.Context, req interface{}) (interface{}, error) {
					typedReq, ok := req.(*AddTeamOrganizationScopeRequest)
					if !ok {
						return nil, twirp.InternalError("failed type assertion req.(*AddTeamOrganizationScopeRequest) when calling interceptor")
					}
					return c.callAddTeamOrganizationScope(ctx, typedReq)
				},
			)(ctx, req)
			if resp != nil {
				typedResp, ok := resp.(*AddTeamOrganizationScopeResponse)
				if !ok {
					return nil, twirp.InternalError("failed type assertion resp.(*AddTeamOrganizationScopeResponse) when calling interceptor")
				}
				return typedResp, err
			}
			return nil, err
		}
	}
	return caller(ctx, in)
}

func (c *teamServiceJSONClient) callAddTeamOrganizationScope(ctx context.Context, in *AddTeamOrganizationScopeRequest) (*AddTeamOrganizationScopeResponse, error) {
	out := new(AddTeamOrganizationScopeResponse)
	ctx, err := doJSONRequest(ctx, c.client, c.opts.Hooks, c.urls[12], in, out)
	if err != nil {
		twerr, ok := err.(twirp.Error)
		if !ok {
			twerr = twirp.InternalErrorWith(err)
		}
		callClientError(ctx, c.opts.Hooks, twerr)
		return nil, err
	}

	callClientResponseReceived(ctx, c.opts.Hooks)

	return out, nil
}

func (c *teamServiceJSONClient) AddTeamOrganizationScopeByName(ctx context.Context, in *AddTeamOrganizationScopeByNameRequest) (*AddTeamOrganizationScopeByNameResponse, error) {
	ctx = ctxsetters.WithPackageName(ctx, "buf.alpha.registry.v1alpha1")
	ctx = ctxsetters.WithServiceName(ctx, "TeamService")
	ctx = ctxsetters.WithMethodName(ctx, "AddTeamOrganizationScopeByName")
	caller := c.callAddTeamOrganizationScopeByName
	if c.interceptor != nil {
		caller = func(ctx context.Context, req *AddTeamOrganizationScopeByNameRequest) (*AddTeamOrganizationScopeByNameResponse, error) {
			resp, err := c.interceptor(
				func(ctx context.Context, req interface{}) (interface{}, error) {
					typedReq, ok := req.(*AddTeamOrganizationScopeByNameRequest)
					if !ok {
						return nil, twirp.InternalError("failed type assertion req.(*AddTeamOrganizationScopeByNameRequest) when calling interceptor")
					}
					return c.callAddTeamOrganizationScopeByName(ctx, typedReq)
				},
			)(ctx, req)
			if resp != nil {
				typedResp, ok := resp.(*AddTeamOrganizationScopeByNameResponse)
				if !ok {
					return nil, twirp.InternalError("failed type assertion resp.(*AddTeamOrganizationScopeByNameResponse) when calling interceptor")
				}
				return typedResp, err
			}
			return nil, err
		}
	}
	return caller(ctx, in)
}

func (c *teamServiceJSONClient) callAddTeamOrganizationScopeByName(ctx context.Context, in *AddTeamOrganizationScopeByNameRequest) (*AddTeamOrganizationScopeByNameResponse, error) {
	out := new(AddTeamOrganizationScopeByNameResponse)
	ctx, err := doJSONRequest(ctx, c.client, c.opts.Hooks, c.urls[13], in, out)
	if err != nil {
		twerr, ok := err.(twirp.Error)
		if !ok {
			twerr = twirp.InternalErrorWith(err)
		}
		callClientError(ctx, c.opts.Hooks, twerr)
		return nil, err
	}

	callClientResponseReceived(ctx, c.opts.Hooks)

	return out, nil
}

func (c *teamServiceJSONClient) RemoveTeamOrganizationScope(ctx context.Context, in *RemoveTeamOrganizationScopeRequest) (*RemoveTeamOrganizationScopeResponse, error) {
	ctx = ctxsetters.WithPackageName(ctx, "buf.alpha.registry.v1alpha1")
	ctx = ctxsetters.WithServiceName(ctx, "TeamService")
	ctx = ctxsetters.WithMethodName(ctx, "RemoveTeamOrganizationScope")
	caller := c.callRemoveTeamOrganizationScope
	if c.interceptor != nil {
		caller = func(ctx context.Context, req *RemoveTeamOrganizationScopeRequest) (*RemoveTeamOrganizationScopeResponse, error) {
			resp, err := c.interceptor(
				func(ctx context.Context, req interface{}) (interface{}, error) {
					typedReq, ok := req.(*RemoveTeamOrganizationScopeRequest)
					if !ok {
						return nil, twirp.InternalError("failed type assertion req.(*RemoveTeamOrganizationScopeRequest) when calling interceptor")
					}
					return c.callRemoveTeamOrganizationScope(ctx, typedReq)
				},
			)(ctx, req)
			if resp != nil {
				typedResp, ok := resp.(*RemoveTeamOrganizationScopeResponse)
				if !ok {
					return nil, twirp.InternalError("failed type assertion resp.(*RemoveTeamOrganizationScopeResponse) when calling interceptor")
				}
				return typedResp, err
			}
			return nil, err
		}
	}
	return caller(ctx, in)
}

func (c *teamServiceJSONClient) callRemoveTeamOrganizationScope(ctx context.Context, in *RemoveTeamOrganizationScopeRequest) (*RemoveTeamOrganizationScopeResponse, error) {
	out := new(RemoveTeamOrganizationScopeResponse)
	ctx, err := doJSONRequest(ctx, c.client, c.opts.Hooks, c.urls[14], in, out)
	if err != nil {
		twerr, ok := err.(twirp.Error)
		if !ok {
			twerr = twirp.InternalErrorWith(err)
		}
		callClientError(ctx, c.opts.Hooks, twerr)
		return nil, err
	}

	callClientResponseReceived(ctx, c.opts.Hooks)

	return out, nil
}

func (c *teamServiceJSONClient) RemoveTeamOrganizationScopeByName(ctx context.Context, in *RemoveTeamOrganizationScopeByNameRequest) (*RemoveTeamOrganizationScopeByNameResponse, error) {
	ctx = ctxsetters.WithPackageName(ctx, "buf.alpha.registry.v1alpha1")
	ctx = ctxsetters.WithServiceName(ctx, "TeamService")
	ctx = ctxsetters.WithMethodName(ctx, "RemoveTeamOrganizationScopeByName")
	caller := c.callRemoveTeamOrganizationScopeByName
	if c.interceptor != nil {
		caller = func(ctx context.Context, req *RemoveTeamOrganizationScopeByNameRequest) (*RemoveTeamOrganizationScopeByNameResponse, error) {
			resp, err := c.interceptor(
				func(ctx context.Context, req interface{}) (interface{}, error) {
					typedReq, ok := req.(*RemoveTeamOrganizationScopeByNameRequest)
					if !ok {
						return nil, twirp.InternalError("failed type assertion req.(*RemoveTeamOrganizationScopeByNameRequest) when calling interceptor")
					}
					return c.callRemoveTeamOrganizationScopeByName(ctx, typedReq)
				},
			)(ctx, req)
			if resp != nil {
				typedResp, ok := resp.(*RemoveTeamOrganizationScopeByNameResponse)
				if !ok {
					return nil, twirp.InternalError("failed type assertion resp.(*RemoveTeamOrganizationScopeByNameResponse) when calling interceptor")
				}
				return typedResp, err
			}
			return nil, err
		}
	}
	return caller(ctx, in)
}

func (c *teamServiceJSONClient) callRemoveTeamOrganizationScopeByName(ctx context.Context, in *RemoveTeamOrganizationScopeByNameRequest) (*RemoveTeamOrganizationScopeByNameResponse, error) {
	out := new(RemoveTeamOrganizationScopeByNameResponse)
	ctx, err := doJSONRequest(ctx, c.client, c.opts.Hooks, c.urls[15], in, out)
	if err != nil {
		twerr, ok := err.(twirp.Error)
		if !ok {
			twerr = twirp.InternalErrorWith(err)
		}
		callClientError(ctx, c.opts.Hooks, twerr)
		return nil, err
	}

	callClientResponseReceived(ctx, c.opts.Hooks)

	return out, nil
}

func (c *teamServiceJSONClient) AddTeamBaseRepositoryScope(ctx context.Context, in *AddTeamBaseRepositoryScopeRequest) (*AddTeamBaseRepositoryScopeResponse, error) {
	ctx = ctxsetters.WithPackageName(ctx, "buf.alpha.registry.v1alpha1")
	ctx = ctxsetters.WithServiceName(ctx, "TeamService")
	ctx = ctxsetters.WithMethodName(ctx, "AddTeamBaseRepositoryScope")
	caller := c.callAddTeamBaseRepositoryScope
	if c.interceptor != nil {
		caller = func(ctx context.Context, req *AddTeamBaseRepositoryScopeRequest) (*AddTeamBaseRepositoryScopeResponse, error) {
			resp, err := c.interceptor(
				func(ctx context.Context, req interface{}) (interface{}, error) {
					typedReq, ok := req.(*AddTeamBaseRepositoryScopeRequest)
					if !ok {
						return nil, twirp.InternalError("failed type assertion req.(*AddTeamBaseRepositoryScopeRequest) when calling interceptor")
					}
					return c.callAddTeamBaseRepositoryScope(ctx, typedReq)
				},
			)(ctx, req)
			if resp != nil {
				typedResp, ok := resp.(*AddTeamBaseRepositoryScopeResponse)
				if !ok {
					return nil, twirp.InternalError("failed type assertion resp.(*AddTeamBaseRepositoryScopeResponse) when calling interceptor")
				}
				return typedResp, err
			}
			return nil, err
		}
	}
	return caller(ctx, in)
}

func (c *teamServiceJSONClient) callAddTeamBaseRepositoryScope(ctx context.Context, in *AddTeamBaseRepositoryScopeRequest) (*AddTeamBaseRepositoryScopeResponse, error) {
	out := new(AddTeamBaseRepositoryScopeResponse)
	ctx, err := doJSONRequest(ctx, c.client, c.opts.Hooks, c.urls[16], in, out)
	if err != nil {
		twerr, ok := err.(twirp.Error)
		if !ok {
			twerr = twirp.InternalErrorWith(err)
		}
		callClientError(ctx, c.opts.Hooks, twerr)
		return nil, err
	}

	callClientResponseReceived(ctx, c.opts.Hooks)

	return out, nil
}

func (c *teamServiceJSONClient) AddTeamBaseRepositoryScopeByName(ctx context.Context, in *AddTeamBaseRepositoryScopeByNameRequest) (*AddTeamBaseRepositoryScopeByNameResponse, error) {
	ctx = ctxsetters.WithPackageName(ctx, "buf.alpha.registry.v1alpha1")
	ctx = ctxsetters.WithServiceName(ctx, "TeamService")
	ctx = ctxsetters.WithMethodName(ctx, "AddTeamBaseRepositoryScopeByName")
	caller := c.callAddTeamBaseRepositoryScopeByName
	if c.interceptor != nil {
		caller = func(ctx context.Context, req *AddTeamBaseRepositoryScopeByNameRequest) (*AddTeamBaseRepositoryScopeByNameResponse, error) {
			resp, err := c.interceptor(
				func(ctx context.Context, req interface{}) (interface{}, error) {
					typedReq, ok := req.(*AddTeamBaseRepositoryScopeByNameRequest)
					if !ok {
						return nil, twirp.InternalError("failed type assertion req.(*AddTeamBaseRepositoryScopeByNameRequest) when calling interceptor")
					}
					return c.callAddTeamBaseRepositoryScopeByName(ctx, typedReq)
				},
			)(ctx, req)
			if resp != nil {
				typedResp, ok := resp.(*AddTeamBaseRepositoryScopeByNameResponse)
				if !ok {
					return nil, twirp.InternalError("failed type assertion resp.(*AddTeamBaseRepositoryScopeByNameResponse) when calling interceptor")
				}
				return typedResp, err
			}
			return nil, err
		}
	}
	return caller(ctx, in)
}

func (c *teamServiceJSONClient) callAddTeamBaseRepositoryScopeByName(ctx context.Context, in *AddTeamBaseRepositoryScopeByNameRequest) (*AddTeamBaseRepositoryScopeByNameResponse, error) {
	out := new(AddTeamBaseRepositoryScopeByNameResponse)
	ctx, err := doJSONRequest(ctx, c.client, c.opts.Hooks, c.urls[17], in, out)
	if err != nil {
		twerr, ok := err.(twirp.Error)
		if !ok {
			twerr = twirp.InternalErrorWith(err)
		}
		callClientError(ctx, c.opts.Hooks, twerr)
		return nil, err
	}

	callClientResponseReceived(ctx, c.opts.Hooks)

	return out, nil
}

func (c *teamServiceJSONClient) RemoveTeamBaseRepositoryScope(ctx context.Context, in *RemoveTeamBaseRepositoryScopeRequest) (*RemoveTeamBaseRepositoryScopeResponse, error) {
	ctx = ctxsetters.WithPackageName(ctx, "buf.alpha.registry.v1alpha1")
	ctx = ctxsetters.WithServiceName(ctx, "TeamService")
	ctx = ctxsetters.WithMethodName(ctx, "RemoveTeamBaseRepositoryScope")
	caller := c.callRemoveTeamBaseRepositoryScope
	if c.interceptor != nil {
		caller = func(ctx context.Context, req *RemoveTeamBaseRepositoryScopeRequest) (*RemoveTeamBaseRepositoryScopeResponse, error) {
			resp, err := c.interceptor(
				func(ctx context.Context, req interface{}) (interface{}, error) {
					typedReq, ok := req.(*RemoveTeamBaseRepositoryScopeRequest)
					if !ok {
						return nil, twirp.InternalError("failed type assertion req.(*RemoveTeamBaseRepositoryScopeRequest) when calling interceptor")
					}
					return c.callRemoveTeamBaseRepositoryScope(ctx, typedReq)
				},
			)(ctx, req)
			if resp != nil {
				typedResp, ok := resp.(*RemoveTeamBaseRepositoryScopeResponse)
				if !ok {
					return nil, twirp.InternalError("failed type assertion resp.(*RemoveTeamBaseRepositoryScopeResponse) when calling interceptor")
				}
				return typedResp, err
			}
			return nil, err
		}
	}
	return caller(ctx, in)
}

func (c *teamServiceJSONClient) callRemoveTeamBaseRepositoryScope(ctx context.Context, in *RemoveTeamBaseRepositoryScopeRequest) (*RemoveTeamBaseRepositoryScopeResponse, error) {
	out := new(RemoveTeamBaseRepositoryScopeResponse)
	ctx, err := doJSONRequest(ctx, c.client, c.opts.Hooks, c.urls[18], in, out)
	if err != nil {
		twerr, ok := err.(twirp.Error)
		if !ok {
			twerr = twirp.InternalErrorWith(err)
		}
		callClientError(ctx, c.opts.Hooks, twerr)
		return nil, err
	}

	callClientResponseReceived(ctx, c.opts.Hooks)

	return out, nil
}

func (c *teamServiceJSONClient) RemoveTeamBaseRepositoryScopeByName(ctx context.Context, in *RemoveTeamBaseRepositoryScopeByNameRequest) (*RemoveTeamBaseRepositoryScopeByNameResponse, error) {
	ctx = ctxsetters.WithPackageName(ctx, "buf.alpha.registry.v1alpha1")
	ctx = ctxsetters.WithServiceName(ctx, "TeamService")
	ctx = ctxsetters.WithMethodName(ctx, "RemoveTeamBaseRepositoryScopeByName")
	caller := c.callRemoveTeamBaseRepositoryScopeByName
	if c.interceptor != nil {
		caller = func(ctx context.Context, req *RemoveTeamBaseRepositoryScopeByNameRequest) (*RemoveTeamBaseRepositoryScopeByNameResponse, error) {
			resp, err := c.interceptor(
				func(ctx context.Context, req interface{}) (interface{}, error) {
					typedReq, ok := req.(*RemoveTeamBaseRepositoryScopeByNameRequest)
					if !ok {
						return nil, twirp.InternalError("failed type assertion req.(*RemoveTeamBaseRepositoryScopeByNameRequest) when calling interceptor")
					}
					return c.callRemoveTeamBaseRepositoryScopeByName(ctx, typedReq)
				},
			)(ctx, req)
			if resp != nil {
				typedResp, ok := resp.(*RemoveTeamBaseRepositoryScopeByNameResponse)
				if !ok {
					return nil, twirp.InternalError("failed type assertion resp.(*RemoveTeamBaseRepositoryScopeByNameResponse) when calling interceptor")
				}
				return typedResp, err
			}
			return nil, err
		}
	}
	return caller(ctx, in)
}

func (c *teamServiceJSONClient) callRemoveTeamBaseRepositoryScopeByName(ctx context.Context, in *RemoveTeamBaseRepositoryScopeByNameRequest) (*RemoveTeamBaseRepositoryScopeByNameResponse, error) {
	out := new(RemoveTeamBaseRepositoryScopeByNameResponse)
	ctx, err := doJSONRequest(ctx, c.client, c.opts.Hooks, c.urls[19], in, out)
	if err != nil {
		twerr, ok := err.(twirp.Error)
		if !ok {
			twerr = twirp.InternalErrorWith(err)
		}
		callClientError(ctx, c.opts.Hooks, twerr)
		return nil, err
	}

	callClientResponseReceived(ctx, c.opts.Hooks)

	return out, nil
}

func (c *teamServiceJSONClient) AddTeamRepositoryScope(ctx context.Context, in *AddTeamRepositoryScopeRequest) (*AddTeamRepositoryScopeResponse, error) {
	ctx = ctxsetters.WithPackageName(ctx, "buf.alpha.registry.v1alpha1")
	ctx = ctxsetters.WithServiceName(ctx, "TeamService")
	ctx = ctxsetters.WithMethodName(ctx, "AddTeamRepositoryScope")
	caller := c.callAddTeamRepositoryScope
	if c.interceptor != nil {
		caller = func(ctx context.Context, req *AddTeamRepositoryScopeRequest) (*AddTeamRepositoryScopeResponse, error) {
			resp, err := c.interceptor(
				func(ctx context.Context, req interface{}) (interface{}, error) {
					typedReq, ok := req.(*AddTeamRepositoryScopeRequest)
					if !ok {
						return nil, twirp.InternalError("failed type assertion req.(*AddTeamRepositoryScopeRequest) when calling interceptor")
					}
					return c.callAddTeamRepositoryScope(ctx, typedReq)
				},
			)(ctx, req)
			if resp != nil {
				typedResp, ok := resp.(*AddTeamRepositoryScopeResponse)
				if !ok {
					return nil, twirp.InternalError("failed type assertion resp.(*AddTeamRepositoryScopeResponse) when calling interceptor")
				}
				return typedResp, err
			}
			return nil, err
		}
	}
	return caller(ctx, in)
}

func (c *teamServiceJSONClient) callAddTeamRepositoryScope(ctx context.Context, in *AddTeamRepositoryScopeRequest) (*AddTeamRepositoryScopeResponse, error) {
	out := new(AddTeamRepositoryScopeResponse)
	ctx, err := doJSONRequest(ctx, c.client, c.opts.Hooks, c.urls[20], in, out)
	if err != nil {
		twerr, ok := err.(twirp.Error)
		if !ok {
			twerr = twirp.InternalErrorWith(err)
		}
		callClientError(ctx, c.opts.Hooks, twerr)
		return nil, err
	}

	callClientResponseReceived(ctx, c.opts.Hooks)

	return out, nil
}

func (c *teamServiceJSONClient) AddTeamRepositoryScopeByName(ctx context.Context, in *AddTeamRepositoryScopeByNameRequest) (*AddTeamRepositoryScopeByNameResponse, error) {
	ctx = ctxsetters.WithPackageName(ctx, "buf.alpha.registry.v1alpha1")
	ctx = ctxsetters.WithServiceName(ctx, "TeamService")
	ctx = ctxsetters.WithMethodName(ctx, "AddTeamRepositoryScopeByName")
	caller := c.callAddTeamRepositoryScopeByName
	if c.interceptor != nil {
		caller = func(ctx context.Context, req *AddTeamRepositoryScopeByNameRequest) (*AddTeamRepositoryScopeByNameResponse, error) {
			resp, err := c.interceptor(
				func(ctx context.Context, req interface{}) (interface{}, error) {
					typedReq, ok := req.(*AddTeamRepositoryScopeByNameRequest)
					if !ok {
						return nil, twirp.InternalError("failed type assertion req.(*AddTeamRepositoryScopeByNameRequest) when calling interceptor")
					}
					return c.callAddTeamRepositoryScopeByName(ctx, typedReq)
				},
			)(ctx, req)
			if resp != nil {
				typedResp, ok := resp.(*AddTeamRepositoryScopeByNameResponse)
				if !ok {
					return nil, twirp.InternalError("failed type assertion resp.(*AddTeamRepositoryScopeByNameResponse) when calling interceptor")
				}
				return typedResp, err
			}
			return nil, err
		}
	}
	return caller(ctx, in)
}

func (c *teamServiceJSONClient) callAddTeamRepositoryScopeByName(ctx context.Context, in *AddTeamRepositoryScopeByNameRequest) (*AddTeamRepositoryScopeByNameResponse, error) {
	out := new(AddTeamRepositoryScopeByNameResponse)
	ctx, err := doJSONRequest(ctx, c.client, c.opts.Hooks, c.urls[21], in, out)
	if err != nil {
		twerr, ok := err.(twirp.Error)
		if !ok {
			twerr = twirp.InternalErrorWith(err)
		}
		callClientError(ctx, c.opts.Hooks, twerr)
		return nil, err
	}

	callClientResponseReceived(ctx, c.opts.Hooks)

	return out, nil
}

func (c *teamServiceJSONClient) RemoveTeamRepositoryScope(ctx context.Context, in *RemoveTeamRepositoryScopeRequest) (*RemoveTeamRepositoryScopeResponse, error) {
	ctx = ctxsetters.WithPackageName(ctx, "buf.alpha.registry.v1alpha1")
	ctx = ctxsetters.WithServiceName(ctx, "TeamService")
	ctx = ctxsetters.WithMethodName(ctx, "RemoveTeamRepositoryScope")
	caller := c.callRemoveTeamRepositoryScope
	if c.interceptor != nil {
		caller = func(ctx context.Context, req *RemoveTeamRepositoryScopeRequest) (*RemoveTeamRepositoryScopeResponse, error) {
			resp, err := c.interceptor(
				func(ctx context.Context, req interface{}) (interface{}, error) {
					typedReq, ok := req.(*RemoveTeamRepositoryScopeRequest)
					if !ok {
						return nil, twirp.InternalError("failed type assertion req.(*RemoveTeamRepositoryScopeRequest) when calling interceptor")
					}
					return c.callRemoveTeamRepositoryScope(ctx, typedReq)
				},
			)(ctx, req)
			if resp != nil {
				typedResp, ok := resp.(*RemoveTeamRepositoryScopeResponse)
				if !ok {
					return nil, twirp.InternalError("failed type assertion resp.(*RemoveTeamRepositoryScopeResponse) when calling interceptor")
				}
				return typedResp, err
			}
			return nil, err
		}
	}
	return caller(ctx, in)
}

func (c *teamServiceJSONClient) callRemoveTeamRepositoryScope(ctx context.Context, in *RemoveTeamRepositoryScopeRequest) (*RemoveTeamRepositoryScopeResponse, error) {
	out := new(RemoveTeamRepositoryScopeResponse)
	ctx, err := doJSONRequest(ctx, c.client, c.opts.Hooks, c.urls[22], in, out)
	if err != nil {
		twerr, ok := err.(twirp.Error)
		if !ok {
			twerr = twirp.InternalErrorWith(err)
		}
		callClientError(ctx, c.opts.Hooks, twerr)
		return nil, err
	}

	callClientResponseReceived(ctx, c.opts.Hooks)

	return out, nil
}

func (c *teamServiceJSONClient) RemoveTeamRepositoryScopeByName(ctx context.Context, in *RemoveTeamRepositoryScopeByNameRequest) (*RemoveTeamRepositoryScopeByNameResponse, error) {
	ctx = ctxsetters.WithPackageName(ctx, "buf.alpha.registry.v1alpha1")
	ctx = ctxsetters.WithServiceName(ctx, "TeamService")
	ctx = ctxsetters.WithMethodName(ctx, "RemoveTeamRepositoryScopeByName")
	caller := c.callRemoveTeamRepositoryScopeByName
	if c.interceptor != nil {
		caller = func(ctx context.Context, req *RemoveTeamRepositoryScopeByNameRequest) (*RemoveTeamRepositoryScopeByNameResponse, error) {
			resp, err := c.interceptor(
				func(ctx context.Context, req interface{}) (interface{}, error) {
					typedReq, ok := req.(*RemoveTeamRepositoryScopeByNameRequest)
					if !ok {
						return nil, twirp.InternalError("failed type assertion req.(*RemoveTeamRepositoryScopeByNameRequest) when calling interceptor")
					}
					return c.callRemoveTeamRepositoryScopeByName(ctx, typedReq)
				},
			)(ctx, req)
			if resp != nil {
				typedResp, ok := resp.(*RemoveTeamRepositoryScopeByNameResponse)
				if !ok {
					return nil, twirp.InternalError("failed type assertion resp.(*RemoveTeamRepositoryScopeByNameResponse) when calling interceptor")
				}
				return typedResp, err
			}
			return nil, err
		}
	}
	return caller(ctx, in)
}

func (c *teamServiceJSONClient) callRemoveTeamRepositoryScopeByName(ctx context.Context, in *RemoveTeamRepositoryScopeByNameRequest) (*RemoveTeamRepositoryScopeByNameResponse, error) {
	out := new(RemoveTeamRepositoryScopeByNameResponse)
	ctx, err := doJSONRequest(ctx, c.client, c.opts.Hooks, c.urls[23], in, out)
	if err != nil {
		twerr, ok := err.(twirp.Error)
		if !ok {
			twerr = twirp.InternalErrorWith(err)
		}
		callClientError(ctx, c.opts.Hooks, twerr)
		return nil, err
	}

	callClientResponseReceived(ctx, c.opts.Hooks)

	return out, nil
}

// ==========================
// TeamService Server Handler
// ==========================

type teamServiceServer struct {
	TeamService
	interceptor      twirp.Interceptor
	hooks            *twirp.ServerHooks
	pathPrefix       string // prefix for routing
	jsonSkipDefaults bool   // do not include unpopulated fields (default values) in the response
	jsonCamelCase    bool   // JSON fields are serialized as lowerCamelCase rather than keeping the original proto names
}

// NewTeamServiceServer builds a TwirpServer that can be used as an http.Handler to handle
// HTTP requests that are routed to the right method in the provided svc implementation.
// The opts are twirp.ServerOption modifiers, for example twirp.WithServerHooks(hooks).
func NewTeamServiceServer(svc TeamService, opts ...interface{}) TwirpServer {
	serverOpts := newServerOpts(opts)

	// Using ReadOpt allows backwards and forwads compatibility with new options in the future
	jsonSkipDefaults := false
	_ = serverOpts.ReadOpt("jsonSkipDefaults", &jsonSkipDefaults)
	jsonCamelCase := false
	_ = serverOpts.ReadOpt("jsonCamelCase", &jsonCamelCase)
	var pathPrefix string
	if ok := serverOpts.ReadOpt("pathPrefix", &pathPrefix); !ok {
		pathPrefix = "/twirp" // default prefix
	}

	return &teamServiceServer{
		TeamService:      svc,
		hooks:            serverOpts.Hooks,
		interceptor:      twirp.ChainInterceptors(serverOpts.Interceptors...),
		pathPrefix:       pathPrefix,
		jsonSkipDefaults: jsonSkipDefaults,
		jsonCamelCase:    jsonCamelCase,
	}
}

// writeError writes an HTTP response with a valid Twirp error format, and triggers hooks.
// If err is not a twirp.Error, it will get wrapped with twirp.InternalErrorWith(err)
func (s *teamServiceServer) writeError(ctx context.Context, resp http.ResponseWriter, err error) {
	writeError(ctx, resp, err, s.hooks)
}

// handleRequestBodyError is used to handle error when the twirp server cannot read request
func (s *teamServiceServer) handleRequestBodyError(ctx context.Context, resp http.ResponseWriter, msg string, err error) {
	if context.Canceled == ctx.Err() {
		s.writeError(ctx, resp, twirp.NewError(twirp.Canceled, "failed to read request: context canceled"))
		return
	}
	if context.DeadlineExceeded == ctx.Err() {
		s.writeError(ctx, resp, twirp.NewError(twirp.DeadlineExceeded, "failed to read request: deadline exceeded"))
		return
	}
	s.writeError(ctx, resp, twirp.WrapError(malformedRequestError(msg), err))
}

// TeamServicePathPrefix is a convenience constant that may identify URL paths.
// Should be used with caution, it only matches routes generated by Twirp Go clients,
// with the default "/twirp" prefix and default CamelCase service and method names.
// More info: https://twitchtv.github.io/twirp/docs/routing.html
const TeamServicePathPrefix = "/twirp/buf.alpha.registry.v1alpha1.TeamService/"

func (s *teamServiceServer) ServeHTTP(resp http.ResponseWriter, req *http.Request) {
	ctx := req.Context()
	ctx = ctxsetters.WithPackageName(ctx, "buf.alpha.registry.v1alpha1")
	ctx = ctxsetters.WithServiceName(ctx, "TeamService")
	ctx = ctxsetters.WithResponseWriter(ctx, resp)

	var err error
	ctx, err = callRequestReceived(ctx, s.hooks)
	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}

	if req.Method != "POST" {
		msg := fmt.Sprintf("unsupported method %q (only POST is allowed)", req.Method)
		s.writeError(ctx, resp, badRouteError(msg, req.Method, req.URL.Path))
		return
	}

	// Verify path format: [<prefix>]/<package>.<Service>/<Method>
	prefix, pkgService, method := parseTwirpPath(req.URL.Path)
	if pkgService != "buf.alpha.registry.v1alpha1.TeamService" {
		msg := fmt.Sprintf("no handler for path %q", req.URL.Path)
		s.writeError(ctx, resp, badRouteError(msg, req.Method, req.URL.Path))
		return
	}
	if prefix != s.pathPrefix {
		msg := fmt.Sprintf("invalid path prefix %q, expected %q, on path %q", prefix, s.pathPrefix, req.URL.Path)
		s.writeError(ctx, resp, badRouteError(msg, req.Method, req.URL.Path))
		return
	}

	switch method {
	case "GetTeam":
		s.serveGetTeam(ctx, resp, req)
		return
	case "GetTeamByName":
		s.serveGetTeamByName(ctx, resp, req)
		return
	case "ListOrganizationTeams":
		s.serveListOrganizationTeams(ctx, resp, req)
		return
	case "CreateTeam":
		s.serveCreateTeam(ctx, resp, req)
		return
	case "CreateTeamByName":
		s.serveCreateTeamByName(ctx, resp, req)
		return
	case "UpdateTeamName":
		s.serveUpdateTeamName(ctx, resp, req)
		return
	case "AddUserToTeam":
		s.serveAddUserToTeam(ctx, resp, req)
		return
	case "AddUserToTeamByName":
		s.serveAddUserToTeamByName(ctx, resp, req)
		return
	case "RemoveUserFromTeam":
		s.serveRemoveUserFromTeam(ctx, resp, req)
		return
	case "RemoveUserFromTeamByName":
		s.serveRemoveUserFromTeamByName(ctx, resp, req)
		return
	case "DeleteTeam":
		s.serveDeleteTeam(ctx, resp, req)
		return
	case "DeleteTeamByName":
		s.serveDeleteTeamByName(ctx, resp, req)
		return
	case "AddTeamOrganizationScope":
		s.serveAddTeamOrganizationScope(ctx, resp, req)
		return
	case "AddTeamOrganizationScopeByName":
		s.serveAddTeamOrganizationScopeByName(ctx, resp, req)
		return
	case "RemoveTeamOrganizationScope":
		s.serveRemoveTeamOrganizationScope(ctx, resp, req)
		return
	case "RemoveTeamOrganizationScopeByName":
		s.serveRemoveTeamOrganizationScopeByName(ctx, resp, req)
		return
	case "AddTeamBaseRepositoryScope":
		s.serveAddTeamBaseRepositoryScope(ctx, resp, req)
		return
	case "AddTeamBaseRepositoryScopeByName":
		s.serveAddTeamBaseRepositoryScopeByName(ctx, resp, req)
		return
	case "RemoveTeamBaseRepositoryScope":
		s.serveRemoveTeamBaseRepositoryScope(ctx, resp, req)
		return
	case "RemoveTeamBaseRepositoryScopeByName":
		s.serveRemoveTeamBaseRepositoryScopeByName(ctx, resp, req)
		return
	case "AddTeamRepositoryScope":
		s.serveAddTeamRepositoryScope(ctx, resp, req)
		return
	case "AddTeamRepositoryScopeByName":
		s.serveAddTeamRepositoryScopeByName(ctx, resp, req)
		return
	case "RemoveTeamRepositoryScope":
		s.serveRemoveTeamRepositoryScope(ctx, resp, req)
		return
	case "RemoveTeamRepositoryScopeByName":
		s.serveRemoveTeamRepositoryScopeByName(ctx, resp, req)
		return
	default:
		msg := fmt.Sprintf("no handler for path %q", req.URL.Path)
		s.writeError(ctx, resp, badRouteError(msg, req.Method, req.URL.Path))
		return
	}
}

func (s *teamServiceServer) serveGetTeam(ctx context.Context, resp http.ResponseWriter, req *http.Request) {
	header := req.Header.Get("Content-Type")
	i := strings.Index(header, ";")
	if i == -1 {
		i = len(header)
	}
	switch strings.TrimSpace(strings.ToLower(header[:i])) {
	case "application/json":
		s.serveGetTeamJSON(ctx, resp, req)
	case "application/protobuf":
		s.serveGetTeamProtobuf(ctx, resp, req)
	default:
		msg := fmt.Sprintf("unexpected Content-Type: %q", req.Header.Get("Content-Type"))
		twerr := badRouteError(msg, req.Method, req.URL.Path)
		s.writeError(ctx, resp, twerr)
	}
}

func (s *teamServiceServer) serveGetTeamJSON(ctx context.Context, resp http.ResponseWriter, req *http.Request) {
	var err error
	ctx = ctxsetters.WithMethodName(ctx, "GetTeam")
	ctx, err = callRequestRouted(ctx, s.hooks)
	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}

	d := json.NewDecoder(req.Body)
	rawReqBody := json.RawMessage{}
	if err := d.Decode(&rawReqBody); err != nil {
		s.handleRequestBodyError(ctx, resp, "the json request could not be decoded", err)
		return
	}
	reqContent := new(GetTeamRequest)
	unmarshaler := protojson.UnmarshalOptions{DiscardUnknown: true}
	if err = unmarshaler.Unmarshal(rawReqBody, reqContent); err != nil {
		s.handleRequestBodyError(ctx, resp, "the json request could not be decoded", err)
		return
	}

	handler := s.TeamService.GetTeam
	if s.interceptor != nil {
		handler = func(ctx context.Context, req *GetTeamRequest) (*GetTeamResponse, error) {
			resp, err := s.interceptor(
				func(ctx context.Context, req interface{}) (interface{}, error) {
					typedReq, ok := req.(*GetTeamRequest)
					if !ok {
						return nil, twirp.InternalError("failed type assertion req.(*GetTeamRequest) when calling interceptor")
					}
					return s.TeamService.GetTeam(ctx, typedReq)
				},
			)(ctx, req)
			if resp != nil {
				typedResp, ok := resp.(*GetTeamResponse)
				if !ok {
					return nil, twirp.InternalError("failed type assertion resp.(*GetTeamResponse) when calling interceptor")
				}
				return typedResp, err
			}
			return nil, err
		}
	}

	// Call service method
	var respContent *GetTeamResponse
	func() {
		defer ensurePanicResponses(ctx, resp, s.hooks)
		respContent, err = handler(ctx, reqContent)
	}()

	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}
	if respContent == nil {
		s.writeError(ctx, resp, twirp.InternalError("received a nil *GetTeamResponse and nil error while calling GetTeam. nil responses are not supported"))
		return
	}

	ctx = callResponsePrepared(ctx, s.hooks)

	marshaler := &protojson.MarshalOptions{UseProtoNames: !s.jsonCamelCase, EmitUnpopulated: !s.jsonSkipDefaults}
	respBytes, err := marshaler.Marshal(respContent)
	if err != nil {
		s.writeError(ctx, resp, wrapInternal(err, "failed to marshal json response"))
		return
	}

	ctx = ctxsetters.WithStatusCode(ctx, http.StatusOK)
	resp.Header().Set("Content-Type", "application/json")
	resp.Header().Set("Content-Length", strconv.Itoa(len(respBytes)))
	resp.WriteHeader(http.StatusOK)

	if n, err := resp.Write(respBytes); err != nil {
		msg := fmt.Sprintf("failed to write response, %d of %d bytes written: %s", n, len(respBytes), err.Error())
		twerr := twirp.NewError(twirp.Unknown, msg)
		ctx = callError(ctx, s.hooks, twerr)
	}
	callResponseSent(ctx, s.hooks)
}

func (s *teamServiceServer) serveGetTeamProtobuf(ctx context.Context, resp http.ResponseWriter, req *http.Request) {
	var err error
	ctx = ctxsetters.WithMethodName(ctx, "GetTeam")
	ctx, err = callRequestRouted(ctx, s.hooks)
	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}

	buf, err := ioutil.ReadAll(req.Body)
	if err != nil {
		s.handleRequestBodyError(ctx, resp, "failed to read request body", err)
		return
	}
	reqContent := new(GetTeamRequest)
	if err = proto.Unmarshal(buf, reqContent); err != nil {
		s.writeError(ctx, resp, malformedRequestError("the protobuf request could not be decoded"))
		return
	}

	handler := s.TeamService.GetTeam
	if s.interceptor != nil {
		handler = func(ctx context.Context, req *GetTeamRequest) (*GetTeamResponse, error) {
			resp, err := s.interceptor(
				func(ctx context.Context, req interface{}) (interface{}, error) {
					typedReq, ok := req.(*GetTeamRequest)
					if !ok {
						return nil, twirp.InternalError("failed type assertion req.(*GetTeamRequest) when calling interceptor")
					}
					return s.TeamService.GetTeam(ctx, typedReq)
				},
			)(ctx, req)
			if resp != nil {
				typedResp, ok := resp.(*GetTeamResponse)
				if !ok {
					return nil, twirp.InternalError("failed type assertion resp.(*GetTeamResponse) when calling interceptor")
				}
				return typedResp, err
			}
			return nil, err
		}
	}

	// Call service method
	var respContent *GetTeamResponse
	func() {
		defer ensurePanicResponses(ctx, resp, s.hooks)
		respContent, err = handler(ctx, reqContent)
	}()

	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}
	if respContent == nil {
		s.writeError(ctx, resp, twirp.InternalError("received a nil *GetTeamResponse and nil error while calling GetTeam. nil responses are not supported"))
		return
	}

	ctx = callResponsePrepared(ctx, s.hooks)

	respBytes, err := proto.Marshal(respContent)
	if err != nil {
		s.writeError(ctx, resp, wrapInternal(err, "failed to marshal proto response"))
		return
	}

	ctx = ctxsetters.WithStatusCode(ctx, http.StatusOK)
	resp.Header().Set("Content-Type", "application/protobuf")
	resp.Header().Set("Content-Length", strconv.Itoa(len(respBytes)))
	resp.WriteHeader(http.StatusOK)
	if n, err := resp.Write(respBytes); err != nil {
		msg := fmt.Sprintf("failed to write response, %d of %d bytes written: %s", n, len(respBytes), err.Error())
		twerr := twirp.NewError(twirp.Unknown, msg)
		ctx = callError(ctx, s.hooks, twerr)
	}
	callResponseSent(ctx, s.hooks)
}

func (s *teamServiceServer) serveGetTeamByName(ctx context.Context, resp http.ResponseWriter, req *http.Request) {
	header := req.Header.Get("Content-Type")
	i := strings.Index(header, ";")
	if i == -1 {
		i = len(header)
	}
	switch strings.TrimSpace(strings.ToLower(header[:i])) {
	case "application/json":
		s.serveGetTeamByNameJSON(ctx, resp, req)
	case "application/protobuf":
		s.serveGetTeamByNameProtobuf(ctx, resp, req)
	default:
		msg := fmt.Sprintf("unexpected Content-Type: %q", req.Header.Get("Content-Type"))
		twerr := badRouteError(msg, req.Method, req.URL.Path)
		s.writeError(ctx, resp, twerr)
	}
}

func (s *teamServiceServer) serveGetTeamByNameJSON(ctx context.Context, resp http.ResponseWriter, req *http.Request) {
	var err error
	ctx = ctxsetters.WithMethodName(ctx, "GetTeamByName")
	ctx, err = callRequestRouted(ctx, s.hooks)
	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}

	d := json.NewDecoder(req.Body)
	rawReqBody := json.RawMessage{}
	if err := d.Decode(&rawReqBody); err != nil {
		s.handleRequestBodyError(ctx, resp, "the json request could not be decoded", err)
		return
	}
	reqContent := new(GetTeamByNameRequest)
	unmarshaler := protojson.UnmarshalOptions{DiscardUnknown: true}
	if err = unmarshaler.Unmarshal(rawReqBody, reqContent); err != nil {
		s.handleRequestBodyError(ctx, resp, "the json request could not be decoded", err)
		return
	}

	handler := s.TeamService.GetTeamByName
	if s.interceptor != nil {
		handler = func(ctx context.Context, req *GetTeamByNameRequest) (*GetTeamByNameResponse, error) {
			resp, err := s.interceptor(
				func(ctx context.Context, req interface{}) (interface{}, error) {
					typedReq, ok := req.(*GetTeamByNameRequest)
					if !ok {
						return nil, twirp.InternalError("failed type assertion req.(*GetTeamByNameRequest) when calling interceptor")
					}
					return s.TeamService.GetTeamByName(ctx, typedReq)
				},
			)(ctx, req)
			if resp != nil {
				typedResp, ok := resp.(*GetTeamByNameResponse)
				if !ok {
					return nil, twirp.InternalError("failed type assertion resp.(*GetTeamByNameResponse) when calling interceptor")
				}
				return typedResp, err
			}
			return nil, err
		}
	}

	// Call service method
	var respContent *GetTeamByNameResponse
	func() {
		defer ensurePanicResponses(ctx, resp, s.hooks)
		respContent, err = handler(ctx, reqContent)
	}()

	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}
	if respContent == nil {
		s.writeError(ctx, resp, twirp.InternalError("received a nil *GetTeamByNameResponse and nil error while calling GetTeamByName. nil responses are not supported"))
		return
	}

	ctx = callResponsePrepared(ctx, s.hooks)

	marshaler := &protojson.MarshalOptions{UseProtoNames: !s.jsonCamelCase, EmitUnpopulated: !s.jsonSkipDefaults}
	respBytes, err := marshaler.Marshal(respContent)
	if err != nil {
		s.writeError(ctx, resp, wrapInternal(err, "failed to marshal json response"))
		return
	}

	ctx = ctxsetters.WithStatusCode(ctx, http.StatusOK)
	resp.Header().Set("Content-Type", "application/json")
	resp.Header().Set("Content-Length", strconv.Itoa(len(respBytes)))
	resp.WriteHeader(http.StatusOK)

	if n, err := resp.Write(respBytes); err != nil {
		msg := fmt.Sprintf("failed to write response, %d of %d bytes written: %s", n, len(respBytes), err.Error())
		twerr := twirp.NewError(twirp.Unknown, msg)
		ctx = callError(ctx, s.hooks, twerr)
	}
	callResponseSent(ctx, s.hooks)
}

func (s *teamServiceServer) serveGetTeamByNameProtobuf(ctx context.Context, resp http.ResponseWriter, req *http.Request) {
	var err error
	ctx = ctxsetters.WithMethodName(ctx, "GetTeamByName")
	ctx, err = callRequestRouted(ctx, s.hooks)
	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}

	buf, err := ioutil.ReadAll(req.Body)
	if err != nil {
		s.handleRequestBodyError(ctx, resp, "failed to read request body", err)
		return
	}
	reqContent := new(GetTeamByNameRequest)
	if err = proto.Unmarshal(buf, reqContent); err != nil {
		s.writeError(ctx, resp, malformedRequestError("the protobuf request could not be decoded"))
		return
	}

	handler := s.TeamService.GetTeamByName
	if s.interceptor != nil {
		handler = func(ctx context.Context, req *GetTeamByNameRequest) (*GetTeamByNameResponse, error) {
			resp, err := s.interceptor(
				func(ctx context.Context, req interface{}) (interface{}, error) {
					typedReq, ok := req.(*GetTeamByNameRequest)
					if !ok {
						return nil, twirp.InternalError("failed type assertion req.(*GetTeamByNameRequest) when calling interceptor")
					}
					return s.TeamService.GetTeamByName(ctx, typedReq)
				},
			)(ctx, req)
			if resp != nil {
				typedResp, ok := resp.(*GetTeamByNameResponse)
				if !ok {
					return nil, twirp.InternalError("failed type assertion resp.(*GetTeamByNameResponse) when calling interceptor")
				}
				return typedResp, err
			}
			return nil, err
		}
	}

	// Call service method
	var respContent *GetTeamByNameResponse
	func() {
		defer ensurePanicResponses(ctx, resp, s.hooks)
		respContent, err = handler(ctx, reqContent)
	}()

	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}
	if respContent == nil {
		s.writeError(ctx, resp, twirp.InternalError("received a nil *GetTeamByNameResponse and nil error while calling GetTeamByName. nil responses are not supported"))
		return
	}

	ctx = callResponsePrepared(ctx, s.hooks)

	respBytes, err := proto.Marshal(respContent)
	if err != nil {
		s.writeError(ctx, resp, wrapInternal(err, "failed to marshal proto response"))
		return
	}

	ctx = ctxsetters.WithStatusCode(ctx, http.StatusOK)
	resp.Header().Set("Content-Type", "application/protobuf")
	resp.Header().Set("Content-Length", strconv.Itoa(len(respBytes)))
	resp.WriteHeader(http.StatusOK)
	if n, err := resp.Write(respBytes); err != nil {
		msg := fmt.Sprintf("failed to write response, %d of %d bytes written: %s", n, len(respBytes), err.Error())
		twerr := twirp.NewError(twirp.Unknown, msg)
		ctx = callError(ctx, s.hooks, twerr)
	}
	callResponseSent(ctx, s.hooks)
}

func (s *teamServiceServer) serveListOrganizationTeams(ctx context.Context, resp http.ResponseWriter, req *http.Request) {
	header := req.Header.Get("Content-Type")
	i := strings.Index(header, ";")
	if i == -1 {
		i = len(header)
	}
	switch strings.TrimSpace(strings.ToLower(header[:i])) {
	case "application/json":
		s.serveListOrganizationTeamsJSON(ctx, resp, req)
	case "application/protobuf":
		s.serveListOrganizationTeamsProtobuf(ctx, resp, req)
	default:
		msg := fmt.Sprintf("unexpected Content-Type: %q", req.Header.Get("Content-Type"))
		twerr := badRouteError(msg, req.Method, req.URL.Path)
		s.writeError(ctx, resp, twerr)
	}
}

func (s *teamServiceServer) serveListOrganizationTeamsJSON(ctx context.Context, resp http.ResponseWriter, req *http.Request) {
	var err error
	ctx = ctxsetters.WithMethodName(ctx, "ListOrganizationTeams")
	ctx, err = callRequestRouted(ctx, s.hooks)
	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}

	d := json.NewDecoder(req.Body)
	rawReqBody := json.RawMessage{}
	if err := d.Decode(&rawReqBody); err != nil {
		s.handleRequestBodyError(ctx, resp, "the json request could not be decoded", err)
		return
	}
	reqContent := new(ListOrganizationTeamsRequest)
	unmarshaler := protojson.UnmarshalOptions{DiscardUnknown: true}
	if err = unmarshaler.Unmarshal(rawReqBody, reqContent); err != nil {
		s.handleRequestBodyError(ctx, resp, "the json request could not be decoded", err)
		return
	}

	handler := s.TeamService.ListOrganizationTeams
	if s.interceptor != nil {
		handler = func(ctx context.Context, req *ListOrganizationTeamsRequest) (*ListOrganizationTeamsResponse, error) {
			resp, err := s.interceptor(
				func(ctx context.Context, req interface{}) (interface{}, error) {
					typedReq, ok := req.(*ListOrganizationTeamsRequest)
					if !ok {
						return nil, twirp.InternalError("failed type assertion req.(*ListOrganizationTeamsRequest) when calling interceptor")
					}
					return s.TeamService.ListOrganizationTeams(ctx, typedReq)
				},
			)(ctx, req)
			if resp != nil {
				typedResp, ok := resp.(*ListOrganizationTeamsResponse)
				if !ok {
					return nil, twirp.InternalError("failed type assertion resp.(*ListOrganizationTeamsResponse) when calling interceptor")
				}
				return typedResp, err
			}
			return nil, err
		}
	}

	// Call service method
	var respContent *ListOrganizationTeamsResponse
	func() {
		defer ensurePanicResponses(ctx, resp, s.hooks)
		respContent, err = handler(ctx, reqContent)
	}()

	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}
	if respContent == nil {
		s.writeError(ctx, resp, twirp.InternalError("received a nil *ListOrganizationTeamsResponse and nil error while calling ListOrganizationTeams. nil responses are not supported"))
		return
	}

	ctx = callResponsePrepared(ctx, s.hooks)

	marshaler := &protojson.MarshalOptions{UseProtoNames: !s.jsonCamelCase, EmitUnpopulated: !s.jsonSkipDefaults}
	respBytes, err := marshaler.Marshal(respContent)
	if err != nil {
		s.writeError(ctx, resp, wrapInternal(err, "failed to marshal json response"))
		return
	}

	ctx = ctxsetters.WithStatusCode(ctx, http.StatusOK)
	resp.Header().Set("Content-Type", "application/json")
	resp.Header().Set("Content-Length", strconv.Itoa(len(respBytes)))
	resp.WriteHeader(http.StatusOK)

	if n, err := resp.Write(respBytes); err != nil {
		msg := fmt.Sprintf("failed to write response, %d of %d bytes written: %s", n, len(respBytes), err.Error())
		twerr := twirp.NewError(twirp.Unknown, msg)
		ctx = callError(ctx, s.hooks, twerr)
	}
	callResponseSent(ctx, s.hooks)
}

func (s *teamServiceServer) serveListOrganizationTeamsProtobuf(ctx context.Context, resp http.ResponseWriter, req *http.Request) {
	var err error
	ctx = ctxsetters.WithMethodName(ctx, "ListOrganizationTeams")
	ctx, err = callRequestRouted(ctx, s.hooks)
	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}

	buf, err := ioutil.ReadAll(req.Body)
	if err != nil {
		s.handleRequestBodyError(ctx, resp, "failed to read request body", err)
		return
	}
	reqContent := new(ListOrganizationTeamsRequest)
	if err = proto.Unmarshal(buf, reqContent); err != nil {
		s.writeError(ctx, resp, malformedRequestError("the protobuf request could not be decoded"))
		return
	}

	handler := s.TeamService.ListOrganizationTeams
	if s.interceptor != nil {
		handler = func(ctx context.Context, req *ListOrganizationTeamsRequest) (*ListOrganizationTeamsResponse, error) {
			resp, err := s.interceptor(
				func(ctx context.Context, req interface{}) (interface{}, error) {
					typedReq, ok := req.(*ListOrganizationTeamsRequest)
					if !ok {
						return nil, twirp.InternalError("failed type assertion req.(*ListOrganizationTeamsRequest) when calling interceptor")
					}
					return s.TeamService.ListOrganizationTeams(ctx, typedReq)
				},
			)(ctx, req)
			if resp != nil {
				typedResp, ok := resp.(*ListOrganizationTeamsResponse)
				if !ok {
					return nil, twirp.InternalError("failed type assertion resp.(*ListOrganizationTeamsResponse) when calling interceptor")
				}
				return typedResp, err
			}
			return nil, err
		}
	}

	// Call service method
	var respContent *ListOrganizationTeamsResponse
	func() {
		defer ensurePanicResponses(ctx, resp, s.hooks)
		respContent, err = handler(ctx, reqContent)
	}()

	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}
	if respContent == nil {
		s.writeError(ctx, resp, twirp.InternalError("received a nil *ListOrganizationTeamsResponse and nil error while calling ListOrganizationTeams. nil responses are not supported"))
		return
	}

	ctx = callResponsePrepared(ctx, s.hooks)

	respBytes, err := proto.Marshal(respContent)
	if err != nil {
		s.writeError(ctx, resp, wrapInternal(err, "failed to marshal proto response"))
		return
	}

	ctx = ctxsetters.WithStatusCode(ctx, http.StatusOK)
	resp.Header().Set("Content-Type", "application/protobuf")
	resp.Header().Set("Content-Length", strconv.Itoa(len(respBytes)))
	resp.WriteHeader(http.StatusOK)
	if n, err := resp.Write(respBytes); err != nil {
		msg := fmt.Sprintf("failed to write response, %d of %d bytes written: %s", n, len(respBytes), err.Error())
		twerr := twirp.NewError(twirp.Unknown, msg)
		ctx = callError(ctx, s.hooks, twerr)
	}
	callResponseSent(ctx, s.hooks)
}

func (s *teamServiceServer) serveCreateTeam(ctx context.Context, resp http.ResponseWriter, req *http.Request) {
	header := req.Header.Get("Content-Type")
	i := strings.Index(header, ";")
	if i == -1 {
		i = len(header)
	}
	switch strings.TrimSpace(strings.ToLower(header[:i])) {
	case "application/json":
		s.serveCreateTeamJSON(ctx, resp, req)
	case "application/protobuf":
		s.serveCreateTeamProtobuf(ctx, resp, req)
	default:
		msg := fmt.Sprintf("unexpected Content-Type: %q", req.Header.Get("Content-Type"))
		twerr := badRouteError(msg, req.Method, req.URL.Path)
		s.writeError(ctx, resp, twerr)
	}
}

func (s *teamServiceServer) serveCreateTeamJSON(ctx context.Context, resp http.ResponseWriter, req *http.Request) {
	var err error
	ctx = ctxsetters.WithMethodName(ctx, "CreateTeam")
	ctx, err = callRequestRouted(ctx, s.hooks)
	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}

	d := json.NewDecoder(req.Body)
	rawReqBody := json.RawMessage{}
	if err := d.Decode(&rawReqBody); err != nil {
		s.handleRequestBodyError(ctx, resp, "the json request could not be decoded", err)
		return
	}
	reqContent := new(CreateTeamRequest)
	unmarshaler := protojson.UnmarshalOptions{DiscardUnknown: true}
	if err = unmarshaler.Unmarshal(rawReqBody, reqContent); err != nil {
		s.handleRequestBodyError(ctx, resp, "the json request could not be decoded", err)
		return
	}

	handler := s.TeamService.CreateTeam
	if s.interceptor != nil {
		handler = func(ctx context.Context, req *CreateTeamRequest) (*CreateTeamResponse, error) {
			resp, err := s.interceptor(
				func(ctx context.Context, req interface{}) (interface{}, error) {
					typedReq, ok := req.(*CreateTeamRequest)
					if !ok {
						return nil, twirp.InternalError("failed type assertion req.(*CreateTeamRequest) when calling interceptor")
					}
					return s.TeamService.CreateTeam(ctx, typedReq)
				},
			)(ctx, req)
			if resp != nil {
				typedResp, ok := resp.(*CreateTeamResponse)
				if !ok {
					return nil, twirp.InternalError("failed type assertion resp.(*CreateTeamResponse) when calling interceptor")
				}
				return typedResp, err
			}
			return nil, err
		}
	}

	// Call service method
	var respContent *CreateTeamResponse
	func() {
		defer ensurePanicResponses(ctx, resp, s.hooks)
		respContent, err = handler(ctx, reqContent)
	}()

	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}
	if respContent == nil {
		s.writeError(ctx, resp, twirp.InternalError("received a nil *CreateTeamResponse and nil error while calling CreateTeam. nil responses are not supported"))
		return
	}

	ctx = callResponsePrepared(ctx, s.hooks)

	marshaler := &protojson.MarshalOptions{UseProtoNames: !s.jsonCamelCase, EmitUnpopulated: !s.jsonSkipDefaults}
	respBytes, err := marshaler.Marshal(respContent)
	if err != nil {
		s.writeError(ctx, resp, wrapInternal(err, "failed to marshal json response"))
		return
	}

	ctx = ctxsetters.WithStatusCode(ctx, http.StatusOK)
	resp.Header().Set("Content-Type", "application/json")
	resp.Header().Set("Content-Length", strconv.Itoa(len(respBytes)))
	resp.WriteHeader(http.StatusOK)

	if n, err := resp.Write(respBytes); err != nil {
		msg := fmt.Sprintf("failed to write response, %d of %d bytes written: %s", n, len(respBytes), err.Error())
		twerr := twirp.NewError(twirp.Unknown, msg)
		ctx = callError(ctx, s.hooks, twerr)
	}
	callResponseSent(ctx, s.hooks)
}

func (s *teamServiceServer) serveCreateTeamProtobuf(ctx context.Context, resp http.ResponseWriter, req *http.Request) {
	var err error
	ctx = ctxsetters.WithMethodName(ctx, "CreateTeam")
	ctx, err = callRequestRouted(ctx, s.hooks)
	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}

	buf, err := ioutil.ReadAll(req.Body)
	if err != nil {
		s.handleRequestBodyError(ctx, resp, "failed to read request body", err)
		return
	}
	reqContent := new(CreateTeamRequest)
	if err = proto.Unmarshal(buf, reqContent); err != nil {
		s.writeError(ctx, resp, malformedRequestError("the protobuf request could not be decoded"))
		return
	}

	handler := s.TeamService.CreateTeam
	if s.interceptor != nil {
		handler = func(ctx context.Context, req *CreateTeamRequest) (*CreateTeamResponse, error) {
			resp, err := s.interceptor(
				func(ctx context.Context, req interface{}) (interface{}, error) {
					typedReq, ok := req.(*CreateTeamRequest)
					if !ok {
						return nil, twirp.InternalError("failed type assertion req.(*CreateTeamRequest) when calling interceptor")
					}
					return s.TeamService.CreateTeam(ctx, typedReq)
				},
			)(ctx, req)
			if resp != nil {
				typedResp, ok := resp.(*CreateTeamResponse)
				if !ok {
					return nil, twirp.InternalError("failed type assertion resp.(*CreateTeamResponse) when calling interceptor")
				}
				return typedResp, err
			}
			return nil, err
		}
	}

	// Call service method
	var respContent *CreateTeamResponse
	func() {
		defer ensurePanicResponses(ctx, resp, s.hooks)
		respContent, err = handler(ctx, reqContent)
	}()

	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}
	if respContent == nil {
		s.writeError(ctx, resp, twirp.InternalError("received a nil *CreateTeamResponse and nil error while calling CreateTeam. nil responses are not supported"))
		return
	}

	ctx = callResponsePrepared(ctx, s.hooks)

	respBytes, err := proto.Marshal(respContent)
	if err != nil {
		s.writeError(ctx, resp, wrapInternal(err, "failed to marshal proto response"))
		return
	}

	ctx = ctxsetters.WithStatusCode(ctx, http.StatusOK)
	resp.Header().Set("Content-Type", "application/protobuf")
	resp.Header().Set("Content-Length", strconv.Itoa(len(respBytes)))
	resp.WriteHeader(http.StatusOK)
	if n, err := resp.Write(respBytes); err != nil {
		msg := fmt.Sprintf("failed to write response, %d of %d bytes written: %s", n, len(respBytes), err.Error())
		twerr := twirp.NewError(twirp.Unknown, msg)
		ctx = callError(ctx, s.hooks, twerr)
	}
	callResponseSent(ctx, s.hooks)
}

func (s *teamServiceServer) serveCreateTeamByName(ctx context.Context, resp http.ResponseWriter, req *http.Request) {
	header := req.Header.Get("Content-Type")
	i := strings.Index(header, ";")
	if i == -1 {
		i = len(header)
	}
	switch strings.TrimSpace(strings.ToLower(header[:i])) {
	case "application/json":
		s.serveCreateTeamByNameJSON(ctx, resp, req)
	case "application/protobuf":
		s.serveCreateTeamByNameProtobuf(ctx, resp, req)
	default:
		msg := fmt.Sprintf("unexpected Content-Type: %q", req.Header.Get("Content-Type"))
		twerr := badRouteError(msg, req.Method, req.URL.Path)
		s.writeError(ctx, resp, twerr)
	}
}

func (s *teamServiceServer) serveCreateTeamByNameJSON(ctx context.Context, resp http.ResponseWriter, req *http.Request) {
	var err error
	ctx = ctxsetters.WithMethodName(ctx, "CreateTeamByName")
	ctx, err = callRequestRouted(ctx, s.hooks)
	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}

	d := json.NewDecoder(req.Body)
	rawReqBody := json.RawMessage{}
	if err := d.Decode(&rawReqBody); err != nil {
		s.handleRequestBodyError(ctx, resp, "the json request could not be decoded", err)
		return
	}
	reqContent := new(CreateTeamByNameRequest)
	unmarshaler := protojson.UnmarshalOptions{DiscardUnknown: true}
	if err = unmarshaler.Unmarshal(rawReqBody, reqContent); err != nil {
		s.handleRequestBodyError(ctx, resp, "the json request could not be decoded", err)
		return
	}

	handler := s.TeamService.CreateTeamByName
	if s.interceptor != nil {
		handler = func(ctx context.Context, req *CreateTeamByNameRequest) (*CreateTeamByNameResponse, error) {
			resp, err := s.interceptor(
				func(ctx context.Context, req interface{}) (interface{}, error) {
					typedReq, ok := req.(*CreateTeamByNameRequest)
					if !ok {
						return nil, twirp.InternalError("failed type assertion req.(*CreateTeamByNameRequest) when calling interceptor")
					}
					return s.TeamService.CreateTeamByName(ctx, typedReq)
				},
			)(ctx, req)
			if resp != nil {
				typedResp, ok := resp.(*CreateTeamByNameResponse)
				if !ok {
					return nil, twirp.InternalError("failed type assertion resp.(*CreateTeamByNameResponse) when calling interceptor")
				}
				return typedResp, err
			}
			return nil, err
		}
	}

	// Call service method
	var respContent *CreateTeamByNameResponse
	func() {
		defer ensurePanicResponses(ctx, resp, s.hooks)
		respContent, err = handler(ctx, reqContent)
	}()

	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}
	if respContent == nil {
		s.writeError(ctx, resp, twirp.InternalError("received a nil *CreateTeamByNameResponse and nil error while calling CreateTeamByName. nil responses are not supported"))
		return
	}

	ctx = callResponsePrepared(ctx, s.hooks)

	marshaler := &protojson.MarshalOptions{UseProtoNames: !s.jsonCamelCase, EmitUnpopulated: !s.jsonSkipDefaults}
	respBytes, err := marshaler.Marshal(respContent)
	if err != nil {
		s.writeError(ctx, resp, wrapInternal(err, "failed to marshal json response"))
		return
	}

	ctx = ctxsetters.WithStatusCode(ctx, http.StatusOK)
	resp.Header().Set("Content-Type", "application/json")
	resp.Header().Set("Content-Length", strconv.Itoa(len(respBytes)))
	resp.WriteHeader(http.StatusOK)

	if n, err := resp.Write(respBytes); err != nil {
		msg := fmt.Sprintf("failed to write response, %d of %d bytes written: %s", n, len(respBytes), err.Error())
		twerr := twirp.NewError(twirp.Unknown, msg)
		ctx = callError(ctx, s.hooks, twerr)
	}
	callResponseSent(ctx, s.hooks)
}

func (s *teamServiceServer) serveCreateTeamByNameProtobuf(ctx context.Context, resp http.ResponseWriter, req *http.Request) {
	var err error
	ctx = ctxsetters.WithMethodName(ctx, "CreateTeamByName")
	ctx, err = callRequestRouted(ctx, s.hooks)
	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}

	buf, err := ioutil.ReadAll(req.Body)
	if err != nil {
		s.handleRequestBodyError(ctx, resp, "failed to read request body", err)
		return
	}
	reqContent := new(CreateTeamByNameRequest)
	if err = proto.Unmarshal(buf, reqContent); err != nil {
		s.writeError(ctx, resp, malformedRequestError("the protobuf request could not be decoded"))
		return
	}

	handler := s.TeamService.CreateTeamByName
	if s.interceptor != nil {
		handler = func(ctx context.Context, req *CreateTeamByNameRequest) (*CreateTeamByNameResponse, error) {
			resp, err := s.interceptor(
				func(ctx context.Context, req interface{}) (interface{}, error) {
					typedReq, ok := req.(*CreateTeamByNameRequest)
					if !ok {
						return nil, twirp.InternalError("failed type assertion req.(*CreateTeamByNameRequest) when calling interceptor")
					}
					return s.TeamService.CreateTeamByName(ctx, typedReq)
				},
			)(ctx, req)
			if resp != nil {
				typedResp, ok := resp.(*CreateTeamByNameResponse)
				if !ok {
					return nil, twirp.InternalError("failed type assertion resp.(*CreateTeamByNameResponse) when calling interceptor")
				}
				return typedResp, err
			}
			return nil, err
		}
	}

	// Call service method
	var respContent *CreateTeamByNameResponse
	func() {
		defer ensurePanicResponses(ctx, resp, s.hooks)
		respContent, err = handler(ctx, reqContent)
	}()

	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}
	if respContent == nil {
		s.writeError(ctx, resp, twirp.InternalError("received a nil *CreateTeamByNameResponse and nil error while calling CreateTeamByName. nil responses are not supported"))
		return
	}

	ctx = callResponsePrepared(ctx, s.hooks)

	respBytes, err := proto.Marshal(respContent)
	if err != nil {
		s.writeError(ctx, resp, wrapInternal(err, "failed to marshal proto response"))
		return
	}

	ctx = ctxsetters.WithStatusCode(ctx, http.StatusOK)
	resp.Header().Set("Content-Type", "application/protobuf")
	resp.Header().Set("Content-Length", strconv.Itoa(len(respBytes)))
	resp.WriteHeader(http.StatusOK)
	if n, err := resp.Write(respBytes); err != nil {
		msg := fmt.Sprintf("failed to write response, %d of %d bytes written: %s", n, len(respBytes), err.Error())
		twerr := twirp.NewError(twirp.Unknown, msg)
		ctx = callError(ctx, s.hooks, twerr)
	}
	callResponseSent(ctx, s.hooks)
}

func (s *teamServiceServer) serveUpdateTeamName(ctx context.Context, resp http.ResponseWriter, req *http.Request) {
	header := req.Header.Get("Content-Type")
	i := strings.Index(header, ";")
	if i == -1 {
		i = len(header)
	}
	switch strings.TrimSpace(strings.ToLower(header[:i])) {
	case "application/json":
		s.serveUpdateTeamNameJSON(ctx, resp, req)
	case "application/protobuf":
		s.serveUpdateTeamNameProtobuf(ctx, resp, req)
	default:
		msg := fmt.Sprintf("unexpected Content-Type: %q", req.Header.Get("Content-Type"))
		twerr := badRouteError(msg, req.Method, req.URL.Path)
		s.writeError(ctx, resp, twerr)
	}
}

func (s *teamServiceServer) serveUpdateTeamNameJSON(ctx context.Context, resp http.ResponseWriter, req *http.Request) {
	var err error
	ctx = ctxsetters.WithMethodName(ctx, "UpdateTeamName")
	ctx, err = callRequestRouted(ctx, s.hooks)
	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}

	d := json.NewDecoder(req.Body)
	rawReqBody := json.RawMessage{}
	if err := d.Decode(&rawReqBody); err != nil {
		s.handleRequestBodyError(ctx, resp, "the json request could not be decoded", err)
		return
	}
	reqContent := new(UpdateTeamNameRequest)
	unmarshaler := protojson.UnmarshalOptions{DiscardUnknown: true}
	if err = unmarshaler.Unmarshal(rawReqBody, reqContent); err != nil {
		s.handleRequestBodyError(ctx, resp, "the json request could not be decoded", err)
		return
	}

	handler := s.TeamService.UpdateTeamName
	if s.interceptor != nil {
		handler = func(ctx context.Context, req *UpdateTeamNameRequest) (*UpdateTeamNameResponse, error) {
			resp, err := s.interceptor(
				func(ctx context.Context, req interface{}) (interface{}, error) {
					typedReq, ok := req.(*UpdateTeamNameRequest)
					if !ok {
						return nil, twirp.InternalError("failed type assertion req.(*UpdateTeamNameRequest) when calling interceptor")
					}
					return s.TeamService.UpdateTeamName(ctx, typedReq)
				},
			)(ctx, req)
			if resp != nil {
				typedResp, ok := resp.(*UpdateTeamNameResponse)
				if !ok {
					return nil, twirp.InternalError("failed type assertion resp.(*UpdateTeamNameResponse) when calling interceptor")
				}
				return typedResp, err
			}
			return nil, err
		}
	}

	// Call service method
	var respContent *UpdateTeamNameResponse
	func() {
		defer ensurePanicResponses(ctx, resp, s.hooks)
		respContent, err = handler(ctx, reqContent)
	}()

	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}
	if respContent == nil {
		s.writeError(ctx, resp, twirp.InternalError("received a nil *UpdateTeamNameResponse and nil error while calling UpdateTeamName. nil responses are not supported"))
		return
	}

	ctx = callResponsePrepared(ctx, s.hooks)

	marshaler := &protojson.MarshalOptions{UseProtoNames: !s.jsonCamelCase, EmitUnpopulated: !s.jsonSkipDefaults}
	respBytes, err := marshaler.Marshal(respContent)
	if err != nil {
		s.writeError(ctx, resp, wrapInternal(err, "failed to marshal json response"))
		return
	}

	ctx = ctxsetters.WithStatusCode(ctx, http.StatusOK)
	resp.Header().Set("Content-Type", "application/json")
	resp.Header().Set("Content-Length", strconv.Itoa(len(respBytes)))
	resp.WriteHeader(http.StatusOK)

	if n, err := resp.Write(respBytes); err != nil {
		msg := fmt.Sprintf("failed to write response, %d of %d bytes written: %s", n, len(respBytes), err.Error())
		twerr := twirp.NewError(twirp.Unknown, msg)
		ctx = callError(ctx, s.hooks, twerr)
	}
	callResponseSent(ctx, s.hooks)
}

func (s *teamServiceServer) serveUpdateTeamNameProtobuf(ctx context.Context, resp http.ResponseWriter, req *http.Request) {
	var err error
	ctx = ctxsetters.WithMethodName(ctx, "UpdateTeamName")
	ctx, err = callRequestRouted(ctx, s.hooks)
	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}

	buf, err := ioutil.ReadAll(req.Body)
	if err != nil {
		s.handleRequestBodyError(ctx, resp, "failed to read request body", err)
		return
	}
	reqContent := new(UpdateTeamNameRequest)
	if err = proto.Unmarshal(buf, reqContent); err != nil {
		s.writeError(ctx, resp, malformedRequestError("the protobuf request could not be decoded"))
		return
	}

	handler := s.TeamService.UpdateTeamName
	if s.interceptor != nil {
		handler = func(ctx context.Context, req *UpdateTeamNameRequest) (*UpdateTeamNameResponse, error) {
			resp, err := s.interceptor(
				func(ctx context.Context, req interface{}) (interface{}, error) {
					typedReq, ok := req.(*UpdateTeamNameRequest)
					if !ok {
						return nil, twirp.InternalError("failed type assertion req.(*UpdateTeamNameRequest) when calling interceptor")
					}
					return s.TeamService.UpdateTeamName(ctx, typedReq)
				},
			)(ctx, req)
			if resp != nil {
				typedResp, ok := resp.(*UpdateTeamNameResponse)
				if !ok {
					return nil, twirp.InternalError("failed type assertion resp.(*UpdateTeamNameResponse) when calling interceptor")
				}
				return typedResp, err
			}
			return nil, err
		}
	}

	// Call service method
	var respContent *UpdateTeamNameResponse
	func() {
		defer ensurePanicResponses(ctx, resp, s.hooks)
		respContent, err = handler(ctx, reqContent)
	}()

	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}
	if respContent == nil {
		s.writeError(ctx, resp, twirp.InternalError("received a nil *UpdateTeamNameResponse and nil error while calling UpdateTeamName. nil responses are not supported"))
		return
	}

	ctx = callResponsePrepared(ctx, s.hooks)

	respBytes, err := proto.Marshal(respContent)
	if err != nil {
		s.writeError(ctx, resp, wrapInternal(err, "failed to marshal proto response"))
		return
	}

	ctx = ctxsetters.WithStatusCode(ctx, http.StatusOK)
	resp.Header().Set("Content-Type", "application/protobuf")
	resp.Header().Set("Content-Length", strconv.Itoa(len(respBytes)))
	resp.WriteHeader(http.StatusOK)
	if n, err := resp.Write(respBytes); err != nil {
		msg := fmt.Sprintf("failed to write response, %d of %d bytes written: %s", n, len(respBytes), err.Error())
		twerr := twirp.NewError(twirp.Unknown, msg)
		ctx = callError(ctx, s.hooks, twerr)
	}
	callResponseSent(ctx, s.hooks)
}

func (s *teamServiceServer) serveAddUserToTeam(ctx context.Context, resp http.ResponseWriter, req *http.Request) {
	header := req.Header.Get("Content-Type")
	i := strings.Index(header, ";")
	if i == -1 {
		i = len(header)
	}
	switch strings.TrimSpace(strings.ToLower(header[:i])) {
	case "application/json":
		s.serveAddUserToTeamJSON(ctx, resp, req)
	case "application/protobuf":
		s.serveAddUserToTeamProtobuf(ctx, resp, req)
	default:
		msg := fmt.Sprintf("unexpected Content-Type: %q", req.Header.Get("Content-Type"))
		twerr := badRouteError(msg, req.Method, req.URL.Path)
		s.writeError(ctx, resp, twerr)
	}
}

func (s *teamServiceServer) serveAddUserToTeamJSON(ctx context.Context, resp http.ResponseWriter, req *http.Request) {
	var err error
	ctx = ctxsetters.WithMethodName(ctx, "AddUserToTeam")
	ctx, err = callRequestRouted(ctx, s.hooks)
	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}

	d := json.NewDecoder(req.Body)
	rawReqBody := json.RawMessage{}
	if err := d.Decode(&rawReqBody); err != nil {
		s.handleRequestBodyError(ctx, resp, "the json request could not be decoded", err)
		return
	}
	reqContent := new(AddUserToTeamRequest)
	unmarshaler := protojson.UnmarshalOptions{DiscardUnknown: true}
	if err = unmarshaler.Unmarshal(rawReqBody, reqContent); err != nil {
		s.handleRequestBodyError(ctx, resp, "the json request could not be decoded", err)
		return
	}

	handler := s.TeamService.AddUserToTeam
	if s.interceptor != nil {
		handler = func(ctx context.Context, req *AddUserToTeamRequest) (*AddUserToTeamResponse, error) {
			resp, err := s.interceptor(
				func(ctx context.Context, req interface{}) (interface{}, error) {
					typedReq, ok := req.(*AddUserToTeamRequest)
					if !ok {
						return nil, twirp.InternalError("failed type assertion req.(*AddUserToTeamRequest) when calling interceptor")
					}
					return s.TeamService.AddUserToTeam(ctx, typedReq)
				},
			)(ctx, req)
			if resp != nil {
				typedResp, ok := resp.(*AddUserToTeamResponse)
				if !ok {
					return nil, twirp.InternalError("failed type assertion resp.(*AddUserToTeamResponse) when calling interceptor")
				}
				return typedResp, err
			}
			return nil, err
		}
	}

	// Call service method
	var respContent *AddUserToTeamResponse
	func() {
		defer ensurePanicResponses(ctx, resp, s.hooks)
		respContent, err = handler(ctx, reqContent)
	}()

	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}
	if respContent == nil {
		s.writeError(ctx, resp, twirp.InternalError("received a nil *AddUserToTeamResponse and nil error while calling AddUserToTeam. nil responses are not supported"))
		return
	}

	ctx = callResponsePrepared(ctx, s.hooks)

	marshaler := &protojson.MarshalOptions{UseProtoNames: !s.jsonCamelCase, EmitUnpopulated: !s.jsonSkipDefaults}
	respBytes, err := marshaler.Marshal(respContent)
	if err != nil {
		s.writeError(ctx, resp, wrapInternal(err, "failed to marshal json response"))
		return
	}

	ctx = ctxsetters.WithStatusCode(ctx, http.StatusOK)
	resp.Header().Set("Content-Type", "application/json")
	resp.Header().Set("Content-Length", strconv.Itoa(len(respBytes)))
	resp.WriteHeader(http.StatusOK)

	if n, err := resp.Write(respBytes); err != nil {
		msg := fmt.Sprintf("failed to write response, %d of %d bytes written: %s", n, len(respBytes), err.Error())
		twerr := twirp.NewError(twirp.Unknown, msg)
		ctx = callError(ctx, s.hooks, twerr)
	}
	callResponseSent(ctx, s.hooks)
}

func (s *teamServiceServer) serveAddUserToTeamProtobuf(ctx context.Context, resp http.ResponseWriter, req *http.Request) {
	var err error
	ctx = ctxsetters.WithMethodName(ctx, "AddUserToTeam")
	ctx, err = callRequestRouted(ctx, s.hooks)
	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}

	buf, err := ioutil.ReadAll(req.Body)
	if err != nil {
		s.handleRequestBodyError(ctx, resp, "failed to read request body", err)
		return
	}
	reqContent := new(AddUserToTeamRequest)
	if err = proto.Unmarshal(buf, reqContent); err != nil {
		s.writeError(ctx, resp, malformedRequestError("the protobuf request could not be decoded"))
		return
	}

	handler := s.TeamService.AddUserToTeam
	if s.interceptor != nil {
		handler = func(ctx context.Context, req *AddUserToTeamRequest) (*AddUserToTeamResponse, error) {
			resp, err := s.interceptor(
				func(ctx context.Context, req interface{}) (interface{}, error) {
					typedReq, ok := req.(*AddUserToTeamRequest)
					if !ok {
						return nil, twirp.InternalError("failed type assertion req.(*AddUserToTeamRequest) when calling interceptor")
					}
					return s.TeamService.AddUserToTeam(ctx, typedReq)
				},
			)(ctx, req)
			if resp != nil {
				typedResp, ok := resp.(*AddUserToTeamResponse)
				if !ok {
					return nil, twirp.InternalError("failed type assertion resp.(*AddUserToTeamResponse) when calling interceptor")
				}
				return typedResp, err
			}
			return nil, err
		}
	}

	// Call service method
	var respContent *AddUserToTeamResponse
	func() {
		defer ensurePanicResponses(ctx, resp, s.hooks)
		respContent, err = handler(ctx, reqContent)
	}()

	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}
	if respContent == nil {
		s.writeError(ctx, resp, twirp.InternalError("received a nil *AddUserToTeamResponse and nil error while calling AddUserToTeam. nil responses are not supported"))
		return
	}

	ctx = callResponsePrepared(ctx, s.hooks)

	respBytes, err := proto.Marshal(respContent)
	if err != nil {
		s.writeError(ctx, resp, wrapInternal(err, "failed to marshal proto response"))
		return
	}

	ctx = ctxsetters.WithStatusCode(ctx, http.StatusOK)
	resp.Header().Set("Content-Type", "application/protobuf")
	resp.Header().Set("Content-Length", strconv.Itoa(len(respBytes)))
	resp.WriteHeader(http.StatusOK)
	if n, err := resp.Write(respBytes); err != nil {
		msg := fmt.Sprintf("failed to write response, %d of %d bytes written: %s", n, len(respBytes), err.Error())
		twerr := twirp.NewError(twirp.Unknown, msg)
		ctx = callError(ctx, s.hooks, twerr)
	}
	callResponseSent(ctx, s.hooks)
}

func (s *teamServiceServer) serveAddUserToTeamByName(ctx context.Context, resp http.ResponseWriter, req *http.Request) {
	header := req.Header.Get("Content-Type")
	i := strings.Index(header, ";")
	if i == -1 {
		i = len(header)
	}
	switch strings.TrimSpace(strings.ToLower(header[:i])) {
	case "application/json":
		s.serveAddUserToTeamByNameJSON(ctx, resp, req)
	case "application/protobuf":
		s.serveAddUserToTeamByNameProtobuf(ctx, resp, req)
	default:
		msg := fmt.Sprintf("unexpected Content-Type: %q", req.Header.Get("Content-Type"))
		twerr := badRouteError(msg, req.Method, req.URL.Path)
		s.writeError(ctx, resp, twerr)
	}
}

func (s *teamServiceServer) serveAddUserToTeamByNameJSON(ctx context.Context, resp http.ResponseWriter, req *http.Request) {
	var err error
	ctx = ctxsetters.WithMethodName(ctx, "AddUserToTeamByName")
	ctx, err = callRequestRouted(ctx, s.hooks)
	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}

	d := json.NewDecoder(req.Body)
	rawReqBody := json.RawMessage{}
	if err := d.Decode(&rawReqBody); err != nil {
		s.handleRequestBodyError(ctx, resp, "the json request could not be decoded", err)
		return
	}
	reqContent := new(AddUserToTeamByNameRequest)
	unmarshaler := protojson.UnmarshalOptions{DiscardUnknown: true}
	if err = unmarshaler.Unmarshal(rawReqBody, reqContent); err != nil {
		s.handleRequestBodyError(ctx, resp, "the json request could not be decoded", err)
		return
	}

	handler := s.TeamService.AddUserToTeamByName
	if s.interceptor != nil {
		handler = func(ctx context.Context, req *AddUserToTeamByNameRequest) (*AddUserToTeamByNameResponse, error) {
			resp, err := s.interceptor(
				func(ctx context.Context, req interface{}) (interface{}, error) {
					typedReq, ok := req.(*AddUserToTeamByNameRequest)
					if !ok {
						return nil, twirp.InternalError("failed type assertion req.(*AddUserToTeamByNameRequest) when calling interceptor")
					}
					return s.TeamService.AddUserToTeamByName(ctx, typedReq)
				},
			)(ctx, req)
			if resp != nil {
				typedResp, ok := resp.(*AddUserToTeamByNameResponse)
				if !ok {
					return nil, twirp.InternalError("failed type assertion resp.(*AddUserToTeamByNameResponse) when calling interceptor")
				}
				return typedResp, err
			}
			return nil, err
		}
	}

	// Call service method
	var respContent *AddUserToTeamByNameResponse
	func() {
		defer ensurePanicResponses(ctx, resp, s.hooks)
		respContent, err = handler(ctx, reqContent)
	}()

	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}
	if respContent == nil {
		s.writeError(ctx, resp, twirp.InternalError("received a nil *AddUserToTeamByNameResponse and nil error while calling AddUserToTeamByName. nil responses are not supported"))
		return
	}

	ctx = callResponsePrepared(ctx, s.hooks)

	marshaler := &protojson.MarshalOptions{UseProtoNames: !s.jsonCamelCase, EmitUnpopulated: !s.jsonSkipDefaults}
	respBytes, err := marshaler.Marshal(respContent)
	if err != nil {
		s.writeError(ctx, resp, wrapInternal(err, "failed to marshal json response"))
		return
	}

	ctx = ctxsetters.WithStatusCode(ctx, http.StatusOK)
	resp.Header().Set("Content-Type", "application/json")
	resp.Header().Set("Content-Length", strconv.Itoa(len(respBytes)))
	resp.WriteHeader(http.StatusOK)

	if n, err := resp.Write(respBytes); err != nil {
		msg := fmt.Sprintf("failed to write response, %d of %d bytes written: %s", n, len(respBytes), err.Error())
		twerr := twirp.NewError(twirp.Unknown, msg)
		ctx = callError(ctx, s.hooks, twerr)
	}
	callResponseSent(ctx, s.hooks)
}

func (s *teamServiceServer) serveAddUserToTeamByNameProtobuf(ctx context.Context, resp http.ResponseWriter, req *http.Request) {
	var err error
	ctx = ctxsetters.WithMethodName(ctx, "AddUserToTeamByName")
	ctx, err = callRequestRouted(ctx, s.hooks)
	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}

	buf, err := ioutil.ReadAll(req.Body)
	if err != nil {
		s.handleRequestBodyError(ctx, resp, "failed to read request body", err)
		return
	}
	reqContent := new(AddUserToTeamByNameRequest)
	if err = proto.Unmarshal(buf, reqContent); err != nil {
		s.writeError(ctx, resp, malformedRequestError("the protobuf request could not be decoded"))
		return
	}

	handler := s.TeamService.AddUserToTeamByName
	if s.interceptor != nil {
		handler = func(ctx context.Context, req *AddUserToTeamByNameRequest) (*AddUserToTeamByNameResponse, error) {
			resp, err := s.interceptor(
				func(ctx context.Context, req interface{}) (interface{}, error) {
					typedReq, ok := req.(*AddUserToTeamByNameRequest)
					if !ok {
						return nil, twirp.InternalError("failed type assertion req.(*AddUserToTeamByNameRequest) when calling interceptor")
					}
					return s.TeamService.AddUserToTeamByName(ctx, typedReq)
				},
			)(ctx, req)
			if resp != nil {
				typedResp, ok := resp.(*AddUserToTeamByNameResponse)
				if !ok {
					return nil, twirp.InternalError("failed type assertion resp.(*AddUserToTeamByNameResponse) when calling interceptor")
				}
				return typedResp, err
			}
			return nil, err
		}
	}

	// Call service method
	var respContent *AddUserToTeamByNameResponse
	func() {
		defer ensurePanicResponses(ctx, resp, s.hooks)
		respContent, err = handler(ctx, reqContent)
	}()

	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}
	if respContent == nil {
		s.writeError(ctx, resp, twirp.InternalError("received a nil *AddUserToTeamByNameResponse and nil error while calling AddUserToTeamByName. nil responses are not supported"))
		return
	}

	ctx = callResponsePrepared(ctx, s.hooks)

	respBytes, err := proto.Marshal(respContent)
	if err != nil {
		s.writeError(ctx, resp, wrapInternal(err, "failed to marshal proto response"))
		return
	}

	ctx = ctxsetters.WithStatusCode(ctx, http.StatusOK)
	resp.Header().Set("Content-Type", "application/protobuf")
	resp.Header().Set("Content-Length", strconv.Itoa(len(respBytes)))
	resp.WriteHeader(http.StatusOK)
	if n, err := resp.Write(respBytes); err != nil {
		msg := fmt.Sprintf("failed to write response, %d of %d bytes written: %s", n, len(respBytes), err.Error())
		twerr := twirp.NewError(twirp.Unknown, msg)
		ctx = callError(ctx, s.hooks, twerr)
	}
	callResponseSent(ctx, s.hooks)
}

func (s *teamServiceServer) serveRemoveUserFromTeam(ctx context.Context, resp http.ResponseWriter, req *http.Request) {
	header := req.Header.Get("Content-Type")
	i := strings.Index(header, ";")
	if i == -1 {
		i = len(header)
	}
	switch strings.TrimSpace(strings.ToLower(header[:i])) {
	case "application/json":
		s.serveRemoveUserFromTeamJSON(ctx, resp, req)
	case "application/protobuf":
		s.serveRemoveUserFromTeamProtobuf(ctx, resp, req)
	default:
		msg := fmt.Sprintf("unexpected Content-Type: %q", req.Header.Get("Content-Type"))
		twerr := badRouteError(msg, req.Method, req.URL.Path)
		s.writeError(ctx, resp, twerr)
	}
}

func (s *teamServiceServer) serveRemoveUserFromTeamJSON(ctx context.Context, resp http.ResponseWriter, req *http.Request) {
	var err error
	ctx = ctxsetters.WithMethodName(ctx, "RemoveUserFromTeam")
	ctx, err = callRequestRouted(ctx, s.hooks)
	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}

	d := json.NewDecoder(req.Body)
	rawReqBody := json.RawMessage{}
	if err := d.Decode(&rawReqBody); err != nil {
		s.handleRequestBodyError(ctx, resp, "the json request could not be decoded", err)
		return
	}
	reqContent := new(RemoveUserFromTeamRequest)
	unmarshaler := protojson.UnmarshalOptions{DiscardUnknown: true}
	if err = unmarshaler.Unmarshal(rawReqBody, reqContent); err != nil {
		s.handleRequestBodyError(ctx, resp, "the json request could not be decoded", err)
		return
	}

	handler := s.TeamService.RemoveUserFromTeam
	if s.interceptor != nil {
		handler = func(ctx context.Context, req *RemoveUserFromTeamRequest) (*RemoveUserFromTeamResponse, error) {
			resp, err := s.interceptor(
				func(ctx context.Context, req interface{}) (interface{}, error) {
					typedReq, ok := req.(*RemoveUserFromTeamRequest)
					if !ok {
						return nil, twirp.InternalError("failed type assertion req.(*RemoveUserFromTeamRequest) when calling interceptor")
					}
					return s.TeamService.RemoveUserFromTeam(ctx, typedReq)
				},
			)(ctx, req)
			if resp != nil {
				typedResp, ok := resp.(*RemoveUserFromTeamResponse)
				if !ok {
					return nil, twirp.InternalError("failed type assertion resp.(*RemoveUserFromTeamResponse) when calling interceptor")
				}
				return typedResp, err
			}
			return nil, err
		}
	}

	// Call service method
	var respContent *RemoveUserFromTeamResponse
	func() {
		defer ensurePanicResponses(ctx, resp, s.hooks)
		respContent, err = handler(ctx, reqContent)
	}()

	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}
	if respContent == nil {
		s.writeError(ctx, resp, twirp.InternalError("received a nil *RemoveUserFromTeamResponse and nil error while calling RemoveUserFromTeam. nil responses are not supported"))
		return
	}

	ctx = callResponsePrepared(ctx, s.hooks)

	marshaler := &protojson.MarshalOptions{UseProtoNames: !s.jsonCamelCase, EmitUnpopulated: !s.jsonSkipDefaults}
	respBytes, err := marshaler.Marshal(respContent)
	if err != nil {
		s.writeError(ctx, resp, wrapInternal(err, "failed to marshal json response"))
		return
	}

	ctx = ctxsetters.WithStatusCode(ctx, http.StatusOK)
	resp.Header().Set("Content-Type", "application/json")
	resp.Header().Set("Content-Length", strconv.Itoa(len(respBytes)))
	resp.WriteHeader(http.StatusOK)

	if n, err := resp.Write(respBytes); err != nil {
		msg := fmt.Sprintf("failed to write response, %d of %d bytes written: %s", n, len(respBytes), err.Error())
		twerr := twirp.NewError(twirp.Unknown, msg)
		ctx = callError(ctx, s.hooks, twerr)
	}
	callResponseSent(ctx, s.hooks)
}

func (s *teamServiceServer) serveRemoveUserFromTeamProtobuf(ctx context.Context, resp http.ResponseWriter, req *http.Request) {
	var err error
	ctx = ctxsetters.WithMethodName(ctx, "RemoveUserFromTeam")
	ctx, err = callRequestRouted(ctx, s.hooks)
	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}

	buf, err := ioutil.ReadAll(req.Body)
	if err != nil {
		s.handleRequestBodyError(ctx, resp, "failed to read request body", err)
		return
	}
	reqContent := new(RemoveUserFromTeamRequest)
	if err = proto.Unmarshal(buf, reqContent); err != nil {
		s.writeError(ctx, resp, malformedRequestError("the protobuf request could not be decoded"))
		return
	}

	handler := s.TeamService.RemoveUserFromTeam
	if s.interceptor != nil {
		handler = func(ctx context.Context, req *RemoveUserFromTeamRequest) (*RemoveUserFromTeamResponse, error) {
			resp, err := s.interceptor(
				func(ctx context.Context, req interface{}) (interface{}, error) {
					typedReq, ok := req.(*RemoveUserFromTeamRequest)
					if !ok {
						return nil, twirp.InternalError("failed type assertion req.(*RemoveUserFromTeamRequest) when calling interceptor")
					}
					return s.TeamService.RemoveUserFromTeam(ctx, typedReq)
				},
			)(ctx, req)
			if resp != nil {
				typedResp, ok := resp.(*RemoveUserFromTeamResponse)
				if !ok {
					return nil, twirp.InternalError("failed type assertion resp.(*RemoveUserFromTeamResponse) when calling interceptor")
				}
				return typedResp, err
			}
			return nil, err
		}
	}

	// Call service method
	var respContent *RemoveUserFromTeamResponse
	func() {
		defer ensurePanicResponses(ctx, resp, s.hooks)
		respContent, err = handler(ctx, reqContent)
	}()

	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}
	if respContent == nil {
		s.writeError(ctx, resp, twirp.InternalError("received a nil *RemoveUserFromTeamResponse and nil error while calling RemoveUserFromTeam. nil responses are not supported"))
		return
	}

	ctx = callResponsePrepared(ctx, s.hooks)

	respBytes, err := proto.Marshal(respContent)
	if err != nil {
		s.writeError(ctx, resp, wrapInternal(err, "failed to marshal proto response"))
		return
	}

	ctx = ctxsetters.WithStatusCode(ctx, http.StatusOK)
	resp.Header().Set("Content-Type", "application/protobuf")
	resp.Header().Set("Content-Length", strconv.Itoa(len(respBytes)))
	resp.WriteHeader(http.StatusOK)
	if n, err := resp.Write(respBytes); err != nil {
		msg := fmt.Sprintf("failed to write response, %d of %d bytes written: %s", n, len(respBytes), err.Error())
		twerr := twirp.NewError(twirp.Unknown, msg)
		ctx = callError(ctx, s.hooks, twerr)
	}
	callResponseSent(ctx, s.hooks)
}

func (s *teamServiceServer) serveRemoveUserFromTeamByName(ctx context.Context, resp http.ResponseWriter, req *http.Request) {
	header := req.Header.Get("Content-Type")
	i := strings.Index(header, ";")
	if i == -1 {
		i = len(header)
	}
	switch strings.TrimSpace(strings.ToLower(header[:i])) {
	case "application/json":
		s.serveRemoveUserFromTeamByNameJSON(ctx, resp, req)
	case "application/protobuf":
		s.serveRemoveUserFromTeamByNameProtobuf(ctx, resp, req)
	default:
		msg := fmt.Sprintf("unexpected Content-Type: %q", req.Header.Get("Content-Type"))
		twerr := badRouteError(msg, req.Method, req.URL.Path)
		s.writeError(ctx, resp, twerr)
	}
}

func (s *teamServiceServer) serveRemoveUserFromTeamByNameJSON(ctx context.Context, resp http.ResponseWriter, req *http.Request) {
	var err error
	ctx = ctxsetters.WithMethodName(ctx, "RemoveUserFromTeamByName")
	ctx, err = callRequestRouted(ctx, s.hooks)
	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}

	d := json.NewDecoder(req.Body)
	rawReqBody := json.RawMessage{}
	if err := d.Decode(&rawReqBody); err != nil {
		s.handleRequestBodyError(ctx, resp, "the json request could not be decoded", err)
		return
	}
	reqContent := new(RemoveUserFromTeamByNameRequest)
	unmarshaler := protojson.UnmarshalOptions{DiscardUnknown: true}
	if err = unmarshaler.Unmarshal(rawReqBody, reqContent); err != nil {
		s.handleRequestBodyError(ctx, resp, "the json request could not be decoded", err)
		return
	}

	handler := s.TeamService.RemoveUserFromTeamByName
	if s.interceptor != nil {
		handler = func(ctx context.Context, req *RemoveUserFromTeamByNameRequest) (*RemoveUserFromTeamByNameResponse, error) {
			resp, err := s.interceptor(
				func(ctx context.Context, req interface{}) (interface{}, error) {
					typedReq, ok := req.(*RemoveUserFromTeamByNameRequest)
					if !ok {
						return nil, twirp.InternalError("failed type assertion req.(*RemoveUserFromTeamByNameRequest) when calling interceptor")
					}
					return s.TeamService.RemoveUserFromTeamByName(ctx, typedReq)
				},
			)(ctx, req)
			if resp != nil {
				typedResp, ok := resp.(*RemoveUserFromTeamByNameResponse)
				if !ok {
					return nil, twirp.InternalError("failed type assertion resp.(*RemoveUserFromTeamByNameResponse) when calling interceptor")
				}
				return typedResp, err
			}
			return nil, err
		}
	}

	// Call service method
	var respContent *RemoveUserFromTeamByNameResponse
	func() {
		defer ensurePanicResponses(ctx, resp, s.hooks)
		respContent, err = handler(ctx, reqContent)
	}()

	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}
	if respContent == nil {
		s.writeError(ctx, resp, twirp.InternalError("received a nil *RemoveUserFromTeamByNameResponse and nil error while calling RemoveUserFromTeamByName. nil responses are not supported"))
		return
	}

	ctx = callResponsePrepared(ctx, s.hooks)

	marshaler := &protojson.MarshalOptions{UseProtoNames: !s.jsonCamelCase, EmitUnpopulated: !s.jsonSkipDefaults}
	respBytes, err := marshaler.Marshal(respContent)
	if err != nil {
		s.writeError(ctx, resp, wrapInternal(err, "failed to marshal json response"))
		return
	}

	ctx = ctxsetters.WithStatusCode(ctx, http.StatusOK)
	resp.Header().Set("Content-Type", "application/json")
	resp.Header().Set("Content-Length", strconv.Itoa(len(respBytes)))
	resp.WriteHeader(http.StatusOK)

	if n, err := resp.Write(respBytes); err != nil {
		msg := fmt.Sprintf("failed to write response, %d of %d bytes written: %s", n, len(respBytes), err.Error())
		twerr := twirp.NewError(twirp.Unknown, msg)
		ctx = callError(ctx, s.hooks, twerr)
	}
	callResponseSent(ctx, s.hooks)
}

func (s *teamServiceServer) serveRemoveUserFromTeamByNameProtobuf(ctx context.Context, resp http.ResponseWriter, req *http.Request) {
	var err error
	ctx = ctxsetters.WithMethodName(ctx, "RemoveUserFromTeamByName")
	ctx, err = callRequestRouted(ctx, s.hooks)
	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}

	buf, err := ioutil.ReadAll(req.Body)
	if err != nil {
		s.handleRequestBodyError(ctx, resp, "failed to read request body", err)
		return
	}
	reqContent := new(RemoveUserFromTeamByNameRequest)
	if err = proto.Unmarshal(buf, reqContent); err != nil {
		s.writeError(ctx, resp, malformedRequestError("the protobuf request could not be decoded"))
		return
	}

	handler := s.TeamService.RemoveUserFromTeamByName
	if s.interceptor != nil {
		handler = func(ctx context.Context, req *RemoveUserFromTeamByNameRequest) (*RemoveUserFromTeamByNameResponse, error) {
			resp, err := s.interceptor(
				func(ctx context.Context, req interface{}) (interface{}, error) {
					typedReq, ok := req.(*RemoveUserFromTeamByNameRequest)
					if !ok {
						return nil, twirp.InternalError("failed type assertion req.(*RemoveUserFromTeamByNameRequest) when calling interceptor")
					}
					return s.TeamService.RemoveUserFromTeamByName(ctx, typedReq)
				},
			)(ctx, req)
			if resp != nil {
				typedResp, ok := resp.(*RemoveUserFromTeamByNameResponse)
				if !ok {
					return nil, twirp.InternalError("failed type assertion resp.(*RemoveUserFromTeamByNameResponse) when calling interceptor")
				}
				return typedResp, err
			}
			return nil, err
		}
	}

	// Call service method
	var respContent *RemoveUserFromTeamByNameResponse
	func() {
		defer ensurePanicResponses(ctx, resp, s.hooks)
		respContent, err = handler(ctx, reqContent)
	}()

	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}
	if respContent == nil {
		s.writeError(ctx, resp, twirp.InternalError("received a nil *RemoveUserFromTeamByNameResponse and nil error while calling RemoveUserFromTeamByName. nil responses are not supported"))
		return
	}

	ctx = callResponsePrepared(ctx, s.hooks)

	respBytes, err := proto.Marshal(respContent)
	if err != nil {
		s.writeError(ctx, resp, wrapInternal(err, "failed to marshal proto response"))
		return
	}

	ctx = ctxsetters.WithStatusCode(ctx, http.StatusOK)
	resp.Header().Set("Content-Type", "application/protobuf")
	resp.Header().Set("Content-Length", strconv.Itoa(len(respBytes)))
	resp.WriteHeader(http.StatusOK)
	if n, err := resp.Write(respBytes); err != nil {
		msg := fmt.Sprintf("failed to write response, %d of %d bytes written: %s", n, len(respBytes), err.Error())
		twerr := twirp.NewError(twirp.Unknown, msg)
		ctx = callError(ctx, s.hooks, twerr)
	}
	callResponseSent(ctx, s.hooks)
}

func (s *teamServiceServer) serveDeleteTeam(ctx context.Context, resp http.ResponseWriter, req *http.Request) {
	header := req.Header.Get("Content-Type")
	i := strings.Index(header, ";")
	if i == -1 {
		i = len(header)
	}
	switch strings.TrimSpace(strings.ToLower(header[:i])) {
	case "application/json":
		s.serveDeleteTeamJSON(ctx, resp, req)
	case "application/protobuf":
		s.serveDeleteTeamProtobuf(ctx, resp, req)
	default:
		msg := fmt.Sprintf("unexpected Content-Type: %q", req.Header.Get("Content-Type"))
		twerr := badRouteError(msg, req.Method, req.URL.Path)
		s.writeError(ctx, resp, twerr)
	}
}

func (s *teamServiceServer) serveDeleteTeamJSON(ctx context.Context, resp http.ResponseWriter, req *http.Request) {
	var err error
	ctx = ctxsetters.WithMethodName(ctx, "DeleteTeam")
	ctx, err = callRequestRouted(ctx, s.hooks)
	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}

	d := json.NewDecoder(req.Body)
	rawReqBody := json.RawMessage{}
	if err := d.Decode(&rawReqBody); err != nil {
		s.handleRequestBodyError(ctx, resp, "the json request could not be decoded", err)
		return
	}
	reqContent := new(DeleteTeamRequest)
	unmarshaler := protojson.UnmarshalOptions{DiscardUnknown: true}
	if err = unmarshaler.Unmarshal(rawReqBody, reqContent); err != nil {
		s.handleRequestBodyError(ctx, resp, "the json request could not be decoded", err)
		return
	}

	handler := s.TeamService.DeleteTeam
	if s.interceptor != nil {
		handler = func(ctx context.Context, req *DeleteTeamRequest) (*DeleteTeamResponse, error) {
			resp, err := s.interceptor(
				func(ctx context.Context, req interface{}) (interface{}, error) {
					typedReq, ok := req.(*DeleteTeamRequest)
					if !ok {
						return nil, twirp.InternalError("failed type assertion req.(*DeleteTeamRequest) when calling interceptor")
					}
					return s.TeamService.DeleteTeam(ctx, typedReq)
				},
			)(ctx, req)
			if resp != nil {
				typedResp, ok := resp.(*DeleteTeamResponse)
				if !ok {
					return nil, twirp.InternalError("failed type assertion resp.(*DeleteTeamResponse) when calling interceptor")
				}
				return typedResp, err
			}
			return nil, err
		}
	}

	// Call service method
	var respContent *DeleteTeamResponse
	func() {
		defer ensurePanicResponses(ctx, resp, s.hooks)
		respContent, err = handler(ctx, reqContent)
	}()

	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}
	if respContent == nil {
		s.writeError(ctx, resp, twirp.InternalError("received a nil *DeleteTeamResponse and nil error while calling DeleteTeam. nil responses are not supported"))
		return
	}

	ctx = callResponsePrepared(ctx, s.hooks)

	marshaler := &protojson.MarshalOptions{UseProtoNames: !s.jsonCamelCase, EmitUnpopulated: !s.jsonSkipDefaults}
	respBytes, err := marshaler.Marshal(respContent)
	if err != nil {
		s.writeError(ctx, resp, wrapInternal(err, "failed to marshal json response"))
		return
	}

	ctx = ctxsetters.WithStatusCode(ctx, http.StatusOK)
	resp.Header().Set("Content-Type", "application/json")
	resp.Header().Set("Content-Length", strconv.Itoa(len(respBytes)))
	resp.WriteHeader(http.StatusOK)

	if n, err := resp.Write(respBytes); err != nil {
		msg := fmt.Sprintf("failed to write response, %d of %d bytes written: %s", n, len(respBytes), err.Error())
		twerr := twirp.NewError(twirp.Unknown, msg)
		ctx = callError(ctx, s.hooks, twerr)
	}
	callResponseSent(ctx, s.hooks)
}

func (s *teamServiceServer) serveDeleteTeamProtobuf(ctx context.Context, resp http.ResponseWriter, req *http.Request) {
	var err error
	ctx = ctxsetters.WithMethodName(ctx, "DeleteTeam")
	ctx, err = callRequestRouted(ctx, s.hooks)
	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}

	buf, err := ioutil.ReadAll(req.Body)
	if err != nil {
		s.handleRequestBodyError(ctx, resp, "failed to read request body", err)
		return
	}
	reqContent := new(DeleteTeamRequest)
	if err = proto.Unmarshal(buf, reqContent); err != nil {
		s.writeError(ctx, resp, malformedRequestError("the protobuf request could not be decoded"))
		return
	}

	handler := s.TeamService.DeleteTeam
	if s.interceptor != nil {
		handler = func(ctx context.Context, req *DeleteTeamRequest) (*DeleteTeamResponse, error) {
			resp, err := s.interceptor(
				func(ctx context.Context, req interface{}) (interface{}, error) {
					typedReq, ok := req.(*DeleteTeamRequest)
					if !ok {
						return nil, twirp.InternalError("failed type assertion req.(*DeleteTeamRequest) when calling interceptor")
					}
					return s.TeamService.DeleteTeam(ctx, typedReq)
				},
			)(ctx, req)
			if resp != nil {
				typedResp, ok := resp.(*DeleteTeamResponse)
				if !ok {
					return nil, twirp.InternalError("failed type assertion resp.(*DeleteTeamResponse) when calling interceptor")
				}
				return typedResp, err
			}
			return nil, err
		}
	}

	// Call service method
	var respContent *DeleteTeamResponse
	func() {
		defer ensurePanicResponses(ctx, resp, s.hooks)
		respContent, err = handler(ctx, reqContent)
	}()

	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}
	if respContent == nil {
		s.writeError(ctx, resp, twirp.InternalError("received a nil *DeleteTeamResponse and nil error while calling DeleteTeam. nil responses are not supported"))
		return
	}

	ctx = callResponsePrepared(ctx, s.hooks)

	respBytes, err := proto.Marshal(respContent)
	if err != nil {
		s.writeError(ctx, resp, wrapInternal(err, "failed to marshal proto response"))
		return
	}

	ctx = ctxsetters.WithStatusCode(ctx, http.StatusOK)
	resp.Header().Set("Content-Type", "application/protobuf")
	resp.Header().Set("Content-Length", strconv.Itoa(len(respBytes)))
	resp.WriteHeader(http.StatusOK)
	if n, err := resp.Write(respBytes); err != nil {
		msg := fmt.Sprintf("failed to write response, %d of %d bytes written: %s", n, len(respBytes), err.Error())
		twerr := twirp.NewError(twirp.Unknown, msg)
		ctx = callError(ctx, s.hooks, twerr)
	}
	callResponseSent(ctx, s.hooks)
}

func (s *teamServiceServer) serveDeleteTeamByName(ctx context.Context, resp http.ResponseWriter, req *http.Request) {
	header := req.Header.Get("Content-Type")
	i := strings.Index(header, ";")
	if i == -1 {
		i = len(header)
	}
	switch strings.TrimSpace(strings.ToLower(header[:i])) {
	case "application/json":
		s.serveDeleteTeamByNameJSON(ctx, resp, req)
	case "application/protobuf":
		s.serveDeleteTeamByNameProtobuf(ctx, resp, req)
	default:
		msg := fmt.Sprintf("unexpected Content-Type: %q", req.Header.Get("Content-Type"))
		twerr := badRouteError(msg, req.Method, req.URL.Path)
		s.writeError(ctx, resp, twerr)
	}
}

func (s *teamServiceServer) serveDeleteTeamByNameJSON(ctx context.Context, resp http.ResponseWriter, req *http.Request) {
	var err error
	ctx = ctxsetters.WithMethodName(ctx, "DeleteTeamByName")
	ctx, err = callRequestRouted(ctx, s.hooks)
	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}

	d := json.NewDecoder(req.Body)
	rawReqBody := json.RawMessage{}
	if err := d.Decode(&rawReqBody); err != nil {
		s.handleRequestBodyError(ctx, resp, "the json request could not be decoded", err)
		return
	}
	reqContent := new(DeleteTeamByNameRequest)
	unmarshaler := protojson.UnmarshalOptions{DiscardUnknown: true}
	if err = unmarshaler.Unmarshal(rawReqBody, reqContent); err != nil {
		s.handleRequestBodyError(ctx, resp, "the json request could not be decoded", err)
		return
	}

	handler := s.TeamService.DeleteTeamByName
	if s.interceptor != nil {
		handler = func(ctx context.Context, req *DeleteTeamByNameRequest) (*DeleteTeamByNameResponse, error) {
			resp, err := s.interceptor(
				func(ctx context.Context, req interface{}) (interface{}, error) {
					typedReq, ok := req.(*DeleteTeamByNameRequest)
					if !ok {
						return nil, twirp.InternalError("failed type assertion req.(*DeleteTeamByNameRequest) when calling interceptor")
					}
					return s.TeamService.DeleteTeamByName(ctx, typedReq)
				},
			)(ctx, req)
			if resp != nil {
				typedResp, ok := resp.(*DeleteTeamByNameResponse)
				if !ok {
					return nil, twirp.InternalError("failed type assertion resp.(*DeleteTeamByNameResponse) when calling interceptor")
				}
				return typedResp, err
			}
			return nil, err
		}
	}

	// Call service method
	var respContent *DeleteTeamByNameResponse
	func() {
		defer ensurePanicResponses(ctx, resp, s.hooks)
		respContent, err = handler(ctx, reqContent)
	}()

	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}
	if respContent == nil {
		s.writeError(ctx, resp, twirp.InternalError("received a nil *DeleteTeamByNameResponse and nil error while calling DeleteTeamByName. nil responses are not supported"))
		return
	}

	ctx = callResponsePrepared(ctx, s.hooks)

	marshaler := &protojson.MarshalOptions{UseProtoNames: !s.jsonCamelCase, EmitUnpopulated: !s.jsonSkipDefaults}
	respBytes, err := marshaler.Marshal(respContent)
	if err != nil {
		s.writeError(ctx, resp, wrapInternal(err, "failed to marshal json response"))
		return
	}

	ctx = ctxsetters.WithStatusCode(ctx, http.StatusOK)
	resp.Header().Set("Content-Type", "application/json")
	resp.Header().Set("Content-Length", strconv.Itoa(len(respBytes)))
	resp.WriteHeader(http.StatusOK)

	if n, err := resp.Write(respBytes); err != nil {
		msg := fmt.Sprintf("failed to write response, %d of %d bytes written: %s", n, len(respBytes), err.Error())
		twerr := twirp.NewError(twirp.Unknown, msg)
		ctx = callError(ctx, s.hooks, twerr)
	}
	callResponseSent(ctx, s.hooks)
}

func (s *teamServiceServer) serveDeleteTeamByNameProtobuf(ctx context.Context, resp http.ResponseWriter, req *http.Request) {
	var err error
	ctx = ctxsetters.WithMethodName(ctx, "DeleteTeamByName")
	ctx, err = callRequestRouted(ctx, s.hooks)
	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}

	buf, err := ioutil.ReadAll(req.Body)
	if err != nil {
		s.handleRequestBodyError(ctx, resp, "failed to read request body", err)
		return
	}
	reqContent := new(DeleteTeamByNameRequest)
	if err = proto.Unmarshal(buf, reqContent); err != nil {
		s.writeError(ctx, resp, malformedRequestError("the protobuf request could not be decoded"))
		return
	}

	handler := s.TeamService.DeleteTeamByName
	if s.interceptor != nil {
		handler = func(ctx context.Context, req *DeleteTeamByNameRequest) (*DeleteTeamByNameResponse, error) {
			resp, err := s.interceptor(
				func(ctx context.Context, req interface{}) (interface{}, error) {
					typedReq, ok := req.(*DeleteTeamByNameRequest)
					if !ok {
						return nil, twirp.InternalError("failed type assertion req.(*DeleteTeamByNameRequest) when calling interceptor")
					}
					return s.TeamService.DeleteTeamByName(ctx, typedReq)
				},
			)(ctx, req)
			if resp != nil {
				typedResp, ok := resp.(*DeleteTeamByNameResponse)
				if !ok {
					return nil, twirp.InternalError("failed type assertion resp.(*DeleteTeamByNameResponse) when calling interceptor")
				}
				return typedResp, err
			}
			return nil, err
		}
	}

	// Call service method
	var respContent *DeleteTeamByNameResponse
	func() {
		defer ensurePanicResponses(ctx, resp, s.hooks)
		respContent, err = handler(ctx, reqContent)
	}()

	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}
	if respContent == nil {
		s.writeError(ctx, resp, twirp.InternalError("received a nil *DeleteTeamByNameResponse and nil error while calling DeleteTeamByName. nil responses are not supported"))
		return
	}

	ctx = callResponsePrepared(ctx, s.hooks)

	respBytes, err := proto.Marshal(respContent)
	if err != nil {
		s.writeError(ctx, resp, wrapInternal(err, "failed to marshal proto response"))
		return
	}

	ctx = ctxsetters.WithStatusCode(ctx, http.StatusOK)
	resp.Header().Set("Content-Type", "application/protobuf")
	resp.Header().Set("Content-Length", strconv.Itoa(len(respBytes)))
	resp.WriteHeader(http.StatusOK)
	if n, err := resp.Write(respBytes); err != nil {
		msg := fmt.Sprintf("failed to write response, %d of %d bytes written: %s", n, len(respBytes), err.Error())
		twerr := twirp.NewError(twirp.Unknown, msg)
		ctx = callError(ctx, s.hooks, twerr)
	}
	callResponseSent(ctx, s.hooks)
}

func (s *teamServiceServer) serveAddTeamOrganizationScope(ctx context.Context, resp http.ResponseWriter, req *http.Request) {
	header := req.Header.Get("Content-Type")
	i := strings.Index(header, ";")
	if i == -1 {
		i = len(header)
	}
	switch strings.TrimSpace(strings.ToLower(header[:i])) {
	case "application/json":
		s.serveAddTeamOrganizationScopeJSON(ctx, resp, req)
	case "application/protobuf":
		s.serveAddTeamOrganizationScopeProtobuf(ctx, resp, req)
	default:
		msg := fmt.Sprintf("unexpected Content-Type: %q", req.Header.Get("Content-Type"))
		twerr := badRouteError(msg, req.Method, req.URL.Path)
		s.writeError(ctx, resp, twerr)
	}
}

func (s *teamServiceServer) serveAddTeamOrganizationScopeJSON(ctx context.Context, resp http.ResponseWriter, req *http.Request) {
	var err error
	ctx = ctxsetters.WithMethodName(ctx, "AddTeamOrganizationScope")
	ctx, err = callRequestRouted(ctx, s.hooks)
	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}

	d := json.NewDecoder(req.Body)
	rawReqBody := json.RawMessage{}
	if err := d.Decode(&rawReqBody); err != nil {
		s.handleRequestBodyError(ctx, resp, "the json request could not be decoded", err)
		return
	}
	reqContent := new(AddTeamOrganizationScopeRequest)
	unmarshaler := protojson.UnmarshalOptions{DiscardUnknown: true}
	if err = unmarshaler.Unmarshal(rawReqBody, reqContent); err != nil {
		s.handleRequestBodyError(ctx, resp, "the json request could not be decoded", err)
		return
	}

	handler := s.TeamService.AddTeamOrganizationScope
	if s.interceptor != nil {
		handler = func(ctx context.Context, req *AddTeamOrganizationScopeRequest) (*AddTeamOrganizationScopeResponse, error) {
			resp, err := s.interceptor(
				func(ctx context.Context, req interface{}) (interface{}, error) {
					typedReq, ok := req.(*AddTeamOrganizationScopeRequest)
					if !ok {
						return nil, twirp.InternalError("failed type assertion req.(*AddTeamOrganizationScopeRequest) when calling interceptor")
					}
					return s.TeamService.AddTeamOrganizationScope(ctx, typedReq)
				},
			)(ctx, req)
			if resp != nil {
				typedResp, ok := resp.(*AddTeamOrganizationScopeResponse)
				if !ok {
					return nil, twirp.InternalError("failed type assertion resp.(*AddTeamOrganizationScopeResponse) when calling interceptor")
				}
				return typedResp, err
			}
			return nil, err
		}
	}

	// Call service method
	var respContent *AddTeamOrganizationScopeResponse
	func() {
		defer ensurePanicResponses(ctx, resp, s.hooks)
		respContent, err = handler(ctx, reqContent)
	}()

	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}
	if respContent == nil {
		s.writeError(ctx, resp, twirp.InternalError("received a nil *AddTeamOrganizationScopeResponse and nil error while calling AddTeamOrganizationScope. nil responses are not supported"))
		return
	}

	ctx = callResponsePrepared(ctx, s.hooks)

	marshaler := &protojson.MarshalOptions{UseProtoNames: !s.jsonCamelCase, EmitUnpopulated: !s.jsonSkipDefaults}
	respBytes, err := marshaler.Marshal(respContent)
	if err != nil {
		s.writeError(ctx, resp, wrapInternal(err, "failed to marshal json response"))
		return
	}

	ctx = ctxsetters.WithStatusCode(ctx, http.StatusOK)
	resp.Header().Set("Content-Type", "application/json")
	resp.Header().Set("Content-Length", strconv.Itoa(len(respBytes)))
	resp.WriteHeader(http.StatusOK)

	if n, err := resp.Write(respBytes); err != nil {
		msg := fmt.Sprintf("failed to write response, %d of %d bytes written: %s", n, len(respBytes), err.Error())
		twerr := twirp.NewError(twirp.Unknown, msg)
		ctx = callError(ctx, s.hooks, twerr)
	}
	callResponseSent(ctx, s.hooks)
}

func (s *teamServiceServer) serveAddTeamOrganizationScopeProtobuf(ctx context.Context, resp http.ResponseWriter, req *http.Request) {
	var err error
	ctx = ctxsetters.WithMethodName(ctx, "AddTeamOrganizationScope")
	ctx, err = callRequestRouted(ctx, s.hooks)
	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}

	buf, err := ioutil.ReadAll(req.Body)
	if err != nil {
		s.handleRequestBodyError(ctx, resp, "failed to read request body", err)
		return
	}
	reqContent := new(AddTeamOrganizationScopeRequest)
	if err = proto.Unmarshal(buf, reqContent); err != nil {
		s.writeError(ctx, resp, malformedRequestError("the protobuf request could not be decoded"))
		return
	}

	handler := s.TeamService.AddTeamOrganizationScope
	if s.interceptor != nil {
		handler = func(ctx context.Context, req *AddTeamOrganizationScopeRequest) (*AddTeamOrganizationScopeResponse, error) {
			resp, err := s.interceptor(
				func(ctx context.Context, req interface{}) (interface{}, error) {
					typedReq, ok := req.(*AddTeamOrganizationScopeRequest)
					if !ok {
						return nil, twirp.InternalError("failed type assertion req.(*AddTeamOrganizationScopeRequest) when calling interceptor")
					}
					return s.TeamService.AddTeamOrganizationScope(ctx, typedReq)
				},
			)(ctx, req)
			if resp != nil {
				typedResp, ok := resp.(*AddTeamOrganizationScopeResponse)
				if !ok {
					return nil, twirp.InternalError("failed type assertion resp.(*AddTeamOrganizationScopeResponse) when calling interceptor")
				}
				return typedResp, err
			}
			return nil, err
		}
	}

	// Call service method
	var respContent *AddTeamOrganizationScopeResponse
	func() {
		defer ensurePanicResponses(ctx, resp, s.hooks)
		respContent, err = handler(ctx, reqContent)
	}()

	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}
	if respContent == nil {
		s.writeError(ctx, resp, twirp.InternalError("received a nil *AddTeamOrganizationScopeResponse and nil error while calling AddTeamOrganizationScope. nil responses are not supported"))
		return
	}

	ctx = callResponsePrepared(ctx, s.hooks)

	respBytes, err := proto.Marshal(respContent)
	if err != nil {
		s.writeError(ctx, resp, wrapInternal(err, "failed to marshal proto response"))
		return
	}

	ctx = ctxsetters.WithStatusCode(ctx, http.StatusOK)
	resp.Header().Set("Content-Type", "application/protobuf")
	resp.Header().Set("Content-Length", strconv.Itoa(len(respBytes)))
	resp.WriteHeader(http.StatusOK)
	if n, err := resp.Write(respBytes); err != nil {
		msg := fmt.Sprintf("failed to write response, %d of %d bytes written: %s", n, len(respBytes), err.Error())
		twerr := twirp.NewError(twirp.Unknown, msg)
		ctx = callError(ctx, s.hooks, twerr)
	}
	callResponseSent(ctx, s.hooks)
}

func (s *teamServiceServer) serveAddTeamOrganizationScopeByName(ctx context.Context, resp http.ResponseWriter, req *http.Request) {
	header := req.Header.Get("Content-Type")
	i := strings.Index(header, ";")
	if i == -1 {
		i = len(header)
	}
	switch strings.TrimSpace(strings.ToLower(header[:i])) {
	case "application/json":
		s.serveAddTeamOrganizationScopeByNameJSON(ctx, resp, req)
	case "application/protobuf":
		s.serveAddTeamOrganizationScopeByNameProtobuf(ctx, resp, req)
	default:
		msg := fmt.Sprintf("unexpected Content-Type: %q", req.Header.Get("Content-Type"))
		twerr := badRouteError(msg, req.Method, req.URL.Path)
		s.writeError(ctx, resp, twerr)
	}
}

func (s *teamServiceServer) serveAddTeamOrganizationScopeByNameJSON(ctx context.Context, resp http.ResponseWriter, req *http.Request) {
	var err error
	ctx = ctxsetters.WithMethodName(ctx, "AddTeamOrganizationScopeByName")
	ctx, err = callRequestRouted(ctx, s.hooks)
	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}

	d := json.NewDecoder(req.Body)
	rawReqBody := json.RawMessage{}
	if err := d.Decode(&rawReqBody); err != nil {
		s.handleRequestBodyError(ctx, resp, "the json request could not be decoded", err)
		return
	}
	reqContent := new(AddTeamOrganizationScopeByNameRequest)
	unmarshaler := protojson.UnmarshalOptions{DiscardUnknown: true}
	if err = unmarshaler.Unmarshal(rawReqBody, reqContent); err != nil {
		s.handleRequestBodyError(ctx, resp, "the json request could not be decoded", err)
		return
	}

	handler := s.TeamService.AddTeamOrganizationScopeByName
	if s.interceptor != nil {
		handler = func(ctx context.Context, req *AddTeamOrganizationScopeByNameRequest) (*AddTeamOrganizationScopeByNameResponse, error) {
			resp, err := s.interceptor(
				func(ctx context.Context, req interface{}) (interface{}, error) {
					typedReq, ok := req.(*AddTeamOrganizationScopeByNameRequest)
					if !ok {
						return nil, twirp.InternalError("failed type assertion req.(*AddTeamOrganizationScopeByNameRequest) when calling interceptor")
					}
					return s.TeamService.AddTeamOrganizationScopeByName(ctx, typedReq)
				},
			)(ctx, req)
			if resp != nil {
				typedResp, ok := resp.(*AddTeamOrganizationScopeByNameResponse)
				if !ok {
					return nil, twirp.InternalError("failed type assertion resp.(*AddTeamOrganizationScopeByNameResponse) when calling interceptor")
				}
				return typedResp, err
			}
			return nil, err
		}
	}

	// Call service method
	var respContent *AddTeamOrganizationScopeByNameResponse
	func() {
		defer ensurePanicResponses(ctx, resp, s.hooks)
		respContent, err = handler(ctx, reqContent)
	}()

	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}
	if respContent == nil {
		s.writeError(ctx, resp, twirp.InternalError("received a nil *AddTeamOrganizationScopeByNameResponse and nil error while calling AddTeamOrganizationScopeByName. nil responses are not supported"))
		return
	}

	ctx = callResponsePrepared(ctx, s.hooks)

	marshaler := &protojson.MarshalOptions{UseProtoNames: !s.jsonCamelCase, EmitUnpopulated: !s.jsonSkipDefaults}
	respBytes, err := marshaler.Marshal(respContent)
	if err != nil {
		s.writeError(ctx, resp, wrapInternal(err, "failed to marshal json response"))
		return
	}

	ctx = ctxsetters.WithStatusCode(ctx, http.StatusOK)
	resp.Header().Set("Content-Type", "application/json")
	resp.Header().Set("Content-Length", strconv.Itoa(len(respBytes)))
	resp.WriteHeader(http.StatusOK)

	if n, err := resp.Write(respBytes); err != nil {
		msg := fmt.Sprintf("failed to write response, %d of %d bytes written: %s", n, len(respBytes), err.Error())
		twerr := twirp.NewError(twirp.Unknown, msg)
		ctx = callError(ctx, s.hooks, twerr)
	}
	callResponseSent(ctx, s.hooks)
}

func (s *teamServiceServer) serveAddTeamOrganizationScopeByNameProtobuf(ctx context.Context, resp http.ResponseWriter, req *http.Request) {
	var err error
	ctx = ctxsetters.WithMethodName(ctx, "AddTeamOrganizationScopeByName")
	ctx, err = callRequestRouted(ctx, s.hooks)
	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}

	buf, err := ioutil.ReadAll(req.Body)
	if err != nil {
		s.handleRequestBodyError(ctx, resp, "failed to read request body", err)
		return
	}
	reqContent := new(AddTeamOrganizationScopeByNameRequest)
	if err = proto.Unmarshal(buf, reqContent); err != nil {
		s.writeError(ctx, resp, malformedRequestError("the protobuf request could not be decoded"))
		return
	}

	handler := s.TeamService.AddTeamOrganizationScopeByName
	if s.interceptor != nil {
		handler = func(ctx context.Context, req *AddTeamOrganizationScopeByNameRequest) (*AddTeamOrganizationScopeByNameResponse, error) {
			resp, err := s.interceptor(
				func(ctx context.Context, req interface{}) (interface{}, error) {
					typedReq, ok := req.(*AddTeamOrganizationScopeByNameRequest)
					if !ok {
						return nil, twirp.InternalError("failed type assertion req.(*AddTeamOrganizationScopeByNameRequest) when calling interceptor")
					}
					return s.TeamService.AddTeamOrganizationScopeByName(ctx, typedReq)
				},
			)(ctx, req)
			if resp != nil {
				typedResp, ok := resp.(*AddTeamOrganizationScopeByNameResponse)
				if !ok {
					return nil, twirp.InternalError("failed type assertion resp.(*AddTeamOrganizationScopeByNameResponse) when calling interceptor")
				}
				return typedResp, err
			}
			return nil, err
		}
	}

	// Call service method
	var respContent *AddTeamOrganizationScopeByNameResponse
	func() {
		defer ensurePanicResponses(ctx, resp, s.hooks)
		respContent, err = handler(ctx, reqContent)
	}()

	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}
	if respContent == nil {
		s.writeError(ctx, resp, twirp.InternalError("received a nil *AddTeamOrganizationScopeByNameResponse and nil error while calling AddTeamOrganizationScopeByName. nil responses are not supported"))
		return
	}

	ctx = callResponsePrepared(ctx, s.hooks)

	respBytes, err := proto.Marshal(respContent)
	if err != nil {
		s.writeError(ctx, resp, wrapInternal(err, "failed to marshal proto response"))
		return
	}

	ctx = ctxsetters.WithStatusCode(ctx, http.StatusOK)
	resp.Header().Set("Content-Type", "application/protobuf")
	resp.Header().Set("Content-Length", strconv.Itoa(len(respBytes)))
	resp.WriteHeader(http.StatusOK)
	if n, err := resp.Write(respBytes); err != nil {
		msg := fmt.Sprintf("failed to write response, %d of %d bytes written: %s", n, len(respBytes), err.Error())
		twerr := twirp.NewError(twirp.Unknown, msg)
		ctx = callError(ctx, s.hooks, twerr)
	}
	callResponseSent(ctx, s.hooks)
}

func (s *teamServiceServer) serveRemoveTeamOrganizationScope(ctx context.Context, resp http.ResponseWriter, req *http.Request) {
	header := req.Header.Get("Content-Type")
	i := strings.Index(header, ";")
	if i == -1 {
		i = len(header)
	}
	switch strings.TrimSpace(strings.ToLower(header[:i])) {
	case "application/json":
		s.serveRemoveTeamOrganizationScopeJSON(ctx, resp, req)
	case "application/protobuf":
		s.serveRemoveTeamOrganizationScopeProtobuf(ctx, resp, req)
	default:
		msg := fmt.Sprintf("unexpected Content-Type: %q", req.Header.Get("Content-Type"))
		twerr := badRouteError(msg, req.Method, req.URL.Path)
		s.writeError(ctx, resp, twerr)
	}
}

func (s *teamServiceServer) serveRemoveTeamOrganizationScopeJSON(ctx context.Context, resp http.ResponseWriter, req *http.Request) {
	var err error
	ctx = ctxsetters.WithMethodName(ctx, "RemoveTeamOrganizationScope")
	ctx, err = callRequestRouted(ctx, s.hooks)
	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}

	d := json.NewDecoder(req.Body)
	rawReqBody := json.RawMessage{}
	if err := d.Decode(&rawReqBody); err != nil {
		s.handleRequestBodyError(ctx, resp, "the json request could not be decoded", err)
		return
	}
	reqContent := new(RemoveTeamOrganizationScopeRequest)
	unmarshaler := protojson.UnmarshalOptions{DiscardUnknown: true}
	if err = unmarshaler.Unmarshal(rawReqBody, reqContent); err != nil {
		s.handleRequestBodyError(ctx, resp, "the json request could not be decoded", err)
		return
	}

	handler := s.TeamService.RemoveTeamOrganizationScope
	if s.interceptor != nil {
		handler = func(ctx context.Context, req *RemoveTeamOrganizationScopeRequest) (*RemoveTeamOrganizationScopeResponse, error) {
			resp, err := s.interceptor(
				func(ctx context.Context, req interface{}) (interface{}, error) {
					typedReq, ok := req.(*RemoveTeamOrganizationScopeRequest)
					if !ok {
						return nil, twirp.InternalError("failed type assertion req.(*RemoveTeamOrganizationScopeRequest) when calling interceptor")
					}
					return s.TeamService.RemoveTeamOrganizationScope(ctx, typedReq)
				},
			)(ctx, req)
			if resp != nil {
				typedResp, ok := resp.(*RemoveTeamOrganizationScopeResponse)
				if !ok {
					return nil, twirp.InternalError("failed type assertion resp.(*RemoveTeamOrganizationScopeResponse) when calling interceptor")
				}
				return typedResp, err
			}
			return nil, err
		}
	}

	// Call service method
	var respContent *RemoveTeamOrganizationScopeResponse
	func() {
		defer ensurePanicResponses(ctx, resp, s.hooks)
		respContent, err = handler(ctx, reqContent)
	}()

	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}
	if respContent == nil {
		s.writeError(ctx, resp, twirp.InternalError("received a nil *RemoveTeamOrganizationScopeResponse and nil error while calling RemoveTeamOrganizationScope. nil responses are not supported"))
		return
	}

	ctx = callResponsePrepared(ctx, s.hooks)

	marshaler := &protojson.MarshalOptions{UseProtoNames: !s.jsonCamelCase, EmitUnpopulated: !s.jsonSkipDefaults}
	respBytes, err := marshaler.Marshal(respContent)
	if err != nil {
		s.writeError(ctx, resp, wrapInternal(err, "failed to marshal json response"))
		return
	}

	ctx = ctxsetters.WithStatusCode(ctx, http.StatusOK)
	resp.Header().Set("Content-Type", "application/json")
	resp.Header().Set("Content-Length", strconv.Itoa(len(respBytes)))
	resp.WriteHeader(http.StatusOK)

	if n, err := resp.Write(respBytes); err != nil {
		msg := fmt.Sprintf("failed to write response, %d of %d bytes written: %s", n, len(respBytes), err.Error())
		twerr := twirp.NewError(twirp.Unknown, msg)
		ctx = callError(ctx, s.hooks, twerr)
	}
	callResponseSent(ctx, s.hooks)
}

func (s *teamServiceServer) serveRemoveTeamOrganizationScopeProtobuf(ctx context.Context, resp http.ResponseWriter, req *http.Request) {
	var err error
	ctx = ctxsetters.WithMethodName(ctx, "RemoveTeamOrganizationScope")
	ctx, err = callRequestRouted(ctx, s.hooks)
	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}

	buf, err := ioutil.ReadAll(req.Body)
	if err != nil {
		s.handleRequestBodyError(ctx, resp, "failed to read request body", err)
		return
	}
	reqContent := new(RemoveTeamOrganizationScopeRequest)
	if err = proto.Unmarshal(buf, reqContent); err != nil {
		s.writeError(ctx, resp, malformedRequestError("the protobuf request could not be decoded"))
		return
	}

	handler := s.TeamService.RemoveTeamOrganizationScope
	if s.interceptor != nil {
		handler = func(ctx context.Context, req *RemoveTeamOrganizationScopeRequest) (*RemoveTeamOrganizationScopeResponse, error) {
			resp, err := s.interceptor(
				func(ctx context.Context, req interface{}) (interface{}, error) {
					typedReq, ok := req.(*RemoveTeamOrganizationScopeRequest)
					if !ok {
						return nil, twirp.InternalError("failed type assertion req.(*RemoveTeamOrganizationScopeRequest) when calling interceptor")
					}
					return s.TeamService.RemoveTeamOrganizationScope(ctx, typedReq)
				},
			)(ctx, req)
			if resp != nil {
				typedResp, ok := resp.(*RemoveTeamOrganizationScopeResponse)
				if !ok {
					return nil, twirp.InternalError("failed type assertion resp.(*RemoveTeamOrganizationScopeResponse) when calling interceptor")
				}
				return typedResp, err
			}
			return nil, err
		}
	}

	// Call service method
	var respContent *RemoveTeamOrganizationScopeResponse
	func() {
		defer ensurePanicResponses(ctx, resp, s.hooks)
		respContent, err = handler(ctx, reqContent)
	}()

	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}
	if respContent == nil {
		s.writeError(ctx, resp, twirp.InternalError("received a nil *RemoveTeamOrganizationScopeResponse and nil error while calling RemoveTeamOrganizationScope. nil responses are not supported"))
		return
	}

	ctx = callResponsePrepared(ctx, s.hooks)

	respBytes, err := proto.Marshal(respContent)
	if err != nil {
		s.writeError(ctx, resp, wrapInternal(err, "failed to marshal proto response"))
		return
	}

	ctx = ctxsetters.WithStatusCode(ctx, http.StatusOK)
	resp.Header().Set("Content-Type", "application/protobuf")
	resp.Header().Set("Content-Length", strconv.Itoa(len(respBytes)))
	resp.WriteHeader(http.StatusOK)
	if n, err := resp.Write(respBytes); err != nil {
		msg := fmt.Sprintf("failed to write response, %d of %d bytes written: %s", n, len(respBytes), err.Error())
		twerr := twirp.NewError(twirp.Unknown, msg)
		ctx = callError(ctx, s.hooks, twerr)
	}
	callResponseSent(ctx, s.hooks)
}

func (s *teamServiceServer) serveRemoveTeamOrganizationScopeByName(ctx context.Context, resp http.ResponseWriter, req *http.Request) {
	header := req.Header.Get("Content-Type")
	i := strings.Index(header, ";")
	if i == -1 {
		i = len(header)
	}
	switch strings.TrimSpace(strings.ToLower(header[:i])) {
	case "application/json":
		s.serveRemoveTeamOrganizationScopeByNameJSON(ctx, resp, req)
	case "application/protobuf":
		s.serveRemoveTeamOrganizationScopeByNameProtobuf(ctx, resp, req)
	default:
		msg := fmt.Sprintf("unexpected Content-Type: %q", req.Header.Get("Content-Type"))
		twerr := badRouteError(msg, req.Method, req.URL.Path)
		s.writeError(ctx, resp, twerr)
	}
}

func (s *teamServiceServer) serveRemoveTeamOrganizationScopeByNameJSON(ctx context.Context, resp http.ResponseWriter, req *http.Request) {
	var err error
	ctx = ctxsetters.WithMethodName(ctx, "RemoveTeamOrganizationScopeByName")
	ctx, err = callRequestRouted(ctx, s.hooks)
	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}

	d := json.NewDecoder(req.Body)
	rawReqBody := json.RawMessage{}
	if err := d.Decode(&rawReqBody); err != nil {
		s.handleRequestBodyError(ctx, resp, "the json request could not be decoded", err)
		return
	}
	reqContent := new(RemoveTeamOrganizationScopeByNameRequest)
	unmarshaler := protojson.UnmarshalOptions{DiscardUnknown: true}
	if err = unmarshaler.Unmarshal(rawReqBody, reqContent); err != nil {
		s.handleRequestBodyError(ctx, resp, "the json request could not be decoded", err)
		return
	}

	handler := s.TeamService.RemoveTeamOrganizationScopeByName
	if s.interceptor != nil {
		handler = func(ctx context.Context, req *RemoveTeamOrganizationScopeByNameRequest) (*RemoveTeamOrganizationScopeByNameResponse, error) {
			resp, err := s.interceptor(
				func(ctx context.Context, req interface{}) (interface{}, error) {
					typedReq, ok := req.(*RemoveTeamOrganizationScopeByNameRequest)
					if !ok {
						return nil, twirp.InternalError("failed type assertion req.(*RemoveTeamOrganizationScopeByNameRequest) when calling interceptor")
					}
					return s.TeamService.RemoveTeamOrganizationScopeByName(ctx, typedReq)
				},
			)(ctx, req)
			if resp != nil {
				typedResp, ok := resp.(*RemoveTeamOrganizationScopeByNameResponse)
				if !ok {
					return nil, twirp.InternalError("failed type assertion resp.(*RemoveTeamOrganizationScopeByNameResponse) when calling interceptor")
				}
				return typedResp, err
			}
			return nil, err
		}
	}

	// Call service method
	var respContent *RemoveTeamOrganizationScopeByNameResponse
	func() {
		defer ensurePanicResponses(ctx, resp, s.hooks)
		respContent, err = handler(ctx, reqContent)
	}()

	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}
	if respContent == nil {
		s.writeError(ctx, resp, twirp.InternalError("received a nil *RemoveTeamOrganizationScopeByNameResponse and nil error while calling RemoveTeamOrganizationScopeByName. nil responses are not supported"))
		return
	}

	ctx = callResponsePrepared(ctx, s.hooks)

	marshaler := &protojson.MarshalOptions{UseProtoNames: !s.jsonCamelCase, EmitUnpopulated: !s.jsonSkipDefaults}
	respBytes, err := marshaler.Marshal(respContent)
	if err != nil {
		s.writeError(ctx, resp, wrapInternal(err, "failed to marshal json response"))
		return
	}

	ctx = ctxsetters.WithStatusCode(ctx, http.StatusOK)
	resp.Header().Set("Content-Type", "application/json")
	resp.Header().Set("Content-Length", strconv.Itoa(len(respBytes)))
	resp.WriteHeader(http.StatusOK)

	if n, err := resp.Write(respBytes); err != nil {
		msg := fmt.Sprintf("failed to write response, %d of %d bytes written: %s", n, len(respBytes), err.Error())
		twerr := twirp.NewError(twirp.Unknown, msg)
		ctx = callError(ctx, s.hooks, twerr)
	}
	callResponseSent(ctx, s.hooks)
}

func (s *teamServiceServer) serveRemoveTeamOrganizationScopeByNameProtobuf(ctx context.Context, resp http.ResponseWriter, req *http.Request) {
	var err error
	ctx = ctxsetters.WithMethodName(ctx, "RemoveTeamOrganizationScopeByName")
	ctx, err = callRequestRouted(ctx, s.hooks)
	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}

	buf, err := ioutil.ReadAll(req.Body)
	if err != nil {
		s.handleRequestBodyError(ctx, resp, "failed to read request body", err)
		return
	}
	reqContent := new(RemoveTeamOrganizationScopeByNameRequest)
	if err = proto.Unmarshal(buf, reqContent); err != nil {
		s.writeError(ctx, resp, malformedRequestError("the protobuf request could not be decoded"))
		return
	}

	handler := s.TeamService.RemoveTeamOrganizationScopeByName
	if s.interceptor != nil {
		handler = func(ctx context.Context, req *RemoveTeamOrganizationScopeByNameRequest) (*RemoveTeamOrganizationScopeByNameResponse, error) {
			resp, err := s.interceptor(
				func(ctx context.Context, req interface{}) (interface{}, error) {
					typedReq, ok := req.(*RemoveTeamOrganizationScopeByNameRequest)
					if !ok {
						return nil, twirp.InternalError("failed type assertion req.(*RemoveTeamOrganizationScopeByNameRequest) when calling interceptor")
					}
					return s.TeamService.RemoveTeamOrganizationScopeByName(ctx, typedReq)
				},
			)(ctx, req)
			if resp != nil {
				typedResp, ok := resp.(*RemoveTeamOrganizationScopeByNameResponse)
				if !ok {
					return nil, twirp.InternalError("failed type assertion resp.(*RemoveTeamOrganizationScopeByNameResponse) when calling interceptor")
				}
				return typedResp, err
			}
			return nil, err
		}
	}

	// Call service method
	var respContent *RemoveTeamOrganizationScopeByNameResponse
	func() {
		defer ensurePanicResponses(ctx, resp, s.hooks)
		respContent, err = handler(ctx, reqContent)
	}()

	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}
	if respContent == nil {
		s.writeError(ctx, resp, twirp.InternalError("received a nil *RemoveTeamOrganizationScopeByNameResponse and nil error while calling RemoveTeamOrganizationScopeByName. nil responses are not supported"))
		return
	}

	ctx = callResponsePrepared(ctx, s.hooks)

	respBytes, err := proto.Marshal(respContent)
	if err != nil {
		s.writeError(ctx, resp, wrapInternal(err, "failed to marshal proto response"))
		return
	}

	ctx = ctxsetters.WithStatusCode(ctx, http.StatusOK)
	resp.Header().Set("Content-Type", "application/protobuf")
	resp.Header().Set("Content-Length", strconv.Itoa(len(respBytes)))
	resp.WriteHeader(http.StatusOK)
	if n, err := resp.Write(respBytes); err != nil {
		msg := fmt.Sprintf("failed to write response, %d of %d bytes written: %s", n, len(respBytes), err.Error())
		twerr := twirp.NewError(twirp.Unknown, msg)
		ctx = callError(ctx, s.hooks, twerr)
	}
	callResponseSent(ctx, s.hooks)
}

func (s *teamServiceServer) serveAddTeamBaseRepositoryScope(ctx context.Context, resp http.ResponseWriter, req *http.Request) {
	header := req.Header.Get("Content-Type")
	i := strings.Index(header, ";")
	if i == -1 {
		i = len(header)
	}
	switch strings.TrimSpace(strings.ToLower(header[:i])) {
	case "application/json":
		s.serveAddTeamBaseRepositoryScopeJSON(ctx, resp, req)
	case "application/protobuf":
		s.serveAddTeamBaseRepositoryScopeProtobuf(ctx, resp, req)
	default:
		msg := fmt.Sprintf("unexpected Content-Type: %q", req.Header.Get("Content-Type"))
		twerr := badRouteError(msg, req.Method, req.URL.Path)
		s.writeError(ctx, resp, twerr)
	}
}

func (s *teamServiceServer) serveAddTeamBaseRepositoryScopeJSON(ctx context.Context, resp http.ResponseWriter, req *http.Request) {
	var err error
	ctx = ctxsetters.WithMethodName(ctx, "AddTeamBaseRepositoryScope")
	ctx, err = callRequestRouted(ctx, s.hooks)
	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}

	d := json.NewDecoder(req.Body)
	rawReqBody := json.RawMessage{}
	if err := d.Decode(&rawReqBody); err != nil {
		s.handleRequestBodyError(ctx, resp, "the json request could not be decoded", err)
		return
	}
	reqContent := new(AddTeamBaseRepositoryScopeRequest)
	unmarshaler := protojson.UnmarshalOptions{DiscardUnknown: true}
	if err = unmarshaler.Unmarshal(rawReqBody, reqContent); err != nil {
		s.handleRequestBodyError(ctx, resp, "the json request could not be decoded", err)
		return
	}

	handler := s.TeamService.AddTeamBaseRepositoryScope
	if s.interceptor != nil {
		handler = func(ctx context.Context, req *AddTeamBaseRepositoryScopeRequest) (*AddTeamBaseRepositoryScopeResponse, error) {
			resp, err := s.interceptor(
				func(ctx context.Context, req interface{}) (interface{}, error) {
					typedReq, ok := req.(*AddTeamBaseRepositoryScopeRequest)
					if !ok {
						return nil, twirp.InternalError("failed type assertion req.(*AddTeamBaseRepositoryScopeRequest) when calling interceptor")
					}
					return s.TeamService.AddTeamBaseRepositoryScope(ctx, typedReq)
				},
			)(ctx, req)
			if resp != nil {
				typedResp, ok := resp.(*AddTeamBaseRepositoryScopeResponse)
				if !ok {
					return nil, twirp.InternalError("failed type assertion resp.(*AddTeamBaseRepositoryScopeResponse) when calling interceptor")
				}
				return typedResp, err
			}
			return nil, err
		}
	}

	// Call service method
	var respContent *AddTeamBaseRepositoryScopeResponse
	func() {
		defer ensurePanicResponses(ctx, resp, s.hooks)
		respContent, err = handler(ctx, reqContent)
	}()

	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}
	if respContent == nil {
		s.writeError(ctx, resp, twirp.InternalError("received a nil *AddTeamBaseRepositoryScopeResponse and nil error while calling AddTeamBaseRepositoryScope. nil responses are not supported"))
		return
	}

	ctx = callResponsePrepared(ctx, s.hooks)

	marshaler := &protojson.MarshalOptions{UseProtoNames: !s.jsonCamelCase, EmitUnpopulated: !s.jsonSkipDefaults}
	respBytes, err := marshaler.Marshal(respContent)
	if err != nil {
		s.writeError(ctx, resp, wrapInternal(err, "failed to marshal json response"))
		return
	}

	ctx = ctxsetters.WithStatusCode(ctx, http.StatusOK)
	resp.Header().Set("Content-Type", "application/json")
	resp.Header().Set("Content-Length", strconv.Itoa(len(respBytes)))
	resp.WriteHeader(http.StatusOK)

	if n, err := resp.Write(respBytes); err != nil {
		msg := fmt.Sprintf("failed to write response, %d of %d bytes written: %s", n, len(respBytes), err.Error())
		twerr := twirp.NewError(twirp.Unknown, msg)
		ctx = callError(ctx, s.hooks, twerr)
	}
	callResponseSent(ctx, s.hooks)
}

func (s *teamServiceServer) serveAddTeamBaseRepositoryScopeProtobuf(ctx context.Context, resp http.ResponseWriter, req *http.Request) {
	var err error
	ctx = ctxsetters.WithMethodName(ctx, "AddTeamBaseRepositoryScope")
	ctx, err = callRequestRouted(ctx, s.hooks)
	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}

	buf, err := ioutil.ReadAll(req.Body)
	if err != nil {
		s.handleRequestBodyError(ctx, resp, "failed to read request body", err)
		return
	}
	reqContent := new(AddTeamBaseRepositoryScopeRequest)
	if err = proto.Unmarshal(buf, reqContent); err != nil {
		s.writeError(ctx, resp, malformedRequestError("the protobuf request could not be decoded"))
		return
	}

	handler := s.TeamService.AddTeamBaseRepositoryScope
	if s.interceptor != nil {
		handler = func(ctx context.Context, req *AddTeamBaseRepositoryScopeRequest) (*AddTeamBaseRepositoryScopeResponse, error) {
			resp, err := s.interceptor(
				func(ctx context.Context, req interface{}) (interface{}, error) {
					typedReq, ok := req.(*AddTeamBaseRepositoryScopeRequest)
					if !ok {
						return nil, twirp.InternalError("failed type assertion req.(*AddTeamBaseRepositoryScopeRequest) when calling interceptor")
					}
					return s.TeamService.AddTeamBaseRepositoryScope(ctx, typedReq)
				},
			)(ctx, req)
			if resp != nil {
				typedResp, ok := resp.(*AddTeamBaseRepositoryScopeResponse)
				if !ok {
					return nil, twirp.InternalError("failed type assertion resp.(*AddTeamBaseRepositoryScopeResponse) when calling interceptor")
				}
				return typedResp, err
			}
			return nil, err
		}
	}

	// Call service method
	var respContent *AddTeamBaseRepositoryScopeResponse
	func() {
		defer ensurePanicResponses(ctx, resp, s.hooks)
		respContent, err = handler(ctx, reqContent)
	}()

	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}
	if respContent == nil {
		s.writeError(ctx, resp, twirp.InternalError("received a nil *AddTeamBaseRepositoryScopeResponse and nil error while calling AddTeamBaseRepositoryScope. nil responses are not supported"))
		return
	}

	ctx = callResponsePrepared(ctx, s.hooks)

	respBytes, err := proto.Marshal(respContent)
	if err != nil {
		s.writeError(ctx, resp, wrapInternal(err, "failed to marshal proto response"))
		return
	}

	ctx = ctxsetters.WithStatusCode(ctx, http.StatusOK)
	resp.Header().Set("Content-Type", "application/protobuf")
	resp.Header().Set("Content-Length", strconv.Itoa(len(respBytes)))
	resp.WriteHeader(http.StatusOK)
	if n, err := resp.Write(respBytes); err != nil {
		msg := fmt.Sprintf("failed to write response, %d of %d bytes written: %s", n, len(respBytes), err.Error())
		twerr := twirp.NewError(twirp.Unknown, msg)
		ctx = callError(ctx, s.hooks, twerr)
	}
	callResponseSent(ctx, s.hooks)
}

func (s *teamServiceServer) serveAddTeamBaseRepositoryScopeByName(ctx context.Context, resp http.ResponseWriter, req *http.Request) {
	header := req.Header.Get("Content-Type")
	i := strings.Index(header, ";")
	if i == -1 {
		i = len(header)
	}
	switch strings.TrimSpace(strings.ToLower(header[:i])) {
	case "application/json":
		s.serveAddTeamBaseRepositoryScopeByNameJSON(ctx, resp, req)
	case "application/protobuf":
		s.serveAddTeamBaseRepositoryScopeByNameProtobuf(ctx, resp, req)
	default:
		msg := fmt.Sprintf("unexpected Content-Type: %q", req.Header.Get("Content-Type"))
		twerr := badRouteError(msg, req.Method, req.URL.Path)
		s.writeError(ctx, resp, twerr)
	}
}

func (s *teamServiceServer) serveAddTeamBaseRepositoryScopeByNameJSON(ctx context.Context, resp http.ResponseWriter, req *http.Request) {
	var err error
	ctx = ctxsetters.WithMethodName(ctx, "AddTeamBaseRepositoryScopeByName")
	ctx, err = callRequestRouted(ctx, s.hooks)
	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}

	d := json.NewDecoder(req.Body)
	rawReqBody := json.RawMessage{}
	if err := d.Decode(&rawReqBody); err != nil {
		s.handleRequestBodyError(ctx, resp, "the json request could not be decoded", err)
		return
	}
	reqContent := new(AddTeamBaseRepositoryScopeByNameRequest)
	unmarshaler := protojson.UnmarshalOptions{DiscardUnknown: true}
	if err = unmarshaler.Unmarshal(rawReqBody, reqContent); err != nil {
		s.handleRequestBodyError(ctx, resp, "the json request could not be decoded", err)
		return
	}

	handler := s.TeamService.AddTeamBaseRepositoryScopeByName
	if s.interceptor != nil {
		handler = func(ctx context.Context, req *AddTeamBaseRepositoryScopeByNameRequest) (*AddTeamBaseRepositoryScopeByNameResponse, error) {
			resp, err := s.interceptor(
				func(ctx context.Context, req interface{}) (interface{}, error) {
					typedReq, ok := req.(*AddTeamBaseRepositoryScopeByNameRequest)
					if !ok {
						return nil, twirp.InternalError("failed type assertion req.(*AddTeamBaseRepositoryScopeByNameRequest) when calling interceptor")
					}
					return s.TeamService.AddTeamBaseRepositoryScopeByName(ctx, typedReq)
				},
			)(ctx, req)
			if resp != nil {
				typedResp, ok := resp.(*AddTeamBaseRepositoryScopeByNameResponse)
				if !ok {
					return nil, twirp.InternalError("failed type assertion resp.(*AddTeamBaseRepositoryScopeByNameResponse) when calling interceptor")
				}
				return typedResp, err
			}
			return nil, err
		}
	}

	// Call service method
	var respContent *AddTeamBaseRepositoryScopeByNameResponse
	func() {
		defer ensurePanicResponses(ctx, resp, s.hooks)
		respContent, err = handler(ctx, reqContent)
	}()

	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}
	if respContent == nil {
		s.writeError(ctx, resp, twirp.InternalError("received a nil *AddTeamBaseRepositoryScopeByNameResponse and nil error while calling AddTeamBaseRepositoryScopeByName. nil responses are not supported"))
		return
	}

	ctx = callResponsePrepared(ctx, s.hooks)

	marshaler := &protojson.MarshalOptions{UseProtoNames: !s.jsonCamelCase, EmitUnpopulated: !s.jsonSkipDefaults}
	respBytes, err := marshaler.Marshal(respContent)
	if err != nil {
		s.writeError(ctx, resp, wrapInternal(err, "failed to marshal json response"))
		return
	}

	ctx = ctxsetters.WithStatusCode(ctx, http.StatusOK)
	resp.Header().Set("Content-Type", "application/json")
	resp.Header().Set("Content-Length", strconv.Itoa(len(respBytes)))
	resp.WriteHeader(http.StatusOK)

	if n, err := resp.Write(respBytes); err != nil {
		msg := fmt.Sprintf("failed to write response, %d of %d bytes written: %s", n, len(respBytes), err.Error())
		twerr := twirp.NewError(twirp.Unknown, msg)
		ctx = callError(ctx, s.hooks, twerr)
	}
	callResponseSent(ctx, s.hooks)
}

func (s *teamServiceServer) serveAddTeamBaseRepositoryScopeByNameProtobuf(ctx context.Context, resp http.ResponseWriter, req *http.Request) {
	var err error
	ctx = ctxsetters.WithMethodName(ctx, "AddTeamBaseRepositoryScopeByName")
	ctx, err = callRequestRouted(ctx, s.hooks)
	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}

	buf, err := ioutil.ReadAll(req.Body)
	if err != nil {
		s.handleRequestBodyError(ctx, resp, "failed to read request body", err)
		return
	}
	reqContent := new(AddTeamBaseRepositoryScopeByNameRequest)
	if err = proto.Unmarshal(buf, reqContent); err != nil {
		s.writeError(ctx, resp, malformedRequestError("the protobuf request could not be decoded"))
		return
	}

	handler := s.TeamService.AddTeamBaseRepositoryScopeByName
	if s.interceptor != nil {
		handler = func(ctx context.Context, req *AddTeamBaseRepositoryScopeByNameRequest) (*AddTeamBaseRepositoryScopeByNameResponse, error) {
			resp, err := s.interceptor(
				func(ctx context.Context, req interface{}) (interface{}, error) {
					typedReq, ok := req.(*AddTeamBaseRepositoryScopeByNameRequest)
					if !ok {
						return nil, twirp.InternalError("failed type assertion req.(*AddTeamBaseRepositoryScopeByNameRequest) when calling interceptor")
					}
					return s.TeamService.AddTeamBaseRepositoryScopeByName(ctx, typedReq)
				},
			)(ctx, req)
			if resp != nil {
				typedResp, ok := resp.(*AddTeamBaseRepositoryScopeByNameResponse)
				if !ok {
					return nil, twirp.InternalError("failed type assertion resp.(*AddTeamBaseRepositoryScopeByNameResponse) when calling interceptor")
				}
				return typedResp, err
			}
			return nil, err
		}
	}

	// Call service method
	var respContent *AddTeamBaseRepositoryScopeByNameResponse
	func() {
		defer ensurePanicResponses(ctx, resp, s.hooks)
		respContent, err = handler(ctx, reqContent)
	}()

	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}
	if respContent == nil {
		s.writeError(ctx, resp, twirp.InternalError("received a nil *AddTeamBaseRepositoryScopeByNameResponse and nil error while calling AddTeamBaseRepositoryScopeByName. nil responses are not supported"))
		return
	}

	ctx = callResponsePrepared(ctx, s.hooks)

	respBytes, err := proto.Marshal(respContent)
	if err != nil {
		s.writeError(ctx, resp, wrapInternal(err, "failed to marshal proto response"))
		return
	}

	ctx = ctxsetters.WithStatusCode(ctx, http.StatusOK)
	resp.Header().Set("Content-Type", "application/protobuf")
	resp.Header().Set("Content-Length", strconv.Itoa(len(respBytes)))
	resp.WriteHeader(http.StatusOK)
	if n, err := resp.Write(respBytes); err != nil {
		msg := fmt.Sprintf("failed to write response, %d of %d bytes written: %s", n, len(respBytes), err.Error())
		twerr := twirp.NewError(twirp.Unknown, msg)
		ctx = callError(ctx, s.hooks, twerr)
	}
	callResponseSent(ctx, s.hooks)
}

func (s *teamServiceServer) serveRemoveTeamBaseRepositoryScope(ctx context.Context, resp http.ResponseWriter, req *http.Request) {
	header := req.Header.Get("Content-Type")
	i := strings.Index(header, ";")
	if i == -1 {
		i = len(header)
	}
	switch strings.TrimSpace(strings.ToLower(header[:i])) {
	case "application/json":
		s.serveRemoveTeamBaseRepositoryScopeJSON(ctx, resp, req)
	case "application/protobuf":
		s.serveRemoveTeamBaseRepositoryScopeProtobuf(ctx, resp, req)
	default:
		msg := fmt.Sprintf("unexpected Content-Type: %q", req.Header.Get("Content-Type"))
		twerr := badRouteError(msg, req.Method, req.URL.Path)
		s.writeError(ctx, resp, twerr)
	}
}

func (s *teamServiceServer) serveRemoveTeamBaseRepositoryScopeJSON(ctx context.Context, resp http.ResponseWriter, req *http.Request) {
	var err error
	ctx = ctxsetters.WithMethodName(ctx, "RemoveTeamBaseRepositoryScope")
	ctx, err = callRequestRouted(ctx, s.hooks)
	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}

	d := json.NewDecoder(req.Body)
	rawReqBody := json.RawMessage{}
	if err := d.Decode(&rawReqBody); err != nil {
		s.handleRequestBodyError(ctx, resp, "the json request could not be decoded", err)
		return
	}
	reqContent := new(RemoveTeamBaseRepositoryScopeRequest)
	unmarshaler := protojson.UnmarshalOptions{DiscardUnknown: true}
	if err = unmarshaler.Unmarshal(rawReqBody, reqContent); err != nil {
		s.handleRequestBodyError(ctx, resp, "the json request could not be decoded", err)
		return
	}

	handler := s.TeamService.RemoveTeamBaseRepositoryScope
	if s.interceptor != nil {
		handler = func(ctx context.Context, req *RemoveTeamBaseRepositoryScopeRequest) (*RemoveTeamBaseRepositoryScopeResponse, error) {
			resp, err := s.interceptor(
				func(ctx context.Context, req interface{}) (interface{}, error) {
					typedReq, ok := req.(*RemoveTeamBaseRepositoryScopeRequest)
					if !ok {
						return nil, twirp.InternalError("failed type assertion req.(*RemoveTeamBaseRepositoryScopeRequest) when calling interceptor")
					}
					return s.TeamService.RemoveTeamBaseRepositoryScope(ctx, typedReq)
				},
			)(ctx, req)
			if resp != nil {
				typedResp, ok := resp.(*RemoveTeamBaseRepositoryScopeResponse)
				if !ok {
					return nil, twirp.InternalError("failed type assertion resp.(*RemoveTeamBaseRepositoryScopeResponse) when calling interceptor")
				}
				return typedResp, err
			}
			return nil, err
		}
	}

	// Call service method
	var respContent *RemoveTeamBaseRepositoryScopeResponse
	func() {
		defer ensurePanicResponses(ctx, resp, s.hooks)
		respContent, err = handler(ctx, reqContent)
	}()

	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}
	if respContent == nil {
		s.writeError(ctx, resp, twirp.InternalError("received a nil *RemoveTeamBaseRepositoryScopeResponse and nil error while calling RemoveTeamBaseRepositoryScope. nil responses are not supported"))
		return
	}

	ctx = callResponsePrepared(ctx, s.hooks)

	marshaler := &protojson.MarshalOptions{UseProtoNames: !s.jsonCamelCase, EmitUnpopulated: !s.jsonSkipDefaults}
	respBytes, err := marshaler.Marshal(respContent)
	if err != nil {
		s.writeError(ctx, resp, wrapInternal(err, "failed to marshal json response"))
		return
	}

	ctx = ctxsetters.WithStatusCode(ctx, http.StatusOK)
	resp.Header().Set("Content-Type", "application/json")
	resp.Header().Set("Content-Length", strconv.Itoa(len(respBytes)))
	resp.WriteHeader(http.StatusOK)

	if n, err := resp.Write(respBytes); err != nil {
		msg := fmt.Sprintf("failed to write response, %d of %d bytes written: %s", n, len(respBytes), err.Error())
		twerr := twirp.NewError(twirp.Unknown, msg)
		ctx = callError(ctx, s.hooks, twerr)
	}
	callResponseSent(ctx, s.hooks)
}

func (s *teamServiceServer) serveRemoveTeamBaseRepositoryScopeProtobuf(ctx context.Context, resp http.ResponseWriter, req *http.Request) {
	var err error
	ctx = ctxsetters.WithMethodName(ctx, "RemoveTeamBaseRepositoryScope")
	ctx, err = callRequestRouted(ctx, s.hooks)
	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}

	buf, err := ioutil.ReadAll(req.Body)
	if err != nil {
		s.handleRequestBodyError(ctx, resp, "failed to read request body", err)
		return
	}
	reqContent := new(RemoveTeamBaseRepositoryScopeRequest)
	if err = proto.Unmarshal(buf, reqContent); err != nil {
		s.writeError(ctx, resp, malformedRequestError("the protobuf request could not be decoded"))
		return
	}

	handler := s.TeamService.RemoveTeamBaseRepositoryScope
	if s.interceptor != nil {
		handler = func(ctx context.Context, req *RemoveTeamBaseRepositoryScopeRequest) (*RemoveTeamBaseRepositoryScopeResponse, error) {
			resp, err := s.interceptor(
				func(ctx context.Context, req interface{}) (interface{}, error) {
					typedReq, ok := req.(*RemoveTeamBaseRepositoryScopeRequest)
					if !ok {
						return nil, twirp.InternalError("failed type assertion req.(*RemoveTeamBaseRepositoryScopeRequest) when calling interceptor")
					}
					return s.TeamService.RemoveTeamBaseRepositoryScope(ctx, typedReq)
				},
			)(ctx, req)
			if resp != nil {
				typedResp, ok := resp.(*RemoveTeamBaseRepositoryScopeResponse)
				if !ok {
					return nil, twirp.InternalError("failed type assertion resp.(*RemoveTeamBaseRepositoryScopeResponse) when calling interceptor")
				}
				return typedResp, err
			}
			return nil, err
		}
	}

	// Call service method
	var respContent *RemoveTeamBaseRepositoryScopeResponse
	func() {
		defer ensurePanicResponses(ctx, resp, s.hooks)
		respContent, err = handler(ctx, reqContent)
	}()

	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}
	if respContent == nil {
		s.writeError(ctx, resp, twirp.InternalError("received a nil *RemoveTeamBaseRepositoryScopeResponse and nil error while calling RemoveTeamBaseRepositoryScope. nil responses are not supported"))
		return
	}

	ctx = callResponsePrepared(ctx, s.hooks)

	respBytes, err := proto.Marshal(respContent)
	if err != nil {
		s.writeError(ctx, resp, wrapInternal(err, "failed to marshal proto response"))
		return
	}

	ctx = ctxsetters.WithStatusCode(ctx, http.StatusOK)
	resp.Header().Set("Content-Type", "application/protobuf")
	resp.Header().Set("Content-Length", strconv.Itoa(len(respBytes)))
	resp.WriteHeader(http.StatusOK)
	if n, err := resp.Write(respBytes); err != nil {
		msg := fmt.Sprintf("failed to write response, %d of %d bytes written: %s", n, len(respBytes), err.Error())
		twerr := twirp.NewError(twirp.Unknown, msg)
		ctx = callError(ctx, s.hooks, twerr)
	}
	callResponseSent(ctx, s.hooks)
}

func (s *teamServiceServer) serveRemoveTeamBaseRepositoryScopeByName(ctx context.Context, resp http.ResponseWriter, req *http.Request) {
	header := req.Header.Get("Content-Type")
	i := strings.Index(header, ";")
	if i == -1 {
		i = len(header)
	}
	switch strings.TrimSpace(strings.ToLower(header[:i])) {
	case "application/json":
		s.serveRemoveTeamBaseRepositoryScopeByNameJSON(ctx, resp, req)
	case "application/protobuf":
		s.serveRemoveTeamBaseRepositoryScopeByNameProtobuf(ctx, resp, req)
	default:
		msg := fmt.Sprintf("unexpected Content-Type: %q", req.Header.Get("Content-Type"))
		twerr := badRouteError(msg, req.Method, req.URL.Path)
		s.writeError(ctx, resp, twerr)
	}
}

func (s *teamServiceServer) serveRemoveTeamBaseRepositoryScopeByNameJSON(ctx context.Context, resp http.ResponseWriter, req *http.Request) {
	var err error
	ctx = ctxsetters.WithMethodName(ctx, "RemoveTeamBaseRepositoryScopeByName")
	ctx, err = callRequestRouted(ctx, s.hooks)
	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}

	d := json.NewDecoder(req.Body)
	rawReqBody := json.RawMessage{}
	if err := d.Decode(&rawReqBody); err != nil {
		s.handleRequestBodyError(ctx, resp, "the json request could not be decoded", err)
		return
	}
	reqContent := new(RemoveTeamBaseRepositoryScopeByNameRequest)
	unmarshaler := protojson.UnmarshalOptions{DiscardUnknown: true}
	if err = unmarshaler.Unmarshal(rawReqBody, reqContent); err != nil {
		s.handleRequestBodyError(ctx, resp, "the json request could not be decoded", err)
		return
	}

	handler := s.TeamService.RemoveTeamBaseRepositoryScopeByName
	if s.interceptor != nil {
		handler = func(ctx context.Context, req *RemoveTeamBaseRepositoryScopeByNameRequest) (*RemoveTeamBaseRepositoryScopeByNameResponse, error) {
			resp, err := s.interceptor(
				func(ctx context.Context, req interface{}) (interface{}, error) {
					typedReq, ok := req.(*RemoveTeamBaseRepositoryScopeByNameRequest)
					if !ok {
						return nil, twirp.InternalError("failed type assertion req.(*RemoveTeamBaseRepositoryScopeByNameRequest) when calling interceptor")
					}
					return s.TeamService.RemoveTeamBaseRepositoryScopeByName(ctx, typedReq)
				},
			)(ctx, req)
			if resp != nil {
				typedResp, ok := resp.(*RemoveTeamBaseRepositoryScopeByNameResponse)
				if !ok {
					return nil, twirp.InternalError("failed type assertion resp.(*RemoveTeamBaseRepositoryScopeByNameResponse) when calling interceptor")
				}
				return typedResp, err
			}
			return nil, err
		}
	}

	// Call service method
	var respContent *RemoveTeamBaseRepositoryScopeByNameResponse
	func() {
		defer ensurePanicResponses(ctx, resp, s.hooks)
		respContent, err = handler(ctx, reqContent)
	}()

	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}
	if respContent == nil {
		s.writeError(ctx, resp, twirp.InternalError("received a nil *RemoveTeamBaseRepositoryScopeByNameResponse and nil error while calling RemoveTeamBaseRepositoryScopeByName. nil responses are not supported"))
		return
	}

	ctx = callResponsePrepared(ctx, s.hooks)

	marshaler := &protojson.MarshalOptions{UseProtoNames: !s.jsonCamelCase, EmitUnpopulated: !s.jsonSkipDefaults}
	respBytes, err := marshaler.Marshal(respContent)
	if err != nil {
		s.writeError(ctx, resp, wrapInternal(err, "failed to marshal json response"))
		return
	}

	ctx = ctxsetters.WithStatusCode(ctx, http.StatusOK)
	resp.Header().Set("Content-Type", "application/json")
	resp.Header().Set("Content-Length", strconv.Itoa(len(respBytes)))
	resp.WriteHeader(http.StatusOK)

	if n, err := resp.Write(respBytes); err != nil {
		msg := fmt.Sprintf("failed to write response, %d of %d bytes written: %s", n, len(respBytes), err.Error())
		twerr := twirp.NewError(twirp.Unknown, msg)
		ctx = callError(ctx, s.hooks, twerr)
	}
	callResponseSent(ctx, s.hooks)
}

func (s *teamServiceServer) serveRemoveTeamBaseRepositoryScopeByNameProtobuf(ctx context.Context, resp http.ResponseWriter, req *http.Request) {
	var err error
	ctx = ctxsetters.WithMethodName(ctx, "RemoveTeamBaseRepositoryScopeByName")
	ctx, err = callRequestRouted(ctx, s.hooks)
	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}

	buf, err := ioutil.ReadAll(req.Body)
	if err != nil {
		s.handleRequestBodyError(ctx, resp, "failed to read request body", err)
		return
	}
	reqContent := new(RemoveTeamBaseRepositoryScopeByNameRequest)
	if err = proto.Unmarshal(buf, reqContent); err != nil {
		s.writeError(ctx, resp, malformedRequestError("the protobuf request could not be decoded"))
		return
	}

	handler := s.TeamService.RemoveTeamBaseRepositoryScopeByName
	if s.interceptor != nil {
		handler = func(ctx context.Context, req *RemoveTeamBaseRepositoryScopeByNameRequest) (*RemoveTeamBaseRepositoryScopeByNameResponse, error) {
			resp, err := s.interceptor(
				func(ctx context.Context, req interface{}) (interface{}, error) {
					typedReq, ok := req.(*RemoveTeamBaseRepositoryScopeByNameRequest)
					if !ok {
						return nil, twirp.InternalError("failed type assertion req.(*RemoveTeamBaseRepositoryScopeByNameRequest) when calling interceptor")
					}
					return s.TeamService.RemoveTeamBaseRepositoryScopeByName(ctx, typedReq)
				},
			)(ctx, req)
			if resp != nil {
				typedResp, ok := resp.(*RemoveTeamBaseRepositoryScopeByNameResponse)
				if !ok {
					return nil, twirp.InternalError("failed type assertion resp.(*RemoveTeamBaseRepositoryScopeByNameResponse) when calling interceptor")
				}
				return typedResp, err
			}
			return nil, err
		}
	}

	// Call service method
	var respContent *RemoveTeamBaseRepositoryScopeByNameResponse
	func() {
		defer ensurePanicResponses(ctx, resp, s.hooks)
		respContent, err = handler(ctx, reqContent)
	}()

	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}
	if respContent == nil {
		s.writeError(ctx, resp, twirp.InternalError("received a nil *RemoveTeamBaseRepositoryScopeByNameResponse and nil error while calling RemoveTeamBaseRepositoryScopeByName. nil responses are not supported"))
		return
	}

	ctx = callResponsePrepared(ctx, s.hooks)

	respBytes, err := proto.Marshal(respContent)
	if err != nil {
		s.writeError(ctx, resp, wrapInternal(err, "failed to marshal proto response"))
		return
	}

	ctx = ctxsetters.WithStatusCode(ctx, http.StatusOK)
	resp.Header().Set("Content-Type", "application/protobuf")
	resp.Header().Set("Content-Length", strconv.Itoa(len(respBytes)))
	resp.WriteHeader(http.StatusOK)
	if n, err := resp.Write(respBytes); err != nil {
		msg := fmt.Sprintf("failed to write response, %d of %d bytes written: %s", n, len(respBytes), err.Error())
		twerr := twirp.NewError(twirp.Unknown, msg)
		ctx = callError(ctx, s.hooks, twerr)
	}
	callResponseSent(ctx, s.hooks)
}

func (s *teamServiceServer) serveAddTeamRepositoryScope(ctx context.Context, resp http.ResponseWriter, req *http.Request) {
	header := req.Header.Get("Content-Type")
	i := strings.Index(header, ";")
	if i == -1 {
		i = len(header)
	}
	switch strings.TrimSpace(strings.ToLower(header[:i])) {
	case "application/json":
		s.serveAddTeamRepositoryScopeJSON(ctx, resp, req)
	case "application/protobuf":
		s.serveAddTeamRepositoryScopeProtobuf(ctx, resp, req)
	default:
		msg := fmt.Sprintf("unexpected Content-Type: %q", req.Header.Get("Content-Type"))
		twerr := badRouteError(msg, req.Method, req.URL.Path)
		s.writeError(ctx, resp, twerr)
	}
}

func (s *teamServiceServer) serveAddTeamRepositoryScopeJSON(ctx context.Context, resp http.ResponseWriter, req *http.Request) {
	var err error
	ctx = ctxsetters.WithMethodName(ctx, "AddTeamRepositoryScope")
	ctx, err = callRequestRouted(ctx, s.hooks)
	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}

	d := json.NewDecoder(req.Body)
	rawReqBody := json.RawMessage{}
	if err := d.Decode(&rawReqBody); err != nil {
		s.handleRequestBodyError(ctx, resp, "the json request could not be decoded", err)
		return
	}
	reqContent := new(AddTeamRepositoryScopeRequest)
	unmarshaler := protojson.UnmarshalOptions{DiscardUnknown: true}
	if err = unmarshaler.Unmarshal(rawReqBody, reqContent); err != nil {
		s.handleRequestBodyError(ctx, resp, "the json request could not be decoded", err)
		return
	}

	handler := s.TeamService.AddTeamRepositoryScope
	if s.interceptor != nil {
		handler = func(ctx context.Context, req *AddTeamRepositoryScopeRequest) (*AddTeamRepositoryScopeResponse, error) {
			resp, err := s.interceptor(
				func(ctx context.Context, req interface{}) (interface{}, error) {
					typedReq, ok := req.(*AddTeamRepositoryScopeRequest)
					if !ok {
						return nil, twirp.InternalError("failed type assertion req.(*AddTeamRepositoryScopeRequest) when calling interceptor")
					}
					return s.TeamService.AddTeamRepositoryScope(ctx, typedReq)
				},
			)(ctx, req)
			if resp != nil {
				typedResp, ok := resp.(*AddTeamRepositoryScopeResponse)
				if !ok {
					return nil, twirp.InternalError("failed type assertion resp.(*AddTeamRepositoryScopeResponse) when calling interceptor")
				}
				return typedResp, err
			}
			return nil, err
		}
	}

	// Call service method
	var respContent *AddTeamRepositoryScopeResponse
	func() {
		defer ensurePanicResponses(ctx, resp, s.hooks)
		respContent, err = handler(ctx, reqContent)
	}()

	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}
	if respContent == nil {
		s.writeError(ctx, resp, twirp.InternalError("received a nil *AddTeamRepositoryScopeResponse and nil error while calling AddTeamRepositoryScope. nil responses are not supported"))
		return
	}

	ctx = callResponsePrepared(ctx, s.hooks)

	marshaler := &protojson.MarshalOptions{UseProtoNames: !s.jsonCamelCase, EmitUnpopulated: !s.jsonSkipDefaults}
	respBytes, err := marshaler.Marshal(respContent)
	if err != nil {
		s.writeError(ctx, resp, wrapInternal(err, "failed to marshal json response"))
		return
	}

	ctx = ctxsetters.WithStatusCode(ctx, http.StatusOK)
	resp.Header().Set("Content-Type", "application/json")
	resp.Header().Set("Content-Length", strconv.Itoa(len(respBytes)))
	resp.WriteHeader(http.StatusOK)

	if n, err := resp.Write(respBytes); err != nil {
		msg := fmt.Sprintf("failed to write response, %d of %d bytes written: %s", n, len(respBytes), err.Error())
		twerr := twirp.NewError(twirp.Unknown, msg)
		ctx = callError(ctx, s.hooks, twerr)
	}
	callResponseSent(ctx, s.hooks)
}

func (s *teamServiceServer) serveAddTeamRepositoryScopeProtobuf(ctx context.Context, resp http.ResponseWriter, req *http.Request) {
	var err error
	ctx = ctxsetters.WithMethodName(ctx, "AddTeamRepositoryScope")
	ctx, err = callRequestRouted(ctx, s.hooks)
	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}

	buf, err := ioutil.ReadAll(req.Body)
	if err != nil {
		s.handleRequestBodyError(ctx, resp, "failed to read request body", err)
		return
	}
	reqContent := new(AddTeamRepositoryScopeRequest)
	if err = proto.Unmarshal(buf, reqContent); err != nil {
		s.writeError(ctx, resp, malformedRequestError("the protobuf request could not be decoded"))
		return
	}

	handler := s.TeamService.AddTeamRepositoryScope
	if s.interceptor != nil {
		handler = func(ctx context.Context, req *AddTeamRepositoryScopeRequest) (*AddTeamRepositoryScopeResponse, error) {
			resp, err := s.interceptor(
				func(ctx context.Context, req interface{}) (interface{}, error) {
					typedReq, ok := req.(*AddTeamRepositoryScopeRequest)
					if !ok {
						return nil, twirp.InternalError("failed type assertion req.(*AddTeamRepositoryScopeRequest) when calling interceptor")
					}
					return s.TeamService.AddTeamRepositoryScope(ctx, typedReq)
				},
			)(ctx, req)
			if resp != nil {
				typedResp, ok := resp.(*AddTeamRepositoryScopeResponse)
				if !ok {
					return nil, twirp.InternalError("failed type assertion resp.(*AddTeamRepositoryScopeResponse) when calling interceptor")
				}
				return typedResp, err
			}
			return nil, err
		}
	}

	// Call service method
	var respContent *AddTeamRepositoryScopeResponse
	func() {
		defer ensurePanicResponses(ctx, resp, s.hooks)
		respContent, err = handler(ctx, reqContent)
	}()

	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}
	if respContent == nil {
		s.writeError(ctx, resp, twirp.InternalError("received a nil *AddTeamRepositoryScopeResponse and nil error while calling AddTeamRepositoryScope. nil responses are not supported"))
		return
	}

	ctx = callResponsePrepared(ctx, s.hooks)

	respBytes, err := proto.Marshal(respContent)
	if err != nil {
		s.writeError(ctx, resp, wrapInternal(err, "failed to marshal proto response"))
		return
	}

	ctx = ctxsetters.WithStatusCode(ctx, http.StatusOK)
	resp.Header().Set("Content-Type", "application/protobuf")
	resp.Header().Set("Content-Length", strconv.Itoa(len(respBytes)))
	resp.WriteHeader(http.StatusOK)
	if n, err := resp.Write(respBytes); err != nil {
		msg := fmt.Sprintf("failed to write response, %d of %d bytes written: %s", n, len(respBytes), err.Error())
		twerr := twirp.NewError(twirp.Unknown, msg)
		ctx = callError(ctx, s.hooks, twerr)
	}
	callResponseSent(ctx, s.hooks)
}

func (s *teamServiceServer) serveAddTeamRepositoryScopeByName(ctx context.Context, resp http.ResponseWriter, req *http.Request) {
	header := req.Header.Get("Content-Type")
	i := strings.Index(header, ";")
	if i == -1 {
		i = len(header)
	}
	switch strings.TrimSpace(strings.ToLower(header[:i])) {
	case "application/json":
		s.serveAddTeamRepositoryScopeByNameJSON(ctx, resp, req)
	case "application/protobuf":
		s.serveAddTeamRepositoryScopeByNameProtobuf(ctx, resp, req)
	default:
		msg := fmt.Sprintf("unexpected Content-Type: %q", req.Header.Get("Content-Type"))
		twerr := badRouteError(msg, req.Method, req.URL.Path)
		s.writeError(ctx, resp, twerr)
	}
}

func (s *teamServiceServer) serveAddTeamRepositoryScopeByNameJSON(ctx context.Context, resp http.ResponseWriter, req *http.Request) {
	var err error
	ctx = ctxsetters.WithMethodName(ctx, "AddTeamRepositoryScopeByName")
	ctx, err = callRequestRouted(ctx, s.hooks)
	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}

	d := json.NewDecoder(req.Body)
	rawReqBody := json.RawMessage{}
	if err := d.Decode(&rawReqBody); err != nil {
		s.handleRequestBodyError(ctx, resp, "the json request could not be decoded", err)
		return
	}
	reqContent := new(AddTeamRepositoryScopeByNameRequest)
	unmarshaler := protojson.UnmarshalOptions{DiscardUnknown: true}
	if err = unmarshaler.Unmarshal(rawReqBody, reqContent); err != nil {
		s.handleRequestBodyError(ctx, resp, "the json request could not be decoded", err)
		return
	}

	handler := s.TeamService.AddTeamRepositoryScopeByName
	if s.interceptor != nil {
		handler = func(ctx context.Context, req *AddTeamRepositoryScopeByNameRequest) (*AddTeamRepositoryScopeByNameResponse, error) {
			resp, err := s.interceptor(
				func(ctx context.Context, req interface{}) (interface{}, error) {
					typedReq, ok := req.(*AddTeamRepositoryScopeByNameRequest)
					if !ok {
						return nil, twirp.InternalError("failed type assertion req.(*AddTeamRepositoryScopeByNameRequest) when calling interceptor")
					}
					return s.TeamService.AddTeamRepositoryScopeByName(ctx, typedReq)
				},
			)(ctx, req)
			if resp != nil {
				typedResp, ok := resp.(*AddTeamRepositoryScopeByNameResponse)
				if !ok {
					return nil, twirp.InternalError("failed type assertion resp.(*AddTeamRepositoryScopeByNameResponse) when calling interceptor")
				}
				return typedResp, err
			}
			return nil, err
		}
	}

	// Call service method
	var respContent *AddTeamRepositoryScopeByNameResponse
	func() {
		defer ensurePanicResponses(ctx, resp, s.hooks)
		respContent, err = handler(ctx, reqContent)
	}()

	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}
	if respContent == nil {
		s.writeError(ctx, resp, twirp.InternalError("received a nil *AddTeamRepositoryScopeByNameResponse and nil error while calling AddTeamRepositoryScopeByName. nil responses are not supported"))
		return
	}

	ctx = callResponsePrepared(ctx, s.hooks)

	marshaler := &protojson.MarshalOptions{UseProtoNames: !s.jsonCamelCase, EmitUnpopulated: !s.jsonSkipDefaults}
	respBytes, err := marshaler.Marshal(respContent)
	if err != nil {
		s.writeError(ctx, resp, wrapInternal(err, "failed to marshal json response"))
		return
	}

	ctx = ctxsetters.WithStatusCode(ctx, http.StatusOK)
	resp.Header().Set("Content-Type", "application/json")
	resp.Header().Set("Content-Length", strconv.Itoa(len(respBytes)))
	resp.WriteHeader(http.StatusOK)

	if n, err := resp.Write(respBytes); err != nil {
		msg := fmt.Sprintf("failed to write response, %d of %d bytes written: %s", n, len(respBytes), err.Error())
		twerr := twirp.NewError(twirp.Unknown, msg)
		ctx = callError(ctx, s.hooks, twerr)
	}
	callResponseSent(ctx, s.hooks)
}

func (s *teamServiceServer) serveAddTeamRepositoryScopeByNameProtobuf(ctx context.Context, resp http.ResponseWriter, req *http.Request) {
	var err error
	ctx = ctxsetters.WithMethodName(ctx, "AddTeamRepositoryScopeByName")
	ctx, err = callRequestRouted(ctx, s.hooks)
	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}

	buf, err := ioutil.ReadAll(req.Body)
	if err != nil {
		s.handleRequestBodyError(ctx, resp, "failed to read request body", err)
		return
	}
	reqContent := new(AddTeamRepositoryScopeByNameRequest)
	if err = proto.Unmarshal(buf, reqContent); err != nil {
		s.writeError(ctx, resp, malformedRequestError("the protobuf request could not be decoded"))
		return
	}

	handler := s.TeamService.AddTeamRepositoryScopeByName
	if s.interceptor != nil {
		handler = func(ctx context.Context, req *AddTeamRepositoryScopeByNameRequest) (*AddTeamRepositoryScopeByNameResponse, error) {
			resp, err := s.interceptor(
				func(ctx context.Context, req interface{}) (interface{}, error) {
					typedReq, ok := req.(*AddTeamRepositoryScopeByNameRequest)
					if !ok {
						return nil, twirp.InternalError("failed type assertion req.(*AddTeamRepositoryScopeByNameRequest) when calling interceptor")
					}
					return s.TeamService.AddTeamRepositoryScopeByName(ctx, typedReq)
				},
			)(ctx, req)
			if resp != nil {
				typedResp, ok := resp.(*AddTeamRepositoryScopeByNameResponse)
				if !ok {
					return nil, twirp.InternalError("failed type assertion resp.(*AddTeamRepositoryScopeByNameResponse) when calling interceptor")
				}
				return typedResp, err
			}
			return nil, err
		}
	}

	// Call service method
	var respContent *AddTeamRepositoryScopeByNameResponse
	func() {
		defer ensurePanicResponses(ctx, resp, s.hooks)
		respContent, err = handler(ctx, reqContent)
	}()

	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}
	if respContent == nil {
		s.writeError(ctx, resp, twirp.InternalError("received a nil *AddTeamRepositoryScopeByNameResponse and nil error while calling AddTeamRepositoryScopeByName. nil responses are not supported"))
		return
	}

	ctx = callResponsePrepared(ctx, s.hooks)

	respBytes, err := proto.Marshal(respContent)
	if err != nil {
		s.writeError(ctx, resp, wrapInternal(err, "failed to marshal proto response"))
		return
	}

	ctx = ctxsetters.WithStatusCode(ctx, http.StatusOK)
	resp.Header().Set("Content-Type", "application/protobuf")
	resp.Header().Set("Content-Length", strconv.Itoa(len(respBytes)))
	resp.WriteHeader(http.StatusOK)
	if n, err := resp.Write(respBytes); err != nil {
		msg := fmt.Sprintf("failed to write response, %d of %d bytes written: %s", n, len(respBytes), err.Error())
		twerr := twirp.NewError(twirp.Unknown, msg)
		ctx = callError(ctx, s.hooks, twerr)
	}
	callResponseSent(ctx, s.hooks)
}

func (s *teamServiceServer) serveRemoveTeamRepositoryScope(ctx context.Context, resp http.ResponseWriter, req *http.Request) {
	header := req.Header.Get("Content-Type")
	i := strings.Index(header, ";")
	if i == -1 {
		i = len(header)
	}
	switch strings.TrimSpace(strings.ToLower(header[:i])) {
	case "application/json":
		s.serveRemoveTeamRepositoryScopeJSON(ctx, resp, req)
	case "application/protobuf":
		s.serveRemoveTeamRepositoryScopeProtobuf(ctx, resp, req)
	default:
		msg := fmt.Sprintf("unexpected Content-Type: %q", req.Header.Get("Content-Type"))
		twerr := badRouteError(msg, req.Method, req.URL.Path)
		s.writeError(ctx, resp, twerr)
	}
}

func (s *teamServiceServer) serveRemoveTeamRepositoryScopeJSON(ctx context.Context, resp http.ResponseWriter, req *http.Request) {
	var err error
	ctx = ctxsetters.WithMethodName(ctx, "RemoveTeamRepositoryScope")
	ctx, err = callRequestRouted(ctx, s.hooks)
	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}

	d := json.NewDecoder(req.Body)
	rawReqBody := json.RawMessage{}
	if err := d.Decode(&rawReqBody); err != nil {
		s.handleRequestBodyError(ctx, resp, "the json request could not be decoded", err)
		return
	}
	reqContent := new(RemoveTeamRepositoryScopeRequest)
	unmarshaler := protojson.UnmarshalOptions{DiscardUnknown: true}
	if err = unmarshaler.Unmarshal(rawReqBody, reqContent); err != nil {
		s.handleRequestBodyError(ctx, resp, "the json request could not be decoded", err)
		return
	}

	handler := s.TeamService.RemoveTeamRepositoryScope
	if s.interceptor != nil {
		handler = func(ctx context.Context, req *RemoveTeamRepositoryScopeRequest) (*RemoveTeamRepositoryScopeResponse, error) {
			resp, err := s.interceptor(
				func(ctx context.Context, req interface{}) (interface{}, error) {
					typedReq, ok := req.(*RemoveTeamRepositoryScopeRequest)
					if !ok {
						return nil, twirp.InternalError("failed type assertion req.(*RemoveTeamRepositoryScopeRequest) when calling interceptor")
					}
					return s.TeamService.RemoveTeamRepositoryScope(ctx, typedReq)
				},
			)(ctx, req)
			if resp != nil {
				typedResp, ok := resp.(*RemoveTeamRepositoryScopeResponse)
				if !ok {
					return nil, twirp.InternalError("failed type assertion resp.(*RemoveTeamRepositoryScopeResponse) when calling interceptor")
				}
				return typedResp, err
			}
			return nil, err
		}
	}

	// Call service method
	var respContent *RemoveTeamRepositoryScopeResponse
	func() {
		defer ensurePanicResponses(ctx, resp, s.hooks)
		respContent, err = handler(ctx, reqContent)
	}()

	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}
	if respContent == nil {
		s.writeError(ctx, resp, twirp.InternalError("received a nil *RemoveTeamRepositoryScopeResponse and nil error while calling RemoveTeamRepositoryScope. nil responses are not supported"))
		return
	}

	ctx = callResponsePrepared(ctx, s.hooks)

	marshaler := &protojson.MarshalOptions{UseProtoNames: !s.jsonCamelCase, EmitUnpopulated: !s.jsonSkipDefaults}
	respBytes, err := marshaler.Marshal(respContent)
	if err != nil {
		s.writeError(ctx, resp, wrapInternal(err, "failed to marshal json response"))
		return
	}

	ctx = ctxsetters.WithStatusCode(ctx, http.StatusOK)
	resp.Header().Set("Content-Type", "application/json")
	resp.Header().Set("Content-Length", strconv.Itoa(len(respBytes)))
	resp.WriteHeader(http.StatusOK)

	if n, err := resp.Write(respBytes); err != nil {
		msg := fmt.Sprintf("failed to write response, %d of %d bytes written: %s", n, len(respBytes), err.Error())
		twerr := twirp.NewError(twirp.Unknown, msg)
		ctx = callError(ctx, s.hooks, twerr)
	}
	callResponseSent(ctx, s.hooks)
}

func (s *teamServiceServer) serveRemoveTeamRepositoryScopeProtobuf(ctx context.Context, resp http.ResponseWriter, req *http.Request) {
	var err error
	ctx = ctxsetters.WithMethodName(ctx, "RemoveTeamRepositoryScope")
	ctx, err = callRequestRouted(ctx, s.hooks)
	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}

	buf, err := ioutil.ReadAll(req.Body)
	if err != nil {
		s.handleRequestBodyError(ctx, resp, "failed to read request body", err)
		return
	}
	reqContent := new(RemoveTeamRepositoryScopeRequest)
	if err = proto.Unmarshal(buf, reqContent); err != nil {
		s.writeError(ctx, resp, malformedRequestError("the protobuf request could not be decoded"))
		return
	}

	handler := s.TeamService.RemoveTeamRepositoryScope
	if s.interceptor != nil {
		handler = func(ctx context.Context, req *RemoveTeamRepositoryScopeRequest) (*RemoveTeamRepositoryScopeResponse, error) {
			resp, err := s.interceptor(
				func(ctx context.Context, req interface{}) (interface{}, error) {
					typedReq, ok := req.(*RemoveTeamRepositoryScopeRequest)
					if !ok {
						return nil, twirp.InternalError("failed type assertion req.(*RemoveTeamRepositoryScopeRequest) when calling interceptor")
					}
					return s.TeamService.RemoveTeamRepositoryScope(ctx, typedReq)
				},
			)(ctx, req)
			if resp != nil {
				typedResp, ok := resp.(*RemoveTeamRepositoryScopeResponse)
				if !ok {
					return nil, twirp.InternalError("failed type assertion resp.(*RemoveTeamRepositoryScopeResponse) when calling interceptor")
				}
				return typedResp, err
			}
			return nil, err
		}
	}

	// Call service method
	var respContent *RemoveTeamRepositoryScopeResponse
	func() {
		defer ensurePanicResponses(ctx, resp, s.hooks)
		respContent, err = handler(ctx, reqContent)
	}()

	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}
	if respContent == nil {
		s.writeError(ctx, resp, twirp.InternalError("received a nil *RemoveTeamRepositoryScopeResponse and nil error while calling RemoveTeamRepositoryScope. nil responses are not supported"))
		return
	}

	ctx = callResponsePrepared(ctx, s.hooks)

	respBytes, err := proto.Marshal(respContent)
	if err != nil {
		s.writeError(ctx, resp, wrapInternal(err, "failed to marshal proto response"))
		return
	}

	ctx = ctxsetters.WithStatusCode(ctx, http.StatusOK)
	resp.Header().Set("Content-Type", "application/protobuf")
	resp.Header().Set("Content-Length", strconv.Itoa(len(respBytes)))
	resp.WriteHeader(http.StatusOK)
	if n, err := resp.Write(respBytes); err != nil {
		msg := fmt.Sprintf("failed to write response, %d of %d bytes written: %s", n, len(respBytes), err.Error())
		twerr := twirp.NewError(twirp.Unknown, msg)
		ctx = callError(ctx, s.hooks, twerr)
	}
	callResponseSent(ctx, s.hooks)
}

func (s *teamServiceServer) serveRemoveTeamRepositoryScopeByName(ctx context.Context, resp http.ResponseWriter, req *http.Request) {
	header := req.Header.Get("Content-Type")
	i := strings.Index(header, ";")
	if i == -1 {
		i = len(header)
	}
	switch strings.TrimSpace(strings.ToLower(header[:i])) {
	case "application/json":
		s.serveRemoveTeamRepositoryScopeByNameJSON(ctx, resp, req)
	case "application/protobuf":
		s.serveRemoveTeamRepositoryScopeByNameProtobuf(ctx, resp, req)
	default:
		msg := fmt.Sprintf("unexpected Content-Type: %q", req.Header.Get("Content-Type"))
		twerr := badRouteError(msg, req.Method, req.URL.Path)
		s.writeError(ctx, resp, twerr)
	}
}

func (s *teamServiceServer) serveRemoveTeamRepositoryScopeByNameJSON(ctx context.Context, resp http.ResponseWriter, req *http.Request) {
	var err error
	ctx = ctxsetters.WithMethodName(ctx, "RemoveTeamRepositoryScopeByName")
	ctx, err = callRequestRouted(ctx, s.hooks)
	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}

	d := json.NewDecoder(req.Body)
	rawReqBody := json.RawMessage{}
	if err := d.Decode(&rawReqBody); err != nil {
		s.handleRequestBodyError(ctx, resp, "the json request could not be decoded", err)
		return
	}
	reqContent := new(RemoveTeamRepositoryScopeByNameRequest)
	unmarshaler := protojson.UnmarshalOptions{DiscardUnknown: true}
	if err = unmarshaler.Unmarshal(rawReqBody, reqContent); err != nil {
		s.handleRequestBodyError(ctx, resp, "the json request could not be decoded", err)
		return
	}

	handler := s.TeamService.RemoveTeamRepositoryScopeByName
	if s.interceptor != nil {
		handler = func(ctx context.Context, req *RemoveTeamRepositoryScopeByNameRequest) (*RemoveTeamRepositoryScopeByNameResponse, error) {
			resp, err := s.interceptor(
				func(ctx context.Context, req interface{}) (interface{}, error) {
					typedReq, ok := req.(*RemoveTeamRepositoryScopeByNameRequest)
					if !ok {
						return nil, twirp.InternalError("failed type assertion req.(*RemoveTeamRepositoryScopeByNameRequest) when calling interceptor")
					}
					return s.TeamService.RemoveTeamRepositoryScopeByName(ctx, typedReq)
				},
			)(ctx, req)
			if resp != nil {
				typedResp, ok := resp.(*RemoveTeamRepositoryScopeByNameResponse)
				if !ok {
					return nil, twirp.InternalError("failed type assertion resp.(*RemoveTeamRepositoryScopeByNameResponse) when calling interceptor")
				}
				return typedResp, err
			}
			return nil, err
		}
	}

	// Call service method
	var respContent *RemoveTeamRepositoryScopeByNameResponse
	func() {
		defer ensurePanicResponses(ctx, resp, s.hooks)
		respContent, err = handler(ctx, reqContent)
	}()

	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}
	if respContent == nil {
		s.writeError(ctx, resp, twirp.InternalError("received a nil *RemoveTeamRepositoryScopeByNameResponse and nil error while calling RemoveTeamRepositoryScopeByName. nil responses are not supported"))
		return
	}

	ctx = callResponsePrepared(ctx, s.hooks)

	marshaler := &protojson.MarshalOptions{UseProtoNames: !s.jsonCamelCase, EmitUnpopulated: !s.jsonSkipDefaults}
	respBytes, err := marshaler.Marshal(respContent)
	if err != nil {
		s.writeError(ctx, resp, wrapInternal(err, "failed to marshal json response"))
		return
	}

	ctx = ctxsetters.WithStatusCode(ctx, http.StatusOK)
	resp.Header().Set("Content-Type", "application/json")
	resp.Header().Set("Content-Length", strconv.Itoa(len(respBytes)))
	resp.WriteHeader(http.StatusOK)

	if n, err := resp.Write(respBytes); err != nil {
		msg := fmt.Sprintf("failed to write response, %d of %d bytes written: %s", n, len(respBytes), err.Error())
		twerr := twirp.NewError(twirp.Unknown, msg)
		ctx = callError(ctx, s.hooks, twerr)
	}
	callResponseSent(ctx, s.hooks)
}

func (s *teamServiceServer) serveRemoveTeamRepositoryScopeByNameProtobuf(ctx context.Context, resp http.ResponseWriter, req *http.Request) {
	var err error
	ctx = ctxsetters.WithMethodName(ctx, "RemoveTeamRepositoryScopeByName")
	ctx, err = callRequestRouted(ctx, s.hooks)
	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}

	buf, err := ioutil.ReadAll(req.Body)
	if err != nil {
		s.handleRequestBodyError(ctx, resp, "failed to read request body", err)
		return
	}
	reqContent := new(RemoveTeamRepositoryScopeByNameRequest)
	if err = proto.Unmarshal(buf, reqContent); err != nil {
		s.writeError(ctx, resp, malformedRequestError("the protobuf request could not be decoded"))
		return
	}

	handler := s.TeamService.RemoveTeamRepositoryScopeByName
	if s.interceptor != nil {
		handler = func(ctx context.Context, req *RemoveTeamRepositoryScopeByNameRequest) (*RemoveTeamRepositoryScopeByNameResponse, error) {
			resp, err := s.interceptor(
				func(ctx context.Context, req interface{}) (interface{}, error) {
					typedReq, ok := req.(*RemoveTeamRepositoryScopeByNameRequest)
					if !ok {
						return nil, twirp.InternalError("failed type assertion req.(*RemoveTeamRepositoryScopeByNameRequest) when calling interceptor")
					}
					return s.TeamService.RemoveTeamRepositoryScopeByName(ctx, typedReq)
				},
			)(ctx, req)
			if resp != nil {
				typedResp, ok := resp.(*RemoveTeamRepositoryScopeByNameResponse)
				if !ok {
					return nil, twirp.InternalError("failed type assertion resp.(*RemoveTeamRepositoryScopeByNameResponse) when calling interceptor")
				}
				return typedResp, err
			}
			return nil, err
		}
	}

	// Call service method
	var respContent *RemoveTeamRepositoryScopeByNameResponse
	func() {
		defer ensurePanicResponses(ctx, resp, s.hooks)
		respContent, err = handler(ctx, reqContent)
	}()

	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}
	if respContent == nil {
		s.writeError(ctx, resp, twirp.InternalError("received a nil *RemoveTeamRepositoryScopeByNameResponse and nil error while calling RemoveTeamRepositoryScopeByName. nil responses are not supported"))
		return
	}

	ctx = callResponsePrepared(ctx, s.hooks)

	respBytes, err := proto.Marshal(respContent)
	if err != nil {
		s.writeError(ctx, resp, wrapInternal(err, "failed to marshal proto response"))
		return
	}

	ctx = ctxsetters.WithStatusCode(ctx, http.StatusOK)
	resp.Header().Set("Content-Type", "application/protobuf")
	resp.Header().Set("Content-Length", strconv.Itoa(len(respBytes)))
	resp.WriteHeader(http.StatusOK)
	if n, err := resp.Write(respBytes); err != nil {
		msg := fmt.Sprintf("failed to write response, %d of %d bytes written: %s", n, len(respBytes), err.Error())
		twerr := twirp.NewError(twirp.Unknown, msg)
		ctx = callError(ctx, s.hooks, twerr)
	}
	callResponseSent(ctx, s.hooks)
}

func (s *teamServiceServer) ServiceDescriptor() ([]byte, int) {
	return twirpFileDescriptor19, 0
}

func (s *teamServiceServer) ProtocGenTwirpVersion() string {
	return "v8.1.0"
}

// PathPrefix returns the base service path, in the form: "/<prefix>/<package>.<Service>/"
// that is everything in a Twirp route except for the <Method>. This can be used for routing,
// for example to identify the requests that are targeted to this service in a mux.
func (s *teamServiceServer) PathPrefix() string {
	return baseServicePath(s.pathPrefix, "buf.alpha.registry.v1alpha1", "TeamService")
}

var twirpFileDescriptor19 = []byte{
	// 1522 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xdc, 0x5a, 0xdf, 0x6f, 0xdb, 0xd4,
	0x17, 0xd7, 0x4d, 0xbb, 0xb5, 0x3d, 0xfd, 0xb6, 0xdd, 0xee, 0x77, 0x5d, 0x33, 0x67, 0x5d, 0x3b,
	0x77, 0x6b, 0xba, 0x75, 0x38, 0x5a, 0xc7, 0x18, 0x64, 0xec, 0x47, 0xb3, 0xee, 0x97, 0x80, 0xad,
	0x64, 0x1d, 0x13, 0x53, 0x51, 0xe5, 0xd6, 0xb7, 0x99, 0x45, 0x1d, 0x07, 0xdb, 0xe9, 0x68, 0x5f,
	0xc6, 0x0b, 0x12, 0x0f, 0x88, 0x1f, 0x42, 0x02, 0x09, 0x69, 0x12, 0x02, 0x09, 0x09, 0x04, 0x02,
	0xf1, 0xc4, 0x3b, 0x12, 0x48, 0x93, 0x78, 0xe5, 0x0f, 0xe0, 0x09, 0xc1, 0x3f, 0x81, 0x7c, 0x7d,
	0xdd, 0xd8, 0x89, 0xef, 0xb5, 0xe3, 0x04, 0xb4, 0xf1, 0xd6, 0xdc, 0x7b, 0xce, 0xe7, 0x7c, 0xce,
	0xf9, 0xdc, 0xeb, 0xfa, 0x9c, 0x04, 0xa6, 0x57, 0xeb, 0xeb, 0x05, 0x75, 0xa3, 0x76, 0x4f, 0x2d,
	0x58, 0xa4, 0xa2, 0xdb, 0x8e, 0xb5, 0x55, 0xd8, 0x3c, 0x49, 0x17, 0x4e, 0x16, 0x1c, 0xa2, 0x1a,
	0x4a, 0xcd, 0x32, 0x1d, 0x13, 0xe7, 0x56, 0xeb, 0xeb, 0x0a, 0x5d, 0x56, 0x7c, 0x3b, 0xc5, 0xb7,
	0x93, 0xf2, 0x22, 0x10, 0x7b, 0xcd, 0xac, 0x11, 0x0f, 0x45, 0x9a, 0xa8, 0x98, 0x66, 0x65, 0x83,
	0x14, 0xe8, 0x27, 0xd7, 0xc9, 0xd1, 0x0d, 0x62, 0x3b, 0xaa, 0x51, 0xf3, 0x0c, 0xe4, 0x5f, 0x11,
	0xf4, 0x2e, 0x11, 0xd5, 0xc0, 0xc3, 0x90, 0xd1, 0xb5, 0x2c, 0x9a, 0x44, 0x33, 0x03, 0xe5, 0x8c,
	0xae, 0xe1, 0xb3, 0x30, 0xb8, 0x66, 0x11, 0xd5, 0x21, 0x2b, 0xae, 0x4b, 0x36, 0x33, 0x89, 0x66,
	0x06, 0xe7, 0x24, 0xc5, 0xc3, 0x53, 0x7c, 0x3c, 0x65, 0xc9, 0xc7, 0x2b, 0x83, 0x67, 0xee, 0x2e,
	0xb8, 0xce, 0xf5, 0x9a, 0xb6, 0xe3, 0xdc, 0x13, 0xef, 0xec, 0x99, 0x53, 0x67, 0x0c, 0xbd, 0x55,
	0xd5, 0x20, 0xd9, 0x5e, 0xca, 0x85, 0xfe, 0x8d, 0xf3, 0x30, 0x62, 0x5a, 0x15, 0xb5, 0xaa, 0x6f,
	0xab, 0x8e, 0x6e, 0x56, 0x57, 0x74, 0x2d, 0xbb, 0x8b, 0x6e, 0x0f, 0x07, 0x97, 0xaf, 0x6b, 0xf2,
	0x24, 0x0c, 0x5f, 0x25, 0x8e, 0x9b, 0x51, 0x99, 0xbc, 0x51, 0x27, 0xb6, 0xd3, 0x9c, 0x98, 0x7c,
	0x0d, 0x46, 0x76, 0x2c, 0xec, 0x9a, 0x59, 0xb5, 0x09, 0x3e, 0x0d, 0xbd, 0x6e, 0xe5, 0xa9, 0xd1,
	0xe0, 0xdc, 0x61, 0x45, 0x50, 0x7a, 0x85, 0x3a, 0x52, 0x73, 0xf9, 0x0e, 0xec, 0x63, 0x48, 0xa5,
	0xad, 0x1b, 0xaa, 0x41, 0xfc, 0x88, 0x7e, 0x02, 0x28, 0x90, 0xc0, 0x2c, 0xec, 0x0d, 0x25, 0x40,
	0x0d, 0x32, 0xd4, 0x60, 0x4f, 0x70, 0xc3, 0xc5, 0x91, 0x6f, 0xc0, 0x68, 0x13, 0x70, 0x67, 0x44,
	0x1f, 0x22, 0x38, 0xf8, 0xa2, 0x6e, 0x3b, 0x37, 0x03, 0x81, 0xdc, 0x6d, 0xdb, 0x67, 0x1c, 0x51,
	0x5e, 0x14, 0x55, 0x5e, 0x9c, 0x83, 0x81, 0x9a, 0x5a, 0x21, 0x2b, 0xb6, 0xbe, 0xed, 0xd1, 0x1f,
	0x2a, 0xf7, 0xbb, 0x0b, 0xb7, 0xf4, 0x6d, 0x82, 0xc7, 0x01, 0xe8, 0xa6, 0x63, 0xbe, 0x4e, 0xaa,
	0x54, 0xf4, 0x81, 0x32, 0x35, 0x5f, 0x72, 0x17, 0x70, 0x16, 0xfa, 0x2c, 0xb2, 0x49, 0x2c, 0xdb,
	0x93, 0xb6, 0xbf, 0xec, 0x7f, 0x94, 0xdf, 0x42, 0x30, 0xce, 0xe1, 0xc7, 0x12, 0x3f, 0x03, 0xbb,
	0xdc, 0x4c, 0xec, 0x2c, 0x9a, 0xec, 0x49, 0x96, 0xb9, 0x67, 0x8f, 0xa7, 0x61, 0xa4, 0x4a, 0xde,
	0x74, 0x56, 0x02, 0xc4, 0xbc, 0xaa, 0x0f, 0xb9, 0xcb, 0x8b, 0x3e, 0x39, 0x79, 0x11, 0xf6, 0x5e,
	0xf2, 0xce, 0x6f, 0xe0, 0xe8, 0x44, 0x09, 0x19, 0x51, 0xaa, 0x4c, 0xe4, 0x49, 0x7c, 0x01, 0x70,
	0x10, 0xb1, 0x33, 0x05, 0xef, 0xc2, 0x58, 0x03, 0xac, 0xcb, 0xa7, 0xed, 0x65, 0xc8, 0xb6, 0x62,
	0x77, 0x46, 0xb7, 0x04, 0xa3, 0xb7, 0xbd, 0x0b, 0x4d, 0x54, 0x23, 0x48, 0xb6, 0xf9, 0x29, 0x73,
	0x00, 0xfa, 0xab, 0xe4, 0x7e, 0x90, 0x5f, 0x5f, 0x95, 0xdc, 0xa7, 0xb4, 0x6e, 0xc2, 0xfe, 0x66,
	0x8c, 0xce, 0x48, 0x5d, 0x80, 0x7d, 0xf3, 0x9a, 0x76, 0xdb, 0x26, 0xd6, 0x92, 0x29, 0x78, 0x40,
	0xe0, 0x31, 0xe8, 0xab, 0xdb, 0xc4, 0x6a, 0x28, 0xbb, 0xdb, 0xfd, 0x78, 0x5d, 0x93, 0xc7, 0x60,
	0xb4, 0x09, 0xc0, 0x23, 0x24, 0x6f, 0x83, 0x14, 0xda, 0x88, 0x17, 0x28, 0x07, 0x03, 0x34, 0x46,
	0x20, 0xf1, 0x7e, 0x77, 0xe1, 0x06, 0x57, 0xbd, 0x1e, 0x8e, 0x7a, 0xe3, 0x90, 0x8b, 0x8c, 0xcd,
	0xa8, 0x2d, 0xc0, 0x81, 0x32, 0x31, 0xcc, 0x4d, 0xe2, 0x5a, 0x5c, 0xb1, 0x4c, 0x23, 0x55, 0xe6,
	0x07, 0x41, 0x8a, 0x42, 0x61, 0x31, 0x1e, 0xc0, 0x44, 0xeb, 0xee, 0xbf, 0x59, 0x03, 0x19, 0x26,
	0xf9, 0x04, 0x18, 0xc9, 0x29, 0xd8, 0xbb, 0x40, 0x36, 0x48, 0xf8, 0x82, 0x37, 0xff, 0x6f, 0xd8,
	0x07, 0x38, 0x68, 0xc4, 0x5c, 0xef, 0xc2, 0x58, 0x63, 0xb5, 0xcb, 0x97, 0x4f, 0x82, 0x6c, 0x2b,
	0x36, 0x8b, 0xfb, 0x01, 0x82, 0x89, 0x79, 0x4d, 0x73, 0x77, 0x82, 0x4f, 0xc6, 0x5b, 0xee, 0xff,
	0x77, 0x9e, 0x84, 0xaf, 0x01, 0x0e, 0x05, 0xa7, 0x2f, 0x03, 0x34, 0xfa, 0xf0, 0x9c, 0x22, 0xbc,
	0x29, 0xad, 0x21, 0x42, 0x69, 0xd0, 0x25, 0xb7, 0xd2, 0x7c, 0x46, 0x8c, 0xf6, 0x2f, 0x08, 0x8e,
	0xf2, 0x8c, 0xba, 0x5b, 0x3d, 0x4e, 0xb6, 0x3d, 0xdd, 0xca, 0x76, 0x06, 0xa6, 0xe3, 0x12, 0x61,
	0x39, 0x7f, 0x84, 0x40, 0xf6, 0x8e, 0xe0, 0xe3, 0xa4, 0xd6, 0x51, 0x98, 0x12, 0x92, 0x62, 0xe4,
	0x1f, 0x21, 0x98, 0x11, 0xd8, 0x3d, 0x59, 0x9a, 0xcd, 0xc2, 0xb1, 0x04, 0xb9, 0xb0, 0xcc, 0xdf,
	0x45, 0x70, 0x98, 0x29, 0x5c, 0x52, 0x6d, 0x52, 0x26, 0x35, 0xd3, 0xd6, 0x1d, 0xd3, 0xda, 0x12,
	0xaa, 0x76, 0x07, 0xf6, 0x58, 0x3b, 0x96, 0x21, 0xcd, 0x4e, 0x08, 0xf9, 0x37, 0xc3, 0x8f, 0x58,
	0xe1, 0x05, 0xf9, 0x08, 0xc8, 0x22, 0x36, 0x8c, 0xf4, 0x4f, 0x08, 0xf2, 0x7c, 0xb3, 0x2e, 0xab,
	0x15, 0x95, 0x6b, 0x4f, 0x37, 0x72, 0x3d, 0x0e, 0x33, 0xf1, 0x49, 0xb0, 0x8c, 0xdf, 0x47, 0x70,
	0xa4, 0x21, 0xea, 0xe3, 0xa0, 0x54, 0x1e, 0x8e, 0xc6, 0x10, 0x62, 0xd4, 0x7f, 0x46, 0x70, 0x5c,
	0x68, 0xf9, 0xa4, 0xe8, 0xf5, 0x14, 0xcc, 0x26, 0xca, 0x83, 0xe5, 0xfd, 0x2d, 0x82, 0x71, 0xa6,
	0x6f, 0x42, 0xad, 0xa6, 0x60, 0x28, 0xc0, 0x7c, 0xe7, 0x15, 0xe4, 0x7f, 0x8d, 0xc5, 0xeb, 0xda,
	0x3f, 0x97, 0xde, 0x24, 0x1c, 0xe2, 0xd1, 0x65, 0x19, 0xfd, 0x81, 0x60, 0x2a, 0xda, 0xa4, 0xcb,
	0x12, 0xe6, 0x21, 0xc0, 0x2e, 0xf8, 0xe2, 0x33, 0xdc, 0x58, 0xe6, 0x6a, 0xdd, 0xdb, 0x8d, 0x62,
	0x4c, 0xc3, 0x11, 0x71, 0xa6, 0xac, 0x24, 0xdf, 0x23, 0xff, 0xc5, 0xeb, 0x89, 0xd1, 0x79, 0x0a,
	0x0e, 0x0b, 0x18, 0xb3, 0xbc, 0xfe, 0x42, 0x30, 0xcd, 0xb5, 0xfa, 0xcf, 0xa9, 0x7d, 0x0c, 0xf2,
	0xb1, 0xc9, 0x7a, 0x85, 0x99, 0xfb, 0x2d, 0x07, 0x83, 0xae, 0xd5, 0x2d, 0x62, 0x6d, 0xea, 0x6b,
	0x04, 0x6b, 0xd0, 0xc7, 0x06, 0x15, 0x78, 0x56, 0x48, 0x22, 0x3c, 0x93, 0x91, 0x4e, 0x24, 0x33,
	0x66, 0xfd, 0xde, 0x26, 0x0c, 0x85, 0xc6, 0x21, 0xf8, 0x64, 0x12, 0xf7, 0x90, 0x4e, 0xd2, 0x5c,
	0x3b, 0x2e, 0x2c, 0xee, 0x7b, 0x08, 0x46, 0x23, 0xc7, 0x12, 0xf8, 0x39, 0x21, 0x9a, 0x68, 0xd4,
	0x22, 0x15, 0xd3, 0xb8, 0x32, 0x42, 0x06, 0x40, 0xa3, 0x53, 0xc7, 0xe2, 0x97, 0xa5, 0x96, 0x69,
	0x86, 0x54, 0x48, 0x6c, 0xcf, 0xc2, 0x3d, 0x80, 0x3d, 0xcd, 0x83, 0x01, 0xfc, 0x74, 0x42, 0x90,
	0x70, 0xf5, 0x4f, 0xb7, 0xe9, 0xc5, 0x08, 0x6c, 0xc1, 0x70, 0x78, 0x04, 0x80, 0xc5, 0x32, 0x46,
	0xce, 0x1c, 0xa4, 0x53, 0x6d, 0xf9, 0x34, 0xce, 0x5c, 0xa8, 0xad, 0x8e, 0x39, 0x73, 0x51, 0x83,
	0x85, 0x98, 0x33, 0x17, 0x39, 0x4a, 0xc0, 0xef, 0x20, 0xf8, 0x7f, 0x44, 0x3f, 0x8f, 0xcf, 0x24,
	0xc7, 0x0a, 0x97, 0xfe, 0xd9, 0xf6, 0x1d, 0x19, 0x95, 0xb7, 0x11, 0xe0, 0xd6, 0xb6, 0x1a, 0x3f,
	0x13, 0xf3, 0xb4, 0xe1, 0x0c, 0x1b, 0xa4, 0x33, 0x6d, 0xfb, 0x31, 0x1e, 0x9f, 0x20, 0xc8, 0xf2,
	0xda, 0x7b, 0xfc, 0x7c, 0x9b, 0xa8, 0xe1, 0xe2, 0x9c, 0x4b, 0xe9, 0xdd, 0xb8, 0x8f, 0x8d, 0xe6,
	0x3d, 0xe6, 0x3e, 0xb6, 0x0c, 0x1f, 0x62, 0xee, 0x63, 0xeb, 0x1c, 0xc2, 0xbd, 0x8f, 0xcd, 0xb3,
	0x82, 0x98, 0xfb, 0xc8, 0x19, 0x5b, 0xc4, 0xdc, 0x47, 0xde, 0x40, 0x82, 0x2a, 0xc1, 0x6b, 0x88,
	0x63, 0x94, 0x88, 0x99, 0x63, 0xc4, 0x28, 0x11, 0x37, 0x73, 0xc0, 0x5f, 0xa1, 0x9d, 0xf7, 0x37,
	0x4e, 0xcf, 0x87, 0x4b, 0xa9, 0x22, 0x84, 0xeb, 0x76, 0xa9, 0x23, 0x0c, 0xc6, 0xf5, 0x33, 0x04,
	0x39, 0x41, 0x8b, 0x8a, 0x2f, 0x24, 0x38, 0x94, 0xc2, 0x5a, 0x5e, 0x4c, 0x0f, 0xc0, 0x28, 0xfe,
	0x80, 0x82, 0xaf, 0x49, 0xbc, 0x8a, 0x5e, 0x4e, 0x1b, 0x27, 0x5c, 0xd4, 0x2b, 0x9d, 0xc2, 0x30,
	0xd2, 0x0f, 0x11, 0x1d, 0xc3, 0x72, 0xfa, 0x13, 0x7c, 0x3e, 0x89, 0x76, 0xfc, 0xde, 0x52, 0xba,
	0x90, 0xda, 0x9f, 0xf1, 0xfb, 0x0e, 0xed, 0x0c, 0xcf, 0xb8, 0xfd, 0x13, 0x5e, 0x48, 0x19, 0x25,
	0x5c, 0xd2, 0xcb, 0x1d, 0xa2, 0x30, 0xc6, 0x5f, 0x22, 0x18, 0x17, 0x36, 0x7d, 0x78, 0x3e, 0xa1,
	0x76, 0x82, 0xba, 0x96, 0x3a, 0x81, 0x60, 0x44, 0x7f, 0x44, 0xc1, 0x49, 0x17, 0xbf, 0xba, 0x57,
	0xd3, 0xc7, 0x0a, 0x17, 0xf8, 0x5a, 0xe7, 0x40, 0x8c, 0xfa, 0x87, 0x08, 0xf6, 0x47, 0x37, 0x5b,
	0xb8, 0x98, 0x44, 0x45, 0x4e, 0x55, 0xcf, 0xa6, 0xf2, 0x65, 0x9c, 0xbe, 0x40, 0x70, 0x50, 0xd4,
	0x00, 0xe2, 0x8b, 0x29, 0xd0, 0xc3, 0x05, 0x9c, 0xef, 0x00, 0x81, 0xb1, 0xfc, 0x14, 0xf9, 0xdf,
	0x6d, 0x44, 0x15, 0xef, 0x5c, 0x42, 0x85, 0x38, 0xf5, 0x3b, 0x9f, 0xd6, 0x9d, 0x91, 0xfb, 0x06,
	0xf9, 0x5f, 0x8a, 0xf0, 0xab, 0x78, 0x29, 0x5d, 0x8c, 0x70, 0x21, 0x17, 0x3a, 0x03, 0xf1, 0xe8,
	0x96, 0x3e, 0xce, 0xc0, 0xc4, 0x9a, 0x69, 0x88, 0xb0, 0x4a, 0x03, 0x2e, 0xcc, 0xa2, 0x65, 0x3a,
	0xe6, 0x22, 0xba, 0xfb, 0x6a, 0x45, 0x77, 0xee, 0xd5, 0x57, 0x95, 0x35, 0xd3, 0x28, 0xac, 0xd6,
	0xd7, 0x57, 0xeb, 0xfa, 0x86, 0xe6, 0xfe, 0x51, 0xa8, 0x59, 0xfa, 0xa6, 0xea, 0x90, 0x42, 0x85,
	0x54, 0xbd, 0x5f, 0x1d, 0x14, 0x2a, 0x66, 0x41, 0xf0, 0x73, 0x85, 0xb3, 0xfe, 0x8a, 0xbf, 0xf0,
	0x79, 0xa6, 0xa7, 0x34, 0x5f, 0xfe, 0x3a, 0x93, 0x2b, 0xd5, 0xd7, 0x95, 0x79, 0xca, 0xa5, 0xec,
	0x73, 0x79, 0x85, 0xd9, 0x3c, 0xa2, 0xbb, 0xcb, 0x74, 0x77, 0xd9, 0xdf, 0x5d, 0xf6, 0x77, 0x7f,
	0xcf, 0xe4, 0x05, 0xbb, 0xcb, 0x57, 0x17, 0x4b, 0x2f, 0x11, 0x47, 0xd5, 0x54, 0x47, 0xfd, 0x33,
	0x73, 0xa8, 0x54, 0x5f, 0x2f, 0x16, 0xa9, 0x69, 0xb1, 0xe8, 0xdb, 0x16, 0x8b, 0xbe, 0xf1, 0xea,
	0x6e, 0x9a, 0xc3, 0xa9, 0xbf, 0x03, 0x00, 0x00, 0xff, 0xff, 0x5e, 0x02, 0xf1, 0xf4, 0xb7, 0x21,
	0x00, 0x00,
}
