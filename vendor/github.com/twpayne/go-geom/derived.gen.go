// Code generated by goderive DO NOT EDIT.

package geom

// deriveCloneBounds returns a clone of the src parameter.
func deriveCloneBounds(src *Bounds) *Bounds {
	if src == nil {
		return nil
	}
	dst := new(Bounds)
	deriveDeepCopy(dst, src)
	return dst
}

// deriveCloneCoord returns a clone of the src parameter.
func deriveCloneCoord(src Coord) Coord {
	if src == nil {
		return nil
	}
	dst := make(Coord, len(src))
	deriveDeepCopy_(dst, src)
	return dst
}

// deriveCloneLinearRing returns a clone of the src parameter.
func deriveCloneLinearRing(src *LinearRing) *LinearRing {
	if src == nil {
		return nil
	}
	dst := new(LinearRing)
	deriveDeepCopy_1(dst, src)
	return dst
}

// deriveCloneLineString returns a clone of the src parameter.
func deriveCloneLineString(src *LineString) *LineString {
	if src == nil {
		return nil
	}
	dst := new(LineString)
	deriveDeepCopy_2(dst, src)
	return dst
}

// deriveCloneMultiLineString returns a clone of the src parameter.
func deriveCloneMultiLineString(src *MultiLineString) *MultiLineString {
	if src == nil {
		return nil
	}
	dst := new(MultiLineString)
	deriveDeepCopy_3(dst, src)
	return dst
}

// deriveCloneMultiPoint returns a clone of the src parameter.
func deriveCloneMultiPoint(src *MultiPoint) *MultiPoint {
	if src == nil {
		return nil
	}
	dst := new(MultiPoint)
	deriveDeepCopy_4(dst, src)
	return dst
}

// deriveCloneMultiPolygon returns a clone of the src parameter.
func deriveCloneMultiPolygon(src *MultiPolygon) *MultiPolygon {
	if src == nil {
		return nil
	}
	dst := new(MultiPolygon)
	deriveDeepCopy_5(dst, src)
	return dst
}

// deriveClonePoint returns a clone of the src parameter.
func deriveClonePoint(src *Point) *Point {
	if src == nil {
		return nil
	}
	dst := new(Point)
	deriveDeepCopy_6(dst, src)
	return dst
}

// deriveClonePolygon returns a clone of the src parameter.
func deriveClonePolygon(src *Polygon) *Polygon {
	if src == nil {
		return nil
	}
	dst := new(Polygon)
	deriveDeepCopy_7(dst, src)
	return dst
}

// deriveDeepCopy recursively copies the contents of src into dst.
func deriveDeepCopy(dst, src *Bounds) {
	dst.layout = src.layout
	if src.min == nil {
		dst.min = nil
	} else {
		if dst.min != nil {
			if len(src.min) > len(dst.min) {
				if cap(dst.min) >= len(src.min) {
					dst.min = (dst.min)[:len(src.min)]
				} else {
					dst.min = make([]float64, len(src.min))
				}
			} else if len(src.min) < len(dst.min) {
				dst.min = (dst.min)[:len(src.min)]
			}
		} else {
			dst.min = make([]float64, len(src.min))
		}
		copy(dst.min, src.min)
	}
	if src.max == nil {
		dst.max = nil
	} else {
		if dst.max != nil {
			if len(src.max) > len(dst.max) {
				if cap(dst.max) >= len(src.max) {
					dst.max = (dst.max)[:len(src.max)]
				} else {
					dst.max = make([]float64, len(src.max))
				}
			} else if len(src.max) < len(dst.max) {
				dst.max = (dst.max)[:len(src.max)]
			}
		} else {
			dst.max = make([]float64, len(src.max))
		}
		copy(dst.max, src.max)
	}
}

// deriveDeepCopy_ recursively copies the contents of src into dst.
func deriveDeepCopy_(dst, src Coord) {
	copy(dst, src)
}

// deriveDeepCopy_1 recursively copies the contents of src into dst.
func deriveDeepCopy_1(dst, src *LinearRing) {
	func() {
		field := new(geom1)
		deriveDeepCopy_8(field, &src.geom1)
		dst.geom1 = *field
	}()
}

// deriveDeepCopy_2 recursively copies the contents of src into dst.
func deriveDeepCopy_2(dst, src *LineString) {
	func() {
		field := new(geom1)
		deriveDeepCopy_8(field, &src.geom1)
		dst.geom1 = *field
	}()
}

// deriveDeepCopy_3 recursively copies the contents of src into dst.
func deriveDeepCopy_3(dst, src *MultiLineString) {
	func() {
		field := new(geom2)
		deriveDeepCopy_9(field, &src.geom2)
		dst.geom2 = *field
	}()
}

// deriveDeepCopy_4 recursively copies the contents of src into dst.
func deriveDeepCopy_4(dst, src *MultiPoint) {
	func() {
		field := new(geom2)
		deriveDeepCopy_9(field, &src.geom2)
		dst.geom2 = *field
	}()
}

// deriveDeepCopy_5 recursively copies the contents of src into dst.
func deriveDeepCopy_5(dst, src *MultiPolygon) {
	func() {
		field := new(geom3)
		deriveDeepCopy_10(field, &src.geom3)
		dst.geom3 = *field
	}()
}

// deriveDeepCopy_6 recursively copies the contents of src into dst.
func deriveDeepCopy_6(dst, src *Point) {
	func() {
		field := new(geom0)
		deriveDeepCopy_11(field, &src.geom0)
		dst.geom0 = *field
	}()
}

// deriveDeepCopy_7 recursively copies the contents of src into dst.
func deriveDeepCopy_7(dst, src *Polygon) {
	func() {
		field := new(geom2)
		deriveDeepCopy_9(field, &src.geom2)
		dst.geom2 = *field
	}()
}

// deriveDeepCopy_8 recursively copies the contents of src into dst.
func deriveDeepCopy_8(dst, src *geom1) {
	func() {
		field := new(geom0)
		deriveDeepCopy_11(field, &src.geom0)
		dst.geom0 = *field
	}()
}

// deriveDeepCopy_9 recursively copies the contents of src into dst.
func deriveDeepCopy_9(dst, src *geom2) {
	func() {
		field := new(geom1)
		deriveDeepCopy_8(field, &src.geom1)
		dst.geom1 = *field
	}()
	if src.ends == nil {
		dst.ends = nil
	} else {
		if dst.ends != nil {
			if len(src.ends) > len(dst.ends) {
				if cap(dst.ends) >= len(src.ends) {
					dst.ends = (dst.ends)[:len(src.ends)]
				} else {
					dst.ends = make([]int, len(src.ends))
				}
			} else if len(src.ends) < len(dst.ends) {
				dst.ends = (dst.ends)[:len(src.ends)]
			}
		} else {
			dst.ends = make([]int, len(src.ends))
		}
		copy(dst.ends, src.ends)
	}
}

// deriveDeepCopy_10 recursively copies the contents of src into dst.
func deriveDeepCopy_10(dst, src *geom3) {
	func() {
		field := new(geom1)
		deriveDeepCopy_8(field, &src.geom1)
		dst.geom1 = *field
	}()
	if src.endss == nil {
		dst.endss = nil
	} else {
		if dst.endss != nil {
			if len(src.endss) > len(dst.endss) {
				if cap(dst.endss) >= len(src.endss) {
					dst.endss = (dst.endss)[:len(src.endss)]
				} else {
					dst.endss = make([][]int, len(src.endss))
				}
			} else if len(src.endss) < len(dst.endss) {
				dst.endss = (dst.endss)[:len(src.endss)]
			}
		} else {
			dst.endss = make([][]int, len(src.endss))
		}
		deriveDeepCopy_12(dst.endss, src.endss)
	}
}

// deriveDeepCopy_11 recursively copies the contents of src into dst.
func deriveDeepCopy_11(dst, src *geom0) {
	dst.layout = src.layout
	dst.stride = src.stride
	if src.flatCoords == nil {
		dst.flatCoords = nil
	} else {
		if dst.flatCoords != nil {
			if len(src.flatCoords) > len(dst.flatCoords) {
				if cap(dst.flatCoords) >= len(src.flatCoords) {
					dst.flatCoords = (dst.flatCoords)[:len(src.flatCoords)]
				} else {
					dst.flatCoords = make([]float64, len(src.flatCoords))
				}
			} else if len(src.flatCoords) < len(dst.flatCoords) {
				dst.flatCoords = (dst.flatCoords)[:len(src.flatCoords)]
			}
		} else {
			dst.flatCoords = make([]float64, len(src.flatCoords))
		}
		copy(dst.flatCoords, src.flatCoords)
	}
	dst.srid = src.srid
}

// deriveDeepCopy_12 recursively copies the contents of src into dst.
func deriveDeepCopy_12(dst, src [][]int) {
	for src_i, src_value := range src {
		if src_value == nil {
			dst[src_i] = nil
		} else {
			if dst[src_i] != nil {
				if len(src_value) > len(dst[src_i]) {
					if cap(dst[src_i]) >= len(src_value) {
						dst[src_i] = (dst[src_i])[:len(src_value)]
					} else {
						dst[src_i] = make([]int, len(src_value))
					}
				} else if len(src_value) < len(dst[src_i]) {
					dst[src_i] = (dst[src_i])[:len(src_value)]
				}
			} else {
				dst[src_i] = make([]int, len(src_value))
			}
			copy(dst[src_i], src_value)
		}
	}
}
