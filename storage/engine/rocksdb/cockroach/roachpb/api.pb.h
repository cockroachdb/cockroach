// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: cockroach/roachpb/api.proto

#ifndef PROTOBUF_cockroach_2froachpb_2fapi_2eproto__INCLUDED
#define PROTOBUF_cockroach_2froachpb_2fapi_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3000000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3000000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "cockroach/roachpb/metadata.pb.h"
#include "cockroach/roachpb/data.pb.h"
#include "cockroach/roachpb/errors.pb.h"
#include "cockroach/util/tracing/span.pb.h"
#include "gogoproto/gogo.pb.h"
// @@protoc_insertion_point(includes)

namespace cockroach {
namespace roachpb {

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_cockroach_2froachpb_2fapi_2eproto();
void protobuf_AssignDesc_cockroach_2froachpb_2fapi_2eproto();
void protobuf_ShutdownFile_cockroach_2froachpb_2fapi_2eproto();

class AdminMergeRequest;
class AdminMergeResponse;
class AdminSplitRequest;
class AdminSplitResponse;
class BatchRequest;
class BatchResponse;
class BatchResponse_Header;
class BeginTransactionRequest;
class BeginTransactionResponse;
class CheckConsistencyRequest;
class CheckConsistencyResponse;
class ComputeChecksumRequest;
class ComputeChecksumResponse;
class ConditionalPutRequest;
class ConditionalPutResponse;
class DeleteRangeRequest;
class DeleteRangeResponse;
class DeleteRequest;
class DeleteResponse;
class EndTransactionRequest;
class EndTransactionResponse;
class GCRequest;
class GCRequest_GCKey;
class GCResponse;
class GetRequest;
class GetResponse;
class Header;
class HeartbeatTxnRequest;
class HeartbeatTxnResponse;
class IncrementRequest;
class IncrementResponse;
class LeaderLeaseRequest;
class LeaderLeaseResponse;
class MergeRequest;
class MergeResponse;
class NoopRequest;
class NoopResponse;
class PushTxnRequest;
class PushTxnResponse;
class PutRequest;
class PutResponse;
class RangeLookupRequest;
class RangeLookupResponse;
class RequestUnion;
class ResolveIntentRangeRequest;
class ResolveIntentRangeResponse;
class ResolveIntentRequest;
class ResolveIntentResponse;
class ResponseHeader;
class ResponseUnion;
class ReverseScanRequest;
class ReverseScanResponse;
class ScanRequest;
class ScanResponse;
class TruncateLogRequest;
class TruncateLogResponse;
class VerifyChecksumRequest;
class VerifyChecksumResponse;

enum ReadConsistencyType {
  CONSISTENT = 0,
  CONSENSUS = 1,
  INCONSISTENT = 2
};
bool ReadConsistencyType_IsValid(int value);
const ReadConsistencyType ReadConsistencyType_MIN = CONSISTENT;
const ReadConsistencyType ReadConsistencyType_MAX = INCONSISTENT;
const int ReadConsistencyType_ARRAYSIZE = ReadConsistencyType_MAX + 1;

const ::google::protobuf::EnumDescriptor* ReadConsistencyType_descriptor();
inline const ::std::string& ReadConsistencyType_Name(ReadConsistencyType value) {
  return ::google::protobuf::internal::NameOfEnum(
    ReadConsistencyType_descriptor(), value);
}
inline bool ReadConsistencyType_Parse(
    const ::std::string& name, ReadConsistencyType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ReadConsistencyType>(
    ReadConsistencyType_descriptor(), name, value);
}
enum PushTxnType {
  PUSH_TIMESTAMP = 0,
  PUSH_ABORT = 1,
  PUSH_TOUCH = 2,
  PUSH_QUERY = 3
};
bool PushTxnType_IsValid(int value);
const PushTxnType PushTxnType_MIN = PUSH_TIMESTAMP;
const PushTxnType PushTxnType_MAX = PUSH_QUERY;
const int PushTxnType_ARRAYSIZE = PushTxnType_MAX + 1;

const ::google::protobuf::EnumDescriptor* PushTxnType_descriptor();
inline const ::std::string& PushTxnType_Name(PushTxnType value) {
  return ::google::protobuf::internal::NameOfEnum(
    PushTxnType_descriptor(), value);
}
inline bool PushTxnType_Parse(
    const ::std::string& name, PushTxnType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<PushTxnType>(
    PushTxnType_descriptor(), name, value);
}
// ===================================================================

class ResponseHeader : public ::google::protobuf::Message {
 public:
  ResponseHeader();
  virtual ~ResponseHeader();

  ResponseHeader(const ResponseHeader& from);

  inline ResponseHeader& operator=(const ResponseHeader& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ResponseHeader& default_instance();

  void Swap(ResponseHeader* other);

  // implements Message ----------------------------------------------

  inline ResponseHeader* New() const { return New(NULL); }

  ResponseHeader* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ResponseHeader& from);
  void MergeFrom(const ResponseHeader& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ResponseHeader* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .cockroach.roachpb.Transaction txn = 3;
  bool has_txn() const;
  void clear_txn();
  static const int kTxnFieldNumber = 3;
  const ::cockroach::roachpb::Transaction& txn() const;
  ::cockroach::roachpb::Transaction* mutable_txn();
  ::cockroach::roachpb::Transaction* release_txn();
  void set_allocated_txn(::cockroach::roachpb::Transaction* txn);

  // @@protoc_insertion_point(class_scope:cockroach.roachpb.ResponseHeader)
 private:
  inline void set_has_txn();
  inline void clear_has_txn();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::cockroach::roachpb::Transaction* txn_;
  friend void  protobuf_AddDesc_cockroach_2froachpb_2fapi_2eproto();
  friend void protobuf_AssignDesc_cockroach_2froachpb_2fapi_2eproto();
  friend void protobuf_ShutdownFile_cockroach_2froachpb_2fapi_2eproto();

  void InitAsDefaultInstance();
  static ResponseHeader* default_instance_;
};
// -------------------------------------------------------------------

class GetRequest : public ::google::protobuf::Message {
 public:
  GetRequest();
  virtual ~GetRequest();

  GetRequest(const GetRequest& from);

  inline GetRequest& operator=(const GetRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetRequest& default_instance();

  void Swap(GetRequest* other);

  // implements Message ----------------------------------------------

  inline GetRequest* New() const { return New(NULL); }

  GetRequest* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetRequest& from);
  void MergeFrom(const GetRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(GetRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .cockroach.roachpb.Span header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::cockroach::roachpb::Span& header() const;
  ::cockroach::roachpb::Span* mutable_header();
  ::cockroach::roachpb::Span* release_header();
  void set_allocated_header(::cockroach::roachpb::Span* header);

  // @@protoc_insertion_point(class_scope:cockroach.roachpb.GetRequest)
 private:
  inline void set_has_header();
  inline void clear_has_header();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::cockroach::roachpb::Span* header_;
  friend void  protobuf_AddDesc_cockroach_2froachpb_2fapi_2eproto();
  friend void protobuf_AssignDesc_cockroach_2froachpb_2fapi_2eproto();
  friend void protobuf_ShutdownFile_cockroach_2froachpb_2fapi_2eproto();

  void InitAsDefaultInstance();
  static GetRequest* default_instance_;
};
// -------------------------------------------------------------------

class GetResponse : public ::google::protobuf::Message {
 public:
  GetResponse();
  virtual ~GetResponse();

  GetResponse(const GetResponse& from);

  inline GetResponse& operator=(const GetResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetResponse& default_instance();

  void Swap(GetResponse* other);

  // implements Message ----------------------------------------------

  inline GetResponse* New() const { return New(NULL); }

  GetResponse* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetResponse& from);
  void MergeFrom(const GetResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(GetResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .cockroach.roachpb.ResponseHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::cockroach::roachpb::ResponseHeader& header() const;
  ::cockroach::roachpb::ResponseHeader* mutable_header();
  ::cockroach::roachpb::ResponseHeader* release_header();
  void set_allocated_header(::cockroach::roachpb::ResponseHeader* header);

  // optional .cockroach.roachpb.Value value = 2;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 2;
  const ::cockroach::roachpb::Value& value() const;
  ::cockroach::roachpb::Value* mutable_value();
  ::cockroach::roachpb::Value* release_value();
  void set_allocated_value(::cockroach::roachpb::Value* value);

  // @@protoc_insertion_point(class_scope:cockroach.roachpb.GetResponse)
 private:
  inline void set_has_header();
  inline void clear_has_header();
  inline void set_has_value();
  inline void clear_has_value();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::cockroach::roachpb::ResponseHeader* header_;
  ::cockroach::roachpb::Value* value_;
  friend void  protobuf_AddDesc_cockroach_2froachpb_2fapi_2eproto();
  friend void protobuf_AssignDesc_cockroach_2froachpb_2fapi_2eproto();
  friend void protobuf_ShutdownFile_cockroach_2froachpb_2fapi_2eproto();

  void InitAsDefaultInstance();
  static GetResponse* default_instance_;
};
// -------------------------------------------------------------------

class PutRequest : public ::google::protobuf::Message {
 public:
  PutRequest();
  virtual ~PutRequest();

  PutRequest(const PutRequest& from);

  inline PutRequest& operator=(const PutRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PutRequest& default_instance();

  void Swap(PutRequest* other);

  // implements Message ----------------------------------------------

  inline PutRequest* New() const { return New(NULL); }

  PutRequest* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PutRequest& from);
  void MergeFrom(const PutRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(PutRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .cockroach.roachpb.Span header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::cockroach::roachpb::Span& header() const;
  ::cockroach::roachpb::Span* mutable_header();
  ::cockroach::roachpb::Span* release_header();
  void set_allocated_header(::cockroach::roachpb::Span* header);

  // optional .cockroach.roachpb.Value value = 2;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 2;
  const ::cockroach::roachpb::Value& value() const;
  ::cockroach::roachpb::Value* mutable_value();
  ::cockroach::roachpb::Value* release_value();
  void set_allocated_value(::cockroach::roachpb::Value* value);

  // @@protoc_insertion_point(class_scope:cockroach.roachpb.PutRequest)
 private:
  inline void set_has_header();
  inline void clear_has_header();
  inline void set_has_value();
  inline void clear_has_value();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::cockroach::roachpb::Span* header_;
  ::cockroach::roachpb::Value* value_;
  friend void  protobuf_AddDesc_cockroach_2froachpb_2fapi_2eproto();
  friend void protobuf_AssignDesc_cockroach_2froachpb_2fapi_2eproto();
  friend void protobuf_ShutdownFile_cockroach_2froachpb_2fapi_2eproto();

  void InitAsDefaultInstance();
  static PutRequest* default_instance_;
};
// -------------------------------------------------------------------

class PutResponse : public ::google::protobuf::Message {
 public:
  PutResponse();
  virtual ~PutResponse();

  PutResponse(const PutResponse& from);

  inline PutResponse& operator=(const PutResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PutResponse& default_instance();

  void Swap(PutResponse* other);

  // implements Message ----------------------------------------------

  inline PutResponse* New() const { return New(NULL); }

  PutResponse* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PutResponse& from);
  void MergeFrom(const PutResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(PutResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .cockroach.roachpb.ResponseHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::cockroach::roachpb::ResponseHeader& header() const;
  ::cockroach::roachpb::ResponseHeader* mutable_header();
  ::cockroach::roachpb::ResponseHeader* release_header();
  void set_allocated_header(::cockroach::roachpb::ResponseHeader* header);

  // @@protoc_insertion_point(class_scope:cockroach.roachpb.PutResponse)
 private:
  inline void set_has_header();
  inline void clear_has_header();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::cockroach::roachpb::ResponseHeader* header_;
  friend void  protobuf_AddDesc_cockroach_2froachpb_2fapi_2eproto();
  friend void protobuf_AssignDesc_cockroach_2froachpb_2fapi_2eproto();
  friend void protobuf_ShutdownFile_cockroach_2froachpb_2fapi_2eproto();

  void InitAsDefaultInstance();
  static PutResponse* default_instance_;
};
// -------------------------------------------------------------------

class ConditionalPutRequest : public ::google::protobuf::Message {
 public:
  ConditionalPutRequest();
  virtual ~ConditionalPutRequest();

  ConditionalPutRequest(const ConditionalPutRequest& from);

  inline ConditionalPutRequest& operator=(const ConditionalPutRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ConditionalPutRequest& default_instance();

  void Swap(ConditionalPutRequest* other);

  // implements Message ----------------------------------------------

  inline ConditionalPutRequest* New() const { return New(NULL); }

  ConditionalPutRequest* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ConditionalPutRequest& from);
  void MergeFrom(const ConditionalPutRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ConditionalPutRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .cockroach.roachpb.Span header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::cockroach::roachpb::Span& header() const;
  ::cockroach::roachpb::Span* mutable_header();
  ::cockroach::roachpb::Span* release_header();
  void set_allocated_header(::cockroach::roachpb::Span* header);

  // optional .cockroach.roachpb.Value value = 2;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 2;
  const ::cockroach::roachpb::Value& value() const;
  ::cockroach::roachpb::Value* mutable_value();
  ::cockroach::roachpb::Value* release_value();
  void set_allocated_value(::cockroach::roachpb::Value* value);

  // optional .cockroach.roachpb.Value exp_value = 3;
  bool has_exp_value() const;
  void clear_exp_value();
  static const int kExpValueFieldNumber = 3;
  const ::cockroach::roachpb::Value& exp_value() const;
  ::cockroach::roachpb::Value* mutable_exp_value();
  ::cockroach::roachpb::Value* release_exp_value();
  void set_allocated_exp_value(::cockroach::roachpb::Value* exp_value);

  // @@protoc_insertion_point(class_scope:cockroach.roachpb.ConditionalPutRequest)
 private:
  inline void set_has_header();
  inline void clear_has_header();
  inline void set_has_value();
  inline void clear_has_value();
  inline void set_has_exp_value();
  inline void clear_has_exp_value();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::cockroach::roachpb::Span* header_;
  ::cockroach::roachpb::Value* value_;
  ::cockroach::roachpb::Value* exp_value_;
  friend void  protobuf_AddDesc_cockroach_2froachpb_2fapi_2eproto();
  friend void protobuf_AssignDesc_cockroach_2froachpb_2fapi_2eproto();
  friend void protobuf_ShutdownFile_cockroach_2froachpb_2fapi_2eproto();

  void InitAsDefaultInstance();
  static ConditionalPutRequest* default_instance_;
};
// -------------------------------------------------------------------

class ConditionalPutResponse : public ::google::protobuf::Message {
 public:
  ConditionalPutResponse();
  virtual ~ConditionalPutResponse();

  ConditionalPutResponse(const ConditionalPutResponse& from);

  inline ConditionalPutResponse& operator=(const ConditionalPutResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ConditionalPutResponse& default_instance();

  void Swap(ConditionalPutResponse* other);

  // implements Message ----------------------------------------------

  inline ConditionalPutResponse* New() const { return New(NULL); }

  ConditionalPutResponse* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ConditionalPutResponse& from);
  void MergeFrom(const ConditionalPutResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ConditionalPutResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .cockroach.roachpb.ResponseHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::cockroach::roachpb::ResponseHeader& header() const;
  ::cockroach::roachpb::ResponseHeader* mutable_header();
  ::cockroach::roachpb::ResponseHeader* release_header();
  void set_allocated_header(::cockroach::roachpb::ResponseHeader* header);

  // @@protoc_insertion_point(class_scope:cockroach.roachpb.ConditionalPutResponse)
 private:
  inline void set_has_header();
  inline void clear_has_header();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::cockroach::roachpb::ResponseHeader* header_;
  friend void  protobuf_AddDesc_cockroach_2froachpb_2fapi_2eproto();
  friend void protobuf_AssignDesc_cockroach_2froachpb_2fapi_2eproto();
  friend void protobuf_ShutdownFile_cockroach_2froachpb_2fapi_2eproto();

  void InitAsDefaultInstance();
  static ConditionalPutResponse* default_instance_;
};
// -------------------------------------------------------------------

class IncrementRequest : public ::google::protobuf::Message {
 public:
  IncrementRequest();
  virtual ~IncrementRequest();

  IncrementRequest(const IncrementRequest& from);

  inline IncrementRequest& operator=(const IncrementRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const IncrementRequest& default_instance();

  void Swap(IncrementRequest* other);

  // implements Message ----------------------------------------------

  inline IncrementRequest* New() const { return New(NULL); }

  IncrementRequest* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const IncrementRequest& from);
  void MergeFrom(const IncrementRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(IncrementRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .cockroach.roachpb.Span header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::cockroach::roachpb::Span& header() const;
  ::cockroach::roachpb::Span* mutable_header();
  ::cockroach::roachpb::Span* release_header();
  void set_allocated_header(::cockroach::roachpb::Span* header);

  // optional int64 increment = 2;
  bool has_increment() const;
  void clear_increment();
  static const int kIncrementFieldNumber = 2;
  ::google::protobuf::int64 increment() const;
  void set_increment(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:cockroach.roachpb.IncrementRequest)
 private:
  inline void set_has_header();
  inline void clear_has_header();
  inline void set_has_increment();
  inline void clear_has_increment();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::cockroach::roachpb::Span* header_;
  ::google::protobuf::int64 increment_;
  friend void  protobuf_AddDesc_cockroach_2froachpb_2fapi_2eproto();
  friend void protobuf_AssignDesc_cockroach_2froachpb_2fapi_2eproto();
  friend void protobuf_ShutdownFile_cockroach_2froachpb_2fapi_2eproto();

  void InitAsDefaultInstance();
  static IncrementRequest* default_instance_;
};
// -------------------------------------------------------------------

class IncrementResponse : public ::google::protobuf::Message {
 public:
  IncrementResponse();
  virtual ~IncrementResponse();

  IncrementResponse(const IncrementResponse& from);

  inline IncrementResponse& operator=(const IncrementResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const IncrementResponse& default_instance();

  void Swap(IncrementResponse* other);

  // implements Message ----------------------------------------------

  inline IncrementResponse* New() const { return New(NULL); }

  IncrementResponse* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const IncrementResponse& from);
  void MergeFrom(const IncrementResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(IncrementResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .cockroach.roachpb.ResponseHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::cockroach::roachpb::ResponseHeader& header() const;
  ::cockroach::roachpb::ResponseHeader* mutable_header();
  ::cockroach::roachpb::ResponseHeader* release_header();
  void set_allocated_header(::cockroach::roachpb::ResponseHeader* header);

  // optional int64 new_value = 2;
  bool has_new_value() const;
  void clear_new_value();
  static const int kNewValueFieldNumber = 2;
  ::google::protobuf::int64 new_value() const;
  void set_new_value(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:cockroach.roachpb.IncrementResponse)
 private:
  inline void set_has_header();
  inline void clear_has_header();
  inline void set_has_new_value();
  inline void clear_has_new_value();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::cockroach::roachpb::ResponseHeader* header_;
  ::google::protobuf::int64 new_value_;
  friend void  protobuf_AddDesc_cockroach_2froachpb_2fapi_2eproto();
  friend void protobuf_AssignDesc_cockroach_2froachpb_2fapi_2eproto();
  friend void protobuf_ShutdownFile_cockroach_2froachpb_2fapi_2eproto();

  void InitAsDefaultInstance();
  static IncrementResponse* default_instance_;
};
// -------------------------------------------------------------------

class DeleteRequest : public ::google::protobuf::Message {
 public:
  DeleteRequest();
  virtual ~DeleteRequest();

  DeleteRequest(const DeleteRequest& from);

  inline DeleteRequest& operator=(const DeleteRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DeleteRequest& default_instance();

  void Swap(DeleteRequest* other);

  // implements Message ----------------------------------------------

  inline DeleteRequest* New() const { return New(NULL); }

  DeleteRequest* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DeleteRequest& from);
  void MergeFrom(const DeleteRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DeleteRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .cockroach.roachpb.Span header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::cockroach::roachpb::Span& header() const;
  ::cockroach::roachpb::Span* mutable_header();
  ::cockroach::roachpb::Span* release_header();
  void set_allocated_header(::cockroach::roachpb::Span* header);

  // @@protoc_insertion_point(class_scope:cockroach.roachpb.DeleteRequest)
 private:
  inline void set_has_header();
  inline void clear_has_header();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::cockroach::roachpb::Span* header_;
  friend void  protobuf_AddDesc_cockroach_2froachpb_2fapi_2eproto();
  friend void protobuf_AssignDesc_cockroach_2froachpb_2fapi_2eproto();
  friend void protobuf_ShutdownFile_cockroach_2froachpb_2fapi_2eproto();

  void InitAsDefaultInstance();
  static DeleteRequest* default_instance_;
};
// -------------------------------------------------------------------

class DeleteResponse : public ::google::protobuf::Message {
 public:
  DeleteResponse();
  virtual ~DeleteResponse();

  DeleteResponse(const DeleteResponse& from);

  inline DeleteResponse& operator=(const DeleteResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DeleteResponse& default_instance();

  void Swap(DeleteResponse* other);

  // implements Message ----------------------------------------------

  inline DeleteResponse* New() const { return New(NULL); }

  DeleteResponse* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DeleteResponse& from);
  void MergeFrom(const DeleteResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DeleteResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .cockroach.roachpb.ResponseHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::cockroach::roachpb::ResponseHeader& header() const;
  ::cockroach::roachpb::ResponseHeader* mutable_header();
  ::cockroach::roachpb::ResponseHeader* release_header();
  void set_allocated_header(::cockroach::roachpb::ResponseHeader* header);

  // @@protoc_insertion_point(class_scope:cockroach.roachpb.DeleteResponse)
 private:
  inline void set_has_header();
  inline void clear_has_header();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::cockroach::roachpb::ResponseHeader* header_;
  friend void  protobuf_AddDesc_cockroach_2froachpb_2fapi_2eproto();
  friend void protobuf_AssignDesc_cockroach_2froachpb_2fapi_2eproto();
  friend void protobuf_ShutdownFile_cockroach_2froachpb_2fapi_2eproto();

  void InitAsDefaultInstance();
  static DeleteResponse* default_instance_;
};
// -------------------------------------------------------------------

class DeleteRangeRequest : public ::google::protobuf::Message {
 public:
  DeleteRangeRequest();
  virtual ~DeleteRangeRequest();

  DeleteRangeRequest(const DeleteRangeRequest& from);

  inline DeleteRangeRequest& operator=(const DeleteRangeRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DeleteRangeRequest& default_instance();

  void Swap(DeleteRangeRequest* other);

  // implements Message ----------------------------------------------

  inline DeleteRangeRequest* New() const { return New(NULL); }

  DeleteRangeRequest* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DeleteRangeRequest& from);
  void MergeFrom(const DeleteRangeRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DeleteRangeRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .cockroach.roachpb.Span header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::cockroach::roachpb::Span& header() const;
  ::cockroach::roachpb::Span* mutable_header();
  ::cockroach::roachpb::Span* release_header();
  void set_allocated_header(::cockroach::roachpb::Span* header);

  // optional int64 max_entries_to_delete = 2;
  bool has_max_entries_to_delete() const;
  void clear_max_entries_to_delete();
  static const int kMaxEntriesToDeleteFieldNumber = 2;
  ::google::protobuf::int64 max_entries_to_delete() const;
  void set_max_entries_to_delete(::google::protobuf::int64 value);

  // optional bool return_keys = 3;
  bool has_return_keys() const;
  void clear_return_keys();
  static const int kReturnKeysFieldNumber = 3;
  bool return_keys() const;
  void set_return_keys(bool value);

  // @@protoc_insertion_point(class_scope:cockroach.roachpb.DeleteRangeRequest)
 private:
  inline void set_has_header();
  inline void clear_has_header();
  inline void set_has_max_entries_to_delete();
  inline void clear_has_max_entries_to_delete();
  inline void set_has_return_keys();
  inline void clear_has_return_keys();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::cockroach::roachpb::Span* header_;
  ::google::protobuf::int64 max_entries_to_delete_;
  bool return_keys_;
  friend void  protobuf_AddDesc_cockroach_2froachpb_2fapi_2eproto();
  friend void protobuf_AssignDesc_cockroach_2froachpb_2fapi_2eproto();
  friend void protobuf_ShutdownFile_cockroach_2froachpb_2fapi_2eproto();

  void InitAsDefaultInstance();
  static DeleteRangeRequest* default_instance_;
};
// -------------------------------------------------------------------

class DeleteRangeResponse : public ::google::protobuf::Message {
 public:
  DeleteRangeResponse();
  virtual ~DeleteRangeResponse();

  DeleteRangeResponse(const DeleteRangeResponse& from);

  inline DeleteRangeResponse& operator=(const DeleteRangeResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DeleteRangeResponse& default_instance();

  void Swap(DeleteRangeResponse* other);

  // implements Message ----------------------------------------------

  inline DeleteRangeResponse* New() const { return New(NULL); }

  DeleteRangeResponse* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DeleteRangeResponse& from);
  void MergeFrom(const DeleteRangeResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DeleteRangeResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .cockroach.roachpb.ResponseHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::cockroach::roachpb::ResponseHeader& header() const;
  ::cockroach::roachpb::ResponseHeader* mutable_header();
  ::cockroach::roachpb::ResponseHeader* release_header();
  void set_allocated_header(::cockroach::roachpb::ResponseHeader* header);

  // repeated bytes keys = 2;
  int keys_size() const;
  void clear_keys();
  static const int kKeysFieldNumber = 2;
  const ::std::string& keys(int index) const;
  ::std::string* mutable_keys(int index);
  void set_keys(int index, const ::std::string& value);
  void set_keys(int index, const char* value);
  void set_keys(int index, const void* value, size_t size);
  ::std::string* add_keys();
  void add_keys(const ::std::string& value);
  void add_keys(const char* value);
  void add_keys(const void* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& keys() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_keys();

  // @@protoc_insertion_point(class_scope:cockroach.roachpb.DeleteRangeResponse)
 private:
  inline void set_has_header();
  inline void clear_has_header();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::cockroach::roachpb::ResponseHeader* header_;
  ::google::protobuf::RepeatedPtrField< ::std::string> keys_;
  friend void  protobuf_AddDesc_cockroach_2froachpb_2fapi_2eproto();
  friend void protobuf_AssignDesc_cockroach_2froachpb_2fapi_2eproto();
  friend void protobuf_ShutdownFile_cockroach_2froachpb_2fapi_2eproto();

  void InitAsDefaultInstance();
  static DeleteRangeResponse* default_instance_;
};
// -------------------------------------------------------------------

class ScanRequest : public ::google::protobuf::Message {
 public:
  ScanRequest();
  virtual ~ScanRequest();

  ScanRequest(const ScanRequest& from);

  inline ScanRequest& operator=(const ScanRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ScanRequest& default_instance();

  void Swap(ScanRequest* other);

  // implements Message ----------------------------------------------

  inline ScanRequest* New() const { return New(NULL); }

  ScanRequest* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ScanRequest& from);
  void MergeFrom(const ScanRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ScanRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .cockroach.roachpb.Span header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::cockroach::roachpb::Span& header() const;
  ::cockroach::roachpb::Span* mutable_header();
  ::cockroach::roachpb::Span* release_header();
  void set_allocated_header(::cockroach::roachpb::Span* header);

  // optional int64 max_results = 2;
  bool has_max_results() const;
  void clear_max_results();
  static const int kMaxResultsFieldNumber = 2;
  ::google::protobuf::int64 max_results() const;
  void set_max_results(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:cockroach.roachpb.ScanRequest)
 private:
  inline void set_has_header();
  inline void clear_has_header();
  inline void set_has_max_results();
  inline void clear_has_max_results();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::cockroach::roachpb::Span* header_;
  ::google::protobuf::int64 max_results_;
  friend void  protobuf_AddDesc_cockroach_2froachpb_2fapi_2eproto();
  friend void protobuf_AssignDesc_cockroach_2froachpb_2fapi_2eproto();
  friend void protobuf_ShutdownFile_cockroach_2froachpb_2fapi_2eproto();

  void InitAsDefaultInstance();
  static ScanRequest* default_instance_;
};
// -------------------------------------------------------------------

class ScanResponse : public ::google::protobuf::Message {
 public:
  ScanResponse();
  virtual ~ScanResponse();

  ScanResponse(const ScanResponse& from);

  inline ScanResponse& operator=(const ScanResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ScanResponse& default_instance();

  void Swap(ScanResponse* other);

  // implements Message ----------------------------------------------

  inline ScanResponse* New() const { return New(NULL); }

  ScanResponse* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ScanResponse& from);
  void MergeFrom(const ScanResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ScanResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .cockroach.roachpb.ResponseHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::cockroach::roachpb::ResponseHeader& header() const;
  ::cockroach::roachpb::ResponseHeader* mutable_header();
  ::cockroach::roachpb::ResponseHeader* release_header();
  void set_allocated_header(::cockroach::roachpb::ResponseHeader* header);

  // repeated .cockroach.roachpb.KeyValue rows = 2;
  int rows_size() const;
  void clear_rows();
  static const int kRowsFieldNumber = 2;
  const ::cockroach::roachpb::KeyValue& rows(int index) const;
  ::cockroach::roachpb::KeyValue* mutable_rows(int index);
  ::cockroach::roachpb::KeyValue* add_rows();
  ::google::protobuf::RepeatedPtrField< ::cockroach::roachpb::KeyValue >*
      mutable_rows();
  const ::google::protobuf::RepeatedPtrField< ::cockroach::roachpb::KeyValue >&
      rows() const;

  // @@protoc_insertion_point(class_scope:cockroach.roachpb.ScanResponse)
 private:
  inline void set_has_header();
  inline void clear_has_header();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::cockroach::roachpb::ResponseHeader* header_;
  ::google::protobuf::RepeatedPtrField< ::cockroach::roachpb::KeyValue > rows_;
  friend void  protobuf_AddDesc_cockroach_2froachpb_2fapi_2eproto();
  friend void protobuf_AssignDesc_cockroach_2froachpb_2fapi_2eproto();
  friend void protobuf_ShutdownFile_cockroach_2froachpb_2fapi_2eproto();

  void InitAsDefaultInstance();
  static ScanResponse* default_instance_;
};
// -------------------------------------------------------------------

class ReverseScanRequest : public ::google::protobuf::Message {
 public:
  ReverseScanRequest();
  virtual ~ReverseScanRequest();

  ReverseScanRequest(const ReverseScanRequest& from);

  inline ReverseScanRequest& operator=(const ReverseScanRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ReverseScanRequest& default_instance();

  void Swap(ReverseScanRequest* other);

  // implements Message ----------------------------------------------

  inline ReverseScanRequest* New() const { return New(NULL); }

  ReverseScanRequest* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReverseScanRequest& from);
  void MergeFrom(const ReverseScanRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ReverseScanRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .cockroach.roachpb.Span header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::cockroach::roachpb::Span& header() const;
  ::cockroach::roachpb::Span* mutable_header();
  ::cockroach::roachpb::Span* release_header();
  void set_allocated_header(::cockroach::roachpb::Span* header);

  // optional int64 max_results = 2;
  bool has_max_results() const;
  void clear_max_results();
  static const int kMaxResultsFieldNumber = 2;
  ::google::protobuf::int64 max_results() const;
  void set_max_results(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:cockroach.roachpb.ReverseScanRequest)
 private:
  inline void set_has_header();
  inline void clear_has_header();
  inline void set_has_max_results();
  inline void clear_has_max_results();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::cockroach::roachpb::Span* header_;
  ::google::protobuf::int64 max_results_;
  friend void  protobuf_AddDesc_cockroach_2froachpb_2fapi_2eproto();
  friend void protobuf_AssignDesc_cockroach_2froachpb_2fapi_2eproto();
  friend void protobuf_ShutdownFile_cockroach_2froachpb_2fapi_2eproto();

  void InitAsDefaultInstance();
  static ReverseScanRequest* default_instance_;
};
// -------------------------------------------------------------------

class ReverseScanResponse : public ::google::protobuf::Message {
 public:
  ReverseScanResponse();
  virtual ~ReverseScanResponse();

  ReverseScanResponse(const ReverseScanResponse& from);

  inline ReverseScanResponse& operator=(const ReverseScanResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ReverseScanResponse& default_instance();

  void Swap(ReverseScanResponse* other);

  // implements Message ----------------------------------------------

  inline ReverseScanResponse* New() const { return New(NULL); }

  ReverseScanResponse* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReverseScanResponse& from);
  void MergeFrom(const ReverseScanResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ReverseScanResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .cockroach.roachpb.ResponseHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::cockroach::roachpb::ResponseHeader& header() const;
  ::cockroach::roachpb::ResponseHeader* mutable_header();
  ::cockroach::roachpb::ResponseHeader* release_header();
  void set_allocated_header(::cockroach::roachpb::ResponseHeader* header);

  // repeated .cockroach.roachpb.KeyValue rows = 2;
  int rows_size() const;
  void clear_rows();
  static const int kRowsFieldNumber = 2;
  const ::cockroach::roachpb::KeyValue& rows(int index) const;
  ::cockroach::roachpb::KeyValue* mutable_rows(int index);
  ::cockroach::roachpb::KeyValue* add_rows();
  ::google::protobuf::RepeatedPtrField< ::cockroach::roachpb::KeyValue >*
      mutable_rows();
  const ::google::protobuf::RepeatedPtrField< ::cockroach::roachpb::KeyValue >&
      rows() const;

  // @@protoc_insertion_point(class_scope:cockroach.roachpb.ReverseScanResponse)
 private:
  inline void set_has_header();
  inline void clear_has_header();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::cockroach::roachpb::ResponseHeader* header_;
  ::google::protobuf::RepeatedPtrField< ::cockroach::roachpb::KeyValue > rows_;
  friend void  protobuf_AddDesc_cockroach_2froachpb_2fapi_2eproto();
  friend void protobuf_AssignDesc_cockroach_2froachpb_2fapi_2eproto();
  friend void protobuf_ShutdownFile_cockroach_2froachpb_2fapi_2eproto();

  void InitAsDefaultInstance();
  static ReverseScanResponse* default_instance_;
};
// -------------------------------------------------------------------

class CheckConsistencyRequest : public ::google::protobuf::Message {
 public:
  CheckConsistencyRequest();
  virtual ~CheckConsistencyRequest();

  CheckConsistencyRequest(const CheckConsistencyRequest& from);

  inline CheckConsistencyRequest& operator=(const CheckConsistencyRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CheckConsistencyRequest& default_instance();

  void Swap(CheckConsistencyRequest* other);

  // implements Message ----------------------------------------------

  inline CheckConsistencyRequest* New() const { return New(NULL); }

  CheckConsistencyRequest* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CheckConsistencyRequest& from);
  void MergeFrom(const CheckConsistencyRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CheckConsistencyRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .cockroach.roachpb.Span header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::cockroach::roachpb::Span& header() const;
  ::cockroach::roachpb::Span* mutable_header();
  ::cockroach::roachpb::Span* release_header();
  void set_allocated_header(::cockroach::roachpb::Span* header);

  // @@protoc_insertion_point(class_scope:cockroach.roachpb.CheckConsistencyRequest)
 private:
  inline void set_has_header();
  inline void clear_has_header();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::cockroach::roachpb::Span* header_;
  friend void  protobuf_AddDesc_cockroach_2froachpb_2fapi_2eproto();
  friend void protobuf_AssignDesc_cockroach_2froachpb_2fapi_2eproto();
  friend void protobuf_ShutdownFile_cockroach_2froachpb_2fapi_2eproto();

  void InitAsDefaultInstance();
  static CheckConsistencyRequest* default_instance_;
};
// -------------------------------------------------------------------

class CheckConsistencyResponse : public ::google::protobuf::Message {
 public:
  CheckConsistencyResponse();
  virtual ~CheckConsistencyResponse();

  CheckConsistencyResponse(const CheckConsistencyResponse& from);

  inline CheckConsistencyResponse& operator=(const CheckConsistencyResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CheckConsistencyResponse& default_instance();

  void Swap(CheckConsistencyResponse* other);

  // implements Message ----------------------------------------------

  inline CheckConsistencyResponse* New() const { return New(NULL); }

  CheckConsistencyResponse* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CheckConsistencyResponse& from);
  void MergeFrom(const CheckConsistencyResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CheckConsistencyResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .cockroach.roachpb.ResponseHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::cockroach::roachpb::ResponseHeader& header() const;
  ::cockroach::roachpb::ResponseHeader* mutable_header();
  ::cockroach::roachpb::ResponseHeader* release_header();
  void set_allocated_header(::cockroach::roachpb::ResponseHeader* header);

  // @@protoc_insertion_point(class_scope:cockroach.roachpb.CheckConsistencyResponse)
 private:
  inline void set_has_header();
  inline void clear_has_header();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::cockroach::roachpb::ResponseHeader* header_;
  friend void  protobuf_AddDesc_cockroach_2froachpb_2fapi_2eproto();
  friend void protobuf_AssignDesc_cockroach_2froachpb_2fapi_2eproto();
  friend void protobuf_ShutdownFile_cockroach_2froachpb_2fapi_2eproto();

  void InitAsDefaultInstance();
  static CheckConsistencyResponse* default_instance_;
};
// -------------------------------------------------------------------

class BeginTransactionRequest : public ::google::protobuf::Message {
 public:
  BeginTransactionRequest();
  virtual ~BeginTransactionRequest();

  BeginTransactionRequest(const BeginTransactionRequest& from);

  inline BeginTransactionRequest& operator=(const BeginTransactionRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BeginTransactionRequest& default_instance();

  void Swap(BeginTransactionRequest* other);

  // implements Message ----------------------------------------------

  inline BeginTransactionRequest* New() const { return New(NULL); }

  BeginTransactionRequest* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BeginTransactionRequest& from);
  void MergeFrom(const BeginTransactionRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(BeginTransactionRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .cockroach.roachpb.Span header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::cockroach::roachpb::Span& header() const;
  ::cockroach::roachpb::Span* mutable_header();
  ::cockroach::roachpb::Span* release_header();
  void set_allocated_header(::cockroach::roachpb::Span* header);

  // @@protoc_insertion_point(class_scope:cockroach.roachpb.BeginTransactionRequest)
 private:
  inline void set_has_header();
  inline void clear_has_header();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::cockroach::roachpb::Span* header_;
  friend void  protobuf_AddDesc_cockroach_2froachpb_2fapi_2eproto();
  friend void protobuf_AssignDesc_cockroach_2froachpb_2fapi_2eproto();
  friend void protobuf_ShutdownFile_cockroach_2froachpb_2fapi_2eproto();

  void InitAsDefaultInstance();
  static BeginTransactionRequest* default_instance_;
};
// -------------------------------------------------------------------

class BeginTransactionResponse : public ::google::protobuf::Message {
 public:
  BeginTransactionResponse();
  virtual ~BeginTransactionResponse();

  BeginTransactionResponse(const BeginTransactionResponse& from);

  inline BeginTransactionResponse& operator=(const BeginTransactionResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BeginTransactionResponse& default_instance();

  void Swap(BeginTransactionResponse* other);

  // implements Message ----------------------------------------------

  inline BeginTransactionResponse* New() const { return New(NULL); }

  BeginTransactionResponse* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BeginTransactionResponse& from);
  void MergeFrom(const BeginTransactionResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(BeginTransactionResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .cockroach.roachpb.ResponseHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::cockroach::roachpb::ResponseHeader& header() const;
  ::cockroach::roachpb::ResponseHeader* mutable_header();
  ::cockroach::roachpb::ResponseHeader* release_header();
  void set_allocated_header(::cockroach::roachpb::ResponseHeader* header);

  // @@protoc_insertion_point(class_scope:cockroach.roachpb.BeginTransactionResponse)
 private:
  inline void set_has_header();
  inline void clear_has_header();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::cockroach::roachpb::ResponseHeader* header_;
  friend void  protobuf_AddDesc_cockroach_2froachpb_2fapi_2eproto();
  friend void protobuf_AssignDesc_cockroach_2froachpb_2fapi_2eproto();
  friend void protobuf_ShutdownFile_cockroach_2froachpb_2fapi_2eproto();

  void InitAsDefaultInstance();
  static BeginTransactionResponse* default_instance_;
};
// -------------------------------------------------------------------

class EndTransactionRequest : public ::google::protobuf::Message {
 public:
  EndTransactionRequest();
  virtual ~EndTransactionRequest();

  EndTransactionRequest(const EndTransactionRequest& from);

  inline EndTransactionRequest& operator=(const EndTransactionRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EndTransactionRequest& default_instance();

  void Swap(EndTransactionRequest* other);

  // implements Message ----------------------------------------------

  inline EndTransactionRequest* New() const { return New(NULL); }

  EndTransactionRequest* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const EndTransactionRequest& from);
  void MergeFrom(const EndTransactionRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(EndTransactionRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .cockroach.roachpb.Span header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::cockroach::roachpb::Span& header() const;
  ::cockroach::roachpb::Span* mutable_header();
  ::cockroach::roachpb::Span* release_header();
  void set_allocated_header(::cockroach::roachpb::Span* header);

  // optional bool commit = 2;
  bool has_commit() const;
  void clear_commit();
  static const int kCommitFieldNumber = 2;
  bool commit() const;
  void set_commit(bool value);

  // optional .cockroach.roachpb.Timestamp deadline = 3;
  bool has_deadline() const;
  void clear_deadline();
  static const int kDeadlineFieldNumber = 3;
  const ::cockroach::roachpb::Timestamp& deadline() const;
  ::cockroach::roachpb::Timestamp* mutable_deadline();
  ::cockroach::roachpb::Timestamp* release_deadline();
  void set_allocated_deadline(::cockroach::roachpb::Timestamp* deadline);

  // optional .cockroach.roachpb.InternalCommitTrigger internal_commit_trigger = 4;
  bool has_internal_commit_trigger() const;
  void clear_internal_commit_trigger();
  static const int kInternalCommitTriggerFieldNumber = 4;
  const ::cockroach::roachpb::InternalCommitTrigger& internal_commit_trigger() const;
  ::cockroach::roachpb::InternalCommitTrigger* mutable_internal_commit_trigger();
  ::cockroach::roachpb::InternalCommitTrigger* release_internal_commit_trigger();
  void set_allocated_internal_commit_trigger(::cockroach::roachpb::InternalCommitTrigger* internal_commit_trigger);

  // repeated .cockroach.roachpb.Span intent_spans = 5;
  int intent_spans_size() const;
  void clear_intent_spans();
  static const int kIntentSpansFieldNumber = 5;
  const ::cockroach::roachpb::Span& intent_spans(int index) const;
  ::cockroach::roachpb::Span* mutable_intent_spans(int index);
  ::cockroach::roachpb::Span* add_intent_spans();
  ::google::protobuf::RepeatedPtrField< ::cockroach::roachpb::Span >*
      mutable_intent_spans();
  const ::google::protobuf::RepeatedPtrField< ::cockroach::roachpb::Span >&
      intent_spans() const;

  // @@protoc_insertion_point(class_scope:cockroach.roachpb.EndTransactionRequest)
 private:
  inline void set_has_header();
  inline void clear_has_header();
  inline void set_has_commit();
  inline void clear_has_commit();
  inline void set_has_deadline();
  inline void clear_has_deadline();
  inline void set_has_internal_commit_trigger();
  inline void clear_has_internal_commit_trigger();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::cockroach::roachpb::Span* header_;
  ::cockroach::roachpb::Timestamp* deadline_;
  ::cockroach::roachpb::InternalCommitTrigger* internal_commit_trigger_;
  ::google::protobuf::RepeatedPtrField< ::cockroach::roachpb::Span > intent_spans_;
  bool commit_;
  friend void  protobuf_AddDesc_cockroach_2froachpb_2fapi_2eproto();
  friend void protobuf_AssignDesc_cockroach_2froachpb_2fapi_2eproto();
  friend void protobuf_ShutdownFile_cockroach_2froachpb_2fapi_2eproto();

  void InitAsDefaultInstance();
  static EndTransactionRequest* default_instance_;
};
// -------------------------------------------------------------------

class EndTransactionResponse : public ::google::protobuf::Message {
 public:
  EndTransactionResponse();
  virtual ~EndTransactionResponse();

  EndTransactionResponse(const EndTransactionResponse& from);

  inline EndTransactionResponse& operator=(const EndTransactionResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EndTransactionResponse& default_instance();

  void Swap(EndTransactionResponse* other);

  // implements Message ----------------------------------------------

  inline EndTransactionResponse* New() const { return New(NULL); }

  EndTransactionResponse* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const EndTransactionResponse& from);
  void MergeFrom(const EndTransactionResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(EndTransactionResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .cockroach.roachpb.ResponseHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::cockroach::roachpb::ResponseHeader& header() const;
  ::cockroach::roachpb::ResponseHeader* mutable_header();
  ::cockroach::roachpb::ResponseHeader* release_header();
  void set_allocated_header(::cockroach::roachpb::ResponseHeader* header);

  // optional int64 commit_wait = 2;
  bool has_commit_wait() const;
  void clear_commit_wait();
  static const int kCommitWaitFieldNumber = 2;
  ::google::protobuf::int64 commit_wait() const;
  void set_commit_wait(::google::protobuf::int64 value);

  // repeated bytes resolved = 3;
  int resolved_size() const;
  void clear_resolved();
  static const int kResolvedFieldNumber = 3;
  const ::std::string& resolved(int index) const;
  ::std::string* mutable_resolved(int index);
  void set_resolved(int index, const ::std::string& value);
  void set_resolved(int index, const char* value);
  void set_resolved(int index, const void* value, size_t size);
  ::std::string* add_resolved();
  void add_resolved(const ::std::string& value);
  void add_resolved(const char* value);
  void add_resolved(const void* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& resolved() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_resolved();

  // @@protoc_insertion_point(class_scope:cockroach.roachpb.EndTransactionResponse)
 private:
  inline void set_has_header();
  inline void clear_has_header();
  inline void set_has_commit_wait();
  inline void clear_has_commit_wait();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::cockroach::roachpb::ResponseHeader* header_;
  ::google::protobuf::int64 commit_wait_;
  ::google::protobuf::RepeatedPtrField< ::std::string> resolved_;
  friend void  protobuf_AddDesc_cockroach_2froachpb_2fapi_2eproto();
  friend void protobuf_AssignDesc_cockroach_2froachpb_2fapi_2eproto();
  friend void protobuf_ShutdownFile_cockroach_2froachpb_2fapi_2eproto();

  void InitAsDefaultInstance();
  static EndTransactionResponse* default_instance_;
};
// -------------------------------------------------------------------

class AdminSplitRequest : public ::google::protobuf::Message {
 public:
  AdminSplitRequest();
  virtual ~AdminSplitRequest();

  AdminSplitRequest(const AdminSplitRequest& from);

  inline AdminSplitRequest& operator=(const AdminSplitRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AdminSplitRequest& default_instance();

  void Swap(AdminSplitRequest* other);

  // implements Message ----------------------------------------------

  inline AdminSplitRequest* New() const { return New(NULL); }

  AdminSplitRequest* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AdminSplitRequest& from);
  void MergeFrom(const AdminSplitRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(AdminSplitRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .cockroach.roachpb.Span header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::cockroach::roachpb::Span& header() const;
  ::cockroach::roachpb::Span* mutable_header();
  ::cockroach::roachpb::Span* release_header();
  void set_allocated_header(::cockroach::roachpb::Span* header);

  // optional bytes split_key = 2;
  bool has_split_key() const;
  void clear_split_key();
  static const int kSplitKeyFieldNumber = 2;
  const ::std::string& split_key() const;
  void set_split_key(const ::std::string& value);
  void set_split_key(const char* value);
  void set_split_key(const void* value, size_t size);
  ::std::string* mutable_split_key();
  ::std::string* release_split_key();
  void set_allocated_split_key(::std::string* split_key);

  // @@protoc_insertion_point(class_scope:cockroach.roachpb.AdminSplitRequest)
 private:
  inline void set_has_header();
  inline void clear_has_header();
  inline void set_has_split_key();
  inline void clear_has_split_key();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::cockroach::roachpb::Span* header_;
  ::google::protobuf::internal::ArenaStringPtr split_key_;
  friend void  protobuf_AddDesc_cockroach_2froachpb_2fapi_2eproto();
  friend void protobuf_AssignDesc_cockroach_2froachpb_2fapi_2eproto();
  friend void protobuf_ShutdownFile_cockroach_2froachpb_2fapi_2eproto();

  void InitAsDefaultInstance();
  static AdminSplitRequest* default_instance_;
};
// -------------------------------------------------------------------

class AdminSplitResponse : public ::google::protobuf::Message {
 public:
  AdminSplitResponse();
  virtual ~AdminSplitResponse();

  AdminSplitResponse(const AdminSplitResponse& from);

  inline AdminSplitResponse& operator=(const AdminSplitResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AdminSplitResponse& default_instance();

  void Swap(AdminSplitResponse* other);

  // implements Message ----------------------------------------------

  inline AdminSplitResponse* New() const { return New(NULL); }

  AdminSplitResponse* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AdminSplitResponse& from);
  void MergeFrom(const AdminSplitResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(AdminSplitResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .cockroach.roachpb.ResponseHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::cockroach::roachpb::ResponseHeader& header() const;
  ::cockroach::roachpb::ResponseHeader* mutable_header();
  ::cockroach::roachpb::ResponseHeader* release_header();
  void set_allocated_header(::cockroach::roachpb::ResponseHeader* header);

  // @@protoc_insertion_point(class_scope:cockroach.roachpb.AdminSplitResponse)
 private:
  inline void set_has_header();
  inline void clear_has_header();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::cockroach::roachpb::ResponseHeader* header_;
  friend void  protobuf_AddDesc_cockroach_2froachpb_2fapi_2eproto();
  friend void protobuf_AssignDesc_cockroach_2froachpb_2fapi_2eproto();
  friend void protobuf_ShutdownFile_cockroach_2froachpb_2fapi_2eproto();

  void InitAsDefaultInstance();
  static AdminSplitResponse* default_instance_;
};
// -------------------------------------------------------------------

class AdminMergeRequest : public ::google::protobuf::Message {
 public:
  AdminMergeRequest();
  virtual ~AdminMergeRequest();

  AdminMergeRequest(const AdminMergeRequest& from);

  inline AdminMergeRequest& operator=(const AdminMergeRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AdminMergeRequest& default_instance();

  void Swap(AdminMergeRequest* other);

  // implements Message ----------------------------------------------

  inline AdminMergeRequest* New() const { return New(NULL); }

  AdminMergeRequest* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AdminMergeRequest& from);
  void MergeFrom(const AdminMergeRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(AdminMergeRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .cockroach.roachpb.Span header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::cockroach::roachpb::Span& header() const;
  ::cockroach::roachpb::Span* mutable_header();
  ::cockroach::roachpb::Span* release_header();
  void set_allocated_header(::cockroach::roachpb::Span* header);

  // @@protoc_insertion_point(class_scope:cockroach.roachpb.AdminMergeRequest)
 private:
  inline void set_has_header();
  inline void clear_has_header();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::cockroach::roachpb::Span* header_;
  friend void  protobuf_AddDesc_cockroach_2froachpb_2fapi_2eproto();
  friend void protobuf_AssignDesc_cockroach_2froachpb_2fapi_2eproto();
  friend void protobuf_ShutdownFile_cockroach_2froachpb_2fapi_2eproto();

  void InitAsDefaultInstance();
  static AdminMergeRequest* default_instance_;
};
// -------------------------------------------------------------------

class AdminMergeResponse : public ::google::protobuf::Message {
 public:
  AdminMergeResponse();
  virtual ~AdminMergeResponse();

  AdminMergeResponse(const AdminMergeResponse& from);

  inline AdminMergeResponse& operator=(const AdminMergeResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AdminMergeResponse& default_instance();

  void Swap(AdminMergeResponse* other);

  // implements Message ----------------------------------------------

  inline AdminMergeResponse* New() const { return New(NULL); }

  AdminMergeResponse* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AdminMergeResponse& from);
  void MergeFrom(const AdminMergeResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(AdminMergeResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .cockroach.roachpb.ResponseHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::cockroach::roachpb::ResponseHeader& header() const;
  ::cockroach::roachpb::ResponseHeader* mutable_header();
  ::cockroach::roachpb::ResponseHeader* release_header();
  void set_allocated_header(::cockroach::roachpb::ResponseHeader* header);

  // @@protoc_insertion_point(class_scope:cockroach.roachpb.AdminMergeResponse)
 private:
  inline void set_has_header();
  inline void clear_has_header();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::cockroach::roachpb::ResponseHeader* header_;
  friend void  protobuf_AddDesc_cockroach_2froachpb_2fapi_2eproto();
  friend void protobuf_AssignDesc_cockroach_2froachpb_2fapi_2eproto();
  friend void protobuf_ShutdownFile_cockroach_2froachpb_2fapi_2eproto();

  void InitAsDefaultInstance();
  static AdminMergeResponse* default_instance_;
};
// -------------------------------------------------------------------

class RangeLookupRequest : public ::google::protobuf::Message {
 public:
  RangeLookupRequest();
  virtual ~RangeLookupRequest();

  RangeLookupRequest(const RangeLookupRequest& from);

  inline RangeLookupRequest& operator=(const RangeLookupRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RangeLookupRequest& default_instance();

  void Swap(RangeLookupRequest* other);

  // implements Message ----------------------------------------------

  inline RangeLookupRequest* New() const { return New(NULL); }

  RangeLookupRequest* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RangeLookupRequest& from);
  void MergeFrom(const RangeLookupRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RangeLookupRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .cockroach.roachpb.Span header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::cockroach::roachpb::Span& header() const;
  ::cockroach::roachpb::Span* mutable_header();
  ::cockroach::roachpb::Span* release_header();
  void set_allocated_header(::cockroach::roachpb::Span* header);

  // optional int32 max_ranges = 2;
  bool has_max_ranges() const;
  void clear_max_ranges();
  static const int kMaxRangesFieldNumber = 2;
  ::google::protobuf::int32 max_ranges() const;
  void set_max_ranges(::google::protobuf::int32 value);

  // optional bool consider_intents = 3;
  bool has_consider_intents() const;
  void clear_consider_intents();
  static const int kConsiderIntentsFieldNumber = 3;
  bool consider_intents() const;
  void set_consider_intents(bool value);

  // optional bool reverse = 4;
  bool has_reverse() const;
  void clear_reverse();
  static const int kReverseFieldNumber = 4;
  bool reverse() const;
  void set_reverse(bool value);

  // @@protoc_insertion_point(class_scope:cockroach.roachpb.RangeLookupRequest)
 private:
  inline void set_has_header();
  inline void clear_has_header();
  inline void set_has_max_ranges();
  inline void clear_has_max_ranges();
  inline void set_has_consider_intents();
  inline void clear_has_consider_intents();
  inline void set_has_reverse();
  inline void clear_has_reverse();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::cockroach::roachpb::Span* header_;
  ::google::protobuf::int32 max_ranges_;
  bool consider_intents_;
  bool reverse_;
  friend void  protobuf_AddDesc_cockroach_2froachpb_2fapi_2eproto();
  friend void protobuf_AssignDesc_cockroach_2froachpb_2fapi_2eproto();
  friend void protobuf_ShutdownFile_cockroach_2froachpb_2fapi_2eproto();

  void InitAsDefaultInstance();
  static RangeLookupRequest* default_instance_;
};
// -------------------------------------------------------------------

class RangeLookupResponse : public ::google::protobuf::Message {
 public:
  RangeLookupResponse();
  virtual ~RangeLookupResponse();

  RangeLookupResponse(const RangeLookupResponse& from);

  inline RangeLookupResponse& operator=(const RangeLookupResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RangeLookupResponse& default_instance();

  void Swap(RangeLookupResponse* other);

  // implements Message ----------------------------------------------

  inline RangeLookupResponse* New() const { return New(NULL); }

  RangeLookupResponse* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RangeLookupResponse& from);
  void MergeFrom(const RangeLookupResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RangeLookupResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .cockroach.roachpb.ResponseHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::cockroach::roachpb::ResponseHeader& header() const;
  ::cockroach::roachpb::ResponseHeader* mutable_header();
  ::cockroach::roachpb::ResponseHeader* release_header();
  void set_allocated_header(::cockroach::roachpb::ResponseHeader* header);

  // repeated .cockroach.roachpb.RangeDescriptor ranges = 2;
  int ranges_size() const;
  void clear_ranges();
  static const int kRangesFieldNumber = 2;
  const ::cockroach::roachpb::RangeDescriptor& ranges(int index) const;
  ::cockroach::roachpb::RangeDescriptor* mutable_ranges(int index);
  ::cockroach::roachpb::RangeDescriptor* add_ranges();
  ::google::protobuf::RepeatedPtrField< ::cockroach::roachpb::RangeDescriptor >*
      mutable_ranges();
  const ::google::protobuf::RepeatedPtrField< ::cockroach::roachpb::RangeDescriptor >&
      ranges() const;

  // @@protoc_insertion_point(class_scope:cockroach.roachpb.RangeLookupResponse)
 private:
  inline void set_has_header();
  inline void clear_has_header();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::cockroach::roachpb::ResponseHeader* header_;
  ::google::protobuf::RepeatedPtrField< ::cockroach::roachpb::RangeDescriptor > ranges_;
  friend void  protobuf_AddDesc_cockroach_2froachpb_2fapi_2eproto();
  friend void protobuf_AssignDesc_cockroach_2froachpb_2fapi_2eproto();
  friend void protobuf_ShutdownFile_cockroach_2froachpb_2fapi_2eproto();

  void InitAsDefaultInstance();
  static RangeLookupResponse* default_instance_;
};
// -------------------------------------------------------------------

class HeartbeatTxnRequest : public ::google::protobuf::Message {
 public:
  HeartbeatTxnRequest();
  virtual ~HeartbeatTxnRequest();

  HeartbeatTxnRequest(const HeartbeatTxnRequest& from);

  inline HeartbeatTxnRequest& operator=(const HeartbeatTxnRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const HeartbeatTxnRequest& default_instance();

  void Swap(HeartbeatTxnRequest* other);

  // implements Message ----------------------------------------------

  inline HeartbeatTxnRequest* New() const { return New(NULL); }

  HeartbeatTxnRequest* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const HeartbeatTxnRequest& from);
  void MergeFrom(const HeartbeatTxnRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(HeartbeatTxnRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .cockroach.roachpb.Span header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::cockroach::roachpb::Span& header() const;
  ::cockroach::roachpb::Span* mutable_header();
  ::cockroach::roachpb::Span* release_header();
  void set_allocated_header(::cockroach::roachpb::Span* header);

  // optional .cockroach.roachpb.Timestamp now = 2;
  bool has_now() const;
  void clear_now();
  static const int kNowFieldNumber = 2;
  const ::cockroach::roachpb::Timestamp& now() const;
  ::cockroach::roachpb::Timestamp* mutable_now();
  ::cockroach::roachpb::Timestamp* release_now();
  void set_allocated_now(::cockroach::roachpb::Timestamp* now);

  // @@protoc_insertion_point(class_scope:cockroach.roachpb.HeartbeatTxnRequest)
 private:
  inline void set_has_header();
  inline void clear_has_header();
  inline void set_has_now();
  inline void clear_has_now();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::cockroach::roachpb::Span* header_;
  ::cockroach::roachpb::Timestamp* now_;
  friend void  protobuf_AddDesc_cockroach_2froachpb_2fapi_2eproto();
  friend void protobuf_AssignDesc_cockroach_2froachpb_2fapi_2eproto();
  friend void protobuf_ShutdownFile_cockroach_2froachpb_2fapi_2eproto();

  void InitAsDefaultInstance();
  static HeartbeatTxnRequest* default_instance_;
};
// -------------------------------------------------------------------

class HeartbeatTxnResponse : public ::google::protobuf::Message {
 public:
  HeartbeatTxnResponse();
  virtual ~HeartbeatTxnResponse();

  HeartbeatTxnResponse(const HeartbeatTxnResponse& from);

  inline HeartbeatTxnResponse& operator=(const HeartbeatTxnResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const HeartbeatTxnResponse& default_instance();

  void Swap(HeartbeatTxnResponse* other);

  // implements Message ----------------------------------------------

  inline HeartbeatTxnResponse* New() const { return New(NULL); }

  HeartbeatTxnResponse* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const HeartbeatTxnResponse& from);
  void MergeFrom(const HeartbeatTxnResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(HeartbeatTxnResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .cockroach.roachpb.ResponseHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::cockroach::roachpb::ResponseHeader& header() const;
  ::cockroach::roachpb::ResponseHeader* mutable_header();
  ::cockroach::roachpb::ResponseHeader* release_header();
  void set_allocated_header(::cockroach::roachpb::ResponseHeader* header);

  // @@protoc_insertion_point(class_scope:cockroach.roachpb.HeartbeatTxnResponse)
 private:
  inline void set_has_header();
  inline void clear_has_header();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::cockroach::roachpb::ResponseHeader* header_;
  friend void  protobuf_AddDesc_cockroach_2froachpb_2fapi_2eproto();
  friend void protobuf_AssignDesc_cockroach_2froachpb_2fapi_2eproto();
  friend void protobuf_ShutdownFile_cockroach_2froachpb_2fapi_2eproto();

  void InitAsDefaultInstance();
  static HeartbeatTxnResponse* default_instance_;
};
// -------------------------------------------------------------------

class GCRequest_GCKey : public ::google::protobuf::Message {
 public:
  GCRequest_GCKey();
  virtual ~GCRequest_GCKey();

  GCRequest_GCKey(const GCRequest_GCKey& from);

  inline GCRequest_GCKey& operator=(const GCRequest_GCKey& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GCRequest_GCKey& default_instance();

  void Swap(GCRequest_GCKey* other);

  // implements Message ----------------------------------------------

  inline GCRequest_GCKey* New() const { return New(NULL); }

  GCRequest_GCKey* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GCRequest_GCKey& from);
  void MergeFrom(const GCRequest_GCKey& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(GCRequest_GCKey* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes key = 1;
  bool has_key() const;
  void clear_key();
  static const int kKeyFieldNumber = 1;
  const ::std::string& key() const;
  void set_key(const ::std::string& value);
  void set_key(const char* value);
  void set_key(const void* value, size_t size);
  ::std::string* mutable_key();
  ::std::string* release_key();
  void set_allocated_key(::std::string* key);

  // optional .cockroach.roachpb.Timestamp timestamp = 2;
  bool has_timestamp() const;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 2;
  const ::cockroach::roachpb::Timestamp& timestamp() const;
  ::cockroach::roachpb::Timestamp* mutable_timestamp();
  ::cockroach::roachpb::Timestamp* release_timestamp();
  void set_allocated_timestamp(::cockroach::roachpb::Timestamp* timestamp);

  // @@protoc_insertion_point(class_scope:cockroach.roachpb.GCRequest.GCKey)
 private:
  inline void set_has_key();
  inline void clear_has_key();
  inline void set_has_timestamp();
  inline void clear_has_timestamp();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr key_;
  ::cockroach::roachpb::Timestamp* timestamp_;
  friend void  protobuf_AddDesc_cockroach_2froachpb_2fapi_2eproto();
  friend void protobuf_AssignDesc_cockroach_2froachpb_2fapi_2eproto();
  friend void protobuf_ShutdownFile_cockroach_2froachpb_2fapi_2eproto();

  void InitAsDefaultInstance();
  static GCRequest_GCKey* default_instance_;
};
// -------------------------------------------------------------------

class GCRequest : public ::google::protobuf::Message {
 public:
  GCRequest();
  virtual ~GCRequest();

  GCRequest(const GCRequest& from);

  inline GCRequest& operator=(const GCRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GCRequest& default_instance();

  void Swap(GCRequest* other);

  // implements Message ----------------------------------------------

  inline GCRequest* New() const { return New(NULL); }

  GCRequest* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GCRequest& from);
  void MergeFrom(const GCRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(GCRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef GCRequest_GCKey GCKey;

  // accessors -------------------------------------------------------

  // optional .cockroach.roachpb.Span header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::cockroach::roachpb::Span& header() const;
  ::cockroach::roachpb::Span* mutable_header();
  ::cockroach::roachpb::Span* release_header();
  void set_allocated_header(::cockroach::roachpb::Span* header);

  // repeated .cockroach.roachpb.GCRequest.GCKey keys = 3;
  int keys_size() const;
  void clear_keys();
  static const int kKeysFieldNumber = 3;
  const ::cockroach::roachpb::GCRequest_GCKey& keys(int index) const;
  ::cockroach::roachpb::GCRequest_GCKey* mutable_keys(int index);
  ::cockroach::roachpb::GCRequest_GCKey* add_keys();
  ::google::protobuf::RepeatedPtrField< ::cockroach::roachpb::GCRequest_GCKey >*
      mutable_keys();
  const ::google::protobuf::RepeatedPtrField< ::cockroach::roachpb::GCRequest_GCKey >&
      keys() const;

  // @@protoc_insertion_point(class_scope:cockroach.roachpb.GCRequest)
 private:
  inline void set_has_header();
  inline void clear_has_header();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::cockroach::roachpb::Span* header_;
  ::google::protobuf::RepeatedPtrField< ::cockroach::roachpb::GCRequest_GCKey > keys_;
  friend void  protobuf_AddDesc_cockroach_2froachpb_2fapi_2eproto();
  friend void protobuf_AssignDesc_cockroach_2froachpb_2fapi_2eproto();
  friend void protobuf_ShutdownFile_cockroach_2froachpb_2fapi_2eproto();

  void InitAsDefaultInstance();
  static GCRequest* default_instance_;
};
// -------------------------------------------------------------------

class GCResponse : public ::google::protobuf::Message {
 public:
  GCResponse();
  virtual ~GCResponse();

  GCResponse(const GCResponse& from);

  inline GCResponse& operator=(const GCResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GCResponse& default_instance();

  void Swap(GCResponse* other);

  // implements Message ----------------------------------------------

  inline GCResponse* New() const { return New(NULL); }

  GCResponse* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GCResponse& from);
  void MergeFrom(const GCResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(GCResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .cockroach.roachpb.ResponseHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::cockroach::roachpb::ResponseHeader& header() const;
  ::cockroach::roachpb::ResponseHeader* mutable_header();
  ::cockroach::roachpb::ResponseHeader* release_header();
  void set_allocated_header(::cockroach::roachpb::ResponseHeader* header);

  // @@protoc_insertion_point(class_scope:cockroach.roachpb.GCResponse)
 private:
  inline void set_has_header();
  inline void clear_has_header();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::cockroach::roachpb::ResponseHeader* header_;
  friend void  protobuf_AddDesc_cockroach_2froachpb_2fapi_2eproto();
  friend void protobuf_AssignDesc_cockroach_2froachpb_2fapi_2eproto();
  friend void protobuf_ShutdownFile_cockroach_2froachpb_2fapi_2eproto();

  void InitAsDefaultInstance();
  static GCResponse* default_instance_;
};
// -------------------------------------------------------------------

class PushTxnRequest : public ::google::protobuf::Message {
 public:
  PushTxnRequest();
  virtual ~PushTxnRequest();

  PushTxnRequest(const PushTxnRequest& from);

  inline PushTxnRequest& operator=(const PushTxnRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PushTxnRequest& default_instance();

  void Swap(PushTxnRequest* other);

  // implements Message ----------------------------------------------

  inline PushTxnRequest* New() const { return New(NULL); }

  PushTxnRequest* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PushTxnRequest& from);
  void MergeFrom(const PushTxnRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(PushTxnRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .cockroach.roachpb.Span header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::cockroach::roachpb::Span& header() const;
  ::cockroach::roachpb::Span* mutable_header();
  ::cockroach::roachpb::Span* release_header();
  void set_allocated_header(::cockroach::roachpb::Span* header);

  // optional .cockroach.roachpb.Transaction pusher_txn = 2;
  bool has_pusher_txn() const;
  void clear_pusher_txn();
  static const int kPusherTxnFieldNumber = 2;
  const ::cockroach::roachpb::Transaction& pusher_txn() const;
  ::cockroach::roachpb::Transaction* mutable_pusher_txn();
  ::cockroach::roachpb::Transaction* release_pusher_txn();
  void set_allocated_pusher_txn(::cockroach::roachpb::Transaction* pusher_txn);

  // optional .cockroach.roachpb.TxnMeta pushee_txn = 3;
  bool has_pushee_txn() const;
  void clear_pushee_txn();
  static const int kPusheeTxnFieldNumber = 3;
  const ::cockroach::roachpb::TxnMeta& pushee_txn() const;
  ::cockroach::roachpb::TxnMeta* mutable_pushee_txn();
  ::cockroach::roachpb::TxnMeta* release_pushee_txn();
  void set_allocated_pushee_txn(::cockroach::roachpb::TxnMeta* pushee_txn);

  // optional .cockroach.roachpb.Timestamp push_to = 4;
  bool has_push_to() const;
  void clear_push_to();
  static const int kPushToFieldNumber = 4;
  const ::cockroach::roachpb::Timestamp& push_to() const;
  ::cockroach::roachpb::Timestamp* mutable_push_to();
  ::cockroach::roachpb::Timestamp* release_push_to();
  void set_allocated_push_to(::cockroach::roachpb::Timestamp* push_to);

  // optional .cockroach.roachpb.Timestamp now = 5;
  bool has_now() const;
  void clear_now();
  static const int kNowFieldNumber = 5;
  const ::cockroach::roachpb::Timestamp& now() const;
  ::cockroach::roachpb::Timestamp* mutable_now();
  ::cockroach::roachpb::Timestamp* release_now();
  void set_allocated_now(::cockroach::roachpb::Timestamp* now);

  // optional .cockroach.roachpb.PushTxnType push_type = 6;
  bool has_push_type() const;
  void clear_push_type();
  static const int kPushTypeFieldNumber = 6;
  ::cockroach::roachpb::PushTxnType push_type() const;
  void set_push_type(::cockroach::roachpb::PushTxnType value);

  // @@protoc_insertion_point(class_scope:cockroach.roachpb.PushTxnRequest)
 private:
  inline void set_has_header();
  inline void clear_has_header();
  inline void set_has_pusher_txn();
  inline void clear_has_pusher_txn();
  inline void set_has_pushee_txn();
  inline void clear_has_pushee_txn();
  inline void set_has_push_to();
  inline void clear_has_push_to();
  inline void set_has_now();
  inline void clear_has_now();
  inline void set_has_push_type();
  inline void clear_has_push_type();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::cockroach::roachpb::Span* header_;
  ::cockroach::roachpb::Transaction* pusher_txn_;
  ::cockroach::roachpb::TxnMeta* pushee_txn_;
  ::cockroach::roachpb::Timestamp* push_to_;
  ::cockroach::roachpb::Timestamp* now_;
  int push_type_;
  friend void  protobuf_AddDesc_cockroach_2froachpb_2fapi_2eproto();
  friend void protobuf_AssignDesc_cockroach_2froachpb_2fapi_2eproto();
  friend void protobuf_ShutdownFile_cockroach_2froachpb_2fapi_2eproto();

  void InitAsDefaultInstance();
  static PushTxnRequest* default_instance_;
};
// -------------------------------------------------------------------

class PushTxnResponse : public ::google::protobuf::Message {
 public:
  PushTxnResponse();
  virtual ~PushTxnResponse();

  PushTxnResponse(const PushTxnResponse& from);

  inline PushTxnResponse& operator=(const PushTxnResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PushTxnResponse& default_instance();

  void Swap(PushTxnResponse* other);

  // implements Message ----------------------------------------------

  inline PushTxnResponse* New() const { return New(NULL); }

  PushTxnResponse* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PushTxnResponse& from);
  void MergeFrom(const PushTxnResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(PushTxnResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .cockroach.roachpb.ResponseHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::cockroach::roachpb::ResponseHeader& header() const;
  ::cockroach::roachpb::ResponseHeader* mutable_header();
  ::cockroach::roachpb::ResponseHeader* release_header();
  void set_allocated_header(::cockroach::roachpb::ResponseHeader* header);

  // optional .cockroach.roachpb.Transaction pushee_txn = 2;
  bool has_pushee_txn() const;
  void clear_pushee_txn();
  static const int kPusheeTxnFieldNumber = 2;
  const ::cockroach::roachpb::Transaction& pushee_txn() const;
  ::cockroach::roachpb::Transaction* mutable_pushee_txn();
  ::cockroach::roachpb::Transaction* release_pushee_txn();
  void set_allocated_pushee_txn(::cockroach::roachpb::Transaction* pushee_txn);

  // @@protoc_insertion_point(class_scope:cockroach.roachpb.PushTxnResponse)
 private:
  inline void set_has_header();
  inline void clear_has_header();
  inline void set_has_pushee_txn();
  inline void clear_has_pushee_txn();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::cockroach::roachpb::ResponseHeader* header_;
  ::cockroach::roachpb::Transaction* pushee_txn_;
  friend void  protobuf_AddDesc_cockroach_2froachpb_2fapi_2eproto();
  friend void protobuf_AssignDesc_cockroach_2froachpb_2fapi_2eproto();
  friend void protobuf_ShutdownFile_cockroach_2froachpb_2fapi_2eproto();

  void InitAsDefaultInstance();
  static PushTxnResponse* default_instance_;
};
// -------------------------------------------------------------------

class ResolveIntentRequest : public ::google::protobuf::Message {
 public:
  ResolveIntentRequest();
  virtual ~ResolveIntentRequest();

  ResolveIntentRequest(const ResolveIntentRequest& from);

  inline ResolveIntentRequest& operator=(const ResolveIntentRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ResolveIntentRequest& default_instance();

  void Swap(ResolveIntentRequest* other);

  // implements Message ----------------------------------------------

  inline ResolveIntentRequest* New() const { return New(NULL); }

  ResolveIntentRequest* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ResolveIntentRequest& from);
  void MergeFrom(const ResolveIntentRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ResolveIntentRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .cockroach.roachpb.Span header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::cockroach::roachpb::Span& header() const;
  ::cockroach::roachpb::Span* mutable_header();
  ::cockroach::roachpb::Span* release_header();
  void set_allocated_header(::cockroach::roachpb::Span* header);

  // optional .cockroach.roachpb.TxnMeta intent_txn = 2;
  bool has_intent_txn() const;
  void clear_intent_txn();
  static const int kIntentTxnFieldNumber = 2;
  const ::cockroach::roachpb::TxnMeta& intent_txn() const;
  ::cockroach::roachpb::TxnMeta* mutable_intent_txn();
  ::cockroach::roachpb::TxnMeta* release_intent_txn();
  void set_allocated_intent_txn(::cockroach::roachpb::TxnMeta* intent_txn);

  // optional .cockroach.roachpb.TransactionStatus status = 3;
  bool has_status() const;
  void clear_status();
  static const int kStatusFieldNumber = 3;
  ::cockroach::roachpb::TransactionStatus status() const;
  void set_status(::cockroach::roachpb::TransactionStatus value);

  // optional bool poison = 4;
  bool has_poison() const;
  void clear_poison();
  static const int kPoisonFieldNumber = 4;
  bool poison() const;
  void set_poison(bool value);

  // @@protoc_insertion_point(class_scope:cockroach.roachpb.ResolveIntentRequest)
 private:
  inline void set_has_header();
  inline void clear_has_header();
  inline void set_has_intent_txn();
  inline void clear_has_intent_txn();
  inline void set_has_status();
  inline void clear_has_status();
  inline void set_has_poison();
  inline void clear_has_poison();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::cockroach::roachpb::Span* header_;
  ::cockroach::roachpb::TxnMeta* intent_txn_;
  int status_;
  bool poison_;
  friend void  protobuf_AddDesc_cockroach_2froachpb_2fapi_2eproto();
  friend void protobuf_AssignDesc_cockroach_2froachpb_2fapi_2eproto();
  friend void protobuf_ShutdownFile_cockroach_2froachpb_2fapi_2eproto();

  void InitAsDefaultInstance();
  static ResolveIntentRequest* default_instance_;
};
// -------------------------------------------------------------------

class ResolveIntentResponse : public ::google::protobuf::Message {
 public:
  ResolveIntentResponse();
  virtual ~ResolveIntentResponse();

  ResolveIntentResponse(const ResolveIntentResponse& from);

  inline ResolveIntentResponse& operator=(const ResolveIntentResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ResolveIntentResponse& default_instance();

  void Swap(ResolveIntentResponse* other);

  // implements Message ----------------------------------------------

  inline ResolveIntentResponse* New() const { return New(NULL); }

  ResolveIntentResponse* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ResolveIntentResponse& from);
  void MergeFrom(const ResolveIntentResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ResolveIntentResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .cockroach.roachpb.ResponseHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::cockroach::roachpb::ResponseHeader& header() const;
  ::cockroach::roachpb::ResponseHeader* mutable_header();
  ::cockroach::roachpb::ResponseHeader* release_header();
  void set_allocated_header(::cockroach::roachpb::ResponseHeader* header);

  // @@protoc_insertion_point(class_scope:cockroach.roachpb.ResolveIntentResponse)
 private:
  inline void set_has_header();
  inline void clear_has_header();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::cockroach::roachpb::ResponseHeader* header_;
  friend void  protobuf_AddDesc_cockroach_2froachpb_2fapi_2eproto();
  friend void protobuf_AssignDesc_cockroach_2froachpb_2fapi_2eproto();
  friend void protobuf_ShutdownFile_cockroach_2froachpb_2fapi_2eproto();

  void InitAsDefaultInstance();
  static ResolveIntentResponse* default_instance_;
};
// -------------------------------------------------------------------

class ResolveIntentRangeRequest : public ::google::protobuf::Message {
 public:
  ResolveIntentRangeRequest();
  virtual ~ResolveIntentRangeRequest();

  ResolveIntentRangeRequest(const ResolveIntentRangeRequest& from);

  inline ResolveIntentRangeRequest& operator=(const ResolveIntentRangeRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ResolveIntentRangeRequest& default_instance();

  void Swap(ResolveIntentRangeRequest* other);

  // implements Message ----------------------------------------------

  inline ResolveIntentRangeRequest* New() const { return New(NULL); }

  ResolveIntentRangeRequest* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ResolveIntentRangeRequest& from);
  void MergeFrom(const ResolveIntentRangeRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ResolveIntentRangeRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .cockroach.roachpb.Span header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::cockroach::roachpb::Span& header() const;
  ::cockroach::roachpb::Span* mutable_header();
  ::cockroach::roachpb::Span* release_header();
  void set_allocated_header(::cockroach::roachpb::Span* header);

  // optional .cockroach.roachpb.TxnMeta intent_txn = 2;
  bool has_intent_txn() const;
  void clear_intent_txn();
  static const int kIntentTxnFieldNumber = 2;
  const ::cockroach::roachpb::TxnMeta& intent_txn() const;
  ::cockroach::roachpb::TxnMeta* mutable_intent_txn();
  ::cockroach::roachpb::TxnMeta* release_intent_txn();
  void set_allocated_intent_txn(::cockroach::roachpb::TxnMeta* intent_txn);

  // optional .cockroach.roachpb.TransactionStatus status = 3;
  bool has_status() const;
  void clear_status();
  static const int kStatusFieldNumber = 3;
  ::cockroach::roachpb::TransactionStatus status() const;
  void set_status(::cockroach::roachpb::TransactionStatus value);

  // optional bool poison = 4;
  bool has_poison() const;
  void clear_poison();
  static const int kPoisonFieldNumber = 4;
  bool poison() const;
  void set_poison(bool value);

  // @@protoc_insertion_point(class_scope:cockroach.roachpb.ResolveIntentRangeRequest)
 private:
  inline void set_has_header();
  inline void clear_has_header();
  inline void set_has_intent_txn();
  inline void clear_has_intent_txn();
  inline void set_has_status();
  inline void clear_has_status();
  inline void set_has_poison();
  inline void clear_has_poison();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::cockroach::roachpb::Span* header_;
  ::cockroach::roachpb::TxnMeta* intent_txn_;
  int status_;
  bool poison_;
  friend void  protobuf_AddDesc_cockroach_2froachpb_2fapi_2eproto();
  friend void protobuf_AssignDesc_cockroach_2froachpb_2fapi_2eproto();
  friend void protobuf_ShutdownFile_cockroach_2froachpb_2fapi_2eproto();

  void InitAsDefaultInstance();
  static ResolveIntentRangeRequest* default_instance_;
};
// -------------------------------------------------------------------

class NoopResponse : public ::google::protobuf::Message {
 public:
  NoopResponse();
  virtual ~NoopResponse();

  NoopResponse(const NoopResponse& from);

  inline NoopResponse& operator=(const NoopResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NoopResponse& default_instance();

  void Swap(NoopResponse* other);

  // implements Message ----------------------------------------------

  inline NoopResponse* New() const { return New(NULL); }

  NoopResponse* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const NoopResponse& from);
  void MergeFrom(const NoopResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(NoopResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:cockroach.roachpb.NoopResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_cockroach_2froachpb_2fapi_2eproto();
  friend void protobuf_AssignDesc_cockroach_2froachpb_2fapi_2eproto();
  friend void protobuf_ShutdownFile_cockroach_2froachpb_2fapi_2eproto();

  void InitAsDefaultInstance();
  static NoopResponse* default_instance_;
};
// -------------------------------------------------------------------

class NoopRequest : public ::google::protobuf::Message {
 public:
  NoopRequest();
  virtual ~NoopRequest();

  NoopRequest(const NoopRequest& from);

  inline NoopRequest& operator=(const NoopRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NoopRequest& default_instance();

  void Swap(NoopRequest* other);

  // implements Message ----------------------------------------------

  inline NoopRequest* New() const { return New(NULL); }

  NoopRequest* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const NoopRequest& from);
  void MergeFrom(const NoopRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(NoopRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:cockroach.roachpb.NoopRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_cockroach_2froachpb_2fapi_2eproto();
  friend void protobuf_AssignDesc_cockroach_2froachpb_2fapi_2eproto();
  friend void protobuf_ShutdownFile_cockroach_2froachpb_2fapi_2eproto();

  void InitAsDefaultInstance();
  static NoopRequest* default_instance_;
};
// -------------------------------------------------------------------

class ResolveIntentRangeResponse : public ::google::protobuf::Message {
 public:
  ResolveIntentRangeResponse();
  virtual ~ResolveIntentRangeResponse();

  ResolveIntentRangeResponse(const ResolveIntentRangeResponse& from);

  inline ResolveIntentRangeResponse& operator=(const ResolveIntentRangeResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ResolveIntentRangeResponse& default_instance();

  void Swap(ResolveIntentRangeResponse* other);

  // implements Message ----------------------------------------------

  inline ResolveIntentRangeResponse* New() const { return New(NULL); }

  ResolveIntentRangeResponse* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ResolveIntentRangeResponse& from);
  void MergeFrom(const ResolveIntentRangeResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ResolveIntentRangeResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .cockroach.roachpb.ResponseHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::cockroach::roachpb::ResponseHeader& header() const;
  ::cockroach::roachpb::ResponseHeader* mutable_header();
  ::cockroach::roachpb::ResponseHeader* release_header();
  void set_allocated_header(::cockroach::roachpb::ResponseHeader* header);

  // @@protoc_insertion_point(class_scope:cockroach.roachpb.ResolveIntentRangeResponse)
 private:
  inline void set_has_header();
  inline void clear_has_header();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::cockroach::roachpb::ResponseHeader* header_;
  friend void  protobuf_AddDesc_cockroach_2froachpb_2fapi_2eproto();
  friend void protobuf_AssignDesc_cockroach_2froachpb_2fapi_2eproto();
  friend void protobuf_ShutdownFile_cockroach_2froachpb_2fapi_2eproto();

  void InitAsDefaultInstance();
  static ResolveIntentRangeResponse* default_instance_;
};
// -------------------------------------------------------------------

class MergeRequest : public ::google::protobuf::Message {
 public:
  MergeRequest();
  virtual ~MergeRequest();

  MergeRequest(const MergeRequest& from);

  inline MergeRequest& operator=(const MergeRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MergeRequest& default_instance();

  void Swap(MergeRequest* other);

  // implements Message ----------------------------------------------

  inline MergeRequest* New() const { return New(NULL); }

  MergeRequest* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MergeRequest& from);
  void MergeFrom(const MergeRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(MergeRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .cockroach.roachpb.Span header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::cockroach::roachpb::Span& header() const;
  ::cockroach::roachpb::Span* mutable_header();
  ::cockroach::roachpb::Span* release_header();
  void set_allocated_header(::cockroach::roachpb::Span* header);

  // optional .cockroach.roachpb.Value value = 2;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 2;
  const ::cockroach::roachpb::Value& value() const;
  ::cockroach::roachpb::Value* mutable_value();
  ::cockroach::roachpb::Value* release_value();
  void set_allocated_value(::cockroach::roachpb::Value* value);

  // @@protoc_insertion_point(class_scope:cockroach.roachpb.MergeRequest)
 private:
  inline void set_has_header();
  inline void clear_has_header();
  inline void set_has_value();
  inline void clear_has_value();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::cockroach::roachpb::Span* header_;
  ::cockroach::roachpb::Value* value_;
  friend void  protobuf_AddDesc_cockroach_2froachpb_2fapi_2eproto();
  friend void protobuf_AssignDesc_cockroach_2froachpb_2fapi_2eproto();
  friend void protobuf_ShutdownFile_cockroach_2froachpb_2fapi_2eproto();

  void InitAsDefaultInstance();
  static MergeRequest* default_instance_;
};
// -------------------------------------------------------------------

class MergeResponse : public ::google::protobuf::Message {
 public:
  MergeResponse();
  virtual ~MergeResponse();

  MergeResponse(const MergeResponse& from);

  inline MergeResponse& operator=(const MergeResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MergeResponse& default_instance();

  void Swap(MergeResponse* other);

  // implements Message ----------------------------------------------

  inline MergeResponse* New() const { return New(NULL); }

  MergeResponse* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MergeResponse& from);
  void MergeFrom(const MergeResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(MergeResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .cockroach.roachpb.ResponseHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::cockroach::roachpb::ResponseHeader& header() const;
  ::cockroach::roachpb::ResponseHeader* mutable_header();
  ::cockroach::roachpb::ResponseHeader* release_header();
  void set_allocated_header(::cockroach::roachpb::ResponseHeader* header);

  // @@protoc_insertion_point(class_scope:cockroach.roachpb.MergeResponse)
 private:
  inline void set_has_header();
  inline void clear_has_header();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::cockroach::roachpb::ResponseHeader* header_;
  friend void  protobuf_AddDesc_cockroach_2froachpb_2fapi_2eproto();
  friend void protobuf_AssignDesc_cockroach_2froachpb_2fapi_2eproto();
  friend void protobuf_ShutdownFile_cockroach_2froachpb_2fapi_2eproto();

  void InitAsDefaultInstance();
  static MergeResponse* default_instance_;
};
// -------------------------------------------------------------------

class TruncateLogRequest : public ::google::protobuf::Message {
 public:
  TruncateLogRequest();
  virtual ~TruncateLogRequest();

  TruncateLogRequest(const TruncateLogRequest& from);

  inline TruncateLogRequest& operator=(const TruncateLogRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TruncateLogRequest& default_instance();

  void Swap(TruncateLogRequest* other);

  // implements Message ----------------------------------------------

  inline TruncateLogRequest* New() const { return New(NULL); }

  TruncateLogRequest* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TruncateLogRequest& from);
  void MergeFrom(const TruncateLogRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TruncateLogRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .cockroach.roachpb.Span header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::cockroach::roachpb::Span& header() const;
  ::cockroach::roachpb::Span* mutable_header();
  ::cockroach::roachpb::Span* release_header();
  void set_allocated_header(::cockroach::roachpb::Span* header);

  // optional uint64 index = 2;
  bool has_index() const;
  void clear_index();
  static const int kIndexFieldNumber = 2;
  ::google::protobuf::uint64 index() const;
  void set_index(::google::protobuf::uint64 value);

  // optional int64 range_id = 3;
  bool has_range_id() const;
  void clear_range_id();
  static const int kRangeIdFieldNumber = 3;
  ::google::protobuf::int64 range_id() const;
  void set_range_id(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:cockroach.roachpb.TruncateLogRequest)
 private:
  inline void set_has_header();
  inline void clear_has_header();
  inline void set_has_index();
  inline void clear_has_index();
  inline void set_has_range_id();
  inline void clear_has_range_id();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::cockroach::roachpb::Span* header_;
  ::google::protobuf::uint64 index_;
  ::google::protobuf::int64 range_id_;
  friend void  protobuf_AddDesc_cockroach_2froachpb_2fapi_2eproto();
  friend void protobuf_AssignDesc_cockroach_2froachpb_2fapi_2eproto();
  friend void protobuf_ShutdownFile_cockroach_2froachpb_2fapi_2eproto();

  void InitAsDefaultInstance();
  static TruncateLogRequest* default_instance_;
};
// -------------------------------------------------------------------

class TruncateLogResponse : public ::google::protobuf::Message {
 public:
  TruncateLogResponse();
  virtual ~TruncateLogResponse();

  TruncateLogResponse(const TruncateLogResponse& from);

  inline TruncateLogResponse& operator=(const TruncateLogResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TruncateLogResponse& default_instance();

  void Swap(TruncateLogResponse* other);

  // implements Message ----------------------------------------------

  inline TruncateLogResponse* New() const { return New(NULL); }

  TruncateLogResponse* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TruncateLogResponse& from);
  void MergeFrom(const TruncateLogResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TruncateLogResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .cockroach.roachpb.ResponseHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::cockroach::roachpb::ResponseHeader& header() const;
  ::cockroach::roachpb::ResponseHeader* mutable_header();
  ::cockroach::roachpb::ResponseHeader* release_header();
  void set_allocated_header(::cockroach::roachpb::ResponseHeader* header);

  // @@protoc_insertion_point(class_scope:cockroach.roachpb.TruncateLogResponse)
 private:
  inline void set_has_header();
  inline void clear_has_header();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::cockroach::roachpb::ResponseHeader* header_;
  friend void  protobuf_AddDesc_cockroach_2froachpb_2fapi_2eproto();
  friend void protobuf_AssignDesc_cockroach_2froachpb_2fapi_2eproto();
  friend void protobuf_ShutdownFile_cockroach_2froachpb_2fapi_2eproto();

  void InitAsDefaultInstance();
  static TruncateLogResponse* default_instance_;
};
// -------------------------------------------------------------------

class LeaderLeaseRequest : public ::google::protobuf::Message {
 public:
  LeaderLeaseRequest();
  virtual ~LeaderLeaseRequest();

  LeaderLeaseRequest(const LeaderLeaseRequest& from);

  inline LeaderLeaseRequest& operator=(const LeaderLeaseRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LeaderLeaseRequest& default_instance();

  void Swap(LeaderLeaseRequest* other);

  // implements Message ----------------------------------------------

  inline LeaderLeaseRequest* New() const { return New(NULL); }

  LeaderLeaseRequest* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LeaderLeaseRequest& from);
  void MergeFrom(const LeaderLeaseRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(LeaderLeaseRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .cockroach.roachpb.Span header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::cockroach::roachpb::Span& header() const;
  ::cockroach::roachpb::Span* mutable_header();
  ::cockroach::roachpb::Span* release_header();
  void set_allocated_header(::cockroach::roachpb::Span* header);

  // optional .cockroach.roachpb.Lease lease = 2;
  bool has_lease() const;
  void clear_lease();
  static const int kLeaseFieldNumber = 2;
  const ::cockroach::roachpb::Lease& lease() const;
  ::cockroach::roachpb::Lease* mutable_lease();
  ::cockroach::roachpb::Lease* release_lease();
  void set_allocated_lease(::cockroach::roachpb::Lease* lease);

  // @@protoc_insertion_point(class_scope:cockroach.roachpb.LeaderLeaseRequest)
 private:
  inline void set_has_header();
  inline void clear_has_header();
  inline void set_has_lease();
  inline void clear_has_lease();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::cockroach::roachpb::Span* header_;
  ::cockroach::roachpb::Lease* lease_;
  friend void  protobuf_AddDesc_cockroach_2froachpb_2fapi_2eproto();
  friend void protobuf_AssignDesc_cockroach_2froachpb_2fapi_2eproto();
  friend void protobuf_ShutdownFile_cockroach_2froachpb_2fapi_2eproto();

  void InitAsDefaultInstance();
  static LeaderLeaseRequest* default_instance_;
};
// -------------------------------------------------------------------

class LeaderLeaseResponse : public ::google::protobuf::Message {
 public:
  LeaderLeaseResponse();
  virtual ~LeaderLeaseResponse();

  LeaderLeaseResponse(const LeaderLeaseResponse& from);

  inline LeaderLeaseResponse& operator=(const LeaderLeaseResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LeaderLeaseResponse& default_instance();

  void Swap(LeaderLeaseResponse* other);

  // implements Message ----------------------------------------------

  inline LeaderLeaseResponse* New() const { return New(NULL); }

  LeaderLeaseResponse* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LeaderLeaseResponse& from);
  void MergeFrom(const LeaderLeaseResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(LeaderLeaseResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .cockroach.roachpb.ResponseHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::cockroach::roachpb::ResponseHeader& header() const;
  ::cockroach::roachpb::ResponseHeader* mutable_header();
  ::cockroach::roachpb::ResponseHeader* release_header();
  void set_allocated_header(::cockroach::roachpb::ResponseHeader* header);

  // @@protoc_insertion_point(class_scope:cockroach.roachpb.LeaderLeaseResponse)
 private:
  inline void set_has_header();
  inline void clear_has_header();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::cockroach::roachpb::ResponseHeader* header_;
  friend void  protobuf_AddDesc_cockroach_2froachpb_2fapi_2eproto();
  friend void protobuf_AssignDesc_cockroach_2froachpb_2fapi_2eproto();
  friend void protobuf_ShutdownFile_cockroach_2froachpb_2fapi_2eproto();

  void InitAsDefaultInstance();
  static LeaderLeaseResponse* default_instance_;
};
// -------------------------------------------------------------------

class ComputeChecksumRequest : public ::google::protobuf::Message {
 public:
  ComputeChecksumRequest();
  virtual ~ComputeChecksumRequest();

  ComputeChecksumRequest(const ComputeChecksumRequest& from);

  inline ComputeChecksumRequest& operator=(const ComputeChecksumRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ComputeChecksumRequest& default_instance();

  void Swap(ComputeChecksumRequest* other);

  // implements Message ----------------------------------------------

  inline ComputeChecksumRequest* New() const { return New(NULL); }

  ComputeChecksumRequest* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ComputeChecksumRequest& from);
  void MergeFrom(const ComputeChecksumRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ComputeChecksumRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .cockroach.roachpb.Span header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::cockroach::roachpb::Span& header() const;
  ::cockroach::roachpb::Span* mutable_header();
  ::cockroach::roachpb::Span* release_header();
  void set_allocated_header(::cockroach::roachpb::Span* header);

  // optional uint32 version = 2;
  bool has_version() const;
  void clear_version();
  static const int kVersionFieldNumber = 2;
  ::google::protobuf::uint32 version() const;
  void set_version(::google::protobuf::uint32 value);

  // optional bytes checksum_id = 3;
  bool has_checksum_id() const;
  void clear_checksum_id();
  static const int kChecksumIdFieldNumber = 3;
  const ::std::string& checksum_id() const;
  void set_checksum_id(const ::std::string& value);
  void set_checksum_id(const char* value);
  void set_checksum_id(const void* value, size_t size);
  ::std::string* mutable_checksum_id();
  ::std::string* release_checksum_id();
  void set_allocated_checksum_id(::std::string* checksum_id);

  // @@protoc_insertion_point(class_scope:cockroach.roachpb.ComputeChecksumRequest)
 private:
  inline void set_has_header();
  inline void clear_has_header();
  inline void set_has_version();
  inline void clear_has_version();
  inline void set_has_checksum_id();
  inline void clear_has_checksum_id();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::cockroach::roachpb::Span* header_;
  ::google::protobuf::internal::ArenaStringPtr checksum_id_;
  ::google::protobuf::uint32 version_;
  friend void  protobuf_AddDesc_cockroach_2froachpb_2fapi_2eproto();
  friend void protobuf_AssignDesc_cockroach_2froachpb_2fapi_2eproto();
  friend void protobuf_ShutdownFile_cockroach_2froachpb_2fapi_2eproto();

  void InitAsDefaultInstance();
  static ComputeChecksumRequest* default_instance_;
};
// -------------------------------------------------------------------

class ComputeChecksumResponse : public ::google::protobuf::Message {
 public:
  ComputeChecksumResponse();
  virtual ~ComputeChecksumResponse();

  ComputeChecksumResponse(const ComputeChecksumResponse& from);

  inline ComputeChecksumResponse& operator=(const ComputeChecksumResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ComputeChecksumResponse& default_instance();

  void Swap(ComputeChecksumResponse* other);

  // implements Message ----------------------------------------------

  inline ComputeChecksumResponse* New() const { return New(NULL); }

  ComputeChecksumResponse* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ComputeChecksumResponse& from);
  void MergeFrom(const ComputeChecksumResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ComputeChecksumResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .cockroach.roachpb.ResponseHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::cockroach::roachpb::ResponseHeader& header() const;
  ::cockroach::roachpb::ResponseHeader* mutable_header();
  ::cockroach::roachpb::ResponseHeader* release_header();
  void set_allocated_header(::cockroach::roachpb::ResponseHeader* header);

  // @@protoc_insertion_point(class_scope:cockroach.roachpb.ComputeChecksumResponse)
 private:
  inline void set_has_header();
  inline void clear_has_header();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::cockroach::roachpb::ResponseHeader* header_;
  friend void  protobuf_AddDesc_cockroach_2froachpb_2fapi_2eproto();
  friend void protobuf_AssignDesc_cockroach_2froachpb_2fapi_2eproto();
  friend void protobuf_ShutdownFile_cockroach_2froachpb_2fapi_2eproto();

  void InitAsDefaultInstance();
  static ComputeChecksumResponse* default_instance_;
};
// -------------------------------------------------------------------

class VerifyChecksumRequest : public ::google::protobuf::Message {
 public:
  VerifyChecksumRequest();
  virtual ~VerifyChecksumRequest();

  VerifyChecksumRequest(const VerifyChecksumRequest& from);

  inline VerifyChecksumRequest& operator=(const VerifyChecksumRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const VerifyChecksumRequest& default_instance();

  void Swap(VerifyChecksumRequest* other);

  // implements Message ----------------------------------------------

  inline VerifyChecksumRequest* New() const { return New(NULL); }

  VerifyChecksumRequest* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const VerifyChecksumRequest& from);
  void MergeFrom(const VerifyChecksumRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(VerifyChecksumRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .cockroach.roachpb.Span header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::cockroach::roachpb::Span& header() const;
  ::cockroach::roachpb::Span* mutable_header();
  ::cockroach::roachpb::Span* release_header();
  void set_allocated_header(::cockroach::roachpb::Span* header);

  // optional uint32 version = 2;
  bool has_version() const;
  void clear_version();
  static const int kVersionFieldNumber = 2;
  ::google::protobuf::uint32 version() const;
  void set_version(::google::protobuf::uint32 value);

  // optional bytes checksum_id = 3;
  bool has_checksum_id() const;
  void clear_checksum_id();
  static const int kChecksumIdFieldNumber = 3;
  const ::std::string& checksum_id() const;
  void set_checksum_id(const ::std::string& value);
  void set_checksum_id(const char* value);
  void set_checksum_id(const void* value, size_t size);
  ::std::string* mutable_checksum_id();
  ::std::string* release_checksum_id();
  void set_allocated_checksum_id(::std::string* checksum_id);

  // optional bytes checksum = 4;
  bool has_checksum() const;
  void clear_checksum();
  static const int kChecksumFieldNumber = 4;
  const ::std::string& checksum() const;
  void set_checksum(const ::std::string& value);
  void set_checksum(const char* value);
  void set_checksum(const void* value, size_t size);
  ::std::string* mutable_checksum();
  ::std::string* release_checksum();
  void set_allocated_checksum(::std::string* checksum);

  // @@protoc_insertion_point(class_scope:cockroach.roachpb.VerifyChecksumRequest)
 private:
  inline void set_has_header();
  inline void clear_has_header();
  inline void set_has_version();
  inline void clear_has_version();
  inline void set_has_checksum_id();
  inline void clear_has_checksum_id();
  inline void set_has_checksum();
  inline void clear_has_checksum();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::cockroach::roachpb::Span* header_;
  ::google::protobuf::internal::ArenaStringPtr checksum_id_;
  ::google::protobuf::internal::ArenaStringPtr checksum_;
  ::google::protobuf::uint32 version_;
  friend void  protobuf_AddDesc_cockroach_2froachpb_2fapi_2eproto();
  friend void protobuf_AssignDesc_cockroach_2froachpb_2fapi_2eproto();
  friend void protobuf_ShutdownFile_cockroach_2froachpb_2fapi_2eproto();

  void InitAsDefaultInstance();
  static VerifyChecksumRequest* default_instance_;
};
// -------------------------------------------------------------------

class VerifyChecksumResponse : public ::google::protobuf::Message {
 public:
  VerifyChecksumResponse();
  virtual ~VerifyChecksumResponse();

  VerifyChecksumResponse(const VerifyChecksumResponse& from);

  inline VerifyChecksumResponse& operator=(const VerifyChecksumResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const VerifyChecksumResponse& default_instance();

  void Swap(VerifyChecksumResponse* other);

  // implements Message ----------------------------------------------

  inline VerifyChecksumResponse* New() const { return New(NULL); }

  VerifyChecksumResponse* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const VerifyChecksumResponse& from);
  void MergeFrom(const VerifyChecksumResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(VerifyChecksumResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .cockroach.roachpb.ResponseHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::cockroach::roachpb::ResponseHeader& header() const;
  ::cockroach::roachpb::ResponseHeader* mutable_header();
  ::cockroach::roachpb::ResponseHeader* release_header();
  void set_allocated_header(::cockroach::roachpb::ResponseHeader* header);

  // @@protoc_insertion_point(class_scope:cockroach.roachpb.VerifyChecksumResponse)
 private:
  inline void set_has_header();
  inline void clear_has_header();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::cockroach::roachpb::ResponseHeader* header_;
  friend void  protobuf_AddDesc_cockroach_2froachpb_2fapi_2eproto();
  friend void protobuf_AssignDesc_cockroach_2froachpb_2fapi_2eproto();
  friend void protobuf_ShutdownFile_cockroach_2froachpb_2fapi_2eproto();

  void InitAsDefaultInstance();
  static VerifyChecksumResponse* default_instance_;
};
// -------------------------------------------------------------------

class RequestUnion : public ::google::protobuf::Message {
 public:
  RequestUnion();
  virtual ~RequestUnion();

  RequestUnion(const RequestUnion& from);

  inline RequestUnion& operator=(const RequestUnion& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RequestUnion& default_instance();

  void Swap(RequestUnion* other);

  // implements Message ----------------------------------------------

  inline RequestUnion* New() const { return New(NULL); }

  RequestUnion* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RequestUnion& from);
  void MergeFrom(const RequestUnion& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RequestUnion* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .cockroach.roachpb.GetRequest get = 1;
  bool has_get() const;
  void clear_get();
  static const int kGetFieldNumber = 1;
  const ::cockroach::roachpb::GetRequest& get() const;
  ::cockroach::roachpb::GetRequest* mutable_get();
  ::cockroach::roachpb::GetRequest* release_get();
  void set_allocated_get(::cockroach::roachpb::GetRequest* get);

  // optional .cockroach.roachpb.PutRequest put = 2;
  bool has_put() const;
  void clear_put();
  static const int kPutFieldNumber = 2;
  const ::cockroach::roachpb::PutRequest& put() const;
  ::cockroach::roachpb::PutRequest* mutable_put();
  ::cockroach::roachpb::PutRequest* release_put();
  void set_allocated_put(::cockroach::roachpb::PutRequest* put);

  // optional .cockroach.roachpb.ConditionalPutRequest conditional_put = 3;
  bool has_conditional_put() const;
  void clear_conditional_put();
  static const int kConditionalPutFieldNumber = 3;
  const ::cockroach::roachpb::ConditionalPutRequest& conditional_put() const;
  ::cockroach::roachpb::ConditionalPutRequest* mutable_conditional_put();
  ::cockroach::roachpb::ConditionalPutRequest* release_conditional_put();
  void set_allocated_conditional_put(::cockroach::roachpb::ConditionalPutRequest* conditional_put);

  // optional .cockroach.roachpb.IncrementRequest increment = 4;
  bool has_increment() const;
  void clear_increment();
  static const int kIncrementFieldNumber = 4;
  const ::cockroach::roachpb::IncrementRequest& increment() const;
  ::cockroach::roachpb::IncrementRequest* mutable_increment();
  ::cockroach::roachpb::IncrementRequest* release_increment();
  void set_allocated_increment(::cockroach::roachpb::IncrementRequest* increment);

  // optional .cockroach.roachpb.DeleteRequest delete = 5;
  bool has_delete_() const;
  void clear_delete_();
  static const int kDeleteFieldNumber = 5;
  const ::cockroach::roachpb::DeleteRequest& delete_() const;
  ::cockroach::roachpb::DeleteRequest* mutable_delete_();
  ::cockroach::roachpb::DeleteRequest* release_delete_();
  void set_allocated_delete_(::cockroach::roachpb::DeleteRequest* delete_);

  // optional .cockroach.roachpb.DeleteRangeRequest delete_range = 6;
  bool has_delete_range() const;
  void clear_delete_range();
  static const int kDeleteRangeFieldNumber = 6;
  const ::cockroach::roachpb::DeleteRangeRequest& delete_range() const;
  ::cockroach::roachpb::DeleteRangeRequest* mutable_delete_range();
  ::cockroach::roachpb::DeleteRangeRequest* release_delete_range();
  void set_allocated_delete_range(::cockroach::roachpb::DeleteRangeRequest* delete_range);

  // optional .cockroach.roachpb.ScanRequest scan = 7;
  bool has_scan() const;
  void clear_scan();
  static const int kScanFieldNumber = 7;
  const ::cockroach::roachpb::ScanRequest& scan() const;
  ::cockroach::roachpb::ScanRequest* mutable_scan();
  ::cockroach::roachpb::ScanRequest* release_scan();
  void set_allocated_scan(::cockroach::roachpb::ScanRequest* scan);

  // optional .cockroach.roachpb.BeginTransactionRequest begin_transaction = 8;
  bool has_begin_transaction() const;
  void clear_begin_transaction();
  static const int kBeginTransactionFieldNumber = 8;
  const ::cockroach::roachpb::BeginTransactionRequest& begin_transaction() const;
  ::cockroach::roachpb::BeginTransactionRequest* mutable_begin_transaction();
  ::cockroach::roachpb::BeginTransactionRequest* release_begin_transaction();
  void set_allocated_begin_transaction(::cockroach::roachpb::BeginTransactionRequest* begin_transaction);

  // optional .cockroach.roachpb.EndTransactionRequest end_transaction = 9;
  bool has_end_transaction() const;
  void clear_end_transaction();
  static const int kEndTransactionFieldNumber = 9;
  const ::cockroach::roachpb::EndTransactionRequest& end_transaction() const;
  ::cockroach::roachpb::EndTransactionRequest* mutable_end_transaction();
  ::cockroach::roachpb::EndTransactionRequest* release_end_transaction();
  void set_allocated_end_transaction(::cockroach::roachpb::EndTransactionRequest* end_transaction);

  // optional .cockroach.roachpb.AdminSplitRequest admin_split = 10;
  bool has_admin_split() const;
  void clear_admin_split();
  static const int kAdminSplitFieldNumber = 10;
  const ::cockroach::roachpb::AdminSplitRequest& admin_split() const;
  ::cockroach::roachpb::AdminSplitRequest* mutable_admin_split();
  ::cockroach::roachpb::AdminSplitRequest* release_admin_split();
  void set_allocated_admin_split(::cockroach::roachpb::AdminSplitRequest* admin_split);

  // optional .cockroach.roachpb.AdminMergeRequest admin_merge = 11;
  bool has_admin_merge() const;
  void clear_admin_merge();
  static const int kAdminMergeFieldNumber = 11;
  const ::cockroach::roachpb::AdminMergeRequest& admin_merge() const;
  ::cockroach::roachpb::AdminMergeRequest* mutable_admin_merge();
  ::cockroach::roachpb::AdminMergeRequest* release_admin_merge();
  void set_allocated_admin_merge(::cockroach::roachpb::AdminMergeRequest* admin_merge);

  // optional .cockroach.roachpb.HeartbeatTxnRequest heartbeat_txn = 12;
  bool has_heartbeat_txn() const;
  void clear_heartbeat_txn();
  static const int kHeartbeatTxnFieldNumber = 12;
  const ::cockroach::roachpb::HeartbeatTxnRequest& heartbeat_txn() const;
  ::cockroach::roachpb::HeartbeatTxnRequest* mutable_heartbeat_txn();
  ::cockroach::roachpb::HeartbeatTxnRequest* release_heartbeat_txn();
  void set_allocated_heartbeat_txn(::cockroach::roachpb::HeartbeatTxnRequest* heartbeat_txn);

  // optional .cockroach.roachpb.GCRequest gc = 13;
  bool has_gc() const;
  void clear_gc();
  static const int kGcFieldNumber = 13;
  const ::cockroach::roachpb::GCRequest& gc() const;
  ::cockroach::roachpb::GCRequest* mutable_gc();
  ::cockroach::roachpb::GCRequest* release_gc();
  void set_allocated_gc(::cockroach::roachpb::GCRequest* gc);

  // optional .cockroach.roachpb.PushTxnRequest push_txn = 14;
  bool has_push_txn() const;
  void clear_push_txn();
  static const int kPushTxnFieldNumber = 14;
  const ::cockroach::roachpb::PushTxnRequest& push_txn() const;
  ::cockroach::roachpb::PushTxnRequest* mutable_push_txn();
  ::cockroach::roachpb::PushTxnRequest* release_push_txn();
  void set_allocated_push_txn(::cockroach::roachpb::PushTxnRequest* push_txn);

  // optional .cockroach.roachpb.RangeLookupRequest range_lookup = 15;
  bool has_range_lookup() const;
  void clear_range_lookup();
  static const int kRangeLookupFieldNumber = 15;
  const ::cockroach::roachpb::RangeLookupRequest& range_lookup() const;
  ::cockroach::roachpb::RangeLookupRequest* mutable_range_lookup();
  ::cockroach::roachpb::RangeLookupRequest* release_range_lookup();
  void set_allocated_range_lookup(::cockroach::roachpb::RangeLookupRequest* range_lookup);

  // optional .cockroach.roachpb.ResolveIntentRequest resolve_intent = 16;
  bool has_resolve_intent() const;
  void clear_resolve_intent();
  static const int kResolveIntentFieldNumber = 16;
  const ::cockroach::roachpb::ResolveIntentRequest& resolve_intent() const;
  ::cockroach::roachpb::ResolveIntentRequest* mutable_resolve_intent();
  ::cockroach::roachpb::ResolveIntentRequest* release_resolve_intent();
  void set_allocated_resolve_intent(::cockroach::roachpb::ResolveIntentRequest* resolve_intent);

  // optional .cockroach.roachpb.ResolveIntentRangeRequest resolve_intent_range = 17;
  bool has_resolve_intent_range() const;
  void clear_resolve_intent_range();
  static const int kResolveIntentRangeFieldNumber = 17;
  const ::cockroach::roachpb::ResolveIntentRangeRequest& resolve_intent_range() const;
  ::cockroach::roachpb::ResolveIntentRangeRequest* mutable_resolve_intent_range();
  ::cockroach::roachpb::ResolveIntentRangeRequest* release_resolve_intent_range();
  void set_allocated_resolve_intent_range(::cockroach::roachpb::ResolveIntentRangeRequest* resolve_intent_range);

  // optional .cockroach.roachpb.MergeRequest merge = 18;
  bool has_merge() const;
  void clear_merge();
  static const int kMergeFieldNumber = 18;
  const ::cockroach::roachpb::MergeRequest& merge() const;
  ::cockroach::roachpb::MergeRequest* mutable_merge();
  ::cockroach::roachpb::MergeRequest* release_merge();
  void set_allocated_merge(::cockroach::roachpb::MergeRequest* merge);

  // optional .cockroach.roachpb.TruncateLogRequest truncate_log = 19;
  bool has_truncate_log() const;
  void clear_truncate_log();
  static const int kTruncateLogFieldNumber = 19;
  const ::cockroach::roachpb::TruncateLogRequest& truncate_log() const;
  ::cockroach::roachpb::TruncateLogRequest* mutable_truncate_log();
  ::cockroach::roachpb::TruncateLogRequest* release_truncate_log();
  void set_allocated_truncate_log(::cockroach::roachpb::TruncateLogRequest* truncate_log);

  // optional .cockroach.roachpb.LeaderLeaseRequest leader_lease = 20;
  bool has_leader_lease() const;
  void clear_leader_lease();
  static const int kLeaderLeaseFieldNumber = 20;
  const ::cockroach::roachpb::LeaderLeaseRequest& leader_lease() const;
  ::cockroach::roachpb::LeaderLeaseRequest* mutable_leader_lease();
  ::cockroach::roachpb::LeaderLeaseRequest* release_leader_lease();
  void set_allocated_leader_lease(::cockroach::roachpb::LeaderLeaseRequest* leader_lease);

  // optional .cockroach.roachpb.ReverseScanRequest reverse_scan = 21;
  bool has_reverse_scan() const;
  void clear_reverse_scan();
  static const int kReverseScanFieldNumber = 21;
  const ::cockroach::roachpb::ReverseScanRequest& reverse_scan() const;
  ::cockroach::roachpb::ReverseScanRequest* mutable_reverse_scan();
  ::cockroach::roachpb::ReverseScanRequest* release_reverse_scan();
  void set_allocated_reverse_scan(::cockroach::roachpb::ReverseScanRequest* reverse_scan);

  // optional .cockroach.roachpb.ComputeChecksumRequest compute_checksum = 22;
  bool has_compute_checksum() const;
  void clear_compute_checksum();
  static const int kComputeChecksumFieldNumber = 22;
  const ::cockroach::roachpb::ComputeChecksumRequest& compute_checksum() const;
  ::cockroach::roachpb::ComputeChecksumRequest* mutable_compute_checksum();
  ::cockroach::roachpb::ComputeChecksumRequest* release_compute_checksum();
  void set_allocated_compute_checksum(::cockroach::roachpb::ComputeChecksumRequest* compute_checksum);

  // optional .cockroach.roachpb.VerifyChecksumRequest verify_checksum = 23;
  bool has_verify_checksum() const;
  void clear_verify_checksum();
  static const int kVerifyChecksumFieldNumber = 23;
  const ::cockroach::roachpb::VerifyChecksumRequest& verify_checksum() const;
  ::cockroach::roachpb::VerifyChecksumRequest* mutable_verify_checksum();
  ::cockroach::roachpb::VerifyChecksumRequest* release_verify_checksum();
  void set_allocated_verify_checksum(::cockroach::roachpb::VerifyChecksumRequest* verify_checksum);

  // optional .cockroach.roachpb.CheckConsistencyRequest check_consistency = 24;
  bool has_check_consistency() const;
  void clear_check_consistency();
  static const int kCheckConsistencyFieldNumber = 24;
  const ::cockroach::roachpb::CheckConsistencyRequest& check_consistency() const;
  ::cockroach::roachpb::CheckConsistencyRequest* mutable_check_consistency();
  ::cockroach::roachpb::CheckConsistencyRequest* release_check_consistency();
  void set_allocated_check_consistency(::cockroach::roachpb::CheckConsistencyRequest* check_consistency);

  // optional .cockroach.roachpb.NoopRequest noop = 25;
  bool has_noop() const;
  void clear_noop();
  static const int kNoopFieldNumber = 25;
  const ::cockroach::roachpb::NoopRequest& noop() const;
  ::cockroach::roachpb::NoopRequest* mutable_noop();
  ::cockroach::roachpb::NoopRequest* release_noop();
  void set_allocated_noop(::cockroach::roachpb::NoopRequest* noop);

  // @@protoc_insertion_point(class_scope:cockroach.roachpb.RequestUnion)
 private:
  inline void set_has_get();
  inline void clear_has_get();
  inline void set_has_put();
  inline void clear_has_put();
  inline void set_has_conditional_put();
  inline void clear_has_conditional_put();
  inline void set_has_increment();
  inline void clear_has_increment();
  inline void set_has_delete_();
  inline void clear_has_delete_();
  inline void set_has_delete_range();
  inline void clear_has_delete_range();
  inline void set_has_scan();
  inline void clear_has_scan();
  inline void set_has_begin_transaction();
  inline void clear_has_begin_transaction();
  inline void set_has_end_transaction();
  inline void clear_has_end_transaction();
  inline void set_has_admin_split();
  inline void clear_has_admin_split();
  inline void set_has_admin_merge();
  inline void clear_has_admin_merge();
  inline void set_has_heartbeat_txn();
  inline void clear_has_heartbeat_txn();
  inline void set_has_gc();
  inline void clear_has_gc();
  inline void set_has_push_txn();
  inline void clear_has_push_txn();
  inline void set_has_range_lookup();
  inline void clear_has_range_lookup();
  inline void set_has_resolve_intent();
  inline void clear_has_resolve_intent();
  inline void set_has_resolve_intent_range();
  inline void clear_has_resolve_intent_range();
  inline void set_has_merge();
  inline void clear_has_merge();
  inline void set_has_truncate_log();
  inline void clear_has_truncate_log();
  inline void set_has_leader_lease();
  inline void clear_has_leader_lease();
  inline void set_has_reverse_scan();
  inline void clear_has_reverse_scan();
  inline void set_has_compute_checksum();
  inline void clear_has_compute_checksum();
  inline void set_has_verify_checksum();
  inline void clear_has_verify_checksum();
  inline void set_has_check_consistency();
  inline void clear_has_check_consistency();
  inline void set_has_noop();
  inline void clear_has_noop();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::cockroach::roachpb::GetRequest* get_;
  ::cockroach::roachpb::PutRequest* put_;
  ::cockroach::roachpb::ConditionalPutRequest* conditional_put_;
  ::cockroach::roachpb::IncrementRequest* increment_;
  ::cockroach::roachpb::DeleteRequest* delete__;
  ::cockroach::roachpb::DeleteRangeRequest* delete_range_;
  ::cockroach::roachpb::ScanRequest* scan_;
  ::cockroach::roachpb::BeginTransactionRequest* begin_transaction_;
  ::cockroach::roachpb::EndTransactionRequest* end_transaction_;
  ::cockroach::roachpb::AdminSplitRequest* admin_split_;
  ::cockroach::roachpb::AdminMergeRequest* admin_merge_;
  ::cockroach::roachpb::HeartbeatTxnRequest* heartbeat_txn_;
  ::cockroach::roachpb::GCRequest* gc_;
  ::cockroach::roachpb::PushTxnRequest* push_txn_;
  ::cockroach::roachpb::RangeLookupRequest* range_lookup_;
  ::cockroach::roachpb::ResolveIntentRequest* resolve_intent_;
  ::cockroach::roachpb::ResolveIntentRangeRequest* resolve_intent_range_;
  ::cockroach::roachpb::MergeRequest* merge_;
  ::cockroach::roachpb::TruncateLogRequest* truncate_log_;
  ::cockroach::roachpb::LeaderLeaseRequest* leader_lease_;
  ::cockroach::roachpb::ReverseScanRequest* reverse_scan_;
  ::cockroach::roachpb::ComputeChecksumRequest* compute_checksum_;
  ::cockroach::roachpb::VerifyChecksumRequest* verify_checksum_;
  ::cockroach::roachpb::CheckConsistencyRequest* check_consistency_;
  ::cockroach::roachpb::NoopRequest* noop_;
  friend void  protobuf_AddDesc_cockroach_2froachpb_2fapi_2eproto();
  friend void protobuf_AssignDesc_cockroach_2froachpb_2fapi_2eproto();
  friend void protobuf_ShutdownFile_cockroach_2froachpb_2fapi_2eproto();

  void InitAsDefaultInstance();
  static RequestUnion* default_instance_;
};
// -------------------------------------------------------------------

class ResponseUnion : public ::google::protobuf::Message {
 public:
  ResponseUnion();
  virtual ~ResponseUnion();

  ResponseUnion(const ResponseUnion& from);

  inline ResponseUnion& operator=(const ResponseUnion& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ResponseUnion& default_instance();

  void Swap(ResponseUnion* other);

  // implements Message ----------------------------------------------

  inline ResponseUnion* New() const { return New(NULL); }

  ResponseUnion* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ResponseUnion& from);
  void MergeFrom(const ResponseUnion& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ResponseUnion* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .cockroach.roachpb.GetResponse get = 1;
  bool has_get() const;
  void clear_get();
  static const int kGetFieldNumber = 1;
  const ::cockroach::roachpb::GetResponse& get() const;
  ::cockroach::roachpb::GetResponse* mutable_get();
  ::cockroach::roachpb::GetResponse* release_get();
  void set_allocated_get(::cockroach::roachpb::GetResponse* get);

  // optional .cockroach.roachpb.PutResponse put = 2;
  bool has_put() const;
  void clear_put();
  static const int kPutFieldNumber = 2;
  const ::cockroach::roachpb::PutResponse& put() const;
  ::cockroach::roachpb::PutResponse* mutable_put();
  ::cockroach::roachpb::PutResponse* release_put();
  void set_allocated_put(::cockroach::roachpb::PutResponse* put);

  // optional .cockroach.roachpb.ConditionalPutResponse conditional_put = 3;
  bool has_conditional_put() const;
  void clear_conditional_put();
  static const int kConditionalPutFieldNumber = 3;
  const ::cockroach::roachpb::ConditionalPutResponse& conditional_put() const;
  ::cockroach::roachpb::ConditionalPutResponse* mutable_conditional_put();
  ::cockroach::roachpb::ConditionalPutResponse* release_conditional_put();
  void set_allocated_conditional_put(::cockroach::roachpb::ConditionalPutResponse* conditional_put);

  // optional .cockroach.roachpb.IncrementResponse increment = 4;
  bool has_increment() const;
  void clear_increment();
  static const int kIncrementFieldNumber = 4;
  const ::cockroach::roachpb::IncrementResponse& increment() const;
  ::cockroach::roachpb::IncrementResponse* mutable_increment();
  ::cockroach::roachpb::IncrementResponse* release_increment();
  void set_allocated_increment(::cockroach::roachpb::IncrementResponse* increment);

  // optional .cockroach.roachpb.DeleteResponse delete = 5;
  bool has_delete_() const;
  void clear_delete_();
  static const int kDeleteFieldNumber = 5;
  const ::cockroach::roachpb::DeleteResponse& delete_() const;
  ::cockroach::roachpb::DeleteResponse* mutable_delete_();
  ::cockroach::roachpb::DeleteResponse* release_delete_();
  void set_allocated_delete_(::cockroach::roachpb::DeleteResponse* delete_);

  // optional .cockroach.roachpb.DeleteRangeResponse delete_range = 6;
  bool has_delete_range() const;
  void clear_delete_range();
  static const int kDeleteRangeFieldNumber = 6;
  const ::cockroach::roachpb::DeleteRangeResponse& delete_range() const;
  ::cockroach::roachpb::DeleteRangeResponse* mutable_delete_range();
  ::cockroach::roachpb::DeleteRangeResponse* release_delete_range();
  void set_allocated_delete_range(::cockroach::roachpb::DeleteRangeResponse* delete_range);

  // optional .cockroach.roachpb.ScanResponse scan = 7;
  bool has_scan() const;
  void clear_scan();
  static const int kScanFieldNumber = 7;
  const ::cockroach::roachpb::ScanResponse& scan() const;
  ::cockroach::roachpb::ScanResponse* mutable_scan();
  ::cockroach::roachpb::ScanResponse* release_scan();
  void set_allocated_scan(::cockroach::roachpb::ScanResponse* scan);

  // optional .cockroach.roachpb.BeginTransactionResponse begin_transaction = 8;
  bool has_begin_transaction() const;
  void clear_begin_transaction();
  static const int kBeginTransactionFieldNumber = 8;
  const ::cockroach::roachpb::BeginTransactionResponse& begin_transaction() const;
  ::cockroach::roachpb::BeginTransactionResponse* mutable_begin_transaction();
  ::cockroach::roachpb::BeginTransactionResponse* release_begin_transaction();
  void set_allocated_begin_transaction(::cockroach::roachpb::BeginTransactionResponse* begin_transaction);

  // optional .cockroach.roachpb.EndTransactionResponse end_transaction = 9;
  bool has_end_transaction() const;
  void clear_end_transaction();
  static const int kEndTransactionFieldNumber = 9;
  const ::cockroach::roachpb::EndTransactionResponse& end_transaction() const;
  ::cockroach::roachpb::EndTransactionResponse* mutable_end_transaction();
  ::cockroach::roachpb::EndTransactionResponse* release_end_transaction();
  void set_allocated_end_transaction(::cockroach::roachpb::EndTransactionResponse* end_transaction);

  // optional .cockroach.roachpb.AdminSplitResponse admin_split = 10;
  bool has_admin_split() const;
  void clear_admin_split();
  static const int kAdminSplitFieldNumber = 10;
  const ::cockroach::roachpb::AdminSplitResponse& admin_split() const;
  ::cockroach::roachpb::AdminSplitResponse* mutable_admin_split();
  ::cockroach::roachpb::AdminSplitResponse* release_admin_split();
  void set_allocated_admin_split(::cockroach::roachpb::AdminSplitResponse* admin_split);

  // optional .cockroach.roachpb.AdminMergeResponse admin_merge = 11;
  bool has_admin_merge() const;
  void clear_admin_merge();
  static const int kAdminMergeFieldNumber = 11;
  const ::cockroach::roachpb::AdminMergeResponse& admin_merge() const;
  ::cockroach::roachpb::AdminMergeResponse* mutable_admin_merge();
  ::cockroach::roachpb::AdminMergeResponse* release_admin_merge();
  void set_allocated_admin_merge(::cockroach::roachpb::AdminMergeResponse* admin_merge);

  // optional .cockroach.roachpb.HeartbeatTxnResponse heartbeat_txn = 12;
  bool has_heartbeat_txn() const;
  void clear_heartbeat_txn();
  static const int kHeartbeatTxnFieldNumber = 12;
  const ::cockroach::roachpb::HeartbeatTxnResponse& heartbeat_txn() const;
  ::cockroach::roachpb::HeartbeatTxnResponse* mutable_heartbeat_txn();
  ::cockroach::roachpb::HeartbeatTxnResponse* release_heartbeat_txn();
  void set_allocated_heartbeat_txn(::cockroach::roachpb::HeartbeatTxnResponse* heartbeat_txn);

  // optional .cockroach.roachpb.GCResponse gc = 13;
  bool has_gc() const;
  void clear_gc();
  static const int kGcFieldNumber = 13;
  const ::cockroach::roachpb::GCResponse& gc() const;
  ::cockroach::roachpb::GCResponse* mutable_gc();
  ::cockroach::roachpb::GCResponse* release_gc();
  void set_allocated_gc(::cockroach::roachpb::GCResponse* gc);

  // optional .cockroach.roachpb.PushTxnResponse push_txn = 14;
  bool has_push_txn() const;
  void clear_push_txn();
  static const int kPushTxnFieldNumber = 14;
  const ::cockroach::roachpb::PushTxnResponse& push_txn() const;
  ::cockroach::roachpb::PushTxnResponse* mutable_push_txn();
  ::cockroach::roachpb::PushTxnResponse* release_push_txn();
  void set_allocated_push_txn(::cockroach::roachpb::PushTxnResponse* push_txn);

  // optional .cockroach.roachpb.RangeLookupResponse range_lookup = 15;
  bool has_range_lookup() const;
  void clear_range_lookup();
  static const int kRangeLookupFieldNumber = 15;
  const ::cockroach::roachpb::RangeLookupResponse& range_lookup() const;
  ::cockroach::roachpb::RangeLookupResponse* mutable_range_lookup();
  ::cockroach::roachpb::RangeLookupResponse* release_range_lookup();
  void set_allocated_range_lookup(::cockroach::roachpb::RangeLookupResponse* range_lookup);

  // optional .cockroach.roachpb.ResolveIntentResponse resolve_intent = 16;
  bool has_resolve_intent() const;
  void clear_resolve_intent();
  static const int kResolveIntentFieldNumber = 16;
  const ::cockroach::roachpb::ResolveIntentResponse& resolve_intent() const;
  ::cockroach::roachpb::ResolveIntentResponse* mutable_resolve_intent();
  ::cockroach::roachpb::ResolveIntentResponse* release_resolve_intent();
  void set_allocated_resolve_intent(::cockroach::roachpb::ResolveIntentResponse* resolve_intent);

  // optional .cockroach.roachpb.ResolveIntentRangeResponse resolve_intent_range = 17;
  bool has_resolve_intent_range() const;
  void clear_resolve_intent_range();
  static const int kResolveIntentRangeFieldNumber = 17;
  const ::cockroach::roachpb::ResolveIntentRangeResponse& resolve_intent_range() const;
  ::cockroach::roachpb::ResolveIntentRangeResponse* mutable_resolve_intent_range();
  ::cockroach::roachpb::ResolveIntentRangeResponse* release_resolve_intent_range();
  void set_allocated_resolve_intent_range(::cockroach::roachpb::ResolveIntentRangeResponse* resolve_intent_range);

  // optional .cockroach.roachpb.MergeResponse merge = 18;
  bool has_merge() const;
  void clear_merge();
  static const int kMergeFieldNumber = 18;
  const ::cockroach::roachpb::MergeResponse& merge() const;
  ::cockroach::roachpb::MergeResponse* mutable_merge();
  ::cockroach::roachpb::MergeResponse* release_merge();
  void set_allocated_merge(::cockroach::roachpb::MergeResponse* merge);

  // optional .cockroach.roachpb.TruncateLogResponse truncate_log = 19;
  bool has_truncate_log() const;
  void clear_truncate_log();
  static const int kTruncateLogFieldNumber = 19;
  const ::cockroach::roachpb::TruncateLogResponse& truncate_log() const;
  ::cockroach::roachpb::TruncateLogResponse* mutable_truncate_log();
  ::cockroach::roachpb::TruncateLogResponse* release_truncate_log();
  void set_allocated_truncate_log(::cockroach::roachpb::TruncateLogResponse* truncate_log);

  // optional .cockroach.roachpb.LeaderLeaseResponse leader_lease = 20;
  bool has_leader_lease() const;
  void clear_leader_lease();
  static const int kLeaderLeaseFieldNumber = 20;
  const ::cockroach::roachpb::LeaderLeaseResponse& leader_lease() const;
  ::cockroach::roachpb::LeaderLeaseResponse* mutable_leader_lease();
  ::cockroach::roachpb::LeaderLeaseResponse* release_leader_lease();
  void set_allocated_leader_lease(::cockroach::roachpb::LeaderLeaseResponse* leader_lease);

  // optional .cockroach.roachpb.ReverseScanResponse reverse_scan = 21;
  bool has_reverse_scan() const;
  void clear_reverse_scan();
  static const int kReverseScanFieldNumber = 21;
  const ::cockroach::roachpb::ReverseScanResponse& reverse_scan() const;
  ::cockroach::roachpb::ReverseScanResponse* mutable_reverse_scan();
  ::cockroach::roachpb::ReverseScanResponse* release_reverse_scan();
  void set_allocated_reverse_scan(::cockroach::roachpb::ReverseScanResponse* reverse_scan);

  // optional .cockroach.roachpb.ComputeChecksumResponse compute_checksum = 22;
  bool has_compute_checksum() const;
  void clear_compute_checksum();
  static const int kComputeChecksumFieldNumber = 22;
  const ::cockroach::roachpb::ComputeChecksumResponse& compute_checksum() const;
  ::cockroach::roachpb::ComputeChecksumResponse* mutable_compute_checksum();
  ::cockroach::roachpb::ComputeChecksumResponse* release_compute_checksum();
  void set_allocated_compute_checksum(::cockroach::roachpb::ComputeChecksumResponse* compute_checksum);

  // optional .cockroach.roachpb.VerifyChecksumResponse verify_checksum = 23;
  bool has_verify_checksum() const;
  void clear_verify_checksum();
  static const int kVerifyChecksumFieldNumber = 23;
  const ::cockroach::roachpb::VerifyChecksumResponse& verify_checksum() const;
  ::cockroach::roachpb::VerifyChecksumResponse* mutable_verify_checksum();
  ::cockroach::roachpb::VerifyChecksumResponse* release_verify_checksum();
  void set_allocated_verify_checksum(::cockroach::roachpb::VerifyChecksumResponse* verify_checksum);

  // optional .cockroach.roachpb.CheckConsistencyResponse check_consistency = 24;
  bool has_check_consistency() const;
  void clear_check_consistency();
  static const int kCheckConsistencyFieldNumber = 24;
  const ::cockroach::roachpb::CheckConsistencyResponse& check_consistency() const;
  ::cockroach::roachpb::CheckConsistencyResponse* mutable_check_consistency();
  ::cockroach::roachpb::CheckConsistencyResponse* release_check_consistency();
  void set_allocated_check_consistency(::cockroach::roachpb::CheckConsistencyResponse* check_consistency);

  // optional .cockroach.roachpb.NoopResponse noop = 25;
  bool has_noop() const;
  void clear_noop();
  static const int kNoopFieldNumber = 25;
  const ::cockroach::roachpb::NoopResponse& noop() const;
  ::cockroach::roachpb::NoopResponse* mutable_noop();
  ::cockroach::roachpb::NoopResponse* release_noop();
  void set_allocated_noop(::cockroach::roachpb::NoopResponse* noop);

  // @@protoc_insertion_point(class_scope:cockroach.roachpb.ResponseUnion)
 private:
  inline void set_has_get();
  inline void clear_has_get();
  inline void set_has_put();
  inline void clear_has_put();
  inline void set_has_conditional_put();
  inline void clear_has_conditional_put();
  inline void set_has_increment();
  inline void clear_has_increment();
  inline void set_has_delete_();
  inline void clear_has_delete_();
  inline void set_has_delete_range();
  inline void clear_has_delete_range();
  inline void set_has_scan();
  inline void clear_has_scan();
  inline void set_has_begin_transaction();
  inline void clear_has_begin_transaction();
  inline void set_has_end_transaction();
  inline void clear_has_end_transaction();
  inline void set_has_admin_split();
  inline void clear_has_admin_split();
  inline void set_has_admin_merge();
  inline void clear_has_admin_merge();
  inline void set_has_heartbeat_txn();
  inline void clear_has_heartbeat_txn();
  inline void set_has_gc();
  inline void clear_has_gc();
  inline void set_has_push_txn();
  inline void clear_has_push_txn();
  inline void set_has_range_lookup();
  inline void clear_has_range_lookup();
  inline void set_has_resolve_intent();
  inline void clear_has_resolve_intent();
  inline void set_has_resolve_intent_range();
  inline void clear_has_resolve_intent_range();
  inline void set_has_merge();
  inline void clear_has_merge();
  inline void set_has_truncate_log();
  inline void clear_has_truncate_log();
  inline void set_has_leader_lease();
  inline void clear_has_leader_lease();
  inline void set_has_reverse_scan();
  inline void clear_has_reverse_scan();
  inline void set_has_compute_checksum();
  inline void clear_has_compute_checksum();
  inline void set_has_verify_checksum();
  inline void clear_has_verify_checksum();
  inline void set_has_check_consistency();
  inline void clear_has_check_consistency();
  inline void set_has_noop();
  inline void clear_has_noop();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::cockroach::roachpb::GetResponse* get_;
  ::cockroach::roachpb::PutResponse* put_;
  ::cockroach::roachpb::ConditionalPutResponse* conditional_put_;
  ::cockroach::roachpb::IncrementResponse* increment_;
  ::cockroach::roachpb::DeleteResponse* delete__;
  ::cockroach::roachpb::DeleteRangeResponse* delete_range_;
  ::cockroach::roachpb::ScanResponse* scan_;
  ::cockroach::roachpb::BeginTransactionResponse* begin_transaction_;
  ::cockroach::roachpb::EndTransactionResponse* end_transaction_;
  ::cockroach::roachpb::AdminSplitResponse* admin_split_;
  ::cockroach::roachpb::AdminMergeResponse* admin_merge_;
  ::cockroach::roachpb::HeartbeatTxnResponse* heartbeat_txn_;
  ::cockroach::roachpb::GCResponse* gc_;
  ::cockroach::roachpb::PushTxnResponse* push_txn_;
  ::cockroach::roachpb::RangeLookupResponse* range_lookup_;
  ::cockroach::roachpb::ResolveIntentResponse* resolve_intent_;
  ::cockroach::roachpb::ResolveIntentRangeResponse* resolve_intent_range_;
  ::cockroach::roachpb::MergeResponse* merge_;
  ::cockroach::roachpb::TruncateLogResponse* truncate_log_;
  ::cockroach::roachpb::LeaderLeaseResponse* leader_lease_;
  ::cockroach::roachpb::ReverseScanResponse* reverse_scan_;
  ::cockroach::roachpb::ComputeChecksumResponse* compute_checksum_;
  ::cockroach::roachpb::VerifyChecksumResponse* verify_checksum_;
  ::cockroach::roachpb::CheckConsistencyResponse* check_consistency_;
  ::cockroach::roachpb::NoopResponse* noop_;
  friend void  protobuf_AddDesc_cockroach_2froachpb_2fapi_2eproto();
  friend void protobuf_AssignDesc_cockroach_2froachpb_2fapi_2eproto();
  friend void protobuf_ShutdownFile_cockroach_2froachpb_2fapi_2eproto();

  void InitAsDefaultInstance();
  static ResponseUnion* default_instance_;
};
// -------------------------------------------------------------------

class Header : public ::google::protobuf::Message {
 public:
  Header();
  virtual ~Header();

  Header(const Header& from);

  inline Header& operator=(const Header& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Header& default_instance();

  void Swap(Header* other);

  // implements Message ----------------------------------------------

  inline Header* New() const { return New(NULL); }

  Header* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Header& from);
  void MergeFrom(const Header& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Header* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .cockroach.roachpb.Timestamp timestamp = 1;
  bool has_timestamp() const;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 1;
  const ::cockroach::roachpb::Timestamp& timestamp() const;
  ::cockroach::roachpb::Timestamp* mutable_timestamp();
  ::cockroach::roachpb::Timestamp* release_timestamp();
  void set_allocated_timestamp(::cockroach::roachpb::Timestamp* timestamp);

  // optional .cockroach.roachpb.ReplicaDescriptor replica = 2;
  bool has_replica() const;
  void clear_replica();
  static const int kReplicaFieldNumber = 2;
  const ::cockroach::roachpb::ReplicaDescriptor& replica() const;
  ::cockroach::roachpb::ReplicaDescriptor* mutable_replica();
  ::cockroach::roachpb::ReplicaDescriptor* release_replica();
  void set_allocated_replica(::cockroach::roachpb::ReplicaDescriptor* replica);

  // optional int64 range_id = 3;
  bool has_range_id() const;
  void clear_range_id();
  static const int kRangeIdFieldNumber = 3;
  ::google::protobuf::int64 range_id() const;
  void set_range_id(::google::protobuf::int64 value);

  // optional double user_priority = 4;
  bool has_user_priority() const;
  void clear_user_priority();
  static const int kUserPriorityFieldNumber = 4;
  double user_priority() const;
  void set_user_priority(double value);

  // optional .cockroach.roachpb.Transaction txn = 5;
  bool has_txn() const;
  void clear_txn();
  static const int kTxnFieldNumber = 5;
  const ::cockroach::roachpb::Transaction& txn() const;
  ::cockroach::roachpb::Transaction* mutable_txn();
  ::cockroach::roachpb::Transaction* release_txn();
  void set_allocated_txn(::cockroach::roachpb::Transaction* txn);

  // optional .cockroach.roachpb.ReadConsistencyType read_consistency = 6;
  bool has_read_consistency() const;
  void clear_read_consistency();
  static const int kReadConsistencyFieldNumber = 6;
  ::cockroach::roachpb::ReadConsistencyType read_consistency() const;
  void set_read_consistency(::cockroach::roachpb::ReadConsistencyType value);

  // optional .cockroach.util.tracing.Span trace = 7;
  bool has_trace() const;
  void clear_trace();
  static const int kTraceFieldNumber = 7;
  const ::cockroach::util::tracing::Span& trace() const;
  ::cockroach::util::tracing::Span* mutable_trace();
  ::cockroach::util::tracing::Span* release_trace();
  void set_allocated_trace(::cockroach::util::tracing::Span* trace);

  // optional int64 max_scan_results = 8;
  bool has_max_scan_results() const;
  void clear_max_scan_results();
  static const int kMaxScanResultsFieldNumber = 8;
  ::google::protobuf::int64 max_scan_results() const;
  void set_max_scan_results(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:cockroach.roachpb.Header)
 private:
  inline void set_has_timestamp();
  inline void clear_has_timestamp();
  inline void set_has_replica();
  inline void clear_has_replica();
  inline void set_has_range_id();
  inline void clear_has_range_id();
  inline void set_has_user_priority();
  inline void clear_has_user_priority();
  inline void set_has_txn();
  inline void clear_has_txn();
  inline void set_has_read_consistency();
  inline void clear_has_read_consistency();
  inline void set_has_trace();
  inline void clear_has_trace();
  inline void set_has_max_scan_results();
  inline void clear_has_max_scan_results();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::cockroach::roachpb::Timestamp* timestamp_;
  ::cockroach::roachpb::ReplicaDescriptor* replica_;
  ::google::protobuf::int64 range_id_;
  double user_priority_;
  ::cockroach::roachpb::Transaction* txn_;
  ::cockroach::util::tracing::Span* trace_;
  ::google::protobuf::int64 max_scan_results_;
  int read_consistency_;
  friend void  protobuf_AddDesc_cockroach_2froachpb_2fapi_2eproto();
  friend void protobuf_AssignDesc_cockroach_2froachpb_2fapi_2eproto();
  friend void protobuf_ShutdownFile_cockroach_2froachpb_2fapi_2eproto();

  void InitAsDefaultInstance();
  static Header* default_instance_;
};
// -------------------------------------------------------------------

class BatchRequest : public ::google::protobuf::Message {
 public:
  BatchRequest();
  virtual ~BatchRequest();

  BatchRequest(const BatchRequest& from);

  inline BatchRequest& operator=(const BatchRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BatchRequest& default_instance();

  void Swap(BatchRequest* other);

  // implements Message ----------------------------------------------

  inline BatchRequest* New() const { return New(NULL); }

  BatchRequest* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BatchRequest& from);
  void MergeFrom(const BatchRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(BatchRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .cockroach.roachpb.Header header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::cockroach::roachpb::Header& header() const;
  ::cockroach::roachpb::Header* mutable_header();
  ::cockroach::roachpb::Header* release_header();
  void set_allocated_header(::cockroach::roachpb::Header* header);

  // repeated .cockroach.roachpb.RequestUnion requests = 2;
  int requests_size() const;
  void clear_requests();
  static const int kRequestsFieldNumber = 2;
  const ::cockroach::roachpb::RequestUnion& requests(int index) const;
  ::cockroach::roachpb::RequestUnion* mutable_requests(int index);
  ::cockroach::roachpb::RequestUnion* add_requests();
  ::google::protobuf::RepeatedPtrField< ::cockroach::roachpb::RequestUnion >*
      mutable_requests();
  const ::google::protobuf::RepeatedPtrField< ::cockroach::roachpb::RequestUnion >&
      requests() const;

  // @@protoc_insertion_point(class_scope:cockroach.roachpb.BatchRequest)
 private:
  inline void set_has_header();
  inline void clear_has_header();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::cockroach::roachpb::Header* header_;
  ::google::protobuf::RepeatedPtrField< ::cockroach::roachpb::RequestUnion > requests_;
  friend void  protobuf_AddDesc_cockroach_2froachpb_2fapi_2eproto();
  friend void protobuf_AssignDesc_cockroach_2froachpb_2fapi_2eproto();
  friend void protobuf_ShutdownFile_cockroach_2froachpb_2fapi_2eproto();

  void InitAsDefaultInstance();
  static BatchRequest* default_instance_;
};
// -------------------------------------------------------------------

class BatchResponse_Header : public ::google::protobuf::Message {
 public:
  BatchResponse_Header();
  virtual ~BatchResponse_Header();

  BatchResponse_Header(const BatchResponse_Header& from);

  inline BatchResponse_Header& operator=(const BatchResponse_Header& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BatchResponse_Header& default_instance();

  void Swap(BatchResponse_Header* other);

  // implements Message ----------------------------------------------

  inline BatchResponse_Header* New() const { return New(NULL); }

  BatchResponse_Header* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BatchResponse_Header& from);
  void MergeFrom(const BatchResponse_Header& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(BatchResponse_Header* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .cockroach.roachpb.Error error = 1;
  bool has_error() const;
  void clear_error();
  static const int kErrorFieldNumber = 1;
  const ::cockroach::roachpb::Error& error() const;
  ::cockroach::roachpb::Error* mutable_error();
  ::cockroach::roachpb::Error* release_error();
  void set_allocated_error(::cockroach::roachpb::Error* error);

  // optional .cockroach.roachpb.Timestamp Timestamp = 2;
  bool has_timestamp() const;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 2;
  const ::cockroach::roachpb::Timestamp& timestamp() const;
  ::cockroach::roachpb::Timestamp* mutable_timestamp();
  ::cockroach::roachpb::Timestamp* release_timestamp();
  void set_allocated_timestamp(::cockroach::roachpb::Timestamp* timestamp);

  // optional .cockroach.roachpb.Transaction txn = 3;
  bool has_txn() const;
  void clear_txn();
  static const int kTxnFieldNumber = 3;
  const ::cockroach::roachpb::Transaction& txn() const;
  ::cockroach::roachpb::Transaction* mutable_txn();
  ::cockroach::roachpb::Transaction* release_txn();
  void set_allocated_txn(::cockroach::roachpb::Transaction* txn);

  // repeated bytes collected_spans = 4;
  int collected_spans_size() const;
  void clear_collected_spans();
  static const int kCollectedSpansFieldNumber = 4;
  const ::std::string& collected_spans(int index) const;
  ::std::string* mutable_collected_spans(int index);
  void set_collected_spans(int index, const ::std::string& value);
  void set_collected_spans(int index, const char* value);
  void set_collected_spans(int index, const void* value, size_t size);
  ::std::string* add_collected_spans();
  void add_collected_spans(const ::std::string& value);
  void add_collected_spans(const char* value);
  void add_collected_spans(const void* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& collected_spans() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_collected_spans();

  // optional .cockroach.roachpb.Timestamp now = 5;
  bool has_now() const;
  void clear_now();
  static const int kNowFieldNumber = 5;
  const ::cockroach::roachpb::Timestamp& now() const;
  ::cockroach::roachpb::Timestamp* mutable_now();
  ::cockroach::roachpb::Timestamp* release_now();
  void set_allocated_now(::cockroach::roachpb::Timestamp* now);

  // @@protoc_insertion_point(class_scope:cockroach.roachpb.BatchResponse.Header)
 private:
  inline void set_has_error();
  inline void clear_has_error();
  inline void set_has_timestamp();
  inline void clear_has_timestamp();
  inline void set_has_txn();
  inline void clear_has_txn();
  inline void set_has_now();
  inline void clear_has_now();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::cockroach::roachpb::Error* error_;
  ::cockroach::roachpb::Timestamp* timestamp_;
  ::cockroach::roachpb::Transaction* txn_;
  ::google::protobuf::RepeatedPtrField< ::std::string> collected_spans_;
  ::cockroach::roachpb::Timestamp* now_;
  friend void  protobuf_AddDesc_cockroach_2froachpb_2fapi_2eproto();
  friend void protobuf_AssignDesc_cockroach_2froachpb_2fapi_2eproto();
  friend void protobuf_ShutdownFile_cockroach_2froachpb_2fapi_2eproto();

  void InitAsDefaultInstance();
  static BatchResponse_Header* default_instance_;
};
// -------------------------------------------------------------------

class BatchResponse : public ::google::protobuf::Message {
 public:
  BatchResponse();
  virtual ~BatchResponse();

  BatchResponse(const BatchResponse& from);

  inline BatchResponse& operator=(const BatchResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BatchResponse& default_instance();

  void Swap(BatchResponse* other);

  // implements Message ----------------------------------------------

  inline BatchResponse* New() const { return New(NULL); }

  BatchResponse* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BatchResponse& from);
  void MergeFrom(const BatchResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(BatchResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef BatchResponse_Header Header;

  // accessors -------------------------------------------------------

  // optional .cockroach.roachpb.BatchResponse.Header header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::cockroach::roachpb::BatchResponse_Header& header() const;
  ::cockroach::roachpb::BatchResponse_Header* mutable_header();
  ::cockroach::roachpb::BatchResponse_Header* release_header();
  void set_allocated_header(::cockroach::roachpb::BatchResponse_Header* header);

  // repeated .cockroach.roachpb.ResponseUnion responses = 2;
  int responses_size() const;
  void clear_responses();
  static const int kResponsesFieldNumber = 2;
  const ::cockroach::roachpb::ResponseUnion& responses(int index) const;
  ::cockroach::roachpb::ResponseUnion* mutable_responses(int index);
  ::cockroach::roachpb::ResponseUnion* add_responses();
  ::google::protobuf::RepeatedPtrField< ::cockroach::roachpb::ResponseUnion >*
      mutable_responses();
  const ::google::protobuf::RepeatedPtrField< ::cockroach::roachpb::ResponseUnion >&
      responses() const;

  // @@protoc_insertion_point(class_scope:cockroach.roachpb.BatchResponse)
 private:
  inline void set_has_header();
  inline void clear_has_header();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::cockroach::roachpb::BatchResponse_Header* header_;
  ::google::protobuf::RepeatedPtrField< ::cockroach::roachpb::ResponseUnion > responses_;
  friend void  protobuf_AddDesc_cockroach_2froachpb_2fapi_2eproto();
  friend void protobuf_AssignDesc_cockroach_2froachpb_2fapi_2eproto();
  friend void protobuf_ShutdownFile_cockroach_2froachpb_2fapi_2eproto();

  void InitAsDefaultInstance();
  static BatchResponse* default_instance_;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// ResponseHeader

// optional .cockroach.roachpb.Transaction txn = 3;
inline bool ResponseHeader::has_txn() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResponseHeader::set_has_txn() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResponseHeader::clear_has_txn() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResponseHeader::clear_txn() {
  if (txn_ != NULL) txn_->::cockroach::roachpb::Transaction::Clear();
  clear_has_txn();
}
inline const ::cockroach::roachpb::Transaction& ResponseHeader::txn() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.ResponseHeader.txn)
  return txn_ != NULL ? *txn_ : *default_instance_->txn_;
}
inline ::cockroach::roachpb::Transaction* ResponseHeader::mutable_txn() {
  set_has_txn();
  if (txn_ == NULL) {
    txn_ = new ::cockroach::roachpb::Transaction;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.ResponseHeader.txn)
  return txn_;
}
inline ::cockroach::roachpb::Transaction* ResponseHeader::release_txn() {
  clear_has_txn();
  ::cockroach::roachpb::Transaction* temp = txn_;
  txn_ = NULL;
  return temp;
}
inline void ResponseHeader::set_allocated_txn(::cockroach::roachpb::Transaction* txn) {
  delete txn_;
  txn_ = txn;
  if (txn) {
    set_has_txn();
  } else {
    clear_has_txn();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.ResponseHeader.txn)
}

// -------------------------------------------------------------------

// GetRequest

// optional .cockroach.roachpb.Span header = 1;
inline bool GetRequest::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetRequest::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetRequest::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetRequest::clear_header() {
  if (header_ != NULL) header_->::cockroach::roachpb::Span::Clear();
  clear_has_header();
}
inline const ::cockroach::roachpb::Span& GetRequest::header() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.GetRequest.header)
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
inline ::cockroach::roachpb::Span* GetRequest::mutable_header() {
  set_has_header();
  if (header_ == NULL) {
    header_ = new ::cockroach::roachpb::Span;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.GetRequest.header)
  return header_;
}
inline ::cockroach::roachpb::Span* GetRequest::release_header() {
  clear_has_header();
  ::cockroach::roachpb::Span* temp = header_;
  header_ = NULL;
  return temp;
}
inline void GetRequest::set_allocated_header(::cockroach::roachpb::Span* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.GetRequest.header)
}

// -------------------------------------------------------------------

// GetResponse

// optional .cockroach.roachpb.ResponseHeader header = 1;
inline bool GetResponse::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetResponse::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetResponse::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetResponse::clear_header() {
  if (header_ != NULL) header_->::cockroach::roachpb::ResponseHeader::Clear();
  clear_has_header();
}
inline const ::cockroach::roachpb::ResponseHeader& GetResponse::header() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.GetResponse.header)
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
inline ::cockroach::roachpb::ResponseHeader* GetResponse::mutable_header() {
  set_has_header();
  if (header_ == NULL) {
    header_ = new ::cockroach::roachpb::ResponseHeader;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.GetResponse.header)
  return header_;
}
inline ::cockroach::roachpb::ResponseHeader* GetResponse::release_header() {
  clear_has_header();
  ::cockroach::roachpb::ResponseHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void GetResponse::set_allocated_header(::cockroach::roachpb::ResponseHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.GetResponse.header)
}

// optional .cockroach.roachpb.Value value = 2;
inline bool GetResponse::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetResponse::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetResponse::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetResponse::clear_value() {
  if (value_ != NULL) value_->::cockroach::roachpb::Value::Clear();
  clear_has_value();
}
inline const ::cockroach::roachpb::Value& GetResponse::value() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.GetResponse.value)
  return value_ != NULL ? *value_ : *default_instance_->value_;
}
inline ::cockroach::roachpb::Value* GetResponse::mutable_value() {
  set_has_value();
  if (value_ == NULL) {
    value_ = new ::cockroach::roachpb::Value;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.GetResponse.value)
  return value_;
}
inline ::cockroach::roachpb::Value* GetResponse::release_value() {
  clear_has_value();
  ::cockroach::roachpb::Value* temp = value_;
  value_ = NULL;
  return temp;
}
inline void GetResponse::set_allocated_value(::cockroach::roachpb::Value* value) {
  delete value_;
  value_ = value;
  if (value) {
    set_has_value();
  } else {
    clear_has_value();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.GetResponse.value)
}

// -------------------------------------------------------------------

// PutRequest

// optional .cockroach.roachpb.Span header = 1;
inline bool PutRequest::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PutRequest::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PutRequest::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PutRequest::clear_header() {
  if (header_ != NULL) header_->::cockroach::roachpb::Span::Clear();
  clear_has_header();
}
inline const ::cockroach::roachpb::Span& PutRequest::header() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.PutRequest.header)
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
inline ::cockroach::roachpb::Span* PutRequest::mutable_header() {
  set_has_header();
  if (header_ == NULL) {
    header_ = new ::cockroach::roachpb::Span;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.PutRequest.header)
  return header_;
}
inline ::cockroach::roachpb::Span* PutRequest::release_header() {
  clear_has_header();
  ::cockroach::roachpb::Span* temp = header_;
  header_ = NULL;
  return temp;
}
inline void PutRequest::set_allocated_header(::cockroach::roachpb::Span* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.PutRequest.header)
}

// optional .cockroach.roachpb.Value value = 2;
inline bool PutRequest::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PutRequest::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PutRequest::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PutRequest::clear_value() {
  if (value_ != NULL) value_->::cockroach::roachpb::Value::Clear();
  clear_has_value();
}
inline const ::cockroach::roachpb::Value& PutRequest::value() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.PutRequest.value)
  return value_ != NULL ? *value_ : *default_instance_->value_;
}
inline ::cockroach::roachpb::Value* PutRequest::mutable_value() {
  set_has_value();
  if (value_ == NULL) {
    value_ = new ::cockroach::roachpb::Value;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.PutRequest.value)
  return value_;
}
inline ::cockroach::roachpb::Value* PutRequest::release_value() {
  clear_has_value();
  ::cockroach::roachpb::Value* temp = value_;
  value_ = NULL;
  return temp;
}
inline void PutRequest::set_allocated_value(::cockroach::roachpb::Value* value) {
  delete value_;
  value_ = value;
  if (value) {
    set_has_value();
  } else {
    clear_has_value();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.PutRequest.value)
}

// -------------------------------------------------------------------

// PutResponse

// optional .cockroach.roachpb.ResponseHeader header = 1;
inline bool PutResponse::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PutResponse::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PutResponse::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PutResponse::clear_header() {
  if (header_ != NULL) header_->::cockroach::roachpb::ResponseHeader::Clear();
  clear_has_header();
}
inline const ::cockroach::roachpb::ResponseHeader& PutResponse::header() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.PutResponse.header)
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
inline ::cockroach::roachpb::ResponseHeader* PutResponse::mutable_header() {
  set_has_header();
  if (header_ == NULL) {
    header_ = new ::cockroach::roachpb::ResponseHeader;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.PutResponse.header)
  return header_;
}
inline ::cockroach::roachpb::ResponseHeader* PutResponse::release_header() {
  clear_has_header();
  ::cockroach::roachpb::ResponseHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void PutResponse::set_allocated_header(::cockroach::roachpb::ResponseHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.PutResponse.header)
}

// -------------------------------------------------------------------

// ConditionalPutRequest

// optional .cockroach.roachpb.Span header = 1;
inline bool ConditionalPutRequest::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ConditionalPutRequest::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ConditionalPutRequest::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ConditionalPutRequest::clear_header() {
  if (header_ != NULL) header_->::cockroach::roachpb::Span::Clear();
  clear_has_header();
}
inline const ::cockroach::roachpb::Span& ConditionalPutRequest::header() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.ConditionalPutRequest.header)
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
inline ::cockroach::roachpb::Span* ConditionalPutRequest::mutable_header() {
  set_has_header();
  if (header_ == NULL) {
    header_ = new ::cockroach::roachpb::Span;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.ConditionalPutRequest.header)
  return header_;
}
inline ::cockroach::roachpb::Span* ConditionalPutRequest::release_header() {
  clear_has_header();
  ::cockroach::roachpb::Span* temp = header_;
  header_ = NULL;
  return temp;
}
inline void ConditionalPutRequest::set_allocated_header(::cockroach::roachpb::Span* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.ConditionalPutRequest.header)
}

// optional .cockroach.roachpb.Value value = 2;
inline bool ConditionalPutRequest::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ConditionalPutRequest::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ConditionalPutRequest::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ConditionalPutRequest::clear_value() {
  if (value_ != NULL) value_->::cockroach::roachpb::Value::Clear();
  clear_has_value();
}
inline const ::cockroach::roachpb::Value& ConditionalPutRequest::value() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.ConditionalPutRequest.value)
  return value_ != NULL ? *value_ : *default_instance_->value_;
}
inline ::cockroach::roachpb::Value* ConditionalPutRequest::mutable_value() {
  set_has_value();
  if (value_ == NULL) {
    value_ = new ::cockroach::roachpb::Value;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.ConditionalPutRequest.value)
  return value_;
}
inline ::cockroach::roachpb::Value* ConditionalPutRequest::release_value() {
  clear_has_value();
  ::cockroach::roachpb::Value* temp = value_;
  value_ = NULL;
  return temp;
}
inline void ConditionalPutRequest::set_allocated_value(::cockroach::roachpb::Value* value) {
  delete value_;
  value_ = value;
  if (value) {
    set_has_value();
  } else {
    clear_has_value();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.ConditionalPutRequest.value)
}

// optional .cockroach.roachpb.Value exp_value = 3;
inline bool ConditionalPutRequest::has_exp_value() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ConditionalPutRequest::set_has_exp_value() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ConditionalPutRequest::clear_has_exp_value() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ConditionalPutRequest::clear_exp_value() {
  if (exp_value_ != NULL) exp_value_->::cockroach::roachpb::Value::Clear();
  clear_has_exp_value();
}
inline const ::cockroach::roachpb::Value& ConditionalPutRequest::exp_value() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.ConditionalPutRequest.exp_value)
  return exp_value_ != NULL ? *exp_value_ : *default_instance_->exp_value_;
}
inline ::cockroach::roachpb::Value* ConditionalPutRequest::mutable_exp_value() {
  set_has_exp_value();
  if (exp_value_ == NULL) {
    exp_value_ = new ::cockroach::roachpb::Value;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.ConditionalPutRequest.exp_value)
  return exp_value_;
}
inline ::cockroach::roachpb::Value* ConditionalPutRequest::release_exp_value() {
  clear_has_exp_value();
  ::cockroach::roachpb::Value* temp = exp_value_;
  exp_value_ = NULL;
  return temp;
}
inline void ConditionalPutRequest::set_allocated_exp_value(::cockroach::roachpb::Value* exp_value) {
  delete exp_value_;
  exp_value_ = exp_value;
  if (exp_value) {
    set_has_exp_value();
  } else {
    clear_has_exp_value();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.ConditionalPutRequest.exp_value)
}

// -------------------------------------------------------------------

// ConditionalPutResponse

// optional .cockroach.roachpb.ResponseHeader header = 1;
inline bool ConditionalPutResponse::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ConditionalPutResponse::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ConditionalPutResponse::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ConditionalPutResponse::clear_header() {
  if (header_ != NULL) header_->::cockroach::roachpb::ResponseHeader::Clear();
  clear_has_header();
}
inline const ::cockroach::roachpb::ResponseHeader& ConditionalPutResponse::header() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.ConditionalPutResponse.header)
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
inline ::cockroach::roachpb::ResponseHeader* ConditionalPutResponse::mutable_header() {
  set_has_header();
  if (header_ == NULL) {
    header_ = new ::cockroach::roachpb::ResponseHeader;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.ConditionalPutResponse.header)
  return header_;
}
inline ::cockroach::roachpb::ResponseHeader* ConditionalPutResponse::release_header() {
  clear_has_header();
  ::cockroach::roachpb::ResponseHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void ConditionalPutResponse::set_allocated_header(::cockroach::roachpb::ResponseHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.ConditionalPutResponse.header)
}

// -------------------------------------------------------------------

// IncrementRequest

// optional .cockroach.roachpb.Span header = 1;
inline bool IncrementRequest::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IncrementRequest::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IncrementRequest::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IncrementRequest::clear_header() {
  if (header_ != NULL) header_->::cockroach::roachpb::Span::Clear();
  clear_has_header();
}
inline const ::cockroach::roachpb::Span& IncrementRequest::header() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.IncrementRequest.header)
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
inline ::cockroach::roachpb::Span* IncrementRequest::mutable_header() {
  set_has_header();
  if (header_ == NULL) {
    header_ = new ::cockroach::roachpb::Span;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.IncrementRequest.header)
  return header_;
}
inline ::cockroach::roachpb::Span* IncrementRequest::release_header() {
  clear_has_header();
  ::cockroach::roachpb::Span* temp = header_;
  header_ = NULL;
  return temp;
}
inline void IncrementRequest::set_allocated_header(::cockroach::roachpb::Span* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.IncrementRequest.header)
}

// optional int64 increment = 2;
inline bool IncrementRequest::has_increment() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IncrementRequest::set_has_increment() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IncrementRequest::clear_has_increment() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IncrementRequest::clear_increment() {
  increment_ = GOOGLE_LONGLONG(0);
  clear_has_increment();
}
inline ::google::protobuf::int64 IncrementRequest::increment() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.IncrementRequest.increment)
  return increment_;
}
inline void IncrementRequest::set_increment(::google::protobuf::int64 value) {
  set_has_increment();
  increment_ = value;
  // @@protoc_insertion_point(field_set:cockroach.roachpb.IncrementRequest.increment)
}

// -------------------------------------------------------------------

// IncrementResponse

// optional .cockroach.roachpb.ResponseHeader header = 1;
inline bool IncrementResponse::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IncrementResponse::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IncrementResponse::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IncrementResponse::clear_header() {
  if (header_ != NULL) header_->::cockroach::roachpb::ResponseHeader::Clear();
  clear_has_header();
}
inline const ::cockroach::roachpb::ResponseHeader& IncrementResponse::header() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.IncrementResponse.header)
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
inline ::cockroach::roachpb::ResponseHeader* IncrementResponse::mutable_header() {
  set_has_header();
  if (header_ == NULL) {
    header_ = new ::cockroach::roachpb::ResponseHeader;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.IncrementResponse.header)
  return header_;
}
inline ::cockroach::roachpb::ResponseHeader* IncrementResponse::release_header() {
  clear_has_header();
  ::cockroach::roachpb::ResponseHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void IncrementResponse::set_allocated_header(::cockroach::roachpb::ResponseHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.IncrementResponse.header)
}

// optional int64 new_value = 2;
inline bool IncrementResponse::has_new_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IncrementResponse::set_has_new_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IncrementResponse::clear_has_new_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IncrementResponse::clear_new_value() {
  new_value_ = GOOGLE_LONGLONG(0);
  clear_has_new_value();
}
inline ::google::protobuf::int64 IncrementResponse::new_value() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.IncrementResponse.new_value)
  return new_value_;
}
inline void IncrementResponse::set_new_value(::google::protobuf::int64 value) {
  set_has_new_value();
  new_value_ = value;
  // @@protoc_insertion_point(field_set:cockroach.roachpb.IncrementResponse.new_value)
}

// -------------------------------------------------------------------

// DeleteRequest

// optional .cockroach.roachpb.Span header = 1;
inline bool DeleteRequest::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DeleteRequest::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DeleteRequest::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DeleteRequest::clear_header() {
  if (header_ != NULL) header_->::cockroach::roachpb::Span::Clear();
  clear_has_header();
}
inline const ::cockroach::roachpb::Span& DeleteRequest::header() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.DeleteRequest.header)
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
inline ::cockroach::roachpb::Span* DeleteRequest::mutable_header() {
  set_has_header();
  if (header_ == NULL) {
    header_ = new ::cockroach::roachpb::Span;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.DeleteRequest.header)
  return header_;
}
inline ::cockroach::roachpb::Span* DeleteRequest::release_header() {
  clear_has_header();
  ::cockroach::roachpb::Span* temp = header_;
  header_ = NULL;
  return temp;
}
inline void DeleteRequest::set_allocated_header(::cockroach::roachpb::Span* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.DeleteRequest.header)
}

// -------------------------------------------------------------------

// DeleteResponse

// optional .cockroach.roachpb.ResponseHeader header = 1;
inline bool DeleteResponse::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DeleteResponse::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DeleteResponse::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DeleteResponse::clear_header() {
  if (header_ != NULL) header_->::cockroach::roachpb::ResponseHeader::Clear();
  clear_has_header();
}
inline const ::cockroach::roachpb::ResponseHeader& DeleteResponse::header() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.DeleteResponse.header)
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
inline ::cockroach::roachpb::ResponseHeader* DeleteResponse::mutable_header() {
  set_has_header();
  if (header_ == NULL) {
    header_ = new ::cockroach::roachpb::ResponseHeader;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.DeleteResponse.header)
  return header_;
}
inline ::cockroach::roachpb::ResponseHeader* DeleteResponse::release_header() {
  clear_has_header();
  ::cockroach::roachpb::ResponseHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void DeleteResponse::set_allocated_header(::cockroach::roachpb::ResponseHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.DeleteResponse.header)
}

// -------------------------------------------------------------------

// DeleteRangeRequest

// optional .cockroach.roachpb.Span header = 1;
inline bool DeleteRangeRequest::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DeleteRangeRequest::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DeleteRangeRequest::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DeleteRangeRequest::clear_header() {
  if (header_ != NULL) header_->::cockroach::roachpb::Span::Clear();
  clear_has_header();
}
inline const ::cockroach::roachpb::Span& DeleteRangeRequest::header() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.DeleteRangeRequest.header)
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
inline ::cockroach::roachpb::Span* DeleteRangeRequest::mutable_header() {
  set_has_header();
  if (header_ == NULL) {
    header_ = new ::cockroach::roachpb::Span;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.DeleteRangeRequest.header)
  return header_;
}
inline ::cockroach::roachpb::Span* DeleteRangeRequest::release_header() {
  clear_has_header();
  ::cockroach::roachpb::Span* temp = header_;
  header_ = NULL;
  return temp;
}
inline void DeleteRangeRequest::set_allocated_header(::cockroach::roachpb::Span* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.DeleteRangeRequest.header)
}

// optional int64 max_entries_to_delete = 2;
inline bool DeleteRangeRequest::has_max_entries_to_delete() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DeleteRangeRequest::set_has_max_entries_to_delete() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DeleteRangeRequest::clear_has_max_entries_to_delete() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DeleteRangeRequest::clear_max_entries_to_delete() {
  max_entries_to_delete_ = GOOGLE_LONGLONG(0);
  clear_has_max_entries_to_delete();
}
inline ::google::protobuf::int64 DeleteRangeRequest::max_entries_to_delete() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.DeleteRangeRequest.max_entries_to_delete)
  return max_entries_to_delete_;
}
inline void DeleteRangeRequest::set_max_entries_to_delete(::google::protobuf::int64 value) {
  set_has_max_entries_to_delete();
  max_entries_to_delete_ = value;
  // @@protoc_insertion_point(field_set:cockroach.roachpb.DeleteRangeRequest.max_entries_to_delete)
}

// optional bool return_keys = 3;
inline bool DeleteRangeRequest::has_return_keys() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DeleteRangeRequest::set_has_return_keys() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DeleteRangeRequest::clear_has_return_keys() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DeleteRangeRequest::clear_return_keys() {
  return_keys_ = false;
  clear_has_return_keys();
}
inline bool DeleteRangeRequest::return_keys() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.DeleteRangeRequest.return_keys)
  return return_keys_;
}
inline void DeleteRangeRequest::set_return_keys(bool value) {
  set_has_return_keys();
  return_keys_ = value;
  // @@protoc_insertion_point(field_set:cockroach.roachpb.DeleteRangeRequest.return_keys)
}

// -------------------------------------------------------------------

// DeleteRangeResponse

// optional .cockroach.roachpb.ResponseHeader header = 1;
inline bool DeleteRangeResponse::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DeleteRangeResponse::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DeleteRangeResponse::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DeleteRangeResponse::clear_header() {
  if (header_ != NULL) header_->::cockroach::roachpb::ResponseHeader::Clear();
  clear_has_header();
}
inline const ::cockroach::roachpb::ResponseHeader& DeleteRangeResponse::header() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.DeleteRangeResponse.header)
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
inline ::cockroach::roachpb::ResponseHeader* DeleteRangeResponse::mutable_header() {
  set_has_header();
  if (header_ == NULL) {
    header_ = new ::cockroach::roachpb::ResponseHeader;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.DeleteRangeResponse.header)
  return header_;
}
inline ::cockroach::roachpb::ResponseHeader* DeleteRangeResponse::release_header() {
  clear_has_header();
  ::cockroach::roachpb::ResponseHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void DeleteRangeResponse::set_allocated_header(::cockroach::roachpb::ResponseHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.DeleteRangeResponse.header)
}

// repeated bytes keys = 2;
inline int DeleteRangeResponse::keys_size() const {
  return keys_.size();
}
inline void DeleteRangeResponse::clear_keys() {
  keys_.Clear();
}
inline const ::std::string& DeleteRangeResponse::keys(int index) const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.DeleteRangeResponse.keys)
  return keys_.Get(index);
}
inline ::std::string* DeleteRangeResponse::mutable_keys(int index) {
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.DeleteRangeResponse.keys)
  return keys_.Mutable(index);
}
inline void DeleteRangeResponse::set_keys(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:cockroach.roachpb.DeleteRangeResponse.keys)
  keys_.Mutable(index)->assign(value);
}
inline void DeleteRangeResponse::set_keys(int index, const char* value) {
  keys_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:cockroach.roachpb.DeleteRangeResponse.keys)
}
inline void DeleteRangeResponse::set_keys(int index, const void* value, size_t size) {
  keys_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:cockroach.roachpb.DeleteRangeResponse.keys)
}
inline ::std::string* DeleteRangeResponse::add_keys() {
  return keys_.Add();
}
inline void DeleteRangeResponse::add_keys(const ::std::string& value) {
  keys_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:cockroach.roachpb.DeleteRangeResponse.keys)
}
inline void DeleteRangeResponse::add_keys(const char* value) {
  keys_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:cockroach.roachpb.DeleteRangeResponse.keys)
}
inline void DeleteRangeResponse::add_keys(const void* value, size_t size) {
  keys_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:cockroach.roachpb.DeleteRangeResponse.keys)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
DeleteRangeResponse::keys() const {
  // @@protoc_insertion_point(field_list:cockroach.roachpb.DeleteRangeResponse.keys)
  return keys_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
DeleteRangeResponse::mutable_keys() {
  // @@protoc_insertion_point(field_mutable_list:cockroach.roachpb.DeleteRangeResponse.keys)
  return &keys_;
}

// -------------------------------------------------------------------

// ScanRequest

// optional .cockroach.roachpb.Span header = 1;
inline bool ScanRequest::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ScanRequest::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ScanRequest::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ScanRequest::clear_header() {
  if (header_ != NULL) header_->::cockroach::roachpb::Span::Clear();
  clear_has_header();
}
inline const ::cockroach::roachpb::Span& ScanRequest::header() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.ScanRequest.header)
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
inline ::cockroach::roachpb::Span* ScanRequest::mutable_header() {
  set_has_header();
  if (header_ == NULL) {
    header_ = new ::cockroach::roachpb::Span;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.ScanRequest.header)
  return header_;
}
inline ::cockroach::roachpb::Span* ScanRequest::release_header() {
  clear_has_header();
  ::cockroach::roachpb::Span* temp = header_;
  header_ = NULL;
  return temp;
}
inline void ScanRequest::set_allocated_header(::cockroach::roachpb::Span* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.ScanRequest.header)
}

// optional int64 max_results = 2;
inline bool ScanRequest::has_max_results() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ScanRequest::set_has_max_results() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ScanRequest::clear_has_max_results() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ScanRequest::clear_max_results() {
  max_results_ = GOOGLE_LONGLONG(0);
  clear_has_max_results();
}
inline ::google::protobuf::int64 ScanRequest::max_results() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.ScanRequest.max_results)
  return max_results_;
}
inline void ScanRequest::set_max_results(::google::protobuf::int64 value) {
  set_has_max_results();
  max_results_ = value;
  // @@protoc_insertion_point(field_set:cockroach.roachpb.ScanRequest.max_results)
}

// -------------------------------------------------------------------

// ScanResponse

// optional .cockroach.roachpb.ResponseHeader header = 1;
inline bool ScanResponse::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ScanResponse::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ScanResponse::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ScanResponse::clear_header() {
  if (header_ != NULL) header_->::cockroach::roachpb::ResponseHeader::Clear();
  clear_has_header();
}
inline const ::cockroach::roachpb::ResponseHeader& ScanResponse::header() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.ScanResponse.header)
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
inline ::cockroach::roachpb::ResponseHeader* ScanResponse::mutable_header() {
  set_has_header();
  if (header_ == NULL) {
    header_ = new ::cockroach::roachpb::ResponseHeader;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.ScanResponse.header)
  return header_;
}
inline ::cockroach::roachpb::ResponseHeader* ScanResponse::release_header() {
  clear_has_header();
  ::cockroach::roachpb::ResponseHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void ScanResponse::set_allocated_header(::cockroach::roachpb::ResponseHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.ScanResponse.header)
}

// repeated .cockroach.roachpb.KeyValue rows = 2;
inline int ScanResponse::rows_size() const {
  return rows_.size();
}
inline void ScanResponse::clear_rows() {
  rows_.Clear();
}
inline const ::cockroach::roachpb::KeyValue& ScanResponse::rows(int index) const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.ScanResponse.rows)
  return rows_.Get(index);
}
inline ::cockroach::roachpb::KeyValue* ScanResponse::mutable_rows(int index) {
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.ScanResponse.rows)
  return rows_.Mutable(index);
}
inline ::cockroach::roachpb::KeyValue* ScanResponse::add_rows() {
  // @@protoc_insertion_point(field_add:cockroach.roachpb.ScanResponse.rows)
  return rows_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::cockroach::roachpb::KeyValue >*
ScanResponse::mutable_rows() {
  // @@protoc_insertion_point(field_mutable_list:cockroach.roachpb.ScanResponse.rows)
  return &rows_;
}
inline const ::google::protobuf::RepeatedPtrField< ::cockroach::roachpb::KeyValue >&
ScanResponse::rows() const {
  // @@protoc_insertion_point(field_list:cockroach.roachpb.ScanResponse.rows)
  return rows_;
}

// -------------------------------------------------------------------

// ReverseScanRequest

// optional .cockroach.roachpb.Span header = 1;
inline bool ReverseScanRequest::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReverseScanRequest::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReverseScanRequest::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReverseScanRequest::clear_header() {
  if (header_ != NULL) header_->::cockroach::roachpb::Span::Clear();
  clear_has_header();
}
inline const ::cockroach::roachpb::Span& ReverseScanRequest::header() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.ReverseScanRequest.header)
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
inline ::cockroach::roachpb::Span* ReverseScanRequest::mutable_header() {
  set_has_header();
  if (header_ == NULL) {
    header_ = new ::cockroach::roachpb::Span;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.ReverseScanRequest.header)
  return header_;
}
inline ::cockroach::roachpb::Span* ReverseScanRequest::release_header() {
  clear_has_header();
  ::cockroach::roachpb::Span* temp = header_;
  header_ = NULL;
  return temp;
}
inline void ReverseScanRequest::set_allocated_header(::cockroach::roachpb::Span* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.ReverseScanRequest.header)
}

// optional int64 max_results = 2;
inline bool ReverseScanRequest::has_max_results() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ReverseScanRequest::set_has_max_results() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ReverseScanRequest::clear_has_max_results() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ReverseScanRequest::clear_max_results() {
  max_results_ = GOOGLE_LONGLONG(0);
  clear_has_max_results();
}
inline ::google::protobuf::int64 ReverseScanRequest::max_results() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.ReverseScanRequest.max_results)
  return max_results_;
}
inline void ReverseScanRequest::set_max_results(::google::protobuf::int64 value) {
  set_has_max_results();
  max_results_ = value;
  // @@protoc_insertion_point(field_set:cockroach.roachpb.ReverseScanRequest.max_results)
}

// -------------------------------------------------------------------

// ReverseScanResponse

// optional .cockroach.roachpb.ResponseHeader header = 1;
inline bool ReverseScanResponse::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReverseScanResponse::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReverseScanResponse::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReverseScanResponse::clear_header() {
  if (header_ != NULL) header_->::cockroach::roachpb::ResponseHeader::Clear();
  clear_has_header();
}
inline const ::cockroach::roachpb::ResponseHeader& ReverseScanResponse::header() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.ReverseScanResponse.header)
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
inline ::cockroach::roachpb::ResponseHeader* ReverseScanResponse::mutable_header() {
  set_has_header();
  if (header_ == NULL) {
    header_ = new ::cockroach::roachpb::ResponseHeader;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.ReverseScanResponse.header)
  return header_;
}
inline ::cockroach::roachpb::ResponseHeader* ReverseScanResponse::release_header() {
  clear_has_header();
  ::cockroach::roachpb::ResponseHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void ReverseScanResponse::set_allocated_header(::cockroach::roachpb::ResponseHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.ReverseScanResponse.header)
}

// repeated .cockroach.roachpb.KeyValue rows = 2;
inline int ReverseScanResponse::rows_size() const {
  return rows_.size();
}
inline void ReverseScanResponse::clear_rows() {
  rows_.Clear();
}
inline const ::cockroach::roachpb::KeyValue& ReverseScanResponse::rows(int index) const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.ReverseScanResponse.rows)
  return rows_.Get(index);
}
inline ::cockroach::roachpb::KeyValue* ReverseScanResponse::mutable_rows(int index) {
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.ReverseScanResponse.rows)
  return rows_.Mutable(index);
}
inline ::cockroach::roachpb::KeyValue* ReverseScanResponse::add_rows() {
  // @@protoc_insertion_point(field_add:cockroach.roachpb.ReverseScanResponse.rows)
  return rows_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::cockroach::roachpb::KeyValue >*
ReverseScanResponse::mutable_rows() {
  // @@protoc_insertion_point(field_mutable_list:cockroach.roachpb.ReverseScanResponse.rows)
  return &rows_;
}
inline const ::google::protobuf::RepeatedPtrField< ::cockroach::roachpb::KeyValue >&
ReverseScanResponse::rows() const {
  // @@protoc_insertion_point(field_list:cockroach.roachpb.ReverseScanResponse.rows)
  return rows_;
}

// -------------------------------------------------------------------

// CheckConsistencyRequest

// optional .cockroach.roachpb.Span header = 1;
inline bool CheckConsistencyRequest::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CheckConsistencyRequest::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CheckConsistencyRequest::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CheckConsistencyRequest::clear_header() {
  if (header_ != NULL) header_->::cockroach::roachpb::Span::Clear();
  clear_has_header();
}
inline const ::cockroach::roachpb::Span& CheckConsistencyRequest::header() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.CheckConsistencyRequest.header)
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
inline ::cockroach::roachpb::Span* CheckConsistencyRequest::mutable_header() {
  set_has_header();
  if (header_ == NULL) {
    header_ = new ::cockroach::roachpb::Span;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.CheckConsistencyRequest.header)
  return header_;
}
inline ::cockroach::roachpb::Span* CheckConsistencyRequest::release_header() {
  clear_has_header();
  ::cockroach::roachpb::Span* temp = header_;
  header_ = NULL;
  return temp;
}
inline void CheckConsistencyRequest::set_allocated_header(::cockroach::roachpb::Span* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.CheckConsistencyRequest.header)
}

// -------------------------------------------------------------------

// CheckConsistencyResponse

// optional .cockroach.roachpb.ResponseHeader header = 1;
inline bool CheckConsistencyResponse::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CheckConsistencyResponse::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CheckConsistencyResponse::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CheckConsistencyResponse::clear_header() {
  if (header_ != NULL) header_->::cockroach::roachpb::ResponseHeader::Clear();
  clear_has_header();
}
inline const ::cockroach::roachpb::ResponseHeader& CheckConsistencyResponse::header() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.CheckConsistencyResponse.header)
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
inline ::cockroach::roachpb::ResponseHeader* CheckConsistencyResponse::mutable_header() {
  set_has_header();
  if (header_ == NULL) {
    header_ = new ::cockroach::roachpb::ResponseHeader;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.CheckConsistencyResponse.header)
  return header_;
}
inline ::cockroach::roachpb::ResponseHeader* CheckConsistencyResponse::release_header() {
  clear_has_header();
  ::cockroach::roachpb::ResponseHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void CheckConsistencyResponse::set_allocated_header(::cockroach::roachpb::ResponseHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.CheckConsistencyResponse.header)
}

// -------------------------------------------------------------------

// BeginTransactionRequest

// optional .cockroach.roachpb.Span header = 1;
inline bool BeginTransactionRequest::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BeginTransactionRequest::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BeginTransactionRequest::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BeginTransactionRequest::clear_header() {
  if (header_ != NULL) header_->::cockroach::roachpb::Span::Clear();
  clear_has_header();
}
inline const ::cockroach::roachpb::Span& BeginTransactionRequest::header() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.BeginTransactionRequest.header)
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
inline ::cockroach::roachpb::Span* BeginTransactionRequest::mutable_header() {
  set_has_header();
  if (header_ == NULL) {
    header_ = new ::cockroach::roachpb::Span;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.BeginTransactionRequest.header)
  return header_;
}
inline ::cockroach::roachpb::Span* BeginTransactionRequest::release_header() {
  clear_has_header();
  ::cockroach::roachpb::Span* temp = header_;
  header_ = NULL;
  return temp;
}
inline void BeginTransactionRequest::set_allocated_header(::cockroach::roachpb::Span* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.BeginTransactionRequest.header)
}

// -------------------------------------------------------------------

// BeginTransactionResponse

// optional .cockroach.roachpb.ResponseHeader header = 1;
inline bool BeginTransactionResponse::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BeginTransactionResponse::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BeginTransactionResponse::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BeginTransactionResponse::clear_header() {
  if (header_ != NULL) header_->::cockroach::roachpb::ResponseHeader::Clear();
  clear_has_header();
}
inline const ::cockroach::roachpb::ResponseHeader& BeginTransactionResponse::header() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.BeginTransactionResponse.header)
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
inline ::cockroach::roachpb::ResponseHeader* BeginTransactionResponse::mutable_header() {
  set_has_header();
  if (header_ == NULL) {
    header_ = new ::cockroach::roachpb::ResponseHeader;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.BeginTransactionResponse.header)
  return header_;
}
inline ::cockroach::roachpb::ResponseHeader* BeginTransactionResponse::release_header() {
  clear_has_header();
  ::cockroach::roachpb::ResponseHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void BeginTransactionResponse::set_allocated_header(::cockroach::roachpb::ResponseHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.BeginTransactionResponse.header)
}

// -------------------------------------------------------------------

// EndTransactionRequest

// optional .cockroach.roachpb.Span header = 1;
inline bool EndTransactionRequest::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EndTransactionRequest::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EndTransactionRequest::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EndTransactionRequest::clear_header() {
  if (header_ != NULL) header_->::cockroach::roachpb::Span::Clear();
  clear_has_header();
}
inline const ::cockroach::roachpb::Span& EndTransactionRequest::header() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.EndTransactionRequest.header)
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
inline ::cockroach::roachpb::Span* EndTransactionRequest::mutable_header() {
  set_has_header();
  if (header_ == NULL) {
    header_ = new ::cockroach::roachpb::Span;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.EndTransactionRequest.header)
  return header_;
}
inline ::cockroach::roachpb::Span* EndTransactionRequest::release_header() {
  clear_has_header();
  ::cockroach::roachpb::Span* temp = header_;
  header_ = NULL;
  return temp;
}
inline void EndTransactionRequest::set_allocated_header(::cockroach::roachpb::Span* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.EndTransactionRequest.header)
}

// optional bool commit = 2;
inline bool EndTransactionRequest::has_commit() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EndTransactionRequest::set_has_commit() {
  _has_bits_[0] |= 0x00000002u;
}
inline void EndTransactionRequest::clear_has_commit() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void EndTransactionRequest::clear_commit() {
  commit_ = false;
  clear_has_commit();
}
inline bool EndTransactionRequest::commit() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.EndTransactionRequest.commit)
  return commit_;
}
inline void EndTransactionRequest::set_commit(bool value) {
  set_has_commit();
  commit_ = value;
  // @@protoc_insertion_point(field_set:cockroach.roachpb.EndTransactionRequest.commit)
}

// optional .cockroach.roachpb.Timestamp deadline = 3;
inline bool EndTransactionRequest::has_deadline() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void EndTransactionRequest::set_has_deadline() {
  _has_bits_[0] |= 0x00000004u;
}
inline void EndTransactionRequest::clear_has_deadline() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void EndTransactionRequest::clear_deadline() {
  if (deadline_ != NULL) deadline_->::cockroach::roachpb::Timestamp::Clear();
  clear_has_deadline();
}
inline const ::cockroach::roachpb::Timestamp& EndTransactionRequest::deadline() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.EndTransactionRequest.deadline)
  return deadline_ != NULL ? *deadline_ : *default_instance_->deadline_;
}
inline ::cockroach::roachpb::Timestamp* EndTransactionRequest::mutable_deadline() {
  set_has_deadline();
  if (deadline_ == NULL) {
    deadline_ = new ::cockroach::roachpb::Timestamp;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.EndTransactionRequest.deadline)
  return deadline_;
}
inline ::cockroach::roachpb::Timestamp* EndTransactionRequest::release_deadline() {
  clear_has_deadline();
  ::cockroach::roachpb::Timestamp* temp = deadline_;
  deadline_ = NULL;
  return temp;
}
inline void EndTransactionRequest::set_allocated_deadline(::cockroach::roachpb::Timestamp* deadline) {
  delete deadline_;
  deadline_ = deadline;
  if (deadline) {
    set_has_deadline();
  } else {
    clear_has_deadline();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.EndTransactionRequest.deadline)
}

// optional .cockroach.roachpb.InternalCommitTrigger internal_commit_trigger = 4;
inline bool EndTransactionRequest::has_internal_commit_trigger() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void EndTransactionRequest::set_has_internal_commit_trigger() {
  _has_bits_[0] |= 0x00000008u;
}
inline void EndTransactionRequest::clear_has_internal_commit_trigger() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void EndTransactionRequest::clear_internal_commit_trigger() {
  if (internal_commit_trigger_ != NULL) internal_commit_trigger_->::cockroach::roachpb::InternalCommitTrigger::Clear();
  clear_has_internal_commit_trigger();
}
inline const ::cockroach::roachpb::InternalCommitTrigger& EndTransactionRequest::internal_commit_trigger() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.EndTransactionRequest.internal_commit_trigger)
  return internal_commit_trigger_ != NULL ? *internal_commit_trigger_ : *default_instance_->internal_commit_trigger_;
}
inline ::cockroach::roachpb::InternalCommitTrigger* EndTransactionRequest::mutable_internal_commit_trigger() {
  set_has_internal_commit_trigger();
  if (internal_commit_trigger_ == NULL) {
    internal_commit_trigger_ = new ::cockroach::roachpb::InternalCommitTrigger;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.EndTransactionRequest.internal_commit_trigger)
  return internal_commit_trigger_;
}
inline ::cockroach::roachpb::InternalCommitTrigger* EndTransactionRequest::release_internal_commit_trigger() {
  clear_has_internal_commit_trigger();
  ::cockroach::roachpb::InternalCommitTrigger* temp = internal_commit_trigger_;
  internal_commit_trigger_ = NULL;
  return temp;
}
inline void EndTransactionRequest::set_allocated_internal_commit_trigger(::cockroach::roachpb::InternalCommitTrigger* internal_commit_trigger) {
  delete internal_commit_trigger_;
  internal_commit_trigger_ = internal_commit_trigger;
  if (internal_commit_trigger) {
    set_has_internal_commit_trigger();
  } else {
    clear_has_internal_commit_trigger();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.EndTransactionRequest.internal_commit_trigger)
}

// repeated .cockroach.roachpb.Span intent_spans = 5;
inline int EndTransactionRequest::intent_spans_size() const {
  return intent_spans_.size();
}
inline void EndTransactionRequest::clear_intent_spans() {
  intent_spans_.Clear();
}
inline const ::cockroach::roachpb::Span& EndTransactionRequest::intent_spans(int index) const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.EndTransactionRequest.intent_spans)
  return intent_spans_.Get(index);
}
inline ::cockroach::roachpb::Span* EndTransactionRequest::mutable_intent_spans(int index) {
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.EndTransactionRequest.intent_spans)
  return intent_spans_.Mutable(index);
}
inline ::cockroach::roachpb::Span* EndTransactionRequest::add_intent_spans() {
  // @@protoc_insertion_point(field_add:cockroach.roachpb.EndTransactionRequest.intent_spans)
  return intent_spans_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::cockroach::roachpb::Span >*
EndTransactionRequest::mutable_intent_spans() {
  // @@protoc_insertion_point(field_mutable_list:cockroach.roachpb.EndTransactionRequest.intent_spans)
  return &intent_spans_;
}
inline const ::google::protobuf::RepeatedPtrField< ::cockroach::roachpb::Span >&
EndTransactionRequest::intent_spans() const {
  // @@protoc_insertion_point(field_list:cockroach.roachpb.EndTransactionRequest.intent_spans)
  return intent_spans_;
}

// -------------------------------------------------------------------

// EndTransactionResponse

// optional .cockroach.roachpb.ResponseHeader header = 1;
inline bool EndTransactionResponse::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EndTransactionResponse::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EndTransactionResponse::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EndTransactionResponse::clear_header() {
  if (header_ != NULL) header_->::cockroach::roachpb::ResponseHeader::Clear();
  clear_has_header();
}
inline const ::cockroach::roachpb::ResponseHeader& EndTransactionResponse::header() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.EndTransactionResponse.header)
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
inline ::cockroach::roachpb::ResponseHeader* EndTransactionResponse::mutable_header() {
  set_has_header();
  if (header_ == NULL) {
    header_ = new ::cockroach::roachpb::ResponseHeader;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.EndTransactionResponse.header)
  return header_;
}
inline ::cockroach::roachpb::ResponseHeader* EndTransactionResponse::release_header() {
  clear_has_header();
  ::cockroach::roachpb::ResponseHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void EndTransactionResponse::set_allocated_header(::cockroach::roachpb::ResponseHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.EndTransactionResponse.header)
}

// optional int64 commit_wait = 2;
inline bool EndTransactionResponse::has_commit_wait() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EndTransactionResponse::set_has_commit_wait() {
  _has_bits_[0] |= 0x00000002u;
}
inline void EndTransactionResponse::clear_has_commit_wait() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void EndTransactionResponse::clear_commit_wait() {
  commit_wait_ = GOOGLE_LONGLONG(0);
  clear_has_commit_wait();
}
inline ::google::protobuf::int64 EndTransactionResponse::commit_wait() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.EndTransactionResponse.commit_wait)
  return commit_wait_;
}
inline void EndTransactionResponse::set_commit_wait(::google::protobuf::int64 value) {
  set_has_commit_wait();
  commit_wait_ = value;
  // @@protoc_insertion_point(field_set:cockroach.roachpb.EndTransactionResponse.commit_wait)
}

// repeated bytes resolved = 3;
inline int EndTransactionResponse::resolved_size() const {
  return resolved_.size();
}
inline void EndTransactionResponse::clear_resolved() {
  resolved_.Clear();
}
inline const ::std::string& EndTransactionResponse::resolved(int index) const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.EndTransactionResponse.resolved)
  return resolved_.Get(index);
}
inline ::std::string* EndTransactionResponse::mutable_resolved(int index) {
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.EndTransactionResponse.resolved)
  return resolved_.Mutable(index);
}
inline void EndTransactionResponse::set_resolved(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:cockroach.roachpb.EndTransactionResponse.resolved)
  resolved_.Mutable(index)->assign(value);
}
inline void EndTransactionResponse::set_resolved(int index, const char* value) {
  resolved_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:cockroach.roachpb.EndTransactionResponse.resolved)
}
inline void EndTransactionResponse::set_resolved(int index, const void* value, size_t size) {
  resolved_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:cockroach.roachpb.EndTransactionResponse.resolved)
}
inline ::std::string* EndTransactionResponse::add_resolved() {
  return resolved_.Add();
}
inline void EndTransactionResponse::add_resolved(const ::std::string& value) {
  resolved_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:cockroach.roachpb.EndTransactionResponse.resolved)
}
inline void EndTransactionResponse::add_resolved(const char* value) {
  resolved_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:cockroach.roachpb.EndTransactionResponse.resolved)
}
inline void EndTransactionResponse::add_resolved(const void* value, size_t size) {
  resolved_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:cockroach.roachpb.EndTransactionResponse.resolved)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
EndTransactionResponse::resolved() const {
  // @@protoc_insertion_point(field_list:cockroach.roachpb.EndTransactionResponse.resolved)
  return resolved_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
EndTransactionResponse::mutable_resolved() {
  // @@protoc_insertion_point(field_mutable_list:cockroach.roachpb.EndTransactionResponse.resolved)
  return &resolved_;
}

// -------------------------------------------------------------------

// AdminSplitRequest

// optional .cockroach.roachpb.Span header = 1;
inline bool AdminSplitRequest::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AdminSplitRequest::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AdminSplitRequest::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AdminSplitRequest::clear_header() {
  if (header_ != NULL) header_->::cockroach::roachpb::Span::Clear();
  clear_has_header();
}
inline const ::cockroach::roachpb::Span& AdminSplitRequest::header() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.AdminSplitRequest.header)
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
inline ::cockroach::roachpb::Span* AdminSplitRequest::mutable_header() {
  set_has_header();
  if (header_ == NULL) {
    header_ = new ::cockroach::roachpb::Span;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.AdminSplitRequest.header)
  return header_;
}
inline ::cockroach::roachpb::Span* AdminSplitRequest::release_header() {
  clear_has_header();
  ::cockroach::roachpb::Span* temp = header_;
  header_ = NULL;
  return temp;
}
inline void AdminSplitRequest::set_allocated_header(::cockroach::roachpb::Span* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.AdminSplitRequest.header)
}

// optional bytes split_key = 2;
inline bool AdminSplitRequest::has_split_key() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AdminSplitRequest::set_has_split_key() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AdminSplitRequest::clear_has_split_key() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AdminSplitRequest::clear_split_key() {
  split_key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_split_key();
}
inline const ::std::string& AdminSplitRequest::split_key() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.AdminSplitRequest.split_key)
  return split_key_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AdminSplitRequest::set_split_key(const ::std::string& value) {
  set_has_split_key();
  split_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cockroach.roachpb.AdminSplitRequest.split_key)
}
inline void AdminSplitRequest::set_split_key(const char* value) {
  set_has_split_key();
  split_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cockroach.roachpb.AdminSplitRequest.split_key)
}
inline void AdminSplitRequest::set_split_key(const void* value, size_t size) {
  set_has_split_key();
  split_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cockroach.roachpb.AdminSplitRequest.split_key)
}
inline ::std::string* AdminSplitRequest::mutable_split_key() {
  set_has_split_key();
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.AdminSplitRequest.split_key)
  return split_key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AdminSplitRequest::release_split_key() {
  clear_has_split_key();
  return split_key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AdminSplitRequest::set_allocated_split_key(::std::string* split_key) {
  if (split_key != NULL) {
    set_has_split_key();
  } else {
    clear_has_split_key();
  }
  split_key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), split_key);
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.AdminSplitRequest.split_key)
}

// -------------------------------------------------------------------

// AdminSplitResponse

// optional .cockroach.roachpb.ResponseHeader header = 1;
inline bool AdminSplitResponse::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AdminSplitResponse::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AdminSplitResponse::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AdminSplitResponse::clear_header() {
  if (header_ != NULL) header_->::cockroach::roachpb::ResponseHeader::Clear();
  clear_has_header();
}
inline const ::cockroach::roachpb::ResponseHeader& AdminSplitResponse::header() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.AdminSplitResponse.header)
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
inline ::cockroach::roachpb::ResponseHeader* AdminSplitResponse::mutable_header() {
  set_has_header();
  if (header_ == NULL) {
    header_ = new ::cockroach::roachpb::ResponseHeader;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.AdminSplitResponse.header)
  return header_;
}
inline ::cockroach::roachpb::ResponseHeader* AdminSplitResponse::release_header() {
  clear_has_header();
  ::cockroach::roachpb::ResponseHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void AdminSplitResponse::set_allocated_header(::cockroach::roachpb::ResponseHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.AdminSplitResponse.header)
}

// -------------------------------------------------------------------

// AdminMergeRequest

// optional .cockroach.roachpb.Span header = 1;
inline bool AdminMergeRequest::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AdminMergeRequest::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AdminMergeRequest::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AdminMergeRequest::clear_header() {
  if (header_ != NULL) header_->::cockroach::roachpb::Span::Clear();
  clear_has_header();
}
inline const ::cockroach::roachpb::Span& AdminMergeRequest::header() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.AdminMergeRequest.header)
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
inline ::cockroach::roachpb::Span* AdminMergeRequest::mutable_header() {
  set_has_header();
  if (header_ == NULL) {
    header_ = new ::cockroach::roachpb::Span;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.AdminMergeRequest.header)
  return header_;
}
inline ::cockroach::roachpb::Span* AdminMergeRequest::release_header() {
  clear_has_header();
  ::cockroach::roachpb::Span* temp = header_;
  header_ = NULL;
  return temp;
}
inline void AdminMergeRequest::set_allocated_header(::cockroach::roachpb::Span* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.AdminMergeRequest.header)
}

// -------------------------------------------------------------------

// AdminMergeResponse

// optional .cockroach.roachpb.ResponseHeader header = 1;
inline bool AdminMergeResponse::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AdminMergeResponse::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AdminMergeResponse::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AdminMergeResponse::clear_header() {
  if (header_ != NULL) header_->::cockroach::roachpb::ResponseHeader::Clear();
  clear_has_header();
}
inline const ::cockroach::roachpb::ResponseHeader& AdminMergeResponse::header() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.AdminMergeResponse.header)
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
inline ::cockroach::roachpb::ResponseHeader* AdminMergeResponse::mutable_header() {
  set_has_header();
  if (header_ == NULL) {
    header_ = new ::cockroach::roachpb::ResponseHeader;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.AdminMergeResponse.header)
  return header_;
}
inline ::cockroach::roachpb::ResponseHeader* AdminMergeResponse::release_header() {
  clear_has_header();
  ::cockroach::roachpb::ResponseHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void AdminMergeResponse::set_allocated_header(::cockroach::roachpb::ResponseHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.AdminMergeResponse.header)
}

// -------------------------------------------------------------------

// RangeLookupRequest

// optional .cockroach.roachpb.Span header = 1;
inline bool RangeLookupRequest::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RangeLookupRequest::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RangeLookupRequest::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RangeLookupRequest::clear_header() {
  if (header_ != NULL) header_->::cockroach::roachpb::Span::Clear();
  clear_has_header();
}
inline const ::cockroach::roachpb::Span& RangeLookupRequest::header() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.RangeLookupRequest.header)
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
inline ::cockroach::roachpb::Span* RangeLookupRequest::mutable_header() {
  set_has_header();
  if (header_ == NULL) {
    header_ = new ::cockroach::roachpb::Span;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.RangeLookupRequest.header)
  return header_;
}
inline ::cockroach::roachpb::Span* RangeLookupRequest::release_header() {
  clear_has_header();
  ::cockroach::roachpb::Span* temp = header_;
  header_ = NULL;
  return temp;
}
inline void RangeLookupRequest::set_allocated_header(::cockroach::roachpb::Span* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.RangeLookupRequest.header)
}

// optional int32 max_ranges = 2;
inline bool RangeLookupRequest::has_max_ranges() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RangeLookupRequest::set_has_max_ranges() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RangeLookupRequest::clear_has_max_ranges() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RangeLookupRequest::clear_max_ranges() {
  max_ranges_ = 0;
  clear_has_max_ranges();
}
inline ::google::protobuf::int32 RangeLookupRequest::max_ranges() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.RangeLookupRequest.max_ranges)
  return max_ranges_;
}
inline void RangeLookupRequest::set_max_ranges(::google::protobuf::int32 value) {
  set_has_max_ranges();
  max_ranges_ = value;
  // @@protoc_insertion_point(field_set:cockroach.roachpb.RangeLookupRequest.max_ranges)
}

// optional bool consider_intents = 3;
inline bool RangeLookupRequest::has_consider_intents() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RangeLookupRequest::set_has_consider_intents() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RangeLookupRequest::clear_has_consider_intents() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RangeLookupRequest::clear_consider_intents() {
  consider_intents_ = false;
  clear_has_consider_intents();
}
inline bool RangeLookupRequest::consider_intents() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.RangeLookupRequest.consider_intents)
  return consider_intents_;
}
inline void RangeLookupRequest::set_consider_intents(bool value) {
  set_has_consider_intents();
  consider_intents_ = value;
  // @@protoc_insertion_point(field_set:cockroach.roachpb.RangeLookupRequest.consider_intents)
}

// optional bool reverse = 4;
inline bool RangeLookupRequest::has_reverse() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RangeLookupRequest::set_has_reverse() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RangeLookupRequest::clear_has_reverse() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RangeLookupRequest::clear_reverse() {
  reverse_ = false;
  clear_has_reverse();
}
inline bool RangeLookupRequest::reverse() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.RangeLookupRequest.reverse)
  return reverse_;
}
inline void RangeLookupRequest::set_reverse(bool value) {
  set_has_reverse();
  reverse_ = value;
  // @@protoc_insertion_point(field_set:cockroach.roachpb.RangeLookupRequest.reverse)
}

// -------------------------------------------------------------------

// RangeLookupResponse

// optional .cockroach.roachpb.ResponseHeader header = 1;
inline bool RangeLookupResponse::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RangeLookupResponse::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RangeLookupResponse::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RangeLookupResponse::clear_header() {
  if (header_ != NULL) header_->::cockroach::roachpb::ResponseHeader::Clear();
  clear_has_header();
}
inline const ::cockroach::roachpb::ResponseHeader& RangeLookupResponse::header() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.RangeLookupResponse.header)
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
inline ::cockroach::roachpb::ResponseHeader* RangeLookupResponse::mutable_header() {
  set_has_header();
  if (header_ == NULL) {
    header_ = new ::cockroach::roachpb::ResponseHeader;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.RangeLookupResponse.header)
  return header_;
}
inline ::cockroach::roachpb::ResponseHeader* RangeLookupResponse::release_header() {
  clear_has_header();
  ::cockroach::roachpb::ResponseHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void RangeLookupResponse::set_allocated_header(::cockroach::roachpb::ResponseHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.RangeLookupResponse.header)
}

// repeated .cockroach.roachpb.RangeDescriptor ranges = 2;
inline int RangeLookupResponse::ranges_size() const {
  return ranges_.size();
}
inline void RangeLookupResponse::clear_ranges() {
  ranges_.Clear();
}
inline const ::cockroach::roachpb::RangeDescriptor& RangeLookupResponse::ranges(int index) const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.RangeLookupResponse.ranges)
  return ranges_.Get(index);
}
inline ::cockroach::roachpb::RangeDescriptor* RangeLookupResponse::mutable_ranges(int index) {
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.RangeLookupResponse.ranges)
  return ranges_.Mutable(index);
}
inline ::cockroach::roachpb::RangeDescriptor* RangeLookupResponse::add_ranges() {
  // @@protoc_insertion_point(field_add:cockroach.roachpb.RangeLookupResponse.ranges)
  return ranges_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::cockroach::roachpb::RangeDescriptor >*
RangeLookupResponse::mutable_ranges() {
  // @@protoc_insertion_point(field_mutable_list:cockroach.roachpb.RangeLookupResponse.ranges)
  return &ranges_;
}
inline const ::google::protobuf::RepeatedPtrField< ::cockroach::roachpb::RangeDescriptor >&
RangeLookupResponse::ranges() const {
  // @@protoc_insertion_point(field_list:cockroach.roachpb.RangeLookupResponse.ranges)
  return ranges_;
}

// -------------------------------------------------------------------

// HeartbeatTxnRequest

// optional .cockroach.roachpb.Span header = 1;
inline bool HeartbeatTxnRequest::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HeartbeatTxnRequest::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void HeartbeatTxnRequest::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void HeartbeatTxnRequest::clear_header() {
  if (header_ != NULL) header_->::cockroach::roachpb::Span::Clear();
  clear_has_header();
}
inline const ::cockroach::roachpb::Span& HeartbeatTxnRequest::header() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.HeartbeatTxnRequest.header)
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
inline ::cockroach::roachpb::Span* HeartbeatTxnRequest::mutable_header() {
  set_has_header();
  if (header_ == NULL) {
    header_ = new ::cockroach::roachpb::Span;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.HeartbeatTxnRequest.header)
  return header_;
}
inline ::cockroach::roachpb::Span* HeartbeatTxnRequest::release_header() {
  clear_has_header();
  ::cockroach::roachpb::Span* temp = header_;
  header_ = NULL;
  return temp;
}
inline void HeartbeatTxnRequest::set_allocated_header(::cockroach::roachpb::Span* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.HeartbeatTxnRequest.header)
}

// optional .cockroach.roachpb.Timestamp now = 2;
inline bool HeartbeatTxnRequest::has_now() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void HeartbeatTxnRequest::set_has_now() {
  _has_bits_[0] |= 0x00000002u;
}
inline void HeartbeatTxnRequest::clear_has_now() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void HeartbeatTxnRequest::clear_now() {
  if (now_ != NULL) now_->::cockroach::roachpb::Timestamp::Clear();
  clear_has_now();
}
inline const ::cockroach::roachpb::Timestamp& HeartbeatTxnRequest::now() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.HeartbeatTxnRequest.now)
  return now_ != NULL ? *now_ : *default_instance_->now_;
}
inline ::cockroach::roachpb::Timestamp* HeartbeatTxnRequest::mutable_now() {
  set_has_now();
  if (now_ == NULL) {
    now_ = new ::cockroach::roachpb::Timestamp;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.HeartbeatTxnRequest.now)
  return now_;
}
inline ::cockroach::roachpb::Timestamp* HeartbeatTxnRequest::release_now() {
  clear_has_now();
  ::cockroach::roachpb::Timestamp* temp = now_;
  now_ = NULL;
  return temp;
}
inline void HeartbeatTxnRequest::set_allocated_now(::cockroach::roachpb::Timestamp* now) {
  delete now_;
  now_ = now;
  if (now) {
    set_has_now();
  } else {
    clear_has_now();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.HeartbeatTxnRequest.now)
}

// -------------------------------------------------------------------

// HeartbeatTxnResponse

// optional .cockroach.roachpb.ResponseHeader header = 1;
inline bool HeartbeatTxnResponse::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HeartbeatTxnResponse::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void HeartbeatTxnResponse::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void HeartbeatTxnResponse::clear_header() {
  if (header_ != NULL) header_->::cockroach::roachpb::ResponseHeader::Clear();
  clear_has_header();
}
inline const ::cockroach::roachpb::ResponseHeader& HeartbeatTxnResponse::header() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.HeartbeatTxnResponse.header)
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
inline ::cockroach::roachpb::ResponseHeader* HeartbeatTxnResponse::mutable_header() {
  set_has_header();
  if (header_ == NULL) {
    header_ = new ::cockroach::roachpb::ResponseHeader;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.HeartbeatTxnResponse.header)
  return header_;
}
inline ::cockroach::roachpb::ResponseHeader* HeartbeatTxnResponse::release_header() {
  clear_has_header();
  ::cockroach::roachpb::ResponseHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void HeartbeatTxnResponse::set_allocated_header(::cockroach::roachpb::ResponseHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.HeartbeatTxnResponse.header)
}

// -------------------------------------------------------------------

// GCRequest_GCKey

// optional bytes key = 1;
inline bool GCRequest_GCKey::has_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GCRequest_GCKey::set_has_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GCRequest_GCKey::clear_has_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GCRequest_GCKey::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_key();
}
inline const ::std::string& GCRequest_GCKey::key() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.GCRequest.GCKey.key)
  return key_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GCRequest_GCKey::set_key(const ::std::string& value) {
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cockroach.roachpb.GCRequest.GCKey.key)
}
inline void GCRequest_GCKey::set_key(const char* value) {
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cockroach.roachpb.GCRequest.GCKey.key)
}
inline void GCRequest_GCKey::set_key(const void* value, size_t size) {
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cockroach.roachpb.GCRequest.GCKey.key)
}
inline ::std::string* GCRequest_GCKey::mutable_key() {
  set_has_key();
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.GCRequest.GCKey.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GCRequest_GCKey::release_key() {
  clear_has_key();
  return key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GCRequest_GCKey::set_allocated_key(::std::string* key) {
  if (key != NULL) {
    set_has_key();
  } else {
    clear_has_key();
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.GCRequest.GCKey.key)
}

// optional .cockroach.roachpb.Timestamp timestamp = 2;
inline bool GCRequest_GCKey::has_timestamp() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GCRequest_GCKey::set_has_timestamp() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GCRequest_GCKey::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GCRequest_GCKey::clear_timestamp() {
  if (timestamp_ != NULL) timestamp_->::cockroach::roachpb::Timestamp::Clear();
  clear_has_timestamp();
}
inline const ::cockroach::roachpb::Timestamp& GCRequest_GCKey::timestamp() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.GCRequest.GCKey.timestamp)
  return timestamp_ != NULL ? *timestamp_ : *default_instance_->timestamp_;
}
inline ::cockroach::roachpb::Timestamp* GCRequest_GCKey::mutable_timestamp() {
  set_has_timestamp();
  if (timestamp_ == NULL) {
    timestamp_ = new ::cockroach::roachpb::Timestamp;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.GCRequest.GCKey.timestamp)
  return timestamp_;
}
inline ::cockroach::roachpb::Timestamp* GCRequest_GCKey::release_timestamp() {
  clear_has_timestamp();
  ::cockroach::roachpb::Timestamp* temp = timestamp_;
  timestamp_ = NULL;
  return temp;
}
inline void GCRequest_GCKey::set_allocated_timestamp(::cockroach::roachpb::Timestamp* timestamp) {
  delete timestamp_;
  timestamp_ = timestamp;
  if (timestamp) {
    set_has_timestamp();
  } else {
    clear_has_timestamp();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.GCRequest.GCKey.timestamp)
}

// -------------------------------------------------------------------

// GCRequest

// optional .cockroach.roachpb.Span header = 1;
inline bool GCRequest::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GCRequest::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GCRequest::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GCRequest::clear_header() {
  if (header_ != NULL) header_->::cockroach::roachpb::Span::Clear();
  clear_has_header();
}
inline const ::cockroach::roachpb::Span& GCRequest::header() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.GCRequest.header)
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
inline ::cockroach::roachpb::Span* GCRequest::mutable_header() {
  set_has_header();
  if (header_ == NULL) {
    header_ = new ::cockroach::roachpb::Span;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.GCRequest.header)
  return header_;
}
inline ::cockroach::roachpb::Span* GCRequest::release_header() {
  clear_has_header();
  ::cockroach::roachpb::Span* temp = header_;
  header_ = NULL;
  return temp;
}
inline void GCRequest::set_allocated_header(::cockroach::roachpb::Span* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.GCRequest.header)
}

// repeated .cockroach.roachpb.GCRequest.GCKey keys = 3;
inline int GCRequest::keys_size() const {
  return keys_.size();
}
inline void GCRequest::clear_keys() {
  keys_.Clear();
}
inline const ::cockroach::roachpb::GCRequest_GCKey& GCRequest::keys(int index) const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.GCRequest.keys)
  return keys_.Get(index);
}
inline ::cockroach::roachpb::GCRequest_GCKey* GCRequest::mutable_keys(int index) {
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.GCRequest.keys)
  return keys_.Mutable(index);
}
inline ::cockroach::roachpb::GCRequest_GCKey* GCRequest::add_keys() {
  // @@protoc_insertion_point(field_add:cockroach.roachpb.GCRequest.keys)
  return keys_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::cockroach::roachpb::GCRequest_GCKey >*
GCRequest::mutable_keys() {
  // @@protoc_insertion_point(field_mutable_list:cockroach.roachpb.GCRequest.keys)
  return &keys_;
}
inline const ::google::protobuf::RepeatedPtrField< ::cockroach::roachpb::GCRequest_GCKey >&
GCRequest::keys() const {
  // @@protoc_insertion_point(field_list:cockroach.roachpb.GCRequest.keys)
  return keys_;
}

// -------------------------------------------------------------------

// GCResponse

// optional .cockroach.roachpb.ResponseHeader header = 1;
inline bool GCResponse::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GCResponse::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GCResponse::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GCResponse::clear_header() {
  if (header_ != NULL) header_->::cockroach::roachpb::ResponseHeader::Clear();
  clear_has_header();
}
inline const ::cockroach::roachpb::ResponseHeader& GCResponse::header() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.GCResponse.header)
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
inline ::cockroach::roachpb::ResponseHeader* GCResponse::mutable_header() {
  set_has_header();
  if (header_ == NULL) {
    header_ = new ::cockroach::roachpb::ResponseHeader;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.GCResponse.header)
  return header_;
}
inline ::cockroach::roachpb::ResponseHeader* GCResponse::release_header() {
  clear_has_header();
  ::cockroach::roachpb::ResponseHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void GCResponse::set_allocated_header(::cockroach::roachpb::ResponseHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.GCResponse.header)
}

// -------------------------------------------------------------------

// PushTxnRequest

// optional .cockroach.roachpb.Span header = 1;
inline bool PushTxnRequest::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PushTxnRequest::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PushTxnRequest::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PushTxnRequest::clear_header() {
  if (header_ != NULL) header_->::cockroach::roachpb::Span::Clear();
  clear_has_header();
}
inline const ::cockroach::roachpb::Span& PushTxnRequest::header() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.PushTxnRequest.header)
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
inline ::cockroach::roachpb::Span* PushTxnRequest::mutable_header() {
  set_has_header();
  if (header_ == NULL) {
    header_ = new ::cockroach::roachpb::Span;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.PushTxnRequest.header)
  return header_;
}
inline ::cockroach::roachpb::Span* PushTxnRequest::release_header() {
  clear_has_header();
  ::cockroach::roachpb::Span* temp = header_;
  header_ = NULL;
  return temp;
}
inline void PushTxnRequest::set_allocated_header(::cockroach::roachpb::Span* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.PushTxnRequest.header)
}

// optional .cockroach.roachpb.Transaction pusher_txn = 2;
inline bool PushTxnRequest::has_pusher_txn() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PushTxnRequest::set_has_pusher_txn() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PushTxnRequest::clear_has_pusher_txn() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PushTxnRequest::clear_pusher_txn() {
  if (pusher_txn_ != NULL) pusher_txn_->::cockroach::roachpb::Transaction::Clear();
  clear_has_pusher_txn();
}
inline const ::cockroach::roachpb::Transaction& PushTxnRequest::pusher_txn() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.PushTxnRequest.pusher_txn)
  return pusher_txn_ != NULL ? *pusher_txn_ : *default_instance_->pusher_txn_;
}
inline ::cockroach::roachpb::Transaction* PushTxnRequest::mutable_pusher_txn() {
  set_has_pusher_txn();
  if (pusher_txn_ == NULL) {
    pusher_txn_ = new ::cockroach::roachpb::Transaction;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.PushTxnRequest.pusher_txn)
  return pusher_txn_;
}
inline ::cockroach::roachpb::Transaction* PushTxnRequest::release_pusher_txn() {
  clear_has_pusher_txn();
  ::cockroach::roachpb::Transaction* temp = pusher_txn_;
  pusher_txn_ = NULL;
  return temp;
}
inline void PushTxnRequest::set_allocated_pusher_txn(::cockroach::roachpb::Transaction* pusher_txn) {
  delete pusher_txn_;
  pusher_txn_ = pusher_txn;
  if (pusher_txn) {
    set_has_pusher_txn();
  } else {
    clear_has_pusher_txn();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.PushTxnRequest.pusher_txn)
}

// optional .cockroach.roachpb.TxnMeta pushee_txn = 3;
inline bool PushTxnRequest::has_pushee_txn() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PushTxnRequest::set_has_pushee_txn() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PushTxnRequest::clear_has_pushee_txn() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PushTxnRequest::clear_pushee_txn() {
  if (pushee_txn_ != NULL) pushee_txn_->::cockroach::roachpb::TxnMeta::Clear();
  clear_has_pushee_txn();
}
inline const ::cockroach::roachpb::TxnMeta& PushTxnRequest::pushee_txn() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.PushTxnRequest.pushee_txn)
  return pushee_txn_ != NULL ? *pushee_txn_ : *default_instance_->pushee_txn_;
}
inline ::cockroach::roachpb::TxnMeta* PushTxnRequest::mutable_pushee_txn() {
  set_has_pushee_txn();
  if (pushee_txn_ == NULL) {
    pushee_txn_ = new ::cockroach::roachpb::TxnMeta;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.PushTxnRequest.pushee_txn)
  return pushee_txn_;
}
inline ::cockroach::roachpb::TxnMeta* PushTxnRequest::release_pushee_txn() {
  clear_has_pushee_txn();
  ::cockroach::roachpb::TxnMeta* temp = pushee_txn_;
  pushee_txn_ = NULL;
  return temp;
}
inline void PushTxnRequest::set_allocated_pushee_txn(::cockroach::roachpb::TxnMeta* pushee_txn) {
  delete pushee_txn_;
  pushee_txn_ = pushee_txn;
  if (pushee_txn) {
    set_has_pushee_txn();
  } else {
    clear_has_pushee_txn();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.PushTxnRequest.pushee_txn)
}

// optional .cockroach.roachpb.Timestamp push_to = 4;
inline bool PushTxnRequest::has_push_to() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PushTxnRequest::set_has_push_to() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PushTxnRequest::clear_has_push_to() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PushTxnRequest::clear_push_to() {
  if (push_to_ != NULL) push_to_->::cockroach::roachpb::Timestamp::Clear();
  clear_has_push_to();
}
inline const ::cockroach::roachpb::Timestamp& PushTxnRequest::push_to() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.PushTxnRequest.push_to)
  return push_to_ != NULL ? *push_to_ : *default_instance_->push_to_;
}
inline ::cockroach::roachpb::Timestamp* PushTxnRequest::mutable_push_to() {
  set_has_push_to();
  if (push_to_ == NULL) {
    push_to_ = new ::cockroach::roachpb::Timestamp;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.PushTxnRequest.push_to)
  return push_to_;
}
inline ::cockroach::roachpb::Timestamp* PushTxnRequest::release_push_to() {
  clear_has_push_to();
  ::cockroach::roachpb::Timestamp* temp = push_to_;
  push_to_ = NULL;
  return temp;
}
inline void PushTxnRequest::set_allocated_push_to(::cockroach::roachpb::Timestamp* push_to) {
  delete push_to_;
  push_to_ = push_to;
  if (push_to) {
    set_has_push_to();
  } else {
    clear_has_push_to();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.PushTxnRequest.push_to)
}

// optional .cockroach.roachpb.Timestamp now = 5;
inline bool PushTxnRequest::has_now() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PushTxnRequest::set_has_now() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PushTxnRequest::clear_has_now() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PushTxnRequest::clear_now() {
  if (now_ != NULL) now_->::cockroach::roachpb::Timestamp::Clear();
  clear_has_now();
}
inline const ::cockroach::roachpb::Timestamp& PushTxnRequest::now() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.PushTxnRequest.now)
  return now_ != NULL ? *now_ : *default_instance_->now_;
}
inline ::cockroach::roachpb::Timestamp* PushTxnRequest::mutable_now() {
  set_has_now();
  if (now_ == NULL) {
    now_ = new ::cockroach::roachpb::Timestamp;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.PushTxnRequest.now)
  return now_;
}
inline ::cockroach::roachpb::Timestamp* PushTxnRequest::release_now() {
  clear_has_now();
  ::cockroach::roachpb::Timestamp* temp = now_;
  now_ = NULL;
  return temp;
}
inline void PushTxnRequest::set_allocated_now(::cockroach::roachpb::Timestamp* now) {
  delete now_;
  now_ = now;
  if (now) {
    set_has_now();
  } else {
    clear_has_now();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.PushTxnRequest.now)
}

// optional .cockroach.roachpb.PushTxnType push_type = 6;
inline bool PushTxnRequest::has_push_type() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void PushTxnRequest::set_has_push_type() {
  _has_bits_[0] |= 0x00000020u;
}
inline void PushTxnRequest::clear_has_push_type() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void PushTxnRequest::clear_push_type() {
  push_type_ = 0;
  clear_has_push_type();
}
inline ::cockroach::roachpb::PushTxnType PushTxnRequest::push_type() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.PushTxnRequest.push_type)
  return static_cast< ::cockroach::roachpb::PushTxnType >(push_type_);
}
inline void PushTxnRequest::set_push_type(::cockroach::roachpb::PushTxnType value) {
  assert(::cockroach::roachpb::PushTxnType_IsValid(value));
  set_has_push_type();
  push_type_ = value;
  // @@protoc_insertion_point(field_set:cockroach.roachpb.PushTxnRequest.push_type)
}

// -------------------------------------------------------------------

// PushTxnResponse

// optional .cockroach.roachpb.ResponseHeader header = 1;
inline bool PushTxnResponse::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PushTxnResponse::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PushTxnResponse::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PushTxnResponse::clear_header() {
  if (header_ != NULL) header_->::cockroach::roachpb::ResponseHeader::Clear();
  clear_has_header();
}
inline const ::cockroach::roachpb::ResponseHeader& PushTxnResponse::header() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.PushTxnResponse.header)
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
inline ::cockroach::roachpb::ResponseHeader* PushTxnResponse::mutable_header() {
  set_has_header();
  if (header_ == NULL) {
    header_ = new ::cockroach::roachpb::ResponseHeader;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.PushTxnResponse.header)
  return header_;
}
inline ::cockroach::roachpb::ResponseHeader* PushTxnResponse::release_header() {
  clear_has_header();
  ::cockroach::roachpb::ResponseHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void PushTxnResponse::set_allocated_header(::cockroach::roachpb::ResponseHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.PushTxnResponse.header)
}

// optional .cockroach.roachpb.Transaction pushee_txn = 2;
inline bool PushTxnResponse::has_pushee_txn() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PushTxnResponse::set_has_pushee_txn() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PushTxnResponse::clear_has_pushee_txn() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PushTxnResponse::clear_pushee_txn() {
  if (pushee_txn_ != NULL) pushee_txn_->::cockroach::roachpb::Transaction::Clear();
  clear_has_pushee_txn();
}
inline const ::cockroach::roachpb::Transaction& PushTxnResponse::pushee_txn() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.PushTxnResponse.pushee_txn)
  return pushee_txn_ != NULL ? *pushee_txn_ : *default_instance_->pushee_txn_;
}
inline ::cockroach::roachpb::Transaction* PushTxnResponse::mutable_pushee_txn() {
  set_has_pushee_txn();
  if (pushee_txn_ == NULL) {
    pushee_txn_ = new ::cockroach::roachpb::Transaction;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.PushTxnResponse.pushee_txn)
  return pushee_txn_;
}
inline ::cockroach::roachpb::Transaction* PushTxnResponse::release_pushee_txn() {
  clear_has_pushee_txn();
  ::cockroach::roachpb::Transaction* temp = pushee_txn_;
  pushee_txn_ = NULL;
  return temp;
}
inline void PushTxnResponse::set_allocated_pushee_txn(::cockroach::roachpb::Transaction* pushee_txn) {
  delete pushee_txn_;
  pushee_txn_ = pushee_txn;
  if (pushee_txn) {
    set_has_pushee_txn();
  } else {
    clear_has_pushee_txn();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.PushTxnResponse.pushee_txn)
}

// -------------------------------------------------------------------

// ResolveIntentRequest

// optional .cockroach.roachpb.Span header = 1;
inline bool ResolveIntentRequest::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResolveIntentRequest::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResolveIntentRequest::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResolveIntentRequest::clear_header() {
  if (header_ != NULL) header_->::cockroach::roachpb::Span::Clear();
  clear_has_header();
}
inline const ::cockroach::roachpb::Span& ResolveIntentRequest::header() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.ResolveIntentRequest.header)
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
inline ::cockroach::roachpb::Span* ResolveIntentRequest::mutable_header() {
  set_has_header();
  if (header_ == NULL) {
    header_ = new ::cockroach::roachpb::Span;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.ResolveIntentRequest.header)
  return header_;
}
inline ::cockroach::roachpb::Span* ResolveIntentRequest::release_header() {
  clear_has_header();
  ::cockroach::roachpb::Span* temp = header_;
  header_ = NULL;
  return temp;
}
inline void ResolveIntentRequest::set_allocated_header(::cockroach::roachpb::Span* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.ResolveIntentRequest.header)
}

// optional .cockroach.roachpb.TxnMeta intent_txn = 2;
inline bool ResolveIntentRequest::has_intent_txn() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ResolveIntentRequest::set_has_intent_txn() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ResolveIntentRequest::clear_has_intent_txn() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ResolveIntentRequest::clear_intent_txn() {
  if (intent_txn_ != NULL) intent_txn_->::cockroach::roachpb::TxnMeta::Clear();
  clear_has_intent_txn();
}
inline const ::cockroach::roachpb::TxnMeta& ResolveIntentRequest::intent_txn() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.ResolveIntentRequest.intent_txn)
  return intent_txn_ != NULL ? *intent_txn_ : *default_instance_->intent_txn_;
}
inline ::cockroach::roachpb::TxnMeta* ResolveIntentRequest::mutable_intent_txn() {
  set_has_intent_txn();
  if (intent_txn_ == NULL) {
    intent_txn_ = new ::cockroach::roachpb::TxnMeta;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.ResolveIntentRequest.intent_txn)
  return intent_txn_;
}
inline ::cockroach::roachpb::TxnMeta* ResolveIntentRequest::release_intent_txn() {
  clear_has_intent_txn();
  ::cockroach::roachpb::TxnMeta* temp = intent_txn_;
  intent_txn_ = NULL;
  return temp;
}
inline void ResolveIntentRequest::set_allocated_intent_txn(::cockroach::roachpb::TxnMeta* intent_txn) {
  delete intent_txn_;
  intent_txn_ = intent_txn;
  if (intent_txn) {
    set_has_intent_txn();
  } else {
    clear_has_intent_txn();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.ResolveIntentRequest.intent_txn)
}

// optional .cockroach.roachpb.TransactionStatus status = 3;
inline bool ResolveIntentRequest::has_status() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ResolveIntentRequest::set_has_status() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ResolveIntentRequest::clear_has_status() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ResolveIntentRequest::clear_status() {
  status_ = 0;
  clear_has_status();
}
inline ::cockroach::roachpb::TransactionStatus ResolveIntentRequest::status() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.ResolveIntentRequest.status)
  return static_cast< ::cockroach::roachpb::TransactionStatus >(status_);
}
inline void ResolveIntentRequest::set_status(::cockroach::roachpb::TransactionStatus value) {
  assert(::cockroach::roachpb::TransactionStatus_IsValid(value));
  set_has_status();
  status_ = value;
  // @@protoc_insertion_point(field_set:cockroach.roachpb.ResolveIntentRequest.status)
}

// optional bool poison = 4;
inline bool ResolveIntentRequest::has_poison() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ResolveIntentRequest::set_has_poison() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ResolveIntentRequest::clear_has_poison() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ResolveIntentRequest::clear_poison() {
  poison_ = false;
  clear_has_poison();
}
inline bool ResolveIntentRequest::poison() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.ResolveIntentRequest.poison)
  return poison_;
}
inline void ResolveIntentRequest::set_poison(bool value) {
  set_has_poison();
  poison_ = value;
  // @@protoc_insertion_point(field_set:cockroach.roachpb.ResolveIntentRequest.poison)
}

// -------------------------------------------------------------------

// ResolveIntentResponse

// optional .cockroach.roachpb.ResponseHeader header = 1;
inline bool ResolveIntentResponse::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResolveIntentResponse::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResolveIntentResponse::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResolveIntentResponse::clear_header() {
  if (header_ != NULL) header_->::cockroach::roachpb::ResponseHeader::Clear();
  clear_has_header();
}
inline const ::cockroach::roachpb::ResponseHeader& ResolveIntentResponse::header() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.ResolveIntentResponse.header)
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
inline ::cockroach::roachpb::ResponseHeader* ResolveIntentResponse::mutable_header() {
  set_has_header();
  if (header_ == NULL) {
    header_ = new ::cockroach::roachpb::ResponseHeader;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.ResolveIntentResponse.header)
  return header_;
}
inline ::cockroach::roachpb::ResponseHeader* ResolveIntentResponse::release_header() {
  clear_has_header();
  ::cockroach::roachpb::ResponseHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void ResolveIntentResponse::set_allocated_header(::cockroach::roachpb::ResponseHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.ResolveIntentResponse.header)
}

// -------------------------------------------------------------------

// ResolveIntentRangeRequest

// optional .cockroach.roachpb.Span header = 1;
inline bool ResolveIntentRangeRequest::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResolveIntentRangeRequest::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResolveIntentRangeRequest::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResolveIntentRangeRequest::clear_header() {
  if (header_ != NULL) header_->::cockroach::roachpb::Span::Clear();
  clear_has_header();
}
inline const ::cockroach::roachpb::Span& ResolveIntentRangeRequest::header() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.ResolveIntentRangeRequest.header)
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
inline ::cockroach::roachpb::Span* ResolveIntentRangeRequest::mutable_header() {
  set_has_header();
  if (header_ == NULL) {
    header_ = new ::cockroach::roachpb::Span;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.ResolveIntentRangeRequest.header)
  return header_;
}
inline ::cockroach::roachpb::Span* ResolveIntentRangeRequest::release_header() {
  clear_has_header();
  ::cockroach::roachpb::Span* temp = header_;
  header_ = NULL;
  return temp;
}
inline void ResolveIntentRangeRequest::set_allocated_header(::cockroach::roachpb::Span* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.ResolveIntentRangeRequest.header)
}

// optional .cockroach.roachpb.TxnMeta intent_txn = 2;
inline bool ResolveIntentRangeRequest::has_intent_txn() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ResolveIntentRangeRequest::set_has_intent_txn() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ResolveIntentRangeRequest::clear_has_intent_txn() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ResolveIntentRangeRequest::clear_intent_txn() {
  if (intent_txn_ != NULL) intent_txn_->::cockroach::roachpb::TxnMeta::Clear();
  clear_has_intent_txn();
}
inline const ::cockroach::roachpb::TxnMeta& ResolveIntentRangeRequest::intent_txn() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.ResolveIntentRangeRequest.intent_txn)
  return intent_txn_ != NULL ? *intent_txn_ : *default_instance_->intent_txn_;
}
inline ::cockroach::roachpb::TxnMeta* ResolveIntentRangeRequest::mutable_intent_txn() {
  set_has_intent_txn();
  if (intent_txn_ == NULL) {
    intent_txn_ = new ::cockroach::roachpb::TxnMeta;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.ResolveIntentRangeRequest.intent_txn)
  return intent_txn_;
}
inline ::cockroach::roachpb::TxnMeta* ResolveIntentRangeRequest::release_intent_txn() {
  clear_has_intent_txn();
  ::cockroach::roachpb::TxnMeta* temp = intent_txn_;
  intent_txn_ = NULL;
  return temp;
}
inline void ResolveIntentRangeRequest::set_allocated_intent_txn(::cockroach::roachpb::TxnMeta* intent_txn) {
  delete intent_txn_;
  intent_txn_ = intent_txn;
  if (intent_txn) {
    set_has_intent_txn();
  } else {
    clear_has_intent_txn();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.ResolveIntentRangeRequest.intent_txn)
}

// optional .cockroach.roachpb.TransactionStatus status = 3;
inline bool ResolveIntentRangeRequest::has_status() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ResolveIntentRangeRequest::set_has_status() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ResolveIntentRangeRequest::clear_has_status() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ResolveIntentRangeRequest::clear_status() {
  status_ = 0;
  clear_has_status();
}
inline ::cockroach::roachpb::TransactionStatus ResolveIntentRangeRequest::status() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.ResolveIntentRangeRequest.status)
  return static_cast< ::cockroach::roachpb::TransactionStatus >(status_);
}
inline void ResolveIntentRangeRequest::set_status(::cockroach::roachpb::TransactionStatus value) {
  assert(::cockroach::roachpb::TransactionStatus_IsValid(value));
  set_has_status();
  status_ = value;
  // @@protoc_insertion_point(field_set:cockroach.roachpb.ResolveIntentRangeRequest.status)
}

// optional bool poison = 4;
inline bool ResolveIntentRangeRequest::has_poison() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ResolveIntentRangeRequest::set_has_poison() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ResolveIntentRangeRequest::clear_has_poison() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ResolveIntentRangeRequest::clear_poison() {
  poison_ = false;
  clear_has_poison();
}
inline bool ResolveIntentRangeRequest::poison() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.ResolveIntentRangeRequest.poison)
  return poison_;
}
inline void ResolveIntentRangeRequest::set_poison(bool value) {
  set_has_poison();
  poison_ = value;
  // @@protoc_insertion_point(field_set:cockroach.roachpb.ResolveIntentRangeRequest.poison)
}

// -------------------------------------------------------------------

// NoopResponse

// -------------------------------------------------------------------

// NoopRequest

// -------------------------------------------------------------------

// ResolveIntentRangeResponse

// optional .cockroach.roachpb.ResponseHeader header = 1;
inline bool ResolveIntentRangeResponse::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResolveIntentRangeResponse::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResolveIntentRangeResponse::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResolveIntentRangeResponse::clear_header() {
  if (header_ != NULL) header_->::cockroach::roachpb::ResponseHeader::Clear();
  clear_has_header();
}
inline const ::cockroach::roachpb::ResponseHeader& ResolveIntentRangeResponse::header() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.ResolveIntentRangeResponse.header)
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
inline ::cockroach::roachpb::ResponseHeader* ResolveIntentRangeResponse::mutable_header() {
  set_has_header();
  if (header_ == NULL) {
    header_ = new ::cockroach::roachpb::ResponseHeader;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.ResolveIntentRangeResponse.header)
  return header_;
}
inline ::cockroach::roachpb::ResponseHeader* ResolveIntentRangeResponse::release_header() {
  clear_has_header();
  ::cockroach::roachpb::ResponseHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void ResolveIntentRangeResponse::set_allocated_header(::cockroach::roachpb::ResponseHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.ResolveIntentRangeResponse.header)
}

// -------------------------------------------------------------------

// MergeRequest

// optional .cockroach.roachpb.Span header = 1;
inline bool MergeRequest::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MergeRequest::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MergeRequest::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MergeRequest::clear_header() {
  if (header_ != NULL) header_->::cockroach::roachpb::Span::Clear();
  clear_has_header();
}
inline const ::cockroach::roachpb::Span& MergeRequest::header() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.MergeRequest.header)
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
inline ::cockroach::roachpb::Span* MergeRequest::mutable_header() {
  set_has_header();
  if (header_ == NULL) {
    header_ = new ::cockroach::roachpb::Span;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.MergeRequest.header)
  return header_;
}
inline ::cockroach::roachpb::Span* MergeRequest::release_header() {
  clear_has_header();
  ::cockroach::roachpb::Span* temp = header_;
  header_ = NULL;
  return temp;
}
inline void MergeRequest::set_allocated_header(::cockroach::roachpb::Span* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.MergeRequest.header)
}

// optional .cockroach.roachpb.Value value = 2;
inline bool MergeRequest::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MergeRequest::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MergeRequest::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MergeRequest::clear_value() {
  if (value_ != NULL) value_->::cockroach::roachpb::Value::Clear();
  clear_has_value();
}
inline const ::cockroach::roachpb::Value& MergeRequest::value() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.MergeRequest.value)
  return value_ != NULL ? *value_ : *default_instance_->value_;
}
inline ::cockroach::roachpb::Value* MergeRequest::mutable_value() {
  set_has_value();
  if (value_ == NULL) {
    value_ = new ::cockroach::roachpb::Value;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.MergeRequest.value)
  return value_;
}
inline ::cockroach::roachpb::Value* MergeRequest::release_value() {
  clear_has_value();
  ::cockroach::roachpb::Value* temp = value_;
  value_ = NULL;
  return temp;
}
inline void MergeRequest::set_allocated_value(::cockroach::roachpb::Value* value) {
  delete value_;
  value_ = value;
  if (value) {
    set_has_value();
  } else {
    clear_has_value();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.MergeRequest.value)
}

// -------------------------------------------------------------------

// MergeResponse

// optional .cockroach.roachpb.ResponseHeader header = 1;
inline bool MergeResponse::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MergeResponse::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MergeResponse::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MergeResponse::clear_header() {
  if (header_ != NULL) header_->::cockroach::roachpb::ResponseHeader::Clear();
  clear_has_header();
}
inline const ::cockroach::roachpb::ResponseHeader& MergeResponse::header() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.MergeResponse.header)
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
inline ::cockroach::roachpb::ResponseHeader* MergeResponse::mutable_header() {
  set_has_header();
  if (header_ == NULL) {
    header_ = new ::cockroach::roachpb::ResponseHeader;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.MergeResponse.header)
  return header_;
}
inline ::cockroach::roachpb::ResponseHeader* MergeResponse::release_header() {
  clear_has_header();
  ::cockroach::roachpb::ResponseHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void MergeResponse::set_allocated_header(::cockroach::roachpb::ResponseHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.MergeResponse.header)
}

// -------------------------------------------------------------------

// TruncateLogRequest

// optional .cockroach.roachpb.Span header = 1;
inline bool TruncateLogRequest::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TruncateLogRequest::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TruncateLogRequest::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TruncateLogRequest::clear_header() {
  if (header_ != NULL) header_->::cockroach::roachpb::Span::Clear();
  clear_has_header();
}
inline const ::cockroach::roachpb::Span& TruncateLogRequest::header() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.TruncateLogRequest.header)
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
inline ::cockroach::roachpb::Span* TruncateLogRequest::mutable_header() {
  set_has_header();
  if (header_ == NULL) {
    header_ = new ::cockroach::roachpb::Span;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.TruncateLogRequest.header)
  return header_;
}
inline ::cockroach::roachpb::Span* TruncateLogRequest::release_header() {
  clear_has_header();
  ::cockroach::roachpb::Span* temp = header_;
  header_ = NULL;
  return temp;
}
inline void TruncateLogRequest::set_allocated_header(::cockroach::roachpb::Span* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.TruncateLogRequest.header)
}

// optional uint64 index = 2;
inline bool TruncateLogRequest::has_index() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TruncateLogRequest::set_has_index() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TruncateLogRequest::clear_has_index() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TruncateLogRequest::clear_index() {
  index_ = GOOGLE_ULONGLONG(0);
  clear_has_index();
}
inline ::google::protobuf::uint64 TruncateLogRequest::index() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.TruncateLogRequest.index)
  return index_;
}
inline void TruncateLogRequest::set_index(::google::protobuf::uint64 value) {
  set_has_index();
  index_ = value;
  // @@protoc_insertion_point(field_set:cockroach.roachpb.TruncateLogRequest.index)
}

// optional int64 range_id = 3;
inline bool TruncateLogRequest::has_range_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TruncateLogRequest::set_has_range_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TruncateLogRequest::clear_has_range_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TruncateLogRequest::clear_range_id() {
  range_id_ = GOOGLE_LONGLONG(0);
  clear_has_range_id();
}
inline ::google::protobuf::int64 TruncateLogRequest::range_id() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.TruncateLogRequest.range_id)
  return range_id_;
}
inline void TruncateLogRequest::set_range_id(::google::protobuf::int64 value) {
  set_has_range_id();
  range_id_ = value;
  // @@protoc_insertion_point(field_set:cockroach.roachpb.TruncateLogRequest.range_id)
}

// -------------------------------------------------------------------

// TruncateLogResponse

// optional .cockroach.roachpb.ResponseHeader header = 1;
inline bool TruncateLogResponse::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TruncateLogResponse::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TruncateLogResponse::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TruncateLogResponse::clear_header() {
  if (header_ != NULL) header_->::cockroach::roachpb::ResponseHeader::Clear();
  clear_has_header();
}
inline const ::cockroach::roachpb::ResponseHeader& TruncateLogResponse::header() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.TruncateLogResponse.header)
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
inline ::cockroach::roachpb::ResponseHeader* TruncateLogResponse::mutable_header() {
  set_has_header();
  if (header_ == NULL) {
    header_ = new ::cockroach::roachpb::ResponseHeader;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.TruncateLogResponse.header)
  return header_;
}
inline ::cockroach::roachpb::ResponseHeader* TruncateLogResponse::release_header() {
  clear_has_header();
  ::cockroach::roachpb::ResponseHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void TruncateLogResponse::set_allocated_header(::cockroach::roachpb::ResponseHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.TruncateLogResponse.header)
}

// -------------------------------------------------------------------

// LeaderLeaseRequest

// optional .cockroach.roachpb.Span header = 1;
inline bool LeaderLeaseRequest::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LeaderLeaseRequest::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LeaderLeaseRequest::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LeaderLeaseRequest::clear_header() {
  if (header_ != NULL) header_->::cockroach::roachpb::Span::Clear();
  clear_has_header();
}
inline const ::cockroach::roachpb::Span& LeaderLeaseRequest::header() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.LeaderLeaseRequest.header)
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
inline ::cockroach::roachpb::Span* LeaderLeaseRequest::mutable_header() {
  set_has_header();
  if (header_ == NULL) {
    header_ = new ::cockroach::roachpb::Span;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.LeaderLeaseRequest.header)
  return header_;
}
inline ::cockroach::roachpb::Span* LeaderLeaseRequest::release_header() {
  clear_has_header();
  ::cockroach::roachpb::Span* temp = header_;
  header_ = NULL;
  return temp;
}
inline void LeaderLeaseRequest::set_allocated_header(::cockroach::roachpb::Span* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.LeaderLeaseRequest.header)
}

// optional .cockroach.roachpb.Lease lease = 2;
inline bool LeaderLeaseRequest::has_lease() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LeaderLeaseRequest::set_has_lease() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LeaderLeaseRequest::clear_has_lease() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LeaderLeaseRequest::clear_lease() {
  if (lease_ != NULL) lease_->::cockroach::roachpb::Lease::Clear();
  clear_has_lease();
}
inline const ::cockroach::roachpb::Lease& LeaderLeaseRequest::lease() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.LeaderLeaseRequest.lease)
  return lease_ != NULL ? *lease_ : *default_instance_->lease_;
}
inline ::cockroach::roachpb::Lease* LeaderLeaseRequest::mutable_lease() {
  set_has_lease();
  if (lease_ == NULL) {
    lease_ = new ::cockroach::roachpb::Lease;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.LeaderLeaseRequest.lease)
  return lease_;
}
inline ::cockroach::roachpb::Lease* LeaderLeaseRequest::release_lease() {
  clear_has_lease();
  ::cockroach::roachpb::Lease* temp = lease_;
  lease_ = NULL;
  return temp;
}
inline void LeaderLeaseRequest::set_allocated_lease(::cockroach::roachpb::Lease* lease) {
  delete lease_;
  lease_ = lease;
  if (lease) {
    set_has_lease();
  } else {
    clear_has_lease();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.LeaderLeaseRequest.lease)
}

// -------------------------------------------------------------------

// LeaderLeaseResponse

// optional .cockroach.roachpb.ResponseHeader header = 1;
inline bool LeaderLeaseResponse::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LeaderLeaseResponse::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LeaderLeaseResponse::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LeaderLeaseResponse::clear_header() {
  if (header_ != NULL) header_->::cockroach::roachpb::ResponseHeader::Clear();
  clear_has_header();
}
inline const ::cockroach::roachpb::ResponseHeader& LeaderLeaseResponse::header() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.LeaderLeaseResponse.header)
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
inline ::cockroach::roachpb::ResponseHeader* LeaderLeaseResponse::mutable_header() {
  set_has_header();
  if (header_ == NULL) {
    header_ = new ::cockroach::roachpb::ResponseHeader;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.LeaderLeaseResponse.header)
  return header_;
}
inline ::cockroach::roachpb::ResponseHeader* LeaderLeaseResponse::release_header() {
  clear_has_header();
  ::cockroach::roachpb::ResponseHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void LeaderLeaseResponse::set_allocated_header(::cockroach::roachpb::ResponseHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.LeaderLeaseResponse.header)
}

// -------------------------------------------------------------------

// ComputeChecksumRequest

// optional .cockroach.roachpb.Span header = 1;
inline bool ComputeChecksumRequest::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ComputeChecksumRequest::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ComputeChecksumRequest::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ComputeChecksumRequest::clear_header() {
  if (header_ != NULL) header_->::cockroach::roachpb::Span::Clear();
  clear_has_header();
}
inline const ::cockroach::roachpb::Span& ComputeChecksumRequest::header() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.ComputeChecksumRequest.header)
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
inline ::cockroach::roachpb::Span* ComputeChecksumRequest::mutable_header() {
  set_has_header();
  if (header_ == NULL) {
    header_ = new ::cockroach::roachpb::Span;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.ComputeChecksumRequest.header)
  return header_;
}
inline ::cockroach::roachpb::Span* ComputeChecksumRequest::release_header() {
  clear_has_header();
  ::cockroach::roachpb::Span* temp = header_;
  header_ = NULL;
  return temp;
}
inline void ComputeChecksumRequest::set_allocated_header(::cockroach::roachpb::Span* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.ComputeChecksumRequest.header)
}

// optional uint32 version = 2;
inline bool ComputeChecksumRequest::has_version() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ComputeChecksumRequest::set_has_version() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ComputeChecksumRequest::clear_has_version() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ComputeChecksumRequest::clear_version() {
  version_ = 0u;
  clear_has_version();
}
inline ::google::protobuf::uint32 ComputeChecksumRequest::version() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.ComputeChecksumRequest.version)
  return version_;
}
inline void ComputeChecksumRequest::set_version(::google::protobuf::uint32 value) {
  set_has_version();
  version_ = value;
  // @@protoc_insertion_point(field_set:cockroach.roachpb.ComputeChecksumRequest.version)
}

// optional bytes checksum_id = 3;
inline bool ComputeChecksumRequest::has_checksum_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ComputeChecksumRequest::set_has_checksum_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ComputeChecksumRequest::clear_has_checksum_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ComputeChecksumRequest::clear_checksum_id() {
  checksum_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_checksum_id();
}
inline const ::std::string& ComputeChecksumRequest::checksum_id() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.ComputeChecksumRequest.checksum_id)
  return checksum_id_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ComputeChecksumRequest::set_checksum_id(const ::std::string& value) {
  set_has_checksum_id();
  checksum_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cockroach.roachpb.ComputeChecksumRequest.checksum_id)
}
inline void ComputeChecksumRequest::set_checksum_id(const char* value) {
  set_has_checksum_id();
  checksum_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cockroach.roachpb.ComputeChecksumRequest.checksum_id)
}
inline void ComputeChecksumRequest::set_checksum_id(const void* value, size_t size) {
  set_has_checksum_id();
  checksum_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cockroach.roachpb.ComputeChecksumRequest.checksum_id)
}
inline ::std::string* ComputeChecksumRequest::mutable_checksum_id() {
  set_has_checksum_id();
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.ComputeChecksumRequest.checksum_id)
  return checksum_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ComputeChecksumRequest::release_checksum_id() {
  clear_has_checksum_id();
  return checksum_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ComputeChecksumRequest::set_allocated_checksum_id(::std::string* checksum_id) {
  if (checksum_id != NULL) {
    set_has_checksum_id();
  } else {
    clear_has_checksum_id();
  }
  checksum_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), checksum_id);
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.ComputeChecksumRequest.checksum_id)
}

// -------------------------------------------------------------------

// ComputeChecksumResponse

// optional .cockroach.roachpb.ResponseHeader header = 1;
inline bool ComputeChecksumResponse::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ComputeChecksumResponse::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ComputeChecksumResponse::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ComputeChecksumResponse::clear_header() {
  if (header_ != NULL) header_->::cockroach::roachpb::ResponseHeader::Clear();
  clear_has_header();
}
inline const ::cockroach::roachpb::ResponseHeader& ComputeChecksumResponse::header() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.ComputeChecksumResponse.header)
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
inline ::cockroach::roachpb::ResponseHeader* ComputeChecksumResponse::mutable_header() {
  set_has_header();
  if (header_ == NULL) {
    header_ = new ::cockroach::roachpb::ResponseHeader;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.ComputeChecksumResponse.header)
  return header_;
}
inline ::cockroach::roachpb::ResponseHeader* ComputeChecksumResponse::release_header() {
  clear_has_header();
  ::cockroach::roachpb::ResponseHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void ComputeChecksumResponse::set_allocated_header(::cockroach::roachpb::ResponseHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.ComputeChecksumResponse.header)
}

// -------------------------------------------------------------------

// VerifyChecksumRequest

// optional .cockroach.roachpb.Span header = 1;
inline bool VerifyChecksumRequest::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void VerifyChecksumRequest::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void VerifyChecksumRequest::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void VerifyChecksumRequest::clear_header() {
  if (header_ != NULL) header_->::cockroach::roachpb::Span::Clear();
  clear_has_header();
}
inline const ::cockroach::roachpb::Span& VerifyChecksumRequest::header() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.VerifyChecksumRequest.header)
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
inline ::cockroach::roachpb::Span* VerifyChecksumRequest::mutable_header() {
  set_has_header();
  if (header_ == NULL) {
    header_ = new ::cockroach::roachpb::Span;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.VerifyChecksumRequest.header)
  return header_;
}
inline ::cockroach::roachpb::Span* VerifyChecksumRequest::release_header() {
  clear_has_header();
  ::cockroach::roachpb::Span* temp = header_;
  header_ = NULL;
  return temp;
}
inline void VerifyChecksumRequest::set_allocated_header(::cockroach::roachpb::Span* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.VerifyChecksumRequest.header)
}

// optional uint32 version = 2;
inline bool VerifyChecksumRequest::has_version() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void VerifyChecksumRequest::set_has_version() {
  _has_bits_[0] |= 0x00000002u;
}
inline void VerifyChecksumRequest::clear_has_version() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void VerifyChecksumRequest::clear_version() {
  version_ = 0u;
  clear_has_version();
}
inline ::google::protobuf::uint32 VerifyChecksumRequest::version() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.VerifyChecksumRequest.version)
  return version_;
}
inline void VerifyChecksumRequest::set_version(::google::protobuf::uint32 value) {
  set_has_version();
  version_ = value;
  // @@protoc_insertion_point(field_set:cockroach.roachpb.VerifyChecksumRequest.version)
}

// optional bytes checksum_id = 3;
inline bool VerifyChecksumRequest::has_checksum_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void VerifyChecksumRequest::set_has_checksum_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void VerifyChecksumRequest::clear_has_checksum_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void VerifyChecksumRequest::clear_checksum_id() {
  checksum_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_checksum_id();
}
inline const ::std::string& VerifyChecksumRequest::checksum_id() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.VerifyChecksumRequest.checksum_id)
  return checksum_id_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void VerifyChecksumRequest::set_checksum_id(const ::std::string& value) {
  set_has_checksum_id();
  checksum_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cockroach.roachpb.VerifyChecksumRequest.checksum_id)
}
inline void VerifyChecksumRequest::set_checksum_id(const char* value) {
  set_has_checksum_id();
  checksum_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cockroach.roachpb.VerifyChecksumRequest.checksum_id)
}
inline void VerifyChecksumRequest::set_checksum_id(const void* value, size_t size) {
  set_has_checksum_id();
  checksum_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cockroach.roachpb.VerifyChecksumRequest.checksum_id)
}
inline ::std::string* VerifyChecksumRequest::mutable_checksum_id() {
  set_has_checksum_id();
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.VerifyChecksumRequest.checksum_id)
  return checksum_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* VerifyChecksumRequest::release_checksum_id() {
  clear_has_checksum_id();
  return checksum_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void VerifyChecksumRequest::set_allocated_checksum_id(::std::string* checksum_id) {
  if (checksum_id != NULL) {
    set_has_checksum_id();
  } else {
    clear_has_checksum_id();
  }
  checksum_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), checksum_id);
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.VerifyChecksumRequest.checksum_id)
}

// optional bytes checksum = 4;
inline bool VerifyChecksumRequest::has_checksum() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void VerifyChecksumRequest::set_has_checksum() {
  _has_bits_[0] |= 0x00000008u;
}
inline void VerifyChecksumRequest::clear_has_checksum() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void VerifyChecksumRequest::clear_checksum() {
  checksum_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_checksum();
}
inline const ::std::string& VerifyChecksumRequest::checksum() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.VerifyChecksumRequest.checksum)
  return checksum_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void VerifyChecksumRequest::set_checksum(const ::std::string& value) {
  set_has_checksum();
  checksum_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cockroach.roachpb.VerifyChecksumRequest.checksum)
}
inline void VerifyChecksumRequest::set_checksum(const char* value) {
  set_has_checksum();
  checksum_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cockroach.roachpb.VerifyChecksumRequest.checksum)
}
inline void VerifyChecksumRequest::set_checksum(const void* value, size_t size) {
  set_has_checksum();
  checksum_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cockroach.roachpb.VerifyChecksumRequest.checksum)
}
inline ::std::string* VerifyChecksumRequest::mutable_checksum() {
  set_has_checksum();
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.VerifyChecksumRequest.checksum)
  return checksum_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* VerifyChecksumRequest::release_checksum() {
  clear_has_checksum();
  return checksum_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void VerifyChecksumRequest::set_allocated_checksum(::std::string* checksum) {
  if (checksum != NULL) {
    set_has_checksum();
  } else {
    clear_has_checksum();
  }
  checksum_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), checksum);
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.VerifyChecksumRequest.checksum)
}

// -------------------------------------------------------------------

// VerifyChecksumResponse

// optional .cockroach.roachpb.ResponseHeader header = 1;
inline bool VerifyChecksumResponse::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void VerifyChecksumResponse::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void VerifyChecksumResponse::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void VerifyChecksumResponse::clear_header() {
  if (header_ != NULL) header_->::cockroach::roachpb::ResponseHeader::Clear();
  clear_has_header();
}
inline const ::cockroach::roachpb::ResponseHeader& VerifyChecksumResponse::header() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.VerifyChecksumResponse.header)
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
inline ::cockroach::roachpb::ResponseHeader* VerifyChecksumResponse::mutable_header() {
  set_has_header();
  if (header_ == NULL) {
    header_ = new ::cockroach::roachpb::ResponseHeader;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.VerifyChecksumResponse.header)
  return header_;
}
inline ::cockroach::roachpb::ResponseHeader* VerifyChecksumResponse::release_header() {
  clear_has_header();
  ::cockroach::roachpb::ResponseHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void VerifyChecksumResponse::set_allocated_header(::cockroach::roachpb::ResponseHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.VerifyChecksumResponse.header)
}

// -------------------------------------------------------------------

// RequestUnion

// optional .cockroach.roachpb.GetRequest get = 1;
inline bool RequestUnion::has_get() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestUnion::set_has_get() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestUnion::clear_has_get() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestUnion::clear_get() {
  if (get_ != NULL) get_->::cockroach::roachpb::GetRequest::Clear();
  clear_has_get();
}
inline const ::cockroach::roachpb::GetRequest& RequestUnion::get() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.RequestUnion.get)
  return get_ != NULL ? *get_ : *default_instance_->get_;
}
inline ::cockroach::roachpb::GetRequest* RequestUnion::mutable_get() {
  set_has_get();
  if (get_ == NULL) {
    get_ = new ::cockroach::roachpb::GetRequest;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.RequestUnion.get)
  return get_;
}
inline ::cockroach::roachpb::GetRequest* RequestUnion::release_get() {
  clear_has_get();
  ::cockroach::roachpb::GetRequest* temp = get_;
  get_ = NULL;
  return temp;
}
inline void RequestUnion::set_allocated_get(::cockroach::roachpb::GetRequest* get) {
  delete get_;
  get_ = get;
  if (get) {
    set_has_get();
  } else {
    clear_has_get();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.RequestUnion.get)
}

// optional .cockroach.roachpb.PutRequest put = 2;
inline bool RequestUnion::has_put() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RequestUnion::set_has_put() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RequestUnion::clear_has_put() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RequestUnion::clear_put() {
  if (put_ != NULL) put_->::cockroach::roachpb::PutRequest::Clear();
  clear_has_put();
}
inline const ::cockroach::roachpb::PutRequest& RequestUnion::put() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.RequestUnion.put)
  return put_ != NULL ? *put_ : *default_instance_->put_;
}
inline ::cockroach::roachpb::PutRequest* RequestUnion::mutable_put() {
  set_has_put();
  if (put_ == NULL) {
    put_ = new ::cockroach::roachpb::PutRequest;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.RequestUnion.put)
  return put_;
}
inline ::cockroach::roachpb::PutRequest* RequestUnion::release_put() {
  clear_has_put();
  ::cockroach::roachpb::PutRequest* temp = put_;
  put_ = NULL;
  return temp;
}
inline void RequestUnion::set_allocated_put(::cockroach::roachpb::PutRequest* put) {
  delete put_;
  put_ = put;
  if (put) {
    set_has_put();
  } else {
    clear_has_put();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.RequestUnion.put)
}

// optional .cockroach.roachpb.ConditionalPutRequest conditional_put = 3;
inline bool RequestUnion::has_conditional_put() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RequestUnion::set_has_conditional_put() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RequestUnion::clear_has_conditional_put() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RequestUnion::clear_conditional_put() {
  if (conditional_put_ != NULL) conditional_put_->::cockroach::roachpb::ConditionalPutRequest::Clear();
  clear_has_conditional_put();
}
inline const ::cockroach::roachpb::ConditionalPutRequest& RequestUnion::conditional_put() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.RequestUnion.conditional_put)
  return conditional_put_ != NULL ? *conditional_put_ : *default_instance_->conditional_put_;
}
inline ::cockroach::roachpb::ConditionalPutRequest* RequestUnion::mutable_conditional_put() {
  set_has_conditional_put();
  if (conditional_put_ == NULL) {
    conditional_put_ = new ::cockroach::roachpb::ConditionalPutRequest;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.RequestUnion.conditional_put)
  return conditional_put_;
}
inline ::cockroach::roachpb::ConditionalPutRequest* RequestUnion::release_conditional_put() {
  clear_has_conditional_put();
  ::cockroach::roachpb::ConditionalPutRequest* temp = conditional_put_;
  conditional_put_ = NULL;
  return temp;
}
inline void RequestUnion::set_allocated_conditional_put(::cockroach::roachpb::ConditionalPutRequest* conditional_put) {
  delete conditional_put_;
  conditional_put_ = conditional_put;
  if (conditional_put) {
    set_has_conditional_put();
  } else {
    clear_has_conditional_put();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.RequestUnion.conditional_put)
}

// optional .cockroach.roachpb.IncrementRequest increment = 4;
inline bool RequestUnion::has_increment() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RequestUnion::set_has_increment() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RequestUnion::clear_has_increment() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RequestUnion::clear_increment() {
  if (increment_ != NULL) increment_->::cockroach::roachpb::IncrementRequest::Clear();
  clear_has_increment();
}
inline const ::cockroach::roachpb::IncrementRequest& RequestUnion::increment() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.RequestUnion.increment)
  return increment_ != NULL ? *increment_ : *default_instance_->increment_;
}
inline ::cockroach::roachpb::IncrementRequest* RequestUnion::mutable_increment() {
  set_has_increment();
  if (increment_ == NULL) {
    increment_ = new ::cockroach::roachpb::IncrementRequest;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.RequestUnion.increment)
  return increment_;
}
inline ::cockroach::roachpb::IncrementRequest* RequestUnion::release_increment() {
  clear_has_increment();
  ::cockroach::roachpb::IncrementRequest* temp = increment_;
  increment_ = NULL;
  return temp;
}
inline void RequestUnion::set_allocated_increment(::cockroach::roachpb::IncrementRequest* increment) {
  delete increment_;
  increment_ = increment;
  if (increment) {
    set_has_increment();
  } else {
    clear_has_increment();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.RequestUnion.increment)
}

// optional .cockroach.roachpb.DeleteRequest delete = 5;
inline bool RequestUnion::has_delete_() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RequestUnion::set_has_delete_() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RequestUnion::clear_has_delete_() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RequestUnion::clear_delete_() {
  if (delete__ != NULL) delete__->::cockroach::roachpb::DeleteRequest::Clear();
  clear_has_delete_();
}
inline const ::cockroach::roachpb::DeleteRequest& RequestUnion::delete_() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.RequestUnion.delete)
  return delete__ != NULL ? *delete__ : *default_instance_->delete__;
}
inline ::cockroach::roachpb::DeleteRequest* RequestUnion::mutable_delete_() {
  set_has_delete_();
  if (delete__ == NULL) {
    delete__ = new ::cockroach::roachpb::DeleteRequest;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.RequestUnion.delete)
  return delete__;
}
inline ::cockroach::roachpb::DeleteRequest* RequestUnion::release_delete_() {
  clear_has_delete_();
  ::cockroach::roachpb::DeleteRequest* temp = delete__;
  delete__ = NULL;
  return temp;
}
inline void RequestUnion::set_allocated_delete_(::cockroach::roachpb::DeleteRequest* delete_) {
  delete delete__;
  delete__ = delete_;
  if (delete_) {
    set_has_delete_();
  } else {
    clear_has_delete_();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.RequestUnion.delete)
}

// optional .cockroach.roachpb.DeleteRangeRequest delete_range = 6;
inline bool RequestUnion::has_delete_range() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void RequestUnion::set_has_delete_range() {
  _has_bits_[0] |= 0x00000020u;
}
inline void RequestUnion::clear_has_delete_range() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void RequestUnion::clear_delete_range() {
  if (delete_range_ != NULL) delete_range_->::cockroach::roachpb::DeleteRangeRequest::Clear();
  clear_has_delete_range();
}
inline const ::cockroach::roachpb::DeleteRangeRequest& RequestUnion::delete_range() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.RequestUnion.delete_range)
  return delete_range_ != NULL ? *delete_range_ : *default_instance_->delete_range_;
}
inline ::cockroach::roachpb::DeleteRangeRequest* RequestUnion::mutable_delete_range() {
  set_has_delete_range();
  if (delete_range_ == NULL) {
    delete_range_ = new ::cockroach::roachpb::DeleteRangeRequest;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.RequestUnion.delete_range)
  return delete_range_;
}
inline ::cockroach::roachpb::DeleteRangeRequest* RequestUnion::release_delete_range() {
  clear_has_delete_range();
  ::cockroach::roachpb::DeleteRangeRequest* temp = delete_range_;
  delete_range_ = NULL;
  return temp;
}
inline void RequestUnion::set_allocated_delete_range(::cockroach::roachpb::DeleteRangeRequest* delete_range) {
  delete delete_range_;
  delete_range_ = delete_range;
  if (delete_range) {
    set_has_delete_range();
  } else {
    clear_has_delete_range();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.RequestUnion.delete_range)
}

// optional .cockroach.roachpb.ScanRequest scan = 7;
inline bool RequestUnion::has_scan() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void RequestUnion::set_has_scan() {
  _has_bits_[0] |= 0x00000040u;
}
inline void RequestUnion::clear_has_scan() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void RequestUnion::clear_scan() {
  if (scan_ != NULL) scan_->::cockroach::roachpb::ScanRequest::Clear();
  clear_has_scan();
}
inline const ::cockroach::roachpb::ScanRequest& RequestUnion::scan() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.RequestUnion.scan)
  return scan_ != NULL ? *scan_ : *default_instance_->scan_;
}
inline ::cockroach::roachpb::ScanRequest* RequestUnion::mutable_scan() {
  set_has_scan();
  if (scan_ == NULL) {
    scan_ = new ::cockroach::roachpb::ScanRequest;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.RequestUnion.scan)
  return scan_;
}
inline ::cockroach::roachpb::ScanRequest* RequestUnion::release_scan() {
  clear_has_scan();
  ::cockroach::roachpb::ScanRequest* temp = scan_;
  scan_ = NULL;
  return temp;
}
inline void RequestUnion::set_allocated_scan(::cockroach::roachpb::ScanRequest* scan) {
  delete scan_;
  scan_ = scan;
  if (scan) {
    set_has_scan();
  } else {
    clear_has_scan();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.RequestUnion.scan)
}

// optional .cockroach.roachpb.BeginTransactionRequest begin_transaction = 8;
inline bool RequestUnion::has_begin_transaction() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void RequestUnion::set_has_begin_transaction() {
  _has_bits_[0] |= 0x00000080u;
}
inline void RequestUnion::clear_has_begin_transaction() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void RequestUnion::clear_begin_transaction() {
  if (begin_transaction_ != NULL) begin_transaction_->::cockroach::roachpb::BeginTransactionRequest::Clear();
  clear_has_begin_transaction();
}
inline const ::cockroach::roachpb::BeginTransactionRequest& RequestUnion::begin_transaction() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.RequestUnion.begin_transaction)
  return begin_transaction_ != NULL ? *begin_transaction_ : *default_instance_->begin_transaction_;
}
inline ::cockroach::roachpb::BeginTransactionRequest* RequestUnion::mutable_begin_transaction() {
  set_has_begin_transaction();
  if (begin_transaction_ == NULL) {
    begin_transaction_ = new ::cockroach::roachpb::BeginTransactionRequest;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.RequestUnion.begin_transaction)
  return begin_transaction_;
}
inline ::cockroach::roachpb::BeginTransactionRequest* RequestUnion::release_begin_transaction() {
  clear_has_begin_transaction();
  ::cockroach::roachpb::BeginTransactionRequest* temp = begin_transaction_;
  begin_transaction_ = NULL;
  return temp;
}
inline void RequestUnion::set_allocated_begin_transaction(::cockroach::roachpb::BeginTransactionRequest* begin_transaction) {
  delete begin_transaction_;
  begin_transaction_ = begin_transaction;
  if (begin_transaction) {
    set_has_begin_transaction();
  } else {
    clear_has_begin_transaction();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.RequestUnion.begin_transaction)
}

// optional .cockroach.roachpb.EndTransactionRequest end_transaction = 9;
inline bool RequestUnion::has_end_transaction() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void RequestUnion::set_has_end_transaction() {
  _has_bits_[0] |= 0x00000100u;
}
inline void RequestUnion::clear_has_end_transaction() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void RequestUnion::clear_end_transaction() {
  if (end_transaction_ != NULL) end_transaction_->::cockroach::roachpb::EndTransactionRequest::Clear();
  clear_has_end_transaction();
}
inline const ::cockroach::roachpb::EndTransactionRequest& RequestUnion::end_transaction() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.RequestUnion.end_transaction)
  return end_transaction_ != NULL ? *end_transaction_ : *default_instance_->end_transaction_;
}
inline ::cockroach::roachpb::EndTransactionRequest* RequestUnion::mutable_end_transaction() {
  set_has_end_transaction();
  if (end_transaction_ == NULL) {
    end_transaction_ = new ::cockroach::roachpb::EndTransactionRequest;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.RequestUnion.end_transaction)
  return end_transaction_;
}
inline ::cockroach::roachpb::EndTransactionRequest* RequestUnion::release_end_transaction() {
  clear_has_end_transaction();
  ::cockroach::roachpb::EndTransactionRequest* temp = end_transaction_;
  end_transaction_ = NULL;
  return temp;
}
inline void RequestUnion::set_allocated_end_transaction(::cockroach::roachpb::EndTransactionRequest* end_transaction) {
  delete end_transaction_;
  end_transaction_ = end_transaction;
  if (end_transaction) {
    set_has_end_transaction();
  } else {
    clear_has_end_transaction();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.RequestUnion.end_transaction)
}

// optional .cockroach.roachpb.AdminSplitRequest admin_split = 10;
inline bool RequestUnion::has_admin_split() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void RequestUnion::set_has_admin_split() {
  _has_bits_[0] |= 0x00000200u;
}
inline void RequestUnion::clear_has_admin_split() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void RequestUnion::clear_admin_split() {
  if (admin_split_ != NULL) admin_split_->::cockroach::roachpb::AdminSplitRequest::Clear();
  clear_has_admin_split();
}
inline const ::cockroach::roachpb::AdminSplitRequest& RequestUnion::admin_split() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.RequestUnion.admin_split)
  return admin_split_ != NULL ? *admin_split_ : *default_instance_->admin_split_;
}
inline ::cockroach::roachpb::AdminSplitRequest* RequestUnion::mutable_admin_split() {
  set_has_admin_split();
  if (admin_split_ == NULL) {
    admin_split_ = new ::cockroach::roachpb::AdminSplitRequest;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.RequestUnion.admin_split)
  return admin_split_;
}
inline ::cockroach::roachpb::AdminSplitRequest* RequestUnion::release_admin_split() {
  clear_has_admin_split();
  ::cockroach::roachpb::AdminSplitRequest* temp = admin_split_;
  admin_split_ = NULL;
  return temp;
}
inline void RequestUnion::set_allocated_admin_split(::cockroach::roachpb::AdminSplitRequest* admin_split) {
  delete admin_split_;
  admin_split_ = admin_split;
  if (admin_split) {
    set_has_admin_split();
  } else {
    clear_has_admin_split();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.RequestUnion.admin_split)
}

// optional .cockroach.roachpb.AdminMergeRequest admin_merge = 11;
inline bool RequestUnion::has_admin_merge() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void RequestUnion::set_has_admin_merge() {
  _has_bits_[0] |= 0x00000400u;
}
inline void RequestUnion::clear_has_admin_merge() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void RequestUnion::clear_admin_merge() {
  if (admin_merge_ != NULL) admin_merge_->::cockroach::roachpb::AdminMergeRequest::Clear();
  clear_has_admin_merge();
}
inline const ::cockroach::roachpb::AdminMergeRequest& RequestUnion::admin_merge() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.RequestUnion.admin_merge)
  return admin_merge_ != NULL ? *admin_merge_ : *default_instance_->admin_merge_;
}
inline ::cockroach::roachpb::AdminMergeRequest* RequestUnion::mutable_admin_merge() {
  set_has_admin_merge();
  if (admin_merge_ == NULL) {
    admin_merge_ = new ::cockroach::roachpb::AdminMergeRequest;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.RequestUnion.admin_merge)
  return admin_merge_;
}
inline ::cockroach::roachpb::AdminMergeRequest* RequestUnion::release_admin_merge() {
  clear_has_admin_merge();
  ::cockroach::roachpb::AdminMergeRequest* temp = admin_merge_;
  admin_merge_ = NULL;
  return temp;
}
inline void RequestUnion::set_allocated_admin_merge(::cockroach::roachpb::AdminMergeRequest* admin_merge) {
  delete admin_merge_;
  admin_merge_ = admin_merge;
  if (admin_merge) {
    set_has_admin_merge();
  } else {
    clear_has_admin_merge();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.RequestUnion.admin_merge)
}

// optional .cockroach.roachpb.HeartbeatTxnRequest heartbeat_txn = 12;
inline bool RequestUnion::has_heartbeat_txn() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void RequestUnion::set_has_heartbeat_txn() {
  _has_bits_[0] |= 0x00000800u;
}
inline void RequestUnion::clear_has_heartbeat_txn() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void RequestUnion::clear_heartbeat_txn() {
  if (heartbeat_txn_ != NULL) heartbeat_txn_->::cockroach::roachpb::HeartbeatTxnRequest::Clear();
  clear_has_heartbeat_txn();
}
inline const ::cockroach::roachpb::HeartbeatTxnRequest& RequestUnion::heartbeat_txn() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.RequestUnion.heartbeat_txn)
  return heartbeat_txn_ != NULL ? *heartbeat_txn_ : *default_instance_->heartbeat_txn_;
}
inline ::cockroach::roachpb::HeartbeatTxnRequest* RequestUnion::mutable_heartbeat_txn() {
  set_has_heartbeat_txn();
  if (heartbeat_txn_ == NULL) {
    heartbeat_txn_ = new ::cockroach::roachpb::HeartbeatTxnRequest;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.RequestUnion.heartbeat_txn)
  return heartbeat_txn_;
}
inline ::cockroach::roachpb::HeartbeatTxnRequest* RequestUnion::release_heartbeat_txn() {
  clear_has_heartbeat_txn();
  ::cockroach::roachpb::HeartbeatTxnRequest* temp = heartbeat_txn_;
  heartbeat_txn_ = NULL;
  return temp;
}
inline void RequestUnion::set_allocated_heartbeat_txn(::cockroach::roachpb::HeartbeatTxnRequest* heartbeat_txn) {
  delete heartbeat_txn_;
  heartbeat_txn_ = heartbeat_txn;
  if (heartbeat_txn) {
    set_has_heartbeat_txn();
  } else {
    clear_has_heartbeat_txn();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.RequestUnion.heartbeat_txn)
}

// optional .cockroach.roachpb.GCRequest gc = 13;
inline bool RequestUnion::has_gc() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void RequestUnion::set_has_gc() {
  _has_bits_[0] |= 0x00001000u;
}
inline void RequestUnion::clear_has_gc() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void RequestUnion::clear_gc() {
  if (gc_ != NULL) gc_->::cockroach::roachpb::GCRequest::Clear();
  clear_has_gc();
}
inline const ::cockroach::roachpb::GCRequest& RequestUnion::gc() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.RequestUnion.gc)
  return gc_ != NULL ? *gc_ : *default_instance_->gc_;
}
inline ::cockroach::roachpb::GCRequest* RequestUnion::mutable_gc() {
  set_has_gc();
  if (gc_ == NULL) {
    gc_ = new ::cockroach::roachpb::GCRequest;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.RequestUnion.gc)
  return gc_;
}
inline ::cockroach::roachpb::GCRequest* RequestUnion::release_gc() {
  clear_has_gc();
  ::cockroach::roachpb::GCRequest* temp = gc_;
  gc_ = NULL;
  return temp;
}
inline void RequestUnion::set_allocated_gc(::cockroach::roachpb::GCRequest* gc) {
  delete gc_;
  gc_ = gc;
  if (gc) {
    set_has_gc();
  } else {
    clear_has_gc();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.RequestUnion.gc)
}

// optional .cockroach.roachpb.PushTxnRequest push_txn = 14;
inline bool RequestUnion::has_push_txn() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void RequestUnion::set_has_push_txn() {
  _has_bits_[0] |= 0x00002000u;
}
inline void RequestUnion::clear_has_push_txn() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void RequestUnion::clear_push_txn() {
  if (push_txn_ != NULL) push_txn_->::cockroach::roachpb::PushTxnRequest::Clear();
  clear_has_push_txn();
}
inline const ::cockroach::roachpb::PushTxnRequest& RequestUnion::push_txn() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.RequestUnion.push_txn)
  return push_txn_ != NULL ? *push_txn_ : *default_instance_->push_txn_;
}
inline ::cockroach::roachpb::PushTxnRequest* RequestUnion::mutable_push_txn() {
  set_has_push_txn();
  if (push_txn_ == NULL) {
    push_txn_ = new ::cockroach::roachpb::PushTxnRequest;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.RequestUnion.push_txn)
  return push_txn_;
}
inline ::cockroach::roachpb::PushTxnRequest* RequestUnion::release_push_txn() {
  clear_has_push_txn();
  ::cockroach::roachpb::PushTxnRequest* temp = push_txn_;
  push_txn_ = NULL;
  return temp;
}
inline void RequestUnion::set_allocated_push_txn(::cockroach::roachpb::PushTxnRequest* push_txn) {
  delete push_txn_;
  push_txn_ = push_txn;
  if (push_txn) {
    set_has_push_txn();
  } else {
    clear_has_push_txn();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.RequestUnion.push_txn)
}

// optional .cockroach.roachpb.RangeLookupRequest range_lookup = 15;
inline bool RequestUnion::has_range_lookup() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void RequestUnion::set_has_range_lookup() {
  _has_bits_[0] |= 0x00004000u;
}
inline void RequestUnion::clear_has_range_lookup() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void RequestUnion::clear_range_lookup() {
  if (range_lookup_ != NULL) range_lookup_->::cockroach::roachpb::RangeLookupRequest::Clear();
  clear_has_range_lookup();
}
inline const ::cockroach::roachpb::RangeLookupRequest& RequestUnion::range_lookup() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.RequestUnion.range_lookup)
  return range_lookup_ != NULL ? *range_lookup_ : *default_instance_->range_lookup_;
}
inline ::cockroach::roachpb::RangeLookupRequest* RequestUnion::mutable_range_lookup() {
  set_has_range_lookup();
  if (range_lookup_ == NULL) {
    range_lookup_ = new ::cockroach::roachpb::RangeLookupRequest;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.RequestUnion.range_lookup)
  return range_lookup_;
}
inline ::cockroach::roachpb::RangeLookupRequest* RequestUnion::release_range_lookup() {
  clear_has_range_lookup();
  ::cockroach::roachpb::RangeLookupRequest* temp = range_lookup_;
  range_lookup_ = NULL;
  return temp;
}
inline void RequestUnion::set_allocated_range_lookup(::cockroach::roachpb::RangeLookupRequest* range_lookup) {
  delete range_lookup_;
  range_lookup_ = range_lookup;
  if (range_lookup) {
    set_has_range_lookup();
  } else {
    clear_has_range_lookup();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.RequestUnion.range_lookup)
}

// optional .cockroach.roachpb.ResolveIntentRequest resolve_intent = 16;
inline bool RequestUnion::has_resolve_intent() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void RequestUnion::set_has_resolve_intent() {
  _has_bits_[0] |= 0x00008000u;
}
inline void RequestUnion::clear_has_resolve_intent() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void RequestUnion::clear_resolve_intent() {
  if (resolve_intent_ != NULL) resolve_intent_->::cockroach::roachpb::ResolveIntentRequest::Clear();
  clear_has_resolve_intent();
}
inline const ::cockroach::roachpb::ResolveIntentRequest& RequestUnion::resolve_intent() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.RequestUnion.resolve_intent)
  return resolve_intent_ != NULL ? *resolve_intent_ : *default_instance_->resolve_intent_;
}
inline ::cockroach::roachpb::ResolveIntentRequest* RequestUnion::mutable_resolve_intent() {
  set_has_resolve_intent();
  if (resolve_intent_ == NULL) {
    resolve_intent_ = new ::cockroach::roachpb::ResolveIntentRequest;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.RequestUnion.resolve_intent)
  return resolve_intent_;
}
inline ::cockroach::roachpb::ResolveIntentRequest* RequestUnion::release_resolve_intent() {
  clear_has_resolve_intent();
  ::cockroach::roachpb::ResolveIntentRequest* temp = resolve_intent_;
  resolve_intent_ = NULL;
  return temp;
}
inline void RequestUnion::set_allocated_resolve_intent(::cockroach::roachpb::ResolveIntentRequest* resolve_intent) {
  delete resolve_intent_;
  resolve_intent_ = resolve_intent;
  if (resolve_intent) {
    set_has_resolve_intent();
  } else {
    clear_has_resolve_intent();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.RequestUnion.resolve_intent)
}

// optional .cockroach.roachpb.ResolveIntentRangeRequest resolve_intent_range = 17;
inline bool RequestUnion::has_resolve_intent_range() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void RequestUnion::set_has_resolve_intent_range() {
  _has_bits_[0] |= 0x00010000u;
}
inline void RequestUnion::clear_has_resolve_intent_range() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void RequestUnion::clear_resolve_intent_range() {
  if (resolve_intent_range_ != NULL) resolve_intent_range_->::cockroach::roachpb::ResolveIntentRangeRequest::Clear();
  clear_has_resolve_intent_range();
}
inline const ::cockroach::roachpb::ResolveIntentRangeRequest& RequestUnion::resolve_intent_range() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.RequestUnion.resolve_intent_range)
  return resolve_intent_range_ != NULL ? *resolve_intent_range_ : *default_instance_->resolve_intent_range_;
}
inline ::cockroach::roachpb::ResolveIntentRangeRequest* RequestUnion::mutable_resolve_intent_range() {
  set_has_resolve_intent_range();
  if (resolve_intent_range_ == NULL) {
    resolve_intent_range_ = new ::cockroach::roachpb::ResolveIntentRangeRequest;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.RequestUnion.resolve_intent_range)
  return resolve_intent_range_;
}
inline ::cockroach::roachpb::ResolveIntentRangeRequest* RequestUnion::release_resolve_intent_range() {
  clear_has_resolve_intent_range();
  ::cockroach::roachpb::ResolveIntentRangeRequest* temp = resolve_intent_range_;
  resolve_intent_range_ = NULL;
  return temp;
}
inline void RequestUnion::set_allocated_resolve_intent_range(::cockroach::roachpb::ResolveIntentRangeRequest* resolve_intent_range) {
  delete resolve_intent_range_;
  resolve_intent_range_ = resolve_intent_range;
  if (resolve_intent_range) {
    set_has_resolve_intent_range();
  } else {
    clear_has_resolve_intent_range();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.RequestUnion.resolve_intent_range)
}

// optional .cockroach.roachpb.MergeRequest merge = 18;
inline bool RequestUnion::has_merge() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void RequestUnion::set_has_merge() {
  _has_bits_[0] |= 0x00020000u;
}
inline void RequestUnion::clear_has_merge() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void RequestUnion::clear_merge() {
  if (merge_ != NULL) merge_->::cockroach::roachpb::MergeRequest::Clear();
  clear_has_merge();
}
inline const ::cockroach::roachpb::MergeRequest& RequestUnion::merge() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.RequestUnion.merge)
  return merge_ != NULL ? *merge_ : *default_instance_->merge_;
}
inline ::cockroach::roachpb::MergeRequest* RequestUnion::mutable_merge() {
  set_has_merge();
  if (merge_ == NULL) {
    merge_ = new ::cockroach::roachpb::MergeRequest;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.RequestUnion.merge)
  return merge_;
}
inline ::cockroach::roachpb::MergeRequest* RequestUnion::release_merge() {
  clear_has_merge();
  ::cockroach::roachpb::MergeRequest* temp = merge_;
  merge_ = NULL;
  return temp;
}
inline void RequestUnion::set_allocated_merge(::cockroach::roachpb::MergeRequest* merge) {
  delete merge_;
  merge_ = merge;
  if (merge) {
    set_has_merge();
  } else {
    clear_has_merge();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.RequestUnion.merge)
}

// optional .cockroach.roachpb.TruncateLogRequest truncate_log = 19;
inline bool RequestUnion::has_truncate_log() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void RequestUnion::set_has_truncate_log() {
  _has_bits_[0] |= 0x00040000u;
}
inline void RequestUnion::clear_has_truncate_log() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void RequestUnion::clear_truncate_log() {
  if (truncate_log_ != NULL) truncate_log_->::cockroach::roachpb::TruncateLogRequest::Clear();
  clear_has_truncate_log();
}
inline const ::cockroach::roachpb::TruncateLogRequest& RequestUnion::truncate_log() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.RequestUnion.truncate_log)
  return truncate_log_ != NULL ? *truncate_log_ : *default_instance_->truncate_log_;
}
inline ::cockroach::roachpb::TruncateLogRequest* RequestUnion::mutable_truncate_log() {
  set_has_truncate_log();
  if (truncate_log_ == NULL) {
    truncate_log_ = new ::cockroach::roachpb::TruncateLogRequest;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.RequestUnion.truncate_log)
  return truncate_log_;
}
inline ::cockroach::roachpb::TruncateLogRequest* RequestUnion::release_truncate_log() {
  clear_has_truncate_log();
  ::cockroach::roachpb::TruncateLogRequest* temp = truncate_log_;
  truncate_log_ = NULL;
  return temp;
}
inline void RequestUnion::set_allocated_truncate_log(::cockroach::roachpb::TruncateLogRequest* truncate_log) {
  delete truncate_log_;
  truncate_log_ = truncate_log;
  if (truncate_log) {
    set_has_truncate_log();
  } else {
    clear_has_truncate_log();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.RequestUnion.truncate_log)
}

// optional .cockroach.roachpb.LeaderLeaseRequest leader_lease = 20;
inline bool RequestUnion::has_leader_lease() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void RequestUnion::set_has_leader_lease() {
  _has_bits_[0] |= 0x00080000u;
}
inline void RequestUnion::clear_has_leader_lease() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void RequestUnion::clear_leader_lease() {
  if (leader_lease_ != NULL) leader_lease_->::cockroach::roachpb::LeaderLeaseRequest::Clear();
  clear_has_leader_lease();
}
inline const ::cockroach::roachpb::LeaderLeaseRequest& RequestUnion::leader_lease() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.RequestUnion.leader_lease)
  return leader_lease_ != NULL ? *leader_lease_ : *default_instance_->leader_lease_;
}
inline ::cockroach::roachpb::LeaderLeaseRequest* RequestUnion::mutable_leader_lease() {
  set_has_leader_lease();
  if (leader_lease_ == NULL) {
    leader_lease_ = new ::cockroach::roachpb::LeaderLeaseRequest;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.RequestUnion.leader_lease)
  return leader_lease_;
}
inline ::cockroach::roachpb::LeaderLeaseRequest* RequestUnion::release_leader_lease() {
  clear_has_leader_lease();
  ::cockroach::roachpb::LeaderLeaseRequest* temp = leader_lease_;
  leader_lease_ = NULL;
  return temp;
}
inline void RequestUnion::set_allocated_leader_lease(::cockroach::roachpb::LeaderLeaseRequest* leader_lease) {
  delete leader_lease_;
  leader_lease_ = leader_lease;
  if (leader_lease) {
    set_has_leader_lease();
  } else {
    clear_has_leader_lease();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.RequestUnion.leader_lease)
}

// optional .cockroach.roachpb.ReverseScanRequest reverse_scan = 21;
inline bool RequestUnion::has_reverse_scan() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void RequestUnion::set_has_reverse_scan() {
  _has_bits_[0] |= 0x00100000u;
}
inline void RequestUnion::clear_has_reverse_scan() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void RequestUnion::clear_reverse_scan() {
  if (reverse_scan_ != NULL) reverse_scan_->::cockroach::roachpb::ReverseScanRequest::Clear();
  clear_has_reverse_scan();
}
inline const ::cockroach::roachpb::ReverseScanRequest& RequestUnion::reverse_scan() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.RequestUnion.reverse_scan)
  return reverse_scan_ != NULL ? *reverse_scan_ : *default_instance_->reverse_scan_;
}
inline ::cockroach::roachpb::ReverseScanRequest* RequestUnion::mutable_reverse_scan() {
  set_has_reverse_scan();
  if (reverse_scan_ == NULL) {
    reverse_scan_ = new ::cockroach::roachpb::ReverseScanRequest;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.RequestUnion.reverse_scan)
  return reverse_scan_;
}
inline ::cockroach::roachpb::ReverseScanRequest* RequestUnion::release_reverse_scan() {
  clear_has_reverse_scan();
  ::cockroach::roachpb::ReverseScanRequest* temp = reverse_scan_;
  reverse_scan_ = NULL;
  return temp;
}
inline void RequestUnion::set_allocated_reverse_scan(::cockroach::roachpb::ReverseScanRequest* reverse_scan) {
  delete reverse_scan_;
  reverse_scan_ = reverse_scan;
  if (reverse_scan) {
    set_has_reverse_scan();
  } else {
    clear_has_reverse_scan();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.RequestUnion.reverse_scan)
}

// optional .cockroach.roachpb.ComputeChecksumRequest compute_checksum = 22;
inline bool RequestUnion::has_compute_checksum() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void RequestUnion::set_has_compute_checksum() {
  _has_bits_[0] |= 0x00200000u;
}
inline void RequestUnion::clear_has_compute_checksum() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void RequestUnion::clear_compute_checksum() {
  if (compute_checksum_ != NULL) compute_checksum_->::cockroach::roachpb::ComputeChecksumRequest::Clear();
  clear_has_compute_checksum();
}
inline const ::cockroach::roachpb::ComputeChecksumRequest& RequestUnion::compute_checksum() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.RequestUnion.compute_checksum)
  return compute_checksum_ != NULL ? *compute_checksum_ : *default_instance_->compute_checksum_;
}
inline ::cockroach::roachpb::ComputeChecksumRequest* RequestUnion::mutable_compute_checksum() {
  set_has_compute_checksum();
  if (compute_checksum_ == NULL) {
    compute_checksum_ = new ::cockroach::roachpb::ComputeChecksumRequest;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.RequestUnion.compute_checksum)
  return compute_checksum_;
}
inline ::cockroach::roachpb::ComputeChecksumRequest* RequestUnion::release_compute_checksum() {
  clear_has_compute_checksum();
  ::cockroach::roachpb::ComputeChecksumRequest* temp = compute_checksum_;
  compute_checksum_ = NULL;
  return temp;
}
inline void RequestUnion::set_allocated_compute_checksum(::cockroach::roachpb::ComputeChecksumRequest* compute_checksum) {
  delete compute_checksum_;
  compute_checksum_ = compute_checksum;
  if (compute_checksum) {
    set_has_compute_checksum();
  } else {
    clear_has_compute_checksum();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.RequestUnion.compute_checksum)
}

// optional .cockroach.roachpb.VerifyChecksumRequest verify_checksum = 23;
inline bool RequestUnion::has_verify_checksum() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void RequestUnion::set_has_verify_checksum() {
  _has_bits_[0] |= 0x00400000u;
}
inline void RequestUnion::clear_has_verify_checksum() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void RequestUnion::clear_verify_checksum() {
  if (verify_checksum_ != NULL) verify_checksum_->::cockroach::roachpb::VerifyChecksumRequest::Clear();
  clear_has_verify_checksum();
}
inline const ::cockroach::roachpb::VerifyChecksumRequest& RequestUnion::verify_checksum() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.RequestUnion.verify_checksum)
  return verify_checksum_ != NULL ? *verify_checksum_ : *default_instance_->verify_checksum_;
}
inline ::cockroach::roachpb::VerifyChecksumRequest* RequestUnion::mutable_verify_checksum() {
  set_has_verify_checksum();
  if (verify_checksum_ == NULL) {
    verify_checksum_ = new ::cockroach::roachpb::VerifyChecksumRequest;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.RequestUnion.verify_checksum)
  return verify_checksum_;
}
inline ::cockroach::roachpb::VerifyChecksumRequest* RequestUnion::release_verify_checksum() {
  clear_has_verify_checksum();
  ::cockroach::roachpb::VerifyChecksumRequest* temp = verify_checksum_;
  verify_checksum_ = NULL;
  return temp;
}
inline void RequestUnion::set_allocated_verify_checksum(::cockroach::roachpb::VerifyChecksumRequest* verify_checksum) {
  delete verify_checksum_;
  verify_checksum_ = verify_checksum;
  if (verify_checksum) {
    set_has_verify_checksum();
  } else {
    clear_has_verify_checksum();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.RequestUnion.verify_checksum)
}

// optional .cockroach.roachpb.CheckConsistencyRequest check_consistency = 24;
inline bool RequestUnion::has_check_consistency() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void RequestUnion::set_has_check_consistency() {
  _has_bits_[0] |= 0x00800000u;
}
inline void RequestUnion::clear_has_check_consistency() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void RequestUnion::clear_check_consistency() {
  if (check_consistency_ != NULL) check_consistency_->::cockroach::roachpb::CheckConsistencyRequest::Clear();
  clear_has_check_consistency();
}
inline const ::cockroach::roachpb::CheckConsistencyRequest& RequestUnion::check_consistency() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.RequestUnion.check_consistency)
  return check_consistency_ != NULL ? *check_consistency_ : *default_instance_->check_consistency_;
}
inline ::cockroach::roachpb::CheckConsistencyRequest* RequestUnion::mutable_check_consistency() {
  set_has_check_consistency();
  if (check_consistency_ == NULL) {
    check_consistency_ = new ::cockroach::roachpb::CheckConsistencyRequest;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.RequestUnion.check_consistency)
  return check_consistency_;
}
inline ::cockroach::roachpb::CheckConsistencyRequest* RequestUnion::release_check_consistency() {
  clear_has_check_consistency();
  ::cockroach::roachpb::CheckConsistencyRequest* temp = check_consistency_;
  check_consistency_ = NULL;
  return temp;
}
inline void RequestUnion::set_allocated_check_consistency(::cockroach::roachpb::CheckConsistencyRequest* check_consistency) {
  delete check_consistency_;
  check_consistency_ = check_consistency;
  if (check_consistency) {
    set_has_check_consistency();
  } else {
    clear_has_check_consistency();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.RequestUnion.check_consistency)
}

// optional .cockroach.roachpb.NoopRequest noop = 25;
inline bool RequestUnion::has_noop() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void RequestUnion::set_has_noop() {
  _has_bits_[0] |= 0x01000000u;
}
inline void RequestUnion::clear_has_noop() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void RequestUnion::clear_noop() {
  if (noop_ != NULL) noop_->::cockroach::roachpb::NoopRequest::Clear();
  clear_has_noop();
}
inline const ::cockroach::roachpb::NoopRequest& RequestUnion::noop() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.RequestUnion.noop)
  return noop_ != NULL ? *noop_ : *default_instance_->noop_;
}
inline ::cockroach::roachpb::NoopRequest* RequestUnion::mutable_noop() {
  set_has_noop();
  if (noop_ == NULL) {
    noop_ = new ::cockroach::roachpb::NoopRequest;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.RequestUnion.noop)
  return noop_;
}
inline ::cockroach::roachpb::NoopRequest* RequestUnion::release_noop() {
  clear_has_noop();
  ::cockroach::roachpb::NoopRequest* temp = noop_;
  noop_ = NULL;
  return temp;
}
inline void RequestUnion::set_allocated_noop(::cockroach::roachpb::NoopRequest* noop) {
  delete noop_;
  noop_ = noop;
  if (noop) {
    set_has_noop();
  } else {
    clear_has_noop();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.RequestUnion.noop)
}

// -------------------------------------------------------------------

// ResponseUnion

// optional .cockroach.roachpb.GetResponse get = 1;
inline bool ResponseUnion::has_get() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResponseUnion::set_has_get() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResponseUnion::clear_has_get() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResponseUnion::clear_get() {
  if (get_ != NULL) get_->::cockroach::roachpb::GetResponse::Clear();
  clear_has_get();
}
inline const ::cockroach::roachpb::GetResponse& ResponseUnion::get() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.ResponseUnion.get)
  return get_ != NULL ? *get_ : *default_instance_->get_;
}
inline ::cockroach::roachpb::GetResponse* ResponseUnion::mutable_get() {
  set_has_get();
  if (get_ == NULL) {
    get_ = new ::cockroach::roachpb::GetResponse;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.ResponseUnion.get)
  return get_;
}
inline ::cockroach::roachpb::GetResponse* ResponseUnion::release_get() {
  clear_has_get();
  ::cockroach::roachpb::GetResponse* temp = get_;
  get_ = NULL;
  return temp;
}
inline void ResponseUnion::set_allocated_get(::cockroach::roachpb::GetResponse* get) {
  delete get_;
  get_ = get;
  if (get) {
    set_has_get();
  } else {
    clear_has_get();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.ResponseUnion.get)
}

// optional .cockroach.roachpb.PutResponse put = 2;
inline bool ResponseUnion::has_put() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ResponseUnion::set_has_put() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ResponseUnion::clear_has_put() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ResponseUnion::clear_put() {
  if (put_ != NULL) put_->::cockroach::roachpb::PutResponse::Clear();
  clear_has_put();
}
inline const ::cockroach::roachpb::PutResponse& ResponseUnion::put() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.ResponseUnion.put)
  return put_ != NULL ? *put_ : *default_instance_->put_;
}
inline ::cockroach::roachpb::PutResponse* ResponseUnion::mutable_put() {
  set_has_put();
  if (put_ == NULL) {
    put_ = new ::cockroach::roachpb::PutResponse;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.ResponseUnion.put)
  return put_;
}
inline ::cockroach::roachpb::PutResponse* ResponseUnion::release_put() {
  clear_has_put();
  ::cockroach::roachpb::PutResponse* temp = put_;
  put_ = NULL;
  return temp;
}
inline void ResponseUnion::set_allocated_put(::cockroach::roachpb::PutResponse* put) {
  delete put_;
  put_ = put;
  if (put) {
    set_has_put();
  } else {
    clear_has_put();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.ResponseUnion.put)
}

// optional .cockroach.roachpb.ConditionalPutResponse conditional_put = 3;
inline bool ResponseUnion::has_conditional_put() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ResponseUnion::set_has_conditional_put() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ResponseUnion::clear_has_conditional_put() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ResponseUnion::clear_conditional_put() {
  if (conditional_put_ != NULL) conditional_put_->::cockroach::roachpb::ConditionalPutResponse::Clear();
  clear_has_conditional_put();
}
inline const ::cockroach::roachpb::ConditionalPutResponse& ResponseUnion::conditional_put() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.ResponseUnion.conditional_put)
  return conditional_put_ != NULL ? *conditional_put_ : *default_instance_->conditional_put_;
}
inline ::cockroach::roachpb::ConditionalPutResponse* ResponseUnion::mutable_conditional_put() {
  set_has_conditional_put();
  if (conditional_put_ == NULL) {
    conditional_put_ = new ::cockroach::roachpb::ConditionalPutResponse;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.ResponseUnion.conditional_put)
  return conditional_put_;
}
inline ::cockroach::roachpb::ConditionalPutResponse* ResponseUnion::release_conditional_put() {
  clear_has_conditional_put();
  ::cockroach::roachpb::ConditionalPutResponse* temp = conditional_put_;
  conditional_put_ = NULL;
  return temp;
}
inline void ResponseUnion::set_allocated_conditional_put(::cockroach::roachpb::ConditionalPutResponse* conditional_put) {
  delete conditional_put_;
  conditional_put_ = conditional_put;
  if (conditional_put) {
    set_has_conditional_put();
  } else {
    clear_has_conditional_put();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.ResponseUnion.conditional_put)
}

// optional .cockroach.roachpb.IncrementResponse increment = 4;
inline bool ResponseUnion::has_increment() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ResponseUnion::set_has_increment() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ResponseUnion::clear_has_increment() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ResponseUnion::clear_increment() {
  if (increment_ != NULL) increment_->::cockroach::roachpb::IncrementResponse::Clear();
  clear_has_increment();
}
inline const ::cockroach::roachpb::IncrementResponse& ResponseUnion::increment() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.ResponseUnion.increment)
  return increment_ != NULL ? *increment_ : *default_instance_->increment_;
}
inline ::cockroach::roachpb::IncrementResponse* ResponseUnion::mutable_increment() {
  set_has_increment();
  if (increment_ == NULL) {
    increment_ = new ::cockroach::roachpb::IncrementResponse;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.ResponseUnion.increment)
  return increment_;
}
inline ::cockroach::roachpb::IncrementResponse* ResponseUnion::release_increment() {
  clear_has_increment();
  ::cockroach::roachpb::IncrementResponse* temp = increment_;
  increment_ = NULL;
  return temp;
}
inline void ResponseUnion::set_allocated_increment(::cockroach::roachpb::IncrementResponse* increment) {
  delete increment_;
  increment_ = increment;
  if (increment) {
    set_has_increment();
  } else {
    clear_has_increment();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.ResponseUnion.increment)
}

// optional .cockroach.roachpb.DeleteResponse delete = 5;
inline bool ResponseUnion::has_delete_() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ResponseUnion::set_has_delete_() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ResponseUnion::clear_has_delete_() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ResponseUnion::clear_delete_() {
  if (delete__ != NULL) delete__->::cockroach::roachpb::DeleteResponse::Clear();
  clear_has_delete_();
}
inline const ::cockroach::roachpb::DeleteResponse& ResponseUnion::delete_() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.ResponseUnion.delete)
  return delete__ != NULL ? *delete__ : *default_instance_->delete__;
}
inline ::cockroach::roachpb::DeleteResponse* ResponseUnion::mutable_delete_() {
  set_has_delete_();
  if (delete__ == NULL) {
    delete__ = new ::cockroach::roachpb::DeleteResponse;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.ResponseUnion.delete)
  return delete__;
}
inline ::cockroach::roachpb::DeleteResponse* ResponseUnion::release_delete_() {
  clear_has_delete_();
  ::cockroach::roachpb::DeleteResponse* temp = delete__;
  delete__ = NULL;
  return temp;
}
inline void ResponseUnion::set_allocated_delete_(::cockroach::roachpb::DeleteResponse* delete_) {
  delete delete__;
  delete__ = delete_;
  if (delete_) {
    set_has_delete_();
  } else {
    clear_has_delete_();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.ResponseUnion.delete)
}

// optional .cockroach.roachpb.DeleteRangeResponse delete_range = 6;
inline bool ResponseUnion::has_delete_range() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ResponseUnion::set_has_delete_range() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ResponseUnion::clear_has_delete_range() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ResponseUnion::clear_delete_range() {
  if (delete_range_ != NULL) delete_range_->::cockroach::roachpb::DeleteRangeResponse::Clear();
  clear_has_delete_range();
}
inline const ::cockroach::roachpb::DeleteRangeResponse& ResponseUnion::delete_range() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.ResponseUnion.delete_range)
  return delete_range_ != NULL ? *delete_range_ : *default_instance_->delete_range_;
}
inline ::cockroach::roachpb::DeleteRangeResponse* ResponseUnion::mutable_delete_range() {
  set_has_delete_range();
  if (delete_range_ == NULL) {
    delete_range_ = new ::cockroach::roachpb::DeleteRangeResponse;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.ResponseUnion.delete_range)
  return delete_range_;
}
inline ::cockroach::roachpb::DeleteRangeResponse* ResponseUnion::release_delete_range() {
  clear_has_delete_range();
  ::cockroach::roachpb::DeleteRangeResponse* temp = delete_range_;
  delete_range_ = NULL;
  return temp;
}
inline void ResponseUnion::set_allocated_delete_range(::cockroach::roachpb::DeleteRangeResponse* delete_range) {
  delete delete_range_;
  delete_range_ = delete_range;
  if (delete_range) {
    set_has_delete_range();
  } else {
    clear_has_delete_range();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.ResponseUnion.delete_range)
}

// optional .cockroach.roachpb.ScanResponse scan = 7;
inline bool ResponseUnion::has_scan() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ResponseUnion::set_has_scan() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ResponseUnion::clear_has_scan() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ResponseUnion::clear_scan() {
  if (scan_ != NULL) scan_->::cockroach::roachpb::ScanResponse::Clear();
  clear_has_scan();
}
inline const ::cockroach::roachpb::ScanResponse& ResponseUnion::scan() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.ResponseUnion.scan)
  return scan_ != NULL ? *scan_ : *default_instance_->scan_;
}
inline ::cockroach::roachpb::ScanResponse* ResponseUnion::mutable_scan() {
  set_has_scan();
  if (scan_ == NULL) {
    scan_ = new ::cockroach::roachpb::ScanResponse;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.ResponseUnion.scan)
  return scan_;
}
inline ::cockroach::roachpb::ScanResponse* ResponseUnion::release_scan() {
  clear_has_scan();
  ::cockroach::roachpb::ScanResponse* temp = scan_;
  scan_ = NULL;
  return temp;
}
inline void ResponseUnion::set_allocated_scan(::cockroach::roachpb::ScanResponse* scan) {
  delete scan_;
  scan_ = scan;
  if (scan) {
    set_has_scan();
  } else {
    clear_has_scan();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.ResponseUnion.scan)
}

// optional .cockroach.roachpb.BeginTransactionResponse begin_transaction = 8;
inline bool ResponseUnion::has_begin_transaction() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ResponseUnion::set_has_begin_transaction() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ResponseUnion::clear_has_begin_transaction() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ResponseUnion::clear_begin_transaction() {
  if (begin_transaction_ != NULL) begin_transaction_->::cockroach::roachpb::BeginTransactionResponse::Clear();
  clear_has_begin_transaction();
}
inline const ::cockroach::roachpb::BeginTransactionResponse& ResponseUnion::begin_transaction() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.ResponseUnion.begin_transaction)
  return begin_transaction_ != NULL ? *begin_transaction_ : *default_instance_->begin_transaction_;
}
inline ::cockroach::roachpb::BeginTransactionResponse* ResponseUnion::mutable_begin_transaction() {
  set_has_begin_transaction();
  if (begin_transaction_ == NULL) {
    begin_transaction_ = new ::cockroach::roachpb::BeginTransactionResponse;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.ResponseUnion.begin_transaction)
  return begin_transaction_;
}
inline ::cockroach::roachpb::BeginTransactionResponse* ResponseUnion::release_begin_transaction() {
  clear_has_begin_transaction();
  ::cockroach::roachpb::BeginTransactionResponse* temp = begin_transaction_;
  begin_transaction_ = NULL;
  return temp;
}
inline void ResponseUnion::set_allocated_begin_transaction(::cockroach::roachpb::BeginTransactionResponse* begin_transaction) {
  delete begin_transaction_;
  begin_transaction_ = begin_transaction;
  if (begin_transaction) {
    set_has_begin_transaction();
  } else {
    clear_has_begin_transaction();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.ResponseUnion.begin_transaction)
}

// optional .cockroach.roachpb.EndTransactionResponse end_transaction = 9;
inline bool ResponseUnion::has_end_transaction() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void ResponseUnion::set_has_end_transaction() {
  _has_bits_[0] |= 0x00000100u;
}
inline void ResponseUnion::clear_has_end_transaction() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void ResponseUnion::clear_end_transaction() {
  if (end_transaction_ != NULL) end_transaction_->::cockroach::roachpb::EndTransactionResponse::Clear();
  clear_has_end_transaction();
}
inline const ::cockroach::roachpb::EndTransactionResponse& ResponseUnion::end_transaction() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.ResponseUnion.end_transaction)
  return end_transaction_ != NULL ? *end_transaction_ : *default_instance_->end_transaction_;
}
inline ::cockroach::roachpb::EndTransactionResponse* ResponseUnion::mutable_end_transaction() {
  set_has_end_transaction();
  if (end_transaction_ == NULL) {
    end_transaction_ = new ::cockroach::roachpb::EndTransactionResponse;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.ResponseUnion.end_transaction)
  return end_transaction_;
}
inline ::cockroach::roachpb::EndTransactionResponse* ResponseUnion::release_end_transaction() {
  clear_has_end_transaction();
  ::cockroach::roachpb::EndTransactionResponse* temp = end_transaction_;
  end_transaction_ = NULL;
  return temp;
}
inline void ResponseUnion::set_allocated_end_transaction(::cockroach::roachpb::EndTransactionResponse* end_transaction) {
  delete end_transaction_;
  end_transaction_ = end_transaction;
  if (end_transaction) {
    set_has_end_transaction();
  } else {
    clear_has_end_transaction();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.ResponseUnion.end_transaction)
}

// optional .cockroach.roachpb.AdminSplitResponse admin_split = 10;
inline bool ResponseUnion::has_admin_split() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void ResponseUnion::set_has_admin_split() {
  _has_bits_[0] |= 0x00000200u;
}
inline void ResponseUnion::clear_has_admin_split() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void ResponseUnion::clear_admin_split() {
  if (admin_split_ != NULL) admin_split_->::cockroach::roachpb::AdminSplitResponse::Clear();
  clear_has_admin_split();
}
inline const ::cockroach::roachpb::AdminSplitResponse& ResponseUnion::admin_split() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.ResponseUnion.admin_split)
  return admin_split_ != NULL ? *admin_split_ : *default_instance_->admin_split_;
}
inline ::cockroach::roachpb::AdminSplitResponse* ResponseUnion::mutable_admin_split() {
  set_has_admin_split();
  if (admin_split_ == NULL) {
    admin_split_ = new ::cockroach::roachpb::AdminSplitResponse;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.ResponseUnion.admin_split)
  return admin_split_;
}
inline ::cockroach::roachpb::AdminSplitResponse* ResponseUnion::release_admin_split() {
  clear_has_admin_split();
  ::cockroach::roachpb::AdminSplitResponse* temp = admin_split_;
  admin_split_ = NULL;
  return temp;
}
inline void ResponseUnion::set_allocated_admin_split(::cockroach::roachpb::AdminSplitResponse* admin_split) {
  delete admin_split_;
  admin_split_ = admin_split;
  if (admin_split) {
    set_has_admin_split();
  } else {
    clear_has_admin_split();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.ResponseUnion.admin_split)
}

// optional .cockroach.roachpb.AdminMergeResponse admin_merge = 11;
inline bool ResponseUnion::has_admin_merge() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void ResponseUnion::set_has_admin_merge() {
  _has_bits_[0] |= 0x00000400u;
}
inline void ResponseUnion::clear_has_admin_merge() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void ResponseUnion::clear_admin_merge() {
  if (admin_merge_ != NULL) admin_merge_->::cockroach::roachpb::AdminMergeResponse::Clear();
  clear_has_admin_merge();
}
inline const ::cockroach::roachpb::AdminMergeResponse& ResponseUnion::admin_merge() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.ResponseUnion.admin_merge)
  return admin_merge_ != NULL ? *admin_merge_ : *default_instance_->admin_merge_;
}
inline ::cockroach::roachpb::AdminMergeResponse* ResponseUnion::mutable_admin_merge() {
  set_has_admin_merge();
  if (admin_merge_ == NULL) {
    admin_merge_ = new ::cockroach::roachpb::AdminMergeResponse;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.ResponseUnion.admin_merge)
  return admin_merge_;
}
inline ::cockroach::roachpb::AdminMergeResponse* ResponseUnion::release_admin_merge() {
  clear_has_admin_merge();
  ::cockroach::roachpb::AdminMergeResponse* temp = admin_merge_;
  admin_merge_ = NULL;
  return temp;
}
inline void ResponseUnion::set_allocated_admin_merge(::cockroach::roachpb::AdminMergeResponse* admin_merge) {
  delete admin_merge_;
  admin_merge_ = admin_merge;
  if (admin_merge) {
    set_has_admin_merge();
  } else {
    clear_has_admin_merge();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.ResponseUnion.admin_merge)
}

// optional .cockroach.roachpb.HeartbeatTxnResponse heartbeat_txn = 12;
inline bool ResponseUnion::has_heartbeat_txn() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void ResponseUnion::set_has_heartbeat_txn() {
  _has_bits_[0] |= 0x00000800u;
}
inline void ResponseUnion::clear_has_heartbeat_txn() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void ResponseUnion::clear_heartbeat_txn() {
  if (heartbeat_txn_ != NULL) heartbeat_txn_->::cockroach::roachpb::HeartbeatTxnResponse::Clear();
  clear_has_heartbeat_txn();
}
inline const ::cockroach::roachpb::HeartbeatTxnResponse& ResponseUnion::heartbeat_txn() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.ResponseUnion.heartbeat_txn)
  return heartbeat_txn_ != NULL ? *heartbeat_txn_ : *default_instance_->heartbeat_txn_;
}
inline ::cockroach::roachpb::HeartbeatTxnResponse* ResponseUnion::mutable_heartbeat_txn() {
  set_has_heartbeat_txn();
  if (heartbeat_txn_ == NULL) {
    heartbeat_txn_ = new ::cockroach::roachpb::HeartbeatTxnResponse;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.ResponseUnion.heartbeat_txn)
  return heartbeat_txn_;
}
inline ::cockroach::roachpb::HeartbeatTxnResponse* ResponseUnion::release_heartbeat_txn() {
  clear_has_heartbeat_txn();
  ::cockroach::roachpb::HeartbeatTxnResponse* temp = heartbeat_txn_;
  heartbeat_txn_ = NULL;
  return temp;
}
inline void ResponseUnion::set_allocated_heartbeat_txn(::cockroach::roachpb::HeartbeatTxnResponse* heartbeat_txn) {
  delete heartbeat_txn_;
  heartbeat_txn_ = heartbeat_txn;
  if (heartbeat_txn) {
    set_has_heartbeat_txn();
  } else {
    clear_has_heartbeat_txn();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.ResponseUnion.heartbeat_txn)
}

// optional .cockroach.roachpb.GCResponse gc = 13;
inline bool ResponseUnion::has_gc() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void ResponseUnion::set_has_gc() {
  _has_bits_[0] |= 0x00001000u;
}
inline void ResponseUnion::clear_has_gc() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void ResponseUnion::clear_gc() {
  if (gc_ != NULL) gc_->::cockroach::roachpb::GCResponse::Clear();
  clear_has_gc();
}
inline const ::cockroach::roachpb::GCResponse& ResponseUnion::gc() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.ResponseUnion.gc)
  return gc_ != NULL ? *gc_ : *default_instance_->gc_;
}
inline ::cockroach::roachpb::GCResponse* ResponseUnion::mutable_gc() {
  set_has_gc();
  if (gc_ == NULL) {
    gc_ = new ::cockroach::roachpb::GCResponse;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.ResponseUnion.gc)
  return gc_;
}
inline ::cockroach::roachpb::GCResponse* ResponseUnion::release_gc() {
  clear_has_gc();
  ::cockroach::roachpb::GCResponse* temp = gc_;
  gc_ = NULL;
  return temp;
}
inline void ResponseUnion::set_allocated_gc(::cockroach::roachpb::GCResponse* gc) {
  delete gc_;
  gc_ = gc;
  if (gc) {
    set_has_gc();
  } else {
    clear_has_gc();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.ResponseUnion.gc)
}

// optional .cockroach.roachpb.PushTxnResponse push_txn = 14;
inline bool ResponseUnion::has_push_txn() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void ResponseUnion::set_has_push_txn() {
  _has_bits_[0] |= 0x00002000u;
}
inline void ResponseUnion::clear_has_push_txn() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void ResponseUnion::clear_push_txn() {
  if (push_txn_ != NULL) push_txn_->::cockroach::roachpb::PushTxnResponse::Clear();
  clear_has_push_txn();
}
inline const ::cockroach::roachpb::PushTxnResponse& ResponseUnion::push_txn() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.ResponseUnion.push_txn)
  return push_txn_ != NULL ? *push_txn_ : *default_instance_->push_txn_;
}
inline ::cockroach::roachpb::PushTxnResponse* ResponseUnion::mutable_push_txn() {
  set_has_push_txn();
  if (push_txn_ == NULL) {
    push_txn_ = new ::cockroach::roachpb::PushTxnResponse;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.ResponseUnion.push_txn)
  return push_txn_;
}
inline ::cockroach::roachpb::PushTxnResponse* ResponseUnion::release_push_txn() {
  clear_has_push_txn();
  ::cockroach::roachpb::PushTxnResponse* temp = push_txn_;
  push_txn_ = NULL;
  return temp;
}
inline void ResponseUnion::set_allocated_push_txn(::cockroach::roachpb::PushTxnResponse* push_txn) {
  delete push_txn_;
  push_txn_ = push_txn;
  if (push_txn) {
    set_has_push_txn();
  } else {
    clear_has_push_txn();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.ResponseUnion.push_txn)
}

// optional .cockroach.roachpb.RangeLookupResponse range_lookup = 15;
inline bool ResponseUnion::has_range_lookup() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void ResponseUnion::set_has_range_lookup() {
  _has_bits_[0] |= 0x00004000u;
}
inline void ResponseUnion::clear_has_range_lookup() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void ResponseUnion::clear_range_lookup() {
  if (range_lookup_ != NULL) range_lookup_->::cockroach::roachpb::RangeLookupResponse::Clear();
  clear_has_range_lookup();
}
inline const ::cockroach::roachpb::RangeLookupResponse& ResponseUnion::range_lookup() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.ResponseUnion.range_lookup)
  return range_lookup_ != NULL ? *range_lookup_ : *default_instance_->range_lookup_;
}
inline ::cockroach::roachpb::RangeLookupResponse* ResponseUnion::mutable_range_lookup() {
  set_has_range_lookup();
  if (range_lookup_ == NULL) {
    range_lookup_ = new ::cockroach::roachpb::RangeLookupResponse;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.ResponseUnion.range_lookup)
  return range_lookup_;
}
inline ::cockroach::roachpb::RangeLookupResponse* ResponseUnion::release_range_lookup() {
  clear_has_range_lookup();
  ::cockroach::roachpb::RangeLookupResponse* temp = range_lookup_;
  range_lookup_ = NULL;
  return temp;
}
inline void ResponseUnion::set_allocated_range_lookup(::cockroach::roachpb::RangeLookupResponse* range_lookup) {
  delete range_lookup_;
  range_lookup_ = range_lookup;
  if (range_lookup) {
    set_has_range_lookup();
  } else {
    clear_has_range_lookup();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.ResponseUnion.range_lookup)
}

// optional .cockroach.roachpb.ResolveIntentResponse resolve_intent = 16;
inline bool ResponseUnion::has_resolve_intent() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void ResponseUnion::set_has_resolve_intent() {
  _has_bits_[0] |= 0x00008000u;
}
inline void ResponseUnion::clear_has_resolve_intent() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void ResponseUnion::clear_resolve_intent() {
  if (resolve_intent_ != NULL) resolve_intent_->::cockroach::roachpb::ResolveIntentResponse::Clear();
  clear_has_resolve_intent();
}
inline const ::cockroach::roachpb::ResolveIntentResponse& ResponseUnion::resolve_intent() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.ResponseUnion.resolve_intent)
  return resolve_intent_ != NULL ? *resolve_intent_ : *default_instance_->resolve_intent_;
}
inline ::cockroach::roachpb::ResolveIntentResponse* ResponseUnion::mutable_resolve_intent() {
  set_has_resolve_intent();
  if (resolve_intent_ == NULL) {
    resolve_intent_ = new ::cockroach::roachpb::ResolveIntentResponse;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.ResponseUnion.resolve_intent)
  return resolve_intent_;
}
inline ::cockroach::roachpb::ResolveIntentResponse* ResponseUnion::release_resolve_intent() {
  clear_has_resolve_intent();
  ::cockroach::roachpb::ResolveIntentResponse* temp = resolve_intent_;
  resolve_intent_ = NULL;
  return temp;
}
inline void ResponseUnion::set_allocated_resolve_intent(::cockroach::roachpb::ResolveIntentResponse* resolve_intent) {
  delete resolve_intent_;
  resolve_intent_ = resolve_intent;
  if (resolve_intent) {
    set_has_resolve_intent();
  } else {
    clear_has_resolve_intent();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.ResponseUnion.resolve_intent)
}

// optional .cockroach.roachpb.ResolveIntentRangeResponse resolve_intent_range = 17;
inline bool ResponseUnion::has_resolve_intent_range() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void ResponseUnion::set_has_resolve_intent_range() {
  _has_bits_[0] |= 0x00010000u;
}
inline void ResponseUnion::clear_has_resolve_intent_range() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void ResponseUnion::clear_resolve_intent_range() {
  if (resolve_intent_range_ != NULL) resolve_intent_range_->::cockroach::roachpb::ResolveIntentRangeResponse::Clear();
  clear_has_resolve_intent_range();
}
inline const ::cockroach::roachpb::ResolveIntentRangeResponse& ResponseUnion::resolve_intent_range() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.ResponseUnion.resolve_intent_range)
  return resolve_intent_range_ != NULL ? *resolve_intent_range_ : *default_instance_->resolve_intent_range_;
}
inline ::cockroach::roachpb::ResolveIntentRangeResponse* ResponseUnion::mutable_resolve_intent_range() {
  set_has_resolve_intent_range();
  if (resolve_intent_range_ == NULL) {
    resolve_intent_range_ = new ::cockroach::roachpb::ResolveIntentRangeResponse;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.ResponseUnion.resolve_intent_range)
  return resolve_intent_range_;
}
inline ::cockroach::roachpb::ResolveIntentRangeResponse* ResponseUnion::release_resolve_intent_range() {
  clear_has_resolve_intent_range();
  ::cockroach::roachpb::ResolveIntentRangeResponse* temp = resolve_intent_range_;
  resolve_intent_range_ = NULL;
  return temp;
}
inline void ResponseUnion::set_allocated_resolve_intent_range(::cockroach::roachpb::ResolveIntentRangeResponse* resolve_intent_range) {
  delete resolve_intent_range_;
  resolve_intent_range_ = resolve_intent_range;
  if (resolve_intent_range) {
    set_has_resolve_intent_range();
  } else {
    clear_has_resolve_intent_range();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.ResponseUnion.resolve_intent_range)
}

// optional .cockroach.roachpb.MergeResponse merge = 18;
inline bool ResponseUnion::has_merge() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void ResponseUnion::set_has_merge() {
  _has_bits_[0] |= 0x00020000u;
}
inline void ResponseUnion::clear_has_merge() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void ResponseUnion::clear_merge() {
  if (merge_ != NULL) merge_->::cockroach::roachpb::MergeResponse::Clear();
  clear_has_merge();
}
inline const ::cockroach::roachpb::MergeResponse& ResponseUnion::merge() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.ResponseUnion.merge)
  return merge_ != NULL ? *merge_ : *default_instance_->merge_;
}
inline ::cockroach::roachpb::MergeResponse* ResponseUnion::mutable_merge() {
  set_has_merge();
  if (merge_ == NULL) {
    merge_ = new ::cockroach::roachpb::MergeResponse;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.ResponseUnion.merge)
  return merge_;
}
inline ::cockroach::roachpb::MergeResponse* ResponseUnion::release_merge() {
  clear_has_merge();
  ::cockroach::roachpb::MergeResponse* temp = merge_;
  merge_ = NULL;
  return temp;
}
inline void ResponseUnion::set_allocated_merge(::cockroach::roachpb::MergeResponse* merge) {
  delete merge_;
  merge_ = merge;
  if (merge) {
    set_has_merge();
  } else {
    clear_has_merge();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.ResponseUnion.merge)
}

// optional .cockroach.roachpb.TruncateLogResponse truncate_log = 19;
inline bool ResponseUnion::has_truncate_log() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void ResponseUnion::set_has_truncate_log() {
  _has_bits_[0] |= 0x00040000u;
}
inline void ResponseUnion::clear_has_truncate_log() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void ResponseUnion::clear_truncate_log() {
  if (truncate_log_ != NULL) truncate_log_->::cockroach::roachpb::TruncateLogResponse::Clear();
  clear_has_truncate_log();
}
inline const ::cockroach::roachpb::TruncateLogResponse& ResponseUnion::truncate_log() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.ResponseUnion.truncate_log)
  return truncate_log_ != NULL ? *truncate_log_ : *default_instance_->truncate_log_;
}
inline ::cockroach::roachpb::TruncateLogResponse* ResponseUnion::mutable_truncate_log() {
  set_has_truncate_log();
  if (truncate_log_ == NULL) {
    truncate_log_ = new ::cockroach::roachpb::TruncateLogResponse;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.ResponseUnion.truncate_log)
  return truncate_log_;
}
inline ::cockroach::roachpb::TruncateLogResponse* ResponseUnion::release_truncate_log() {
  clear_has_truncate_log();
  ::cockroach::roachpb::TruncateLogResponse* temp = truncate_log_;
  truncate_log_ = NULL;
  return temp;
}
inline void ResponseUnion::set_allocated_truncate_log(::cockroach::roachpb::TruncateLogResponse* truncate_log) {
  delete truncate_log_;
  truncate_log_ = truncate_log;
  if (truncate_log) {
    set_has_truncate_log();
  } else {
    clear_has_truncate_log();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.ResponseUnion.truncate_log)
}

// optional .cockroach.roachpb.LeaderLeaseResponse leader_lease = 20;
inline bool ResponseUnion::has_leader_lease() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void ResponseUnion::set_has_leader_lease() {
  _has_bits_[0] |= 0x00080000u;
}
inline void ResponseUnion::clear_has_leader_lease() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void ResponseUnion::clear_leader_lease() {
  if (leader_lease_ != NULL) leader_lease_->::cockroach::roachpb::LeaderLeaseResponse::Clear();
  clear_has_leader_lease();
}
inline const ::cockroach::roachpb::LeaderLeaseResponse& ResponseUnion::leader_lease() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.ResponseUnion.leader_lease)
  return leader_lease_ != NULL ? *leader_lease_ : *default_instance_->leader_lease_;
}
inline ::cockroach::roachpb::LeaderLeaseResponse* ResponseUnion::mutable_leader_lease() {
  set_has_leader_lease();
  if (leader_lease_ == NULL) {
    leader_lease_ = new ::cockroach::roachpb::LeaderLeaseResponse;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.ResponseUnion.leader_lease)
  return leader_lease_;
}
inline ::cockroach::roachpb::LeaderLeaseResponse* ResponseUnion::release_leader_lease() {
  clear_has_leader_lease();
  ::cockroach::roachpb::LeaderLeaseResponse* temp = leader_lease_;
  leader_lease_ = NULL;
  return temp;
}
inline void ResponseUnion::set_allocated_leader_lease(::cockroach::roachpb::LeaderLeaseResponse* leader_lease) {
  delete leader_lease_;
  leader_lease_ = leader_lease;
  if (leader_lease) {
    set_has_leader_lease();
  } else {
    clear_has_leader_lease();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.ResponseUnion.leader_lease)
}

// optional .cockroach.roachpb.ReverseScanResponse reverse_scan = 21;
inline bool ResponseUnion::has_reverse_scan() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void ResponseUnion::set_has_reverse_scan() {
  _has_bits_[0] |= 0x00100000u;
}
inline void ResponseUnion::clear_has_reverse_scan() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void ResponseUnion::clear_reverse_scan() {
  if (reverse_scan_ != NULL) reverse_scan_->::cockroach::roachpb::ReverseScanResponse::Clear();
  clear_has_reverse_scan();
}
inline const ::cockroach::roachpb::ReverseScanResponse& ResponseUnion::reverse_scan() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.ResponseUnion.reverse_scan)
  return reverse_scan_ != NULL ? *reverse_scan_ : *default_instance_->reverse_scan_;
}
inline ::cockroach::roachpb::ReverseScanResponse* ResponseUnion::mutable_reverse_scan() {
  set_has_reverse_scan();
  if (reverse_scan_ == NULL) {
    reverse_scan_ = new ::cockroach::roachpb::ReverseScanResponse;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.ResponseUnion.reverse_scan)
  return reverse_scan_;
}
inline ::cockroach::roachpb::ReverseScanResponse* ResponseUnion::release_reverse_scan() {
  clear_has_reverse_scan();
  ::cockroach::roachpb::ReverseScanResponse* temp = reverse_scan_;
  reverse_scan_ = NULL;
  return temp;
}
inline void ResponseUnion::set_allocated_reverse_scan(::cockroach::roachpb::ReverseScanResponse* reverse_scan) {
  delete reverse_scan_;
  reverse_scan_ = reverse_scan;
  if (reverse_scan) {
    set_has_reverse_scan();
  } else {
    clear_has_reverse_scan();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.ResponseUnion.reverse_scan)
}

// optional .cockroach.roachpb.ComputeChecksumResponse compute_checksum = 22;
inline bool ResponseUnion::has_compute_checksum() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void ResponseUnion::set_has_compute_checksum() {
  _has_bits_[0] |= 0x00200000u;
}
inline void ResponseUnion::clear_has_compute_checksum() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void ResponseUnion::clear_compute_checksum() {
  if (compute_checksum_ != NULL) compute_checksum_->::cockroach::roachpb::ComputeChecksumResponse::Clear();
  clear_has_compute_checksum();
}
inline const ::cockroach::roachpb::ComputeChecksumResponse& ResponseUnion::compute_checksum() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.ResponseUnion.compute_checksum)
  return compute_checksum_ != NULL ? *compute_checksum_ : *default_instance_->compute_checksum_;
}
inline ::cockroach::roachpb::ComputeChecksumResponse* ResponseUnion::mutable_compute_checksum() {
  set_has_compute_checksum();
  if (compute_checksum_ == NULL) {
    compute_checksum_ = new ::cockroach::roachpb::ComputeChecksumResponse;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.ResponseUnion.compute_checksum)
  return compute_checksum_;
}
inline ::cockroach::roachpb::ComputeChecksumResponse* ResponseUnion::release_compute_checksum() {
  clear_has_compute_checksum();
  ::cockroach::roachpb::ComputeChecksumResponse* temp = compute_checksum_;
  compute_checksum_ = NULL;
  return temp;
}
inline void ResponseUnion::set_allocated_compute_checksum(::cockroach::roachpb::ComputeChecksumResponse* compute_checksum) {
  delete compute_checksum_;
  compute_checksum_ = compute_checksum;
  if (compute_checksum) {
    set_has_compute_checksum();
  } else {
    clear_has_compute_checksum();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.ResponseUnion.compute_checksum)
}

// optional .cockroach.roachpb.VerifyChecksumResponse verify_checksum = 23;
inline bool ResponseUnion::has_verify_checksum() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void ResponseUnion::set_has_verify_checksum() {
  _has_bits_[0] |= 0x00400000u;
}
inline void ResponseUnion::clear_has_verify_checksum() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void ResponseUnion::clear_verify_checksum() {
  if (verify_checksum_ != NULL) verify_checksum_->::cockroach::roachpb::VerifyChecksumResponse::Clear();
  clear_has_verify_checksum();
}
inline const ::cockroach::roachpb::VerifyChecksumResponse& ResponseUnion::verify_checksum() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.ResponseUnion.verify_checksum)
  return verify_checksum_ != NULL ? *verify_checksum_ : *default_instance_->verify_checksum_;
}
inline ::cockroach::roachpb::VerifyChecksumResponse* ResponseUnion::mutable_verify_checksum() {
  set_has_verify_checksum();
  if (verify_checksum_ == NULL) {
    verify_checksum_ = new ::cockroach::roachpb::VerifyChecksumResponse;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.ResponseUnion.verify_checksum)
  return verify_checksum_;
}
inline ::cockroach::roachpb::VerifyChecksumResponse* ResponseUnion::release_verify_checksum() {
  clear_has_verify_checksum();
  ::cockroach::roachpb::VerifyChecksumResponse* temp = verify_checksum_;
  verify_checksum_ = NULL;
  return temp;
}
inline void ResponseUnion::set_allocated_verify_checksum(::cockroach::roachpb::VerifyChecksumResponse* verify_checksum) {
  delete verify_checksum_;
  verify_checksum_ = verify_checksum;
  if (verify_checksum) {
    set_has_verify_checksum();
  } else {
    clear_has_verify_checksum();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.ResponseUnion.verify_checksum)
}

// optional .cockroach.roachpb.CheckConsistencyResponse check_consistency = 24;
inline bool ResponseUnion::has_check_consistency() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void ResponseUnion::set_has_check_consistency() {
  _has_bits_[0] |= 0x00800000u;
}
inline void ResponseUnion::clear_has_check_consistency() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void ResponseUnion::clear_check_consistency() {
  if (check_consistency_ != NULL) check_consistency_->::cockroach::roachpb::CheckConsistencyResponse::Clear();
  clear_has_check_consistency();
}
inline const ::cockroach::roachpb::CheckConsistencyResponse& ResponseUnion::check_consistency() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.ResponseUnion.check_consistency)
  return check_consistency_ != NULL ? *check_consistency_ : *default_instance_->check_consistency_;
}
inline ::cockroach::roachpb::CheckConsistencyResponse* ResponseUnion::mutable_check_consistency() {
  set_has_check_consistency();
  if (check_consistency_ == NULL) {
    check_consistency_ = new ::cockroach::roachpb::CheckConsistencyResponse;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.ResponseUnion.check_consistency)
  return check_consistency_;
}
inline ::cockroach::roachpb::CheckConsistencyResponse* ResponseUnion::release_check_consistency() {
  clear_has_check_consistency();
  ::cockroach::roachpb::CheckConsistencyResponse* temp = check_consistency_;
  check_consistency_ = NULL;
  return temp;
}
inline void ResponseUnion::set_allocated_check_consistency(::cockroach::roachpb::CheckConsistencyResponse* check_consistency) {
  delete check_consistency_;
  check_consistency_ = check_consistency;
  if (check_consistency) {
    set_has_check_consistency();
  } else {
    clear_has_check_consistency();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.ResponseUnion.check_consistency)
}

// optional .cockroach.roachpb.NoopResponse noop = 25;
inline bool ResponseUnion::has_noop() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void ResponseUnion::set_has_noop() {
  _has_bits_[0] |= 0x01000000u;
}
inline void ResponseUnion::clear_has_noop() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void ResponseUnion::clear_noop() {
  if (noop_ != NULL) noop_->::cockroach::roachpb::NoopResponse::Clear();
  clear_has_noop();
}
inline const ::cockroach::roachpb::NoopResponse& ResponseUnion::noop() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.ResponseUnion.noop)
  return noop_ != NULL ? *noop_ : *default_instance_->noop_;
}
inline ::cockroach::roachpb::NoopResponse* ResponseUnion::mutable_noop() {
  set_has_noop();
  if (noop_ == NULL) {
    noop_ = new ::cockroach::roachpb::NoopResponse;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.ResponseUnion.noop)
  return noop_;
}
inline ::cockroach::roachpb::NoopResponse* ResponseUnion::release_noop() {
  clear_has_noop();
  ::cockroach::roachpb::NoopResponse* temp = noop_;
  noop_ = NULL;
  return temp;
}
inline void ResponseUnion::set_allocated_noop(::cockroach::roachpb::NoopResponse* noop) {
  delete noop_;
  noop_ = noop;
  if (noop) {
    set_has_noop();
  } else {
    clear_has_noop();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.ResponseUnion.noop)
}

// -------------------------------------------------------------------

// Header

// optional .cockroach.roachpb.Timestamp timestamp = 1;
inline bool Header::has_timestamp() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Header::set_has_timestamp() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Header::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Header::clear_timestamp() {
  if (timestamp_ != NULL) timestamp_->::cockroach::roachpb::Timestamp::Clear();
  clear_has_timestamp();
}
inline const ::cockroach::roachpb::Timestamp& Header::timestamp() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.Header.timestamp)
  return timestamp_ != NULL ? *timestamp_ : *default_instance_->timestamp_;
}
inline ::cockroach::roachpb::Timestamp* Header::mutable_timestamp() {
  set_has_timestamp();
  if (timestamp_ == NULL) {
    timestamp_ = new ::cockroach::roachpb::Timestamp;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.Header.timestamp)
  return timestamp_;
}
inline ::cockroach::roachpb::Timestamp* Header::release_timestamp() {
  clear_has_timestamp();
  ::cockroach::roachpb::Timestamp* temp = timestamp_;
  timestamp_ = NULL;
  return temp;
}
inline void Header::set_allocated_timestamp(::cockroach::roachpb::Timestamp* timestamp) {
  delete timestamp_;
  timestamp_ = timestamp;
  if (timestamp) {
    set_has_timestamp();
  } else {
    clear_has_timestamp();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.Header.timestamp)
}

// optional .cockroach.roachpb.ReplicaDescriptor replica = 2;
inline bool Header::has_replica() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Header::set_has_replica() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Header::clear_has_replica() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Header::clear_replica() {
  if (replica_ != NULL) replica_->::cockroach::roachpb::ReplicaDescriptor::Clear();
  clear_has_replica();
}
inline const ::cockroach::roachpb::ReplicaDescriptor& Header::replica() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.Header.replica)
  return replica_ != NULL ? *replica_ : *default_instance_->replica_;
}
inline ::cockroach::roachpb::ReplicaDescriptor* Header::mutable_replica() {
  set_has_replica();
  if (replica_ == NULL) {
    replica_ = new ::cockroach::roachpb::ReplicaDescriptor;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.Header.replica)
  return replica_;
}
inline ::cockroach::roachpb::ReplicaDescriptor* Header::release_replica() {
  clear_has_replica();
  ::cockroach::roachpb::ReplicaDescriptor* temp = replica_;
  replica_ = NULL;
  return temp;
}
inline void Header::set_allocated_replica(::cockroach::roachpb::ReplicaDescriptor* replica) {
  delete replica_;
  replica_ = replica;
  if (replica) {
    set_has_replica();
  } else {
    clear_has_replica();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.Header.replica)
}

// optional int64 range_id = 3;
inline bool Header::has_range_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Header::set_has_range_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Header::clear_has_range_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Header::clear_range_id() {
  range_id_ = GOOGLE_LONGLONG(0);
  clear_has_range_id();
}
inline ::google::protobuf::int64 Header::range_id() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.Header.range_id)
  return range_id_;
}
inline void Header::set_range_id(::google::protobuf::int64 value) {
  set_has_range_id();
  range_id_ = value;
  // @@protoc_insertion_point(field_set:cockroach.roachpb.Header.range_id)
}

// optional double user_priority = 4;
inline bool Header::has_user_priority() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Header::set_has_user_priority() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Header::clear_has_user_priority() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Header::clear_user_priority() {
  user_priority_ = 0;
  clear_has_user_priority();
}
inline double Header::user_priority() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.Header.user_priority)
  return user_priority_;
}
inline void Header::set_user_priority(double value) {
  set_has_user_priority();
  user_priority_ = value;
  // @@protoc_insertion_point(field_set:cockroach.roachpb.Header.user_priority)
}

// optional .cockroach.roachpb.Transaction txn = 5;
inline bool Header::has_txn() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Header::set_has_txn() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Header::clear_has_txn() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Header::clear_txn() {
  if (txn_ != NULL) txn_->::cockroach::roachpb::Transaction::Clear();
  clear_has_txn();
}
inline const ::cockroach::roachpb::Transaction& Header::txn() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.Header.txn)
  return txn_ != NULL ? *txn_ : *default_instance_->txn_;
}
inline ::cockroach::roachpb::Transaction* Header::mutable_txn() {
  set_has_txn();
  if (txn_ == NULL) {
    txn_ = new ::cockroach::roachpb::Transaction;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.Header.txn)
  return txn_;
}
inline ::cockroach::roachpb::Transaction* Header::release_txn() {
  clear_has_txn();
  ::cockroach::roachpb::Transaction* temp = txn_;
  txn_ = NULL;
  return temp;
}
inline void Header::set_allocated_txn(::cockroach::roachpb::Transaction* txn) {
  delete txn_;
  txn_ = txn;
  if (txn) {
    set_has_txn();
  } else {
    clear_has_txn();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.Header.txn)
}

// optional .cockroach.roachpb.ReadConsistencyType read_consistency = 6;
inline bool Header::has_read_consistency() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Header::set_has_read_consistency() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Header::clear_has_read_consistency() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Header::clear_read_consistency() {
  read_consistency_ = 0;
  clear_has_read_consistency();
}
inline ::cockroach::roachpb::ReadConsistencyType Header::read_consistency() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.Header.read_consistency)
  return static_cast< ::cockroach::roachpb::ReadConsistencyType >(read_consistency_);
}
inline void Header::set_read_consistency(::cockroach::roachpb::ReadConsistencyType value) {
  assert(::cockroach::roachpb::ReadConsistencyType_IsValid(value));
  set_has_read_consistency();
  read_consistency_ = value;
  // @@protoc_insertion_point(field_set:cockroach.roachpb.Header.read_consistency)
}

// optional .cockroach.util.tracing.Span trace = 7;
inline bool Header::has_trace() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Header::set_has_trace() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Header::clear_has_trace() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Header::clear_trace() {
  if (trace_ != NULL) trace_->::cockroach::util::tracing::Span::Clear();
  clear_has_trace();
}
inline const ::cockroach::util::tracing::Span& Header::trace() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.Header.trace)
  return trace_ != NULL ? *trace_ : *default_instance_->trace_;
}
inline ::cockroach::util::tracing::Span* Header::mutable_trace() {
  set_has_trace();
  if (trace_ == NULL) {
    trace_ = new ::cockroach::util::tracing::Span;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.Header.trace)
  return trace_;
}
inline ::cockroach::util::tracing::Span* Header::release_trace() {
  clear_has_trace();
  ::cockroach::util::tracing::Span* temp = trace_;
  trace_ = NULL;
  return temp;
}
inline void Header::set_allocated_trace(::cockroach::util::tracing::Span* trace) {
  delete trace_;
  trace_ = trace;
  if (trace) {
    set_has_trace();
  } else {
    clear_has_trace();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.Header.trace)
}

// optional int64 max_scan_results = 8;
inline bool Header::has_max_scan_results() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Header::set_has_max_scan_results() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Header::clear_has_max_scan_results() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Header::clear_max_scan_results() {
  max_scan_results_ = GOOGLE_LONGLONG(0);
  clear_has_max_scan_results();
}
inline ::google::protobuf::int64 Header::max_scan_results() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.Header.max_scan_results)
  return max_scan_results_;
}
inline void Header::set_max_scan_results(::google::protobuf::int64 value) {
  set_has_max_scan_results();
  max_scan_results_ = value;
  // @@protoc_insertion_point(field_set:cockroach.roachpb.Header.max_scan_results)
}

// -------------------------------------------------------------------

// BatchRequest

// optional .cockroach.roachpb.Header header = 1;
inline bool BatchRequest::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BatchRequest::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BatchRequest::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BatchRequest::clear_header() {
  if (header_ != NULL) header_->::cockroach::roachpb::Header::Clear();
  clear_has_header();
}
inline const ::cockroach::roachpb::Header& BatchRequest::header() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.BatchRequest.header)
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
inline ::cockroach::roachpb::Header* BatchRequest::mutable_header() {
  set_has_header();
  if (header_ == NULL) {
    header_ = new ::cockroach::roachpb::Header;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.BatchRequest.header)
  return header_;
}
inline ::cockroach::roachpb::Header* BatchRequest::release_header() {
  clear_has_header();
  ::cockroach::roachpb::Header* temp = header_;
  header_ = NULL;
  return temp;
}
inline void BatchRequest::set_allocated_header(::cockroach::roachpb::Header* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.BatchRequest.header)
}

// repeated .cockroach.roachpb.RequestUnion requests = 2;
inline int BatchRequest::requests_size() const {
  return requests_.size();
}
inline void BatchRequest::clear_requests() {
  requests_.Clear();
}
inline const ::cockroach::roachpb::RequestUnion& BatchRequest::requests(int index) const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.BatchRequest.requests)
  return requests_.Get(index);
}
inline ::cockroach::roachpb::RequestUnion* BatchRequest::mutable_requests(int index) {
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.BatchRequest.requests)
  return requests_.Mutable(index);
}
inline ::cockroach::roachpb::RequestUnion* BatchRequest::add_requests() {
  // @@protoc_insertion_point(field_add:cockroach.roachpb.BatchRequest.requests)
  return requests_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::cockroach::roachpb::RequestUnion >*
BatchRequest::mutable_requests() {
  // @@protoc_insertion_point(field_mutable_list:cockroach.roachpb.BatchRequest.requests)
  return &requests_;
}
inline const ::google::protobuf::RepeatedPtrField< ::cockroach::roachpb::RequestUnion >&
BatchRequest::requests() const {
  // @@protoc_insertion_point(field_list:cockroach.roachpb.BatchRequest.requests)
  return requests_;
}

// -------------------------------------------------------------------

// BatchResponse_Header

// optional .cockroach.roachpb.Error error = 1;
inline bool BatchResponse_Header::has_error() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BatchResponse_Header::set_has_error() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BatchResponse_Header::clear_has_error() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BatchResponse_Header::clear_error() {
  if (error_ != NULL) error_->::cockroach::roachpb::Error::Clear();
  clear_has_error();
}
inline const ::cockroach::roachpb::Error& BatchResponse_Header::error() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.BatchResponse.Header.error)
  return error_ != NULL ? *error_ : *default_instance_->error_;
}
inline ::cockroach::roachpb::Error* BatchResponse_Header::mutable_error() {
  set_has_error();
  if (error_ == NULL) {
    error_ = new ::cockroach::roachpb::Error;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.BatchResponse.Header.error)
  return error_;
}
inline ::cockroach::roachpb::Error* BatchResponse_Header::release_error() {
  clear_has_error();
  ::cockroach::roachpb::Error* temp = error_;
  error_ = NULL;
  return temp;
}
inline void BatchResponse_Header::set_allocated_error(::cockroach::roachpb::Error* error) {
  delete error_;
  error_ = error;
  if (error) {
    set_has_error();
  } else {
    clear_has_error();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.BatchResponse.Header.error)
}

// optional .cockroach.roachpb.Timestamp Timestamp = 2;
inline bool BatchResponse_Header::has_timestamp() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BatchResponse_Header::set_has_timestamp() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BatchResponse_Header::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BatchResponse_Header::clear_timestamp() {
  if (timestamp_ != NULL) timestamp_->::cockroach::roachpb::Timestamp::Clear();
  clear_has_timestamp();
}
inline const ::cockroach::roachpb::Timestamp& BatchResponse_Header::timestamp() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.BatchResponse.Header.Timestamp)
  return timestamp_ != NULL ? *timestamp_ : *default_instance_->timestamp_;
}
inline ::cockroach::roachpb::Timestamp* BatchResponse_Header::mutable_timestamp() {
  set_has_timestamp();
  if (timestamp_ == NULL) {
    timestamp_ = new ::cockroach::roachpb::Timestamp;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.BatchResponse.Header.Timestamp)
  return timestamp_;
}
inline ::cockroach::roachpb::Timestamp* BatchResponse_Header::release_timestamp() {
  clear_has_timestamp();
  ::cockroach::roachpb::Timestamp* temp = timestamp_;
  timestamp_ = NULL;
  return temp;
}
inline void BatchResponse_Header::set_allocated_timestamp(::cockroach::roachpb::Timestamp* timestamp) {
  delete timestamp_;
  timestamp_ = timestamp;
  if (timestamp) {
    set_has_timestamp();
  } else {
    clear_has_timestamp();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.BatchResponse.Header.Timestamp)
}

// optional .cockroach.roachpb.Transaction txn = 3;
inline bool BatchResponse_Header::has_txn() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BatchResponse_Header::set_has_txn() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BatchResponse_Header::clear_has_txn() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BatchResponse_Header::clear_txn() {
  if (txn_ != NULL) txn_->::cockroach::roachpb::Transaction::Clear();
  clear_has_txn();
}
inline const ::cockroach::roachpb::Transaction& BatchResponse_Header::txn() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.BatchResponse.Header.txn)
  return txn_ != NULL ? *txn_ : *default_instance_->txn_;
}
inline ::cockroach::roachpb::Transaction* BatchResponse_Header::mutable_txn() {
  set_has_txn();
  if (txn_ == NULL) {
    txn_ = new ::cockroach::roachpb::Transaction;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.BatchResponse.Header.txn)
  return txn_;
}
inline ::cockroach::roachpb::Transaction* BatchResponse_Header::release_txn() {
  clear_has_txn();
  ::cockroach::roachpb::Transaction* temp = txn_;
  txn_ = NULL;
  return temp;
}
inline void BatchResponse_Header::set_allocated_txn(::cockroach::roachpb::Transaction* txn) {
  delete txn_;
  txn_ = txn;
  if (txn) {
    set_has_txn();
  } else {
    clear_has_txn();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.BatchResponse.Header.txn)
}

// repeated bytes collected_spans = 4;
inline int BatchResponse_Header::collected_spans_size() const {
  return collected_spans_.size();
}
inline void BatchResponse_Header::clear_collected_spans() {
  collected_spans_.Clear();
}
inline const ::std::string& BatchResponse_Header::collected_spans(int index) const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.BatchResponse.Header.collected_spans)
  return collected_spans_.Get(index);
}
inline ::std::string* BatchResponse_Header::mutable_collected_spans(int index) {
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.BatchResponse.Header.collected_spans)
  return collected_spans_.Mutable(index);
}
inline void BatchResponse_Header::set_collected_spans(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:cockroach.roachpb.BatchResponse.Header.collected_spans)
  collected_spans_.Mutable(index)->assign(value);
}
inline void BatchResponse_Header::set_collected_spans(int index, const char* value) {
  collected_spans_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:cockroach.roachpb.BatchResponse.Header.collected_spans)
}
inline void BatchResponse_Header::set_collected_spans(int index, const void* value, size_t size) {
  collected_spans_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:cockroach.roachpb.BatchResponse.Header.collected_spans)
}
inline ::std::string* BatchResponse_Header::add_collected_spans() {
  return collected_spans_.Add();
}
inline void BatchResponse_Header::add_collected_spans(const ::std::string& value) {
  collected_spans_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:cockroach.roachpb.BatchResponse.Header.collected_spans)
}
inline void BatchResponse_Header::add_collected_spans(const char* value) {
  collected_spans_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:cockroach.roachpb.BatchResponse.Header.collected_spans)
}
inline void BatchResponse_Header::add_collected_spans(const void* value, size_t size) {
  collected_spans_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:cockroach.roachpb.BatchResponse.Header.collected_spans)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
BatchResponse_Header::collected_spans() const {
  // @@protoc_insertion_point(field_list:cockroach.roachpb.BatchResponse.Header.collected_spans)
  return collected_spans_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
BatchResponse_Header::mutable_collected_spans() {
  // @@protoc_insertion_point(field_mutable_list:cockroach.roachpb.BatchResponse.Header.collected_spans)
  return &collected_spans_;
}

// optional .cockroach.roachpb.Timestamp now = 5;
inline bool BatchResponse_Header::has_now() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void BatchResponse_Header::set_has_now() {
  _has_bits_[0] |= 0x00000010u;
}
inline void BatchResponse_Header::clear_has_now() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void BatchResponse_Header::clear_now() {
  if (now_ != NULL) now_->::cockroach::roachpb::Timestamp::Clear();
  clear_has_now();
}
inline const ::cockroach::roachpb::Timestamp& BatchResponse_Header::now() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.BatchResponse.Header.now)
  return now_ != NULL ? *now_ : *default_instance_->now_;
}
inline ::cockroach::roachpb::Timestamp* BatchResponse_Header::mutable_now() {
  set_has_now();
  if (now_ == NULL) {
    now_ = new ::cockroach::roachpb::Timestamp;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.BatchResponse.Header.now)
  return now_;
}
inline ::cockroach::roachpb::Timestamp* BatchResponse_Header::release_now() {
  clear_has_now();
  ::cockroach::roachpb::Timestamp* temp = now_;
  now_ = NULL;
  return temp;
}
inline void BatchResponse_Header::set_allocated_now(::cockroach::roachpb::Timestamp* now) {
  delete now_;
  now_ = now;
  if (now) {
    set_has_now();
  } else {
    clear_has_now();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.BatchResponse.Header.now)
}

// -------------------------------------------------------------------

// BatchResponse

// optional .cockroach.roachpb.BatchResponse.Header header = 1;
inline bool BatchResponse::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BatchResponse::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BatchResponse::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BatchResponse::clear_header() {
  if (header_ != NULL) header_->::cockroach::roachpb::BatchResponse_Header::Clear();
  clear_has_header();
}
inline const ::cockroach::roachpb::BatchResponse_Header& BatchResponse::header() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.BatchResponse.header)
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
inline ::cockroach::roachpb::BatchResponse_Header* BatchResponse::mutable_header() {
  set_has_header();
  if (header_ == NULL) {
    header_ = new ::cockroach::roachpb::BatchResponse_Header;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.BatchResponse.header)
  return header_;
}
inline ::cockroach::roachpb::BatchResponse_Header* BatchResponse::release_header() {
  clear_has_header();
  ::cockroach::roachpb::BatchResponse_Header* temp = header_;
  header_ = NULL;
  return temp;
}
inline void BatchResponse::set_allocated_header(::cockroach::roachpb::BatchResponse_Header* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.BatchResponse.header)
}

// repeated .cockroach.roachpb.ResponseUnion responses = 2;
inline int BatchResponse::responses_size() const {
  return responses_.size();
}
inline void BatchResponse::clear_responses() {
  responses_.Clear();
}
inline const ::cockroach::roachpb::ResponseUnion& BatchResponse::responses(int index) const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.BatchResponse.responses)
  return responses_.Get(index);
}
inline ::cockroach::roachpb::ResponseUnion* BatchResponse::mutable_responses(int index) {
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.BatchResponse.responses)
  return responses_.Mutable(index);
}
inline ::cockroach::roachpb::ResponseUnion* BatchResponse::add_responses() {
  // @@protoc_insertion_point(field_add:cockroach.roachpb.BatchResponse.responses)
  return responses_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::cockroach::roachpb::ResponseUnion >*
BatchResponse::mutable_responses() {
  // @@protoc_insertion_point(field_mutable_list:cockroach.roachpb.BatchResponse.responses)
  return &responses_;
}
inline const ::google::protobuf::RepeatedPtrField< ::cockroach::roachpb::ResponseUnion >&
BatchResponse::responses() const {
  // @@protoc_insertion_point(field_list:cockroach.roachpb.BatchResponse.responses)
  return responses_;
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace roachpb
}  // namespace cockroach

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::cockroach::roachpb::ReadConsistencyType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::cockroach::roachpb::ReadConsistencyType>() {
  return ::cockroach::roachpb::ReadConsistencyType_descriptor();
}
template <> struct is_proto_enum< ::cockroach::roachpb::PushTxnType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::cockroach::roachpb::PushTxnType>() {
  return ::cockroach::roachpb::PushTxnType_descriptor();
}

}  // namespace protobuf
}  // namespace google
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_cockroach_2froachpb_2fapi_2eproto__INCLUDED
