// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: cockroach/roachpb/api.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "cockroach/roachpb/api.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/port.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)

namespace cockroach {
namespace roachpb {

namespace {

const ::google::protobuf::Descriptor* ResponseHeader_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ResponseHeader_reflection_ = NULL;
const ::google::protobuf::Descriptor* GetRequest_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  GetRequest_reflection_ = NULL;
const ::google::protobuf::Descriptor* GetResponse_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  GetResponse_reflection_ = NULL;
const ::google::protobuf::Descriptor* PutRequest_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  PutRequest_reflection_ = NULL;
const ::google::protobuf::Descriptor* PutResponse_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  PutResponse_reflection_ = NULL;
const ::google::protobuf::Descriptor* ConditionalPutRequest_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ConditionalPutRequest_reflection_ = NULL;
const ::google::protobuf::Descriptor* ConditionalPutResponse_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ConditionalPutResponse_reflection_ = NULL;
const ::google::protobuf::Descriptor* IncrementRequest_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  IncrementRequest_reflection_ = NULL;
const ::google::protobuf::Descriptor* IncrementResponse_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  IncrementResponse_reflection_ = NULL;
const ::google::protobuf::Descriptor* DeleteRequest_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  DeleteRequest_reflection_ = NULL;
const ::google::protobuf::Descriptor* DeleteResponse_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  DeleteResponse_reflection_ = NULL;
const ::google::protobuf::Descriptor* DeleteRangeRequest_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  DeleteRangeRequest_reflection_ = NULL;
const ::google::protobuf::Descriptor* DeleteRangeResponse_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  DeleteRangeResponse_reflection_ = NULL;
const ::google::protobuf::Descriptor* ScanRequest_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ScanRequest_reflection_ = NULL;
const ::google::protobuf::Descriptor* ScanResponse_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ScanResponse_reflection_ = NULL;
const ::google::protobuf::Descriptor* ReverseScanRequest_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ReverseScanRequest_reflection_ = NULL;
const ::google::protobuf::Descriptor* ReverseScanResponse_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ReverseScanResponse_reflection_ = NULL;
const ::google::protobuf::Descriptor* CheckConsistencyRequest_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  CheckConsistencyRequest_reflection_ = NULL;
const ::google::protobuf::Descriptor* CheckConsistencyResponse_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  CheckConsistencyResponse_reflection_ = NULL;
const ::google::protobuf::Descriptor* BeginTransactionRequest_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  BeginTransactionRequest_reflection_ = NULL;
const ::google::protobuf::Descriptor* BeginTransactionResponse_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  BeginTransactionResponse_reflection_ = NULL;
const ::google::protobuf::Descriptor* EndTransactionRequest_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  EndTransactionRequest_reflection_ = NULL;
const ::google::protobuf::Descriptor* EndTransactionResponse_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  EndTransactionResponse_reflection_ = NULL;
const ::google::protobuf::Descriptor* AdminSplitRequest_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  AdminSplitRequest_reflection_ = NULL;
const ::google::protobuf::Descriptor* AdminSplitResponse_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  AdminSplitResponse_reflection_ = NULL;
const ::google::protobuf::Descriptor* AdminMergeRequest_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  AdminMergeRequest_reflection_ = NULL;
const ::google::protobuf::Descriptor* AdminMergeResponse_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  AdminMergeResponse_reflection_ = NULL;
const ::google::protobuf::Descriptor* RangeLookupRequest_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  RangeLookupRequest_reflection_ = NULL;
const ::google::protobuf::Descriptor* RangeLookupResponse_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  RangeLookupResponse_reflection_ = NULL;
const ::google::protobuf::Descriptor* HeartbeatTxnRequest_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  HeartbeatTxnRequest_reflection_ = NULL;
const ::google::protobuf::Descriptor* HeartbeatTxnResponse_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  HeartbeatTxnResponse_reflection_ = NULL;
const ::google::protobuf::Descriptor* GCRequest_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  GCRequest_reflection_ = NULL;
const ::google::protobuf::Descriptor* GCRequest_GCKey_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  GCRequest_GCKey_reflection_ = NULL;
const ::google::protobuf::Descriptor* GCResponse_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  GCResponse_reflection_ = NULL;
const ::google::protobuf::Descriptor* PushTxnRequest_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  PushTxnRequest_reflection_ = NULL;
const ::google::protobuf::Descriptor* PushTxnResponse_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  PushTxnResponse_reflection_ = NULL;
const ::google::protobuf::Descriptor* ResolveIntentRequest_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ResolveIntentRequest_reflection_ = NULL;
const ::google::protobuf::Descriptor* ResolveIntentResponse_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ResolveIntentResponse_reflection_ = NULL;
const ::google::protobuf::Descriptor* ResolveIntentRangeRequest_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ResolveIntentRangeRequest_reflection_ = NULL;
const ::google::protobuf::Descriptor* NoopResponse_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  NoopResponse_reflection_ = NULL;
const ::google::protobuf::Descriptor* NoopRequest_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  NoopRequest_reflection_ = NULL;
const ::google::protobuf::Descriptor* ResolveIntentRangeResponse_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ResolveIntentRangeResponse_reflection_ = NULL;
const ::google::protobuf::Descriptor* MergeRequest_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  MergeRequest_reflection_ = NULL;
const ::google::protobuf::Descriptor* MergeResponse_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  MergeResponse_reflection_ = NULL;
const ::google::protobuf::Descriptor* TruncateLogRequest_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  TruncateLogRequest_reflection_ = NULL;
const ::google::protobuf::Descriptor* TruncateLogResponse_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  TruncateLogResponse_reflection_ = NULL;
const ::google::protobuf::Descriptor* LeaderLeaseRequest_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  LeaderLeaseRequest_reflection_ = NULL;
const ::google::protobuf::Descriptor* LeaderLeaseResponse_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  LeaderLeaseResponse_reflection_ = NULL;
const ::google::protobuf::Descriptor* ComputeChecksumRequest_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ComputeChecksumRequest_reflection_ = NULL;
const ::google::protobuf::Descriptor* ComputeChecksumResponse_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ComputeChecksumResponse_reflection_ = NULL;
const ::google::protobuf::Descriptor* VerifyChecksumRequest_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  VerifyChecksumRequest_reflection_ = NULL;
const ::google::protobuf::Descriptor* VerifyChecksumResponse_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  VerifyChecksumResponse_reflection_ = NULL;
const ::google::protobuf::Descriptor* RequestUnion_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  RequestUnion_reflection_ = NULL;
const ::google::protobuf::Descriptor* ResponseUnion_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ResponseUnion_reflection_ = NULL;
const ::google::protobuf::Descriptor* Header_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Header_reflection_ = NULL;
const ::google::protobuf::Descriptor* BatchRequest_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  BatchRequest_reflection_ = NULL;
const ::google::protobuf::Descriptor* BatchResponse_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  BatchResponse_reflection_ = NULL;
const ::google::protobuf::Descriptor* BatchResponse_Header_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  BatchResponse_Header_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* ReadConsistencyType_descriptor_ = NULL;
const ::google::protobuf::EnumDescriptor* PushTxnType_descriptor_ = NULL;

}  // namespace


void protobuf_AssignDesc_cockroach_2froachpb_2fapi_2eproto() {
  protobuf_AddDesc_cockroach_2froachpb_2fapi_2eproto();
  const ::google::protobuf::FileDescriptor* file =
    ::google::protobuf::DescriptorPool::generated_pool()->FindFileByName(
      "cockroach/roachpb/api.proto");
  GOOGLE_CHECK(file != NULL);
  ResponseHeader_descriptor_ = file->message_type(0);
  static const int ResponseHeader_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResponseHeader, timestamp_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResponseHeader, txn_),
  };
  ResponseHeader_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      ResponseHeader_descriptor_,
      ResponseHeader::default_instance_,
      ResponseHeader_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResponseHeader, _has_bits_[0]),
      -1,
      -1,
      sizeof(ResponseHeader),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResponseHeader, _internal_metadata_),
      -1);
  GetRequest_descriptor_ = file->message_type(1);
  static const int GetRequest_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GetRequest, header_),
  };
  GetRequest_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      GetRequest_descriptor_,
      GetRequest::default_instance_,
      GetRequest_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GetRequest, _has_bits_[0]),
      -1,
      -1,
      sizeof(GetRequest),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GetRequest, _internal_metadata_),
      -1);
  GetResponse_descriptor_ = file->message_type(2);
  static const int GetResponse_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GetResponse, header_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GetResponse, value_),
  };
  GetResponse_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      GetResponse_descriptor_,
      GetResponse::default_instance_,
      GetResponse_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GetResponse, _has_bits_[0]),
      -1,
      -1,
      sizeof(GetResponse),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GetResponse, _internal_metadata_),
      -1);
  PutRequest_descriptor_ = file->message_type(3);
  static const int PutRequest_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PutRequest, header_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PutRequest, value_),
  };
  PutRequest_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      PutRequest_descriptor_,
      PutRequest::default_instance_,
      PutRequest_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PutRequest, _has_bits_[0]),
      -1,
      -1,
      sizeof(PutRequest),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PutRequest, _internal_metadata_),
      -1);
  PutResponse_descriptor_ = file->message_type(4);
  static const int PutResponse_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PutResponse, header_),
  };
  PutResponse_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      PutResponse_descriptor_,
      PutResponse::default_instance_,
      PutResponse_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PutResponse, _has_bits_[0]),
      -1,
      -1,
      sizeof(PutResponse),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PutResponse, _internal_metadata_),
      -1);
  ConditionalPutRequest_descriptor_ = file->message_type(5);
  static const int ConditionalPutRequest_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ConditionalPutRequest, header_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ConditionalPutRequest, value_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ConditionalPutRequest, exp_value_),
  };
  ConditionalPutRequest_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      ConditionalPutRequest_descriptor_,
      ConditionalPutRequest::default_instance_,
      ConditionalPutRequest_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ConditionalPutRequest, _has_bits_[0]),
      -1,
      -1,
      sizeof(ConditionalPutRequest),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ConditionalPutRequest, _internal_metadata_),
      -1);
  ConditionalPutResponse_descriptor_ = file->message_type(6);
  static const int ConditionalPutResponse_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ConditionalPutResponse, header_),
  };
  ConditionalPutResponse_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      ConditionalPutResponse_descriptor_,
      ConditionalPutResponse::default_instance_,
      ConditionalPutResponse_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ConditionalPutResponse, _has_bits_[0]),
      -1,
      -1,
      sizeof(ConditionalPutResponse),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ConditionalPutResponse, _internal_metadata_),
      -1);
  IncrementRequest_descriptor_ = file->message_type(7);
  static const int IncrementRequest_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(IncrementRequest, header_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(IncrementRequest, increment_),
  };
  IncrementRequest_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      IncrementRequest_descriptor_,
      IncrementRequest::default_instance_,
      IncrementRequest_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(IncrementRequest, _has_bits_[0]),
      -1,
      -1,
      sizeof(IncrementRequest),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(IncrementRequest, _internal_metadata_),
      -1);
  IncrementResponse_descriptor_ = file->message_type(8);
  static const int IncrementResponse_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(IncrementResponse, header_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(IncrementResponse, new_value_),
  };
  IncrementResponse_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      IncrementResponse_descriptor_,
      IncrementResponse::default_instance_,
      IncrementResponse_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(IncrementResponse, _has_bits_[0]),
      -1,
      -1,
      sizeof(IncrementResponse),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(IncrementResponse, _internal_metadata_),
      -1);
  DeleteRequest_descriptor_ = file->message_type(9);
  static const int DeleteRequest_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DeleteRequest, header_),
  };
  DeleteRequest_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      DeleteRequest_descriptor_,
      DeleteRequest::default_instance_,
      DeleteRequest_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DeleteRequest, _has_bits_[0]),
      -1,
      -1,
      sizeof(DeleteRequest),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DeleteRequest, _internal_metadata_),
      -1);
  DeleteResponse_descriptor_ = file->message_type(10);
  static const int DeleteResponse_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DeleteResponse, header_),
  };
  DeleteResponse_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      DeleteResponse_descriptor_,
      DeleteResponse::default_instance_,
      DeleteResponse_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DeleteResponse, _has_bits_[0]),
      -1,
      -1,
      sizeof(DeleteResponse),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DeleteResponse, _internal_metadata_),
      -1);
  DeleteRangeRequest_descriptor_ = file->message_type(11);
  static const int DeleteRangeRequest_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DeleteRangeRequest, header_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DeleteRangeRequest, max_entries_to_delete_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DeleteRangeRequest, return_keys_),
  };
  DeleteRangeRequest_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      DeleteRangeRequest_descriptor_,
      DeleteRangeRequest::default_instance_,
      DeleteRangeRequest_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DeleteRangeRequest, _has_bits_[0]),
      -1,
      -1,
      sizeof(DeleteRangeRequest),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DeleteRangeRequest, _internal_metadata_),
      -1);
  DeleteRangeResponse_descriptor_ = file->message_type(12);
  static const int DeleteRangeResponse_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DeleteRangeResponse, header_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DeleteRangeResponse, keys_),
  };
  DeleteRangeResponse_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      DeleteRangeResponse_descriptor_,
      DeleteRangeResponse::default_instance_,
      DeleteRangeResponse_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DeleteRangeResponse, _has_bits_[0]),
      -1,
      -1,
      sizeof(DeleteRangeResponse),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DeleteRangeResponse, _internal_metadata_),
      -1);
  ScanRequest_descriptor_ = file->message_type(13);
  static const int ScanRequest_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ScanRequest, header_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ScanRequest, max_results_),
  };
  ScanRequest_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      ScanRequest_descriptor_,
      ScanRequest::default_instance_,
      ScanRequest_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ScanRequest, _has_bits_[0]),
      -1,
      -1,
      sizeof(ScanRequest),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ScanRequest, _internal_metadata_),
      -1);
  ScanResponse_descriptor_ = file->message_type(14);
  static const int ScanResponse_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ScanResponse, header_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ScanResponse, rows_),
  };
  ScanResponse_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      ScanResponse_descriptor_,
      ScanResponse::default_instance_,
      ScanResponse_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ScanResponse, _has_bits_[0]),
      -1,
      -1,
      sizeof(ScanResponse),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ScanResponse, _internal_metadata_),
      -1);
  ReverseScanRequest_descriptor_ = file->message_type(15);
  static const int ReverseScanRequest_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReverseScanRequest, header_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReverseScanRequest, max_results_),
  };
  ReverseScanRequest_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      ReverseScanRequest_descriptor_,
      ReverseScanRequest::default_instance_,
      ReverseScanRequest_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReverseScanRequest, _has_bits_[0]),
      -1,
      -1,
      sizeof(ReverseScanRequest),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReverseScanRequest, _internal_metadata_),
      -1);
  ReverseScanResponse_descriptor_ = file->message_type(16);
  static const int ReverseScanResponse_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReverseScanResponse, header_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReverseScanResponse, rows_),
  };
  ReverseScanResponse_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      ReverseScanResponse_descriptor_,
      ReverseScanResponse::default_instance_,
      ReverseScanResponse_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReverseScanResponse, _has_bits_[0]),
      -1,
      -1,
      sizeof(ReverseScanResponse),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReverseScanResponse, _internal_metadata_),
      -1);
  CheckConsistencyRequest_descriptor_ = file->message_type(17);
  static const int CheckConsistencyRequest_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CheckConsistencyRequest, header_),
  };
  CheckConsistencyRequest_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      CheckConsistencyRequest_descriptor_,
      CheckConsistencyRequest::default_instance_,
      CheckConsistencyRequest_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CheckConsistencyRequest, _has_bits_[0]),
      -1,
      -1,
      sizeof(CheckConsistencyRequest),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CheckConsistencyRequest, _internal_metadata_),
      -1);
  CheckConsistencyResponse_descriptor_ = file->message_type(18);
  static const int CheckConsistencyResponse_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CheckConsistencyResponse, header_),
  };
  CheckConsistencyResponse_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      CheckConsistencyResponse_descriptor_,
      CheckConsistencyResponse::default_instance_,
      CheckConsistencyResponse_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CheckConsistencyResponse, _has_bits_[0]),
      -1,
      -1,
      sizeof(CheckConsistencyResponse),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CheckConsistencyResponse, _internal_metadata_),
      -1);
  BeginTransactionRequest_descriptor_ = file->message_type(19);
  static const int BeginTransactionRequest_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BeginTransactionRequest, header_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BeginTransactionRequest, heartbeat_interval_),
  };
  BeginTransactionRequest_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      BeginTransactionRequest_descriptor_,
      BeginTransactionRequest::default_instance_,
      BeginTransactionRequest_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BeginTransactionRequest, _has_bits_[0]),
      -1,
      -1,
      sizeof(BeginTransactionRequest),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BeginTransactionRequest, _internal_metadata_),
      -1);
  BeginTransactionResponse_descriptor_ = file->message_type(20);
  static const int BeginTransactionResponse_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BeginTransactionResponse, header_),
  };
  BeginTransactionResponse_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      BeginTransactionResponse_descriptor_,
      BeginTransactionResponse::default_instance_,
      BeginTransactionResponse_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BeginTransactionResponse, _has_bits_[0]),
      -1,
      -1,
      sizeof(BeginTransactionResponse),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BeginTransactionResponse, _internal_metadata_),
      -1);
  EndTransactionRequest_descriptor_ = file->message_type(21);
  static const int EndTransactionRequest_offsets_[5] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EndTransactionRequest, header_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EndTransactionRequest, commit_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EndTransactionRequest, deadline_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EndTransactionRequest, internal_commit_trigger_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EndTransactionRequest, intent_spans_),
  };
  EndTransactionRequest_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      EndTransactionRequest_descriptor_,
      EndTransactionRequest::default_instance_,
      EndTransactionRequest_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EndTransactionRequest, _has_bits_[0]),
      -1,
      -1,
      sizeof(EndTransactionRequest),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EndTransactionRequest, _internal_metadata_),
      -1);
  EndTransactionResponse_descriptor_ = file->message_type(22);
  static const int EndTransactionResponse_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EndTransactionResponse, header_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EndTransactionResponse, commit_wait_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EndTransactionResponse, resolved_),
  };
  EndTransactionResponse_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      EndTransactionResponse_descriptor_,
      EndTransactionResponse::default_instance_,
      EndTransactionResponse_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EndTransactionResponse, _has_bits_[0]),
      -1,
      -1,
      sizeof(EndTransactionResponse),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EndTransactionResponse, _internal_metadata_),
      -1);
  AdminSplitRequest_descriptor_ = file->message_type(23);
  static const int AdminSplitRequest_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AdminSplitRequest, header_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AdminSplitRequest, split_key_),
  };
  AdminSplitRequest_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      AdminSplitRequest_descriptor_,
      AdminSplitRequest::default_instance_,
      AdminSplitRequest_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AdminSplitRequest, _has_bits_[0]),
      -1,
      -1,
      sizeof(AdminSplitRequest),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AdminSplitRequest, _internal_metadata_),
      -1);
  AdminSplitResponse_descriptor_ = file->message_type(24);
  static const int AdminSplitResponse_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AdminSplitResponse, header_),
  };
  AdminSplitResponse_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      AdminSplitResponse_descriptor_,
      AdminSplitResponse::default_instance_,
      AdminSplitResponse_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AdminSplitResponse, _has_bits_[0]),
      -1,
      -1,
      sizeof(AdminSplitResponse),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AdminSplitResponse, _internal_metadata_),
      -1);
  AdminMergeRequest_descriptor_ = file->message_type(25);
  static const int AdminMergeRequest_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AdminMergeRequest, header_),
  };
  AdminMergeRequest_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      AdminMergeRequest_descriptor_,
      AdminMergeRequest::default_instance_,
      AdminMergeRequest_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AdminMergeRequest, _has_bits_[0]),
      -1,
      -1,
      sizeof(AdminMergeRequest),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AdminMergeRequest, _internal_metadata_),
      -1);
  AdminMergeResponse_descriptor_ = file->message_type(26);
  static const int AdminMergeResponse_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AdminMergeResponse, header_),
  };
  AdminMergeResponse_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      AdminMergeResponse_descriptor_,
      AdminMergeResponse::default_instance_,
      AdminMergeResponse_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AdminMergeResponse, _has_bits_[0]),
      -1,
      -1,
      sizeof(AdminMergeResponse),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AdminMergeResponse, _internal_metadata_),
      -1);
  RangeLookupRequest_descriptor_ = file->message_type(27);
  static const int RangeLookupRequest_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RangeLookupRequest, header_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RangeLookupRequest, max_ranges_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RangeLookupRequest, consider_intents_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RangeLookupRequest, reverse_),
  };
  RangeLookupRequest_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      RangeLookupRequest_descriptor_,
      RangeLookupRequest::default_instance_,
      RangeLookupRequest_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RangeLookupRequest, _has_bits_[0]),
      -1,
      -1,
      sizeof(RangeLookupRequest),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RangeLookupRequest, _internal_metadata_),
      -1);
  RangeLookupResponse_descriptor_ = file->message_type(28);
  static const int RangeLookupResponse_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RangeLookupResponse, header_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RangeLookupResponse, ranges_),
  };
  RangeLookupResponse_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      RangeLookupResponse_descriptor_,
      RangeLookupResponse::default_instance_,
      RangeLookupResponse_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RangeLookupResponse, _has_bits_[0]),
      -1,
      -1,
      sizeof(RangeLookupResponse),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RangeLookupResponse, _internal_metadata_),
      -1);
  HeartbeatTxnRequest_descriptor_ = file->message_type(29);
  static const int HeartbeatTxnRequest_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HeartbeatTxnRequest, header_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HeartbeatTxnRequest, now_),
  };
  HeartbeatTxnRequest_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      HeartbeatTxnRequest_descriptor_,
      HeartbeatTxnRequest::default_instance_,
      HeartbeatTxnRequest_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HeartbeatTxnRequest, _has_bits_[0]),
      -1,
      -1,
      sizeof(HeartbeatTxnRequest),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HeartbeatTxnRequest, _internal_metadata_),
      -1);
  HeartbeatTxnResponse_descriptor_ = file->message_type(30);
  static const int HeartbeatTxnResponse_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HeartbeatTxnResponse, header_),
  };
  HeartbeatTxnResponse_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      HeartbeatTxnResponse_descriptor_,
      HeartbeatTxnResponse::default_instance_,
      HeartbeatTxnResponse_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HeartbeatTxnResponse, _has_bits_[0]),
      -1,
      -1,
      sizeof(HeartbeatTxnResponse),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HeartbeatTxnResponse, _internal_metadata_),
      -1);
  GCRequest_descriptor_ = file->message_type(31);
  static const int GCRequest_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GCRequest, header_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GCRequest, keys_),
  };
  GCRequest_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      GCRequest_descriptor_,
      GCRequest::default_instance_,
      GCRequest_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GCRequest, _has_bits_[0]),
      -1,
      -1,
      sizeof(GCRequest),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GCRequest, _internal_metadata_),
      -1);
  GCRequest_GCKey_descriptor_ = GCRequest_descriptor_->nested_type(0);
  static const int GCRequest_GCKey_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GCRequest_GCKey, key_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GCRequest_GCKey, timestamp_),
  };
  GCRequest_GCKey_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      GCRequest_GCKey_descriptor_,
      GCRequest_GCKey::default_instance_,
      GCRequest_GCKey_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GCRequest_GCKey, _has_bits_[0]),
      -1,
      -1,
      sizeof(GCRequest_GCKey),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GCRequest_GCKey, _internal_metadata_),
      -1);
  GCResponse_descriptor_ = file->message_type(32);
  static const int GCResponse_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GCResponse, header_),
  };
  GCResponse_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      GCResponse_descriptor_,
      GCResponse::default_instance_,
      GCResponse_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GCResponse, _has_bits_[0]),
      -1,
      -1,
      sizeof(GCResponse),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GCResponse, _internal_metadata_),
      -1);
  PushTxnRequest_descriptor_ = file->message_type(33);
  static const int PushTxnRequest_offsets_[6] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PushTxnRequest, header_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PushTxnRequest, pusher_txn_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PushTxnRequest, pushee_txn_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PushTxnRequest, push_to_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PushTxnRequest, now_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PushTxnRequest, push_type_),
  };
  PushTxnRequest_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      PushTxnRequest_descriptor_,
      PushTxnRequest::default_instance_,
      PushTxnRequest_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PushTxnRequest, _has_bits_[0]),
      -1,
      -1,
      sizeof(PushTxnRequest),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PushTxnRequest, _internal_metadata_),
      -1);
  PushTxnResponse_descriptor_ = file->message_type(34);
  static const int PushTxnResponse_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PushTxnResponse, header_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PushTxnResponse, pushee_txn_),
  };
  PushTxnResponse_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      PushTxnResponse_descriptor_,
      PushTxnResponse::default_instance_,
      PushTxnResponse_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PushTxnResponse, _has_bits_[0]),
      -1,
      -1,
      sizeof(PushTxnResponse),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PushTxnResponse, _internal_metadata_),
      -1);
  ResolveIntentRequest_descriptor_ = file->message_type(35);
  static const int ResolveIntentRequest_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResolveIntentRequest, header_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResolveIntentRequest, intent_txn_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResolveIntentRequest, status_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResolveIntentRequest, poison_),
  };
  ResolveIntentRequest_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      ResolveIntentRequest_descriptor_,
      ResolveIntentRequest::default_instance_,
      ResolveIntentRequest_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResolveIntentRequest, _has_bits_[0]),
      -1,
      -1,
      sizeof(ResolveIntentRequest),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResolveIntentRequest, _internal_metadata_),
      -1);
  ResolveIntentResponse_descriptor_ = file->message_type(36);
  static const int ResolveIntentResponse_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResolveIntentResponse, header_),
  };
  ResolveIntentResponse_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      ResolveIntentResponse_descriptor_,
      ResolveIntentResponse::default_instance_,
      ResolveIntentResponse_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResolveIntentResponse, _has_bits_[0]),
      -1,
      -1,
      sizeof(ResolveIntentResponse),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResolveIntentResponse, _internal_metadata_),
      -1);
  ResolveIntentRangeRequest_descriptor_ = file->message_type(37);
  static const int ResolveIntentRangeRequest_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResolveIntentRangeRequest, header_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResolveIntentRangeRequest, intent_txn_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResolveIntentRangeRequest, status_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResolveIntentRangeRequest, poison_),
  };
  ResolveIntentRangeRequest_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      ResolveIntentRangeRequest_descriptor_,
      ResolveIntentRangeRequest::default_instance_,
      ResolveIntentRangeRequest_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResolveIntentRangeRequest, _has_bits_[0]),
      -1,
      -1,
      sizeof(ResolveIntentRangeRequest),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResolveIntentRangeRequest, _internal_metadata_),
      -1);
  NoopResponse_descriptor_ = file->message_type(38);
  static const int NoopResponse_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NoopResponse, header_),
  };
  NoopResponse_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      NoopResponse_descriptor_,
      NoopResponse::default_instance_,
      NoopResponse_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NoopResponse, _has_bits_[0]),
      -1,
      -1,
      sizeof(NoopResponse),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NoopResponse, _internal_metadata_),
      -1);
  NoopRequest_descriptor_ = file->message_type(39);
  static const int NoopRequest_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NoopRequest, header_),
  };
  NoopRequest_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      NoopRequest_descriptor_,
      NoopRequest::default_instance_,
      NoopRequest_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NoopRequest, _has_bits_[0]),
      -1,
      -1,
      sizeof(NoopRequest),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NoopRequest, _internal_metadata_),
      -1);
  ResolveIntentRangeResponse_descriptor_ = file->message_type(40);
  static const int ResolveIntentRangeResponse_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResolveIntentRangeResponse, header_),
  };
  ResolveIntentRangeResponse_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      ResolveIntentRangeResponse_descriptor_,
      ResolveIntentRangeResponse::default_instance_,
      ResolveIntentRangeResponse_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResolveIntentRangeResponse, _has_bits_[0]),
      -1,
      -1,
      sizeof(ResolveIntentRangeResponse),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResolveIntentRangeResponse, _internal_metadata_),
      -1);
  MergeRequest_descriptor_ = file->message_type(41);
  static const int MergeRequest_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MergeRequest, header_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MergeRequest, value_),
  };
  MergeRequest_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      MergeRequest_descriptor_,
      MergeRequest::default_instance_,
      MergeRequest_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MergeRequest, _has_bits_[0]),
      -1,
      -1,
      sizeof(MergeRequest),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MergeRequest, _internal_metadata_),
      -1);
  MergeResponse_descriptor_ = file->message_type(42);
  static const int MergeResponse_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MergeResponse, header_),
  };
  MergeResponse_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      MergeResponse_descriptor_,
      MergeResponse::default_instance_,
      MergeResponse_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MergeResponse, _has_bits_[0]),
      -1,
      -1,
      sizeof(MergeResponse),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MergeResponse, _internal_metadata_),
      -1);
  TruncateLogRequest_descriptor_ = file->message_type(43);
  static const int TruncateLogRequest_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TruncateLogRequest, header_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TruncateLogRequest, index_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TruncateLogRequest, range_id_),
  };
  TruncateLogRequest_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      TruncateLogRequest_descriptor_,
      TruncateLogRequest::default_instance_,
      TruncateLogRequest_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TruncateLogRequest, _has_bits_[0]),
      -1,
      -1,
      sizeof(TruncateLogRequest),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TruncateLogRequest, _internal_metadata_),
      -1);
  TruncateLogResponse_descriptor_ = file->message_type(44);
  static const int TruncateLogResponse_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TruncateLogResponse, header_),
  };
  TruncateLogResponse_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      TruncateLogResponse_descriptor_,
      TruncateLogResponse::default_instance_,
      TruncateLogResponse_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TruncateLogResponse, _has_bits_[0]),
      -1,
      -1,
      sizeof(TruncateLogResponse),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TruncateLogResponse, _internal_metadata_),
      -1);
  LeaderLeaseRequest_descriptor_ = file->message_type(45);
  static const int LeaderLeaseRequest_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LeaderLeaseRequest, header_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LeaderLeaseRequest, lease_),
  };
  LeaderLeaseRequest_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      LeaderLeaseRequest_descriptor_,
      LeaderLeaseRequest::default_instance_,
      LeaderLeaseRequest_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LeaderLeaseRequest, _has_bits_[0]),
      -1,
      -1,
      sizeof(LeaderLeaseRequest),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LeaderLeaseRequest, _internal_metadata_),
      -1);
  LeaderLeaseResponse_descriptor_ = file->message_type(46);
  static const int LeaderLeaseResponse_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LeaderLeaseResponse, header_),
  };
  LeaderLeaseResponse_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      LeaderLeaseResponse_descriptor_,
      LeaderLeaseResponse::default_instance_,
      LeaderLeaseResponse_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LeaderLeaseResponse, _has_bits_[0]),
      -1,
      -1,
      sizeof(LeaderLeaseResponse),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LeaderLeaseResponse, _internal_metadata_),
      -1);
  ComputeChecksumRequest_descriptor_ = file->message_type(47);
  static const int ComputeChecksumRequest_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ComputeChecksumRequest, header_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ComputeChecksumRequest, version_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ComputeChecksumRequest, checksum_id_),
  };
  ComputeChecksumRequest_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      ComputeChecksumRequest_descriptor_,
      ComputeChecksumRequest::default_instance_,
      ComputeChecksumRequest_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ComputeChecksumRequest, _has_bits_[0]),
      -1,
      -1,
      sizeof(ComputeChecksumRequest),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ComputeChecksumRequest, _internal_metadata_),
      -1);
  ComputeChecksumResponse_descriptor_ = file->message_type(48);
  static const int ComputeChecksumResponse_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ComputeChecksumResponse, header_),
  };
  ComputeChecksumResponse_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      ComputeChecksumResponse_descriptor_,
      ComputeChecksumResponse::default_instance_,
      ComputeChecksumResponse_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ComputeChecksumResponse, _has_bits_[0]),
      -1,
      -1,
      sizeof(ComputeChecksumResponse),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ComputeChecksumResponse, _internal_metadata_),
      -1);
  VerifyChecksumRequest_descriptor_ = file->message_type(49);
  static const int VerifyChecksumRequest_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VerifyChecksumRequest, header_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VerifyChecksumRequest, version_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VerifyChecksumRequest, checksum_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VerifyChecksumRequest, checksum_),
  };
  VerifyChecksumRequest_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      VerifyChecksumRequest_descriptor_,
      VerifyChecksumRequest::default_instance_,
      VerifyChecksumRequest_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VerifyChecksumRequest, _has_bits_[0]),
      -1,
      -1,
      sizeof(VerifyChecksumRequest),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VerifyChecksumRequest, _internal_metadata_),
      -1);
  VerifyChecksumResponse_descriptor_ = file->message_type(50);
  static const int VerifyChecksumResponse_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VerifyChecksumResponse, header_),
  };
  VerifyChecksumResponse_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      VerifyChecksumResponse_descriptor_,
      VerifyChecksumResponse::default_instance_,
      VerifyChecksumResponse_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VerifyChecksumResponse, _has_bits_[0]),
      -1,
      -1,
      sizeof(VerifyChecksumResponse),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VerifyChecksumResponse, _internal_metadata_),
      -1);
  RequestUnion_descriptor_ = file->message_type(51);
  static const int RequestUnion_offsets_[25] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RequestUnion, get_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RequestUnion, put_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RequestUnion, conditional_put_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RequestUnion, increment_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RequestUnion, delete__),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RequestUnion, delete_range_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RequestUnion, scan_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RequestUnion, begin_transaction_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RequestUnion, end_transaction_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RequestUnion, admin_split_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RequestUnion, admin_merge_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RequestUnion, heartbeat_txn_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RequestUnion, gc_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RequestUnion, push_txn_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RequestUnion, range_lookup_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RequestUnion, resolve_intent_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RequestUnion, resolve_intent_range_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RequestUnion, merge_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RequestUnion, truncate_log_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RequestUnion, leader_lease_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RequestUnion, reverse_scan_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RequestUnion, compute_checksum_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RequestUnion, verify_checksum_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RequestUnion, check_consistency_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RequestUnion, noop_),
  };
  RequestUnion_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      RequestUnion_descriptor_,
      RequestUnion::default_instance_,
      RequestUnion_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RequestUnion, _has_bits_[0]),
      -1,
      -1,
      sizeof(RequestUnion),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RequestUnion, _internal_metadata_),
      -1);
  ResponseUnion_descriptor_ = file->message_type(52);
  static const int ResponseUnion_offsets_[25] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResponseUnion, get_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResponseUnion, put_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResponseUnion, conditional_put_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResponseUnion, increment_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResponseUnion, delete__),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResponseUnion, delete_range_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResponseUnion, scan_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResponseUnion, begin_transaction_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResponseUnion, end_transaction_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResponseUnion, admin_split_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResponseUnion, admin_merge_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResponseUnion, heartbeat_txn_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResponseUnion, gc_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResponseUnion, push_txn_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResponseUnion, range_lookup_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResponseUnion, resolve_intent_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResponseUnion, resolve_intent_range_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResponseUnion, merge_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResponseUnion, truncate_log_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResponseUnion, leader_lease_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResponseUnion, reverse_scan_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResponseUnion, compute_checksum_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResponseUnion, verify_checksum_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResponseUnion, check_consistency_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResponseUnion, noop_),
  };
  ResponseUnion_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      ResponseUnion_descriptor_,
      ResponseUnion::default_instance_,
      ResponseUnion_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResponseUnion, _has_bits_[0]),
      -1,
      -1,
      sizeof(ResponseUnion),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResponseUnion, _internal_metadata_),
      -1);
  Header_descriptor_ = file->message_type(53);
  static const int Header_offsets_[9] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Header, timestamp_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Header, replica_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Header, range_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Header, user_priority_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Header, txn_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Header, heartbeat_interval_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Header, read_consistency_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Header, trace_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Header, max_scan_results_),
  };
  Header_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      Header_descriptor_,
      Header::default_instance_,
      Header_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Header, _has_bits_[0]),
      -1,
      -1,
      sizeof(Header),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Header, _internal_metadata_),
      -1);
  BatchRequest_descriptor_ = file->message_type(54);
  static const int BatchRequest_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BatchRequest, header_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BatchRequest, requests_),
  };
  BatchRequest_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      BatchRequest_descriptor_,
      BatchRequest::default_instance_,
      BatchRequest_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BatchRequest, _has_bits_[0]),
      -1,
      -1,
      sizeof(BatchRequest),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BatchRequest, _internal_metadata_),
      -1);
  BatchResponse_descriptor_ = file->message_type(55);
  static const int BatchResponse_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BatchResponse, header_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BatchResponse, responses_),
  };
  BatchResponse_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      BatchResponse_descriptor_,
      BatchResponse::default_instance_,
      BatchResponse_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BatchResponse, _has_bits_[0]),
      -1,
      -1,
      sizeof(BatchResponse),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BatchResponse, _internal_metadata_),
      -1);
  BatchResponse_Header_descriptor_ = BatchResponse_descriptor_->nested_type(0);
  static const int BatchResponse_Header_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BatchResponse_Header, error_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BatchResponse_Header, txn_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BatchResponse_Header, collected_spans_),
  };
  BatchResponse_Header_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      BatchResponse_Header_descriptor_,
      BatchResponse_Header::default_instance_,
      BatchResponse_Header_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BatchResponse_Header, _has_bits_[0]),
      -1,
      -1,
      sizeof(BatchResponse_Header),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BatchResponse_Header, _internal_metadata_),
      -1);
  ReadConsistencyType_descriptor_ = file->enum_type(0);
  PushTxnType_descriptor_ = file->enum_type(1);
}

namespace {

GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AssignDescriptors_once_);
inline void protobuf_AssignDescriptorsOnce() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AssignDescriptors_once_,
                 &protobuf_AssignDesc_cockroach_2froachpb_2fapi_2eproto);
}

void protobuf_RegisterTypes(const ::std::string&) {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      ResponseHeader_descriptor_, &ResponseHeader::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      GetRequest_descriptor_, &GetRequest::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      GetResponse_descriptor_, &GetResponse::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      PutRequest_descriptor_, &PutRequest::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      PutResponse_descriptor_, &PutResponse::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      ConditionalPutRequest_descriptor_, &ConditionalPutRequest::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      ConditionalPutResponse_descriptor_, &ConditionalPutResponse::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      IncrementRequest_descriptor_, &IncrementRequest::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      IncrementResponse_descriptor_, &IncrementResponse::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      DeleteRequest_descriptor_, &DeleteRequest::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      DeleteResponse_descriptor_, &DeleteResponse::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      DeleteRangeRequest_descriptor_, &DeleteRangeRequest::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      DeleteRangeResponse_descriptor_, &DeleteRangeResponse::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      ScanRequest_descriptor_, &ScanRequest::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      ScanResponse_descriptor_, &ScanResponse::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      ReverseScanRequest_descriptor_, &ReverseScanRequest::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      ReverseScanResponse_descriptor_, &ReverseScanResponse::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      CheckConsistencyRequest_descriptor_, &CheckConsistencyRequest::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      CheckConsistencyResponse_descriptor_, &CheckConsistencyResponse::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      BeginTransactionRequest_descriptor_, &BeginTransactionRequest::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      BeginTransactionResponse_descriptor_, &BeginTransactionResponse::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      EndTransactionRequest_descriptor_, &EndTransactionRequest::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      EndTransactionResponse_descriptor_, &EndTransactionResponse::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      AdminSplitRequest_descriptor_, &AdminSplitRequest::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      AdminSplitResponse_descriptor_, &AdminSplitResponse::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      AdminMergeRequest_descriptor_, &AdminMergeRequest::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      AdminMergeResponse_descriptor_, &AdminMergeResponse::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      RangeLookupRequest_descriptor_, &RangeLookupRequest::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      RangeLookupResponse_descriptor_, &RangeLookupResponse::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      HeartbeatTxnRequest_descriptor_, &HeartbeatTxnRequest::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      HeartbeatTxnResponse_descriptor_, &HeartbeatTxnResponse::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      GCRequest_descriptor_, &GCRequest::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      GCRequest_GCKey_descriptor_, &GCRequest_GCKey::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      GCResponse_descriptor_, &GCResponse::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      PushTxnRequest_descriptor_, &PushTxnRequest::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      PushTxnResponse_descriptor_, &PushTxnResponse::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      ResolveIntentRequest_descriptor_, &ResolveIntentRequest::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      ResolveIntentResponse_descriptor_, &ResolveIntentResponse::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      ResolveIntentRangeRequest_descriptor_, &ResolveIntentRangeRequest::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      NoopResponse_descriptor_, &NoopResponse::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      NoopRequest_descriptor_, &NoopRequest::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      ResolveIntentRangeResponse_descriptor_, &ResolveIntentRangeResponse::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      MergeRequest_descriptor_, &MergeRequest::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      MergeResponse_descriptor_, &MergeResponse::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      TruncateLogRequest_descriptor_, &TruncateLogRequest::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      TruncateLogResponse_descriptor_, &TruncateLogResponse::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      LeaderLeaseRequest_descriptor_, &LeaderLeaseRequest::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      LeaderLeaseResponse_descriptor_, &LeaderLeaseResponse::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      ComputeChecksumRequest_descriptor_, &ComputeChecksumRequest::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      ComputeChecksumResponse_descriptor_, &ComputeChecksumResponse::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      VerifyChecksumRequest_descriptor_, &VerifyChecksumRequest::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      VerifyChecksumResponse_descriptor_, &VerifyChecksumResponse::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      RequestUnion_descriptor_, &RequestUnion::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      ResponseUnion_descriptor_, &ResponseUnion::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      Header_descriptor_, &Header::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      BatchRequest_descriptor_, &BatchRequest::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      BatchResponse_descriptor_, &BatchResponse::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      BatchResponse_Header_descriptor_, &BatchResponse_Header::default_instance());
}

}  // namespace

void protobuf_ShutdownFile_cockroach_2froachpb_2fapi_2eproto() {
  delete ResponseHeader::default_instance_;
  delete ResponseHeader_reflection_;
  delete GetRequest::default_instance_;
  delete GetRequest_reflection_;
  delete GetResponse::default_instance_;
  delete GetResponse_reflection_;
  delete PutRequest::default_instance_;
  delete PutRequest_reflection_;
  delete PutResponse::default_instance_;
  delete PutResponse_reflection_;
  delete ConditionalPutRequest::default_instance_;
  delete ConditionalPutRequest_reflection_;
  delete ConditionalPutResponse::default_instance_;
  delete ConditionalPutResponse_reflection_;
  delete IncrementRequest::default_instance_;
  delete IncrementRequest_reflection_;
  delete IncrementResponse::default_instance_;
  delete IncrementResponse_reflection_;
  delete DeleteRequest::default_instance_;
  delete DeleteRequest_reflection_;
  delete DeleteResponse::default_instance_;
  delete DeleteResponse_reflection_;
  delete DeleteRangeRequest::default_instance_;
  delete DeleteRangeRequest_reflection_;
  delete DeleteRangeResponse::default_instance_;
  delete DeleteRangeResponse_reflection_;
  delete ScanRequest::default_instance_;
  delete ScanRequest_reflection_;
  delete ScanResponse::default_instance_;
  delete ScanResponse_reflection_;
  delete ReverseScanRequest::default_instance_;
  delete ReverseScanRequest_reflection_;
  delete ReverseScanResponse::default_instance_;
  delete ReverseScanResponse_reflection_;
  delete CheckConsistencyRequest::default_instance_;
  delete CheckConsistencyRequest_reflection_;
  delete CheckConsistencyResponse::default_instance_;
  delete CheckConsistencyResponse_reflection_;
  delete BeginTransactionRequest::default_instance_;
  delete BeginTransactionRequest_reflection_;
  delete BeginTransactionResponse::default_instance_;
  delete BeginTransactionResponse_reflection_;
  delete EndTransactionRequest::default_instance_;
  delete EndTransactionRequest_reflection_;
  delete EndTransactionResponse::default_instance_;
  delete EndTransactionResponse_reflection_;
  delete AdminSplitRequest::default_instance_;
  delete AdminSplitRequest_reflection_;
  delete AdminSplitResponse::default_instance_;
  delete AdminSplitResponse_reflection_;
  delete AdminMergeRequest::default_instance_;
  delete AdminMergeRequest_reflection_;
  delete AdminMergeResponse::default_instance_;
  delete AdminMergeResponse_reflection_;
  delete RangeLookupRequest::default_instance_;
  delete RangeLookupRequest_reflection_;
  delete RangeLookupResponse::default_instance_;
  delete RangeLookupResponse_reflection_;
  delete HeartbeatTxnRequest::default_instance_;
  delete HeartbeatTxnRequest_reflection_;
  delete HeartbeatTxnResponse::default_instance_;
  delete HeartbeatTxnResponse_reflection_;
  delete GCRequest::default_instance_;
  delete GCRequest_reflection_;
  delete GCRequest_GCKey::default_instance_;
  delete GCRequest_GCKey_reflection_;
  delete GCResponse::default_instance_;
  delete GCResponse_reflection_;
  delete PushTxnRequest::default_instance_;
  delete PushTxnRequest_reflection_;
  delete PushTxnResponse::default_instance_;
  delete PushTxnResponse_reflection_;
  delete ResolveIntentRequest::default_instance_;
  delete ResolveIntentRequest_reflection_;
  delete ResolveIntentResponse::default_instance_;
  delete ResolveIntentResponse_reflection_;
  delete ResolveIntentRangeRequest::default_instance_;
  delete ResolveIntentRangeRequest_reflection_;
  delete NoopResponse::default_instance_;
  delete NoopResponse_reflection_;
  delete NoopRequest::default_instance_;
  delete NoopRequest_reflection_;
  delete ResolveIntentRangeResponse::default_instance_;
  delete ResolveIntentRangeResponse_reflection_;
  delete MergeRequest::default_instance_;
  delete MergeRequest_reflection_;
  delete MergeResponse::default_instance_;
  delete MergeResponse_reflection_;
  delete TruncateLogRequest::default_instance_;
  delete TruncateLogRequest_reflection_;
  delete TruncateLogResponse::default_instance_;
  delete TruncateLogResponse_reflection_;
  delete LeaderLeaseRequest::default_instance_;
  delete LeaderLeaseRequest_reflection_;
  delete LeaderLeaseResponse::default_instance_;
  delete LeaderLeaseResponse_reflection_;
  delete ComputeChecksumRequest::default_instance_;
  delete ComputeChecksumRequest_reflection_;
  delete ComputeChecksumResponse::default_instance_;
  delete ComputeChecksumResponse_reflection_;
  delete VerifyChecksumRequest::default_instance_;
  delete VerifyChecksumRequest_reflection_;
  delete VerifyChecksumResponse::default_instance_;
  delete VerifyChecksumResponse_reflection_;
  delete RequestUnion::default_instance_;
  delete RequestUnion_reflection_;
  delete ResponseUnion::default_instance_;
  delete ResponseUnion_reflection_;
  delete Header::default_instance_;
  delete Header_reflection_;
  delete BatchRequest::default_instance_;
  delete BatchRequest_reflection_;
  delete BatchResponse::default_instance_;
  delete BatchResponse_reflection_;
  delete BatchResponse_Header::default_instance_;
  delete BatchResponse_Header_reflection_;
}

void protobuf_AddDesc_cockroach_2froachpb_2fapi_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  ::cockroach::roachpb::protobuf_AddDesc_cockroach_2froachpb_2fmetadata_2eproto();
  ::cockroach::roachpb::protobuf_AddDesc_cockroach_2froachpb_2fdata_2eproto();
  ::cockroach::roachpb::protobuf_AddDesc_cockroach_2froachpb_2ferrors_2eproto();
  ::cockroach::util::tracing::protobuf_AddDesc_cockroach_2futil_2ftracing_2fspan_2eproto();
  ::gogoproto::protobuf_AddDesc_gogoproto_2fgogo_2eproto();
  ::google::protobuf::DescriptorPool::InternalAddGeneratedFile(
    "\n\033cockroach/roachpb/api.proto\022\021cockroach"
    ".roachpb\032 cockroach/roachpb/metadata.pro"
    "to\032\034cockroach/roachpb/data.proto\032\036cockro"
    "ach/roachpb/errors.proto\032!cockroach/util"
    "/tracing/span.proto\032\024gogoproto/gogo.prot"
    "o\"t\n\016ResponseHeader\0225\n\ttimestamp\030\002 \001(\0132\034"
    ".cockroach.roachpb.TimestampB\004\310\336\037\000\022+\n\003tx"
    "n\030\003 \001(\0132\036.cockroach.roachpb.Transaction\""
    "\?\n\nGetRequest\0221\n\006header\030\001 \001(\0132\027.cockroac"
    "h.roachpb.SpanB\010\310\336\037\000\320\336\037\001\"s\n\013GetResponse\022"
    ";\n\006header\030\001 \001(\0132!.cockroach.roachpb.Resp"
    "onseHeaderB\010\310\336\037\000\320\336\037\001\022\'\n\005value\030\002 \001(\0132\030.co"
    "ckroach.roachpb.Value\"n\n\nPutRequest\0221\n\006h"
    "eader\030\001 \001(\0132\027.cockroach.roachpb.SpanB\010\310\336"
    "\037\000\320\336\037\001\022-\n\005value\030\002 \001(\0132\030.cockroach.roachp"
    "b.ValueB\004\310\336\037\000\"J\n\013PutResponse\022;\n\006header\030\001"
    " \001(\0132!.cockroach.roachpb.ResponseHeaderB"
    "\010\310\336\037\000\320\336\037\001\"\246\001\n\025ConditionalPutRequest\0221\n\006h"
    "eader\030\001 \001(\0132\027.cockroach.roachpb.SpanB\010\310\336"
    "\037\000\320\336\037\001\022-\n\005value\030\002 \001(\0132\030.cockroach.roachp"
    "b.ValueB\004\310\336\037\000\022+\n\texp_value\030\003 \001(\0132\030.cockr"
    "oach.roachpb.Value\"U\n\026ConditionalPutResp"
    "onse\022;\n\006header\030\001 \001(\0132!.cockroach.roachpb"
    ".ResponseHeaderB\010\310\336\037\000\320\336\037\001\"^\n\020IncrementRe"
    "quest\0221\n\006header\030\001 \001(\0132\027.cockroach.roachp"
    "b.SpanB\010\310\336\037\000\320\336\037\001\022\027\n\tincrement\030\002 \001(\003B\004\310\336\037"
    "\000\"i\n\021IncrementResponse\022;\n\006header\030\001 \001(\0132!"
    ".cockroach.roachpb.ResponseHeaderB\010\310\336\037\000\320"
    "\336\037\001\022\027\n\tnew_value\030\002 \001(\003B\004\310\336\037\000\"B\n\rDeleteRe"
    "quest\0221\n\006header\030\001 \001(\0132\027.cockroach.roachp"
    "b.SpanB\010\310\336\037\000\320\336\037\001\"M\n\016DeleteResponse\022;\n\006he"
    "ader\030\001 \001(\0132!.cockroach.roachpb.ResponseH"
    "eaderB\010\310\336\037\000\320\336\037\001\"\207\001\n\022DeleteRangeRequest\0221"
    "\n\006header\030\001 \001(\0132\027.cockroach.roachpb.SpanB"
    "\010\310\336\037\000\320\336\037\001\022#\n\025max_entries_to_delete\030\002 \001(\003"
    "B\004\310\336\037\000\022\031\n\013return_keys\030\003 \001(\010B\004\310\336\037\000\"i\n\023Del"
    "eteRangeResponse\022;\n\006header\030\001 \001(\0132!.cockr"
    "oach.roachpb.ResponseHeaderB\010\310\336\037\000\320\336\037\001\022\025\n"
    "\004keys\030\002 \003(\014B\007\372\336\037\003Key\"[\n\013ScanRequest\0221\n\006h"
    "eader\030\001 \001(\0132\027.cockroach.roachpb.SpanB\010\310\336"
    "\037\000\320\336\037\001\022\031\n\013max_results\030\002 \001(\003B\004\310\336\037\000\"|\n\014Sca"
    "nResponse\022;\n\006header\030\001 \001(\0132!.cockroach.ro"
    "achpb.ResponseHeaderB\010\310\336\037\000\320\336\037\001\022/\n\004rows\030\002"
    " \003(\0132\033.cockroach.roachpb.KeyValueB\004\310\336\037\000\""
    "b\n\022ReverseScanRequest\0221\n\006header\030\001 \001(\0132\027."
    "cockroach.roachpb.SpanB\010\310\336\037\000\320\336\037\001\022\031\n\013max_"
    "results\030\002 \001(\003B\004\310\336\037\000\"\203\001\n\023ReverseScanRespo"
    "nse\022;\n\006header\030\001 \001(\0132!.cockroach.roachpb."
    "ResponseHeaderB\010\310\336\037\000\320\336\037\001\022/\n\004rows\030\002 \003(\0132\033"
    ".cockroach.roachpb.KeyValueB\004\310\336\037\000\"L\n\027Che"
    "ckConsistencyRequest\0221\n\006header\030\001 \001(\0132\027.c"
    "ockroach.roachpb.SpanB\010\310\336\037\000\320\336\037\001\"W\n\030Check"
    "ConsistencyResponse\022;\n\006header\030\001 \001(\0132!.co"
    "ckroach.roachpb.ResponseHeaderB\010\310\336\037\000\320\336\037\001"
    "\"h\n\027BeginTransactionRequest\0221\n\006header\030\001 "
    "\001(\0132\027.cockroach.roachpb.SpanB\010\310\336\037\000\320\336\037\001\022\032"
    "\n\022heartbeat_interval\030\002 \001(\003\"W\n\030BeginTrans"
    "actionResponse\022;\n\006header\030\001 \001(\0132!.cockroa"
    "ch.roachpb.ResponseHeaderB\010\310\336\037\000\320\336\037\001\"\220\002\n\025"
    "EndTransactionRequest\0221\n\006header\030\001 \001(\0132\027."
    "cockroach.roachpb.SpanB\010\310\336\037\000\320\336\037\001\022\024\n\006comm"
    "it\030\002 \001(\010B\004\310\336\037\000\022.\n\010deadline\030\003 \001(\0132\034.cockr"
    "oach.roachpb.Timestamp\022I\n\027internal_commi"
    "t_trigger\030\004 \001(\0132(.cockroach.roachpb.Inte"
    "rnalCommitTrigger\0223\n\014intent_spans\030\005 \003(\0132"
    "\027.cockroach.roachpb.SpanB\004\310\336\037\000\"\213\001\n\026EndTr"
    "ansactionResponse\022;\n\006header\030\001 \001(\0132!.cock"
    "roach.roachpb.ResponseHeaderB\010\310\336\037\000\320\336\037\001\022\031"
    "\n\013commit_wait\030\002 \001(\003B\004\310\336\037\000\022\031\n\010resolved\030\003 "
    "\003(\014B\007\372\336\037\003Key\"b\n\021AdminSplitRequest\0221\n\006hea"
    "der\030\001 \001(\0132\027.cockroach.roachpb.SpanB\010\310\336\037\000"
    "\320\336\037\001\022\032\n\tsplit_key\030\002 \001(\014B\007\372\336\037\003Key\"Q\n\022Admi"
    "nSplitResponse\022;\n\006header\030\001 \001(\0132!.cockroa"
    "ch.roachpb.ResponseHeaderB\010\310\336\037\000\320\336\037\001\"F\n\021A"
    "dminMergeRequest\0221\n\006header\030\001 \001(\0132\027.cockr"
    "oach.roachpb.SpanB\010\310\336\037\000\320\336\037\001\"Q\n\022AdminMerg"
    "eResponse\022;\n\006header\030\001 \001(\0132!.cockroach.ro"
    "achpb.ResponseHeaderB\010\310\336\037\000\320\336\037\001\"\230\001\n\022Range"
    "LookupRequest\0221\n\006header\030\001 \001(\0132\027.cockroac"
    "h.roachpb.SpanB\010\310\336\037\000\320\336\037\001\022\030\n\nmax_ranges\030\002"
    " \001(\005B\004\310\336\037\000\022\036\n\020consider_intents\030\003 \001(\010B\004\310\336"
    "\037\000\022\025\n\007reverse\030\004 \001(\010B\004\310\336\037\000\"\214\001\n\023RangeLooku"
    "pResponse\022;\n\006header\030\001 \001(\0132!.cockroach.ro"
    "achpb.ResponseHeaderB\010\310\336\037\000\320\336\037\001\0228\n\006ranges"
    "\030\002 \003(\0132\".cockroach.roachpb.RangeDescript"
    "orB\004\310\336\037\000\"y\n\023HeartbeatTxnRequest\0221\n\006heade"
    "r\030\001 \001(\0132\027.cockroach.roachpb.SpanB\010\310\336\037\000\320\336"
    "\037\001\022/\n\003now\030\002 \001(\0132\034.cockroach.roachpb.Time"
    "stampB\004\310\336\037\000\"S\n\024HeartbeatTxnResponse\022;\n\006h"
    "eader\030\001 \001(\0132!.cockroach.roachpb.Response"
    "HeaderB\010\310\336\037\000\320\336\037\001\"\314\001\n\tGCRequest\0221\n\006header"
    "\030\001 \001(\0132\027.cockroach.roachpb.SpanB\010\310\336\037\000\320\336\037"
    "\001\0226\n\004keys\030\003 \003(\0132\".cockroach.roachpb.GCRe"
    "quest.GCKeyB\004\310\336\037\000\032T\n\005GCKey\022\024\n\003key\030\001 \001(\014B"
    "\007\372\336\037\003Key\0225\n\ttimestamp\030\002 \001(\0132\034.cockroach."
    "roachpb.TimestampB\004\310\336\037\000\"I\n\nGCResponse\022;\n"
    "\006header\030\001 \001(\0132!.cockroach.roachpb.Respon"
    "seHeaderB\010\310\336\037\000\320\336\037\001\"\322\002\n\016PushTxnRequest\0221\n"
    "\006header\030\001 \001(\0132\027.cockroach.roachpb.SpanB\010"
    "\310\336\037\000\320\336\037\001\0228\n\npusher_txn\030\002 \001(\0132\036.cockroach"
    ".roachpb.TransactionB\004\310\336\037\000\0224\n\npushee_txn"
    "\030\003 \001(\0132\032.cockroach.roachpb.TxnMetaB\004\310\336\037\000"
    "\0223\n\007push_to\030\004 \001(\0132\034.cockroach.roachpb.Ti"
    "mestampB\004\310\336\037\000\022/\n\003now\030\005 \001(\0132\034.cockroach.r"
    "oachpb.TimestampB\004\310\336\037\000\0227\n\tpush_type\030\006 \001("
    "\0162\036.cockroach.roachpb.PushTxnTypeB\004\310\336\037\000\""
    "\210\001\n\017PushTxnResponse\022;\n\006header\030\001 \001(\0132!.co"
    "ckroach.roachpb.ResponseHeaderB\010\310\336\037\000\320\336\037\001"
    "\0228\n\npushee_txn\030\002 \001(\0132\036.cockroach.roachpb"
    ".TransactionB\004\310\336\037\000\"\321\001\n\024ResolveIntentRequ"
    "est\0221\n\006header\030\001 \001(\0132\027.cockroach.roachpb."
    "SpanB\010\310\336\037\000\320\336\037\001\0224\n\nintent_txn\030\002 \001(\0132\032.coc"
    "kroach.roachpb.TxnMetaB\004\310\336\037\000\022:\n\006status\030\003"
    " \001(\0162$.cockroach.roachpb.TransactionStat"
    "usB\004\310\336\037\000\022\024\n\006poison\030\004 \001(\010B\004\310\336\037\000\"T\n\025Resolv"
    "eIntentResponse\022;\n\006header\030\001 \001(\0132!.cockro"
    "ach.roachpb.ResponseHeaderB\010\310\336\037\000\320\336\037\001\"\326\001\n"
    "\031ResolveIntentRangeRequest\0221\n\006header\030\001 \001"
    "(\0132\027.cockroach.roachpb.SpanB\010\310\336\037\000\320\336\037\001\0224\n"
    "\nintent_txn\030\002 \001(\0132\032.cockroach.roachpb.Tx"
    "nMetaB\004\310\336\037\000\022:\n\006status\030\003 \001(\0162$.cockroach."
    "roachpb.TransactionStatusB\004\310\336\037\000\022\024\n\006poiso"
    "n\030\004 \001(\010B\004\310\336\037\000\"K\n\014NoopResponse\022;\n\006header\030"
    "\001 \001(\0132!.cockroach.roachpb.ResponseHeader"
    "B\010\310\336\037\000\320\336\037\001\"@\n\013NoopRequest\0221\n\006header\030\001 \001("
    "\0132\027.cockroach.roachpb.SpanB\010\310\336\037\000\320\336\037\001\"Y\n\032"
    "ResolveIntentRangeResponse\022;\n\006header\030\001 \001"
    "(\0132!.cockroach.roachpb.ResponseHeaderB\010\310"
    "\336\037\000\320\336\037\001\"p\n\014MergeRequest\0221\n\006header\030\001 \001(\0132"
    "\027.cockroach.roachpb.SpanB\010\310\336\037\000\320\336\037\001\022-\n\005va"
    "lue\030\002 \001(\0132\030.cockroach.roachpb.ValueB\004\310\336\037"
    "\000\"L\n\rMergeResponse\022;\n\006header\030\001 \001(\0132!.coc"
    "kroach.roachpb.ResponseHeaderB\010\310\336\037\000\320\336\037\001\""
    "\212\001\n\022TruncateLogRequest\0221\n\006header\030\001 \001(\0132\027"
    ".cockroach.roachpb.SpanB\010\310\336\037\000\320\336\037\001\022\023\n\005ind"
    "ex\030\002 \001(\004B\004\310\336\037\000\022,\n\010range_id\030\003 \001(\003B\032\310\336\037\000\342\336"
    "\037\007RangeID\372\336\037\007RangeID\"R\n\023TruncateLogRespo"
    "nse\022;\n\006header\030\001 \001(\0132!.cockroach.roachpb."
    "ResponseHeaderB\010\310\336\037\000\320\336\037\001\"v\n\022LeaderLeaseR"
    "equest\0221\n\006header\030\001 \001(\0132\027.cockroach.roach"
    "pb.SpanB\010\310\336\037\000\320\336\037\001\022-\n\005lease\030\002 \001(\0132\030.cockr"
    "oach.roachpb.LeaseB\004\310\336\037\000\"R\n\023LeaderLeaseR"
    "esponse\022;\n\006header\030\001 \001(\0132!.cockroach.roac"
    "hpb.ResponseHeaderB\010\310\336\037\000\320\336\037\001\"\276\001\n\026Compute"
    "ChecksumRequest\0221\n\006header\030\001 \001(\0132\027.cockro"
    "ach.roachpb.SpanB\010\310\336\037\000\320\336\037\001\022\025\n\007version\030\002 "
    "\001(\rB\004\310\336\037\000\022Z\n\013checksum_id\030\003 \001(\014BE\310\336\037\000\342\336\037\n"
    "ChecksumID\332\336\037/github.com/cockroachdb/coc"
    "kroach/util/uuid.UUID\"V\n\027ComputeChecksum"
    "Response\022;\n\006header\030\001 \001(\0132!.cockroach.roa"
    "chpb.ResponseHeaderB\010\310\336\037\000\320\336\037\001\"\317\001\n\025Verify"
    "ChecksumRequest\0221\n\006header\030\001 \001(\0132\027.cockro"
    "ach.roachpb.SpanB\010\310\336\037\000\320\336\037\001\022\025\n\007version\030\002 "
    "\001(\rB\004\310\336\037\000\022Z\n\013checksum_id\030\003 \001(\014BE\310\336\037\000\342\336\037\n"
    "ChecksumID\332\336\037/github.com/cockroachdb/coc"
    "kroach/util/uuid.UUID\022\020\n\010checksum\030\004 \001(\014\""
    "U\n\026VerifyChecksumResponse\022;\n\006header\030\001 \001("
    "\0132!.cockroach.roachpb.ResponseHeaderB\010\310\336"
    "\037\000\320\336\037\001\"\320\013\n\014RequestUnion\022*\n\003get\030\001 \001(\0132\035.c"
    "ockroach.roachpb.GetRequest\022*\n\003put\030\002 \001(\013"
    "2\035.cockroach.roachpb.PutRequest\022A\n\017condi"
    "tional_put\030\003 \001(\0132(.cockroach.roachpb.Con"
    "ditionalPutRequest\0226\n\tincrement\030\004 \001(\0132#."
    "cockroach.roachpb.IncrementRequest\0220\n\006de"
    "lete\030\005 \001(\0132 .cockroach.roachpb.DeleteReq"
    "uest\022;\n\014delete_range\030\006 \001(\0132%.cockroach.r"
    "oachpb.DeleteRangeRequest\022,\n\004scan\030\007 \001(\0132"
    "\036.cockroach.roachpb.ScanRequest\022E\n\021begin"
    "_transaction\030\010 \001(\0132*.cockroach.roachpb.B"
    "eginTransactionRequest\022A\n\017end_transactio"
    "n\030\t \001(\0132(.cockroach.roachpb.EndTransacti"
    "onRequest\0229\n\013admin_split\030\n \001(\0132$.cockroa"
    "ch.roachpb.AdminSplitRequest\0229\n\013admin_me"
    "rge\030\013 \001(\0132$.cockroach.roachpb.AdminMerge"
    "Request\022=\n\rheartbeat_txn\030\014 \001(\0132&.cockroa"
    "ch.roachpb.HeartbeatTxnRequest\022(\n\002gc\030\r \001"
    "(\0132\034.cockroach.roachpb.GCRequest\0223\n\010push"
    "_txn\030\016 \001(\0132!.cockroach.roachpb.PushTxnRe"
    "quest\022;\n\014range_lookup\030\017 \001(\0132%.cockroach."
    "roachpb.RangeLookupRequest\022\?\n\016resolve_in"
    "tent\030\020 \001(\0132\'.cockroach.roachpb.ResolveIn"
    "tentRequest\022J\n\024resolve_intent_range\030\021 \001("
    "\0132,.cockroach.roachpb.ResolveIntentRange"
    "Request\022.\n\005merge\030\022 \001(\0132\037.cockroach.roach"
    "pb.MergeRequest\022;\n\014truncate_log\030\023 \001(\0132%."
    "cockroach.roachpb.TruncateLogRequest\022;\n\014"
    "leader_lease\030\024 \001(\0132%.cockroach.roachpb.L"
    "eaderLeaseRequest\022;\n\014reverse_scan\030\025 \001(\0132"
    "%.cockroach.roachpb.ReverseScanRequest\022C"
    "\n\020compute_checksum\030\026 \001(\0132).cockroach.roa"
    "chpb.ComputeChecksumRequest\022A\n\017verify_ch"
    "ecksum\030\027 \001(\0132(.cockroach.roachpb.VerifyC"
    "hecksumRequest\022E\n\021check_consistency\030\030 \001("
    "\0132*.cockroach.roachpb.CheckConsistencyRe"
    "quest\022,\n\004noop\030\031 \001(\0132\036.cockroach.roachpb."
    "NoopRequest:\004\310\240\037\001\"\352\013\n\rResponseUnion\022+\n\003g"
    "et\030\001 \001(\0132\036.cockroach.roachpb.GetResponse"
    "\022+\n\003put\030\002 \001(\0132\036.cockroach.roachpb.PutRes"
    "ponse\022B\n\017conditional_put\030\003 \001(\0132).cockroa"
    "ch.roachpb.ConditionalPutResponse\0227\n\tinc"
    "rement\030\004 \001(\0132$.cockroach.roachpb.Increme"
    "ntResponse\0221\n\006delete\030\005 \001(\0132!.cockroach.r"
    "oachpb.DeleteResponse\022<\n\014delete_range\030\006 "
    "\001(\0132&.cockroach.roachpb.DeleteRangeRespo"
    "nse\022-\n\004scan\030\007 \001(\0132\037.cockroach.roachpb.Sc"
    "anResponse\022F\n\021begin_transaction\030\010 \001(\0132+."
    "cockroach.roachpb.BeginTransactionRespon"
    "se\022B\n\017end_transaction\030\t \001(\0132).cockroach."
    "roachpb.EndTransactionResponse\022:\n\013admin_"
    "split\030\n \001(\0132%.cockroach.roachpb.AdminSpl"
    "itResponse\022:\n\013admin_merge\030\013 \001(\0132%.cockro"
    "ach.roachpb.AdminMergeResponse\022>\n\rheartb"
    "eat_txn\030\014 \001(\0132\'.cockroach.roachpb.Heartb"
    "eatTxnResponse\022)\n\002gc\030\r \001(\0132\035.cockroach.r"
    "oachpb.GCResponse\0224\n\010push_txn\030\016 \001(\0132\".co"
    "ckroach.roachpb.PushTxnResponse\022<\n\014range"
    "_lookup\030\017 \001(\0132&.cockroach.roachpb.RangeL"
    "ookupResponse\022@\n\016resolve_intent\030\020 \001(\0132(."
    "cockroach.roachpb.ResolveIntentResponse\022"
    "K\n\024resolve_intent_range\030\021 \001(\0132-.cockroac"
    "h.roachpb.ResolveIntentRangeResponse\022/\n\005"
    "merge\030\022 \001(\0132 .cockroach.roachpb.MergeRes"
    "ponse\022<\n\014truncate_log\030\023 \001(\0132&.cockroach."
    "roachpb.TruncateLogResponse\022<\n\014leader_le"
    "ase\030\024 \001(\0132&.cockroach.roachpb.LeaderLeas"
    "eResponse\022<\n\014reverse_scan\030\025 \001(\0132&.cockro"
    "ach.roachpb.ReverseScanResponse\022D\n\020compu"
    "te_checksum\030\026 \001(\0132*.cockroach.roachpb.Co"
    "mputeChecksumResponse\022B\n\017verify_checksum"
    "\030\027 \001(\0132).cockroach.roachpb.VerifyChecksu"
    "mResponse\022F\n\021check_consistency\030\030 \001(\0132+.c"
    "ockroach.roachpb.CheckConsistencyRespons"
    "e\022-\n\004noop\030\031 \001(\0132\037.cockroach.roachpb.Noop"
    "Response:\004\310\240\037\001\"\265\003\n\006Header\0225\n\ttimestamp\030\001"
    " \001(\0132\034.cockroach.roachpb.TimestampB\004\310\336\037\000"
    "\022;\n\007replica\030\002 \001(\0132$.cockroach.roachpb.Re"
    "plicaDescriptorB\004\310\336\037\000\022,\n\010range_id\030\003 \001(\003B"
    "\032\310\336\037\000\342\336\037\007RangeID\372\336\037\007RangeID\022+\n\ruser_prio"
    "rity\030\004 \001(\001B\024\310\336\037\000\372\336\037\014UserPriority\022+\n\003txn\030"
    "\005 \001(\0132\036.cockroach.roachpb.Transaction\022\032\n"
    "\022heartbeat_interval\030\t \001(\003\022F\n\020read_consis"
    "tency\030\006 \001(\0162&.cockroach.roachpb.ReadCons"
    "istencyTypeB\004\310\336\037\000\022+\n\005trace\030\007 \001(\0132\034.cockr"
    "oach.util.tracing.Span\022\036\n\020max_scan_resul"
    "ts\030\010 \001(\003B\004\310\336\037\000\"\202\001\n\014BatchRequest\0223\n\006heade"
    "r\030\001 \001(\0132\031.cockroach.roachpb.HeaderB\010\310\336\037\000"
    "\320\336\037\001\0227\n\010requests\030\002 \003(\0132\037.cockroach.roach"
    "pb.RequestUnionB\004\310\336\037\000:\004\230\240\037\000\"\214\002\n\rBatchRes"
    "ponse\022A\n\006header\030\001 \001(\0132\'.cockroach.roachp"
    "b.BatchResponse.HeaderB\010\310\336\037\000\320\336\037\001\0229\n\tresp"
    "onses\030\002 \003(\0132 .cockroach.roachpb.Response"
    "UnionB\004\310\336\037\000\032w\n\006Header\022\'\n\005error\030\001 \001(\0132\030.c"
    "ockroach.roachpb.Error\022+\n\003txn\030\003 \001(\0132\036.co"
    "ckroach.roachpb.Transaction\022\027\n\017collected"
    "_spans\030\004 \003(\014:\004\230\240\037\000*L\n\023ReadConsistencyTyp"
    "e\022\016\n\nCONSISTENT\020\000\022\r\n\tCONSENSUS\020\001\022\020\n\014INCO"
    "NSISTENT\020\002\032\004\210\243\036\000*G\n\013PushTxnType\022\022\n\016PUSH_"
    "TIMESTAMP\020\000\022\016\n\nPUSH_ABORT\020\001\022\016\n\nPUSH_TOUC"
    "H\020\002\032\004\210\243\036\0002X\n\010Internal\022L\n\005Batch\022\037.cockroa"
    "ch.roachpb.BatchRequest\032 .cockroach.roac"
    "hpb.BatchResponse\"\0002X\n\010External\022L\n\005Batch"
    "\022\037.cockroach.roachpb.BatchRequest\032 .cock"
    "roach.roachpb.BatchResponse\"\000B\tZ\007roachpb"
    "X\004", 10522);
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedFile(
    "cockroach/roachpb/api.proto", &protobuf_RegisterTypes);
  ResponseHeader::default_instance_ = new ResponseHeader();
  GetRequest::default_instance_ = new GetRequest();
  GetResponse::default_instance_ = new GetResponse();
  PutRequest::default_instance_ = new PutRequest();
  PutResponse::default_instance_ = new PutResponse();
  ConditionalPutRequest::default_instance_ = new ConditionalPutRequest();
  ConditionalPutResponse::default_instance_ = new ConditionalPutResponse();
  IncrementRequest::default_instance_ = new IncrementRequest();
  IncrementResponse::default_instance_ = new IncrementResponse();
  DeleteRequest::default_instance_ = new DeleteRequest();
  DeleteResponse::default_instance_ = new DeleteResponse();
  DeleteRangeRequest::default_instance_ = new DeleteRangeRequest();
  DeleteRangeResponse::default_instance_ = new DeleteRangeResponse();
  ScanRequest::default_instance_ = new ScanRequest();
  ScanResponse::default_instance_ = new ScanResponse();
  ReverseScanRequest::default_instance_ = new ReverseScanRequest();
  ReverseScanResponse::default_instance_ = new ReverseScanResponse();
  CheckConsistencyRequest::default_instance_ = new CheckConsistencyRequest();
  CheckConsistencyResponse::default_instance_ = new CheckConsistencyResponse();
  BeginTransactionRequest::default_instance_ = new BeginTransactionRequest();
  BeginTransactionResponse::default_instance_ = new BeginTransactionResponse();
  EndTransactionRequest::default_instance_ = new EndTransactionRequest();
  EndTransactionResponse::default_instance_ = new EndTransactionResponse();
  AdminSplitRequest::default_instance_ = new AdminSplitRequest();
  AdminSplitResponse::default_instance_ = new AdminSplitResponse();
  AdminMergeRequest::default_instance_ = new AdminMergeRequest();
  AdminMergeResponse::default_instance_ = new AdminMergeResponse();
  RangeLookupRequest::default_instance_ = new RangeLookupRequest();
  RangeLookupResponse::default_instance_ = new RangeLookupResponse();
  HeartbeatTxnRequest::default_instance_ = new HeartbeatTxnRequest();
  HeartbeatTxnResponse::default_instance_ = new HeartbeatTxnResponse();
  GCRequest::default_instance_ = new GCRequest();
  GCRequest_GCKey::default_instance_ = new GCRequest_GCKey();
  GCResponse::default_instance_ = new GCResponse();
  PushTxnRequest::default_instance_ = new PushTxnRequest();
  PushTxnResponse::default_instance_ = new PushTxnResponse();
  ResolveIntentRequest::default_instance_ = new ResolveIntentRequest();
  ResolveIntentResponse::default_instance_ = new ResolveIntentResponse();
  ResolveIntentRangeRequest::default_instance_ = new ResolveIntentRangeRequest();
  NoopResponse::default_instance_ = new NoopResponse();
  NoopRequest::default_instance_ = new NoopRequest();
  ResolveIntentRangeResponse::default_instance_ = new ResolveIntentRangeResponse();
  MergeRequest::default_instance_ = new MergeRequest();
  MergeResponse::default_instance_ = new MergeResponse();
  TruncateLogRequest::default_instance_ = new TruncateLogRequest();
  TruncateLogResponse::default_instance_ = new TruncateLogResponse();
  LeaderLeaseRequest::default_instance_ = new LeaderLeaseRequest();
  LeaderLeaseResponse::default_instance_ = new LeaderLeaseResponse();
  ComputeChecksumRequest::default_instance_ = new ComputeChecksumRequest();
  ComputeChecksumResponse::default_instance_ = new ComputeChecksumResponse();
  VerifyChecksumRequest::default_instance_ = new VerifyChecksumRequest();
  VerifyChecksumResponse::default_instance_ = new VerifyChecksumResponse();
  RequestUnion::default_instance_ = new RequestUnion();
  ResponseUnion::default_instance_ = new ResponseUnion();
  Header::default_instance_ = new Header();
  BatchRequest::default_instance_ = new BatchRequest();
  BatchResponse::default_instance_ = new BatchResponse();
  BatchResponse_Header::default_instance_ = new BatchResponse_Header();
  ResponseHeader::default_instance_->InitAsDefaultInstance();
  GetRequest::default_instance_->InitAsDefaultInstance();
  GetResponse::default_instance_->InitAsDefaultInstance();
  PutRequest::default_instance_->InitAsDefaultInstance();
  PutResponse::default_instance_->InitAsDefaultInstance();
  ConditionalPutRequest::default_instance_->InitAsDefaultInstance();
  ConditionalPutResponse::default_instance_->InitAsDefaultInstance();
  IncrementRequest::default_instance_->InitAsDefaultInstance();
  IncrementResponse::default_instance_->InitAsDefaultInstance();
  DeleteRequest::default_instance_->InitAsDefaultInstance();
  DeleteResponse::default_instance_->InitAsDefaultInstance();
  DeleteRangeRequest::default_instance_->InitAsDefaultInstance();
  DeleteRangeResponse::default_instance_->InitAsDefaultInstance();
  ScanRequest::default_instance_->InitAsDefaultInstance();
  ScanResponse::default_instance_->InitAsDefaultInstance();
  ReverseScanRequest::default_instance_->InitAsDefaultInstance();
  ReverseScanResponse::default_instance_->InitAsDefaultInstance();
  CheckConsistencyRequest::default_instance_->InitAsDefaultInstance();
  CheckConsistencyResponse::default_instance_->InitAsDefaultInstance();
  BeginTransactionRequest::default_instance_->InitAsDefaultInstance();
  BeginTransactionResponse::default_instance_->InitAsDefaultInstance();
  EndTransactionRequest::default_instance_->InitAsDefaultInstance();
  EndTransactionResponse::default_instance_->InitAsDefaultInstance();
  AdminSplitRequest::default_instance_->InitAsDefaultInstance();
  AdminSplitResponse::default_instance_->InitAsDefaultInstance();
  AdminMergeRequest::default_instance_->InitAsDefaultInstance();
  AdminMergeResponse::default_instance_->InitAsDefaultInstance();
  RangeLookupRequest::default_instance_->InitAsDefaultInstance();
  RangeLookupResponse::default_instance_->InitAsDefaultInstance();
  HeartbeatTxnRequest::default_instance_->InitAsDefaultInstance();
  HeartbeatTxnResponse::default_instance_->InitAsDefaultInstance();
  GCRequest::default_instance_->InitAsDefaultInstance();
  GCRequest_GCKey::default_instance_->InitAsDefaultInstance();
  GCResponse::default_instance_->InitAsDefaultInstance();
  PushTxnRequest::default_instance_->InitAsDefaultInstance();
  PushTxnResponse::default_instance_->InitAsDefaultInstance();
  ResolveIntentRequest::default_instance_->InitAsDefaultInstance();
  ResolveIntentResponse::default_instance_->InitAsDefaultInstance();
  ResolveIntentRangeRequest::default_instance_->InitAsDefaultInstance();
  NoopResponse::default_instance_->InitAsDefaultInstance();
  NoopRequest::default_instance_->InitAsDefaultInstance();
  ResolveIntentRangeResponse::default_instance_->InitAsDefaultInstance();
  MergeRequest::default_instance_->InitAsDefaultInstance();
  MergeResponse::default_instance_->InitAsDefaultInstance();
  TruncateLogRequest::default_instance_->InitAsDefaultInstance();
  TruncateLogResponse::default_instance_->InitAsDefaultInstance();
  LeaderLeaseRequest::default_instance_->InitAsDefaultInstance();
  LeaderLeaseResponse::default_instance_->InitAsDefaultInstance();
  ComputeChecksumRequest::default_instance_->InitAsDefaultInstance();
  ComputeChecksumResponse::default_instance_->InitAsDefaultInstance();
  VerifyChecksumRequest::default_instance_->InitAsDefaultInstance();
  VerifyChecksumResponse::default_instance_->InitAsDefaultInstance();
  RequestUnion::default_instance_->InitAsDefaultInstance();
  ResponseUnion::default_instance_->InitAsDefaultInstance();
  Header::default_instance_->InitAsDefaultInstance();
  BatchRequest::default_instance_->InitAsDefaultInstance();
  BatchResponse::default_instance_->InitAsDefaultInstance();
  BatchResponse_Header::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_cockroach_2froachpb_2fapi_2eproto);
}

// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_cockroach_2froachpb_2fapi_2eproto {
  StaticDescriptorInitializer_cockroach_2froachpb_2fapi_2eproto() {
    protobuf_AddDesc_cockroach_2froachpb_2fapi_2eproto();
  }
} static_descriptor_initializer_cockroach_2froachpb_2fapi_2eproto_;
const ::google::protobuf::EnumDescriptor* ReadConsistencyType_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ReadConsistencyType_descriptor_;
}
bool ReadConsistencyType_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

const ::google::protobuf::EnumDescriptor* PushTxnType_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return PushTxnType_descriptor_;
}
bool PushTxnType_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}


namespace {

static void MergeFromFail(int line) GOOGLE_ATTRIBUTE_COLD;
static void MergeFromFail(int line) {
  GOOGLE_CHECK(false) << __FILE__ << ":" << line;
}

}  // namespace


// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int ResponseHeader::kTimestampFieldNumber;
const int ResponseHeader::kTxnFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

ResponseHeader::ResponseHeader()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:cockroach.roachpb.ResponseHeader)
}

void ResponseHeader::InitAsDefaultInstance() {
  timestamp_ = const_cast< ::cockroach::roachpb::Timestamp*>(&::cockroach::roachpb::Timestamp::default_instance());
  txn_ = const_cast< ::cockroach::roachpb::Transaction*>(&::cockroach::roachpb::Transaction::default_instance());
}

ResponseHeader::ResponseHeader(const ResponseHeader& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:cockroach.roachpb.ResponseHeader)
}

void ResponseHeader::SharedCtor() {
  _cached_size_ = 0;
  timestamp_ = NULL;
  txn_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ResponseHeader::~ResponseHeader() {
  // @@protoc_insertion_point(destructor:cockroach.roachpb.ResponseHeader)
  SharedDtor();
}

void ResponseHeader::SharedDtor() {
  if (this != default_instance_) {
    delete timestamp_;
    delete txn_;
  }
}

void ResponseHeader::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ResponseHeader::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ResponseHeader_descriptor_;
}

const ResponseHeader& ResponseHeader::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_cockroach_2froachpb_2fapi_2eproto();
  return *default_instance_;
}

ResponseHeader* ResponseHeader::default_instance_ = NULL;

ResponseHeader* ResponseHeader::New(::google::protobuf::Arena* arena) const {
  ResponseHeader* n = new ResponseHeader;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void ResponseHeader::Clear() {
  if (_has_bits_[0 / 32] & 3u) {
    if (has_timestamp()) {
      if (timestamp_ != NULL) timestamp_->::cockroach::roachpb::Timestamp::Clear();
    }
    if (has_txn()) {
      if (txn_ != NULL) txn_->::cockroach::roachpb::Transaction::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool ResponseHeader::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:cockroach.roachpb.ResponseHeader)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .cockroach.roachpb.Timestamp timestamp = 2;
      case 2: {
        if (tag == 18) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_timestamp()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_txn;
        break;
      }

      // optional .cockroach.roachpb.Transaction txn = 3;
      case 3: {
        if (tag == 26) {
         parse_txn:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_txn()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:cockroach.roachpb.ResponseHeader)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:cockroach.roachpb.ResponseHeader)
  return false;
#undef DO_
}

void ResponseHeader::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:cockroach.roachpb.ResponseHeader)
  // optional .cockroach.roachpb.Timestamp timestamp = 2;
  if (has_timestamp()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, *this->timestamp_, output);
  }

  // optional .cockroach.roachpb.Transaction txn = 3;
  if (has_txn()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, *this->txn_, output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:cockroach.roachpb.ResponseHeader)
}

::google::protobuf::uint8* ResponseHeader::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:cockroach.roachpb.ResponseHeader)
  // optional .cockroach.roachpb.Timestamp timestamp = 2;
  if (has_timestamp()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, *this->timestamp_, target);
  }

  // optional .cockroach.roachpb.Transaction txn = 3;
  if (has_txn()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, *this->txn_, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:cockroach.roachpb.ResponseHeader)
  return target;
}

int ResponseHeader::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & 3u) {
    // optional .cockroach.roachpb.Timestamp timestamp = 2;
    if (has_timestamp()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->timestamp_);
    }

    // optional .cockroach.roachpb.Transaction txn = 3;
    if (has_txn()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->txn_);
    }

  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ResponseHeader::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const ResponseHeader* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const ResponseHeader>(
          &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ResponseHeader::MergeFrom(const ResponseHeader& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_timestamp()) {
      mutable_timestamp()->::cockroach::roachpb::Timestamp::MergeFrom(from.timestamp());
    }
    if (from.has_txn()) {
      mutable_txn()->::cockroach::roachpb::Transaction::MergeFrom(from.txn());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void ResponseHeader::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ResponseHeader::CopyFrom(const ResponseHeader& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ResponseHeader::IsInitialized() const {

  return true;
}

void ResponseHeader::Swap(ResponseHeader* other) {
  if (other == this) return;
  InternalSwap(other);
}
void ResponseHeader::InternalSwap(ResponseHeader* other) {
  std::swap(timestamp_, other->timestamp_);
  std::swap(txn_, other->txn_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata ResponseHeader::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ResponseHeader_descriptor_;
  metadata.reflection = ResponseHeader_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// ResponseHeader

// optional .cockroach.roachpb.Timestamp timestamp = 2;
bool ResponseHeader::has_timestamp() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void ResponseHeader::set_has_timestamp() {
  _has_bits_[0] |= 0x00000001u;
}
void ResponseHeader::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000001u;
}
void ResponseHeader::clear_timestamp() {
  if (timestamp_ != NULL) timestamp_->::cockroach::roachpb::Timestamp::Clear();
  clear_has_timestamp();
}
const ::cockroach::roachpb::Timestamp& ResponseHeader::timestamp() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.ResponseHeader.timestamp)
  return timestamp_ != NULL ? *timestamp_ : *default_instance_->timestamp_;
}
::cockroach::roachpb::Timestamp* ResponseHeader::mutable_timestamp() {
  set_has_timestamp();
  if (timestamp_ == NULL) {
    timestamp_ = new ::cockroach::roachpb::Timestamp;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.ResponseHeader.timestamp)
  return timestamp_;
}
::cockroach::roachpb::Timestamp* ResponseHeader::release_timestamp() {
  clear_has_timestamp();
  ::cockroach::roachpb::Timestamp* temp = timestamp_;
  timestamp_ = NULL;
  return temp;
}
void ResponseHeader::set_allocated_timestamp(::cockroach::roachpb::Timestamp* timestamp) {
  delete timestamp_;
  timestamp_ = timestamp;
  if (timestamp) {
    set_has_timestamp();
  } else {
    clear_has_timestamp();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.ResponseHeader.timestamp)
}

// optional .cockroach.roachpb.Transaction txn = 3;
bool ResponseHeader::has_txn() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void ResponseHeader::set_has_txn() {
  _has_bits_[0] |= 0x00000002u;
}
void ResponseHeader::clear_has_txn() {
  _has_bits_[0] &= ~0x00000002u;
}
void ResponseHeader::clear_txn() {
  if (txn_ != NULL) txn_->::cockroach::roachpb::Transaction::Clear();
  clear_has_txn();
}
const ::cockroach::roachpb::Transaction& ResponseHeader::txn() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.ResponseHeader.txn)
  return txn_ != NULL ? *txn_ : *default_instance_->txn_;
}
::cockroach::roachpb::Transaction* ResponseHeader::mutable_txn() {
  set_has_txn();
  if (txn_ == NULL) {
    txn_ = new ::cockroach::roachpb::Transaction;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.ResponseHeader.txn)
  return txn_;
}
::cockroach::roachpb::Transaction* ResponseHeader::release_txn() {
  clear_has_txn();
  ::cockroach::roachpb::Transaction* temp = txn_;
  txn_ = NULL;
  return temp;
}
void ResponseHeader::set_allocated_txn(::cockroach::roachpb::Transaction* txn) {
  delete txn_;
  txn_ = txn;
  if (txn) {
    set_has_txn();
  } else {
    clear_has_txn();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.ResponseHeader.txn)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int GetRequest::kHeaderFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

GetRequest::GetRequest()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:cockroach.roachpb.GetRequest)
}

void GetRequest::InitAsDefaultInstance() {
  header_ = const_cast< ::cockroach::roachpb::Span*>(&::cockroach::roachpb::Span::default_instance());
}

GetRequest::GetRequest(const GetRequest& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:cockroach.roachpb.GetRequest)
}

void GetRequest::SharedCtor() {
  _cached_size_ = 0;
  header_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GetRequest::~GetRequest() {
  // @@protoc_insertion_point(destructor:cockroach.roachpb.GetRequest)
  SharedDtor();
}

void GetRequest::SharedDtor() {
  if (this != default_instance_) {
    delete header_;
  }
}

void GetRequest::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* GetRequest::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return GetRequest_descriptor_;
}

const GetRequest& GetRequest::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_cockroach_2froachpb_2fapi_2eproto();
  return *default_instance_;
}

GetRequest* GetRequest::default_instance_ = NULL;

GetRequest* GetRequest::New(::google::protobuf::Arena* arena) const {
  GetRequest* n = new GetRequest;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void GetRequest::Clear() {
  if (has_header()) {
    if (header_ != NULL) header_->::cockroach::roachpb::Span::Clear();
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool GetRequest::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:cockroach.roachpb.GetRequest)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .cockroach.roachpb.Span header = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_header()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:cockroach.roachpb.GetRequest)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:cockroach.roachpb.GetRequest)
  return false;
#undef DO_
}

void GetRequest::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:cockroach.roachpb.GetRequest)
  // optional .cockroach.roachpb.Span header = 1;
  if (has_header()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->header_, output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:cockroach.roachpb.GetRequest)
}

::google::protobuf::uint8* GetRequest::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:cockroach.roachpb.GetRequest)
  // optional .cockroach.roachpb.Span header = 1;
  if (has_header()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, *this->header_, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:cockroach.roachpb.GetRequest)
  return target;
}

int GetRequest::ByteSize() const {
  int total_size = 0;

  // optional .cockroach.roachpb.Span header = 1;
  if (has_header()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->header_);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GetRequest::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const GetRequest* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const GetRequest>(
          &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void GetRequest::MergeFrom(const GetRequest& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_header()) {
      mutable_header()->::cockroach::roachpb::Span::MergeFrom(from.header());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void GetRequest::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void GetRequest::CopyFrom(const GetRequest& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GetRequest::IsInitialized() const {

  return true;
}

void GetRequest::Swap(GetRequest* other) {
  if (other == this) return;
  InternalSwap(other);
}
void GetRequest::InternalSwap(GetRequest* other) {
  std::swap(header_, other->header_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata GetRequest::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = GetRequest_descriptor_;
  metadata.reflection = GetRequest_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// GetRequest

// optional .cockroach.roachpb.Span header = 1;
bool GetRequest::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void GetRequest::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
void GetRequest::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
void GetRequest::clear_header() {
  if (header_ != NULL) header_->::cockroach::roachpb::Span::Clear();
  clear_has_header();
}
const ::cockroach::roachpb::Span& GetRequest::header() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.GetRequest.header)
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
::cockroach::roachpb::Span* GetRequest::mutable_header() {
  set_has_header();
  if (header_ == NULL) {
    header_ = new ::cockroach::roachpb::Span;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.GetRequest.header)
  return header_;
}
::cockroach::roachpb::Span* GetRequest::release_header() {
  clear_has_header();
  ::cockroach::roachpb::Span* temp = header_;
  header_ = NULL;
  return temp;
}
void GetRequest::set_allocated_header(::cockroach::roachpb::Span* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.GetRequest.header)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int GetResponse::kHeaderFieldNumber;
const int GetResponse::kValueFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

GetResponse::GetResponse()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:cockroach.roachpb.GetResponse)
}

void GetResponse::InitAsDefaultInstance() {
  header_ = const_cast< ::cockroach::roachpb::ResponseHeader*>(&::cockroach::roachpb::ResponseHeader::default_instance());
  value_ = const_cast< ::cockroach::roachpb::Value*>(&::cockroach::roachpb::Value::default_instance());
}

GetResponse::GetResponse(const GetResponse& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:cockroach.roachpb.GetResponse)
}

void GetResponse::SharedCtor() {
  _cached_size_ = 0;
  header_ = NULL;
  value_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GetResponse::~GetResponse() {
  // @@protoc_insertion_point(destructor:cockroach.roachpb.GetResponse)
  SharedDtor();
}

void GetResponse::SharedDtor() {
  if (this != default_instance_) {
    delete header_;
    delete value_;
  }
}

void GetResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* GetResponse::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return GetResponse_descriptor_;
}

const GetResponse& GetResponse::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_cockroach_2froachpb_2fapi_2eproto();
  return *default_instance_;
}

GetResponse* GetResponse::default_instance_ = NULL;

GetResponse* GetResponse::New(::google::protobuf::Arena* arena) const {
  GetResponse* n = new GetResponse;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void GetResponse::Clear() {
  if (_has_bits_[0 / 32] & 3u) {
    if (has_header()) {
      if (header_ != NULL) header_->::cockroach::roachpb::ResponseHeader::Clear();
    }
    if (has_value()) {
      if (value_ != NULL) value_->::cockroach::roachpb::Value::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool GetResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:cockroach.roachpb.GetResponse)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .cockroach.roachpb.ResponseHeader header = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_header()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_value;
        break;
      }

      // optional .cockroach.roachpb.Value value = 2;
      case 2: {
        if (tag == 18) {
         parse_value:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_value()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:cockroach.roachpb.GetResponse)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:cockroach.roachpb.GetResponse)
  return false;
#undef DO_
}

void GetResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:cockroach.roachpb.GetResponse)
  // optional .cockroach.roachpb.ResponseHeader header = 1;
  if (has_header()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->header_, output);
  }

  // optional .cockroach.roachpb.Value value = 2;
  if (has_value()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, *this->value_, output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:cockroach.roachpb.GetResponse)
}

::google::protobuf::uint8* GetResponse::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:cockroach.roachpb.GetResponse)
  // optional .cockroach.roachpb.ResponseHeader header = 1;
  if (has_header()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, *this->header_, target);
  }

  // optional .cockroach.roachpb.Value value = 2;
  if (has_value()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, *this->value_, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:cockroach.roachpb.GetResponse)
  return target;
}

int GetResponse::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & 3u) {
    // optional .cockroach.roachpb.ResponseHeader header = 1;
    if (has_header()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->header_);
    }

    // optional .cockroach.roachpb.Value value = 2;
    if (has_value()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->value_);
    }

  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GetResponse::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const GetResponse* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const GetResponse>(
          &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void GetResponse::MergeFrom(const GetResponse& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_header()) {
      mutable_header()->::cockroach::roachpb::ResponseHeader::MergeFrom(from.header());
    }
    if (from.has_value()) {
      mutable_value()->::cockroach::roachpb::Value::MergeFrom(from.value());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void GetResponse::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void GetResponse::CopyFrom(const GetResponse& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GetResponse::IsInitialized() const {

  return true;
}

void GetResponse::Swap(GetResponse* other) {
  if (other == this) return;
  InternalSwap(other);
}
void GetResponse::InternalSwap(GetResponse* other) {
  std::swap(header_, other->header_);
  std::swap(value_, other->value_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata GetResponse::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = GetResponse_descriptor_;
  metadata.reflection = GetResponse_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// GetResponse

// optional .cockroach.roachpb.ResponseHeader header = 1;
bool GetResponse::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void GetResponse::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
void GetResponse::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
void GetResponse::clear_header() {
  if (header_ != NULL) header_->::cockroach::roachpb::ResponseHeader::Clear();
  clear_has_header();
}
const ::cockroach::roachpb::ResponseHeader& GetResponse::header() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.GetResponse.header)
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
::cockroach::roachpb::ResponseHeader* GetResponse::mutable_header() {
  set_has_header();
  if (header_ == NULL) {
    header_ = new ::cockroach::roachpb::ResponseHeader;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.GetResponse.header)
  return header_;
}
::cockroach::roachpb::ResponseHeader* GetResponse::release_header() {
  clear_has_header();
  ::cockroach::roachpb::ResponseHeader* temp = header_;
  header_ = NULL;
  return temp;
}
void GetResponse::set_allocated_header(::cockroach::roachpb::ResponseHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.GetResponse.header)
}

// optional .cockroach.roachpb.Value value = 2;
bool GetResponse::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void GetResponse::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
void GetResponse::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
void GetResponse::clear_value() {
  if (value_ != NULL) value_->::cockroach::roachpb::Value::Clear();
  clear_has_value();
}
const ::cockroach::roachpb::Value& GetResponse::value() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.GetResponse.value)
  return value_ != NULL ? *value_ : *default_instance_->value_;
}
::cockroach::roachpb::Value* GetResponse::mutable_value() {
  set_has_value();
  if (value_ == NULL) {
    value_ = new ::cockroach::roachpb::Value;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.GetResponse.value)
  return value_;
}
::cockroach::roachpb::Value* GetResponse::release_value() {
  clear_has_value();
  ::cockroach::roachpb::Value* temp = value_;
  value_ = NULL;
  return temp;
}
void GetResponse::set_allocated_value(::cockroach::roachpb::Value* value) {
  delete value_;
  value_ = value;
  if (value) {
    set_has_value();
  } else {
    clear_has_value();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.GetResponse.value)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int PutRequest::kHeaderFieldNumber;
const int PutRequest::kValueFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

PutRequest::PutRequest()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:cockroach.roachpb.PutRequest)
}

void PutRequest::InitAsDefaultInstance() {
  header_ = const_cast< ::cockroach::roachpb::Span*>(&::cockroach::roachpb::Span::default_instance());
  value_ = const_cast< ::cockroach::roachpb::Value*>(&::cockroach::roachpb::Value::default_instance());
}

PutRequest::PutRequest(const PutRequest& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:cockroach.roachpb.PutRequest)
}

void PutRequest::SharedCtor() {
  _cached_size_ = 0;
  header_ = NULL;
  value_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

PutRequest::~PutRequest() {
  // @@protoc_insertion_point(destructor:cockroach.roachpb.PutRequest)
  SharedDtor();
}

void PutRequest::SharedDtor() {
  if (this != default_instance_) {
    delete header_;
    delete value_;
  }
}

void PutRequest::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* PutRequest::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return PutRequest_descriptor_;
}

const PutRequest& PutRequest::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_cockroach_2froachpb_2fapi_2eproto();
  return *default_instance_;
}

PutRequest* PutRequest::default_instance_ = NULL;

PutRequest* PutRequest::New(::google::protobuf::Arena* arena) const {
  PutRequest* n = new PutRequest;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void PutRequest::Clear() {
  if (_has_bits_[0 / 32] & 3u) {
    if (has_header()) {
      if (header_ != NULL) header_->::cockroach::roachpb::Span::Clear();
    }
    if (has_value()) {
      if (value_ != NULL) value_->::cockroach::roachpb::Value::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool PutRequest::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:cockroach.roachpb.PutRequest)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .cockroach.roachpb.Span header = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_header()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_value;
        break;
      }

      // optional .cockroach.roachpb.Value value = 2;
      case 2: {
        if (tag == 18) {
         parse_value:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_value()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:cockroach.roachpb.PutRequest)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:cockroach.roachpb.PutRequest)
  return false;
#undef DO_
}

void PutRequest::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:cockroach.roachpb.PutRequest)
  // optional .cockroach.roachpb.Span header = 1;
  if (has_header()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->header_, output);
  }

  // optional .cockroach.roachpb.Value value = 2;
  if (has_value()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, *this->value_, output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:cockroach.roachpb.PutRequest)
}

::google::protobuf::uint8* PutRequest::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:cockroach.roachpb.PutRequest)
  // optional .cockroach.roachpb.Span header = 1;
  if (has_header()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, *this->header_, target);
  }

  // optional .cockroach.roachpb.Value value = 2;
  if (has_value()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, *this->value_, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:cockroach.roachpb.PutRequest)
  return target;
}

int PutRequest::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & 3u) {
    // optional .cockroach.roachpb.Span header = 1;
    if (has_header()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->header_);
    }

    // optional .cockroach.roachpb.Value value = 2;
    if (has_value()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->value_);
    }

  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void PutRequest::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const PutRequest* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const PutRequest>(
          &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void PutRequest::MergeFrom(const PutRequest& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_header()) {
      mutable_header()->::cockroach::roachpb::Span::MergeFrom(from.header());
    }
    if (from.has_value()) {
      mutable_value()->::cockroach::roachpb::Value::MergeFrom(from.value());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void PutRequest::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void PutRequest::CopyFrom(const PutRequest& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PutRequest::IsInitialized() const {

  return true;
}

void PutRequest::Swap(PutRequest* other) {
  if (other == this) return;
  InternalSwap(other);
}
void PutRequest::InternalSwap(PutRequest* other) {
  std::swap(header_, other->header_);
  std::swap(value_, other->value_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata PutRequest::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = PutRequest_descriptor_;
  metadata.reflection = PutRequest_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// PutRequest

// optional .cockroach.roachpb.Span header = 1;
bool PutRequest::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void PutRequest::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
void PutRequest::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
void PutRequest::clear_header() {
  if (header_ != NULL) header_->::cockroach::roachpb::Span::Clear();
  clear_has_header();
}
const ::cockroach::roachpb::Span& PutRequest::header() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.PutRequest.header)
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
::cockroach::roachpb::Span* PutRequest::mutable_header() {
  set_has_header();
  if (header_ == NULL) {
    header_ = new ::cockroach::roachpb::Span;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.PutRequest.header)
  return header_;
}
::cockroach::roachpb::Span* PutRequest::release_header() {
  clear_has_header();
  ::cockroach::roachpb::Span* temp = header_;
  header_ = NULL;
  return temp;
}
void PutRequest::set_allocated_header(::cockroach::roachpb::Span* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.PutRequest.header)
}

// optional .cockroach.roachpb.Value value = 2;
bool PutRequest::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void PutRequest::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
void PutRequest::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
void PutRequest::clear_value() {
  if (value_ != NULL) value_->::cockroach::roachpb::Value::Clear();
  clear_has_value();
}
const ::cockroach::roachpb::Value& PutRequest::value() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.PutRequest.value)
  return value_ != NULL ? *value_ : *default_instance_->value_;
}
::cockroach::roachpb::Value* PutRequest::mutable_value() {
  set_has_value();
  if (value_ == NULL) {
    value_ = new ::cockroach::roachpb::Value;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.PutRequest.value)
  return value_;
}
::cockroach::roachpb::Value* PutRequest::release_value() {
  clear_has_value();
  ::cockroach::roachpb::Value* temp = value_;
  value_ = NULL;
  return temp;
}
void PutRequest::set_allocated_value(::cockroach::roachpb::Value* value) {
  delete value_;
  value_ = value;
  if (value) {
    set_has_value();
  } else {
    clear_has_value();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.PutRequest.value)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int PutResponse::kHeaderFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

PutResponse::PutResponse()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:cockroach.roachpb.PutResponse)
}

void PutResponse::InitAsDefaultInstance() {
  header_ = const_cast< ::cockroach::roachpb::ResponseHeader*>(&::cockroach::roachpb::ResponseHeader::default_instance());
}

PutResponse::PutResponse(const PutResponse& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:cockroach.roachpb.PutResponse)
}

void PutResponse::SharedCtor() {
  _cached_size_ = 0;
  header_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

PutResponse::~PutResponse() {
  // @@protoc_insertion_point(destructor:cockroach.roachpb.PutResponse)
  SharedDtor();
}

void PutResponse::SharedDtor() {
  if (this != default_instance_) {
    delete header_;
  }
}

void PutResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* PutResponse::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return PutResponse_descriptor_;
}

const PutResponse& PutResponse::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_cockroach_2froachpb_2fapi_2eproto();
  return *default_instance_;
}

PutResponse* PutResponse::default_instance_ = NULL;

PutResponse* PutResponse::New(::google::protobuf::Arena* arena) const {
  PutResponse* n = new PutResponse;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void PutResponse::Clear() {
  if (has_header()) {
    if (header_ != NULL) header_->::cockroach::roachpb::ResponseHeader::Clear();
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool PutResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:cockroach.roachpb.PutResponse)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .cockroach.roachpb.ResponseHeader header = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_header()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:cockroach.roachpb.PutResponse)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:cockroach.roachpb.PutResponse)
  return false;
#undef DO_
}

void PutResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:cockroach.roachpb.PutResponse)
  // optional .cockroach.roachpb.ResponseHeader header = 1;
  if (has_header()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->header_, output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:cockroach.roachpb.PutResponse)
}

::google::protobuf::uint8* PutResponse::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:cockroach.roachpb.PutResponse)
  // optional .cockroach.roachpb.ResponseHeader header = 1;
  if (has_header()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, *this->header_, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:cockroach.roachpb.PutResponse)
  return target;
}

int PutResponse::ByteSize() const {
  int total_size = 0;

  // optional .cockroach.roachpb.ResponseHeader header = 1;
  if (has_header()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->header_);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void PutResponse::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const PutResponse* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const PutResponse>(
          &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void PutResponse::MergeFrom(const PutResponse& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_header()) {
      mutable_header()->::cockroach::roachpb::ResponseHeader::MergeFrom(from.header());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void PutResponse::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void PutResponse::CopyFrom(const PutResponse& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PutResponse::IsInitialized() const {

  return true;
}

void PutResponse::Swap(PutResponse* other) {
  if (other == this) return;
  InternalSwap(other);
}
void PutResponse::InternalSwap(PutResponse* other) {
  std::swap(header_, other->header_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata PutResponse::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = PutResponse_descriptor_;
  metadata.reflection = PutResponse_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// PutResponse

// optional .cockroach.roachpb.ResponseHeader header = 1;
bool PutResponse::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void PutResponse::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
void PutResponse::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
void PutResponse::clear_header() {
  if (header_ != NULL) header_->::cockroach::roachpb::ResponseHeader::Clear();
  clear_has_header();
}
const ::cockroach::roachpb::ResponseHeader& PutResponse::header() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.PutResponse.header)
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
::cockroach::roachpb::ResponseHeader* PutResponse::mutable_header() {
  set_has_header();
  if (header_ == NULL) {
    header_ = new ::cockroach::roachpb::ResponseHeader;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.PutResponse.header)
  return header_;
}
::cockroach::roachpb::ResponseHeader* PutResponse::release_header() {
  clear_has_header();
  ::cockroach::roachpb::ResponseHeader* temp = header_;
  header_ = NULL;
  return temp;
}
void PutResponse::set_allocated_header(::cockroach::roachpb::ResponseHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.PutResponse.header)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int ConditionalPutRequest::kHeaderFieldNumber;
const int ConditionalPutRequest::kValueFieldNumber;
const int ConditionalPutRequest::kExpValueFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

ConditionalPutRequest::ConditionalPutRequest()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:cockroach.roachpb.ConditionalPutRequest)
}

void ConditionalPutRequest::InitAsDefaultInstance() {
  header_ = const_cast< ::cockroach::roachpb::Span*>(&::cockroach::roachpb::Span::default_instance());
  value_ = const_cast< ::cockroach::roachpb::Value*>(&::cockroach::roachpb::Value::default_instance());
  exp_value_ = const_cast< ::cockroach::roachpb::Value*>(&::cockroach::roachpb::Value::default_instance());
}

ConditionalPutRequest::ConditionalPutRequest(const ConditionalPutRequest& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:cockroach.roachpb.ConditionalPutRequest)
}

void ConditionalPutRequest::SharedCtor() {
  _cached_size_ = 0;
  header_ = NULL;
  value_ = NULL;
  exp_value_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ConditionalPutRequest::~ConditionalPutRequest() {
  // @@protoc_insertion_point(destructor:cockroach.roachpb.ConditionalPutRequest)
  SharedDtor();
}

void ConditionalPutRequest::SharedDtor() {
  if (this != default_instance_) {
    delete header_;
    delete value_;
    delete exp_value_;
  }
}

void ConditionalPutRequest::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ConditionalPutRequest::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ConditionalPutRequest_descriptor_;
}

const ConditionalPutRequest& ConditionalPutRequest::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_cockroach_2froachpb_2fapi_2eproto();
  return *default_instance_;
}

ConditionalPutRequest* ConditionalPutRequest::default_instance_ = NULL;

ConditionalPutRequest* ConditionalPutRequest::New(::google::protobuf::Arena* arena) const {
  ConditionalPutRequest* n = new ConditionalPutRequest;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void ConditionalPutRequest::Clear() {
  if (_has_bits_[0 / 32] & 7u) {
    if (has_header()) {
      if (header_ != NULL) header_->::cockroach::roachpb::Span::Clear();
    }
    if (has_value()) {
      if (value_ != NULL) value_->::cockroach::roachpb::Value::Clear();
    }
    if (has_exp_value()) {
      if (exp_value_ != NULL) exp_value_->::cockroach::roachpb::Value::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool ConditionalPutRequest::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:cockroach.roachpb.ConditionalPutRequest)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .cockroach.roachpb.Span header = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_header()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_value;
        break;
      }

      // optional .cockroach.roachpb.Value value = 2;
      case 2: {
        if (tag == 18) {
         parse_value:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_value()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_exp_value;
        break;
      }

      // optional .cockroach.roachpb.Value exp_value = 3;
      case 3: {
        if (tag == 26) {
         parse_exp_value:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_exp_value()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:cockroach.roachpb.ConditionalPutRequest)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:cockroach.roachpb.ConditionalPutRequest)
  return false;
#undef DO_
}

void ConditionalPutRequest::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:cockroach.roachpb.ConditionalPutRequest)
  // optional .cockroach.roachpb.Span header = 1;
  if (has_header()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->header_, output);
  }

  // optional .cockroach.roachpb.Value value = 2;
  if (has_value()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, *this->value_, output);
  }

  // optional .cockroach.roachpb.Value exp_value = 3;
  if (has_exp_value()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, *this->exp_value_, output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:cockroach.roachpb.ConditionalPutRequest)
}

::google::protobuf::uint8* ConditionalPutRequest::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:cockroach.roachpb.ConditionalPutRequest)
  // optional .cockroach.roachpb.Span header = 1;
  if (has_header()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, *this->header_, target);
  }

  // optional .cockroach.roachpb.Value value = 2;
  if (has_value()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, *this->value_, target);
  }

  // optional .cockroach.roachpb.Value exp_value = 3;
  if (has_exp_value()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, *this->exp_value_, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:cockroach.roachpb.ConditionalPutRequest)
  return target;
}

int ConditionalPutRequest::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & 7u) {
    // optional .cockroach.roachpb.Span header = 1;
    if (has_header()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->header_);
    }

    // optional .cockroach.roachpb.Value value = 2;
    if (has_value()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->value_);
    }

    // optional .cockroach.roachpb.Value exp_value = 3;
    if (has_exp_value()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->exp_value_);
    }

  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ConditionalPutRequest::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const ConditionalPutRequest* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const ConditionalPutRequest>(
          &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ConditionalPutRequest::MergeFrom(const ConditionalPutRequest& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_header()) {
      mutable_header()->::cockroach::roachpb::Span::MergeFrom(from.header());
    }
    if (from.has_value()) {
      mutable_value()->::cockroach::roachpb::Value::MergeFrom(from.value());
    }
    if (from.has_exp_value()) {
      mutable_exp_value()->::cockroach::roachpb::Value::MergeFrom(from.exp_value());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void ConditionalPutRequest::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ConditionalPutRequest::CopyFrom(const ConditionalPutRequest& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ConditionalPutRequest::IsInitialized() const {

  return true;
}

void ConditionalPutRequest::Swap(ConditionalPutRequest* other) {
  if (other == this) return;
  InternalSwap(other);
}
void ConditionalPutRequest::InternalSwap(ConditionalPutRequest* other) {
  std::swap(header_, other->header_);
  std::swap(value_, other->value_);
  std::swap(exp_value_, other->exp_value_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata ConditionalPutRequest::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ConditionalPutRequest_descriptor_;
  metadata.reflection = ConditionalPutRequest_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// ConditionalPutRequest

// optional .cockroach.roachpb.Span header = 1;
bool ConditionalPutRequest::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void ConditionalPutRequest::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
void ConditionalPutRequest::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
void ConditionalPutRequest::clear_header() {
  if (header_ != NULL) header_->::cockroach::roachpb::Span::Clear();
  clear_has_header();
}
const ::cockroach::roachpb::Span& ConditionalPutRequest::header() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.ConditionalPutRequest.header)
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
::cockroach::roachpb::Span* ConditionalPutRequest::mutable_header() {
  set_has_header();
  if (header_ == NULL) {
    header_ = new ::cockroach::roachpb::Span;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.ConditionalPutRequest.header)
  return header_;
}
::cockroach::roachpb::Span* ConditionalPutRequest::release_header() {
  clear_has_header();
  ::cockroach::roachpb::Span* temp = header_;
  header_ = NULL;
  return temp;
}
void ConditionalPutRequest::set_allocated_header(::cockroach::roachpb::Span* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.ConditionalPutRequest.header)
}

// optional .cockroach.roachpb.Value value = 2;
bool ConditionalPutRequest::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void ConditionalPutRequest::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
void ConditionalPutRequest::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
void ConditionalPutRequest::clear_value() {
  if (value_ != NULL) value_->::cockroach::roachpb::Value::Clear();
  clear_has_value();
}
const ::cockroach::roachpb::Value& ConditionalPutRequest::value() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.ConditionalPutRequest.value)
  return value_ != NULL ? *value_ : *default_instance_->value_;
}
::cockroach::roachpb::Value* ConditionalPutRequest::mutable_value() {
  set_has_value();
  if (value_ == NULL) {
    value_ = new ::cockroach::roachpb::Value;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.ConditionalPutRequest.value)
  return value_;
}
::cockroach::roachpb::Value* ConditionalPutRequest::release_value() {
  clear_has_value();
  ::cockroach::roachpb::Value* temp = value_;
  value_ = NULL;
  return temp;
}
void ConditionalPutRequest::set_allocated_value(::cockroach::roachpb::Value* value) {
  delete value_;
  value_ = value;
  if (value) {
    set_has_value();
  } else {
    clear_has_value();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.ConditionalPutRequest.value)
}

// optional .cockroach.roachpb.Value exp_value = 3;
bool ConditionalPutRequest::has_exp_value() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void ConditionalPutRequest::set_has_exp_value() {
  _has_bits_[0] |= 0x00000004u;
}
void ConditionalPutRequest::clear_has_exp_value() {
  _has_bits_[0] &= ~0x00000004u;
}
void ConditionalPutRequest::clear_exp_value() {
  if (exp_value_ != NULL) exp_value_->::cockroach::roachpb::Value::Clear();
  clear_has_exp_value();
}
const ::cockroach::roachpb::Value& ConditionalPutRequest::exp_value() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.ConditionalPutRequest.exp_value)
  return exp_value_ != NULL ? *exp_value_ : *default_instance_->exp_value_;
}
::cockroach::roachpb::Value* ConditionalPutRequest::mutable_exp_value() {
  set_has_exp_value();
  if (exp_value_ == NULL) {
    exp_value_ = new ::cockroach::roachpb::Value;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.ConditionalPutRequest.exp_value)
  return exp_value_;
}
::cockroach::roachpb::Value* ConditionalPutRequest::release_exp_value() {
  clear_has_exp_value();
  ::cockroach::roachpb::Value* temp = exp_value_;
  exp_value_ = NULL;
  return temp;
}
void ConditionalPutRequest::set_allocated_exp_value(::cockroach::roachpb::Value* exp_value) {
  delete exp_value_;
  exp_value_ = exp_value;
  if (exp_value) {
    set_has_exp_value();
  } else {
    clear_has_exp_value();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.ConditionalPutRequest.exp_value)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int ConditionalPutResponse::kHeaderFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

ConditionalPutResponse::ConditionalPutResponse()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:cockroach.roachpb.ConditionalPutResponse)
}

void ConditionalPutResponse::InitAsDefaultInstance() {
  header_ = const_cast< ::cockroach::roachpb::ResponseHeader*>(&::cockroach::roachpb::ResponseHeader::default_instance());
}

ConditionalPutResponse::ConditionalPutResponse(const ConditionalPutResponse& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:cockroach.roachpb.ConditionalPutResponse)
}

void ConditionalPutResponse::SharedCtor() {
  _cached_size_ = 0;
  header_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ConditionalPutResponse::~ConditionalPutResponse() {
  // @@protoc_insertion_point(destructor:cockroach.roachpb.ConditionalPutResponse)
  SharedDtor();
}

void ConditionalPutResponse::SharedDtor() {
  if (this != default_instance_) {
    delete header_;
  }
}

void ConditionalPutResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ConditionalPutResponse::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ConditionalPutResponse_descriptor_;
}

const ConditionalPutResponse& ConditionalPutResponse::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_cockroach_2froachpb_2fapi_2eproto();
  return *default_instance_;
}

ConditionalPutResponse* ConditionalPutResponse::default_instance_ = NULL;

ConditionalPutResponse* ConditionalPutResponse::New(::google::protobuf::Arena* arena) const {
  ConditionalPutResponse* n = new ConditionalPutResponse;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void ConditionalPutResponse::Clear() {
  if (has_header()) {
    if (header_ != NULL) header_->::cockroach::roachpb::ResponseHeader::Clear();
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool ConditionalPutResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:cockroach.roachpb.ConditionalPutResponse)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .cockroach.roachpb.ResponseHeader header = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_header()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:cockroach.roachpb.ConditionalPutResponse)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:cockroach.roachpb.ConditionalPutResponse)
  return false;
#undef DO_
}

void ConditionalPutResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:cockroach.roachpb.ConditionalPutResponse)
  // optional .cockroach.roachpb.ResponseHeader header = 1;
  if (has_header()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->header_, output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:cockroach.roachpb.ConditionalPutResponse)
}

::google::protobuf::uint8* ConditionalPutResponse::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:cockroach.roachpb.ConditionalPutResponse)
  // optional .cockroach.roachpb.ResponseHeader header = 1;
  if (has_header()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, *this->header_, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:cockroach.roachpb.ConditionalPutResponse)
  return target;
}

int ConditionalPutResponse::ByteSize() const {
  int total_size = 0;

  // optional .cockroach.roachpb.ResponseHeader header = 1;
  if (has_header()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->header_);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ConditionalPutResponse::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const ConditionalPutResponse* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const ConditionalPutResponse>(
          &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ConditionalPutResponse::MergeFrom(const ConditionalPutResponse& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_header()) {
      mutable_header()->::cockroach::roachpb::ResponseHeader::MergeFrom(from.header());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void ConditionalPutResponse::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ConditionalPutResponse::CopyFrom(const ConditionalPutResponse& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ConditionalPutResponse::IsInitialized() const {

  return true;
}

void ConditionalPutResponse::Swap(ConditionalPutResponse* other) {
  if (other == this) return;
  InternalSwap(other);
}
void ConditionalPutResponse::InternalSwap(ConditionalPutResponse* other) {
  std::swap(header_, other->header_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata ConditionalPutResponse::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ConditionalPutResponse_descriptor_;
  metadata.reflection = ConditionalPutResponse_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// ConditionalPutResponse

// optional .cockroach.roachpb.ResponseHeader header = 1;
bool ConditionalPutResponse::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void ConditionalPutResponse::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
void ConditionalPutResponse::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
void ConditionalPutResponse::clear_header() {
  if (header_ != NULL) header_->::cockroach::roachpb::ResponseHeader::Clear();
  clear_has_header();
}
const ::cockroach::roachpb::ResponseHeader& ConditionalPutResponse::header() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.ConditionalPutResponse.header)
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
::cockroach::roachpb::ResponseHeader* ConditionalPutResponse::mutable_header() {
  set_has_header();
  if (header_ == NULL) {
    header_ = new ::cockroach::roachpb::ResponseHeader;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.ConditionalPutResponse.header)
  return header_;
}
::cockroach::roachpb::ResponseHeader* ConditionalPutResponse::release_header() {
  clear_has_header();
  ::cockroach::roachpb::ResponseHeader* temp = header_;
  header_ = NULL;
  return temp;
}
void ConditionalPutResponse::set_allocated_header(::cockroach::roachpb::ResponseHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.ConditionalPutResponse.header)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int IncrementRequest::kHeaderFieldNumber;
const int IncrementRequest::kIncrementFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

IncrementRequest::IncrementRequest()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:cockroach.roachpb.IncrementRequest)
}

void IncrementRequest::InitAsDefaultInstance() {
  header_ = const_cast< ::cockroach::roachpb::Span*>(&::cockroach::roachpb::Span::default_instance());
}

IncrementRequest::IncrementRequest(const IncrementRequest& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:cockroach.roachpb.IncrementRequest)
}

void IncrementRequest::SharedCtor() {
  _cached_size_ = 0;
  header_ = NULL;
  increment_ = GOOGLE_LONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

IncrementRequest::~IncrementRequest() {
  // @@protoc_insertion_point(destructor:cockroach.roachpb.IncrementRequest)
  SharedDtor();
}

void IncrementRequest::SharedDtor() {
  if (this != default_instance_) {
    delete header_;
  }
}

void IncrementRequest::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* IncrementRequest::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return IncrementRequest_descriptor_;
}

const IncrementRequest& IncrementRequest::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_cockroach_2froachpb_2fapi_2eproto();
  return *default_instance_;
}

IncrementRequest* IncrementRequest::default_instance_ = NULL;

IncrementRequest* IncrementRequest::New(::google::protobuf::Arena* arena) const {
  IncrementRequest* n = new IncrementRequest;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void IncrementRequest::Clear() {
  if (_has_bits_[0 / 32] & 3u) {
    if (has_header()) {
      if (header_ != NULL) header_->::cockroach::roachpb::Span::Clear();
    }
    increment_ = GOOGLE_LONGLONG(0);
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool IncrementRequest::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:cockroach.roachpb.IncrementRequest)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .cockroach.roachpb.Span header = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_header()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_increment;
        break;
      }

      // optional int64 increment = 2;
      case 2: {
        if (tag == 16) {
         parse_increment:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &increment_)));
          set_has_increment();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:cockroach.roachpb.IncrementRequest)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:cockroach.roachpb.IncrementRequest)
  return false;
#undef DO_
}

void IncrementRequest::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:cockroach.roachpb.IncrementRequest)
  // optional .cockroach.roachpb.Span header = 1;
  if (has_header()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->header_, output);
  }

  // optional int64 increment = 2;
  if (has_increment()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(2, this->increment(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:cockroach.roachpb.IncrementRequest)
}

::google::protobuf::uint8* IncrementRequest::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:cockroach.roachpb.IncrementRequest)
  // optional .cockroach.roachpb.Span header = 1;
  if (has_header()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, *this->header_, target);
  }

  // optional int64 increment = 2;
  if (has_increment()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(2, this->increment(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:cockroach.roachpb.IncrementRequest)
  return target;
}

int IncrementRequest::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & 3u) {
    // optional .cockroach.roachpb.Span header = 1;
    if (has_header()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->header_);
    }

    // optional int64 increment = 2;
    if (has_increment()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->increment());
    }

  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void IncrementRequest::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const IncrementRequest* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const IncrementRequest>(
          &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void IncrementRequest::MergeFrom(const IncrementRequest& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_header()) {
      mutable_header()->::cockroach::roachpb::Span::MergeFrom(from.header());
    }
    if (from.has_increment()) {
      set_increment(from.increment());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void IncrementRequest::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void IncrementRequest::CopyFrom(const IncrementRequest& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IncrementRequest::IsInitialized() const {

  return true;
}

void IncrementRequest::Swap(IncrementRequest* other) {
  if (other == this) return;
  InternalSwap(other);
}
void IncrementRequest::InternalSwap(IncrementRequest* other) {
  std::swap(header_, other->header_);
  std::swap(increment_, other->increment_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata IncrementRequest::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = IncrementRequest_descriptor_;
  metadata.reflection = IncrementRequest_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// IncrementRequest

// optional .cockroach.roachpb.Span header = 1;
bool IncrementRequest::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void IncrementRequest::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
void IncrementRequest::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
void IncrementRequest::clear_header() {
  if (header_ != NULL) header_->::cockroach::roachpb::Span::Clear();
  clear_has_header();
}
const ::cockroach::roachpb::Span& IncrementRequest::header() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.IncrementRequest.header)
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
::cockroach::roachpb::Span* IncrementRequest::mutable_header() {
  set_has_header();
  if (header_ == NULL) {
    header_ = new ::cockroach::roachpb::Span;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.IncrementRequest.header)
  return header_;
}
::cockroach::roachpb::Span* IncrementRequest::release_header() {
  clear_has_header();
  ::cockroach::roachpb::Span* temp = header_;
  header_ = NULL;
  return temp;
}
void IncrementRequest::set_allocated_header(::cockroach::roachpb::Span* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.IncrementRequest.header)
}

// optional int64 increment = 2;
bool IncrementRequest::has_increment() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void IncrementRequest::set_has_increment() {
  _has_bits_[0] |= 0x00000002u;
}
void IncrementRequest::clear_has_increment() {
  _has_bits_[0] &= ~0x00000002u;
}
void IncrementRequest::clear_increment() {
  increment_ = GOOGLE_LONGLONG(0);
  clear_has_increment();
}
 ::google::protobuf::int64 IncrementRequest::increment() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.IncrementRequest.increment)
  return increment_;
}
 void IncrementRequest::set_increment(::google::protobuf::int64 value) {
  set_has_increment();
  increment_ = value;
  // @@protoc_insertion_point(field_set:cockroach.roachpb.IncrementRequest.increment)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int IncrementResponse::kHeaderFieldNumber;
const int IncrementResponse::kNewValueFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

IncrementResponse::IncrementResponse()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:cockroach.roachpb.IncrementResponse)
}

void IncrementResponse::InitAsDefaultInstance() {
  header_ = const_cast< ::cockroach::roachpb::ResponseHeader*>(&::cockroach::roachpb::ResponseHeader::default_instance());
}

IncrementResponse::IncrementResponse(const IncrementResponse& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:cockroach.roachpb.IncrementResponse)
}

void IncrementResponse::SharedCtor() {
  _cached_size_ = 0;
  header_ = NULL;
  new_value_ = GOOGLE_LONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

IncrementResponse::~IncrementResponse() {
  // @@protoc_insertion_point(destructor:cockroach.roachpb.IncrementResponse)
  SharedDtor();
}

void IncrementResponse::SharedDtor() {
  if (this != default_instance_) {
    delete header_;
  }
}

void IncrementResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* IncrementResponse::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return IncrementResponse_descriptor_;
}

const IncrementResponse& IncrementResponse::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_cockroach_2froachpb_2fapi_2eproto();
  return *default_instance_;
}

IncrementResponse* IncrementResponse::default_instance_ = NULL;

IncrementResponse* IncrementResponse::New(::google::protobuf::Arena* arena) const {
  IncrementResponse* n = new IncrementResponse;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void IncrementResponse::Clear() {
  if (_has_bits_[0 / 32] & 3u) {
    if (has_header()) {
      if (header_ != NULL) header_->::cockroach::roachpb::ResponseHeader::Clear();
    }
    new_value_ = GOOGLE_LONGLONG(0);
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool IncrementResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:cockroach.roachpb.IncrementResponse)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .cockroach.roachpb.ResponseHeader header = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_header()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_new_value;
        break;
      }

      // optional int64 new_value = 2;
      case 2: {
        if (tag == 16) {
         parse_new_value:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &new_value_)));
          set_has_new_value();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:cockroach.roachpb.IncrementResponse)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:cockroach.roachpb.IncrementResponse)
  return false;
#undef DO_
}

void IncrementResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:cockroach.roachpb.IncrementResponse)
  // optional .cockroach.roachpb.ResponseHeader header = 1;
  if (has_header()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->header_, output);
  }

  // optional int64 new_value = 2;
  if (has_new_value()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(2, this->new_value(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:cockroach.roachpb.IncrementResponse)
}

::google::protobuf::uint8* IncrementResponse::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:cockroach.roachpb.IncrementResponse)
  // optional .cockroach.roachpb.ResponseHeader header = 1;
  if (has_header()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, *this->header_, target);
  }

  // optional int64 new_value = 2;
  if (has_new_value()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(2, this->new_value(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:cockroach.roachpb.IncrementResponse)
  return target;
}

int IncrementResponse::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & 3u) {
    // optional .cockroach.roachpb.ResponseHeader header = 1;
    if (has_header()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->header_);
    }

    // optional int64 new_value = 2;
    if (has_new_value()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->new_value());
    }

  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void IncrementResponse::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const IncrementResponse* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const IncrementResponse>(
          &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void IncrementResponse::MergeFrom(const IncrementResponse& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_header()) {
      mutable_header()->::cockroach::roachpb::ResponseHeader::MergeFrom(from.header());
    }
    if (from.has_new_value()) {
      set_new_value(from.new_value());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void IncrementResponse::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void IncrementResponse::CopyFrom(const IncrementResponse& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IncrementResponse::IsInitialized() const {

  return true;
}

void IncrementResponse::Swap(IncrementResponse* other) {
  if (other == this) return;
  InternalSwap(other);
}
void IncrementResponse::InternalSwap(IncrementResponse* other) {
  std::swap(header_, other->header_);
  std::swap(new_value_, other->new_value_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata IncrementResponse::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = IncrementResponse_descriptor_;
  metadata.reflection = IncrementResponse_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// IncrementResponse

// optional .cockroach.roachpb.ResponseHeader header = 1;
bool IncrementResponse::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void IncrementResponse::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
void IncrementResponse::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
void IncrementResponse::clear_header() {
  if (header_ != NULL) header_->::cockroach::roachpb::ResponseHeader::Clear();
  clear_has_header();
}
const ::cockroach::roachpb::ResponseHeader& IncrementResponse::header() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.IncrementResponse.header)
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
::cockroach::roachpb::ResponseHeader* IncrementResponse::mutable_header() {
  set_has_header();
  if (header_ == NULL) {
    header_ = new ::cockroach::roachpb::ResponseHeader;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.IncrementResponse.header)
  return header_;
}
::cockroach::roachpb::ResponseHeader* IncrementResponse::release_header() {
  clear_has_header();
  ::cockroach::roachpb::ResponseHeader* temp = header_;
  header_ = NULL;
  return temp;
}
void IncrementResponse::set_allocated_header(::cockroach::roachpb::ResponseHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.IncrementResponse.header)
}

// optional int64 new_value = 2;
bool IncrementResponse::has_new_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void IncrementResponse::set_has_new_value() {
  _has_bits_[0] |= 0x00000002u;
}
void IncrementResponse::clear_has_new_value() {
  _has_bits_[0] &= ~0x00000002u;
}
void IncrementResponse::clear_new_value() {
  new_value_ = GOOGLE_LONGLONG(0);
  clear_has_new_value();
}
 ::google::protobuf::int64 IncrementResponse::new_value() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.IncrementResponse.new_value)
  return new_value_;
}
 void IncrementResponse::set_new_value(::google::protobuf::int64 value) {
  set_has_new_value();
  new_value_ = value;
  // @@protoc_insertion_point(field_set:cockroach.roachpb.IncrementResponse.new_value)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int DeleteRequest::kHeaderFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

DeleteRequest::DeleteRequest()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:cockroach.roachpb.DeleteRequest)
}

void DeleteRequest::InitAsDefaultInstance() {
  header_ = const_cast< ::cockroach::roachpb::Span*>(&::cockroach::roachpb::Span::default_instance());
}

DeleteRequest::DeleteRequest(const DeleteRequest& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:cockroach.roachpb.DeleteRequest)
}

void DeleteRequest::SharedCtor() {
  _cached_size_ = 0;
  header_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

DeleteRequest::~DeleteRequest() {
  // @@protoc_insertion_point(destructor:cockroach.roachpb.DeleteRequest)
  SharedDtor();
}

void DeleteRequest::SharedDtor() {
  if (this != default_instance_) {
    delete header_;
  }
}

void DeleteRequest::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* DeleteRequest::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return DeleteRequest_descriptor_;
}

const DeleteRequest& DeleteRequest::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_cockroach_2froachpb_2fapi_2eproto();
  return *default_instance_;
}

DeleteRequest* DeleteRequest::default_instance_ = NULL;

DeleteRequest* DeleteRequest::New(::google::protobuf::Arena* arena) const {
  DeleteRequest* n = new DeleteRequest;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void DeleteRequest::Clear() {
  if (has_header()) {
    if (header_ != NULL) header_->::cockroach::roachpb::Span::Clear();
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool DeleteRequest::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:cockroach.roachpb.DeleteRequest)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .cockroach.roachpb.Span header = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_header()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:cockroach.roachpb.DeleteRequest)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:cockroach.roachpb.DeleteRequest)
  return false;
#undef DO_
}

void DeleteRequest::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:cockroach.roachpb.DeleteRequest)
  // optional .cockroach.roachpb.Span header = 1;
  if (has_header()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->header_, output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:cockroach.roachpb.DeleteRequest)
}

::google::protobuf::uint8* DeleteRequest::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:cockroach.roachpb.DeleteRequest)
  // optional .cockroach.roachpb.Span header = 1;
  if (has_header()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, *this->header_, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:cockroach.roachpb.DeleteRequest)
  return target;
}

int DeleteRequest::ByteSize() const {
  int total_size = 0;

  // optional .cockroach.roachpb.Span header = 1;
  if (has_header()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->header_);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void DeleteRequest::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const DeleteRequest* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const DeleteRequest>(
          &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void DeleteRequest::MergeFrom(const DeleteRequest& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_header()) {
      mutable_header()->::cockroach::roachpb::Span::MergeFrom(from.header());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void DeleteRequest::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void DeleteRequest::CopyFrom(const DeleteRequest& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DeleteRequest::IsInitialized() const {

  return true;
}

void DeleteRequest::Swap(DeleteRequest* other) {
  if (other == this) return;
  InternalSwap(other);
}
void DeleteRequest::InternalSwap(DeleteRequest* other) {
  std::swap(header_, other->header_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata DeleteRequest::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = DeleteRequest_descriptor_;
  metadata.reflection = DeleteRequest_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// DeleteRequest

// optional .cockroach.roachpb.Span header = 1;
bool DeleteRequest::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void DeleteRequest::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
void DeleteRequest::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
void DeleteRequest::clear_header() {
  if (header_ != NULL) header_->::cockroach::roachpb::Span::Clear();
  clear_has_header();
}
const ::cockroach::roachpb::Span& DeleteRequest::header() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.DeleteRequest.header)
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
::cockroach::roachpb::Span* DeleteRequest::mutable_header() {
  set_has_header();
  if (header_ == NULL) {
    header_ = new ::cockroach::roachpb::Span;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.DeleteRequest.header)
  return header_;
}
::cockroach::roachpb::Span* DeleteRequest::release_header() {
  clear_has_header();
  ::cockroach::roachpb::Span* temp = header_;
  header_ = NULL;
  return temp;
}
void DeleteRequest::set_allocated_header(::cockroach::roachpb::Span* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.DeleteRequest.header)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int DeleteResponse::kHeaderFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

DeleteResponse::DeleteResponse()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:cockroach.roachpb.DeleteResponse)
}

void DeleteResponse::InitAsDefaultInstance() {
  header_ = const_cast< ::cockroach::roachpb::ResponseHeader*>(&::cockroach::roachpb::ResponseHeader::default_instance());
}

DeleteResponse::DeleteResponse(const DeleteResponse& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:cockroach.roachpb.DeleteResponse)
}

void DeleteResponse::SharedCtor() {
  _cached_size_ = 0;
  header_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

DeleteResponse::~DeleteResponse() {
  // @@protoc_insertion_point(destructor:cockroach.roachpb.DeleteResponse)
  SharedDtor();
}

void DeleteResponse::SharedDtor() {
  if (this != default_instance_) {
    delete header_;
  }
}

void DeleteResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* DeleteResponse::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return DeleteResponse_descriptor_;
}

const DeleteResponse& DeleteResponse::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_cockroach_2froachpb_2fapi_2eproto();
  return *default_instance_;
}

DeleteResponse* DeleteResponse::default_instance_ = NULL;

DeleteResponse* DeleteResponse::New(::google::protobuf::Arena* arena) const {
  DeleteResponse* n = new DeleteResponse;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void DeleteResponse::Clear() {
  if (has_header()) {
    if (header_ != NULL) header_->::cockroach::roachpb::ResponseHeader::Clear();
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool DeleteResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:cockroach.roachpb.DeleteResponse)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .cockroach.roachpb.ResponseHeader header = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_header()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:cockroach.roachpb.DeleteResponse)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:cockroach.roachpb.DeleteResponse)
  return false;
#undef DO_
}

void DeleteResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:cockroach.roachpb.DeleteResponse)
  // optional .cockroach.roachpb.ResponseHeader header = 1;
  if (has_header()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->header_, output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:cockroach.roachpb.DeleteResponse)
}

::google::protobuf::uint8* DeleteResponse::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:cockroach.roachpb.DeleteResponse)
  // optional .cockroach.roachpb.ResponseHeader header = 1;
  if (has_header()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, *this->header_, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:cockroach.roachpb.DeleteResponse)
  return target;
}

int DeleteResponse::ByteSize() const {
  int total_size = 0;

  // optional .cockroach.roachpb.ResponseHeader header = 1;
  if (has_header()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->header_);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void DeleteResponse::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const DeleteResponse* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const DeleteResponse>(
          &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void DeleteResponse::MergeFrom(const DeleteResponse& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_header()) {
      mutable_header()->::cockroach::roachpb::ResponseHeader::MergeFrom(from.header());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void DeleteResponse::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void DeleteResponse::CopyFrom(const DeleteResponse& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DeleteResponse::IsInitialized() const {

  return true;
}

void DeleteResponse::Swap(DeleteResponse* other) {
  if (other == this) return;
  InternalSwap(other);
}
void DeleteResponse::InternalSwap(DeleteResponse* other) {
  std::swap(header_, other->header_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata DeleteResponse::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = DeleteResponse_descriptor_;
  metadata.reflection = DeleteResponse_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// DeleteResponse

// optional .cockroach.roachpb.ResponseHeader header = 1;
bool DeleteResponse::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void DeleteResponse::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
void DeleteResponse::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
void DeleteResponse::clear_header() {
  if (header_ != NULL) header_->::cockroach::roachpb::ResponseHeader::Clear();
  clear_has_header();
}
const ::cockroach::roachpb::ResponseHeader& DeleteResponse::header() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.DeleteResponse.header)
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
::cockroach::roachpb::ResponseHeader* DeleteResponse::mutable_header() {
  set_has_header();
  if (header_ == NULL) {
    header_ = new ::cockroach::roachpb::ResponseHeader;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.DeleteResponse.header)
  return header_;
}
::cockroach::roachpb::ResponseHeader* DeleteResponse::release_header() {
  clear_has_header();
  ::cockroach::roachpb::ResponseHeader* temp = header_;
  header_ = NULL;
  return temp;
}
void DeleteResponse::set_allocated_header(::cockroach::roachpb::ResponseHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.DeleteResponse.header)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int DeleteRangeRequest::kHeaderFieldNumber;
const int DeleteRangeRequest::kMaxEntriesToDeleteFieldNumber;
const int DeleteRangeRequest::kReturnKeysFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

DeleteRangeRequest::DeleteRangeRequest()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:cockroach.roachpb.DeleteRangeRequest)
}

void DeleteRangeRequest::InitAsDefaultInstance() {
  header_ = const_cast< ::cockroach::roachpb::Span*>(&::cockroach::roachpb::Span::default_instance());
}

DeleteRangeRequest::DeleteRangeRequest(const DeleteRangeRequest& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:cockroach.roachpb.DeleteRangeRequest)
}

void DeleteRangeRequest::SharedCtor() {
  _cached_size_ = 0;
  header_ = NULL;
  max_entries_to_delete_ = GOOGLE_LONGLONG(0);
  return_keys_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

DeleteRangeRequest::~DeleteRangeRequest() {
  // @@protoc_insertion_point(destructor:cockroach.roachpb.DeleteRangeRequest)
  SharedDtor();
}

void DeleteRangeRequest::SharedDtor() {
  if (this != default_instance_) {
    delete header_;
  }
}

void DeleteRangeRequest::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* DeleteRangeRequest::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return DeleteRangeRequest_descriptor_;
}

const DeleteRangeRequest& DeleteRangeRequest::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_cockroach_2froachpb_2fapi_2eproto();
  return *default_instance_;
}

DeleteRangeRequest* DeleteRangeRequest::default_instance_ = NULL;

DeleteRangeRequest* DeleteRangeRequest::New(::google::protobuf::Arena* arena) const {
  DeleteRangeRequest* n = new DeleteRangeRequest;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void DeleteRangeRequest::Clear() {
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<DeleteRangeRequest*>(16)->f)

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  if (_has_bits_[0 / 32] & 7u) {
    ZR_(max_entries_to_delete_, return_keys_);
    if (has_header()) {
      if (header_ != NULL) header_->::cockroach::roachpb::Span::Clear();
    }
  }

#undef ZR_HELPER_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool DeleteRangeRequest::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:cockroach.roachpb.DeleteRangeRequest)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .cockroach.roachpb.Span header = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_header()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_max_entries_to_delete;
        break;
      }

      // optional int64 max_entries_to_delete = 2;
      case 2: {
        if (tag == 16) {
         parse_max_entries_to_delete:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &max_entries_to_delete_)));
          set_has_max_entries_to_delete();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_return_keys;
        break;
      }

      // optional bool return_keys = 3;
      case 3: {
        if (tag == 24) {
         parse_return_keys:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &return_keys_)));
          set_has_return_keys();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:cockroach.roachpb.DeleteRangeRequest)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:cockroach.roachpb.DeleteRangeRequest)
  return false;
#undef DO_
}

void DeleteRangeRequest::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:cockroach.roachpb.DeleteRangeRequest)
  // optional .cockroach.roachpb.Span header = 1;
  if (has_header()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->header_, output);
  }

  // optional int64 max_entries_to_delete = 2;
  if (has_max_entries_to_delete()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(2, this->max_entries_to_delete(), output);
  }

  // optional bool return_keys = 3;
  if (has_return_keys()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(3, this->return_keys(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:cockroach.roachpb.DeleteRangeRequest)
}

::google::protobuf::uint8* DeleteRangeRequest::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:cockroach.roachpb.DeleteRangeRequest)
  // optional .cockroach.roachpb.Span header = 1;
  if (has_header()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, *this->header_, target);
  }

  // optional int64 max_entries_to_delete = 2;
  if (has_max_entries_to_delete()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(2, this->max_entries_to_delete(), target);
  }

  // optional bool return_keys = 3;
  if (has_return_keys()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(3, this->return_keys(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:cockroach.roachpb.DeleteRangeRequest)
  return target;
}

int DeleteRangeRequest::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & 7u) {
    // optional .cockroach.roachpb.Span header = 1;
    if (has_header()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->header_);
    }

    // optional int64 max_entries_to_delete = 2;
    if (has_max_entries_to_delete()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->max_entries_to_delete());
    }

    // optional bool return_keys = 3;
    if (has_return_keys()) {
      total_size += 1 + 1;
    }

  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void DeleteRangeRequest::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const DeleteRangeRequest* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const DeleteRangeRequest>(
          &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void DeleteRangeRequest::MergeFrom(const DeleteRangeRequest& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_header()) {
      mutable_header()->::cockroach::roachpb::Span::MergeFrom(from.header());
    }
    if (from.has_max_entries_to_delete()) {
      set_max_entries_to_delete(from.max_entries_to_delete());
    }
    if (from.has_return_keys()) {
      set_return_keys(from.return_keys());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void DeleteRangeRequest::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void DeleteRangeRequest::CopyFrom(const DeleteRangeRequest& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DeleteRangeRequest::IsInitialized() const {

  return true;
}

void DeleteRangeRequest::Swap(DeleteRangeRequest* other) {
  if (other == this) return;
  InternalSwap(other);
}
void DeleteRangeRequest::InternalSwap(DeleteRangeRequest* other) {
  std::swap(header_, other->header_);
  std::swap(max_entries_to_delete_, other->max_entries_to_delete_);
  std::swap(return_keys_, other->return_keys_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata DeleteRangeRequest::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = DeleteRangeRequest_descriptor_;
  metadata.reflection = DeleteRangeRequest_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// DeleteRangeRequest

// optional .cockroach.roachpb.Span header = 1;
bool DeleteRangeRequest::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void DeleteRangeRequest::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
void DeleteRangeRequest::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
void DeleteRangeRequest::clear_header() {
  if (header_ != NULL) header_->::cockroach::roachpb::Span::Clear();
  clear_has_header();
}
const ::cockroach::roachpb::Span& DeleteRangeRequest::header() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.DeleteRangeRequest.header)
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
::cockroach::roachpb::Span* DeleteRangeRequest::mutable_header() {
  set_has_header();
  if (header_ == NULL) {
    header_ = new ::cockroach::roachpb::Span;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.DeleteRangeRequest.header)
  return header_;
}
::cockroach::roachpb::Span* DeleteRangeRequest::release_header() {
  clear_has_header();
  ::cockroach::roachpb::Span* temp = header_;
  header_ = NULL;
  return temp;
}
void DeleteRangeRequest::set_allocated_header(::cockroach::roachpb::Span* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.DeleteRangeRequest.header)
}

// optional int64 max_entries_to_delete = 2;
bool DeleteRangeRequest::has_max_entries_to_delete() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void DeleteRangeRequest::set_has_max_entries_to_delete() {
  _has_bits_[0] |= 0x00000002u;
}
void DeleteRangeRequest::clear_has_max_entries_to_delete() {
  _has_bits_[0] &= ~0x00000002u;
}
void DeleteRangeRequest::clear_max_entries_to_delete() {
  max_entries_to_delete_ = GOOGLE_LONGLONG(0);
  clear_has_max_entries_to_delete();
}
 ::google::protobuf::int64 DeleteRangeRequest::max_entries_to_delete() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.DeleteRangeRequest.max_entries_to_delete)
  return max_entries_to_delete_;
}
 void DeleteRangeRequest::set_max_entries_to_delete(::google::protobuf::int64 value) {
  set_has_max_entries_to_delete();
  max_entries_to_delete_ = value;
  // @@protoc_insertion_point(field_set:cockroach.roachpb.DeleteRangeRequest.max_entries_to_delete)
}

// optional bool return_keys = 3;
bool DeleteRangeRequest::has_return_keys() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void DeleteRangeRequest::set_has_return_keys() {
  _has_bits_[0] |= 0x00000004u;
}
void DeleteRangeRequest::clear_has_return_keys() {
  _has_bits_[0] &= ~0x00000004u;
}
void DeleteRangeRequest::clear_return_keys() {
  return_keys_ = false;
  clear_has_return_keys();
}
 bool DeleteRangeRequest::return_keys() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.DeleteRangeRequest.return_keys)
  return return_keys_;
}
 void DeleteRangeRequest::set_return_keys(bool value) {
  set_has_return_keys();
  return_keys_ = value;
  // @@protoc_insertion_point(field_set:cockroach.roachpb.DeleteRangeRequest.return_keys)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int DeleteRangeResponse::kHeaderFieldNumber;
const int DeleteRangeResponse::kKeysFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

DeleteRangeResponse::DeleteRangeResponse()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:cockroach.roachpb.DeleteRangeResponse)
}

void DeleteRangeResponse::InitAsDefaultInstance() {
  header_ = const_cast< ::cockroach::roachpb::ResponseHeader*>(&::cockroach::roachpb::ResponseHeader::default_instance());
}

DeleteRangeResponse::DeleteRangeResponse(const DeleteRangeResponse& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:cockroach.roachpb.DeleteRangeResponse)
}

void DeleteRangeResponse::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  header_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

DeleteRangeResponse::~DeleteRangeResponse() {
  // @@protoc_insertion_point(destructor:cockroach.roachpb.DeleteRangeResponse)
  SharedDtor();
}

void DeleteRangeResponse::SharedDtor() {
  if (this != default_instance_) {
    delete header_;
  }
}

void DeleteRangeResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* DeleteRangeResponse::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return DeleteRangeResponse_descriptor_;
}

const DeleteRangeResponse& DeleteRangeResponse::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_cockroach_2froachpb_2fapi_2eproto();
  return *default_instance_;
}

DeleteRangeResponse* DeleteRangeResponse::default_instance_ = NULL;

DeleteRangeResponse* DeleteRangeResponse::New(::google::protobuf::Arena* arena) const {
  DeleteRangeResponse* n = new DeleteRangeResponse;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void DeleteRangeResponse::Clear() {
  if (has_header()) {
    if (header_ != NULL) header_->::cockroach::roachpb::ResponseHeader::Clear();
  }
  keys_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool DeleteRangeResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:cockroach.roachpb.DeleteRangeResponse)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .cockroach.roachpb.ResponseHeader header = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_header()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_keys;
        break;
      }

      // repeated bytes keys = 2;
      case 2: {
        if (tag == 18) {
         parse_keys:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->add_keys()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_keys;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:cockroach.roachpb.DeleteRangeResponse)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:cockroach.roachpb.DeleteRangeResponse)
  return false;
#undef DO_
}

void DeleteRangeResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:cockroach.roachpb.DeleteRangeResponse)
  // optional .cockroach.roachpb.ResponseHeader header = 1;
  if (has_header()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->header_, output);
  }

  // repeated bytes keys = 2;
  for (int i = 0; i < this->keys_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      2, this->keys(i), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:cockroach.roachpb.DeleteRangeResponse)
}

::google::protobuf::uint8* DeleteRangeResponse::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:cockroach.roachpb.DeleteRangeResponse)
  // optional .cockroach.roachpb.ResponseHeader header = 1;
  if (has_header()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, *this->header_, target);
  }

  // repeated bytes keys = 2;
  for (int i = 0; i < this->keys_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteBytesToArray(2, this->keys(i), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:cockroach.roachpb.DeleteRangeResponse)
  return target;
}

int DeleteRangeResponse::ByteSize() const {
  int total_size = 0;

  // optional .cockroach.roachpb.ResponseHeader header = 1;
  if (has_header()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->header_);
  }

  // repeated bytes keys = 2;
  total_size += 1 * this->keys_size();
  for (int i = 0; i < this->keys_size(); i++) {
    total_size += ::google::protobuf::internal::WireFormatLite::BytesSize(
      this->keys(i));
  }

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void DeleteRangeResponse::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const DeleteRangeResponse* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const DeleteRangeResponse>(
          &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void DeleteRangeResponse::MergeFrom(const DeleteRangeResponse& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  keys_.MergeFrom(from.keys_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_header()) {
      mutable_header()->::cockroach::roachpb::ResponseHeader::MergeFrom(from.header());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void DeleteRangeResponse::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void DeleteRangeResponse::CopyFrom(const DeleteRangeResponse& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DeleteRangeResponse::IsInitialized() const {

  return true;
}

void DeleteRangeResponse::Swap(DeleteRangeResponse* other) {
  if (other == this) return;
  InternalSwap(other);
}
void DeleteRangeResponse::InternalSwap(DeleteRangeResponse* other) {
  std::swap(header_, other->header_);
  keys_.UnsafeArenaSwap(&other->keys_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata DeleteRangeResponse::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = DeleteRangeResponse_descriptor_;
  metadata.reflection = DeleteRangeResponse_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// DeleteRangeResponse

// optional .cockroach.roachpb.ResponseHeader header = 1;
bool DeleteRangeResponse::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void DeleteRangeResponse::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
void DeleteRangeResponse::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
void DeleteRangeResponse::clear_header() {
  if (header_ != NULL) header_->::cockroach::roachpb::ResponseHeader::Clear();
  clear_has_header();
}
const ::cockroach::roachpb::ResponseHeader& DeleteRangeResponse::header() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.DeleteRangeResponse.header)
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
::cockroach::roachpb::ResponseHeader* DeleteRangeResponse::mutable_header() {
  set_has_header();
  if (header_ == NULL) {
    header_ = new ::cockroach::roachpb::ResponseHeader;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.DeleteRangeResponse.header)
  return header_;
}
::cockroach::roachpb::ResponseHeader* DeleteRangeResponse::release_header() {
  clear_has_header();
  ::cockroach::roachpb::ResponseHeader* temp = header_;
  header_ = NULL;
  return temp;
}
void DeleteRangeResponse::set_allocated_header(::cockroach::roachpb::ResponseHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.DeleteRangeResponse.header)
}

// repeated bytes keys = 2;
int DeleteRangeResponse::keys_size() const {
  return keys_.size();
}
void DeleteRangeResponse::clear_keys() {
  keys_.Clear();
}
 const ::std::string& DeleteRangeResponse::keys(int index) const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.DeleteRangeResponse.keys)
  return keys_.Get(index);
}
 ::std::string* DeleteRangeResponse::mutable_keys(int index) {
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.DeleteRangeResponse.keys)
  return keys_.Mutable(index);
}
 void DeleteRangeResponse::set_keys(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:cockroach.roachpb.DeleteRangeResponse.keys)
  keys_.Mutable(index)->assign(value);
}
 void DeleteRangeResponse::set_keys(int index, const char* value) {
  keys_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:cockroach.roachpb.DeleteRangeResponse.keys)
}
 void DeleteRangeResponse::set_keys(int index, const void* value, size_t size) {
  keys_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:cockroach.roachpb.DeleteRangeResponse.keys)
}
 ::std::string* DeleteRangeResponse::add_keys() {
  return keys_.Add();
}
 void DeleteRangeResponse::add_keys(const ::std::string& value) {
  keys_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:cockroach.roachpb.DeleteRangeResponse.keys)
}
 void DeleteRangeResponse::add_keys(const char* value) {
  keys_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:cockroach.roachpb.DeleteRangeResponse.keys)
}
 void DeleteRangeResponse::add_keys(const void* value, size_t size) {
  keys_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:cockroach.roachpb.DeleteRangeResponse.keys)
}
 const ::google::protobuf::RepeatedPtrField< ::std::string>&
DeleteRangeResponse::keys() const {
  // @@protoc_insertion_point(field_list:cockroach.roachpb.DeleteRangeResponse.keys)
  return keys_;
}
 ::google::protobuf::RepeatedPtrField< ::std::string>*
DeleteRangeResponse::mutable_keys() {
  // @@protoc_insertion_point(field_mutable_list:cockroach.roachpb.DeleteRangeResponse.keys)
  return &keys_;
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int ScanRequest::kHeaderFieldNumber;
const int ScanRequest::kMaxResultsFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

ScanRequest::ScanRequest()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:cockroach.roachpb.ScanRequest)
}

void ScanRequest::InitAsDefaultInstance() {
  header_ = const_cast< ::cockroach::roachpb::Span*>(&::cockroach::roachpb::Span::default_instance());
}

ScanRequest::ScanRequest(const ScanRequest& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:cockroach.roachpb.ScanRequest)
}

void ScanRequest::SharedCtor() {
  _cached_size_ = 0;
  header_ = NULL;
  max_results_ = GOOGLE_LONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ScanRequest::~ScanRequest() {
  // @@protoc_insertion_point(destructor:cockroach.roachpb.ScanRequest)
  SharedDtor();
}

void ScanRequest::SharedDtor() {
  if (this != default_instance_) {
    delete header_;
  }
}

void ScanRequest::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ScanRequest::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ScanRequest_descriptor_;
}

const ScanRequest& ScanRequest::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_cockroach_2froachpb_2fapi_2eproto();
  return *default_instance_;
}

ScanRequest* ScanRequest::default_instance_ = NULL;

ScanRequest* ScanRequest::New(::google::protobuf::Arena* arena) const {
  ScanRequest* n = new ScanRequest;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void ScanRequest::Clear() {
  if (_has_bits_[0 / 32] & 3u) {
    if (has_header()) {
      if (header_ != NULL) header_->::cockroach::roachpb::Span::Clear();
    }
    max_results_ = GOOGLE_LONGLONG(0);
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool ScanRequest::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:cockroach.roachpb.ScanRequest)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .cockroach.roachpb.Span header = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_header()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_max_results;
        break;
      }

      // optional int64 max_results = 2;
      case 2: {
        if (tag == 16) {
         parse_max_results:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &max_results_)));
          set_has_max_results();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:cockroach.roachpb.ScanRequest)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:cockroach.roachpb.ScanRequest)
  return false;
#undef DO_
}

void ScanRequest::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:cockroach.roachpb.ScanRequest)
  // optional .cockroach.roachpb.Span header = 1;
  if (has_header()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->header_, output);
  }

  // optional int64 max_results = 2;
  if (has_max_results()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(2, this->max_results(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:cockroach.roachpb.ScanRequest)
}

::google::protobuf::uint8* ScanRequest::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:cockroach.roachpb.ScanRequest)
  // optional .cockroach.roachpb.Span header = 1;
  if (has_header()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, *this->header_, target);
  }

  // optional int64 max_results = 2;
  if (has_max_results()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(2, this->max_results(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:cockroach.roachpb.ScanRequest)
  return target;
}

int ScanRequest::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & 3u) {
    // optional .cockroach.roachpb.Span header = 1;
    if (has_header()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->header_);
    }

    // optional int64 max_results = 2;
    if (has_max_results()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->max_results());
    }

  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ScanRequest::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const ScanRequest* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const ScanRequest>(
          &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ScanRequest::MergeFrom(const ScanRequest& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_header()) {
      mutable_header()->::cockroach::roachpb::Span::MergeFrom(from.header());
    }
    if (from.has_max_results()) {
      set_max_results(from.max_results());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void ScanRequest::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ScanRequest::CopyFrom(const ScanRequest& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ScanRequest::IsInitialized() const {

  return true;
}

void ScanRequest::Swap(ScanRequest* other) {
  if (other == this) return;
  InternalSwap(other);
}
void ScanRequest::InternalSwap(ScanRequest* other) {
  std::swap(header_, other->header_);
  std::swap(max_results_, other->max_results_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata ScanRequest::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ScanRequest_descriptor_;
  metadata.reflection = ScanRequest_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// ScanRequest

// optional .cockroach.roachpb.Span header = 1;
bool ScanRequest::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void ScanRequest::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
void ScanRequest::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
void ScanRequest::clear_header() {
  if (header_ != NULL) header_->::cockroach::roachpb::Span::Clear();
  clear_has_header();
}
const ::cockroach::roachpb::Span& ScanRequest::header() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.ScanRequest.header)
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
::cockroach::roachpb::Span* ScanRequest::mutable_header() {
  set_has_header();
  if (header_ == NULL) {
    header_ = new ::cockroach::roachpb::Span;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.ScanRequest.header)
  return header_;
}
::cockroach::roachpb::Span* ScanRequest::release_header() {
  clear_has_header();
  ::cockroach::roachpb::Span* temp = header_;
  header_ = NULL;
  return temp;
}
void ScanRequest::set_allocated_header(::cockroach::roachpb::Span* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.ScanRequest.header)
}

// optional int64 max_results = 2;
bool ScanRequest::has_max_results() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void ScanRequest::set_has_max_results() {
  _has_bits_[0] |= 0x00000002u;
}
void ScanRequest::clear_has_max_results() {
  _has_bits_[0] &= ~0x00000002u;
}
void ScanRequest::clear_max_results() {
  max_results_ = GOOGLE_LONGLONG(0);
  clear_has_max_results();
}
 ::google::protobuf::int64 ScanRequest::max_results() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.ScanRequest.max_results)
  return max_results_;
}
 void ScanRequest::set_max_results(::google::protobuf::int64 value) {
  set_has_max_results();
  max_results_ = value;
  // @@protoc_insertion_point(field_set:cockroach.roachpb.ScanRequest.max_results)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int ScanResponse::kHeaderFieldNumber;
const int ScanResponse::kRowsFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

ScanResponse::ScanResponse()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:cockroach.roachpb.ScanResponse)
}

void ScanResponse::InitAsDefaultInstance() {
  header_ = const_cast< ::cockroach::roachpb::ResponseHeader*>(&::cockroach::roachpb::ResponseHeader::default_instance());
}

ScanResponse::ScanResponse(const ScanResponse& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:cockroach.roachpb.ScanResponse)
}

void ScanResponse::SharedCtor() {
  _cached_size_ = 0;
  header_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ScanResponse::~ScanResponse() {
  // @@protoc_insertion_point(destructor:cockroach.roachpb.ScanResponse)
  SharedDtor();
}

void ScanResponse::SharedDtor() {
  if (this != default_instance_) {
    delete header_;
  }
}

void ScanResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ScanResponse::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ScanResponse_descriptor_;
}

const ScanResponse& ScanResponse::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_cockroach_2froachpb_2fapi_2eproto();
  return *default_instance_;
}

ScanResponse* ScanResponse::default_instance_ = NULL;

ScanResponse* ScanResponse::New(::google::protobuf::Arena* arena) const {
  ScanResponse* n = new ScanResponse;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void ScanResponse::Clear() {
  if (has_header()) {
    if (header_ != NULL) header_->::cockroach::roachpb::ResponseHeader::Clear();
  }
  rows_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool ScanResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:cockroach.roachpb.ScanResponse)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .cockroach.roachpb.ResponseHeader header = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_header()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_rows;
        break;
      }

      // repeated .cockroach.roachpb.KeyValue rows = 2;
      case 2: {
        if (tag == 18) {
         parse_rows:
          DO_(input->IncrementRecursionDepth());
         parse_loop_rows:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                input, add_rows()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_loop_rows;
        input->UnsafeDecrementRecursionDepth();
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:cockroach.roachpb.ScanResponse)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:cockroach.roachpb.ScanResponse)
  return false;
#undef DO_
}

void ScanResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:cockroach.roachpb.ScanResponse)
  // optional .cockroach.roachpb.ResponseHeader header = 1;
  if (has_header()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->header_, output);
  }

  // repeated .cockroach.roachpb.KeyValue rows = 2;
  for (unsigned int i = 0, n = this->rows_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->rows(i), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:cockroach.roachpb.ScanResponse)
}

::google::protobuf::uint8* ScanResponse::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:cockroach.roachpb.ScanResponse)
  // optional .cockroach.roachpb.ResponseHeader header = 1;
  if (has_header()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, *this->header_, target);
  }

  // repeated .cockroach.roachpb.KeyValue rows = 2;
  for (unsigned int i = 0, n = this->rows_size(); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->rows(i), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:cockroach.roachpb.ScanResponse)
  return target;
}

int ScanResponse::ByteSize() const {
  int total_size = 0;

  // optional .cockroach.roachpb.ResponseHeader header = 1;
  if (has_header()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->header_);
  }

  // repeated .cockroach.roachpb.KeyValue rows = 2;
  total_size += 1 * this->rows_size();
  for (int i = 0; i < this->rows_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->rows(i));
  }

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ScanResponse::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const ScanResponse* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const ScanResponse>(
          &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ScanResponse::MergeFrom(const ScanResponse& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  rows_.MergeFrom(from.rows_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_header()) {
      mutable_header()->::cockroach::roachpb::ResponseHeader::MergeFrom(from.header());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void ScanResponse::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ScanResponse::CopyFrom(const ScanResponse& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ScanResponse::IsInitialized() const {

  return true;
}

void ScanResponse::Swap(ScanResponse* other) {
  if (other == this) return;
  InternalSwap(other);
}
void ScanResponse::InternalSwap(ScanResponse* other) {
  std::swap(header_, other->header_);
  rows_.UnsafeArenaSwap(&other->rows_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata ScanResponse::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ScanResponse_descriptor_;
  metadata.reflection = ScanResponse_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// ScanResponse

// optional .cockroach.roachpb.ResponseHeader header = 1;
bool ScanResponse::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void ScanResponse::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
void ScanResponse::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
void ScanResponse::clear_header() {
  if (header_ != NULL) header_->::cockroach::roachpb::ResponseHeader::Clear();
  clear_has_header();
}
const ::cockroach::roachpb::ResponseHeader& ScanResponse::header() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.ScanResponse.header)
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
::cockroach::roachpb::ResponseHeader* ScanResponse::mutable_header() {
  set_has_header();
  if (header_ == NULL) {
    header_ = new ::cockroach::roachpb::ResponseHeader;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.ScanResponse.header)
  return header_;
}
::cockroach::roachpb::ResponseHeader* ScanResponse::release_header() {
  clear_has_header();
  ::cockroach::roachpb::ResponseHeader* temp = header_;
  header_ = NULL;
  return temp;
}
void ScanResponse::set_allocated_header(::cockroach::roachpb::ResponseHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.ScanResponse.header)
}

// repeated .cockroach.roachpb.KeyValue rows = 2;
int ScanResponse::rows_size() const {
  return rows_.size();
}
void ScanResponse::clear_rows() {
  rows_.Clear();
}
const ::cockroach::roachpb::KeyValue& ScanResponse::rows(int index) const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.ScanResponse.rows)
  return rows_.Get(index);
}
::cockroach::roachpb::KeyValue* ScanResponse::mutable_rows(int index) {
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.ScanResponse.rows)
  return rows_.Mutable(index);
}
::cockroach::roachpb::KeyValue* ScanResponse::add_rows() {
  // @@protoc_insertion_point(field_add:cockroach.roachpb.ScanResponse.rows)
  return rows_.Add();
}
::google::protobuf::RepeatedPtrField< ::cockroach::roachpb::KeyValue >*
ScanResponse::mutable_rows() {
  // @@protoc_insertion_point(field_mutable_list:cockroach.roachpb.ScanResponse.rows)
  return &rows_;
}
const ::google::protobuf::RepeatedPtrField< ::cockroach::roachpb::KeyValue >&
ScanResponse::rows() const {
  // @@protoc_insertion_point(field_list:cockroach.roachpb.ScanResponse.rows)
  return rows_;
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int ReverseScanRequest::kHeaderFieldNumber;
const int ReverseScanRequest::kMaxResultsFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

ReverseScanRequest::ReverseScanRequest()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:cockroach.roachpb.ReverseScanRequest)
}

void ReverseScanRequest::InitAsDefaultInstance() {
  header_ = const_cast< ::cockroach::roachpb::Span*>(&::cockroach::roachpb::Span::default_instance());
}

ReverseScanRequest::ReverseScanRequest(const ReverseScanRequest& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:cockroach.roachpb.ReverseScanRequest)
}

void ReverseScanRequest::SharedCtor() {
  _cached_size_ = 0;
  header_ = NULL;
  max_results_ = GOOGLE_LONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ReverseScanRequest::~ReverseScanRequest() {
  // @@protoc_insertion_point(destructor:cockroach.roachpb.ReverseScanRequest)
  SharedDtor();
}

void ReverseScanRequest::SharedDtor() {
  if (this != default_instance_) {
    delete header_;
  }
}

void ReverseScanRequest::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ReverseScanRequest::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ReverseScanRequest_descriptor_;
}

const ReverseScanRequest& ReverseScanRequest::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_cockroach_2froachpb_2fapi_2eproto();
  return *default_instance_;
}

ReverseScanRequest* ReverseScanRequest::default_instance_ = NULL;

ReverseScanRequest* ReverseScanRequest::New(::google::protobuf::Arena* arena) const {
  ReverseScanRequest* n = new ReverseScanRequest;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void ReverseScanRequest::Clear() {
  if (_has_bits_[0 / 32] & 3u) {
    if (has_header()) {
      if (header_ != NULL) header_->::cockroach::roachpb::Span::Clear();
    }
    max_results_ = GOOGLE_LONGLONG(0);
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool ReverseScanRequest::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:cockroach.roachpb.ReverseScanRequest)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .cockroach.roachpb.Span header = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_header()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_max_results;
        break;
      }

      // optional int64 max_results = 2;
      case 2: {
        if (tag == 16) {
         parse_max_results:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &max_results_)));
          set_has_max_results();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:cockroach.roachpb.ReverseScanRequest)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:cockroach.roachpb.ReverseScanRequest)
  return false;
#undef DO_
}

void ReverseScanRequest::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:cockroach.roachpb.ReverseScanRequest)
  // optional .cockroach.roachpb.Span header = 1;
  if (has_header()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->header_, output);
  }

  // optional int64 max_results = 2;
  if (has_max_results()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(2, this->max_results(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:cockroach.roachpb.ReverseScanRequest)
}

::google::protobuf::uint8* ReverseScanRequest::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:cockroach.roachpb.ReverseScanRequest)
  // optional .cockroach.roachpb.Span header = 1;
  if (has_header()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, *this->header_, target);
  }

  // optional int64 max_results = 2;
  if (has_max_results()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(2, this->max_results(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:cockroach.roachpb.ReverseScanRequest)
  return target;
}

int ReverseScanRequest::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & 3u) {
    // optional .cockroach.roachpb.Span header = 1;
    if (has_header()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->header_);
    }

    // optional int64 max_results = 2;
    if (has_max_results()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->max_results());
    }

  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ReverseScanRequest::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const ReverseScanRequest* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const ReverseScanRequest>(
          &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ReverseScanRequest::MergeFrom(const ReverseScanRequest& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_header()) {
      mutable_header()->::cockroach::roachpb::Span::MergeFrom(from.header());
    }
    if (from.has_max_results()) {
      set_max_results(from.max_results());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void ReverseScanRequest::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ReverseScanRequest::CopyFrom(const ReverseScanRequest& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ReverseScanRequest::IsInitialized() const {

  return true;
}

void ReverseScanRequest::Swap(ReverseScanRequest* other) {
  if (other == this) return;
  InternalSwap(other);
}
void ReverseScanRequest::InternalSwap(ReverseScanRequest* other) {
  std::swap(header_, other->header_);
  std::swap(max_results_, other->max_results_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata ReverseScanRequest::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ReverseScanRequest_descriptor_;
  metadata.reflection = ReverseScanRequest_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// ReverseScanRequest

// optional .cockroach.roachpb.Span header = 1;
bool ReverseScanRequest::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void ReverseScanRequest::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
void ReverseScanRequest::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
void ReverseScanRequest::clear_header() {
  if (header_ != NULL) header_->::cockroach::roachpb::Span::Clear();
  clear_has_header();
}
const ::cockroach::roachpb::Span& ReverseScanRequest::header() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.ReverseScanRequest.header)
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
::cockroach::roachpb::Span* ReverseScanRequest::mutable_header() {
  set_has_header();
  if (header_ == NULL) {
    header_ = new ::cockroach::roachpb::Span;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.ReverseScanRequest.header)
  return header_;
}
::cockroach::roachpb::Span* ReverseScanRequest::release_header() {
  clear_has_header();
  ::cockroach::roachpb::Span* temp = header_;
  header_ = NULL;
  return temp;
}
void ReverseScanRequest::set_allocated_header(::cockroach::roachpb::Span* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.ReverseScanRequest.header)
}

// optional int64 max_results = 2;
bool ReverseScanRequest::has_max_results() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void ReverseScanRequest::set_has_max_results() {
  _has_bits_[0] |= 0x00000002u;
}
void ReverseScanRequest::clear_has_max_results() {
  _has_bits_[0] &= ~0x00000002u;
}
void ReverseScanRequest::clear_max_results() {
  max_results_ = GOOGLE_LONGLONG(0);
  clear_has_max_results();
}
 ::google::protobuf::int64 ReverseScanRequest::max_results() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.ReverseScanRequest.max_results)
  return max_results_;
}
 void ReverseScanRequest::set_max_results(::google::protobuf::int64 value) {
  set_has_max_results();
  max_results_ = value;
  // @@protoc_insertion_point(field_set:cockroach.roachpb.ReverseScanRequest.max_results)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int ReverseScanResponse::kHeaderFieldNumber;
const int ReverseScanResponse::kRowsFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

ReverseScanResponse::ReverseScanResponse()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:cockroach.roachpb.ReverseScanResponse)
}

void ReverseScanResponse::InitAsDefaultInstance() {
  header_ = const_cast< ::cockroach::roachpb::ResponseHeader*>(&::cockroach::roachpb::ResponseHeader::default_instance());
}

ReverseScanResponse::ReverseScanResponse(const ReverseScanResponse& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:cockroach.roachpb.ReverseScanResponse)
}

void ReverseScanResponse::SharedCtor() {
  _cached_size_ = 0;
  header_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ReverseScanResponse::~ReverseScanResponse() {
  // @@protoc_insertion_point(destructor:cockroach.roachpb.ReverseScanResponse)
  SharedDtor();
}

void ReverseScanResponse::SharedDtor() {
  if (this != default_instance_) {
    delete header_;
  }
}

void ReverseScanResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ReverseScanResponse::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ReverseScanResponse_descriptor_;
}

const ReverseScanResponse& ReverseScanResponse::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_cockroach_2froachpb_2fapi_2eproto();
  return *default_instance_;
}

ReverseScanResponse* ReverseScanResponse::default_instance_ = NULL;

ReverseScanResponse* ReverseScanResponse::New(::google::protobuf::Arena* arena) const {
  ReverseScanResponse* n = new ReverseScanResponse;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void ReverseScanResponse::Clear() {
  if (has_header()) {
    if (header_ != NULL) header_->::cockroach::roachpb::ResponseHeader::Clear();
  }
  rows_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool ReverseScanResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:cockroach.roachpb.ReverseScanResponse)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .cockroach.roachpb.ResponseHeader header = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_header()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_rows;
        break;
      }

      // repeated .cockroach.roachpb.KeyValue rows = 2;
      case 2: {
        if (tag == 18) {
         parse_rows:
          DO_(input->IncrementRecursionDepth());
         parse_loop_rows:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                input, add_rows()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_loop_rows;
        input->UnsafeDecrementRecursionDepth();
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:cockroach.roachpb.ReverseScanResponse)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:cockroach.roachpb.ReverseScanResponse)
  return false;
#undef DO_
}

void ReverseScanResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:cockroach.roachpb.ReverseScanResponse)
  // optional .cockroach.roachpb.ResponseHeader header = 1;
  if (has_header()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->header_, output);
  }

  // repeated .cockroach.roachpb.KeyValue rows = 2;
  for (unsigned int i = 0, n = this->rows_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->rows(i), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:cockroach.roachpb.ReverseScanResponse)
}

::google::protobuf::uint8* ReverseScanResponse::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:cockroach.roachpb.ReverseScanResponse)
  // optional .cockroach.roachpb.ResponseHeader header = 1;
  if (has_header()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, *this->header_, target);
  }

  // repeated .cockroach.roachpb.KeyValue rows = 2;
  for (unsigned int i = 0, n = this->rows_size(); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->rows(i), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:cockroach.roachpb.ReverseScanResponse)
  return target;
}

int ReverseScanResponse::ByteSize() const {
  int total_size = 0;

  // optional .cockroach.roachpb.ResponseHeader header = 1;
  if (has_header()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->header_);
  }

  // repeated .cockroach.roachpb.KeyValue rows = 2;
  total_size += 1 * this->rows_size();
  for (int i = 0; i < this->rows_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->rows(i));
  }

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ReverseScanResponse::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const ReverseScanResponse* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const ReverseScanResponse>(
          &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ReverseScanResponse::MergeFrom(const ReverseScanResponse& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  rows_.MergeFrom(from.rows_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_header()) {
      mutable_header()->::cockroach::roachpb::ResponseHeader::MergeFrom(from.header());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void ReverseScanResponse::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ReverseScanResponse::CopyFrom(const ReverseScanResponse& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ReverseScanResponse::IsInitialized() const {

  return true;
}

void ReverseScanResponse::Swap(ReverseScanResponse* other) {
  if (other == this) return;
  InternalSwap(other);
}
void ReverseScanResponse::InternalSwap(ReverseScanResponse* other) {
  std::swap(header_, other->header_);
  rows_.UnsafeArenaSwap(&other->rows_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata ReverseScanResponse::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ReverseScanResponse_descriptor_;
  metadata.reflection = ReverseScanResponse_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// ReverseScanResponse

// optional .cockroach.roachpb.ResponseHeader header = 1;
bool ReverseScanResponse::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void ReverseScanResponse::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
void ReverseScanResponse::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
void ReverseScanResponse::clear_header() {
  if (header_ != NULL) header_->::cockroach::roachpb::ResponseHeader::Clear();
  clear_has_header();
}
const ::cockroach::roachpb::ResponseHeader& ReverseScanResponse::header() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.ReverseScanResponse.header)
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
::cockroach::roachpb::ResponseHeader* ReverseScanResponse::mutable_header() {
  set_has_header();
  if (header_ == NULL) {
    header_ = new ::cockroach::roachpb::ResponseHeader;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.ReverseScanResponse.header)
  return header_;
}
::cockroach::roachpb::ResponseHeader* ReverseScanResponse::release_header() {
  clear_has_header();
  ::cockroach::roachpb::ResponseHeader* temp = header_;
  header_ = NULL;
  return temp;
}
void ReverseScanResponse::set_allocated_header(::cockroach::roachpb::ResponseHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.ReverseScanResponse.header)
}

// repeated .cockroach.roachpb.KeyValue rows = 2;
int ReverseScanResponse::rows_size() const {
  return rows_.size();
}
void ReverseScanResponse::clear_rows() {
  rows_.Clear();
}
const ::cockroach::roachpb::KeyValue& ReverseScanResponse::rows(int index) const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.ReverseScanResponse.rows)
  return rows_.Get(index);
}
::cockroach::roachpb::KeyValue* ReverseScanResponse::mutable_rows(int index) {
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.ReverseScanResponse.rows)
  return rows_.Mutable(index);
}
::cockroach::roachpb::KeyValue* ReverseScanResponse::add_rows() {
  // @@protoc_insertion_point(field_add:cockroach.roachpb.ReverseScanResponse.rows)
  return rows_.Add();
}
::google::protobuf::RepeatedPtrField< ::cockroach::roachpb::KeyValue >*
ReverseScanResponse::mutable_rows() {
  // @@protoc_insertion_point(field_mutable_list:cockroach.roachpb.ReverseScanResponse.rows)
  return &rows_;
}
const ::google::protobuf::RepeatedPtrField< ::cockroach::roachpb::KeyValue >&
ReverseScanResponse::rows() const {
  // @@protoc_insertion_point(field_list:cockroach.roachpb.ReverseScanResponse.rows)
  return rows_;
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int CheckConsistencyRequest::kHeaderFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

CheckConsistencyRequest::CheckConsistencyRequest()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:cockroach.roachpb.CheckConsistencyRequest)
}

void CheckConsistencyRequest::InitAsDefaultInstance() {
  header_ = const_cast< ::cockroach::roachpb::Span*>(&::cockroach::roachpb::Span::default_instance());
}

CheckConsistencyRequest::CheckConsistencyRequest(const CheckConsistencyRequest& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:cockroach.roachpb.CheckConsistencyRequest)
}

void CheckConsistencyRequest::SharedCtor() {
  _cached_size_ = 0;
  header_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CheckConsistencyRequest::~CheckConsistencyRequest() {
  // @@protoc_insertion_point(destructor:cockroach.roachpb.CheckConsistencyRequest)
  SharedDtor();
}

void CheckConsistencyRequest::SharedDtor() {
  if (this != default_instance_) {
    delete header_;
  }
}

void CheckConsistencyRequest::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* CheckConsistencyRequest::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return CheckConsistencyRequest_descriptor_;
}

const CheckConsistencyRequest& CheckConsistencyRequest::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_cockroach_2froachpb_2fapi_2eproto();
  return *default_instance_;
}

CheckConsistencyRequest* CheckConsistencyRequest::default_instance_ = NULL;

CheckConsistencyRequest* CheckConsistencyRequest::New(::google::protobuf::Arena* arena) const {
  CheckConsistencyRequest* n = new CheckConsistencyRequest;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void CheckConsistencyRequest::Clear() {
  if (has_header()) {
    if (header_ != NULL) header_->::cockroach::roachpb::Span::Clear();
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool CheckConsistencyRequest::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:cockroach.roachpb.CheckConsistencyRequest)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .cockroach.roachpb.Span header = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_header()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:cockroach.roachpb.CheckConsistencyRequest)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:cockroach.roachpb.CheckConsistencyRequest)
  return false;
#undef DO_
}

void CheckConsistencyRequest::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:cockroach.roachpb.CheckConsistencyRequest)
  // optional .cockroach.roachpb.Span header = 1;
  if (has_header()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->header_, output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:cockroach.roachpb.CheckConsistencyRequest)
}

::google::protobuf::uint8* CheckConsistencyRequest::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:cockroach.roachpb.CheckConsistencyRequest)
  // optional .cockroach.roachpb.Span header = 1;
  if (has_header()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, *this->header_, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:cockroach.roachpb.CheckConsistencyRequest)
  return target;
}

int CheckConsistencyRequest::ByteSize() const {
  int total_size = 0;

  // optional .cockroach.roachpb.Span header = 1;
  if (has_header()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->header_);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CheckConsistencyRequest::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const CheckConsistencyRequest* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const CheckConsistencyRequest>(
          &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void CheckConsistencyRequest::MergeFrom(const CheckConsistencyRequest& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_header()) {
      mutable_header()->::cockroach::roachpb::Span::MergeFrom(from.header());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void CheckConsistencyRequest::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CheckConsistencyRequest::CopyFrom(const CheckConsistencyRequest& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CheckConsistencyRequest::IsInitialized() const {

  return true;
}

void CheckConsistencyRequest::Swap(CheckConsistencyRequest* other) {
  if (other == this) return;
  InternalSwap(other);
}
void CheckConsistencyRequest::InternalSwap(CheckConsistencyRequest* other) {
  std::swap(header_, other->header_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata CheckConsistencyRequest::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = CheckConsistencyRequest_descriptor_;
  metadata.reflection = CheckConsistencyRequest_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// CheckConsistencyRequest

// optional .cockroach.roachpb.Span header = 1;
bool CheckConsistencyRequest::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void CheckConsistencyRequest::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
void CheckConsistencyRequest::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
void CheckConsistencyRequest::clear_header() {
  if (header_ != NULL) header_->::cockroach::roachpb::Span::Clear();
  clear_has_header();
}
const ::cockroach::roachpb::Span& CheckConsistencyRequest::header() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.CheckConsistencyRequest.header)
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
::cockroach::roachpb::Span* CheckConsistencyRequest::mutable_header() {
  set_has_header();
  if (header_ == NULL) {
    header_ = new ::cockroach::roachpb::Span;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.CheckConsistencyRequest.header)
  return header_;
}
::cockroach::roachpb::Span* CheckConsistencyRequest::release_header() {
  clear_has_header();
  ::cockroach::roachpb::Span* temp = header_;
  header_ = NULL;
  return temp;
}
void CheckConsistencyRequest::set_allocated_header(::cockroach::roachpb::Span* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.CheckConsistencyRequest.header)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int CheckConsistencyResponse::kHeaderFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

CheckConsistencyResponse::CheckConsistencyResponse()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:cockroach.roachpb.CheckConsistencyResponse)
}

void CheckConsistencyResponse::InitAsDefaultInstance() {
  header_ = const_cast< ::cockroach::roachpb::ResponseHeader*>(&::cockroach::roachpb::ResponseHeader::default_instance());
}

CheckConsistencyResponse::CheckConsistencyResponse(const CheckConsistencyResponse& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:cockroach.roachpb.CheckConsistencyResponse)
}

void CheckConsistencyResponse::SharedCtor() {
  _cached_size_ = 0;
  header_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CheckConsistencyResponse::~CheckConsistencyResponse() {
  // @@protoc_insertion_point(destructor:cockroach.roachpb.CheckConsistencyResponse)
  SharedDtor();
}

void CheckConsistencyResponse::SharedDtor() {
  if (this != default_instance_) {
    delete header_;
  }
}

void CheckConsistencyResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* CheckConsistencyResponse::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return CheckConsistencyResponse_descriptor_;
}

const CheckConsistencyResponse& CheckConsistencyResponse::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_cockroach_2froachpb_2fapi_2eproto();
  return *default_instance_;
}

CheckConsistencyResponse* CheckConsistencyResponse::default_instance_ = NULL;

CheckConsistencyResponse* CheckConsistencyResponse::New(::google::protobuf::Arena* arena) const {
  CheckConsistencyResponse* n = new CheckConsistencyResponse;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void CheckConsistencyResponse::Clear() {
  if (has_header()) {
    if (header_ != NULL) header_->::cockroach::roachpb::ResponseHeader::Clear();
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool CheckConsistencyResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:cockroach.roachpb.CheckConsistencyResponse)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .cockroach.roachpb.ResponseHeader header = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_header()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:cockroach.roachpb.CheckConsistencyResponse)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:cockroach.roachpb.CheckConsistencyResponse)
  return false;
#undef DO_
}

void CheckConsistencyResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:cockroach.roachpb.CheckConsistencyResponse)
  // optional .cockroach.roachpb.ResponseHeader header = 1;
  if (has_header()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->header_, output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:cockroach.roachpb.CheckConsistencyResponse)
}

::google::protobuf::uint8* CheckConsistencyResponse::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:cockroach.roachpb.CheckConsistencyResponse)
  // optional .cockroach.roachpb.ResponseHeader header = 1;
  if (has_header()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, *this->header_, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:cockroach.roachpb.CheckConsistencyResponse)
  return target;
}

int CheckConsistencyResponse::ByteSize() const {
  int total_size = 0;

  // optional .cockroach.roachpb.ResponseHeader header = 1;
  if (has_header()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->header_);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CheckConsistencyResponse::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const CheckConsistencyResponse* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const CheckConsistencyResponse>(
          &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void CheckConsistencyResponse::MergeFrom(const CheckConsistencyResponse& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_header()) {
      mutable_header()->::cockroach::roachpb::ResponseHeader::MergeFrom(from.header());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void CheckConsistencyResponse::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CheckConsistencyResponse::CopyFrom(const CheckConsistencyResponse& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CheckConsistencyResponse::IsInitialized() const {

  return true;
}

void CheckConsistencyResponse::Swap(CheckConsistencyResponse* other) {
  if (other == this) return;
  InternalSwap(other);
}
void CheckConsistencyResponse::InternalSwap(CheckConsistencyResponse* other) {
  std::swap(header_, other->header_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata CheckConsistencyResponse::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = CheckConsistencyResponse_descriptor_;
  metadata.reflection = CheckConsistencyResponse_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// CheckConsistencyResponse

// optional .cockroach.roachpb.ResponseHeader header = 1;
bool CheckConsistencyResponse::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void CheckConsistencyResponse::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
void CheckConsistencyResponse::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
void CheckConsistencyResponse::clear_header() {
  if (header_ != NULL) header_->::cockroach::roachpb::ResponseHeader::Clear();
  clear_has_header();
}
const ::cockroach::roachpb::ResponseHeader& CheckConsistencyResponse::header() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.CheckConsistencyResponse.header)
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
::cockroach::roachpb::ResponseHeader* CheckConsistencyResponse::mutable_header() {
  set_has_header();
  if (header_ == NULL) {
    header_ = new ::cockroach::roachpb::ResponseHeader;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.CheckConsistencyResponse.header)
  return header_;
}
::cockroach::roachpb::ResponseHeader* CheckConsistencyResponse::release_header() {
  clear_has_header();
  ::cockroach::roachpb::ResponseHeader* temp = header_;
  header_ = NULL;
  return temp;
}
void CheckConsistencyResponse::set_allocated_header(::cockroach::roachpb::ResponseHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.CheckConsistencyResponse.header)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int BeginTransactionRequest::kHeaderFieldNumber;
const int BeginTransactionRequest::kHeartbeatIntervalFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

BeginTransactionRequest::BeginTransactionRequest()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:cockroach.roachpb.BeginTransactionRequest)
}

void BeginTransactionRequest::InitAsDefaultInstance() {
  header_ = const_cast< ::cockroach::roachpb::Span*>(&::cockroach::roachpb::Span::default_instance());
}

BeginTransactionRequest::BeginTransactionRequest(const BeginTransactionRequest& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:cockroach.roachpb.BeginTransactionRequest)
}

void BeginTransactionRequest::SharedCtor() {
  _cached_size_ = 0;
  header_ = NULL;
  heartbeat_interval_ = GOOGLE_LONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

BeginTransactionRequest::~BeginTransactionRequest() {
  // @@protoc_insertion_point(destructor:cockroach.roachpb.BeginTransactionRequest)
  SharedDtor();
}

void BeginTransactionRequest::SharedDtor() {
  if (this != default_instance_) {
    delete header_;
  }
}

void BeginTransactionRequest::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* BeginTransactionRequest::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return BeginTransactionRequest_descriptor_;
}

const BeginTransactionRequest& BeginTransactionRequest::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_cockroach_2froachpb_2fapi_2eproto();
  return *default_instance_;
}

BeginTransactionRequest* BeginTransactionRequest::default_instance_ = NULL;

BeginTransactionRequest* BeginTransactionRequest::New(::google::protobuf::Arena* arena) const {
  BeginTransactionRequest* n = new BeginTransactionRequest;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void BeginTransactionRequest::Clear() {
  if (_has_bits_[0 / 32] & 3u) {
    if (has_header()) {
      if (header_ != NULL) header_->::cockroach::roachpb::Span::Clear();
    }
    heartbeat_interval_ = GOOGLE_LONGLONG(0);
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool BeginTransactionRequest::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:cockroach.roachpb.BeginTransactionRequest)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .cockroach.roachpb.Span header = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_header()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_heartbeat_interval;
        break;
      }

      // optional int64 heartbeat_interval = 2;
      case 2: {
        if (tag == 16) {
         parse_heartbeat_interval:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &heartbeat_interval_)));
          set_has_heartbeat_interval();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:cockroach.roachpb.BeginTransactionRequest)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:cockroach.roachpb.BeginTransactionRequest)
  return false;
#undef DO_
}

void BeginTransactionRequest::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:cockroach.roachpb.BeginTransactionRequest)
  // optional .cockroach.roachpb.Span header = 1;
  if (has_header()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->header_, output);
  }

  // optional int64 heartbeat_interval = 2;
  if (has_heartbeat_interval()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(2, this->heartbeat_interval(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:cockroach.roachpb.BeginTransactionRequest)
}

::google::protobuf::uint8* BeginTransactionRequest::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:cockroach.roachpb.BeginTransactionRequest)
  // optional .cockroach.roachpb.Span header = 1;
  if (has_header()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, *this->header_, target);
  }

  // optional int64 heartbeat_interval = 2;
  if (has_heartbeat_interval()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(2, this->heartbeat_interval(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:cockroach.roachpb.BeginTransactionRequest)
  return target;
}

int BeginTransactionRequest::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & 3u) {
    // optional .cockroach.roachpb.Span header = 1;
    if (has_header()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->header_);
    }

    // optional int64 heartbeat_interval = 2;
    if (has_heartbeat_interval()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->heartbeat_interval());
    }

  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void BeginTransactionRequest::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const BeginTransactionRequest* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const BeginTransactionRequest>(
          &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void BeginTransactionRequest::MergeFrom(const BeginTransactionRequest& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_header()) {
      mutable_header()->::cockroach::roachpb::Span::MergeFrom(from.header());
    }
    if (from.has_heartbeat_interval()) {
      set_heartbeat_interval(from.heartbeat_interval());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void BeginTransactionRequest::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void BeginTransactionRequest::CopyFrom(const BeginTransactionRequest& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BeginTransactionRequest::IsInitialized() const {

  return true;
}

void BeginTransactionRequest::Swap(BeginTransactionRequest* other) {
  if (other == this) return;
  InternalSwap(other);
}
void BeginTransactionRequest::InternalSwap(BeginTransactionRequest* other) {
  std::swap(header_, other->header_);
  std::swap(heartbeat_interval_, other->heartbeat_interval_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata BeginTransactionRequest::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = BeginTransactionRequest_descriptor_;
  metadata.reflection = BeginTransactionRequest_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// BeginTransactionRequest

// optional .cockroach.roachpb.Span header = 1;
bool BeginTransactionRequest::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void BeginTransactionRequest::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
void BeginTransactionRequest::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
void BeginTransactionRequest::clear_header() {
  if (header_ != NULL) header_->::cockroach::roachpb::Span::Clear();
  clear_has_header();
}
const ::cockroach::roachpb::Span& BeginTransactionRequest::header() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.BeginTransactionRequest.header)
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
::cockroach::roachpb::Span* BeginTransactionRequest::mutable_header() {
  set_has_header();
  if (header_ == NULL) {
    header_ = new ::cockroach::roachpb::Span;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.BeginTransactionRequest.header)
  return header_;
}
::cockroach::roachpb::Span* BeginTransactionRequest::release_header() {
  clear_has_header();
  ::cockroach::roachpb::Span* temp = header_;
  header_ = NULL;
  return temp;
}
void BeginTransactionRequest::set_allocated_header(::cockroach::roachpb::Span* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.BeginTransactionRequest.header)
}

// optional int64 heartbeat_interval = 2;
bool BeginTransactionRequest::has_heartbeat_interval() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void BeginTransactionRequest::set_has_heartbeat_interval() {
  _has_bits_[0] |= 0x00000002u;
}
void BeginTransactionRequest::clear_has_heartbeat_interval() {
  _has_bits_[0] &= ~0x00000002u;
}
void BeginTransactionRequest::clear_heartbeat_interval() {
  heartbeat_interval_ = GOOGLE_LONGLONG(0);
  clear_has_heartbeat_interval();
}
 ::google::protobuf::int64 BeginTransactionRequest::heartbeat_interval() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.BeginTransactionRequest.heartbeat_interval)
  return heartbeat_interval_;
}
 void BeginTransactionRequest::set_heartbeat_interval(::google::protobuf::int64 value) {
  set_has_heartbeat_interval();
  heartbeat_interval_ = value;
  // @@protoc_insertion_point(field_set:cockroach.roachpb.BeginTransactionRequest.heartbeat_interval)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int BeginTransactionResponse::kHeaderFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

BeginTransactionResponse::BeginTransactionResponse()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:cockroach.roachpb.BeginTransactionResponse)
}

void BeginTransactionResponse::InitAsDefaultInstance() {
  header_ = const_cast< ::cockroach::roachpb::ResponseHeader*>(&::cockroach::roachpb::ResponseHeader::default_instance());
}

BeginTransactionResponse::BeginTransactionResponse(const BeginTransactionResponse& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:cockroach.roachpb.BeginTransactionResponse)
}

void BeginTransactionResponse::SharedCtor() {
  _cached_size_ = 0;
  header_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

BeginTransactionResponse::~BeginTransactionResponse() {
  // @@protoc_insertion_point(destructor:cockroach.roachpb.BeginTransactionResponse)
  SharedDtor();
}

void BeginTransactionResponse::SharedDtor() {
  if (this != default_instance_) {
    delete header_;
  }
}

void BeginTransactionResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* BeginTransactionResponse::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return BeginTransactionResponse_descriptor_;
}

const BeginTransactionResponse& BeginTransactionResponse::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_cockroach_2froachpb_2fapi_2eproto();
  return *default_instance_;
}

BeginTransactionResponse* BeginTransactionResponse::default_instance_ = NULL;

BeginTransactionResponse* BeginTransactionResponse::New(::google::protobuf::Arena* arena) const {
  BeginTransactionResponse* n = new BeginTransactionResponse;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void BeginTransactionResponse::Clear() {
  if (has_header()) {
    if (header_ != NULL) header_->::cockroach::roachpb::ResponseHeader::Clear();
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool BeginTransactionResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:cockroach.roachpb.BeginTransactionResponse)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .cockroach.roachpb.ResponseHeader header = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_header()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:cockroach.roachpb.BeginTransactionResponse)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:cockroach.roachpb.BeginTransactionResponse)
  return false;
#undef DO_
}

void BeginTransactionResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:cockroach.roachpb.BeginTransactionResponse)
  // optional .cockroach.roachpb.ResponseHeader header = 1;
  if (has_header()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->header_, output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:cockroach.roachpb.BeginTransactionResponse)
}

::google::protobuf::uint8* BeginTransactionResponse::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:cockroach.roachpb.BeginTransactionResponse)
  // optional .cockroach.roachpb.ResponseHeader header = 1;
  if (has_header()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, *this->header_, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:cockroach.roachpb.BeginTransactionResponse)
  return target;
}

int BeginTransactionResponse::ByteSize() const {
  int total_size = 0;

  // optional .cockroach.roachpb.ResponseHeader header = 1;
  if (has_header()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->header_);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void BeginTransactionResponse::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const BeginTransactionResponse* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const BeginTransactionResponse>(
          &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void BeginTransactionResponse::MergeFrom(const BeginTransactionResponse& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_header()) {
      mutable_header()->::cockroach::roachpb::ResponseHeader::MergeFrom(from.header());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void BeginTransactionResponse::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void BeginTransactionResponse::CopyFrom(const BeginTransactionResponse& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BeginTransactionResponse::IsInitialized() const {

  return true;
}

void BeginTransactionResponse::Swap(BeginTransactionResponse* other) {
  if (other == this) return;
  InternalSwap(other);
}
void BeginTransactionResponse::InternalSwap(BeginTransactionResponse* other) {
  std::swap(header_, other->header_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata BeginTransactionResponse::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = BeginTransactionResponse_descriptor_;
  metadata.reflection = BeginTransactionResponse_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// BeginTransactionResponse

// optional .cockroach.roachpb.ResponseHeader header = 1;
bool BeginTransactionResponse::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void BeginTransactionResponse::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
void BeginTransactionResponse::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
void BeginTransactionResponse::clear_header() {
  if (header_ != NULL) header_->::cockroach::roachpb::ResponseHeader::Clear();
  clear_has_header();
}
const ::cockroach::roachpb::ResponseHeader& BeginTransactionResponse::header() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.BeginTransactionResponse.header)
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
::cockroach::roachpb::ResponseHeader* BeginTransactionResponse::mutable_header() {
  set_has_header();
  if (header_ == NULL) {
    header_ = new ::cockroach::roachpb::ResponseHeader;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.BeginTransactionResponse.header)
  return header_;
}
::cockroach::roachpb::ResponseHeader* BeginTransactionResponse::release_header() {
  clear_has_header();
  ::cockroach::roachpb::ResponseHeader* temp = header_;
  header_ = NULL;
  return temp;
}
void BeginTransactionResponse::set_allocated_header(::cockroach::roachpb::ResponseHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.BeginTransactionResponse.header)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int EndTransactionRequest::kHeaderFieldNumber;
const int EndTransactionRequest::kCommitFieldNumber;
const int EndTransactionRequest::kDeadlineFieldNumber;
const int EndTransactionRequest::kInternalCommitTriggerFieldNumber;
const int EndTransactionRequest::kIntentSpansFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

EndTransactionRequest::EndTransactionRequest()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:cockroach.roachpb.EndTransactionRequest)
}

void EndTransactionRequest::InitAsDefaultInstance() {
  header_ = const_cast< ::cockroach::roachpb::Span*>(&::cockroach::roachpb::Span::default_instance());
  deadline_ = const_cast< ::cockroach::roachpb::Timestamp*>(&::cockroach::roachpb::Timestamp::default_instance());
  internal_commit_trigger_ = const_cast< ::cockroach::roachpb::InternalCommitTrigger*>(&::cockroach::roachpb::InternalCommitTrigger::default_instance());
}

EndTransactionRequest::EndTransactionRequest(const EndTransactionRequest& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:cockroach.roachpb.EndTransactionRequest)
}

void EndTransactionRequest::SharedCtor() {
  _cached_size_ = 0;
  header_ = NULL;
  commit_ = false;
  deadline_ = NULL;
  internal_commit_trigger_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

EndTransactionRequest::~EndTransactionRequest() {
  // @@protoc_insertion_point(destructor:cockroach.roachpb.EndTransactionRequest)
  SharedDtor();
}

void EndTransactionRequest::SharedDtor() {
  if (this != default_instance_) {
    delete header_;
    delete deadline_;
    delete internal_commit_trigger_;
  }
}

void EndTransactionRequest::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* EndTransactionRequest::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return EndTransactionRequest_descriptor_;
}

const EndTransactionRequest& EndTransactionRequest::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_cockroach_2froachpb_2fapi_2eproto();
  return *default_instance_;
}

EndTransactionRequest* EndTransactionRequest::default_instance_ = NULL;

EndTransactionRequest* EndTransactionRequest::New(::google::protobuf::Arena* arena) const {
  EndTransactionRequest* n = new EndTransactionRequest;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void EndTransactionRequest::Clear() {
  if (_has_bits_[0 / 32] & 15u) {
    if (has_header()) {
      if (header_ != NULL) header_->::cockroach::roachpb::Span::Clear();
    }
    commit_ = false;
    if (has_deadline()) {
      if (deadline_ != NULL) deadline_->::cockroach::roachpb::Timestamp::Clear();
    }
    if (has_internal_commit_trigger()) {
      if (internal_commit_trigger_ != NULL) internal_commit_trigger_->::cockroach::roachpb::InternalCommitTrigger::Clear();
    }
  }
  intent_spans_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool EndTransactionRequest::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:cockroach.roachpb.EndTransactionRequest)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .cockroach.roachpb.Span header = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_header()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_commit;
        break;
      }

      // optional bool commit = 2;
      case 2: {
        if (tag == 16) {
         parse_commit:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &commit_)));
          set_has_commit();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_deadline;
        break;
      }

      // optional .cockroach.roachpb.Timestamp deadline = 3;
      case 3: {
        if (tag == 26) {
         parse_deadline:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_deadline()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_internal_commit_trigger;
        break;
      }

      // optional .cockroach.roachpb.InternalCommitTrigger internal_commit_trigger = 4;
      case 4: {
        if (tag == 34) {
         parse_internal_commit_trigger:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_internal_commit_trigger()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_intent_spans;
        break;
      }

      // repeated .cockroach.roachpb.Span intent_spans = 5;
      case 5: {
        if (tag == 42) {
         parse_intent_spans:
          DO_(input->IncrementRecursionDepth());
         parse_loop_intent_spans:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                input, add_intent_spans()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_loop_intent_spans;
        input->UnsafeDecrementRecursionDepth();
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:cockroach.roachpb.EndTransactionRequest)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:cockroach.roachpb.EndTransactionRequest)
  return false;
#undef DO_
}

void EndTransactionRequest::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:cockroach.roachpb.EndTransactionRequest)
  // optional .cockroach.roachpb.Span header = 1;
  if (has_header()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->header_, output);
  }

  // optional bool commit = 2;
  if (has_commit()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(2, this->commit(), output);
  }

  // optional .cockroach.roachpb.Timestamp deadline = 3;
  if (has_deadline()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, *this->deadline_, output);
  }

  // optional .cockroach.roachpb.InternalCommitTrigger internal_commit_trigger = 4;
  if (has_internal_commit_trigger()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, *this->internal_commit_trigger_, output);
  }

  // repeated .cockroach.roachpb.Span intent_spans = 5;
  for (unsigned int i = 0, n = this->intent_spans_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      5, this->intent_spans(i), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:cockroach.roachpb.EndTransactionRequest)
}

::google::protobuf::uint8* EndTransactionRequest::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:cockroach.roachpb.EndTransactionRequest)
  // optional .cockroach.roachpb.Span header = 1;
  if (has_header()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, *this->header_, target);
  }

  // optional bool commit = 2;
  if (has_commit()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(2, this->commit(), target);
  }

  // optional .cockroach.roachpb.Timestamp deadline = 3;
  if (has_deadline()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, *this->deadline_, target);
  }

  // optional .cockroach.roachpb.InternalCommitTrigger internal_commit_trigger = 4;
  if (has_internal_commit_trigger()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        4, *this->internal_commit_trigger_, target);
  }

  // repeated .cockroach.roachpb.Span intent_spans = 5;
  for (unsigned int i = 0, n = this->intent_spans_size(); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        5, this->intent_spans(i), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:cockroach.roachpb.EndTransactionRequest)
  return target;
}

int EndTransactionRequest::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & 15u) {
    // optional .cockroach.roachpb.Span header = 1;
    if (has_header()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->header_);
    }

    // optional bool commit = 2;
    if (has_commit()) {
      total_size += 1 + 1;
    }

    // optional .cockroach.roachpb.Timestamp deadline = 3;
    if (has_deadline()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->deadline_);
    }

    // optional .cockroach.roachpb.InternalCommitTrigger internal_commit_trigger = 4;
    if (has_internal_commit_trigger()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->internal_commit_trigger_);
    }

  }
  // repeated .cockroach.roachpb.Span intent_spans = 5;
  total_size += 1 * this->intent_spans_size();
  for (int i = 0; i < this->intent_spans_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->intent_spans(i));
  }

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void EndTransactionRequest::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const EndTransactionRequest* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const EndTransactionRequest>(
          &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void EndTransactionRequest::MergeFrom(const EndTransactionRequest& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  intent_spans_.MergeFrom(from.intent_spans_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_header()) {
      mutable_header()->::cockroach::roachpb::Span::MergeFrom(from.header());
    }
    if (from.has_commit()) {
      set_commit(from.commit());
    }
    if (from.has_deadline()) {
      mutable_deadline()->::cockroach::roachpb::Timestamp::MergeFrom(from.deadline());
    }
    if (from.has_internal_commit_trigger()) {
      mutable_internal_commit_trigger()->::cockroach::roachpb::InternalCommitTrigger::MergeFrom(from.internal_commit_trigger());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void EndTransactionRequest::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void EndTransactionRequest::CopyFrom(const EndTransactionRequest& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EndTransactionRequest::IsInitialized() const {

  return true;
}

void EndTransactionRequest::Swap(EndTransactionRequest* other) {
  if (other == this) return;
  InternalSwap(other);
}
void EndTransactionRequest::InternalSwap(EndTransactionRequest* other) {
  std::swap(header_, other->header_);
  std::swap(commit_, other->commit_);
  std::swap(deadline_, other->deadline_);
  std::swap(internal_commit_trigger_, other->internal_commit_trigger_);
  intent_spans_.UnsafeArenaSwap(&other->intent_spans_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata EndTransactionRequest::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = EndTransactionRequest_descriptor_;
  metadata.reflection = EndTransactionRequest_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// EndTransactionRequest

// optional .cockroach.roachpb.Span header = 1;
bool EndTransactionRequest::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void EndTransactionRequest::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
void EndTransactionRequest::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
void EndTransactionRequest::clear_header() {
  if (header_ != NULL) header_->::cockroach::roachpb::Span::Clear();
  clear_has_header();
}
const ::cockroach::roachpb::Span& EndTransactionRequest::header() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.EndTransactionRequest.header)
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
::cockroach::roachpb::Span* EndTransactionRequest::mutable_header() {
  set_has_header();
  if (header_ == NULL) {
    header_ = new ::cockroach::roachpb::Span;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.EndTransactionRequest.header)
  return header_;
}
::cockroach::roachpb::Span* EndTransactionRequest::release_header() {
  clear_has_header();
  ::cockroach::roachpb::Span* temp = header_;
  header_ = NULL;
  return temp;
}
void EndTransactionRequest::set_allocated_header(::cockroach::roachpb::Span* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.EndTransactionRequest.header)
}

// optional bool commit = 2;
bool EndTransactionRequest::has_commit() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void EndTransactionRequest::set_has_commit() {
  _has_bits_[0] |= 0x00000002u;
}
void EndTransactionRequest::clear_has_commit() {
  _has_bits_[0] &= ~0x00000002u;
}
void EndTransactionRequest::clear_commit() {
  commit_ = false;
  clear_has_commit();
}
 bool EndTransactionRequest::commit() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.EndTransactionRequest.commit)
  return commit_;
}
 void EndTransactionRequest::set_commit(bool value) {
  set_has_commit();
  commit_ = value;
  // @@protoc_insertion_point(field_set:cockroach.roachpb.EndTransactionRequest.commit)
}

// optional .cockroach.roachpb.Timestamp deadline = 3;
bool EndTransactionRequest::has_deadline() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void EndTransactionRequest::set_has_deadline() {
  _has_bits_[0] |= 0x00000004u;
}
void EndTransactionRequest::clear_has_deadline() {
  _has_bits_[0] &= ~0x00000004u;
}
void EndTransactionRequest::clear_deadline() {
  if (deadline_ != NULL) deadline_->::cockroach::roachpb::Timestamp::Clear();
  clear_has_deadline();
}
const ::cockroach::roachpb::Timestamp& EndTransactionRequest::deadline() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.EndTransactionRequest.deadline)
  return deadline_ != NULL ? *deadline_ : *default_instance_->deadline_;
}
::cockroach::roachpb::Timestamp* EndTransactionRequest::mutable_deadline() {
  set_has_deadline();
  if (deadline_ == NULL) {
    deadline_ = new ::cockroach::roachpb::Timestamp;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.EndTransactionRequest.deadline)
  return deadline_;
}
::cockroach::roachpb::Timestamp* EndTransactionRequest::release_deadline() {
  clear_has_deadline();
  ::cockroach::roachpb::Timestamp* temp = deadline_;
  deadline_ = NULL;
  return temp;
}
void EndTransactionRequest::set_allocated_deadline(::cockroach::roachpb::Timestamp* deadline) {
  delete deadline_;
  deadline_ = deadline;
  if (deadline) {
    set_has_deadline();
  } else {
    clear_has_deadline();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.EndTransactionRequest.deadline)
}

// optional .cockroach.roachpb.InternalCommitTrigger internal_commit_trigger = 4;
bool EndTransactionRequest::has_internal_commit_trigger() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void EndTransactionRequest::set_has_internal_commit_trigger() {
  _has_bits_[0] |= 0x00000008u;
}
void EndTransactionRequest::clear_has_internal_commit_trigger() {
  _has_bits_[0] &= ~0x00000008u;
}
void EndTransactionRequest::clear_internal_commit_trigger() {
  if (internal_commit_trigger_ != NULL) internal_commit_trigger_->::cockroach::roachpb::InternalCommitTrigger::Clear();
  clear_has_internal_commit_trigger();
}
const ::cockroach::roachpb::InternalCommitTrigger& EndTransactionRequest::internal_commit_trigger() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.EndTransactionRequest.internal_commit_trigger)
  return internal_commit_trigger_ != NULL ? *internal_commit_trigger_ : *default_instance_->internal_commit_trigger_;
}
::cockroach::roachpb::InternalCommitTrigger* EndTransactionRequest::mutable_internal_commit_trigger() {
  set_has_internal_commit_trigger();
  if (internal_commit_trigger_ == NULL) {
    internal_commit_trigger_ = new ::cockroach::roachpb::InternalCommitTrigger;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.EndTransactionRequest.internal_commit_trigger)
  return internal_commit_trigger_;
}
::cockroach::roachpb::InternalCommitTrigger* EndTransactionRequest::release_internal_commit_trigger() {
  clear_has_internal_commit_trigger();
  ::cockroach::roachpb::InternalCommitTrigger* temp = internal_commit_trigger_;
  internal_commit_trigger_ = NULL;
  return temp;
}
void EndTransactionRequest::set_allocated_internal_commit_trigger(::cockroach::roachpb::InternalCommitTrigger* internal_commit_trigger) {
  delete internal_commit_trigger_;
  internal_commit_trigger_ = internal_commit_trigger;
  if (internal_commit_trigger) {
    set_has_internal_commit_trigger();
  } else {
    clear_has_internal_commit_trigger();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.EndTransactionRequest.internal_commit_trigger)
}

// repeated .cockroach.roachpb.Span intent_spans = 5;
int EndTransactionRequest::intent_spans_size() const {
  return intent_spans_.size();
}
void EndTransactionRequest::clear_intent_spans() {
  intent_spans_.Clear();
}
const ::cockroach::roachpb::Span& EndTransactionRequest::intent_spans(int index) const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.EndTransactionRequest.intent_spans)
  return intent_spans_.Get(index);
}
::cockroach::roachpb::Span* EndTransactionRequest::mutable_intent_spans(int index) {
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.EndTransactionRequest.intent_spans)
  return intent_spans_.Mutable(index);
}
::cockroach::roachpb::Span* EndTransactionRequest::add_intent_spans() {
  // @@protoc_insertion_point(field_add:cockroach.roachpb.EndTransactionRequest.intent_spans)
  return intent_spans_.Add();
}
::google::protobuf::RepeatedPtrField< ::cockroach::roachpb::Span >*
EndTransactionRequest::mutable_intent_spans() {
  // @@protoc_insertion_point(field_mutable_list:cockroach.roachpb.EndTransactionRequest.intent_spans)
  return &intent_spans_;
}
const ::google::protobuf::RepeatedPtrField< ::cockroach::roachpb::Span >&
EndTransactionRequest::intent_spans() const {
  // @@protoc_insertion_point(field_list:cockroach.roachpb.EndTransactionRequest.intent_spans)
  return intent_spans_;
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int EndTransactionResponse::kHeaderFieldNumber;
const int EndTransactionResponse::kCommitWaitFieldNumber;
const int EndTransactionResponse::kResolvedFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

EndTransactionResponse::EndTransactionResponse()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:cockroach.roachpb.EndTransactionResponse)
}

void EndTransactionResponse::InitAsDefaultInstance() {
  header_ = const_cast< ::cockroach::roachpb::ResponseHeader*>(&::cockroach::roachpb::ResponseHeader::default_instance());
}

EndTransactionResponse::EndTransactionResponse(const EndTransactionResponse& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:cockroach.roachpb.EndTransactionResponse)
}

void EndTransactionResponse::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  header_ = NULL;
  commit_wait_ = GOOGLE_LONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

EndTransactionResponse::~EndTransactionResponse() {
  // @@protoc_insertion_point(destructor:cockroach.roachpb.EndTransactionResponse)
  SharedDtor();
}

void EndTransactionResponse::SharedDtor() {
  if (this != default_instance_) {
    delete header_;
  }
}

void EndTransactionResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* EndTransactionResponse::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return EndTransactionResponse_descriptor_;
}

const EndTransactionResponse& EndTransactionResponse::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_cockroach_2froachpb_2fapi_2eproto();
  return *default_instance_;
}

EndTransactionResponse* EndTransactionResponse::default_instance_ = NULL;

EndTransactionResponse* EndTransactionResponse::New(::google::protobuf::Arena* arena) const {
  EndTransactionResponse* n = new EndTransactionResponse;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void EndTransactionResponse::Clear() {
  if (_has_bits_[0 / 32] & 3u) {
    if (has_header()) {
      if (header_ != NULL) header_->::cockroach::roachpb::ResponseHeader::Clear();
    }
    commit_wait_ = GOOGLE_LONGLONG(0);
  }
  resolved_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool EndTransactionResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:cockroach.roachpb.EndTransactionResponse)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .cockroach.roachpb.ResponseHeader header = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_header()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_commit_wait;
        break;
      }

      // optional int64 commit_wait = 2;
      case 2: {
        if (tag == 16) {
         parse_commit_wait:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &commit_wait_)));
          set_has_commit_wait();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_resolved;
        break;
      }

      // repeated bytes resolved = 3;
      case 3: {
        if (tag == 26) {
         parse_resolved:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->add_resolved()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_resolved;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:cockroach.roachpb.EndTransactionResponse)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:cockroach.roachpb.EndTransactionResponse)
  return false;
#undef DO_
}

void EndTransactionResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:cockroach.roachpb.EndTransactionResponse)
  // optional .cockroach.roachpb.ResponseHeader header = 1;
  if (has_header()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->header_, output);
  }

  // optional int64 commit_wait = 2;
  if (has_commit_wait()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(2, this->commit_wait(), output);
  }

  // repeated bytes resolved = 3;
  for (int i = 0; i < this->resolved_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      3, this->resolved(i), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:cockroach.roachpb.EndTransactionResponse)
}

::google::protobuf::uint8* EndTransactionResponse::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:cockroach.roachpb.EndTransactionResponse)
  // optional .cockroach.roachpb.ResponseHeader header = 1;
  if (has_header()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, *this->header_, target);
  }

  // optional int64 commit_wait = 2;
  if (has_commit_wait()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(2, this->commit_wait(), target);
  }

  // repeated bytes resolved = 3;
  for (int i = 0; i < this->resolved_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteBytesToArray(3, this->resolved(i), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:cockroach.roachpb.EndTransactionResponse)
  return target;
}

int EndTransactionResponse::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & 3u) {
    // optional .cockroach.roachpb.ResponseHeader header = 1;
    if (has_header()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->header_);
    }

    // optional int64 commit_wait = 2;
    if (has_commit_wait()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->commit_wait());
    }

  }
  // repeated bytes resolved = 3;
  total_size += 1 * this->resolved_size();
  for (int i = 0; i < this->resolved_size(); i++) {
    total_size += ::google::protobuf::internal::WireFormatLite::BytesSize(
      this->resolved(i));
  }

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void EndTransactionResponse::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const EndTransactionResponse* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const EndTransactionResponse>(
          &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void EndTransactionResponse::MergeFrom(const EndTransactionResponse& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  resolved_.MergeFrom(from.resolved_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_header()) {
      mutable_header()->::cockroach::roachpb::ResponseHeader::MergeFrom(from.header());
    }
    if (from.has_commit_wait()) {
      set_commit_wait(from.commit_wait());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void EndTransactionResponse::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void EndTransactionResponse::CopyFrom(const EndTransactionResponse& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EndTransactionResponse::IsInitialized() const {

  return true;
}

void EndTransactionResponse::Swap(EndTransactionResponse* other) {
  if (other == this) return;
  InternalSwap(other);
}
void EndTransactionResponse::InternalSwap(EndTransactionResponse* other) {
  std::swap(header_, other->header_);
  std::swap(commit_wait_, other->commit_wait_);
  resolved_.UnsafeArenaSwap(&other->resolved_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata EndTransactionResponse::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = EndTransactionResponse_descriptor_;
  metadata.reflection = EndTransactionResponse_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// EndTransactionResponse

// optional .cockroach.roachpb.ResponseHeader header = 1;
bool EndTransactionResponse::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void EndTransactionResponse::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
void EndTransactionResponse::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
void EndTransactionResponse::clear_header() {
  if (header_ != NULL) header_->::cockroach::roachpb::ResponseHeader::Clear();
  clear_has_header();
}
const ::cockroach::roachpb::ResponseHeader& EndTransactionResponse::header() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.EndTransactionResponse.header)
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
::cockroach::roachpb::ResponseHeader* EndTransactionResponse::mutable_header() {
  set_has_header();
  if (header_ == NULL) {
    header_ = new ::cockroach::roachpb::ResponseHeader;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.EndTransactionResponse.header)
  return header_;
}
::cockroach::roachpb::ResponseHeader* EndTransactionResponse::release_header() {
  clear_has_header();
  ::cockroach::roachpb::ResponseHeader* temp = header_;
  header_ = NULL;
  return temp;
}
void EndTransactionResponse::set_allocated_header(::cockroach::roachpb::ResponseHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.EndTransactionResponse.header)
}

// optional int64 commit_wait = 2;
bool EndTransactionResponse::has_commit_wait() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void EndTransactionResponse::set_has_commit_wait() {
  _has_bits_[0] |= 0x00000002u;
}
void EndTransactionResponse::clear_has_commit_wait() {
  _has_bits_[0] &= ~0x00000002u;
}
void EndTransactionResponse::clear_commit_wait() {
  commit_wait_ = GOOGLE_LONGLONG(0);
  clear_has_commit_wait();
}
 ::google::protobuf::int64 EndTransactionResponse::commit_wait() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.EndTransactionResponse.commit_wait)
  return commit_wait_;
}
 void EndTransactionResponse::set_commit_wait(::google::protobuf::int64 value) {
  set_has_commit_wait();
  commit_wait_ = value;
  // @@protoc_insertion_point(field_set:cockroach.roachpb.EndTransactionResponse.commit_wait)
}

// repeated bytes resolved = 3;
int EndTransactionResponse::resolved_size() const {
  return resolved_.size();
}
void EndTransactionResponse::clear_resolved() {
  resolved_.Clear();
}
 const ::std::string& EndTransactionResponse::resolved(int index) const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.EndTransactionResponse.resolved)
  return resolved_.Get(index);
}
 ::std::string* EndTransactionResponse::mutable_resolved(int index) {
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.EndTransactionResponse.resolved)
  return resolved_.Mutable(index);
}
 void EndTransactionResponse::set_resolved(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:cockroach.roachpb.EndTransactionResponse.resolved)
  resolved_.Mutable(index)->assign(value);
}
 void EndTransactionResponse::set_resolved(int index, const char* value) {
  resolved_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:cockroach.roachpb.EndTransactionResponse.resolved)
}
 void EndTransactionResponse::set_resolved(int index, const void* value, size_t size) {
  resolved_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:cockroach.roachpb.EndTransactionResponse.resolved)
}
 ::std::string* EndTransactionResponse::add_resolved() {
  return resolved_.Add();
}
 void EndTransactionResponse::add_resolved(const ::std::string& value) {
  resolved_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:cockroach.roachpb.EndTransactionResponse.resolved)
}
 void EndTransactionResponse::add_resolved(const char* value) {
  resolved_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:cockroach.roachpb.EndTransactionResponse.resolved)
}
 void EndTransactionResponse::add_resolved(const void* value, size_t size) {
  resolved_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:cockroach.roachpb.EndTransactionResponse.resolved)
}
 const ::google::protobuf::RepeatedPtrField< ::std::string>&
EndTransactionResponse::resolved() const {
  // @@protoc_insertion_point(field_list:cockroach.roachpb.EndTransactionResponse.resolved)
  return resolved_;
}
 ::google::protobuf::RepeatedPtrField< ::std::string>*
EndTransactionResponse::mutable_resolved() {
  // @@protoc_insertion_point(field_mutable_list:cockroach.roachpb.EndTransactionResponse.resolved)
  return &resolved_;
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int AdminSplitRequest::kHeaderFieldNumber;
const int AdminSplitRequest::kSplitKeyFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

AdminSplitRequest::AdminSplitRequest()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:cockroach.roachpb.AdminSplitRequest)
}

void AdminSplitRequest::InitAsDefaultInstance() {
  header_ = const_cast< ::cockroach::roachpb::Span*>(&::cockroach::roachpb::Span::default_instance());
}

AdminSplitRequest::AdminSplitRequest(const AdminSplitRequest& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:cockroach.roachpb.AdminSplitRequest)
}

void AdminSplitRequest::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  header_ = NULL;
  split_key_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

AdminSplitRequest::~AdminSplitRequest() {
  // @@protoc_insertion_point(destructor:cockroach.roachpb.AdminSplitRequest)
  SharedDtor();
}

void AdminSplitRequest::SharedDtor() {
  split_key_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != default_instance_) {
    delete header_;
  }
}

void AdminSplitRequest::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* AdminSplitRequest::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return AdminSplitRequest_descriptor_;
}

const AdminSplitRequest& AdminSplitRequest::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_cockroach_2froachpb_2fapi_2eproto();
  return *default_instance_;
}

AdminSplitRequest* AdminSplitRequest::default_instance_ = NULL;

AdminSplitRequest* AdminSplitRequest::New(::google::protobuf::Arena* arena) const {
  AdminSplitRequest* n = new AdminSplitRequest;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void AdminSplitRequest::Clear() {
  if (_has_bits_[0 / 32] & 3u) {
    if (has_header()) {
      if (header_ != NULL) header_->::cockroach::roachpb::Span::Clear();
    }
    if (has_split_key()) {
      split_key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool AdminSplitRequest::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:cockroach.roachpb.AdminSplitRequest)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .cockroach.roachpb.Span header = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_header()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_split_key;
        break;
      }

      // optional bytes split_key = 2;
      case 2: {
        if (tag == 18) {
         parse_split_key:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_split_key()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:cockroach.roachpb.AdminSplitRequest)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:cockroach.roachpb.AdminSplitRequest)
  return false;
#undef DO_
}

void AdminSplitRequest::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:cockroach.roachpb.AdminSplitRequest)
  // optional .cockroach.roachpb.Span header = 1;
  if (has_header()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->header_, output);
  }

  // optional bytes split_key = 2;
  if (has_split_key()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      2, this->split_key(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:cockroach.roachpb.AdminSplitRequest)
}

::google::protobuf::uint8* AdminSplitRequest::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:cockroach.roachpb.AdminSplitRequest)
  // optional .cockroach.roachpb.Span header = 1;
  if (has_header()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, *this->header_, target);
  }

  // optional bytes split_key = 2;
  if (has_split_key()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        2, this->split_key(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:cockroach.roachpb.AdminSplitRequest)
  return target;
}

int AdminSplitRequest::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & 3u) {
    // optional .cockroach.roachpb.Span header = 1;
    if (has_header()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->header_);
    }

    // optional bytes split_key = 2;
    if (has_split_key()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->split_key());
    }

  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void AdminSplitRequest::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const AdminSplitRequest* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const AdminSplitRequest>(
          &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void AdminSplitRequest::MergeFrom(const AdminSplitRequest& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_header()) {
      mutable_header()->::cockroach::roachpb::Span::MergeFrom(from.header());
    }
    if (from.has_split_key()) {
      set_has_split_key();
      split_key_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.split_key_);
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void AdminSplitRequest::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void AdminSplitRequest::CopyFrom(const AdminSplitRequest& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AdminSplitRequest::IsInitialized() const {

  return true;
}

void AdminSplitRequest::Swap(AdminSplitRequest* other) {
  if (other == this) return;
  InternalSwap(other);
}
void AdminSplitRequest::InternalSwap(AdminSplitRequest* other) {
  std::swap(header_, other->header_);
  split_key_.Swap(&other->split_key_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata AdminSplitRequest::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = AdminSplitRequest_descriptor_;
  metadata.reflection = AdminSplitRequest_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// AdminSplitRequest

// optional .cockroach.roachpb.Span header = 1;
bool AdminSplitRequest::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void AdminSplitRequest::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
void AdminSplitRequest::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
void AdminSplitRequest::clear_header() {
  if (header_ != NULL) header_->::cockroach::roachpb::Span::Clear();
  clear_has_header();
}
const ::cockroach::roachpb::Span& AdminSplitRequest::header() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.AdminSplitRequest.header)
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
::cockroach::roachpb::Span* AdminSplitRequest::mutable_header() {
  set_has_header();
  if (header_ == NULL) {
    header_ = new ::cockroach::roachpb::Span;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.AdminSplitRequest.header)
  return header_;
}
::cockroach::roachpb::Span* AdminSplitRequest::release_header() {
  clear_has_header();
  ::cockroach::roachpb::Span* temp = header_;
  header_ = NULL;
  return temp;
}
void AdminSplitRequest::set_allocated_header(::cockroach::roachpb::Span* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.AdminSplitRequest.header)
}

// optional bytes split_key = 2;
bool AdminSplitRequest::has_split_key() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void AdminSplitRequest::set_has_split_key() {
  _has_bits_[0] |= 0x00000002u;
}
void AdminSplitRequest::clear_has_split_key() {
  _has_bits_[0] &= ~0x00000002u;
}
void AdminSplitRequest::clear_split_key() {
  split_key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_split_key();
}
 const ::std::string& AdminSplitRequest::split_key() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.AdminSplitRequest.split_key)
  return split_key_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void AdminSplitRequest::set_split_key(const ::std::string& value) {
  set_has_split_key();
  split_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cockroach.roachpb.AdminSplitRequest.split_key)
}
 void AdminSplitRequest::set_split_key(const char* value) {
  set_has_split_key();
  split_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cockroach.roachpb.AdminSplitRequest.split_key)
}
 void AdminSplitRequest::set_split_key(const void* value, size_t size) {
  set_has_split_key();
  split_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cockroach.roachpb.AdminSplitRequest.split_key)
}
 ::std::string* AdminSplitRequest::mutable_split_key() {
  set_has_split_key();
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.AdminSplitRequest.split_key)
  return split_key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* AdminSplitRequest::release_split_key() {
  clear_has_split_key();
  return split_key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void AdminSplitRequest::set_allocated_split_key(::std::string* split_key) {
  if (split_key != NULL) {
    set_has_split_key();
  } else {
    clear_has_split_key();
  }
  split_key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), split_key);
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.AdminSplitRequest.split_key)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int AdminSplitResponse::kHeaderFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

AdminSplitResponse::AdminSplitResponse()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:cockroach.roachpb.AdminSplitResponse)
}

void AdminSplitResponse::InitAsDefaultInstance() {
  header_ = const_cast< ::cockroach::roachpb::ResponseHeader*>(&::cockroach::roachpb::ResponseHeader::default_instance());
}

AdminSplitResponse::AdminSplitResponse(const AdminSplitResponse& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:cockroach.roachpb.AdminSplitResponse)
}

void AdminSplitResponse::SharedCtor() {
  _cached_size_ = 0;
  header_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

AdminSplitResponse::~AdminSplitResponse() {
  // @@protoc_insertion_point(destructor:cockroach.roachpb.AdminSplitResponse)
  SharedDtor();
}

void AdminSplitResponse::SharedDtor() {
  if (this != default_instance_) {
    delete header_;
  }
}

void AdminSplitResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* AdminSplitResponse::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return AdminSplitResponse_descriptor_;
}

const AdminSplitResponse& AdminSplitResponse::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_cockroach_2froachpb_2fapi_2eproto();
  return *default_instance_;
}

AdminSplitResponse* AdminSplitResponse::default_instance_ = NULL;

AdminSplitResponse* AdminSplitResponse::New(::google::protobuf::Arena* arena) const {
  AdminSplitResponse* n = new AdminSplitResponse;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void AdminSplitResponse::Clear() {
  if (has_header()) {
    if (header_ != NULL) header_->::cockroach::roachpb::ResponseHeader::Clear();
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool AdminSplitResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:cockroach.roachpb.AdminSplitResponse)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .cockroach.roachpb.ResponseHeader header = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_header()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:cockroach.roachpb.AdminSplitResponse)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:cockroach.roachpb.AdminSplitResponse)
  return false;
#undef DO_
}

void AdminSplitResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:cockroach.roachpb.AdminSplitResponse)
  // optional .cockroach.roachpb.ResponseHeader header = 1;
  if (has_header()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->header_, output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:cockroach.roachpb.AdminSplitResponse)
}

::google::protobuf::uint8* AdminSplitResponse::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:cockroach.roachpb.AdminSplitResponse)
  // optional .cockroach.roachpb.ResponseHeader header = 1;
  if (has_header()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, *this->header_, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:cockroach.roachpb.AdminSplitResponse)
  return target;
}

int AdminSplitResponse::ByteSize() const {
  int total_size = 0;

  // optional .cockroach.roachpb.ResponseHeader header = 1;
  if (has_header()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->header_);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void AdminSplitResponse::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const AdminSplitResponse* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const AdminSplitResponse>(
          &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void AdminSplitResponse::MergeFrom(const AdminSplitResponse& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_header()) {
      mutable_header()->::cockroach::roachpb::ResponseHeader::MergeFrom(from.header());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void AdminSplitResponse::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void AdminSplitResponse::CopyFrom(const AdminSplitResponse& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AdminSplitResponse::IsInitialized() const {

  return true;
}

void AdminSplitResponse::Swap(AdminSplitResponse* other) {
  if (other == this) return;
  InternalSwap(other);
}
void AdminSplitResponse::InternalSwap(AdminSplitResponse* other) {
  std::swap(header_, other->header_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata AdminSplitResponse::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = AdminSplitResponse_descriptor_;
  metadata.reflection = AdminSplitResponse_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// AdminSplitResponse

// optional .cockroach.roachpb.ResponseHeader header = 1;
bool AdminSplitResponse::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void AdminSplitResponse::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
void AdminSplitResponse::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
void AdminSplitResponse::clear_header() {
  if (header_ != NULL) header_->::cockroach::roachpb::ResponseHeader::Clear();
  clear_has_header();
}
const ::cockroach::roachpb::ResponseHeader& AdminSplitResponse::header() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.AdminSplitResponse.header)
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
::cockroach::roachpb::ResponseHeader* AdminSplitResponse::mutable_header() {
  set_has_header();
  if (header_ == NULL) {
    header_ = new ::cockroach::roachpb::ResponseHeader;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.AdminSplitResponse.header)
  return header_;
}
::cockroach::roachpb::ResponseHeader* AdminSplitResponse::release_header() {
  clear_has_header();
  ::cockroach::roachpb::ResponseHeader* temp = header_;
  header_ = NULL;
  return temp;
}
void AdminSplitResponse::set_allocated_header(::cockroach::roachpb::ResponseHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.AdminSplitResponse.header)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int AdminMergeRequest::kHeaderFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

AdminMergeRequest::AdminMergeRequest()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:cockroach.roachpb.AdminMergeRequest)
}

void AdminMergeRequest::InitAsDefaultInstance() {
  header_ = const_cast< ::cockroach::roachpb::Span*>(&::cockroach::roachpb::Span::default_instance());
}

AdminMergeRequest::AdminMergeRequest(const AdminMergeRequest& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:cockroach.roachpb.AdminMergeRequest)
}

void AdminMergeRequest::SharedCtor() {
  _cached_size_ = 0;
  header_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

AdminMergeRequest::~AdminMergeRequest() {
  // @@protoc_insertion_point(destructor:cockroach.roachpb.AdminMergeRequest)
  SharedDtor();
}

void AdminMergeRequest::SharedDtor() {
  if (this != default_instance_) {
    delete header_;
  }
}

void AdminMergeRequest::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* AdminMergeRequest::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return AdminMergeRequest_descriptor_;
}

const AdminMergeRequest& AdminMergeRequest::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_cockroach_2froachpb_2fapi_2eproto();
  return *default_instance_;
}

AdminMergeRequest* AdminMergeRequest::default_instance_ = NULL;

AdminMergeRequest* AdminMergeRequest::New(::google::protobuf::Arena* arena) const {
  AdminMergeRequest* n = new AdminMergeRequest;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void AdminMergeRequest::Clear() {
  if (has_header()) {
    if (header_ != NULL) header_->::cockroach::roachpb::Span::Clear();
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool AdminMergeRequest::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:cockroach.roachpb.AdminMergeRequest)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .cockroach.roachpb.Span header = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_header()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:cockroach.roachpb.AdminMergeRequest)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:cockroach.roachpb.AdminMergeRequest)
  return false;
#undef DO_
}

void AdminMergeRequest::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:cockroach.roachpb.AdminMergeRequest)
  // optional .cockroach.roachpb.Span header = 1;
  if (has_header()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->header_, output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:cockroach.roachpb.AdminMergeRequest)
}

::google::protobuf::uint8* AdminMergeRequest::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:cockroach.roachpb.AdminMergeRequest)
  // optional .cockroach.roachpb.Span header = 1;
  if (has_header()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, *this->header_, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:cockroach.roachpb.AdminMergeRequest)
  return target;
}

int AdminMergeRequest::ByteSize() const {
  int total_size = 0;

  // optional .cockroach.roachpb.Span header = 1;
  if (has_header()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->header_);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void AdminMergeRequest::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const AdminMergeRequest* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const AdminMergeRequest>(
          &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void AdminMergeRequest::MergeFrom(const AdminMergeRequest& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_header()) {
      mutable_header()->::cockroach::roachpb::Span::MergeFrom(from.header());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void AdminMergeRequest::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void AdminMergeRequest::CopyFrom(const AdminMergeRequest& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AdminMergeRequest::IsInitialized() const {

  return true;
}

void AdminMergeRequest::Swap(AdminMergeRequest* other) {
  if (other == this) return;
  InternalSwap(other);
}
void AdminMergeRequest::InternalSwap(AdminMergeRequest* other) {
  std::swap(header_, other->header_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata AdminMergeRequest::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = AdminMergeRequest_descriptor_;
  metadata.reflection = AdminMergeRequest_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// AdminMergeRequest

// optional .cockroach.roachpb.Span header = 1;
bool AdminMergeRequest::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void AdminMergeRequest::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
void AdminMergeRequest::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
void AdminMergeRequest::clear_header() {
  if (header_ != NULL) header_->::cockroach::roachpb::Span::Clear();
  clear_has_header();
}
const ::cockroach::roachpb::Span& AdminMergeRequest::header() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.AdminMergeRequest.header)
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
::cockroach::roachpb::Span* AdminMergeRequest::mutable_header() {
  set_has_header();
  if (header_ == NULL) {
    header_ = new ::cockroach::roachpb::Span;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.AdminMergeRequest.header)
  return header_;
}
::cockroach::roachpb::Span* AdminMergeRequest::release_header() {
  clear_has_header();
  ::cockroach::roachpb::Span* temp = header_;
  header_ = NULL;
  return temp;
}
void AdminMergeRequest::set_allocated_header(::cockroach::roachpb::Span* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.AdminMergeRequest.header)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int AdminMergeResponse::kHeaderFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

AdminMergeResponse::AdminMergeResponse()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:cockroach.roachpb.AdminMergeResponse)
}

void AdminMergeResponse::InitAsDefaultInstance() {
  header_ = const_cast< ::cockroach::roachpb::ResponseHeader*>(&::cockroach::roachpb::ResponseHeader::default_instance());
}

AdminMergeResponse::AdminMergeResponse(const AdminMergeResponse& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:cockroach.roachpb.AdminMergeResponse)
}

void AdminMergeResponse::SharedCtor() {
  _cached_size_ = 0;
  header_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

AdminMergeResponse::~AdminMergeResponse() {
  // @@protoc_insertion_point(destructor:cockroach.roachpb.AdminMergeResponse)
  SharedDtor();
}

void AdminMergeResponse::SharedDtor() {
  if (this != default_instance_) {
    delete header_;
  }
}

void AdminMergeResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* AdminMergeResponse::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return AdminMergeResponse_descriptor_;
}

const AdminMergeResponse& AdminMergeResponse::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_cockroach_2froachpb_2fapi_2eproto();
  return *default_instance_;
}

AdminMergeResponse* AdminMergeResponse::default_instance_ = NULL;

AdminMergeResponse* AdminMergeResponse::New(::google::protobuf::Arena* arena) const {
  AdminMergeResponse* n = new AdminMergeResponse;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void AdminMergeResponse::Clear() {
  if (has_header()) {
    if (header_ != NULL) header_->::cockroach::roachpb::ResponseHeader::Clear();
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool AdminMergeResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:cockroach.roachpb.AdminMergeResponse)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .cockroach.roachpb.ResponseHeader header = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_header()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:cockroach.roachpb.AdminMergeResponse)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:cockroach.roachpb.AdminMergeResponse)
  return false;
#undef DO_
}

void AdminMergeResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:cockroach.roachpb.AdminMergeResponse)
  // optional .cockroach.roachpb.ResponseHeader header = 1;
  if (has_header()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->header_, output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:cockroach.roachpb.AdminMergeResponse)
}

::google::protobuf::uint8* AdminMergeResponse::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:cockroach.roachpb.AdminMergeResponse)
  // optional .cockroach.roachpb.ResponseHeader header = 1;
  if (has_header()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, *this->header_, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:cockroach.roachpb.AdminMergeResponse)
  return target;
}

int AdminMergeResponse::ByteSize() const {
  int total_size = 0;

  // optional .cockroach.roachpb.ResponseHeader header = 1;
  if (has_header()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->header_);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void AdminMergeResponse::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const AdminMergeResponse* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const AdminMergeResponse>(
          &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void AdminMergeResponse::MergeFrom(const AdminMergeResponse& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_header()) {
      mutable_header()->::cockroach::roachpb::ResponseHeader::MergeFrom(from.header());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void AdminMergeResponse::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void AdminMergeResponse::CopyFrom(const AdminMergeResponse& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AdminMergeResponse::IsInitialized() const {

  return true;
}

void AdminMergeResponse::Swap(AdminMergeResponse* other) {
  if (other == this) return;
  InternalSwap(other);
}
void AdminMergeResponse::InternalSwap(AdminMergeResponse* other) {
  std::swap(header_, other->header_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata AdminMergeResponse::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = AdminMergeResponse_descriptor_;
  metadata.reflection = AdminMergeResponse_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// AdminMergeResponse

// optional .cockroach.roachpb.ResponseHeader header = 1;
bool AdminMergeResponse::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void AdminMergeResponse::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
void AdminMergeResponse::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
void AdminMergeResponse::clear_header() {
  if (header_ != NULL) header_->::cockroach::roachpb::ResponseHeader::Clear();
  clear_has_header();
}
const ::cockroach::roachpb::ResponseHeader& AdminMergeResponse::header() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.AdminMergeResponse.header)
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
::cockroach::roachpb::ResponseHeader* AdminMergeResponse::mutable_header() {
  set_has_header();
  if (header_ == NULL) {
    header_ = new ::cockroach::roachpb::ResponseHeader;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.AdminMergeResponse.header)
  return header_;
}
::cockroach::roachpb::ResponseHeader* AdminMergeResponse::release_header() {
  clear_has_header();
  ::cockroach::roachpb::ResponseHeader* temp = header_;
  header_ = NULL;
  return temp;
}
void AdminMergeResponse::set_allocated_header(::cockroach::roachpb::ResponseHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.AdminMergeResponse.header)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int RangeLookupRequest::kHeaderFieldNumber;
const int RangeLookupRequest::kMaxRangesFieldNumber;
const int RangeLookupRequest::kConsiderIntentsFieldNumber;
const int RangeLookupRequest::kReverseFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

RangeLookupRequest::RangeLookupRequest()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:cockroach.roachpb.RangeLookupRequest)
}

void RangeLookupRequest::InitAsDefaultInstance() {
  header_ = const_cast< ::cockroach::roachpb::Span*>(&::cockroach::roachpb::Span::default_instance());
}

RangeLookupRequest::RangeLookupRequest(const RangeLookupRequest& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:cockroach.roachpb.RangeLookupRequest)
}

void RangeLookupRequest::SharedCtor() {
  _cached_size_ = 0;
  header_ = NULL;
  max_ranges_ = 0;
  consider_intents_ = false;
  reverse_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RangeLookupRequest::~RangeLookupRequest() {
  // @@protoc_insertion_point(destructor:cockroach.roachpb.RangeLookupRequest)
  SharedDtor();
}

void RangeLookupRequest::SharedDtor() {
  if (this != default_instance_) {
    delete header_;
  }
}

void RangeLookupRequest::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* RangeLookupRequest::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return RangeLookupRequest_descriptor_;
}

const RangeLookupRequest& RangeLookupRequest::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_cockroach_2froachpb_2fapi_2eproto();
  return *default_instance_;
}

RangeLookupRequest* RangeLookupRequest::default_instance_ = NULL;

RangeLookupRequest* RangeLookupRequest::New(::google::protobuf::Arena* arena) const {
  RangeLookupRequest* n = new RangeLookupRequest;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void RangeLookupRequest::Clear() {
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<RangeLookupRequest*>(16)->f)

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  if (_has_bits_[0 / 32] & 15u) {
    ZR_(max_ranges_, reverse_);
    if (has_header()) {
      if (header_ != NULL) header_->::cockroach::roachpb::Span::Clear();
    }
  }

#undef ZR_HELPER_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool RangeLookupRequest::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:cockroach.roachpb.RangeLookupRequest)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .cockroach.roachpb.Span header = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_header()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_max_ranges;
        break;
      }

      // optional int32 max_ranges = 2;
      case 2: {
        if (tag == 16) {
         parse_max_ranges:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &max_ranges_)));
          set_has_max_ranges();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_consider_intents;
        break;
      }

      // optional bool consider_intents = 3;
      case 3: {
        if (tag == 24) {
         parse_consider_intents:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &consider_intents_)));
          set_has_consider_intents();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_reverse;
        break;
      }

      // optional bool reverse = 4;
      case 4: {
        if (tag == 32) {
         parse_reverse:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &reverse_)));
          set_has_reverse();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:cockroach.roachpb.RangeLookupRequest)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:cockroach.roachpb.RangeLookupRequest)
  return false;
#undef DO_
}

void RangeLookupRequest::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:cockroach.roachpb.RangeLookupRequest)
  // optional .cockroach.roachpb.Span header = 1;
  if (has_header()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->header_, output);
  }

  // optional int32 max_ranges = 2;
  if (has_max_ranges()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->max_ranges(), output);
  }

  // optional bool consider_intents = 3;
  if (has_consider_intents()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(3, this->consider_intents(), output);
  }

  // optional bool reverse = 4;
  if (has_reverse()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(4, this->reverse(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:cockroach.roachpb.RangeLookupRequest)
}

::google::protobuf::uint8* RangeLookupRequest::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:cockroach.roachpb.RangeLookupRequest)
  // optional .cockroach.roachpb.Span header = 1;
  if (has_header()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, *this->header_, target);
  }

  // optional int32 max_ranges = 2;
  if (has_max_ranges()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->max_ranges(), target);
  }

  // optional bool consider_intents = 3;
  if (has_consider_intents()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(3, this->consider_intents(), target);
  }

  // optional bool reverse = 4;
  if (has_reverse()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(4, this->reverse(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:cockroach.roachpb.RangeLookupRequest)
  return target;
}

int RangeLookupRequest::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & 15u) {
    // optional .cockroach.roachpb.Span header = 1;
    if (has_header()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->header_);
    }

    // optional int32 max_ranges = 2;
    if (has_max_ranges()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->max_ranges());
    }

    // optional bool consider_intents = 3;
    if (has_consider_intents()) {
      total_size += 1 + 1;
    }

    // optional bool reverse = 4;
    if (has_reverse()) {
      total_size += 1 + 1;
    }

  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RangeLookupRequest::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const RangeLookupRequest* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const RangeLookupRequest>(
          &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void RangeLookupRequest::MergeFrom(const RangeLookupRequest& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_header()) {
      mutable_header()->::cockroach::roachpb::Span::MergeFrom(from.header());
    }
    if (from.has_max_ranges()) {
      set_max_ranges(from.max_ranges());
    }
    if (from.has_consider_intents()) {
      set_consider_intents(from.consider_intents());
    }
    if (from.has_reverse()) {
      set_reverse(from.reverse());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void RangeLookupRequest::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void RangeLookupRequest::CopyFrom(const RangeLookupRequest& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RangeLookupRequest::IsInitialized() const {

  return true;
}

void RangeLookupRequest::Swap(RangeLookupRequest* other) {
  if (other == this) return;
  InternalSwap(other);
}
void RangeLookupRequest::InternalSwap(RangeLookupRequest* other) {
  std::swap(header_, other->header_);
  std::swap(max_ranges_, other->max_ranges_);
  std::swap(consider_intents_, other->consider_intents_);
  std::swap(reverse_, other->reverse_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata RangeLookupRequest::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = RangeLookupRequest_descriptor_;
  metadata.reflection = RangeLookupRequest_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// RangeLookupRequest

// optional .cockroach.roachpb.Span header = 1;
bool RangeLookupRequest::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void RangeLookupRequest::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
void RangeLookupRequest::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
void RangeLookupRequest::clear_header() {
  if (header_ != NULL) header_->::cockroach::roachpb::Span::Clear();
  clear_has_header();
}
const ::cockroach::roachpb::Span& RangeLookupRequest::header() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.RangeLookupRequest.header)
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
::cockroach::roachpb::Span* RangeLookupRequest::mutable_header() {
  set_has_header();
  if (header_ == NULL) {
    header_ = new ::cockroach::roachpb::Span;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.RangeLookupRequest.header)
  return header_;
}
::cockroach::roachpb::Span* RangeLookupRequest::release_header() {
  clear_has_header();
  ::cockroach::roachpb::Span* temp = header_;
  header_ = NULL;
  return temp;
}
void RangeLookupRequest::set_allocated_header(::cockroach::roachpb::Span* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.RangeLookupRequest.header)
}

// optional int32 max_ranges = 2;
bool RangeLookupRequest::has_max_ranges() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void RangeLookupRequest::set_has_max_ranges() {
  _has_bits_[0] |= 0x00000002u;
}
void RangeLookupRequest::clear_has_max_ranges() {
  _has_bits_[0] &= ~0x00000002u;
}
void RangeLookupRequest::clear_max_ranges() {
  max_ranges_ = 0;
  clear_has_max_ranges();
}
 ::google::protobuf::int32 RangeLookupRequest::max_ranges() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.RangeLookupRequest.max_ranges)
  return max_ranges_;
}
 void RangeLookupRequest::set_max_ranges(::google::protobuf::int32 value) {
  set_has_max_ranges();
  max_ranges_ = value;
  // @@protoc_insertion_point(field_set:cockroach.roachpb.RangeLookupRequest.max_ranges)
}

// optional bool consider_intents = 3;
bool RangeLookupRequest::has_consider_intents() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void RangeLookupRequest::set_has_consider_intents() {
  _has_bits_[0] |= 0x00000004u;
}
void RangeLookupRequest::clear_has_consider_intents() {
  _has_bits_[0] &= ~0x00000004u;
}
void RangeLookupRequest::clear_consider_intents() {
  consider_intents_ = false;
  clear_has_consider_intents();
}
 bool RangeLookupRequest::consider_intents() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.RangeLookupRequest.consider_intents)
  return consider_intents_;
}
 void RangeLookupRequest::set_consider_intents(bool value) {
  set_has_consider_intents();
  consider_intents_ = value;
  // @@protoc_insertion_point(field_set:cockroach.roachpb.RangeLookupRequest.consider_intents)
}

// optional bool reverse = 4;
bool RangeLookupRequest::has_reverse() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void RangeLookupRequest::set_has_reverse() {
  _has_bits_[0] |= 0x00000008u;
}
void RangeLookupRequest::clear_has_reverse() {
  _has_bits_[0] &= ~0x00000008u;
}
void RangeLookupRequest::clear_reverse() {
  reverse_ = false;
  clear_has_reverse();
}
 bool RangeLookupRequest::reverse() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.RangeLookupRequest.reverse)
  return reverse_;
}
 void RangeLookupRequest::set_reverse(bool value) {
  set_has_reverse();
  reverse_ = value;
  // @@protoc_insertion_point(field_set:cockroach.roachpb.RangeLookupRequest.reverse)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int RangeLookupResponse::kHeaderFieldNumber;
const int RangeLookupResponse::kRangesFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

RangeLookupResponse::RangeLookupResponse()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:cockroach.roachpb.RangeLookupResponse)
}

void RangeLookupResponse::InitAsDefaultInstance() {
  header_ = const_cast< ::cockroach::roachpb::ResponseHeader*>(&::cockroach::roachpb::ResponseHeader::default_instance());
}

RangeLookupResponse::RangeLookupResponse(const RangeLookupResponse& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:cockroach.roachpb.RangeLookupResponse)
}

void RangeLookupResponse::SharedCtor() {
  _cached_size_ = 0;
  header_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RangeLookupResponse::~RangeLookupResponse() {
  // @@protoc_insertion_point(destructor:cockroach.roachpb.RangeLookupResponse)
  SharedDtor();
}

void RangeLookupResponse::SharedDtor() {
  if (this != default_instance_) {
    delete header_;
  }
}

void RangeLookupResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* RangeLookupResponse::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return RangeLookupResponse_descriptor_;
}

const RangeLookupResponse& RangeLookupResponse::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_cockroach_2froachpb_2fapi_2eproto();
  return *default_instance_;
}

RangeLookupResponse* RangeLookupResponse::default_instance_ = NULL;

RangeLookupResponse* RangeLookupResponse::New(::google::protobuf::Arena* arena) const {
  RangeLookupResponse* n = new RangeLookupResponse;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void RangeLookupResponse::Clear() {
  if (has_header()) {
    if (header_ != NULL) header_->::cockroach::roachpb::ResponseHeader::Clear();
  }
  ranges_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool RangeLookupResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:cockroach.roachpb.RangeLookupResponse)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .cockroach.roachpb.ResponseHeader header = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_header()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_ranges;
        break;
      }

      // repeated .cockroach.roachpb.RangeDescriptor ranges = 2;
      case 2: {
        if (tag == 18) {
         parse_ranges:
          DO_(input->IncrementRecursionDepth());
         parse_loop_ranges:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                input, add_ranges()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_loop_ranges;
        input->UnsafeDecrementRecursionDepth();
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:cockroach.roachpb.RangeLookupResponse)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:cockroach.roachpb.RangeLookupResponse)
  return false;
#undef DO_
}

void RangeLookupResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:cockroach.roachpb.RangeLookupResponse)
  // optional .cockroach.roachpb.ResponseHeader header = 1;
  if (has_header()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->header_, output);
  }

  // repeated .cockroach.roachpb.RangeDescriptor ranges = 2;
  for (unsigned int i = 0, n = this->ranges_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->ranges(i), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:cockroach.roachpb.RangeLookupResponse)
}

::google::protobuf::uint8* RangeLookupResponse::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:cockroach.roachpb.RangeLookupResponse)
  // optional .cockroach.roachpb.ResponseHeader header = 1;
  if (has_header()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, *this->header_, target);
  }

  // repeated .cockroach.roachpb.RangeDescriptor ranges = 2;
  for (unsigned int i = 0, n = this->ranges_size(); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->ranges(i), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:cockroach.roachpb.RangeLookupResponse)
  return target;
}

int RangeLookupResponse::ByteSize() const {
  int total_size = 0;

  // optional .cockroach.roachpb.ResponseHeader header = 1;
  if (has_header()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->header_);
  }

  // repeated .cockroach.roachpb.RangeDescriptor ranges = 2;
  total_size += 1 * this->ranges_size();
  for (int i = 0; i < this->ranges_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->ranges(i));
  }

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RangeLookupResponse::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const RangeLookupResponse* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const RangeLookupResponse>(
          &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void RangeLookupResponse::MergeFrom(const RangeLookupResponse& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  ranges_.MergeFrom(from.ranges_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_header()) {
      mutable_header()->::cockroach::roachpb::ResponseHeader::MergeFrom(from.header());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void RangeLookupResponse::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void RangeLookupResponse::CopyFrom(const RangeLookupResponse& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RangeLookupResponse::IsInitialized() const {

  return true;
}

void RangeLookupResponse::Swap(RangeLookupResponse* other) {
  if (other == this) return;
  InternalSwap(other);
}
void RangeLookupResponse::InternalSwap(RangeLookupResponse* other) {
  std::swap(header_, other->header_);
  ranges_.UnsafeArenaSwap(&other->ranges_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata RangeLookupResponse::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = RangeLookupResponse_descriptor_;
  metadata.reflection = RangeLookupResponse_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// RangeLookupResponse

// optional .cockroach.roachpb.ResponseHeader header = 1;
bool RangeLookupResponse::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void RangeLookupResponse::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
void RangeLookupResponse::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
void RangeLookupResponse::clear_header() {
  if (header_ != NULL) header_->::cockroach::roachpb::ResponseHeader::Clear();
  clear_has_header();
}
const ::cockroach::roachpb::ResponseHeader& RangeLookupResponse::header() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.RangeLookupResponse.header)
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
::cockroach::roachpb::ResponseHeader* RangeLookupResponse::mutable_header() {
  set_has_header();
  if (header_ == NULL) {
    header_ = new ::cockroach::roachpb::ResponseHeader;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.RangeLookupResponse.header)
  return header_;
}
::cockroach::roachpb::ResponseHeader* RangeLookupResponse::release_header() {
  clear_has_header();
  ::cockroach::roachpb::ResponseHeader* temp = header_;
  header_ = NULL;
  return temp;
}
void RangeLookupResponse::set_allocated_header(::cockroach::roachpb::ResponseHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.RangeLookupResponse.header)
}

// repeated .cockroach.roachpb.RangeDescriptor ranges = 2;
int RangeLookupResponse::ranges_size() const {
  return ranges_.size();
}
void RangeLookupResponse::clear_ranges() {
  ranges_.Clear();
}
const ::cockroach::roachpb::RangeDescriptor& RangeLookupResponse::ranges(int index) const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.RangeLookupResponse.ranges)
  return ranges_.Get(index);
}
::cockroach::roachpb::RangeDescriptor* RangeLookupResponse::mutable_ranges(int index) {
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.RangeLookupResponse.ranges)
  return ranges_.Mutable(index);
}
::cockroach::roachpb::RangeDescriptor* RangeLookupResponse::add_ranges() {
  // @@protoc_insertion_point(field_add:cockroach.roachpb.RangeLookupResponse.ranges)
  return ranges_.Add();
}
::google::protobuf::RepeatedPtrField< ::cockroach::roachpb::RangeDescriptor >*
RangeLookupResponse::mutable_ranges() {
  // @@protoc_insertion_point(field_mutable_list:cockroach.roachpb.RangeLookupResponse.ranges)
  return &ranges_;
}
const ::google::protobuf::RepeatedPtrField< ::cockroach::roachpb::RangeDescriptor >&
RangeLookupResponse::ranges() const {
  // @@protoc_insertion_point(field_list:cockroach.roachpb.RangeLookupResponse.ranges)
  return ranges_;
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int HeartbeatTxnRequest::kHeaderFieldNumber;
const int HeartbeatTxnRequest::kNowFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

HeartbeatTxnRequest::HeartbeatTxnRequest()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:cockroach.roachpb.HeartbeatTxnRequest)
}

void HeartbeatTxnRequest::InitAsDefaultInstance() {
  header_ = const_cast< ::cockroach::roachpb::Span*>(&::cockroach::roachpb::Span::default_instance());
  now_ = const_cast< ::cockroach::roachpb::Timestamp*>(&::cockroach::roachpb::Timestamp::default_instance());
}

HeartbeatTxnRequest::HeartbeatTxnRequest(const HeartbeatTxnRequest& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:cockroach.roachpb.HeartbeatTxnRequest)
}

void HeartbeatTxnRequest::SharedCtor() {
  _cached_size_ = 0;
  header_ = NULL;
  now_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

HeartbeatTxnRequest::~HeartbeatTxnRequest() {
  // @@protoc_insertion_point(destructor:cockroach.roachpb.HeartbeatTxnRequest)
  SharedDtor();
}

void HeartbeatTxnRequest::SharedDtor() {
  if (this != default_instance_) {
    delete header_;
    delete now_;
  }
}

void HeartbeatTxnRequest::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* HeartbeatTxnRequest::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return HeartbeatTxnRequest_descriptor_;
}

const HeartbeatTxnRequest& HeartbeatTxnRequest::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_cockroach_2froachpb_2fapi_2eproto();
  return *default_instance_;
}

HeartbeatTxnRequest* HeartbeatTxnRequest::default_instance_ = NULL;

HeartbeatTxnRequest* HeartbeatTxnRequest::New(::google::protobuf::Arena* arena) const {
  HeartbeatTxnRequest* n = new HeartbeatTxnRequest;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void HeartbeatTxnRequest::Clear() {
  if (_has_bits_[0 / 32] & 3u) {
    if (has_header()) {
      if (header_ != NULL) header_->::cockroach::roachpb::Span::Clear();
    }
    if (has_now()) {
      if (now_ != NULL) now_->::cockroach::roachpb::Timestamp::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool HeartbeatTxnRequest::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:cockroach.roachpb.HeartbeatTxnRequest)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .cockroach.roachpb.Span header = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_header()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_now;
        break;
      }

      // optional .cockroach.roachpb.Timestamp now = 2;
      case 2: {
        if (tag == 18) {
         parse_now:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_now()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:cockroach.roachpb.HeartbeatTxnRequest)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:cockroach.roachpb.HeartbeatTxnRequest)
  return false;
#undef DO_
}

void HeartbeatTxnRequest::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:cockroach.roachpb.HeartbeatTxnRequest)
  // optional .cockroach.roachpb.Span header = 1;
  if (has_header()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->header_, output);
  }

  // optional .cockroach.roachpb.Timestamp now = 2;
  if (has_now()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, *this->now_, output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:cockroach.roachpb.HeartbeatTxnRequest)
}

::google::protobuf::uint8* HeartbeatTxnRequest::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:cockroach.roachpb.HeartbeatTxnRequest)
  // optional .cockroach.roachpb.Span header = 1;
  if (has_header()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, *this->header_, target);
  }

  // optional .cockroach.roachpb.Timestamp now = 2;
  if (has_now()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, *this->now_, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:cockroach.roachpb.HeartbeatTxnRequest)
  return target;
}

int HeartbeatTxnRequest::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & 3u) {
    // optional .cockroach.roachpb.Span header = 1;
    if (has_header()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->header_);
    }

    // optional .cockroach.roachpb.Timestamp now = 2;
    if (has_now()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->now_);
    }

  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void HeartbeatTxnRequest::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const HeartbeatTxnRequest* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const HeartbeatTxnRequest>(
          &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void HeartbeatTxnRequest::MergeFrom(const HeartbeatTxnRequest& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_header()) {
      mutable_header()->::cockroach::roachpb::Span::MergeFrom(from.header());
    }
    if (from.has_now()) {
      mutable_now()->::cockroach::roachpb::Timestamp::MergeFrom(from.now());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void HeartbeatTxnRequest::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void HeartbeatTxnRequest::CopyFrom(const HeartbeatTxnRequest& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool HeartbeatTxnRequest::IsInitialized() const {

  return true;
}

void HeartbeatTxnRequest::Swap(HeartbeatTxnRequest* other) {
  if (other == this) return;
  InternalSwap(other);
}
void HeartbeatTxnRequest::InternalSwap(HeartbeatTxnRequest* other) {
  std::swap(header_, other->header_);
  std::swap(now_, other->now_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata HeartbeatTxnRequest::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = HeartbeatTxnRequest_descriptor_;
  metadata.reflection = HeartbeatTxnRequest_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// HeartbeatTxnRequest

// optional .cockroach.roachpb.Span header = 1;
bool HeartbeatTxnRequest::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void HeartbeatTxnRequest::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
void HeartbeatTxnRequest::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
void HeartbeatTxnRequest::clear_header() {
  if (header_ != NULL) header_->::cockroach::roachpb::Span::Clear();
  clear_has_header();
}
const ::cockroach::roachpb::Span& HeartbeatTxnRequest::header() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.HeartbeatTxnRequest.header)
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
::cockroach::roachpb::Span* HeartbeatTxnRequest::mutable_header() {
  set_has_header();
  if (header_ == NULL) {
    header_ = new ::cockroach::roachpb::Span;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.HeartbeatTxnRequest.header)
  return header_;
}
::cockroach::roachpb::Span* HeartbeatTxnRequest::release_header() {
  clear_has_header();
  ::cockroach::roachpb::Span* temp = header_;
  header_ = NULL;
  return temp;
}
void HeartbeatTxnRequest::set_allocated_header(::cockroach::roachpb::Span* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.HeartbeatTxnRequest.header)
}

// optional .cockroach.roachpb.Timestamp now = 2;
bool HeartbeatTxnRequest::has_now() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void HeartbeatTxnRequest::set_has_now() {
  _has_bits_[0] |= 0x00000002u;
}
void HeartbeatTxnRequest::clear_has_now() {
  _has_bits_[0] &= ~0x00000002u;
}
void HeartbeatTxnRequest::clear_now() {
  if (now_ != NULL) now_->::cockroach::roachpb::Timestamp::Clear();
  clear_has_now();
}
const ::cockroach::roachpb::Timestamp& HeartbeatTxnRequest::now() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.HeartbeatTxnRequest.now)
  return now_ != NULL ? *now_ : *default_instance_->now_;
}
::cockroach::roachpb::Timestamp* HeartbeatTxnRequest::mutable_now() {
  set_has_now();
  if (now_ == NULL) {
    now_ = new ::cockroach::roachpb::Timestamp;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.HeartbeatTxnRequest.now)
  return now_;
}
::cockroach::roachpb::Timestamp* HeartbeatTxnRequest::release_now() {
  clear_has_now();
  ::cockroach::roachpb::Timestamp* temp = now_;
  now_ = NULL;
  return temp;
}
void HeartbeatTxnRequest::set_allocated_now(::cockroach::roachpb::Timestamp* now) {
  delete now_;
  now_ = now;
  if (now) {
    set_has_now();
  } else {
    clear_has_now();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.HeartbeatTxnRequest.now)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int HeartbeatTxnResponse::kHeaderFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

HeartbeatTxnResponse::HeartbeatTxnResponse()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:cockroach.roachpb.HeartbeatTxnResponse)
}

void HeartbeatTxnResponse::InitAsDefaultInstance() {
  header_ = const_cast< ::cockroach::roachpb::ResponseHeader*>(&::cockroach::roachpb::ResponseHeader::default_instance());
}

HeartbeatTxnResponse::HeartbeatTxnResponse(const HeartbeatTxnResponse& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:cockroach.roachpb.HeartbeatTxnResponse)
}

void HeartbeatTxnResponse::SharedCtor() {
  _cached_size_ = 0;
  header_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

HeartbeatTxnResponse::~HeartbeatTxnResponse() {
  // @@protoc_insertion_point(destructor:cockroach.roachpb.HeartbeatTxnResponse)
  SharedDtor();
}

void HeartbeatTxnResponse::SharedDtor() {
  if (this != default_instance_) {
    delete header_;
  }
}

void HeartbeatTxnResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* HeartbeatTxnResponse::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return HeartbeatTxnResponse_descriptor_;
}

const HeartbeatTxnResponse& HeartbeatTxnResponse::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_cockroach_2froachpb_2fapi_2eproto();
  return *default_instance_;
}

HeartbeatTxnResponse* HeartbeatTxnResponse::default_instance_ = NULL;

HeartbeatTxnResponse* HeartbeatTxnResponse::New(::google::protobuf::Arena* arena) const {
  HeartbeatTxnResponse* n = new HeartbeatTxnResponse;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void HeartbeatTxnResponse::Clear() {
  if (has_header()) {
    if (header_ != NULL) header_->::cockroach::roachpb::ResponseHeader::Clear();
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool HeartbeatTxnResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:cockroach.roachpb.HeartbeatTxnResponse)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .cockroach.roachpb.ResponseHeader header = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_header()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:cockroach.roachpb.HeartbeatTxnResponse)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:cockroach.roachpb.HeartbeatTxnResponse)
  return false;
#undef DO_
}

void HeartbeatTxnResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:cockroach.roachpb.HeartbeatTxnResponse)
  // optional .cockroach.roachpb.ResponseHeader header = 1;
  if (has_header()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->header_, output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:cockroach.roachpb.HeartbeatTxnResponse)
}

::google::protobuf::uint8* HeartbeatTxnResponse::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:cockroach.roachpb.HeartbeatTxnResponse)
  // optional .cockroach.roachpb.ResponseHeader header = 1;
  if (has_header()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, *this->header_, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:cockroach.roachpb.HeartbeatTxnResponse)
  return target;
}

int HeartbeatTxnResponse::ByteSize() const {
  int total_size = 0;

  // optional .cockroach.roachpb.ResponseHeader header = 1;
  if (has_header()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->header_);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void HeartbeatTxnResponse::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const HeartbeatTxnResponse* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const HeartbeatTxnResponse>(
          &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void HeartbeatTxnResponse::MergeFrom(const HeartbeatTxnResponse& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_header()) {
      mutable_header()->::cockroach::roachpb::ResponseHeader::MergeFrom(from.header());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void HeartbeatTxnResponse::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void HeartbeatTxnResponse::CopyFrom(const HeartbeatTxnResponse& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool HeartbeatTxnResponse::IsInitialized() const {

  return true;
}

void HeartbeatTxnResponse::Swap(HeartbeatTxnResponse* other) {
  if (other == this) return;
  InternalSwap(other);
}
void HeartbeatTxnResponse::InternalSwap(HeartbeatTxnResponse* other) {
  std::swap(header_, other->header_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata HeartbeatTxnResponse::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = HeartbeatTxnResponse_descriptor_;
  metadata.reflection = HeartbeatTxnResponse_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// HeartbeatTxnResponse

// optional .cockroach.roachpb.ResponseHeader header = 1;
bool HeartbeatTxnResponse::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void HeartbeatTxnResponse::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
void HeartbeatTxnResponse::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
void HeartbeatTxnResponse::clear_header() {
  if (header_ != NULL) header_->::cockroach::roachpb::ResponseHeader::Clear();
  clear_has_header();
}
const ::cockroach::roachpb::ResponseHeader& HeartbeatTxnResponse::header() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.HeartbeatTxnResponse.header)
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
::cockroach::roachpb::ResponseHeader* HeartbeatTxnResponse::mutable_header() {
  set_has_header();
  if (header_ == NULL) {
    header_ = new ::cockroach::roachpb::ResponseHeader;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.HeartbeatTxnResponse.header)
  return header_;
}
::cockroach::roachpb::ResponseHeader* HeartbeatTxnResponse::release_header() {
  clear_has_header();
  ::cockroach::roachpb::ResponseHeader* temp = header_;
  header_ = NULL;
  return temp;
}
void HeartbeatTxnResponse::set_allocated_header(::cockroach::roachpb::ResponseHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.HeartbeatTxnResponse.header)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int GCRequest_GCKey::kKeyFieldNumber;
const int GCRequest_GCKey::kTimestampFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

GCRequest_GCKey::GCRequest_GCKey()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:cockroach.roachpb.GCRequest.GCKey)
}

void GCRequest_GCKey::InitAsDefaultInstance() {
  timestamp_ = const_cast< ::cockroach::roachpb::Timestamp*>(&::cockroach::roachpb::Timestamp::default_instance());
}

GCRequest_GCKey::GCRequest_GCKey(const GCRequest_GCKey& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:cockroach.roachpb.GCRequest.GCKey)
}

void GCRequest_GCKey::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  key_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  timestamp_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GCRequest_GCKey::~GCRequest_GCKey() {
  // @@protoc_insertion_point(destructor:cockroach.roachpb.GCRequest.GCKey)
  SharedDtor();
}

void GCRequest_GCKey::SharedDtor() {
  key_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != default_instance_) {
    delete timestamp_;
  }
}

void GCRequest_GCKey::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* GCRequest_GCKey::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return GCRequest_GCKey_descriptor_;
}

const GCRequest_GCKey& GCRequest_GCKey::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_cockroach_2froachpb_2fapi_2eproto();
  return *default_instance_;
}

GCRequest_GCKey* GCRequest_GCKey::default_instance_ = NULL;

GCRequest_GCKey* GCRequest_GCKey::New(::google::protobuf::Arena* arena) const {
  GCRequest_GCKey* n = new GCRequest_GCKey;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void GCRequest_GCKey::Clear() {
  if (_has_bits_[0 / 32] & 3u) {
    if (has_key()) {
      key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    if (has_timestamp()) {
      if (timestamp_ != NULL) timestamp_->::cockroach::roachpb::Timestamp::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool GCRequest_GCKey::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:cockroach.roachpb.GCRequest.GCKey)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional bytes key = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_key()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_timestamp;
        break;
      }

      // optional .cockroach.roachpb.Timestamp timestamp = 2;
      case 2: {
        if (tag == 18) {
         parse_timestamp:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_timestamp()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:cockroach.roachpb.GCRequest.GCKey)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:cockroach.roachpb.GCRequest.GCKey)
  return false;
#undef DO_
}

void GCRequest_GCKey::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:cockroach.roachpb.GCRequest.GCKey)
  // optional bytes key = 1;
  if (has_key()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      1, this->key(), output);
  }

  // optional .cockroach.roachpb.Timestamp timestamp = 2;
  if (has_timestamp()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, *this->timestamp_, output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:cockroach.roachpb.GCRequest.GCKey)
}

::google::protobuf::uint8* GCRequest_GCKey::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:cockroach.roachpb.GCRequest.GCKey)
  // optional bytes key = 1;
  if (has_key()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        1, this->key(), target);
  }

  // optional .cockroach.roachpb.Timestamp timestamp = 2;
  if (has_timestamp()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, *this->timestamp_, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:cockroach.roachpb.GCRequest.GCKey)
  return target;
}

int GCRequest_GCKey::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & 3u) {
    // optional bytes key = 1;
    if (has_key()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->key());
    }

    // optional .cockroach.roachpb.Timestamp timestamp = 2;
    if (has_timestamp()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->timestamp_);
    }

  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GCRequest_GCKey::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const GCRequest_GCKey* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const GCRequest_GCKey>(
          &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void GCRequest_GCKey::MergeFrom(const GCRequest_GCKey& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_key()) {
      set_has_key();
      key_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.key_);
    }
    if (from.has_timestamp()) {
      mutable_timestamp()->::cockroach::roachpb::Timestamp::MergeFrom(from.timestamp());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void GCRequest_GCKey::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void GCRequest_GCKey::CopyFrom(const GCRequest_GCKey& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GCRequest_GCKey::IsInitialized() const {

  return true;
}

void GCRequest_GCKey::Swap(GCRequest_GCKey* other) {
  if (other == this) return;
  InternalSwap(other);
}
void GCRequest_GCKey::InternalSwap(GCRequest_GCKey* other) {
  key_.Swap(&other->key_);
  std::swap(timestamp_, other->timestamp_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata GCRequest_GCKey::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = GCRequest_GCKey_descriptor_;
  metadata.reflection = GCRequest_GCKey_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int GCRequest::kHeaderFieldNumber;
const int GCRequest::kKeysFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

GCRequest::GCRequest()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:cockroach.roachpb.GCRequest)
}

void GCRequest::InitAsDefaultInstance() {
  header_ = const_cast< ::cockroach::roachpb::Span*>(&::cockroach::roachpb::Span::default_instance());
}

GCRequest::GCRequest(const GCRequest& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:cockroach.roachpb.GCRequest)
}

void GCRequest::SharedCtor() {
  _cached_size_ = 0;
  header_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GCRequest::~GCRequest() {
  // @@protoc_insertion_point(destructor:cockroach.roachpb.GCRequest)
  SharedDtor();
}

void GCRequest::SharedDtor() {
  if (this != default_instance_) {
    delete header_;
  }
}

void GCRequest::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* GCRequest::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return GCRequest_descriptor_;
}

const GCRequest& GCRequest::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_cockroach_2froachpb_2fapi_2eproto();
  return *default_instance_;
}

GCRequest* GCRequest::default_instance_ = NULL;

GCRequest* GCRequest::New(::google::protobuf::Arena* arena) const {
  GCRequest* n = new GCRequest;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void GCRequest::Clear() {
  if (has_header()) {
    if (header_ != NULL) header_->::cockroach::roachpb::Span::Clear();
  }
  keys_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool GCRequest::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:cockroach.roachpb.GCRequest)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .cockroach.roachpb.Span header = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_header()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_keys;
        break;
      }

      // repeated .cockroach.roachpb.GCRequest.GCKey keys = 3;
      case 3: {
        if (tag == 26) {
         parse_keys:
          DO_(input->IncrementRecursionDepth());
         parse_loop_keys:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                input, add_keys()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_loop_keys;
        input->UnsafeDecrementRecursionDepth();
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:cockroach.roachpb.GCRequest)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:cockroach.roachpb.GCRequest)
  return false;
#undef DO_
}

void GCRequest::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:cockroach.roachpb.GCRequest)
  // optional .cockroach.roachpb.Span header = 1;
  if (has_header()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->header_, output);
  }

  // repeated .cockroach.roachpb.GCRequest.GCKey keys = 3;
  for (unsigned int i = 0, n = this->keys_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->keys(i), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:cockroach.roachpb.GCRequest)
}

::google::protobuf::uint8* GCRequest::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:cockroach.roachpb.GCRequest)
  // optional .cockroach.roachpb.Span header = 1;
  if (has_header()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, *this->header_, target);
  }

  // repeated .cockroach.roachpb.GCRequest.GCKey keys = 3;
  for (unsigned int i = 0, n = this->keys_size(); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->keys(i), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:cockroach.roachpb.GCRequest)
  return target;
}

int GCRequest::ByteSize() const {
  int total_size = 0;

  // optional .cockroach.roachpb.Span header = 1;
  if (has_header()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->header_);
  }

  // repeated .cockroach.roachpb.GCRequest.GCKey keys = 3;
  total_size += 1 * this->keys_size();
  for (int i = 0; i < this->keys_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->keys(i));
  }

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GCRequest::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const GCRequest* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const GCRequest>(
          &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void GCRequest::MergeFrom(const GCRequest& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  keys_.MergeFrom(from.keys_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_header()) {
      mutable_header()->::cockroach::roachpb::Span::MergeFrom(from.header());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void GCRequest::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void GCRequest::CopyFrom(const GCRequest& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GCRequest::IsInitialized() const {

  return true;
}

void GCRequest::Swap(GCRequest* other) {
  if (other == this) return;
  InternalSwap(other);
}
void GCRequest::InternalSwap(GCRequest* other) {
  std::swap(header_, other->header_);
  keys_.UnsafeArenaSwap(&other->keys_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata GCRequest::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = GCRequest_descriptor_;
  metadata.reflection = GCRequest_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// GCRequest_GCKey

// optional bytes key = 1;
bool GCRequest_GCKey::has_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void GCRequest_GCKey::set_has_key() {
  _has_bits_[0] |= 0x00000001u;
}
void GCRequest_GCKey::clear_has_key() {
  _has_bits_[0] &= ~0x00000001u;
}
void GCRequest_GCKey::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_key();
}
 const ::std::string& GCRequest_GCKey::key() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.GCRequest.GCKey.key)
  return key_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void GCRequest_GCKey::set_key(const ::std::string& value) {
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cockroach.roachpb.GCRequest.GCKey.key)
}
 void GCRequest_GCKey::set_key(const char* value) {
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cockroach.roachpb.GCRequest.GCKey.key)
}
 void GCRequest_GCKey::set_key(const void* value, size_t size) {
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cockroach.roachpb.GCRequest.GCKey.key)
}
 ::std::string* GCRequest_GCKey::mutable_key() {
  set_has_key();
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.GCRequest.GCKey.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* GCRequest_GCKey::release_key() {
  clear_has_key();
  return key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void GCRequest_GCKey::set_allocated_key(::std::string* key) {
  if (key != NULL) {
    set_has_key();
  } else {
    clear_has_key();
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.GCRequest.GCKey.key)
}

// optional .cockroach.roachpb.Timestamp timestamp = 2;
bool GCRequest_GCKey::has_timestamp() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void GCRequest_GCKey::set_has_timestamp() {
  _has_bits_[0] |= 0x00000002u;
}
void GCRequest_GCKey::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000002u;
}
void GCRequest_GCKey::clear_timestamp() {
  if (timestamp_ != NULL) timestamp_->::cockroach::roachpb::Timestamp::Clear();
  clear_has_timestamp();
}
const ::cockroach::roachpb::Timestamp& GCRequest_GCKey::timestamp() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.GCRequest.GCKey.timestamp)
  return timestamp_ != NULL ? *timestamp_ : *default_instance_->timestamp_;
}
::cockroach::roachpb::Timestamp* GCRequest_GCKey::mutable_timestamp() {
  set_has_timestamp();
  if (timestamp_ == NULL) {
    timestamp_ = new ::cockroach::roachpb::Timestamp;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.GCRequest.GCKey.timestamp)
  return timestamp_;
}
::cockroach::roachpb::Timestamp* GCRequest_GCKey::release_timestamp() {
  clear_has_timestamp();
  ::cockroach::roachpb::Timestamp* temp = timestamp_;
  timestamp_ = NULL;
  return temp;
}
void GCRequest_GCKey::set_allocated_timestamp(::cockroach::roachpb::Timestamp* timestamp) {
  delete timestamp_;
  timestamp_ = timestamp;
  if (timestamp) {
    set_has_timestamp();
  } else {
    clear_has_timestamp();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.GCRequest.GCKey.timestamp)
}

// -------------------------------------------------------------------

// GCRequest

// optional .cockroach.roachpb.Span header = 1;
bool GCRequest::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void GCRequest::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
void GCRequest::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
void GCRequest::clear_header() {
  if (header_ != NULL) header_->::cockroach::roachpb::Span::Clear();
  clear_has_header();
}
const ::cockroach::roachpb::Span& GCRequest::header() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.GCRequest.header)
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
::cockroach::roachpb::Span* GCRequest::mutable_header() {
  set_has_header();
  if (header_ == NULL) {
    header_ = new ::cockroach::roachpb::Span;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.GCRequest.header)
  return header_;
}
::cockroach::roachpb::Span* GCRequest::release_header() {
  clear_has_header();
  ::cockroach::roachpb::Span* temp = header_;
  header_ = NULL;
  return temp;
}
void GCRequest::set_allocated_header(::cockroach::roachpb::Span* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.GCRequest.header)
}

// repeated .cockroach.roachpb.GCRequest.GCKey keys = 3;
int GCRequest::keys_size() const {
  return keys_.size();
}
void GCRequest::clear_keys() {
  keys_.Clear();
}
const ::cockroach::roachpb::GCRequest_GCKey& GCRequest::keys(int index) const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.GCRequest.keys)
  return keys_.Get(index);
}
::cockroach::roachpb::GCRequest_GCKey* GCRequest::mutable_keys(int index) {
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.GCRequest.keys)
  return keys_.Mutable(index);
}
::cockroach::roachpb::GCRequest_GCKey* GCRequest::add_keys() {
  // @@protoc_insertion_point(field_add:cockroach.roachpb.GCRequest.keys)
  return keys_.Add();
}
::google::protobuf::RepeatedPtrField< ::cockroach::roachpb::GCRequest_GCKey >*
GCRequest::mutable_keys() {
  // @@protoc_insertion_point(field_mutable_list:cockroach.roachpb.GCRequest.keys)
  return &keys_;
}
const ::google::protobuf::RepeatedPtrField< ::cockroach::roachpb::GCRequest_GCKey >&
GCRequest::keys() const {
  // @@protoc_insertion_point(field_list:cockroach.roachpb.GCRequest.keys)
  return keys_;
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int GCResponse::kHeaderFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

GCResponse::GCResponse()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:cockroach.roachpb.GCResponse)
}

void GCResponse::InitAsDefaultInstance() {
  header_ = const_cast< ::cockroach::roachpb::ResponseHeader*>(&::cockroach::roachpb::ResponseHeader::default_instance());
}

GCResponse::GCResponse(const GCResponse& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:cockroach.roachpb.GCResponse)
}

void GCResponse::SharedCtor() {
  _cached_size_ = 0;
  header_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GCResponse::~GCResponse() {
  // @@protoc_insertion_point(destructor:cockroach.roachpb.GCResponse)
  SharedDtor();
}

void GCResponse::SharedDtor() {
  if (this != default_instance_) {
    delete header_;
  }
}

void GCResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* GCResponse::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return GCResponse_descriptor_;
}

const GCResponse& GCResponse::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_cockroach_2froachpb_2fapi_2eproto();
  return *default_instance_;
}

GCResponse* GCResponse::default_instance_ = NULL;

GCResponse* GCResponse::New(::google::protobuf::Arena* arena) const {
  GCResponse* n = new GCResponse;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void GCResponse::Clear() {
  if (has_header()) {
    if (header_ != NULL) header_->::cockroach::roachpb::ResponseHeader::Clear();
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool GCResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:cockroach.roachpb.GCResponse)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .cockroach.roachpb.ResponseHeader header = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_header()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:cockroach.roachpb.GCResponse)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:cockroach.roachpb.GCResponse)
  return false;
#undef DO_
}

void GCResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:cockroach.roachpb.GCResponse)
  // optional .cockroach.roachpb.ResponseHeader header = 1;
  if (has_header()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->header_, output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:cockroach.roachpb.GCResponse)
}

::google::protobuf::uint8* GCResponse::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:cockroach.roachpb.GCResponse)
  // optional .cockroach.roachpb.ResponseHeader header = 1;
  if (has_header()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, *this->header_, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:cockroach.roachpb.GCResponse)
  return target;
}

int GCResponse::ByteSize() const {
  int total_size = 0;

  // optional .cockroach.roachpb.ResponseHeader header = 1;
  if (has_header()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->header_);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GCResponse::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const GCResponse* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const GCResponse>(
          &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void GCResponse::MergeFrom(const GCResponse& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_header()) {
      mutable_header()->::cockroach::roachpb::ResponseHeader::MergeFrom(from.header());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void GCResponse::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void GCResponse::CopyFrom(const GCResponse& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GCResponse::IsInitialized() const {

  return true;
}

void GCResponse::Swap(GCResponse* other) {
  if (other == this) return;
  InternalSwap(other);
}
void GCResponse::InternalSwap(GCResponse* other) {
  std::swap(header_, other->header_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata GCResponse::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = GCResponse_descriptor_;
  metadata.reflection = GCResponse_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// GCResponse

// optional .cockroach.roachpb.ResponseHeader header = 1;
bool GCResponse::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void GCResponse::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
void GCResponse::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
void GCResponse::clear_header() {
  if (header_ != NULL) header_->::cockroach::roachpb::ResponseHeader::Clear();
  clear_has_header();
}
const ::cockroach::roachpb::ResponseHeader& GCResponse::header() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.GCResponse.header)
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
::cockroach::roachpb::ResponseHeader* GCResponse::mutable_header() {
  set_has_header();
  if (header_ == NULL) {
    header_ = new ::cockroach::roachpb::ResponseHeader;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.GCResponse.header)
  return header_;
}
::cockroach::roachpb::ResponseHeader* GCResponse::release_header() {
  clear_has_header();
  ::cockroach::roachpb::ResponseHeader* temp = header_;
  header_ = NULL;
  return temp;
}
void GCResponse::set_allocated_header(::cockroach::roachpb::ResponseHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.GCResponse.header)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int PushTxnRequest::kHeaderFieldNumber;
const int PushTxnRequest::kPusherTxnFieldNumber;
const int PushTxnRequest::kPusheeTxnFieldNumber;
const int PushTxnRequest::kPushToFieldNumber;
const int PushTxnRequest::kNowFieldNumber;
const int PushTxnRequest::kPushTypeFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

PushTxnRequest::PushTxnRequest()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:cockroach.roachpb.PushTxnRequest)
}

void PushTxnRequest::InitAsDefaultInstance() {
  header_ = const_cast< ::cockroach::roachpb::Span*>(&::cockroach::roachpb::Span::default_instance());
  pusher_txn_ = const_cast< ::cockroach::roachpb::Transaction*>(&::cockroach::roachpb::Transaction::default_instance());
  pushee_txn_ = const_cast< ::cockroach::roachpb::TxnMeta*>(&::cockroach::roachpb::TxnMeta::default_instance());
  push_to_ = const_cast< ::cockroach::roachpb::Timestamp*>(&::cockroach::roachpb::Timestamp::default_instance());
  now_ = const_cast< ::cockroach::roachpb::Timestamp*>(&::cockroach::roachpb::Timestamp::default_instance());
}

PushTxnRequest::PushTxnRequest(const PushTxnRequest& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:cockroach.roachpb.PushTxnRequest)
}

void PushTxnRequest::SharedCtor() {
  _cached_size_ = 0;
  header_ = NULL;
  pusher_txn_ = NULL;
  pushee_txn_ = NULL;
  push_to_ = NULL;
  now_ = NULL;
  push_type_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

PushTxnRequest::~PushTxnRequest() {
  // @@protoc_insertion_point(destructor:cockroach.roachpb.PushTxnRequest)
  SharedDtor();
}

void PushTxnRequest::SharedDtor() {
  if (this != default_instance_) {
    delete header_;
    delete pusher_txn_;
    delete pushee_txn_;
    delete push_to_;
    delete now_;
  }
}

void PushTxnRequest::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* PushTxnRequest::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return PushTxnRequest_descriptor_;
}

const PushTxnRequest& PushTxnRequest::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_cockroach_2froachpb_2fapi_2eproto();
  return *default_instance_;
}

PushTxnRequest* PushTxnRequest::default_instance_ = NULL;

PushTxnRequest* PushTxnRequest::New(::google::protobuf::Arena* arena) const {
  PushTxnRequest* n = new PushTxnRequest;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void PushTxnRequest::Clear() {
  if (_has_bits_[0 / 32] & 63u) {
    if (has_header()) {
      if (header_ != NULL) header_->::cockroach::roachpb::Span::Clear();
    }
    if (has_pusher_txn()) {
      if (pusher_txn_ != NULL) pusher_txn_->::cockroach::roachpb::Transaction::Clear();
    }
    if (has_pushee_txn()) {
      if (pushee_txn_ != NULL) pushee_txn_->::cockroach::roachpb::TxnMeta::Clear();
    }
    if (has_push_to()) {
      if (push_to_ != NULL) push_to_->::cockroach::roachpb::Timestamp::Clear();
    }
    if (has_now()) {
      if (now_ != NULL) now_->::cockroach::roachpb::Timestamp::Clear();
    }
    push_type_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool PushTxnRequest::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:cockroach.roachpb.PushTxnRequest)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .cockroach.roachpb.Span header = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_header()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_pusher_txn;
        break;
      }

      // optional .cockroach.roachpb.Transaction pusher_txn = 2;
      case 2: {
        if (tag == 18) {
         parse_pusher_txn:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_pusher_txn()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_pushee_txn;
        break;
      }

      // optional .cockroach.roachpb.TxnMeta pushee_txn = 3;
      case 3: {
        if (tag == 26) {
         parse_pushee_txn:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_pushee_txn()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_push_to;
        break;
      }

      // optional .cockroach.roachpb.Timestamp push_to = 4;
      case 4: {
        if (tag == 34) {
         parse_push_to:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_push_to()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_now;
        break;
      }

      // optional .cockroach.roachpb.Timestamp now = 5;
      case 5: {
        if (tag == 42) {
         parse_now:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_now()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(48)) goto parse_push_type;
        break;
      }

      // optional .cockroach.roachpb.PushTxnType push_type = 6;
      case 6: {
        if (tag == 48) {
         parse_push_type:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::cockroach::roachpb::PushTxnType_IsValid(value)) {
            set_push_type(static_cast< ::cockroach::roachpb::PushTxnType >(value));
          } else {
            mutable_unknown_fields()->AddVarint(6, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:cockroach.roachpb.PushTxnRequest)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:cockroach.roachpb.PushTxnRequest)
  return false;
#undef DO_
}

void PushTxnRequest::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:cockroach.roachpb.PushTxnRequest)
  // optional .cockroach.roachpb.Span header = 1;
  if (has_header()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->header_, output);
  }

  // optional .cockroach.roachpb.Transaction pusher_txn = 2;
  if (has_pusher_txn()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, *this->pusher_txn_, output);
  }

  // optional .cockroach.roachpb.TxnMeta pushee_txn = 3;
  if (has_pushee_txn()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, *this->pushee_txn_, output);
  }

  // optional .cockroach.roachpb.Timestamp push_to = 4;
  if (has_push_to()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, *this->push_to_, output);
  }

  // optional .cockroach.roachpb.Timestamp now = 5;
  if (has_now()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      5, *this->now_, output);
  }

  // optional .cockroach.roachpb.PushTxnType push_type = 6;
  if (has_push_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      6, this->push_type(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:cockroach.roachpb.PushTxnRequest)
}

::google::protobuf::uint8* PushTxnRequest::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:cockroach.roachpb.PushTxnRequest)
  // optional .cockroach.roachpb.Span header = 1;
  if (has_header()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, *this->header_, target);
  }

  // optional .cockroach.roachpb.Transaction pusher_txn = 2;
  if (has_pusher_txn()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, *this->pusher_txn_, target);
  }

  // optional .cockroach.roachpb.TxnMeta pushee_txn = 3;
  if (has_pushee_txn()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, *this->pushee_txn_, target);
  }

  // optional .cockroach.roachpb.Timestamp push_to = 4;
  if (has_push_to()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        4, *this->push_to_, target);
  }

  // optional .cockroach.roachpb.Timestamp now = 5;
  if (has_now()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        5, *this->now_, target);
  }

  // optional .cockroach.roachpb.PushTxnType push_type = 6;
  if (has_push_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      6, this->push_type(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:cockroach.roachpb.PushTxnRequest)
  return target;
}

int PushTxnRequest::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & 63u) {
    // optional .cockroach.roachpb.Span header = 1;
    if (has_header()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->header_);
    }

    // optional .cockroach.roachpb.Transaction pusher_txn = 2;
    if (has_pusher_txn()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->pusher_txn_);
    }

    // optional .cockroach.roachpb.TxnMeta pushee_txn = 3;
    if (has_pushee_txn()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->pushee_txn_);
    }

    // optional .cockroach.roachpb.Timestamp push_to = 4;
    if (has_push_to()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->push_to_);
    }

    // optional .cockroach.roachpb.Timestamp now = 5;
    if (has_now()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->now_);
    }

    // optional .cockroach.roachpb.PushTxnType push_type = 6;
    if (has_push_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->push_type());
    }

  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void PushTxnRequest::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const PushTxnRequest* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const PushTxnRequest>(
          &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void PushTxnRequest::MergeFrom(const PushTxnRequest& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_header()) {
      mutable_header()->::cockroach::roachpb::Span::MergeFrom(from.header());
    }
    if (from.has_pusher_txn()) {
      mutable_pusher_txn()->::cockroach::roachpb::Transaction::MergeFrom(from.pusher_txn());
    }
    if (from.has_pushee_txn()) {
      mutable_pushee_txn()->::cockroach::roachpb::TxnMeta::MergeFrom(from.pushee_txn());
    }
    if (from.has_push_to()) {
      mutable_push_to()->::cockroach::roachpb::Timestamp::MergeFrom(from.push_to());
    }
    if (from.has_now()) {
      mutable_now()->::cockroach::roachpb::Timestamp::MergeFrom(from.now());
    }
    if (from.has_push_type()) {
      set_push_type(from.push_type());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void PushTxnRequest::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void PushTxnRequest::CopyFrom(const PushTxnRequest& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PushTxnRequest::IsInitialized() const {

  return true;
}

void PushTxnRequest::Swap(PushTxnRequest* other) {
  if (other == this) return;
  InternalSwap(other);
}
void PushTxnRequest::InternalSwap(PushTxnRequest* other) {
  std::swap(header_, other->header_);
  std::swap(pusher_txn_, other->pusher_txn_);
  std::swap(pushee_txn_, other->pushee_txn_);
  std::swap(push_to_, other->push_to_);
  std::swap(now_, other->now_);
  std::swap(push_type_, other->push_type_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata PushTxnRequest::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = PushTxnRequest_descriptor_;
  metadata.reflection = PushTxnRequest_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// PushTxnRequest

// optional .cockroach.roachpb.Span header = 1;
bool PushTxnRequest::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void PushTxnRequest::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
void PushTxnRequest::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
void PushTxnRequest::clear_header() {
  if (header_ != NULL) header_->::cockroach::roachpb::Span::Clear();
  clear_has_header();
}
const ::cockroach::roachpb::Span& PushTxnRequest::header() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.PushTxnRequest.header)
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
::cockroach::roachpb::Span* PushTxnRequest::mutable_header() {
  set_has_header();
  if (header_ == NULL) {
    header_ = new ::cockroach::roachpb::Span;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.PushTxnRequest.header)
  return header_;
}
::cockroach::roachpb::Span* PushTxnRequest::release_header() {
  clear_has_header();
  ::cockroach::roachpb::Span* temp = header_;
  header_ = NULL;
  return temp;
}
void PushTxnRequest::set_allocated_header(::cockroach::roachpb::Span* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.PushTxnRequest.header)
}

// optional .cockroach.roachpb.Transaction pusher_txn = 2;
bool PushTxnRequest::has_pusher_txn() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void PushTxnRequest::set_has_pusher_txn() {
  _has_bits_[0] |= 0x00000002u;
}
void PushTxnRequest::clear_has_pusher_txn() {
  _has_bits_[0] &= ~0x00000002u;
}
void PushTxnRequest::clear_pusher_txn() {
  if (pusher_txn_ != NULL) pusher_txn_->::cockroach::roachpb::Transaction::Clear();
  clear_has_pusher_txn();
}
const ::cockroach::roachpb::Transaction& PushTxnRequest::pusher_txn() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.PushTxnRequest.pusher_txn)
  return pusher_txn_ != NULL ? *pusher_txn_ : *default_instance_->pusher_txn_;
}
::cockroach::roachpb::Transaction* PushTxnRequest::mutable_pusher_txn() {
  set_has_pusher_txn();
  if (pusher_txn_ == NULL) {
    pusher_txn_ = new ::cockroach::roachpb::Transaction;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.PushTxnRequest.pusher_txn)
  return pusher_txn_;
}
::cockroach::roachpb::Transaction* PushTxnRequest::release_pusher_txn() {
  clear_has_pusher_txn();
  ::cockroach::roachpb::Transaction* temp = pusher_txn_;
  pusher_txn_ = NULL;
  return temp;
}
void PushTxnRequest::set_allocated_pusher_txn(::cockroach::roachpb::Transaction* pusher_txn) {
  delete pusher_txn_;
  pusher_txn_ = pusher_txn;
  if (pusher_txn) {
    set_has_pusher_txn();
  } else {
    clear_has_pusher_txn();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.PushTxnRequest.pusher_txn)
}

// optional .cockroach.roachpb.TxnMeta pushee_txn = 3;
bool PushTxnRequest::has_pushee_txn() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void PushTxnRequest::set_has_pushee_txn() {
  _has_bits_[0] |= 0x00000004u;
}
void PushTxnRequest::clear_has_pushee_txn() {
  _has_bits_[0] &= ~0x00000004u;
}
void PushTxnRequest::clear_pushee_txn() {
  if (pushee_txn_ != NULL) pushee_txn_->::cockroach::roachpb::TxnMeta::Clear();
  clear_has_pushee_txn();
}
const ::cockroach::roachpb::TxnMeta& PushTxnRequest::pushee_txn() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.PushTxnRequest.pushee_txn)
  return pushee_txn_ != NULL ? *pushee_txn_ : *default_instance_->pushee_txn_;
}
::cockroach::roachpb::TxnMeta* PushTxnRequest::mutable_pushee_txn() {
  set_has_pushee_txn();
  if (pushee_txn_ == NULL) {
    pushee_txn_ = new ::cockroach::roachpb::TxnMeta;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.PushTxnRequest.pushee_txn)
  return pushee_txn_;
}
::cockroach::roachpb::TxnMeta* PushTxnRequest::release_pushee_txn() {
  clear_has_pushee_txn();
  ::cockroach::roachpb::TxnMeta* temp = pushee_txn_;
  pushee_txn_ = NULL;
  return temp;
}
void PushTxnRequest::set_allocated_pushee_txn(::cockroach::roachpb::TxnMeta* pushee_txn) {
  delete pushee_txn_;
  pushee_txn_ = pushee_txn;
  if (pushee_txn) {
    set_has_pushee_txn();
  } else {
    clear_has_pushee_txn();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.PushTxnRequest.pushee_txn)
}

// optional .cockroach.roachpb.Timestamp push_to = 4;
bool PushTxnRequest::has_push_to() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void PushTxnRequest::set_has_push_to() {
  _has_bits_[0] |= 0x00000008u;
}
void PushTxnRequest::clear_has_push_to() {
  _has_bits_[0] &= ~0x00000008u;
}
void PushTxnRequest::clear_push_to() {
  if (push_to_ != NULL) push_to_->::cockroach::roachpb::Timestamp::Clear();
  clear_has_push_to();
}
const ::cockroach::roachpb::Timestamp& PushTxnRequest::push_to() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.PushTxnRequest.push_to)
  return push_to_ != NULL ? *push_to_ : *default_instance_->push_to_;
}
::cockroach::roachpb::Timestamp* PushTxnRequest::mutable_push_to() {
  set_has_push_to();
  if (push_to_ == NULL) {
    push_to_ = new ::cockroach::roachpb::Timestamp;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.PushTxnRequest.push_to)
  return push_to_;
}
::cockroach::roachpb::Timestamp* PushTxnRequest::release_push_to() {
  clear_has_push_to();
  ::cockroach::roachpb::Timestamp* temp = push_to_;
  push_to_ = NULL;
  return temp;
}
void PushTxnRequest::set_allocated_push_to(::cockroach::roachpb::Timestamp* push_to) {
  delete push_to_;
  push_to_ = push_to;
  if (push_to) {
    set_has_push_to();
  } else {
    clear_has_push_to();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.PushTxnRequest.push_to)
}

// optional .cockroach.roachpb.Timestamp now = 5;
bool PushTxnRequest::has_now() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
void PushTxnRequest::set_has_now() {
  _has_bits_[0] |= 0x00000010u;
}
void PushTxnRequest::clear_has_now() {
  _has_bits_[0] &= ~0x00000010u;
}
void PushTxnRequest::clear_now() {
  if (now_ != NULL) now_->::cockroach::roachpb::Timestamp::Clear();
  clear_has_now();
}
const ::cockroach::roachpb::Timestamp& PushTxnRequest::now() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.PushTxnRequest.now)
  return now_ != NULL ? *now_ : *default_instance_->now_;
}
::cockroach::roachpb::Timestamp* PushTxnRequest::mutable_now() {
  set_has_now();
  if (now_ == NULL) {
    now_ = new ::cockroach::roachpb::Timestamp;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.PushTxnRequest.now)
  return now_;
}
::cockroach::roachpb::Timestamp* PushTxnRequest::release_now() {
  clear_has_now();
  ::cockroach::roachpb::Timestamp* temp = now_;
  now_ = NULL;
  return temp;
}
void PushTxnRequest::set_allocated_now(::cockroach::roachpb::Timestamp* now) {
  delete now_;
  now_ = now;
  if (now) {
    set_has_now();
  } else {
    clear_has_now();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.PushTxnRequest.now)
}

// optional .cockroach.roachpb.PushTxnType push_type = 6;
bool PushTxnRequest::has_push_type() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
void PushTxnRequest::set_has_push_type() {
  _has_bits_[0] |= 0x00000020u;
}
void PushTxnRequest::clear_has_push_type() {
  _has_bits_[0] &= ~0x00000020u;
}
void PushTxnRequest::clear_push_type() {
  push_type_ = 0;
  clear_has_push_type();
}
 ::cockroach::roachpb::PushTxnType PushTxnRequest::push_type() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.PushTxnRequest.push_type)
  return static_cast< ::cockroach::roachpb::PushTxnType >(push_type_);
}
 void PushTxnRequest::set_push_type(::cockroach::roachpb::PushTxnType value) {
  assert(::cockroach::roachpb::PushTxnType_IsValid(value));
  set_has_push_type();
  push_type_ = value;
  // @@protoc_insertion_point(field_set:cockroach.roachpb.PushTxnRequest.push_type)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int PushTxnResponse::kHeaderFieldNumber;
const int PushTxnResponse::kPusheeTxnFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

PushTxnResponse::PushTxnResponse()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:cockroach.roachpb.PushTxnResponse)
}

void PushTxnResponse::InitAsDefaultInstance() {
  header_ = const_cast< ::cockroach::roachpb::ResponseHeader*>(&::cockroach::roachpb::ResponseHeader::default_instance());
  pushee_txn_ = const_cast< ::cockroach::roachpb::Transaction*>(&::cockroach::roachpb::Transaction::default_instance());
}

PushTxnResponse::PushTxnResponse(const PushTxnResponse& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:cockroach.roachpb.PushTxnResponse)
}

void PushTxnResponse::SharedCtor() {
  _cached_size_ = 0;
  header_ = NULL;
  pushee_txn_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

PushTxnResponse::~PushTxnResponse() {
  // @@protoc_insertion_point(destructor:cockroach.roachpb.PushTxnResponse)
  SharedDtor();
}

void PushTxnResponse::SharedDtor() {
  if (this != default_instance_) {
    delete header_;
    delete pushee_txn_;
  }
}

void PushTxnResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* PushTxnResponse::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return PushTxnResponse_descriptor_;
}

const PushTxnResponse& PushTxnResponse::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_cockroach_2froachpb_2fapi_2eproto();
  return *default_instance_;
}

PushTxnResponse* PushTxnResponse::default_instance_ = NULL;

PushTxnResponse* PushTxnResponse::New(::google::protobuf::Arena* arena) const {
  PushTxnResponse* n = new PushTxnResponse;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void PushTxnResponse::Clear() {
  if (_has_bits_[0 / 32] & 3u) {
    if (has_header()) {
      if (header_ != NULL) header_->::cockroach::roachpb::ResponseHeader::Clear();
    }
    if (has_pushee_txn()) {
      if (pushee_txn_ != NULL) pushee_txn_->::cockroach::roachpb::Transaction::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool PushTxnResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:cockroach.roachpb.PushTxnResponse)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .cockroach.roachpb.ResponseHeader header = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_header()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_pushee_txn;
        break;
      }

      // optional .cockroach.roachpb.Transaction pushee_txn = 2;
      case 2: {
        if (tag == 18) {
         parse_pushee_txn:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_pushee_txn()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:cockroach.roachpb.PushTxnResponse)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:cockroach.roachpb.PushTxnResponse)
  return false;
#undef DO_
}

void PushTxnResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:cockroach.roachpb.PushTxnResponse)
  // optional .cockroach.roachpb.ResponseHeader header = 1;
  if (has_header()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->header_, output);
  }

  // optional .cockroach.roachpb.Transaction pushee_txn = 2;
  if (has_pushee_txn()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, *this->pushee_txn_, output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:cockroach.roachpb.PushTxnResponse)
}

::google::protobuf::uint8* PushTxnResponse::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:cockroach.roachpb.PushTxnResponse)
  // optional .cockroach.roachpb.ResponseHeader header = 1;
  if (has_header()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, *this->header_, target);
  }

  // optional .cockroach.roachpb.Transaction pushee_txn = 2;
  if (has_pushee_txn()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, *this->pushee_txn_, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:cockroach.roachpb.PushTxnResponse)
  return target;
}

int PushTxnResponse::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & 3u) {
    // optional .cockroach.roachpb.ResponseHeader header = 1;
    if (has_header()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->header_);
    }

    // optional .cockroach.roachpb.Transaction pushee_txn = 2;
    if (has_pushee_txn()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->pushee_txn_);
    }

  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void PushTxnResponse::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const PushTxnResponse* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const PushTxnResponse>(
          &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void PushTxnResponse::MergeFrom(const PushTxnResponse& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_header()) {
      mutable_header()->::cockroach::roachpb::ResponseHeader::MergeFrom(from.header());
    }
    if (from.has_pushee_txn()) {
      mutable_pushee_txn()->::cockroach::roachpb::Transaction::MergeFrom(from.pushee_txn());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void PushTxnResponse::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void PushTxnResponse::CopyFrom(const PushTxnResponse& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PushTxnResponse::IsInitialized() const {

  return true;
}

void PushTxnResponse::Swap(PushTxnResponse* other) {
  if (other == this) return;
  InternalSwap(other);
}
void PushTxnResponse::InternalSwap(PushTxnResponse* other) {
  std::swap(header_, other->header_);
  std::swap(pushee_txn_, other->pushee_txn_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata PushTxnResponse::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = PushTxnResponse_descriptor_;
  metadata.reflection = PushTxnResponse_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// PushTxnResponse

// optional .cockroach.roachpb.ResponseHeader header = 1;
bool PushTxnResponse::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void PushTxnResponse::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
void PushTxnResponse::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
void PushTxnResponse::clear_header() {
  if (header_ != NULL) header_->::cockroach::roachpb::ResponseHeader::Clear();
  clear_has_header();
}
const ::cockroach::roachpb::ResponseHeader& PushTxnResponse::header() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.PushTxnResponse.header)
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
::cockroach::roachpb::ResponseHeader* PushTxnResponse::mutable_header() {
  set_has_header();
  if (header_ == NULL) {
    header_ = new ::cockroach::roachpb::ResponseHeader;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.PushTxnResponse.header)
  return header_;
}
::cockroach::roachpb::ResponseHeader* PushTxnResponse::release_header() {
  clear_has_header();
  ::cockroach::roachpb::ResponseHeader* temp = header_;
  header_ = NULL;
  return temp;
}
void PushTxnResponse::set_allocated_header(::cockroach::roachpb::ResponseHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.PushTxnResponse.header)
}

// optional .cockroach.roachpb.Transaction pushee_txn = 2;
bool PushTxnResponse::has_pushee_txn() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void PushTxnResponse::set_has_pushee_txn() {
  _has_bits_[0] |= 0x00000002u;
}
void PushTxnResponse::clear_has_pushee_txn() {
  _has_bits_[0] &= ~0x00000002u;
}
void PushTxnResponse::clear_pushee_txn() {
  if (pushee_txn_ != NULL) pushee_txn_->::cockroach::roachpb::Transaction::Clear();
  clear_has_pushee_txn();
}
const ::cockroach::roachpb::Transaction& PushTxnResponse::pushee_txn() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.PushTxnResponse.pushee_txn)
  return pushee_txn_ != NULL ? *pushee_txn_ : *default_instance_->pushee_txn_;
}
::cockroach::roachpb::Transaction* PushTxnResponse::mutable_pushee_txn() {
  set_has_pushee_txn();
  if (pushee_txn_ == NULL) {
    pushee_txn_ = new ::cockroach::roachpb::Transaction;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.PushTxnResponse.pushee_txn)
  return pushee_txn_;
}
::cockroach::roachpb::Transaction* PushTxnResponse::release_pushee_txn() {
  clear_has_pushee_txn();
  ::cockroach::roachpb::Transaction* temp = pushee_txn_;
  pushee_txn_ = NULL;
  return temp;
}
void PushTxnResponse::set_allocated_pushee_txn(::cockroach::roachpb::Transaction* pushee_txn) {
  delete pushee_txn_;
  pushee_txn_ = pushee_txn;
  if (pushee_txn) {
    set_has_pushee_txn();
  } else {
    clear_has_pushee_txn();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.PushTxnResponse.pushee_txn)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int ResolveIntentRequest::kHeaderFieldNumber;
const int ResolveIntentRequest::kIntentTxnFieldNumber;
const int ResolveIntentRequest::kStatusFieldNumber;
const int ResolveIntentRequest::kPoisonFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

ResolveIntentRequest::ResolveIntentRequest()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:cockroach.roachpb.ResolveIntentRequest)
}

void ResolveIntentRequest::InitAsDefaultInstance() {
  header_ = const_cast< ::cockroach::roachpb::Span*>(&::cockroach::roachpb::Span::default_instance());
  intent_txn_ = const_cast< ::cockroach::roachpb::TxnMeta*>(&::cockroach::roachpb::TxnMeta::default_instance());
}

ResolveIntentRequest::ResolveIntentRequest(const ResolveIntentRequest& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:cockroach.roachpb.ResolveIntentRequest)
}

void ResolveIntentRequest::SharedCtor() {
  _cached_size_ = 0;
  header_ = NULL;
  intent_txn_ = NULL;
  status_ = 0;
  poison_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ResolveIntentRequest::~ResolveIntentRequest() {
  // @@protoc_insertion_point(destructor:cockroach.roachpb.ResolveIntentRequest)
  SharedDtor();
}

void ResolveIntentRequest::SharedDtor() {
  if (this != default_instance_) {
    delete header_;
    delete intent_txn_;
  }
}

void ResolveIntentRequest::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ResolveIntentRequest::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ResolveIntentRequest_descriptor_;
}

const ResolveIntentRequest& ResolveIntentRequest::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_cockroach_2froachpb_2fapi_2eproto();
  return *default_instance_;
}

ResolveIntentRequest* ResolveIntentRequest::default_instance_ = NULL;

ResolveIntentRequest* ResolveIntentRequest::New(::google::protobuf::Arena* arena) const {
  ResolveIntentRequest* n = new ResolveIntentRequest;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void ResolveIntentRequest::Clear() {
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<ResolveIntentRequest*>(16)->f)

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  if (_has_bits_[0 / 32] & 15u) {
    ZR_(status_, poison_);
    if (has_header()) {
      if (header_ != NULL) header_->::cockroach::roachpb::Span::Clear();
    }
    if (has_intent_txn()) {
      if (intent_txn_ != NULL) intent_txn_->::cockroach::roachpb::TxnMeta::Clear();
    }
  }

#undef ZR_HELPER_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool ResolveIntentRequest::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:cockroach.roachpb.ResolveIntentRequest)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .cockroach.roachpb.Span header = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_header()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_intent_txn;
        break;
      }

      // optional .cockroach.roachpb.TxnMeta intent_txn = 2;
      case 2: {
        if (tag == 18) {
         parse_intent_txn:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_intent_txn()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_status;
        break;
      }

      // optional .cockroach.roachpb.TransactionStatus status = 3;
      case 3: {
        if (tag == 24) {
         parse_status:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::cockroach::roachpb::TransactionStatus_IsValid(value)) {
            set_status(static_cast< ::cockroach::roachpb::TransactionStatus >(value));
          } else {
            mutable_unknown_fields()->AddVarint(3, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_poison;
        break;
      }

      // optional bool poison = 4;
      case 4: {
        if (tag == 32) {
         parse_poison:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &poison_)));
          set_has_poison();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:cockroach.roachpb.ResolveIntentRequest)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:cockroach.roachpb.ResolveIntentRequest)
  return false;
#undef DO_
}

void ResolveIntentRequest::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:cockroach.roachpb.ResolveIntentRequest)
  // optional .cockroach.roachpb.Span header = 1;
  if (has_header()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->header_, output);
  }

  // optional .cockroach.roachpb.TxnMeta intent_txn = 2;
  if (has_intent_txn()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, *this->intent_txn_, output);
  }

  // optional .cockroach.roachpb.TransactionStatus status = 3;
  if (has_status()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      3, this->status(), output);
  }

  // optional bool poison = 4;
  if (has_poison()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(4, this->poison(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:cockroach.roachpb.ResolveIntentRequest)
}

::google::protobuf::uint8* ResolveIntentRequest::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:cockroach.roachpb.ResolveIntentRequest)
  // optional .cockroach.roachpb.Span header = 1;
  if (has_header()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, *this->header_, target);
  }

  // optional .cockroach.roachpb.TxnMeta intent_txn = 2;
  if (has_intent_txn()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, *this->intent_txn_, target);
  }

  // optional .cockroach.roachpb.TransactionStatus status = 3;
  if (has_status()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      3, this->status(), target);
  }

  // optional bool poison = 4;
  if (has_poison()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(4, this->poison(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:cockroach.roachpb.ResolveIntentRequest)
  return target;
}

int ResolveIntentRequest::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & 15u) {
    // optional .cockroach.roachpb.Span header = 1;
    if (has_header()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->header_);
    }

    // optional .cockroach.roachpb.TxnMeta intent_txn = 2;
    if (has_intent_txn()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->intent_txn_);
    }

    // optional .cockroach.roachpb.TransactionStatus status = 3;
    if (has_status()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->status());
    }

    // optional bool poison = 4;
    if (has_poison()) {
      total_size += 1 + 1;
    }

  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ResolveIntentRequest::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const ResolveIntentRequest* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const ResolveIntentRequest>(
          &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ResolveIntentRequest::MergeFrom(const ResolveIntentRequest& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_header()) {
      mutable_header()->::cockroach::roachpb::Span::MergeFrom(from.header());
    }
    if (from.has_intent_txn()) {
      mutable_intent_txn()->::cockroach::roachpb::TxnMeta::MergeFrom(from.intent_txn());
    }
    if (from.has_status()) {
      set_status(from.status());
    }
    if (from.has_poison()) {
      set_poison(from.poison());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void ResolveIntentRequest::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ResolveIntentRequest::CopyFrom(const ResolveIntentRequest& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ResolveIntentRequest::IsInitialized() const {

  return true;
}

void ResolveIntentRequest::Swap(ResolveIntentRequest* other) {
  if (other == this) return;
  InternalSwap(other);
}
void ResolveIntentRequest::InternalSwap(ResolveIntentRequest* other) {
  std::swap(header_, other->header_);
  std::swap(intent_txn_, other->intent_txn_);
  std::swap(status_, other->status_);
  std::swap(poison_, other->poison_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata ResolveIntentRequest::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ResolveIntentRequest_descriptor_;
  metadata.reflection = ResolveIntentRequest_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// ResolveIntentRequest

// optional .cockroach.roachpb.Span header = 1;
bool ResolveIntentRequest::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void ResolveIntentRequest::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
void ResolveIntentRequest::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
void ResolveIntentRequest::clear_header() {
  if (header_ != NULL) header_->::cockroach::roachpb::Span::Clear();
  clear_has_header();
}
const ::cockroach::roachpb::Span& ResolveIntentRequest::header() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.ResolveIntentRequest.header)
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
::cockroach::roachpb::Span* ResolveIntentRequest::mutable_header() {
  set_has_header();
  if (header_ == NULL) {
    header_ = new ::cockroach::roachpb::Span;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.ResolveIntentRequest.header)
  return header_;
}
::cockroach::roachpb::Span* ResolveIntentRequest::release_header() {
  clear_has_header();
  ::cockroach::roachpb::Span* temp = header_;
  header_ = NULL;
  return temp;
}
void ResolveIntentRequest::set_allocated_header(::cockroach::roachpb::Span* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.ResolveIntentRequest.header)
}

// optional .cockroach.roachpb.TxnMeta intent_txn = 2;
bool ResolveIntentRequest::has_intent_txn() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void ResolveIntentRequest::set_has_intent_txn() {
  _has_bits_[0] |= 0x00000002u;
}
void ResolveIntentRequest::clear_has_intent_txn() {
  _has_bits_[0] &= ~0x00000002u;
}
void ResolveIntentRequest::clear_intent_txn() {
  if (intent_txn_ != NULL) intent_txn_->::cockroach::roachpb::TxnMeta::Clear();
  clear_has_intent_txn();
}
const ::cockroach::roachpb::TxnMeta& ResolveIntentRequest::intent_txn() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.ResolveIntentRequest.intent_txn)
  return intent_txn_ != NULL ? *intent_txn_ : *default_instance_->intent_txn_;
}
::cockroach::roachpb::TxnMeta* ResolveIntentRequest::mutable_intent_txn() {
  set_has_intent_txn();
  if (intent_txn_ == NULL) {
    intent_txn_ = new ::cockroach::roachpb::TxnMeta;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.ResolveIntentRequest.intent_txn)
  return intent_txn_;
}
::cockroach::roachpb::TxnMeta* ResolveIntentRequest::release_intent_txn() {
  clear_has_intent_txn();
  ::cockroach::roachpb::TxnMeta* temp = intent_txn_;
  intent_txn_ = NULL;
  return temp;
}
void ResolveIntentRequest::set_allocated_intent_txn(::cockroach::roachpb::TxnMeta* intent_txn) {
  delete intent_txn_;
  intent_txn_ = intent_txn;
  if (intent_txn) {
    set_has_intent_txn();
  } else {
    clear_has_intent_txn();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.ResolveIntentRequest.intent_txn)
}

// optional .cockroach.roachpb.TransactionStatus status = 3;
bool ResolveIntentRequest::has_status() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void ResolveIntentRequest::set_has_status() {
  _has_bits_[0] |= 0x00000004u;
}
void ResolveIntentRequest::clear_has_status() {
  _has_bits_[0] &= ~0x00000004u;
}
void ResolveIntentRequest::clear_status() {
  status_ = 0;
  clear_has_status();
}
 ::cockroach::roachpb::TransactionStatus ResolveIntentRequest::status() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.ResolveIntentRequest.status)
  return static_cast< ::cockroach::roachpb::TransactionStatus >(status_);
}
 void ResolveIntentRequest::set_status(::cockroach::roachpb::TransactionStatus value) {
  assert(::cockroach::roachpb::TransactionStatus_IsValid(value));
  set_has_status();
  status_ = value;
  // @@protoc_insertion_point(field_set:cockroach.roachpb.ResolveIntentRequest.status)
}

// optional bool poison = 4;
bool ResolveIntentRequest::has_poison() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void ResolveIntentRequest::set_has_poison() {
  _has_bits_[0] |= 0x00000008u;
}
void ResolveIntentRequest::clear_has_poison() {
  _has_bits_[0] &= ~0x00000008u;
}
void ResolveIntentRequest::clear_poison() {
  poison_ = false;
  clear_has_poison();
}
 bool ResolveIntentRequest::poison() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.ResolveIntentRequest.poison)
  return poison_;
}
 void ResolveIntentRequest::set_poison(bool value) {
  set_has_poison();
  poison_ = value;
  // @@protoc_insertion_point(field_set:cockroach.roachpb.ResolveIntentRequest.poison)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int ResolveIntentResponse::kHeaderFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

ResolveIntentResponse::ResolveIntentResponse()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:cockroach.roachpb.ResolveIntentResponse)
}

void ResolveIntentResponse::InitAsDefaultInstance() {
  header_ = const_cast< ::cockroach::roachpb::ResponseHeader*>(&::cockroach::roachpb::ResponseHeader::default_instance());
}

ResolveIntentResponse::ResolveIntentResponse(const ResolveIntentResponse& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:cockroach.roachpb.ResolveIntentResponse)
}

void ResolveIntentResponse::SharedCtor() {
  _cached_size_ = 0;
  header_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ResolveIntentResponse::~ResolveIntentResponse() {
  // @@protoc_insertion_point(destructor:cockroach.roachpb.ResolveIntentResponse)
  SharedDtor();
}

void ResolveIntentResponse::SharedDtor() {
  if (this != default_instance_) {
    delete header_;
  }
}

void ResolveIntentResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ResolveIntentResponse::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ResolveIntentResponse_descriptor_;
}

const ResolveIntentResponse& ResolveIntentResponse::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_cockroach_2froachpb_2fapi_2eproto();
  return *default_instance_;
}

ResolveIntentResponse* ResolveIntentResponse::default_instance_ = NULL;

ResolveIntentResponse* ResolveIntentResponse::New(::google::protobuf::Arena* arena) const {
  ResolveIntentResponse* n = new ResolveIntentResponse;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void ResolveIntentResponse::Clear() {
  if (has_header()) {
    if (header_ != NULL) header_->::cockroach::roachpb::ResponseHeader::Clear();
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool ResolveIntentResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:cockroach.roachpb.ResolveIntentResponse)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .cockroach.roachpb.ResponseHeader header = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_header()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:cockroach.roachpb.ResolveIntentResponse)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:cockroach.roachpb.ResolveIntentResponse)
  return false;
#undef DO_
}

void ResolveIntentResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:cockroach.roachpb.ResolveIntentResponse)
  // optional .cockroach.roachpb.ResponseHeader header = 1;
  if (has_header()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->header_, output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:cockroach.roachpb.ResolveIntentResponse)
}

::google::protobuf::uint8* ResolveIntentResponse::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:cockroach.roachpb.ResolveIntentResponse)
  // optional .cockroach.roachpb.ResponseHeader header = 1;
  if (has_header()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, *this->header_, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:cockroach.roachpb.ResolveIntentResponse)
  return target;
}

int ResolveIntentResponse::ByteSize() const {
  int total_size = 0;

  // optional .cockroach.roachpb.ResponseHeader header = 1;
  if (has_header()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->header_);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ResolveIntentResponse::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const ResolveIntentResponse* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const ResolveIntentResponse>(
          &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ResolveIntentResponse::MergeFrom(const ResolveIntentResponse& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_header()) {
      mutable_header()->::cockroach::roachpb::ResponseHeader::MergeFrom(from.header());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void ResolveIntentResponse::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ResolveIntentResponse::CopyFrom(const ResolveIntentResponse& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ResolveIntentResponse::IsInitialized() const {

  return true;
}

void ResolveIntentResponse::Swap(ResolveIntentResponse* other) {
  if (other == this) return;
  InternalSwap(other);
}
void ResolveIntentResponse::InternalSwap(ResolveIntentResponse* other) {
  std::swap(header_, other->header_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata ResolveIntentResponse::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ResolveIntentResponse_descriptor_;
  metadata.reflection = ResolveIntentResponse_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// ResolveIntentResponse

// optional .cockroach.roachpb.ResponseHeader header = 1;
bool ResolveIntentResponse::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void ResolveIntentResponse::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
void ResolveIntentResponse::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
void ResolveIntentResponse::clear_header() {
  if (header_ != NULL) header_->::cockroach::roachpb::ResponseHeader::Clear();
  clear_has_header();
}
const ::cockroach::roachpb::ResponseHeader& ResolveIntentResponse::header() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.ResolveIntentResponse.header)
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
::cockroach::roachpb::ResponseHeader* ResolveIntentResponse::mutable_header() {
  set_has_header();
  if (header_ == NULL) {
    header_ = new ::cockroach::roachpb::ResponseHeader;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.ResolveIntentResponse.header)
  return header_;
}
::cockroach::roachpb::ResponseHeader* ResolveIntentResponse::release_header() {
  clear_has_header();
  ::cockroach::roachpb::ResponseHeader* temp = header_;
  header_ = NULL;
  return temp;
}
void ResolveIntentResponse::set_allocated_header(::cockroach::roachpb::ResponseHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.ResolveIntentResponse.header)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int ResolveIntentRangeRequest::kHeaderFieldNumber;
const int ResolveIntentRangeRequest::kIntentTxnFieldNumber;
const int ResolveIntentRangeRequest::kStatusFieldNumber;
const int ResolveIntentRangeRequest::kPoisonFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

ResolveIntentRangeRequest::ResolveIntentRangeRequest()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:cockroach.roachpb.ResolveIntentRangeRequest)
}

void ResolveIntentRangeRequest::InitAsDefaultInstance() {
  header_ = const_cast< ::cockroach::roachpb::Span*>(&::cockroach::roachpb::Span::default_instance());
  intent_txn_ = const_cast< ::cockroach::roachpb::TxnMeta*>(&::cockroach::roachpb::TxnMeta::default_instance());
}

ResolveIntentRangeRequest::ResolveIntentRangeRequest(const ResolveIntentRangeRequest& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:cockroach.roachpb.ResolveIntentRangeRequest)
}

void ResolveIntentRangeRequest::SharedCtor() {
  _cached_size_ = 0;
  header_ = NULL;
  intent_txn_ = NULL;
  status_ = 0;
  poison_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ResolveIntentRangeRequest::~ResolveIntentRangeRequest() {
  // @@protoc_insertion_point(destructor:cockroach.roachpb.ResolveIntentRangeRequest)
  SharedDtor();
}

void ResolveIntentRangeRequest::SharedDtor() {
  if (this != default_instance_) {
    delete header_;
    delete intent_txn_;
  }
}

void ResolveIntentRangeRequest::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ResolveIntentRangeRequest::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ResolveIntentRangeRequest_descriptor_;
}

const ResolveIntentRangeRequest& ResolveIntentRangeRequest::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_cockroach_2froachpb_2fapi_2eproto();
  return *default_instance_;
}

ResolveIntentRangeRequest* ResolveIntentRangeRequest::default_instance_ = NULL;

ResolveIntentRangeRequest* ResolveIntentRangeRequest::New(::google::protobuf::Arena* arena) const {
  ResolveIntentRangeRequest* n = new ResolveIntentRangeRequest;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void ResolveIntentRangeRequest::Clear() {
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<ResolveIntentRangeRequest*>(16)->f)

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  if (_has_bits_[0 / 32] & 15u) {
    ZR_(status_, poison_);
    if (has_header()) {
      if (header_ != NULL) header_->::cockroach::roachpb::Span::Clear();
    }
    if (has_intent_txn()) {
      if (intent_txn_ != NULL) intent_txn_->::cockroach::roachpb::TxnMeta::Clear();
    }
  }

#undef ZR_HELPER_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool ResolveIntentRangeRequest::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:cockroach.roachpb.ResolveIntentRangeRequest)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .cockroach.roachpb.Span header = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_header()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_intent_txn;
        break;
      }

      // optional .cockroach.roachpb.TxnMeta intent_txn = 2;
      case 2: {
        if (tag == 18) {
         parse_intent_txn:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_intent_txn()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_status;
        break;
      }

      // optional .cockroach.roachpb.TransactionStatus status = 3;
      case 3: {
        if (tag == 24) {
         parse_status:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::cockroach::roachpb::TransactionStatus_IsValid(value)) {
            set_status(static_cast< ::cockroach::roachpb::TransactionStatus >(value));
          } else {
            mutable_unknown_fields()->AddVarint(3, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_poison;
        break;
      }

      // optional bool poison = 4;
      case 4: {
        if (tag == 32) {
         parse_poison:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &poison_)));
          set_has_poison();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:cockroach.roachpb.ResolveIntentRangeRequest)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:cockroach.roachpb.ResolveIntentRangeRequest)
  return false;
#undef DO_
}

void ResolveIntentRangeRequest::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:cockroach.roachpb.ResolveIntentRangeRequest)
  // optional .cockroach.roachpb.Span header = 1;
  if (has_header()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->header_, output);
  }

  // optional .cockroach.roachpb.TxnMeta intent_txn = 2;
  if (has_intent_txn()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, *this->intent_txn_, output);
  }

  // optional .cockroach.roachpb.TransactionStatus status = 3;
  if (has_status()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      3, this->status(), output);
  }

  // optional bool poison = 4;
  if (has_poison()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(4, this->poison(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:cockroach.roachpb.ResolveIntentRangeRequest)
}

::google::protobuf::uint8* ResolveIntentRangeRequest::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:cockroach.roachpb.ResolveIntentRangeRequest)
  // optional .cockroach.roachpb.Span header = 1;
  if (has_header()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, *this->header_, target);
  }

  // optional .cockroach.roachpb.TxnMeta intent_txn = 2;
  if (has_intent_txn()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, *this->intent_txn_, target);
  }

  // optional .cockroach.roachpb.TransactionStatus status = 3;
  if (has_status()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      3, this->status(), target);
  }

  // optional bool poison = 4;
  if (has_poison()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(4, this->poison(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:cockroach.roachpb.ResolveIntentRangeRequest)
  return target;
}

int ResolveIntentRangeRequest::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & 15u) {
    // optional .cockroach.roachpb.Span header = 1;
    if (has_header()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->header_);
    }

    // optional .cockroach.roachpb.TxnMeta intent_txn = 2;
    if (has_intent_txn()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->intent_txn_);
    }

    // optional .cockroach.roachpb.TransactionStatus status = 3;
    if (has_status()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->status());
    }

    // optional bool poison = 4;
    if (has_poison()) {
      total_size += 1 + 1;
    }

  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ResolveIntentRangeRequest::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const ResolveIntentRangeRequest* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const ResolveIntentRangeRequest>(
          &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ResolveIntentRangeRequest::MergeFrom(const ResolveIntentRangeRequest& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_header()) {
      mutable_header()->::cockroach::roachpb::Span::MergeFrom(from.header());
    }
    if (from.has_intent_txn()) {
      mutable_intent_txn()->::cockroach::roachpb::TxnMeta::MergeFrom(from.intent_txn());
    }
    if (from.has_status()) {
      set_status(from.status());
    }
    if (from.has_poison()) {
      set_poison(from.poison());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void ResolveIntentRangeRequest::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ResolveIntentRangeRequest::CopyFrom(const ResolveIntentRangeRequest& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ResolveIntentRangeRequest::IsInitialized() const {

  return true;
}

void ResolveIntentRangeRequest::Swap(ResolveIntentRangeRequest* other) {
  if (other == this) return;
  InternalSwap(other);
}
void ResolveIntentRangeRequest::InternalSwap(ResolveIntentRangeRequest* other) {
  std::swap(header_, other->header_);
  std::swap(intent_txn_, other->intent_txn_);
  std::swap(status_, other->status_);
  std::swap(poison_, other->poison_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata ResolveIntentRangeRequest::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ResolveIntentRangeRequest_descriptor_;
  metadata.reflection = ResolveIntentRangeRequest_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// ResolveIntentRangeRequest

// optional .cockroach.roachpb.Span header = 1;
bool ResolveIntentRangeRequest::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void ResolveIntentRangeRequest::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
void ResolveIntentRangeRequest::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
void ResolveIntentRangeRequest::clear_header() {
  if (header_ != NULL) header_->::cockroach::roachpb::Span::Clear();
  clear_has_header();
}
const ::cockroach::roachpb::Span& ResolveIntentRangeRequest::header() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.ResolveIntentRangeRequest.header)
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
::cockroach::roachpb::Span* ResolveIntentRangeRequest::mutable_header() {
  set_has_header();
  if (header_ == NULL) {
    header_ = new ::cockroach::roachpb::Span;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.ResolveIntentRangeRequest.header)
  return header_;
}
::cockroach::roachpb::Span* ResolveIntentRangeRequest::release_header() {
  clear_has_header();
  ::cockroach::roachpb::Span* temp = header_;
  header_ = NULL;
  return temp;
}
void ResolveIntentRangeRequest::set_allocated_header(::cockroach::roachpb::Span* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.ResolveIntentRangeRequest.header)
}

// optional .cockroach.roachpb.TxnMeta intent_txn = 2;
bool ResolveIntentRangeRequest::has_intent_txn() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void ResolveIntentRangeRequest::set_has_intent_txn() {
  _has_bits_[0] |= 0x00000002u;
}
void ResolveIntentRangeRequest::clear_has_intent_txn() {
  _has_bits_[0] &= ~0x00000002u;
}
void ResolveIntentRangeRequest::clear_intent_txn() {
  if (intent_txn_ != NULL) intent_txn_->::cockroach::roachpb::TxnMeta::Clear();
  clear_has_intent_txn();
}
const ::cockroach::roachpb::TxnMeta& ResolveIntentRangeRequest::intent_txn() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.ResolveIntentRangeRequest.intent_txn)
  return intent_txn_ != NULL ? *intent_txn_ : *default_instance_->intent_txn_;
}
::cockroach::roachpb::TxnMeta* ResolveIntentRangeRequest::mutable_intent_txn() {
  set_has_intent_txn();
  if (intent_txn_ == NULL) {
    intent_txn_ = new ::cockroach::roachpb::TxnMeta;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.ResolveIntentRangeRequest.intent_txn)
  return intent_txn_;
}
::cockroach::roachpb::TxnMeta* ResolveIntentRangeRequest::release_intent_txn() {
  clear_has_intent_txn();
  ::cockroach::roachpb::TxnMeta* temp = intent_txn_;
  intent_txn_ = NULL;
  return temp;
}
void ResolveIntentRangeRequest::set_allocated_intent_txn(::cockroach::roachpb::TxnMeta* intent_txn) {
  delete intent_txn_;
  intent_txn_ = intent_txn;
  if (intent_txn) {
    set_has_intent_txn();
  } else {
    clear_has_intent_txn();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.ResolveIntentRangeRequest.intent_txn)
}

// optional .cockroach.roachpb.TransactionStatus status = 3;
bool ResolveIntentRangeRequest::has_status() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void ResolveIntentRangeRequest::set_has_status() {
  _has_bits_[0] |= 0x00000004u;
}
void ResolveIntentRangeRequest::clear_has_status() {
  _has_bits_[0] &= ~0x00000004u;
}
void ResolveIntentRangeRequest::clear_status() {
  status_ = 0;
  clear_has_status();
}
 ::cockroach::roachpb::TransactionStatus ResolveIntentRangeRequest::status() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.ResolveIntentRangeRequest.status)
  return static_cast< ::cockroach::roachpb::TransactionStatus >(status_);
}
 void ResolveIntentRangeRequest::set_status(::cockroach::roachpb::TransactionStatus value) {
  assert(::cockroach::roachpb::TransactionStatus_IsValid(value));
  set_has_status();
  status_ = value;
  // @@protoc_insertion_point(field_set:cockroach.roachpb.ResolveIntentRangeRequest.status)
}

// optional bool poison = 4;
bool ResolveIntentRangeRequest::has_poison() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void ResolveIntentRangeRequest::set_has_poison() {
  _has_bits_[0] |= 0x00000008u;
}
void ResolveIntentRangeRequest::clear_has_poison() {
  _has_bits_[0] &= ~0x00000008u;
}
void ResolveIntentRangeRequest::clear_poison() {
  poison_ = false;
  clear_has_poison();
}
 bool ResolveIntentRangeRequest::poison() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.ResolveIntentRangeRequest.poison)
  return poison_;
}
 void ResolveIntentRangeRequest::set_poison(bool value) {
  set_has_poison();
  poison_ = value;
  // @@protoc_insertion_point(field_set:cockroach.roachpb.ResolveIntentRangeRequest.poison)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int NoopResponse::kHeaderFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

NoopResponse::NoopResponse()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:cockroach.roachpb.NoopResponse)
}

void NoopResponse::InitAsDefaultInstance() {
  header_ = const_cast< ::cockroach::roachpb::ResponseHeader*>(&::cockroach::roachpb::ResponseHeader::default_instance());
}

NoopResponse::NoopResponse(const NoopResponse& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:cockroach.roachpb.NoopResponse)
}

void NoopResponse::SharedCtor() {
  _cached_size_ = 0;
  header_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

NoopResponse::~NoopResponse() {
  // @@protoc_insertion_point(destructor:cockroach.roachpb.NoopResponse)
  SharedDtor();
}

void NoopResponse::SharedDtor() {
  if (this != default_instance_) {
    delete header_;
  }
}

void NoopResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* NoopResponse::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return NoopResponse_descriptor_;
}

const NoopResponse& NoopResponse::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_cockroach_2froachpb_2fapi_2eproto();
  return *default_instance_;
}

NoopResponse* NoopResponse::default_instance_ = NULL;

NoopResponse* NoopResponse::New(::google::protobuf::Arena* arena) const {
  NoopResponse* n = new NoopResponse;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void NoopResponse::Clear() {
  if (has_header()) {
    if (header_ != NULL) header_->::cockroach::roachpb::ResponseHeader::Clear();
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool NoopResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:cockroach.roachpb.NoopResponse)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .cockroach.roachpb.ResponseHeader header = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_header()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:cockroach.roachpb.NoopResponse)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:cockroach.roachpb.NoopResponse)
  return false;
#undef DO_
}

void NoopResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:cockroach.roachpb.NoopResponse)
  // optional .cockroach.roachpb.ResponseHeader header = 1;
  if (has_header()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->header_, output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:cockroach.roachpb.NoopResponse)
}

::google::protobuf::uint8* NoopResponse::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:cockroach.roachpb.NoopResponse)
  // optional .cockroach.roachpb.ResponseHeader header = 1;
  if (has_header()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, *this->header_, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:cockroach.roachpb.NoopResponse)
  return target;
}

int NoopResponse::ByteSize() const {
  int total_size = 0;

  // optional .cockroach.roachpb.ResponseHeader header = 1;
  if (has_header()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->header_);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void NoopResponse::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const NoopResponse* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const NoopResponse>(
          &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void NoopResponse::MergeFrom(const NoopResponse& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_header()) {
      mutable_header()->::cockroach::roachpb::ResponseHeader::MergeFrom(from.header());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void NoopResponse::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void NoopResponse::CopyFrom(const NoopResponse& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NoopResponse::IsInitialized() const {

  return true;
}

void NoopResponse::Swap(NoopResponse* other) {
  if (other == this) return;
  InternalSwap(other);
}
void NoopResponse::InternalSwap(NoopResponse* other) {
  std::swap(header_, other->header_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata NoopResponse::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = NoopResponse_descriptor_;
  metadata.reflection = NoopResponse_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// NoopResponse

// optional .cockroach.roachpb.ResponseHeader header = 1;
bool NoopResponse::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void NoopResponse::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
void NoopResponse::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
void NoopResponse::clear_header() {
  if (header_ != NULL) header_->::cockroach::roachpb::ResponseHeader::Clear();
  clear_has_header();
}
const ::cockroach::roachpb::ResponseHeader& NoopResponse::header() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.NoopResponse.header)
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
::cockroach::roachpb::ResponseHeader* NoopResponse::mutable_header() {
  set_has_header();
  if (header_ == NULL) {
    header_ = new ::cockroach::roachpb::ResponseHeader;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.NoopResponse.header)
  return header_;
}
::cockroach::roachpb::ResponseHeader* NoopResponse::release_header() {
  clear_has_header();
  ::cockroach::roachpb::ResponseHeader* temp = header_;
  header_ = NULL;
  return temp;
}
void NoopResponse::set_allocated_header(::cockroach::roachpb::ResponseHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.NoopResponse.header)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int NoopRequest::kHeaderFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

NoopRequest::NoopRequest()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:cockroach.roachpb.NoopRequest)
}

void NoopRequest::InitAsDefaultInstance() {
  header_ = const_cast< ::cockroach::roachpb::Span*>(&::cockroach::roachpb::Span::default_instance());
}

NoopRequest::NoopRequest(const NoopRequest& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:cockroach.roachpb.NoopRequest)
}

void NoopRequest::SharedCtor() {
  _cached_size_ = 0;
  header_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

NoopRequest::~NoopRequest() {
  // @@protoc_insertion_point(destructor:cockroach.roachpb.NoopRequest)
  SharedDtor();
}

void NoopRequest::SharedDtor() {
  if (this != default_instance_) {
    delete header_;
  }
}

void NoopRequest::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* NoopRequest::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return NoopRequest_descriptor_;
}

const NoopRequest& NoopRequest::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_cockroach_2froachpb_2fapi_2eproto();
  return *default_instance_;
}

NoopRequest* NoopRequest::default_instance_ = NULL;

NoopRequest* NoopRequest::New(::google::protobuf::Arena* arena) const {
  NoopRequest* n = new NoopRequest;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void NoopRequest::Clear() {
  if (has_header()) {
    if (header_ != NULL) header_->::cockroach::roachpb::Span::Clear();
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool NoopRequest::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:cockroach.roachpb.NoopRequest)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .cockroach.roachpb.Span header = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_header()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:cockroach.roachpb.NoopRequest)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:cockroach.roachpb.NoopRequest)
  return false;
#undef DO_
}

void NoopRequest::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:cockroach.roachpb.NoopRequest)
  // optional .cockroach.roachpb.Span header = 1;
  if (has_header()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->header_, output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:cockroach.roachpb.NoopRequest)
}

::google::protobuf::uint8* NoopRequest::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:cockroach.roachpb.NoopRequest)
  // optional .cockroach.roachpb.Span header = 1;
  if (has_header()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, *this->header_, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:cockroach.roachpb.NoopRequest)
  return target;
}

int NoopRequest::ByteSize() const {
  int total_size = 0;

  // optional .cockroach.roachpb.Span header = 1;
  if (has_header()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->header_);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void NoopRequest::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const NoopRequest* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const NoopRequest>(
          &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void NoopRequest::MergeFrom(const NoopRequest& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_header()) {
      mutable_header()->::cockroach::roachpb::Span::MergeFrom(from.header());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void NoopRequest::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void NoopRequest::CopyFrom(const NoopRequest& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NoopRequest::IsInitialized() const {

  return true;
}

void NoopRequest::Swap(NoopRequest* other) {
  if (other == this) return;
  InternalSwap(other);
}
void NoopRequest::InternalSwap(NoopRequest* other) {
  std::swap(header_, other->header_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata NoopRequest::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = NoopRequest_descriptor_;
  metadata.reflection = NoopRequest_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// NoopRequest

// optional .cockroach.roachpb.Span header = 1;
bool NoopRequest::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void NoopRequest::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
void NoopRequest::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
void NoopRequest::clear_header() {
  if (header_ != NULL) header_->::cockroach::roachpb::Span::Clear();
  clear_has_header();
}
const ::cockroach::roachpb::Span& NoopRequest::header() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.NoopRequest.header)
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
::cockroach::roachpb::Span* NoopRequest::mutable_header() {
  set_has_header();
  if (header_ == NULL) {
    header_ = new ::cockroach::roachpb::Span;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.NoopRequest.header)
  return header_;
}
::cockroach::roachpb::Span* NoopRequest::release_header() {
  clear_has_header();
  ::cockroach::roachpb::Span* temp = header_;
  header_ = NULL;
  return temp;
}
void NoopRequest::set_allocated_header(::cockroach::roachpb::Span* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.NoopRequest.header)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int ResolveIntentRangeResponse::kHeaderFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

ResolveIntentRangeResponse::ResolveIntentRangeResponse()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:cockroach.roachpb.ResolveIntentRangeResponse)
}

void ResolveIntentRangeResponse::InitAsDefaultInstance() {
  header_ = const_cast< ::cockroach::roachpb::ResponseHeader*>(&::cockroach::roachpb::ResponseHeader::default_instance());
}

ResolveIntentRangeResponse::ResolveIntentRangeResponse(const ResolveIntentRangeResponse& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:cockroach.roachpb.ResolveIntentRangeResponse)
}

void ResolveIntentRangeResponse::SharedCtor() {
  _cached_size_ = 0;
  header_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ResolveIntentRangeResponse::~ResolveIntentRangeResponse() {
  // @@protoc_insertion_point(destructor:cockroach.roachpb.ResolveIntentRangeResponse)
  SharedDtor();
}

void ResolveIntentRangeResponse::SharedDtor() {
  if (this != default_instance_) {
    delete header_;
  }
}

void ResolveIntentRangeResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ResolveIntentRangeResponse::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ResolveIntentRangeResponse_descriptor_;
}

const ResolveIntentRangeResponse& ResolveIntentRangeResponse::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_cockroach_2froachpb_2fapi_2eproto();
  return *default_instance_;
}

ResolveIntentRangeResponse* ResolveIntentRangeResponse::default_instance_ = NULL;

ResolveIntentRangeResponse* ResolveIntentRangeResponse::New(::google::protobuf::Arena* arena) const {
  ResolveIntentRangeResponse* n = new ResolveIntentRangeResponse;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void ResolveIntentRangeResponse::Clear() {
  if (has_header()) {
    if (header_ != NULL) header_->::cockroach::roachpb::ResponseHeader::Clear();
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool ResolveIntentRangeResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:cockroach.roachpb.ResolveIntentRangeResponse)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .cockroach.roachpb.ResponseHeader header = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_header()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:cockroach.roachpb.ResolveIntentRangeResponse)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:cockroach.roachpb.ResolveIntentRangeResponse)
  return false;
#undef DO_
}

void ResolveIntentRangeResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:cockroach.roachpb.ResolveIntentRangeResponse)
  // optional .cockroach.roachpb.ResponseHeader header = 1;
  if (has_header()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->header_, output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:cockroach.roachpb.ResolveIntentRangeResponse)
}

::google::protobuf::uint8* ResolveIntentRangeResponse::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:cockroach.roachpb.ResolveIntentRangeResponse)
  // optional .cockroach.roachpb.ResponseHeader header = 1;
  if (has_header()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, *this->header_, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:cockroach.roachpb.ResolveIntentRangeResponse)
  return target;
}

int ResolveIntentRangeResponse::ByteSize() const {
  int total_size = 0;

  // optional .cockroach.roachpb.ResponseHeader header = 1;
  if (has_header()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->header_);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ResolveIntentRangeResponse::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const ResolveIntentRangeResponse* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const ResolveIntentRangeResponse>(
          &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ResolveIntentRangeResponse::MergeFrom(const ResolveIntentRangeResponse& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_header()) {
      mutable_header()->::cockroach::roachpb::ResponseHeader::MergeFrom(from.header());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void ResolveIntentRangeResponse::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ResolveIntentRangeResponse::CopyFrom(const ResolveIntentRangeResponse& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ResolveIntentRangeResponse::IsInitialized() const {

  return true;
}

void ResolveIntentRangeResponse::Swap(ResolveIntentRangeResponse* other) {
  if (other == this) return;
  InternalSwap(other);
}
void ResolveIntentRangeResponse::InternalSwap(ResolveIntentRangeResponse* other) {
  std::swap(header_, other->header_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata ResolveIntentRangeResponse::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ResolveIntentRangeResponse_descriptor_;
  metadata.reflection = ResolveIntentRangeResponse_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// ResolveIntentRangeResponse

// optional .cockroach.roachpb.ResponseHeader header = 1;
bool ResolveIntentRangeResponse::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void ResolveIntentRangeResponse::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
void ResolveIntentRangeResponse::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
void ResolveIntentRangeResponse::clear_header() {
  if (header_ != NULL) header_->::cockroach::roachpb::ResponseHeader::Clear();
  clear_has_header();
}
const ::cockroach::roachpb::ResponseHeader& ResolveIntentRangeResponse::header() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.ResolveIntentRangeResponse.header)
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
::cockroach::roachpb::ResponseHeader* ResolveIntentRangeResponse::mutable_header() {
  set_has_header();
  if (header_ == NULL) {
    header_ = new ::cockroach::roachpb::ResponseHeader;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.ResolveIntentRangeResponse.header)
  return header_;
}
::cockroach::roachpb::ResponseHeader* ResolveIntentRangeResponse::release_header() {
  clear_has_header();
  ::cockroach::roachpb::ResponseHeader* temp = header_;
  header_ = NULL;
  return temp;
}
void ResolveIntentRangeResponse::set_allocated_header(::cockroach::roachpb::ResponseHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.ResolveIntentRangeResponse.header)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int MergeRequest::kHeaderFieldNumber;
const int MergeRequest::kValueFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

MergeRequest::MergeRequest()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:cockroach.roachpb.MergeRequest)
}

void MergeRequest::InitAsDefaultInstance() {
  header_ = const_cast< ::cockroach::roachpb::Span*>(&::cockroach::roachpb::Span::default_instance());
  value_ = const_cast< ::cockroach::roachpb::Value*>(&::cockroach::roachpb::Value::default_instance());
}

MergeRequest::MergeRequest(const MergeRequest& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:cockroach.roachpb.MergeRequest)
}

void MergeRequest::SharedCtor() {
  _cached_size_ = 0;
  header_ = NULL;
  value_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

MergeRequest::~MergeRequest() {
  // @@protoc_insertion_point(destructor:cockroach.roachpb.MergeRequest)
  SharedDtor();
}

void MergeRequest::SharedDtor() {
  if (this != default_instance_) {
    delete header_;
    delete value_;
  }
}

void MergeRequest::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* MergeRequest::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return MergeRequest_descriptor_;
}

const MergeRequest& MergeRequest::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_cockroach_2froachpb_2fapi_2eproto();
  return *default_instance_;
}

MergeRequest* MergeRequest::default_instance_ = NULL;

MergeRequest* MergeRequest::New(::google::protobuf::Arena* arena) const {
  MergeRequest* n = new MergeRequest;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void MergeRequest::Clear() {
  if (_has_bits_[0 / 32] & 3u) {
    if (has_header()) {
      if (header_ != NULL) header_->::cockroach::roachpb::Span::Clear();
    }
    if (has_value()) {
      if (value_ != NULL) value_->::cockroach::roachpb::Value::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool MergeRequest::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:cockroach.roachpb.MergeRequest)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .cockroach.roachpb.Span header = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_header()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_value;
        break;
      }

      // optional .cockroach.roachpb.Value value = 2;
      case 2: {
        if (tag == 18) {
         parse_value:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_value()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:cockroach.roachpb.MergeRequest)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:cockroach.roachpb.MergeRequest)
  return false;
#undef DO_
}

void MergeRequest::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:cockroach.roachpb.MergeRequest)
  // optional .cockroach.roachpb.Span header = 1;
  if (has_header()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->header_, output);
  }

  // optional .cockroach.roachpb.Value value = 2;
  if (has_value()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, *this->value_, output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:cockroach.roachpb.MergeRequest)
}

::google::protobuf::uint8* MergeRequest::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:cockroach.roachpb.MergeRequest)
  // optional .cockroach.roachpb.Span header = 1;
  if (has_header()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, *this->header_, target);
  }

  // optional .cockroach.roachpb.Value value = 2;
  if (has_value()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, *this->value_, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:cockroach.roachpb.MergeRequest)
  return target;
}

int MergeRequest::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & 3u) {
    // optional .cockroach.roachpb.Span header = 1;
    if (has_header()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->header_);
    }

    // optional .cockroach.roachpb.Value value = 2;
    if (has_value()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->value_);
    }

  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void MergeRequest::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const MergeRequest* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const MergeRequest>(
          &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void MergeRequest::MergeFrom(const MergeRequest& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_header()) {
      mutable_header()->::cockroach::roachpb::Span::MergeFrom(from.header());
    }
    if (from.has_value()) {
      mutable_value()->::cockroach::roachpb::Value::MergeFrom(from.value());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void MergeRequest::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void MergeRequest::CopyFrom(const MergeRequest& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MergeRequest::IsInitialized() const {

  return true;
}

void MergeRequest::Swap(MergeRequest* other) {
  if (other == this) return;
  InternalSwap(other);
}
void MergeRequest::InternalSwap(MergeRequest* other) {
  std::swap(header_, other->header_);
  std::swap(value_, other->value_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata MergeRequest::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = MergeRequest_descriptor_;
  metadata.reflection = MergeRequest_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// MergeRequest

// optional .cockroach.roachpb.Span header = 1;
bool MergeRequest::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void MergeRequest::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
void MergeRequest::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
void MergeRequest::clear_header() {
  if (header_ != NULL) header_->::cockroach::roachpb::Span::Clear();
  clear_has_header();
}
const ::cockroach::roachpb::Span& MergeRequest::header() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.MergeRequest.header)
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
::cockroach::roachpb::Span* MergeRequest::mutable_header() {
  set_has_header();
  if (header_ == NULL) {
    header_ = new ::cockroach::roachpb::Span;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.MergeRequest.header)
  return header_;
}
::cockroach::roachpb::Span* MergeRequest::release_header() {
  clear_has_header();
  ::cockroach::roachpb::Span* temp = header_;
  header_ = NULL;
  return temp;
}
void MergeRequest::set_allocated_header(::cockroach::roachpb::Span* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.MergeRequest.header)
}

// optional .cockroach.roachpb.Value value = 2;
bool MergeRequest::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void MergeRequest::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
void MergeRequest::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
void MergeRequest::clear_value() {
  if (value_ != NULL) value_->::cockroach::roachpb::Value::Clear();
  clear_has_value();
}
const ::cockroach::roachpb::Value& MergeRequest::value() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.MergeRequest.value)
  return value_ != NULL ? *value_ : *default_instance_->value_;
}
::cockroach::roachpb::Value* MergeRequest::mutable_value() {
  set_has_value();
  if (value_ == NULL) {
    value_ = new ::cockroach::roachpb::Value;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.MergeRequest.value)
  return value_;
}
::cockroach::roachpb::Value* MergeRequest::release_value() {
  clear_has_value();
  ::cockroach::roachpb::Value* temp = value_;
  value_ = NULL;
  return temp;
}
void MergeRequest::set_allocated_value(::cockroach::roachpb::Value* value) {
  delete value_;
  value_ = value;
  if (value) {
    set_has_value();
  } else {
    clear_has_value();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.MergeRequest.value)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int MergeResponse::kHeaderFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

MergeResponse::MergeResponse()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:cockroach.roachpb.MergeResponse)
}

void MergeResponse::InitAsDefaultInstance() {
  header_ = const_cast< ::cockroach::roachpb::ResponseHeader*>(&::cockroach::roachpb::ResponseHeader::default_instance());
}

MergeResponse::MergeResponse(const MergeResponse& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:cockroach.roachpb.MergeResponse)
}

void MergeResponse::SharedCtor() {
  _cached_size_ = 0;
  header_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

MergeResponse::~MergeResponse() {
  // @@protoc_insertion_point(destructor:cockroach.roachpb.MergeResponse)
  SharedDtor();
}

void MergeResponse::SharedDtor() {
  if (this != default_instance_) {
    delete header_;
  }
}

void MergeResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* MergeResponse::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return MergeResponse_descriptor_;
}

const MergeResponse& MergeResponse::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_cockroach_2froachpb_2fapi_2eproto();
  return *default_instance_;
}

MergeResponse* MergeResponse::default_instance_ = NULL;

MergeResponse* MergeResponse::New(::google::protobuf::Arena* arena) const {
  MergeResponse* n = new MergeResponse;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void MergeResponse::Clear() {
  if (has_header()) {
    if (header_ != NULL) header_->::cockroach::roachpb::ResponseHeader::Clear();
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool MergeResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:cockroach.roachpb.MergeResponse)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .cockroach.roachpb.ResponseHeader header = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_header()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:cockroach.roachpb.MergeResponse)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:cockroach.roachpb.MergeResponse)
  return false;
#undef DO_
}

void MergeResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:cockroach.roachpb.MergeResponse)
  // optional .cockroach.roachpb.ResponseHeader header = 1;
  if (has_header()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->header_, output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:cockroach.roachpb.MergeResponse)
}

::google::protobuf::uint8* MergeResponse::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:cockroach.roachpb.MergeResponse)
  // optional .cockroach.roachpb.ResponseHeader header = 1;
  if (has_header()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, *this->header_, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:cockroach.roachpb.MergeResponse)
  return target;
}

int MergeResponse::ByteSize() const {
  int total_size = 0;

  // optional .cockroach.roachpb.ResponseHeader header = 1;
  if (has_header()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->header_);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void MergeResponse::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const MergeResponse* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const MergeResponse>(
          &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void MergeResponse::MergeFrom(const MergeResponse& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_header()) {
      mutable_header()->::cockroach::roachpb::ResponseHeader::MergeFrom(from.header());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void MergeResponse::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void MergeResponse::CopyFrom(const MergeResponse& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MergeResponse::IsInitialized() const {

  return true;
}

void MergeResponse::Swap(MergeResponse* other) {
  if (other == this) return;
  InternalSwap(other);
}
void MergeResponse::InternalSwap(MergeResponse* other) {
  std::swap(header_, other->header_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata MergeResponse::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = MergeResponse_descriptor_;
  metadata.reflection = MergeResponse_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// MergeResponse

// optional .cockroach.roachpb.ResponseHeader header = 1;
bool MergeResponse::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void MergeResponse::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
void MergeResponse::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
void MergeResponse::clear_header() {
  if (header_ != NULL) header_->::cockroach::roachpb::ResponseHeader::Clear();
  clear_has_header();
}
const ::cockroach::roachpb::ResponseHeader& MergeResponse::header() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.MergeResponse.header)
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
::cockroach::roachpb::ResponseHeader* MergeResponse::mutable_header() {
  set_has_header();
  if (header_ == NULL) {
    header_ = new ::cockroach::roachpb::ResponseHeader;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.MergeResponse.header)
  return header_;
}
::cockroach::roachpb::ResponseHeader* MergeResponse::release_header() {
  clear_has_header();
  ::cockroach::roachpb::ResponseHeader* temp = header_;
  header_ = NULL;
  return temp;
}
void MergeResponse::set_allocated_header(::cockroach::roachpb::ResponseHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.MergeResponse.header)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int TruncateLogRequest::kHeaderFieldNumber;
const int TruncateLogRequest::kIndexFieldNumber;
const int TruncateLogRequest::kRangeIdFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

TruncateLogRequest::TruncateLogRequest()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:cockroach.roachpb.TruncateLogRequest)
}

void TruncateLogRequest::InitAsDefaultInstance() {
  header_ = const_cast< ::cockroach::roachpb::Span*>(&::cockroach::roachpb::Span::default_instance());
}

TruncateLogRequest::TruncateLogRequest(const TruncateLogRequest& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:cockroach.roachpb.TruncateLogRequest)
}

void TruncateLogRequest::SharedCtor() {
  _cached_size_ = 0;
  header_ = NULL;
  index_ = GOOGLE_ULONGLONG(0);
  range_id_ = GOOGLE_LONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

TruncateLogRequest::~TruncateLogRequest() {
  // @@protoc_insertion_point(destructor:cockroach.roachpb.TruncateLogRequest)
  SharedDtor();
}

void TruncateLogRequest::SharedDtor() {
  if (this != default_instance_) {
    delete header_;
  }
}

void TruncateLogRequest::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* TruncateLogRequest::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return TruncateLogRequest_descriptor_;
}

const TruncateLogRequest& TruncateLogRequest::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_cockroach_2froachpb_2fapi_2eproto();
  return *default_instance_;
}

TruncateLogRequest* TruncateLogRequest::default_instance_ = NULL;

TruncateLogRequest* TruncateLogRequest::New(::google::protobuf::Arena* arena) const {
  TruncateLogRequest* n = new TruncateLogRequest;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void TruncateLogRequest::Clear() {
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<TruncateLogRequest*>(16)->f)

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  if (_has_bits_[0 / 32] & 7u) {
    ZR_(index_, range_id_);
    if (has_header()) {
      if (header_ != NULL) header_->::cockroach::roachpb::Span::Clear();
    }
  }

#undef ZR_HELPER_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool TruncateLogRequest::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:cockroach.roachpb.TruncateLogRequest)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .cockroach.roachpb.Span header = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_header()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_index;
        break;
      }

      // optional uint64 index = 2;
      case 2: {
        if (tag == 16) {
         parse_index:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &index_)));
          set_has_index();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_range_id;
        break;
      }

      // optional int64 range_id = 3;
      case 3: {
        if (tag == 24) {
         parse_range_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &range_id_)));
          set_has_range_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:cockroach.roachpb.TruncateLogRequest)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:cockroach.roachpb.TruncateLogRequest)
  return false;
#undef DO_
}

void TruncateLogRequest::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:cockroach.roachpb.TruncateLogRequest)
  // optional .cockroach.roachpb.Span header = 1;
  if (has_header()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->header_, output);
  }

  // optional uint64 index = 2;
  if (has_index()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(2, this->index(), output);
  }

  // optional int64 range_id = 3;
  if (has_range_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(3, this->range_id(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:cockroach.roachpb.TruncateLogRequest)
}

::google::protobuf::uint8* TruncateLogRequest::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:cockroach.roachpb.TruncateLogRequest)
  // optional .cockroach.roachpb.Span header = 1;
  if (has_header()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, *this->header_, target);
  }

  // optional uint64 index = 2;
  if (has_index()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(2, this->index(), target);
  }

  // optional int64 range_id = 3;
  if (has_range_id()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(3, this->range_id(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:cockroach.roachpb.TruncateLogRequest)
  return target;
}

int TruncateLogRequest::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & 7u) {
    // optional .cockroach.roachpb.Span header = 1;
    if (has_header()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->header_);
    }

    // optional uint64 index = 2;
    if (has_index()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->index());
    }

    // optional int64 range_id = 3;
    if (has_range_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->range_id());
    }

  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TruncateLogRequest::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const TruncateLogRequest* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const TruncateLogRequest>(
          &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void TruncateLogRequest::MergeFrom(const TruncateLogRequest& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_header()) {
      mutable_header()->::cockroach::roachpb::Span::MergeFrom(from.header());
    }
    if (from.has_index()) {
      set_index(from.index());
    }
    if (from.has_range_id()) {
      set_range_id(from.range_id());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void TruncateLogRequest::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TruncateLogRequest::CopyFrom(const TruncateLogRequest& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TruncateLogRequest::IsInitialized() const {

  return true;
}

void TruncateLogRequest::Swap(TruncateLogRequest* other) {
  if (other == this) return;
  InternalSwap(other);
}
void TruncateLogRequest::InternalSwap(TruncateLogRequest* other) {
  std::swap(header_, other->header_);
  std::swap(index_, other->index_);
  std::swap(range_id_, other->range_id_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata TruncateLogRequest::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = TruncateLogRequest_descriptor_;
  metadata.reflection = TruncateLogRequest_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// TruncateLogRequest

// optional .cockroach.roachpb.Span header = 1;
bool TruncateLogRequest::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void TruncateLogRequest::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
void TruncateLogRequest::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
void TruncateLogRequest::clear_header() {
  if (header_ != NULL) header_->::cockroach::roachpb::Span::Clear();
  clear_has_header();
}
const ::cockroach::roachpb::Span& TruncateLogRequest::header() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.TruncateLogRequest.header)
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
::cockroach::roachpb::Span* TruncateLogRequest::mutable_header() {
  set_has_header();
  if (header_ == NULL) {
    header_ = new ::cockroach::roachpb::Span;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.TruncateLogRequest.header)
  return header_;
}
::cockroach::roachpb::Span* TruncateLogRequest::release_header() {
  clear_has_header();
  ::cockroach::roachpb::Span* temp = header_;
  header_ = NULL;
  return temp;
}
void TruncateLogRequest::set_allocated_header(::cockroach::roachpb::Span* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.TruncateLogRequest.header)
}

// optional uint64 index = 2;
bool TruncateLogRequest::has_index() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void TruncateLogRequest::set_has_index() {
  _has_bits_[0] |= 0x00000002u;
}
void TruncateLogRequest::clear_has_index() {
  _has_bits_[0] &= ~0x00000002u;
}
void TruncateLogRequest::clear_index() {
  index_ = GOOGLE_ULONGLONG(0);
  clear_has_index();
}
 ::google::protobuf::uint64 TruncateLogRequest::index() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.TruncateLogRequest.index)
  return index_;
}
 void TruncateLogRequest::set_index(::google::protobuf::uint64 value) {
  set_has_index();
  index_ = value;
  // @@protoc_insertion_point(field_set:cockroach.roachpb.TruncateLogRequest.index)
}

// optional int64 range_id = 3;
bool TruncateLogRequest::has_range_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void TruncateLogRequest::set_has_range_id() {
  _has_bits_[0] |= 0x00000004u;
}
void TruncateLogRequest::clear_has_range_id() {
  _has_bits_[0] &= ~0x00000004u;
}
void TruncateLogRequest::clear_range_id() {
  range_id_ = GOOGLE_LONGLONG(0);
  clear_has_range_id();
}
 ::google::protobuf::int64 TruncateLogRequest::range_id() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.TruncateLogRequest.range_id)
  return range_id_;
}
 void TruncateLogRequest::set_range_id(::google::protobuf::int64 value) {
  set_has_range_id();
  range_id_ = value;
  // @@protoc_insertion_point(field_set:cockroach.roachpb.TruncateLogRequest.range_id)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int TruncateLogResponse::kHeaderFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

TruncateLogResponse::TruncateLogResponse()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:cockroach.roachpb.TruncateLogResponse)
}

void TruncateLogResponse::InitAsDefaultInstance() {
  header_ = const_cast< ::cockroach::roachpb::ResponseHeader*>(&::cockroach::roachpb::ResponseHeader::default_instance());
}

TruncateLogResponse::TruncateLogResponse(const TruncateLogResponse& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:cockroach.roachpb.TruncateLogResponse)
}

void TruncateLogResponse::SharedCtor() {
  _cached_size_ = 0;
  header_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

TruncateLogResponse::~TruncateLogResponse() {
  // @@protoc_insertion_point(destructor:cockroach.roachpb.TruncateLogResponse)
  SharedDtor();
}

void TruncateLogResponse::SharedDtor() {
  if (this != default_instance_) {
    delete header_;
  }
}

void TruncateLogResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* TruncateLogResponse::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return TruncateLogResponse_descriptor_;
}

const TruncateLogResponse& TruncateLogResponse::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_cockroach_2froachpb_2fapi_2eproto();
  return *default_instance_;
}

TruncateLogResponse* TruncateLogResponse::default_instance_ = NULL;

TruncateLogResponse* TruncateLogResponse::New(::google::protobuf::Arena* arena) const {
  TruncateLogResponse* n = new TruncateLogResponse;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void TruncateLogResponse::Clear() {
  if (has_header()) {
    if (header_ != NULL) header_->::cockroach::roachpb::ResponseHeader::Clear();
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool TruncateLogResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:cockroach.roachpb.TruncateLogResponse)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .cockroach.roachpb.ResponseHeader header = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_header()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:cockroach.roachpb.TruncateLogResponse)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:cockroach.roachpb.TruncateLogResponse)
  return false;
#undef DO_
}

void TruncateLogResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:cockroach.roachpb.TruncateLogResponse)
  // optional .cockroach.roachpb.ResponseHeader header = 1;
  if (has_header()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->header_, output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:cockroach.roachpb.TruncateLogResponse)
}

::google::protobuf::uint8* TruncateLogResponse::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:cockroach.roachpb.TruncateLogResponse)
  // optional .cockroach.roachpb.ResponseHeader header = 1;
  if (has_header()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, *this->header_, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:cockroach.roachpb.TruncateLogResponse)
  return target;
}

int TruncateLogResponse::ByteSize() const {
  int total_size = 0;

  // optional .cockroach.roachpb.ResponseHeader header = 1;
  if (has_header()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->header_);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TruncateLogResponse::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const TruncateLogResponse* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const TruncateLogResponse>(
          &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void TruncateLogResponse::MergeFrom(const TruncateLogResponse& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_header()) {
      mutable_header()->::cockroach::roachpb::ResponseHeader::MergeFrom(from.header());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void TruncateLogResponse::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TruncateLogResponse::CopyFrom(const TruncateLogResponse& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TruncateLogResponse::IsInitialized() const {

  return true;
}

void TruncateLogResponse::Swap(TruncateLogResponse* other) {
  if (other == this) return;
  InternalSwap(other);
}
void TruncateLogResponse::InternalSwap(TruncateLogResponse* other) {
  std::swap(header_, other->header_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata TruncateLogResponse::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = TruncateLogResponse_descriptor_;
  metadata.reflection = TruncateLogResponse_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// TruncateLogResponse

// optional .cockroach.roachpb.ResponseHeader header = 1;
bool TruncateLogResponse::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void TruncateLogResponse::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
void TruncateLogResponse::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
void TruncateLogResponse::clear_header() {
  if (header_ != NULL) header_->::cockroach::roachpb::ResponseHeader::Clear();
  clear_has_header();
}
const ::cockroach::roachpb::ResponseHeader& TruncateLogResponse::header() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.TruncateLogResponse.header)
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
::cockroach::roachpb::ResponseHeader* TruncateLogResponse::mutable_header() {
  set_has_header();
  if (header_ == NULL) {
    header_ = new ::cockroach::roachpb::ResponseHeader;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.TruncateLogResponse.header)
  return header_;
}
::cockroach::roachpb::ResponseHeader* TruncateLogResponse::release_header() {
  clear_has_header();
  ::cockroach::roachpb::ResponseHeader* temp = header_;
  header_ = NULL;
  return temp;
}
void TruncateLogResponse::set_allocated_header(::cockroach::roachpb::ResponseHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.TruncateLogResponse.header)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int LeaderLeaseRequest::kHeaderFieldNumber;
const int LeaderLeaseRequest::kLeaseFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

LeaderLeaseRequest::LeaderLeaseRequest()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:cockroach.roachpb.LeaderLeaseRequest)
}

void LeaderLeaseRequest::InitAsDefaultInstance() {
  header_ = const_cast< ::cockroach::roachpb::Span*>(&::cockroach::roachpb::Span::default_instance());
  lease_ = const_cast< ::cockroach::roachpb::Lease*>(&::cockroach::roachpb::Lease::default_instance());
}

LeaderLeaseRequest::LeaderLeaseRequest(const LeaderLeaseRequest& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:cockroach.roachpb.LeaderLeaseRequest)
}

void LeaderLeaseRequest::SharedCtor() {
  _cached_size_ = 0;
  header_ = NULL;
  lease_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

LeaderLeaseRequest::~LeaderLeaseRequest() {
  // @@protoc_insertion_point(destructor:cockroach.roachpb.LeaderLeaseRequest)
  SharedDtor();
}

void LeaderLeaseRequest::SharedDtor() {
  if (this != default_instance_) {
    delete header_;
    delete lease_;
  }
}

void LeaderLeaseRequest::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* LeaderLeaseRequest::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return LeaderLeaseRequest_descriptor_;
}

const LeaderLeaseRequest& LeaderLeaseRequest::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_cockroach_2froachpb_2fapi_2eproto();
  return *default_instance_;
}

LeaderLeaseRequest* LeaderLeaseRequest::default_instance_ = NULL;

LeaderLeaseRequest* LeaderLeaseRequest::New(::google::protobuf::Arena* arena) const {
  LeaderLeaseRequest* n = new LeaderLeaseRequest;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void LeaderLeaseRequest::Clear() {
  if (_has_bits_[0 / 32] & 3u) {
    if (has_header()) {
      if (header_ != NULL) header_->::cockroach::roachpb::Span::Clear();
    }
    if (has_lease()) {
      if (lease_ != NULL) lease_->::cockroach::roachpb::Lease::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool LeaderLeaseRequest::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:cockroach.roachpb.LeaderLeaseRequest)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .cockroach.roachpb.Span header = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_header()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_lease;
        break;
      }

      // optional .cockroach.roachpb.Lease lease = 2;
      case 2: {
        if (tag == 18) {
         parse_lease:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_lease()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:cockroach.roachpb.LeaderLeaseRequest)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:cockroach.roachpb.LeaderLeaseRequest)
  return false;
#undef DO_
}

void LeaderLeaseRequest::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:cockroach.roachpb.LeaderLeaseRequest)
  // optional .cockroach.roachpb.Span header = 1;
  if (has_header()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->header_, output);
  }

  // optional .cockroach.roachpb.Lease lease = 2;
  if (has_lease()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, *this->lease_, output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:cockroach.roachpb.LeaderLeaseRequest)
}

::google::protobuf::uint8* LeaderLeaseRequest::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:cockroach.roachpb.LeaderLeaseRequest)
  // optional .cockroach.roachpb.Span header = 1;
  if (has_header()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, *this->header_, target);
  }

  // optional .cockroach.roachpb.Lease lease = 2;
  if (has_lease()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, *this->lease_, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:cockroach.roachpb.LeaderLeaseRequest)
  return target;
}

int LeaderLeaseRequest::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & 3u) {
    // optional .cockroach.roachpb.Span header = 1;
    if (has_header()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->header_);
    }

    // optional .cockroach.roachpb.Lease lease = 2;
    if (has_lease()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->lease_);
    }

  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void LeaderLeaseRequest::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const LeaderLeaseRequest* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const LeaderLeaseRequest>(
          &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void LeaderLeaseRequest::MergeFrom(const LeaderLeaseRequest& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_header()) {
      mutable_header()->::cockroach::roachpb::Span::MergeFrom(from.header());
    }
    if (from.has_lease()) {
      mutable_lease()->::cockroach::roachpb::Lease::MergeFrom(from.lease());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void LeaderLeaseRequest::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void LeaderLeaseRequest::CopyFrom(const LeaderLeaseRequest& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LeaderLeaseRequest::IsInitialized() const {

  return true;
}

void LeaderLeaseRequest::Swap(LeaderLeaseRequest* other) {
  if (other == this) return;
  InternalSwap(other);
}
void LeaderLeaseRequest::InternalSwap(LeaderLeaseRequest* other) {
  std::swap(header_, other->header_);
  std::swap(lease_, other->lease_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata LeaderLeaseRequest::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = LeaderLeaseRequest_descriptor_;
  metadata.reflection = LeaderLeaseRequest_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// LeaderLeaseRequest

// optional .cockroach.roachpb.Span header = 1;
bool LeaderLeaseRequest::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void LeaderLeaseRequest::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
void LeaderLeaseRequest::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
void LeaderLeaseRequest::clear_header() {
  if (header_ != NULL) header_->::cockroach::roachpb::Span::Clear();
  clear_has_header();
}
const ::cockroach::roachpb::Span& LeaderLeaseRequest::header() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.LeaderLeaseRequest.header)
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
::cockroach::roachpb::Span* LeaderLeaseRequest::mutable_header() {
  set_has_header();
  if (header_ == NULL) {
    header_ = new ::cockroach::roachpb::Span;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.LeaderLeaseRequest.header)
  return header_;
}
::cockroach::roachpb::Span* LeaderLeaseRequest::release_header() {
  clear_has_header();
  ::cockroach::roachpb::Span* temp = header_;
  header_ = NULL;
  return temp;
}
void LeaderLeaseRequest::set_allocated_header(::cockroach::roachpb::Span* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.LeaderLeaseRequest.header)
}

// optional .cockroach.roachpb.Lease lease = 2;
bool LeaderLeaseRequest::has_lease() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void LeaderLeaseRequest::set_has_lease() {
  _has_bits_[0] |= 0x00000002u;
}
void LeaderLeaseRequest::clear_has_lease() {
  _has_bits_[0] &= ~0x00000002u;
}
void LeaderLeaseRequest::clear_lease() {
  if (lease_ != NULL) lease_->::cockroach::roachpb::Lease::Clear();
  clear_has_lease();
}
const ::cockroach::roachpb::Lease& LeaderLeaseRequest::lease() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.LeaderLeaseRequest.lease)
  return lease_ != NULL ? *lease_ : *default_instance_->lease_;
}
::cockroach::roachpb::Lease* LeaderLeaseRequest::mutable_lease() {
  set_has_lease();
  if (lease_ == NULL) {
    lease_ = new ::cockroach::roachpb::Lease;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.LeaderLeaseRequest.lease)
  return lease_;
}
::cockroach::roachpb::Lease* LeaderLeaseRequest::release_lease() {
  clear_has_lease();
  ::cockroach::roachpb::Lease* temp = lease_;
  lease_ = NULL;
  return temp;
}
void LeaderLeaseRequest::set_allocated_lease(::cockroach::roachpb::Lease* lease) {
  delete lease_;
  lease_ = lease;
  if (lease) {
    set_has_lease();
  } else {
    clear_has_lease();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.LeaderLeaseRequest.lease)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int LeaderLeaseResponse::kHeaderFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

LeaderLeaseResponse::LeaderLeaseResponse()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:cockroach.roachpb.LeaderLeaseResponse)
}

void LeaderLeaseResponse::InitAsDefaultInstance() {
  header_ = const_cast< ::cockroach::roachpb::ResponseHeader*>(&::cockroach::roachpb::ResponseHeader::default_instance());
}

LeaderLeaseResponse::LeaderLeaseResponse(const LeaderLeaseResponse& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:cockroach.roachpb.LeaderLeaseResponse)
}

void LeaderLeaseResponse::SharedCtor() {
  _cached_size_ = 0;
  header_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

LeaderLeaseResponse::~LeaderLeaseResponse() {
  // @@protoc_insertion_point(destructor:cockroach.roachpb.LeaderLeaseResponse)
  SharedDtor();
}

void LeaderLeaseResponse::SharedDtor() {
  if (this != default_instance_) {
    delete header_;
  }
}

void LeaderLeaseResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* LeaderLeaseResponse::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return LeaderLeaseResponse_descriptor_;
}

const LeaderLeaseResponse& LeaderLeaseResponse::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_cockroach_2froachpb_2fapi_2eproto();
  return *default_instance_;
}

LeaderLeaseResponse* LeaderLeaseResponse::default_instance_ = NULL;

LeaderLeaseResponse* LeaderLeaseResponse::New(::google::protobuf::Arena* arena) const {
  LeaderLeaseResponse* n = new LeaderLeaseResponse;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void LeaderLeaseResponse::Clear() {
  if (has_header()) {
    if (header_ != NULL) header_->::cockroach::roachpb::ResponseHeader::Clear();
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool LeaderLeaseResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:cockroach.roachpb.LeaderLeaseResponse)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .cockroach.roachpb.ResponseHeader header = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_header()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:cockroach.roachpb.LeaderLeaseResponse)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:cockroach.roachpb.LeaderLeaseResponse)
  return false;
#undef DO_
}

void LeaderLeaseResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:cockroach.roachpb.LeaderLeaseResponse)
  // optional .cockroach.roachpb.ResponseHeader header = 1;
  if (has_header()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->header_, output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:cockroach.roachpb.LeaderLeaseResponse)
}

::google::protobuf::uint8* LeaderLeaseResponse::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:cockroach.roachpb.LeaderLeaseResponse)
  // optional .cockroach.roachpb.ResponseHeader header = 1;
  if (has_header()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, *this->header_, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:cockroach.roachpb.LeaderLeaseResponse)
  return target;
}

int LeaderLeaseResponse::ByteSize() const {
  int total_size = 0;

  // optional .cockroach.roachpb.ResponseHeader header = 1;
  if (has_header()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->header_);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void LeaderLeaseResponse::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const LeaderLeaseResponse* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const LeaderLeaseResponse>(
          &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void LeaderLeaseResponse::MergeFrom(const LeaderLeaseResponse& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_header()) {
      mutable_header()->::cockroach::roachpb::ResponseHeader::MergeFrom(from.header());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void LeaderLeaseResponse::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void LeaderLeaseResponse::CopyFrom(const LeaderLeaseResponse& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LeaderLeaseResponse::IsInitialized() const {

  return true;
}

void LeaderLeaseResponse::Swap(LeaderLeaseResponse* other) {
  if (other == this) return;
  InternalSwap(other);
}
void LeaderLeaseResponse::InternalSwap(LeaderLeaseResponse* other) {
  std::swap(header_, other->header_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata LeaderLeaseResponse::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = LeaderLeaseResponse_descriptor_;
  metadata.reflection = LeaderLeaseResponse_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// LeaderLeaseResponse

// optional .cockroach.roachpb.ResponseHeader header = 1;
bool LeaderLeaseResponse::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void LeaderLeaseResponse::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
void LeaderLeaseResponse::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
void LeaderLeaseResponse::clear_header() {
  if (header_ != NULL) header_->::cockroach::roachpb::ResponseHeader::Clear();
  clear_has_header();
}
const ::cockroach::roachpb::ResponseHeader& LeaderLeaseResponse::header() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.LeaderLeaseResponse.header)
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
::cockroach::roachpb::ResponseHeader* LeaderLeaseResponse::mutable_header() {
  set_has_header();
  if (header_ == NULL) {
    header_ = new ::cockroach::roachpb::ResponseHeader;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.LeaderLeaseResponse.header)
  return header_;
}
::cockroach::roachpb::ResponseHeader* LeaderLeaseResponse::release_header() {
  clear_has_header();
  ::cockroach::roachpb::ResponseHeader* temp = header_;
  header_ = NULL;
  return temp;
}
void LeaderLeaseResponse::set_allocated_header(::cockroach::roachpb::ResponseHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.LeaderLeaseResponse.header)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int ComputeChecksumRequest::kHeaderFieldNumber;
const int ComputeChecksumRequest::kVersionFieldNumber;
const int ComputeChecksumRequest::kChecksumIdFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

ComputeChecksumRequest::ComputeChecksumRequest()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:cockroach.roachpb.ComputeChecksumRequest)
}

void ComputeChecksumRequest::InitAsDefaultInstance() {
  header_ = const_cast< ::cockroach::roachpb::Span*>(&::cockroach::roachpb::Span::default_instance());
}

ComputeChecksumRequest::ComputeChecksumRequest(const ComputeChecksumRequest& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:cockroach.roachpb.ComputeChecksumRequest)
}

void ComputeChecksumRequest::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  header_ = NULL;
  version_ = 0u;
  checksum_id_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ComputeChecksumRequest::~ComputeChecksumRequest() {
  // @@protoc_insertion_point(destructor:cockroach.roachpb.ComputeChecksumRequest)
  SharedDtor();
}

void ComputeChecksumRequest::SharedDtor() {
  checksum_id_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != default_instance_) {
    delete header_;
  }
}

void ComputeChecksumRequest::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ComputeChecksumRequest::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ComputeChecksumRequest_descriptor_;
}

const ComputeChecksumRequest& ComputeChecksumRequest::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_cockroach_2froachpb_2fapi_2eproto();
  return *default_instance_;
}

ComputeChecksumRequest* ComputeChecksumRequest::default_instance_ = NULL;

ComputeChecksumRequest* ComputeChecksumRequest::New(::google::protobuf::Arena* arena) const {
  ComputeChecksumRequest* n = new ComputeChecksumRequest;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void ComputeChecksumRequest::Clear() {
  if (_has_bits_[0 / 32] & 7u) {
    if (has_header()) {
      if (header_ != NULL) header_->::cockroach::roachpb::Span::Clear();
    }
    version_ = 0u;
    if (has_checksum_id()) {
      checksum_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool ComputeChecksumRequest::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:cockroach.roachpb.ComputeChecksumRequest)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .cockroach.roachpb.Span header = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_header()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_version;
        break;
      }

      // optional uint32 version = 2;
      case 2: {
        if (tag == 16) {
         parse_version:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &version_)));
          set_has_version();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_checksum_id;
        break;
      }

      // optional bytes checksum_id = 3;
      case 3: {
        if (tag == 26) {
         parse_checksum_id:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_checksum_id()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:cockroach.roachpb.ComputeChecksumRequest)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:cockroach.roachpb.ComputeChecksumRequest)
  return false;
#undef DO_
}

void ComputeChecksumRequest::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:cockroach.roachpb.ComputeChecksumRequest)
  // optional .cockroach.roachpb.Span header = 1;
  if (has_header()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->header_, output);
  }

  // optional uint32 version = 2;
  if (has_version()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->version(), output);
  }

  // optional bytes checksum_id = 3;
  if (has_checksum_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      3, this->checksum_id(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:cockroach.roachpb.ComputeChecksumRequest)
}

::google::protobuf::uint8* ComputeChecksumRequest::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:cockroach.roachpb.ComputeChecksumRequest)
  // optional .cockroach.roachpb.Span header = 1;
  if (has_header()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, *this->header_, target);
  }

  // optional uint32 version = 2;
  if (has_version()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->version(), target);
  }

  // optional bytes checksum_id = 3;
  if (has_checksum_id()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        3, this->checksum_id(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:cockroach.roachpb.ComputeChecksumRequest)
  return target;
}

int ComputeChecksumRequest::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & 7u) {
    // optional .cockroach.roachpb.Span header = 1;
    if (has_header()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->header_);
    }

    // optional uint32 version = 2;
    if (has_version()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->version());
    }

    // optional bytes checksum_id = 3;
    if (has_checksum_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->checksum_id());
    }

  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ComputeChecksumRequest::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const ComputeChecksumRequest* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const ComputeChecksumRequest>(
          &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ComputeChecksumRequest::MergeFrom(const ComputeChecksumRequest& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_header()) {
      mutable_header()->::cockroach::roachpb::Span::MergeFrom(from.header());
    }
    if (from.has_version()) {
      set_version(from.version());
    }
    if (from.has_checksum_id()) {
      set_has_checksum_id();
      checksum_id_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.checksum_id_);
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void ComputeChecksumRequest::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ComputeChecksumRequest::CopyFrom(const ComputeChecksumRequest& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ComputeChecksumRequest::IsInitialized() const {

  return true;
}

void ComputeChecksumRequest::Swap(ComputeChecksumRequest* other) {
  if (other == this) return;
  InternalSwap(other);
}
void ComputeChecksumRequest::InternalSwap(ComputeChecksumRequest* other) {
  std::swap(header_, other->header_);
  std::swap(version_, other->version_);
  checksum_id_.Swap(&other->checksum_id_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata ComputeChecksumRequest::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ComputeChecksumRequest_descriptor_;
  metadata.reflection = ComputeChecksumRequest_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// ComputeChecksumRequest

// optional .cockroach.roachpb.Span header = 1;
bool ComputeChecksumRequest::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void ComputeChecksumRequest::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
void ComputeChecksumRequest::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
void ComputeChecksumRequest::clear_header() {
  if (header_ != NULL) header_->::cockroach::roachpb::Span::Clear();
  clear_has_header();
}
const ::cockroach::roachpb::Span& ComputeChecksumRequest::header() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.ComputeChecksumRequest.header)
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
::cockroach::roachpb::Span* ComputeChecksumRequest::mutable_header() {
  set_has_header();
  if (header_ == NULL) {
    header_ = new ::cockroach::roachpb::Span;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.ComputeChecksumRequest.header)
  return header_;
}
::cockroach::roachpb::Span* ComputeChecksumRequest::release_header() {
  clear_has_header();
  ::cockroach::roachpb::Span* temp = header_;
  header_ = NULL;
  return temp;
}
void ComputeChecksumRequest::set_allocated_header(::cockroach::roachpb::Span* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.ComputeChecksumRequest.header)
}

// optional uint32 version = 2;
bool ComputeChecksumRequest::has_version() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void ComputeChecksumRequest::set_has_version() {
  _has_bits_[0] |= 0x00000002u;
}
void ComputeChecksumRequest::clear_has_version() {
  _has_bits_[0] &= ~0x00000002u;
}
void ComputeChecksumRequest::clear_version() {
  version_ = 0u;
  clear_has_version();
}
 ::google::protobuf::uint32 ComputeChecksumRequest::version() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.ComputeChecksumRequest.version)
  return version_;
}
 void ComputeChecksumRequest::set_version(::google::protobuf::uint32 value) {
  set_has_version();
  version_ = value;
  // @@protoc_insertion_point(field_set:cockroach.roachpb.ComputeChecksumRequest.version)
}

// optional bytes checksum_id = 3;
bool ComputeChecksumRequest::has_checksum_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void ComputeChecksumRequest::set_has_checksum_id() {
  _has_bits_[0] |= 0x00000004u;
}
void ComputeChecksumRequest::clear_has_checksum_id() {
  _has_bits_[0] &= ~0x00000004u;
}
void ComputeChecksumRequest::clear_checksum_id() {
  checksum_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_checksum_id();
}
 const ::std::string& ComputeChecksumRequest::checksum_id() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.ComputeChecksumRequest.checksum_id)
  return checksum_id_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void ComputeChecksumRequest::set_checksum_id(const ::std::string& value) {
  set_has_checksum_id();
  checksum_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cockroach.roachpb.ComputeChecksumRequest.checksum_id)
}
 void ComputeChecksumRequest::set_checksum_id(const char* value) {
  set_has_checksum_id();
  checksum_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cockroach.roachpb.ComputeChecksumRequest.checksum_id)
}
 void ComputeChecksumRequest::set_checksum_id(const void* value, size_t size) {
  set_has_checksum_id();
  checksum_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cockroach.roachpb.ComputeChecksumRequest.checksum_id)
}
 ::std::string* ComputeChecksumRequest::mutable_checksum_id() {
  set_has_checksum_id();
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.ComputeChecksumRequest.checksum_id)
  return checksum_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* ComputeChecksumRequest::release_checksum_id() {
  clear_has_checksum_id();
  return checksum_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void ComputeChecksumRequest::set_allocated_checksum_id(::std::string* checksum_id) {
  if (checksum_id != NULL) {
    set_has_checksum_id();
  } else {
    clear_has_checksum_id();
  }
  checksum_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), checksum_id);
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.ComputeChecksumRequest.checksum_id)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int ComputeChecksumResponse::kHeaderFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

ComputeChecksumResponse::ComputeChecksumResponse()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:cockroach.roachpb.ComputeChecksumResponse)
}

void ComputeChecksumResponse::InitAsDefaultInstance() {
  header_ = const_cast< ::cockroach::roachpb::ResponseHeader*>(&::cockroach::roachpb::ResponseHeader::default_instance());
}

ComputeChecksumResponse::ComputeChecksumResponse(const ComputeChecksumResponse& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:cockroach.roachpb.ComputeChecksumResponse)
}

void ComputeChecksumResponse::SharedCtor() {
  _cached_size_ = 0;
  header_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ComputeChecksumResponse::~ComputeChecksumResponse() {
  // @@protoc_insertion_point(destructor:cockroach.roachpb.ComputeChecksumResponse)
  SharedDtor();
}

void ComputeChecksumResponse::SharedDtor() {
  if (this != default_instance_) {
    delete header_;
  }
}

void ComputeChecksumResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ComputeChecksumResponse::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ComputeChecksumResponse_descriptor_;
}

const ComputeChecksumResponse& ComputeChecksumResponse::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_cockroach_2froachpb_2fapi_2eproto();
  return *default_instance_;
}

ComputeChecksumResponse* ComputeChecksumResponse::default_instance_ = NULL;

ComputeChecksumResponse* ComputeChecksumResponse::New(::google::protobuf::Arena* arena) const {
  ComputeChecksumResponse* n = new ComputeChecksumResponse;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void ComputeChecksumResponse::Clear() {
  if (has_header()) {
    if (header_ != NULL) header_->::cockroach::roachpb::ResponseHeader::Clear();
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool ComputeChecksumResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:cockroach.roachpb.ComputeChecksumResponse)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .cockroach.roachpb.ResponseHeader header = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_header()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:cockroach.roachpb.ComputeChecksumResponse)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:cockroach.roachpb.ComputeChecksumResponse)
  return false;
#undef DO_
}

void ComputeChecksumResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:cockroach.roachpb.ComputeChecksumResponse)
  // optional .cockroach.roachpb.ResponseHeader header = 1;
  if (has_header()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->header_, output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:cockroach.roachpb.ComputeChecksumResponse)
}

::google::protobuf::uint8* ComputeChecksumResponse::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:cockroach.roachpb.ComputeChecksumResponse)
  // optional .cockroach.roachpb.ResponseHeader header = 1;
  if (has_header()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, *this->header_, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:cockroach.roachpb.ComputeChecksumResponse)
  return target;
}

int ComputeChecksumResponse::ByteSize() const {
  int total_size = 0;

  // optional .cockroach.roachpb.ResponseHeader header = 1;
  if (has_header()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->header_);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ComputeChecksumResponse::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const ComputeChecksumResponse* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const ComputeChecksumResponse>(
          &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ComputeChecksumResponse::MergeFrom(const ComputeChecksumResponse& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_header()) {
      mutable_header()->::cockroach::roachpb::ResponseHeader::MergeFrom(from.header());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void ComputeChecksumResponse::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ComputeChecksumResponse::CopyFrom(const ComputeChecksumResponse& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ComputeChecksumResponse::IsInitialized() const {

  return true;
}

void ComputeChecksumResponse::Swap(ComputeChecksumResponse* other) {
  if (other == this) return;
  InternalSwap(other);
}
void ComputeChecksumResponse::InternalSwap(ComputeChecksumResponse* other) {
  std::swap(header_, other->header_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata ComputeChecksumResponse::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ComputeChecksumResponse_descriptor_;
  metadata.reflection = ComputeChecksumResponse_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// ComputeChecksumResponse

// optional .cockroach.roachpb.ResponseHeader header = 1;
bool ComputeChecksumResponse::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void ComputeChecksumResponse::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
void ComputeChecksumResponse::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
void ComputeChecksumResponse::clear_header() {
  if (header_ != NULL) header_->::cockroach::roachpb::ResponseHeader::Clear();
  clear_has_header();
}
const ::cockroach::roachpb::ResponseHeader& ComputeChecksumResponse::header() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.ComputeChecksumResponse.header)
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
::cockroach::roachpb::ResponseHeader* ComputeChecksumResponse::mutable_header() {
  set_has_header();
  if (header_ == NULL) {
    header_ = new ::cockroach::roachpb::ResponseHeader;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.ComputeChecksumResponse.header)
  return header_;
}
::cockroach::roachpb::ResponseHeader* ComputeChecksumResponse::release_header() {
  clear_has_header();
  ::cockroach::roachpb::ResponseHeader* temp = header_;
  header_ = NULL;
  return temp;
}
void ComputeChecksumResponse::set_allocated_header(::cockroach::roachpb::ResponseHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.ComputeChecksumResponse.header)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int VerifyChecksumRequest::kHeaderFieldNumber;
const int VerifyChecksumRequest::kVersionFieldNumber;
const int VerifyChecksumRequest::kChecksumIdFieldNumber;
const int VerifyChecksumRequest::kChecksumFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

VerifyChecksumRequest::VerifyChecksumRequest()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:cockroach.roachpb.VerifyChecksumRequest)
}

void VerifyChecksumRequest::InitAsDefaultInstance() {
  header_ = const_cast< ::cockroach::roachpb::Span*>(&::cockroach::roachpb::Span::default_instance());
}

VerifyChecksumRequest::VerifyChecksumRequest(const VerifyChecksumRequest& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:cockroach.roachpb.VerifyChecksumRequest)
}

void VerifyChecksumRequest::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  header_ = NULL;
  version_ = 0u;
  checksum_id_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  checksum_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

VerifyChecksumRequest::~VerifyChecksumRequest() {
  // @@protoc_insertion_point(destructor:cockroach.roachpb.VerifyChecksumRequest)
  SharedDtor();
}

void VerifyChecksumRequest::SharedDtor() {
  checksum_id_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  checksum_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != default_instance_) {
    delete header_;
  }
}

void VerifyChecksumRequest::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* VerifyChecksumRequest::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return VerifyChecksumRequest_descriptor_;
}

const VerifyChecksumRequest& VerifyChecksumRequest::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_cockroach_2froachpb_2fapi_2eproto();
  return *default_instance_;
}

VerifyChecksumRequest* VerifyChecksumRequest::default_instance_ = NULL;

VerifyChecksumRequest* VerifyChecksumRequest::New(::google::protobuf::Arena* arena) const {
  VerifyChecksumRequest* n = new VerifyChecksumRequest;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void VerifyChecksumRequest::Clear() {
  if (_has_bits_[0 / 32] & 15u) {
    if (has_header()) {
      if (header_ != NULL) header_->::cockroach::roachpb::Span::Clear();
    }
    version_ = 0u;
    if (has_checksum_id()) {
      checksum_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    if (has_checksum()) {
      checksum_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool VerifyChecksumRequest::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:cockroach.roachpb.VerifyChecksumRequest)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .cockroach.roachpb.Span header = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_header()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_version;
        break;
      }

      // optional uint32 version = 2;
      case 2: {
        if (tag == 16) {
         parse_version:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &version_)));
          set_has_version();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_checksum_id;
        break;
      }

      // optional bytes checksum_id = 3;
      case 3: {
        if (tag == 26) {
         parse_checksum_id:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_checksum_id()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_checksum;
        break;
      }

      // optional bytes checksum = 4;
      case 4: {
        if (tag == 34) {
         parse_checksum:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_checksum()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:cockroach.roachpb.VerifyChecksumRequest)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:cockroach.roachpb.VerifyChecksumRequest)
  return false;
#undef DO_
}

void VerifyChecksumRequest::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:cockroach.roachpb.VerifyChecksumRequest)
  // optional .cockroach.roachpb.Span header = 1;
  if (has_header()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->header_, output);
  }

  // optional uint32 version = 2;
  if (has_version()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->version(), output);
  }

  // optional bytes checksum_id = 3;
  if (has_checksum_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      3, this->checksum_id(), output);
  }

  // optional bytes checksum = 4;
  if (has_checksum()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      4, this->checksum(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:cockroach.roachpb.VerifyChecksumRequest)
}

::google::protobuf::uint8* VerifyChecksumRequest::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:cockroach.roachpb.VerifyChecksumRequest)
  // optional .cockroach.roachpb.Span header = 1;
  if (has_header()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, *this->header_, target);
  }

  // optional uint32 version = 2;
  if (has_version()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->version(), target);
  }

  // optional bytes checksum_id = 3;
  if (has_checksum_id()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        3, this->checksum_id(), target);
  }

  // optional bytes checksum = 4;
  if (has_checksum()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        4, this->checksum(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:cockroach.roachpb.VerifyChecksumRequest)
  return target;
}

int VerifyChecksumRequest::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & 15u) {
    // optional .cockroach.roachpb.Span header = 1;
    if (has_header()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->header_);
    }

    // optional uint32 version = 2;
    if (has_version()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->version());
    }

    // optional bytes checksum_id = 3;
    if (has_checksum_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->checksum_id());
    }

    // optional bytes checksum = 4;
    if (has_checksum()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->checksum());
    }

  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void VerifyChecksumRequest::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const VerifyChecksumRequest* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const VerifyChecksumRequest>(
          &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void VerifyChecksumRequest::MergeFrom(const VerifyChecksumRequest& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_header()) {
      mutable_header()->::cockroach::roachpb::Span::MergeFrom(from.header());
    }
    if (from.has_version()) {
      set_version(from.version());
    }
    if (from.has_checksum_id()) {
      set_has_checksum_id();
      checksum_id_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.checksum_id_);
    }
    if (from.has_checksum()) {
      set_has_checksum();
      checksum_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.checksum_);
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void VerifyChecksumRequest::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void VerifyChecksumRequest::CopyFrom(const VerifyChecksumRequest& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool VerifyChecksumRequest::IsInitialized() const {

  return true;
}

void VerifyChecksumRequest::Swap(VerifyChecksumRequest* other) {
  if (other == this) return;
  InternalSwap(other);
}
void VerifyChecksumRequest::InternalSwap(VerifyChecksumRequest* other) {
  std::swap(header_, other->header_);
  std::swap(version_, other->version_);
  checksum_id_.Swap(&other->checksum_id_);
  checksum_.Swap(&other->checksum_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata VerifyChecksumRequest::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = VerifyChecksumRequest_descriptor_;
  metadata.reflection = VerifyChecksumRequest_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// VerifyChecksumRequest

// optional .cockroach.roachpb.Span header = 1;
bool VerifyChecksumRequest::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void VerifyChecksumRequest::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
void VerifyChecksumRequest::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
void VerifyChecksumRequest::clear_header() {
  if (header_ != NULL) header_->::cockroach::roachpb::Span::Clear();
  clear_has_header();
}
const ::cockroach::roachpb::Span& VerifyChecksumRequest::header() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.VerifyChecksumRequest.header)
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
::cockroach::roachpb::Span* VerifyChecksumRequest::mutable_header() {
  set_has_header();
  if (header_ == NULL) {
    header_ = new ::cockroach::roachpb::Span;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.VerifyChecksumRequest.header)
  return header_;
}
::cockroach::roachpb::Span* VerifyChecksumRequest::release_header() {
  clear_has_header();
  ::cockroach::roachpb::Span* temp = header_;
  header_ = NULL;
  return temp;
}
void VerifyChecksumRequest::set_allocated_header(::cockroach::roachpb::Span* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.VerifyChecksumRequest.header)
}

// optional uint32 version = 2;
bool VerifyChecksumRequest::has_version() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void VerifyChecksumRequest::set_has_version() {
  _has_bits_[0] |= 0x00000002u;
}
void VerifyChecksumRequest::clear_has_version() {
  _has_bits_[0] &= ~0x00000002u;
}
void VerifyChecksumRequest::clear_version() {
  version_ = 0u;
  clear_has_version();
}
 ::google::protobuf::uint32 VerifyChecksumRequest::version() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.VerifyChecksumRequest.version)
  return version_;
}
 void VerifyChecksumRequest::set_version(::google::protobuf::uint32 value) {
  set_has_version();
  version_ = value;
  // @@protoc_insertion_point(field_set:cockroach.roachpb.VerifyChecksumRequest.version)
}

// optional bytes checksum_id = 3;
bool VerifyChecksumRequest::has_checksum_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void VerifyChecksumRequest::set_has_checksum_id() {
  _has_bits_[0] |= 0x00000004u;
}
void VerifyChecksumRequest::clear_has_checksum_id() {
  _has_bits_[0] &= ~0x00000004u;
}
void VerifyChecksumRequest::clear_checksum_id() {
  checksum_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_checksum_id();
}
 const ::std::string& VerifyChecksumRequest::checksum_id() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.VerifyChecksumRequest.checksum_id)
  return checksum_id_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void VerifyChecksumRequest::set_checksum_id(const ::std::string& value) {
  set_has_checksum_id();
  checksum_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cockroach.roachpb.VerifyChecksumRequest.checksum_id)
}
 void VerifyChecksumRequest::set_checksum_id(const char* value) {
  set_has_checksum_id();
  checksum_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cockroach.roachpb.VerifyChecksumRequest.checksum_id)
}
 void VerifyChecksumRequest::set_checksum_id(const void* value, size_t size) {
  set_has_checksum_id();
  checksum_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cockroach.roachpb.VerifyChecksumRequest.checksum_id)
}
 ::std::string* VerifyChecksumRequest::mutable_checksum_id() {
  set_has_checksum_id();
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.VerifyChecksumRequest.checksum_id)
  return checksum_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* VerifyChecksumRequest::release_checksum_id() {
  clear_has_checksum_id();
  return checksum_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void VerifyChecksumRequest::set_allocated_checksum_id(::std::string* checksum_id) {
  if (checksum_id != NULL) {
    set_has_checksum_id();
  } else {
    clear_has_checksum_id();
  }
  checksum_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), checksum_id);
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.VerifyChecksumRequest.checksum_id)
}

// optional bytes checksum = 4;
bool VerifyChecksumRequest::has_checksum() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void VerifyChecksumRequest::set_has_checksum() {
  _has_bits_[0] |= 0x00000008u;
}
void VerifyChecksumRequest::clear_has_checksum() {
  _has_bits_[0] &= ~0x00000008u;
}
void VerifyChecksumRequest::clear_checksum() {
  checksum_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_checksum();
}
 const ::std::string& VerifyChecksumRequest::checksum() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.VerifyChecksumRequest.checksum)
  return checksum_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void VerifyChecksumRequest::set_checksum(const ::std::string& value) {
  set_has_checksum();
  checksum_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cockroach.roachpb.VerifyChecksumRequest.checksum)
}
 void VerifyChecksumRequest::set_checksum(const char* value) {
  set_has_checksum();
  checksum_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cockroach.roachpb.VerifyChecksumRequest.checksum)
}
 void VerifyChecksumRequest::set_checksum(const void* value, size_t size) {
  set_has_checksum();
  checksum_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cockroach.roachpb.VerifyChecksumRequest.checksum)
}
 ::std::string* VerifyChecksumRequest::mutable_checksum() {
  set_has_checksum();
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.VerifyChecksumRequest.checksum)
  return checksum_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* VerifyChecksumRequest::release_checksum() {
  clear_has_checksum();
  return checksum_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void VerifyChecksumRequest::set_allocated_checksum(::std::string* checksum) {
  if (checksum != NULL) {
    set_has_checksum();
  } else {
    clear_has_checksum();
  }
  checksum_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), checksum);
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.VerifyChecksumRequest.checksum)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int VerifyChecksumResponse::kHeaderFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

VerifyChecksumResponse::VerifyChecksumResponse()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:cockroach.roachpb.VerifyChecksumResponse)
}

void VerifyChecksumResponse::InitAsDefaultInstance() {
  header_ = const_cast< ::cockroach::roachpb::ResponseHeader*>(&::cockroach::roachpb::ResponseHeader::default_instance());
}

VerifyChecksumResponse::VerifyChecksumResponse(const VerifyChecksumResponse& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:cockroach.roachpb.VerifyChecksumResponse)
}

void VerifyChecksumResponse::SharedCtor() {
  _cached_size_ = 0;
  header_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

VerifyChecksumResponse::~VerifyChecksumResponse() {
  // @@protoc_insertion_point(destructor:cockroach.roachpb.VerifyChecksumResponse)
  SharedDtor();
}

void VerifyChecksumResponse::SharedDtor() {
  if (this != default_instance_) {
    delete header_;
  }
}

void VerifyChecksumResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* VerifyChecksumResponse::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return VerifyChecksumResponse_descriptor_;
}

const VerifyChecksumResponse& VerifyChecksumResponse::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_cockroach_2froachpb_2fapi_2eproto();
  return *default_instance_;
}

VerifyChecksumResponse* VerifyChecksumResponse::default_instance_ = NULL;

VerifyChecksumResponse* VerifyChecksumResponse::New(::google::protobuf::Arena* arena) const {
  VerifyChecksumResponse* n = new VerifyChecksumResponse;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void VerifyChecksumResponse::Clear() {
  if (has_header()) {
    if (header_ != NULL) header_->::cockroach::roachpb::ResponseHeader::Clear();
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool VerifyChecksumResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:cockroach.roachpb.VerifyChecksumResponse)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .cockroach.roachpb.ResponseHeader header = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_header()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:cockroach.roachpb.VerifyChecksumResponse)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:cockroach.roachpb.VerifyChecksumResponse)
  return false;
#undef DO_
}

void VerifyChecksumResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:cockroach.roachpb.VerifyChecksumResponse)
  // optional .cockroach.roachpb.ResponseHeader header = 1;
  if (has_header()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->header_, output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:cockroach.roachpb.VerifyChecksumResponse)
}

::google::protobuf::uint8* VerifyChecksumResponse::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:cockroach.roachpb.VerifyChecksumResponse)
  // optional .cockroach.roachpb.ResponseHeader header = 1;
  if (has_header()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, *this->header_, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:cockroach.roachpb.VerifyChecksumResponse)
  return target;
}

int VerifyChecksumResponse::ByteSize() const {
  int total_size = 0;

  // optional .cockroach.roachpb.ResponseHeader header = 1;
  if (has_header()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->header_);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void VerifyChecksumResponse::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const VerifyChecksumResponse* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const VerifyChecksumResponse>(
          &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void VerifyChecksumResponse::MergeFrom(const VerifyChecksumResponse& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_header()) {
      mutable_header()->::cockroach::roachpb::ResponseHeader::MergeFrom(from.header());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void VerifyChecksumResponse::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void VerifyChecksumResponse::CopyFrom(const VerifyChecksumResponse& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool VerifyChecksumResponse::IsInitialized() const {

  return true;
}

void VerifyChecksumResponse::Swap(VerifyChecksumResponse* other) {
  if (other == this) return;
  InternalSwap(other);
}
void VerifyChecksumResponse::InternalSwap(VerifyChecksumResponse* other) {
  std::swap(header_, other->header_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata VerifyChecksumResponse::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = VerifyChecksumResponse_descriptor_;
  metadata.reflection = VerifyChecksumResponse_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// VerifyChecksumResponse

// optional .cockroach.roachpb.ResponseHeader header = 1;
bool VerifyChecksumResponse::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void VerifyChecksumResponse::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
void VerifyChecksumResponse::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
void VerifyChecksumResponse::clear_header() {
  if (header_ != NULL) header_->::cockroach::roachpb::ResponseHeader::Clear();
  clear_has_header();
}
const ::cockroach::roachpb::ResponseHeader& VerifyChecksumResponse::header() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.VerifyChecksumResponse.header)
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
::cockroach::roachpb::ResponseHeader* VerifyChecksumResponse::mutable_header() {
  set_has_header();
  if (header_ == NULL) {
    header_ = new ::cockroach::roachpb::ResponseHeader;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.VerifyChecksumResponse.header)
  return header_;
}
::cockroach::roachpb::ResponseHeader* VerifyChecksumResponse::release_header() {
  clear_has_header();
  ::cockroach::roachpb::ResponseHeader* temp = header_;
  header_ = NULL;
  return temp;
}
void VerifyChecksumResponse::set_allocated_header(::cockroach::roachpb::ResponseHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.VerifyChecksumResponse.header)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int RequestUnion::kGetFieldNumber;
const int RequestUnion::kPutFieldNumber;
const int RequestUnion::kConditionalPutFieldNumber;
const int RequestUnion::kIncrementFieldNumber;
const int RequestUnion::kDeleteFieldNumber;
const int RequestUnion::kDeleteRangeFieldNumber;
const int RequestUnion::kScanFieldNumber;
const int RequestUnion::kBeginTransactionFieldNumber;
const int RequestUnion::kEndTransactionFieldNumber;
const int RequestUnion::kAdminSplitFieldNumber;
const int RequestUnion::kAdminMergeFieldNumber;
const int RequestUnion::kHeartbeatTxnFieldNumber;
const int RequestUnion::kGcFieldNumber;
const int RequestUnion::kPushTxnFieldNumber;
const int RequestUnion::kRangeLookupFieldNumber;
const int RequestUnion::kResolveIntentFieldNumber;
const int RequestUnion::kResolveIntentRangeFieldNumber;
const int RequestUnion::kMergeFieldNumber;
const int RequestUnion::kTruncateLogFieldNumber;
const int RequestUnion::kLeaderLeaseFieldNumber;
const int RequestUnion::kReverseScanFieldNumber;
const int RequestUnion::kComputeChecksumFieldNumber;
const int RequestUnion::kVerifyChecksumFieldNumber;
const int RequestUnion::kCheckConsistencyFieldNumber;
const int RequestUnion::kNoopFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

RequestUnion::RequestUnion()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:cockroach.roachpb.RequestUnion)
}

void RequestUnion::InitAsDefaultInstance() {
  get_ = const_cast< ::cockroach::roachpb::GetRequest*>(&::cockroach::roachpb::GetRequest::default_instance());
  put_ = const_cast< ::cockroach::roachpb::PutRequest*>(&::cockroach::roachpb::PutRequest::default_instance());
  conditional_put_ = const_cast< ::cockroach::roachpb::ConditionalPutRequest*>(&::cockroach::roachpb::ConditionalPutRequest::default_instance());
  increment_ = const_cast< ::cockroach::roachpb::IncrementRequest*>(&::cockroach::roachpb::IncrementRequest::default_instance());
  delete__ = const_cast< ::cockroach::roachpb::DeleteRequest*>(&::cockroach::roachpb::DeleteRequest::default_instance());
  delete_range_ = const_cast< ::cockroach::roachpb::DeleteRangeRequest*>(&::cockroach::roachpb::DeleteRangeRequest::default_instance());
  scan_ = const_cast< ::cockroach::roachpb::ScanRequest*>(&::cockroach::roachpb::ScanRequest::default_instance());
  begin_transaction_ = const_cast< ::cockroach::roachpb::BeginTransactionRequest*>(&::cockroach::roachpb::BeginTransactionRequest::default_instance());
  end_transaction_ = const_cast< ::cockroach::roachpb::EndTransactionRequest*>(&::cockroach::roachpb::EndTransactionRequest::default_instance());
  admin_split_ = const_cast< ::cockroach::roachpb::AdminSplitRequest*>(&::cockroach::roachpb::AdminSplitRequest::default_instance());
  admin_merge_ = const_cast< ::cockroach::roachpb::AdminMergeRequest*>(&::cockroach::roachpb::AdminMergeRequest::default_instance());
  heartbeat_txn_ = const_cast< ::cockroach::roachpb::HeartbeatTxnRequest*>(&::cockroach::roachpb::HeartbeatTxnRequest::default_instance());
  gc_ = const_cast< ::cockroach::roachpb::GCRequest*>(&::cockroach::roachpb::GCRequest::default_instance());
  push_txn_ = const_cast< ::cockroach::roachpb::PushTxnRequest*>(&::cockroach::roachpb::PushTxnRequest::default_instance());
  range_lookup_ = const_cast< ::cockroach::roachpb::RangeLookupRequest*>(&::cockroach::roachpb::RangeLookupRequest::default_instance());
  resolve_intent_ = const_cast< ::cockroach::roachpb::ResolveIntentRequest*>(&::cockroach::roachpb::ResolveIntentRequest::default_instance());
  resolve_intent_range_ = const_cast< ::cockroach::roachpb::ResolveIntentRangeRequest*>(&::cockroach::roachpb::ResolveIntentRangeRequest::default_instance());
  merge_ = const_cast< ::cockroach::roachpb::MergeRequest*>(&::cockroach::roachpb::MergeRequest::default_instance());
  truncate_log_ = const_cast< ::cockroach::roachpb::TruncateLogRequest*>(&::cockroach::roachpb::TruncateLogRequest::default_instance());
  leader_lease_ = const_cast< ::cockroach::roachpb::LeaderLeaseRequest*>(&::cockroach::roachpb::LeaderLeaseRequest::default_instance());
  reverse_scan_ = const_cast< ::cockroach::roachpb::ReverseScanRequest*>(&::cockroach::roachpb::ReverseScanRequest::default_instance());
  compute_checksum_ = const_cast< ::cockroach::roachpb::ComputeChecksumRequest*>(&::cockroach::roachpb::ComputeChecksumRequest::default_instance());
  verify_checksum_ = const_cast< ::cockroach::roachpb::VerifyChecksumRequest*>(&::cockroach::roachpb::VerifyChecksumRequest::default_instance());
  check_consistency_ = const_cast< ::cockroach::roachpb::CheckConsistencyRequest*>(&::cockroach::roachpb::CheckConsistencyRequest::default_instance());
  noop_ = const_cast< ::cockroach::roachpb::NoopRequest*>(&::cockroach::roachpb::NoopRequest::default_instance());
}

RequestUnion::RequestUnion(const RequestUnion& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:cockroach.roachpb.RequestUnion)
}

void RequestUnion::SharedCtor() {
  _cached_size_ = 0;
  get_ = NULL;
  put_ = NULL;
  conditional_put_ = NULL;
  increment_ = NULL;
  delete__ = NULL;
  delete_range_ = NULL;
  scan_ = NULL;
  begin_transaction_ = NULL;
  end_transaction_ = NULL;
  admin_split_ = NULL;
  admin_merge_ = NULL;
  heartbeat_txn_ = NULL;
  gc_ = NULL;
  push_txn_ = NULL;
  range_lookup_ = NULL;
  resolve_intent_ = NULL;
  resolve_intent_range_ = NULL;
  merge_ = NULL;
  truncate_log_ = NULL;
  leader_lease_ = NULL;
  reverse_scan_ = NULL;
  compute_checksum_ = NULL;
  verify_checksum_ = NULL;
  check_consistency_ = NULL;
  noop_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RequestUnion::~RequestUnion() {
  // @@protoc_insertion_point(destructor:cockroach.roachpb.RequestUnion)
  SharedDtor();
}

void RequestUnion::SharedDtor() {
  if (this != default_instance_) {
    delete get_;
    delete put_;
    delete conditional_put_;
    delete increment_;
    delete delete__;
    delete delete_range_;
    delete scan_;
    delete begin_transaction_;
    delete end_transaction_;
    delete admin_split_;
    delete admin_merge_;
    delete heartbeat_txn_;
    delete gc_;
    delete push_txn_;
    delete range_lookup_;
    delete resolve_intent_;
    delete resolve_intent_range_;
    delete merge_;
    delete truncate_log_;
    delete leader_lease_;
    delete reverse_scan_;
    delete compute_checksum_;
    delete verify_checksum_;
    delete check_consistency_;
    delete noop_;
  }
}

void RequestUnion::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* RequestUnion::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return RequestUnion_descriptor_;
}

const RequestUnion& RequestUnion::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_cockroach_2froachpb_2fapi_2eproto();
  return *default_instance_;
}

RequestUnion* RequestUnion::default_instance_ = NULL;

RequestUnion* RequestUnion::New(::google::protobuf::Arena* arena) const {
  RequestUnion* n = new RequestUnion;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void RequestUnion::Clear() {
  if (_has_bits_[0 / 32] & 255u) {
    if (has_get()) {
      if (get_ != NULL) get_->::cockroach::roachpb::GetRequest::Clear();
    }
    if (has_put()) {
      if (put_ != NULL) put_->::cockroach::roachpb::PutRequest::Clear();
    }
    if (has_conditional_put()) {
      if (conditional_put_ != NULL) conditional_put_->::cockroach::roachpb::ConditionalPutRequest::Clear();
    }
    if (has_increment()) {
      if (increment_ != NULL) increment_->::cockroach::roachpb::IncrementRequest::Clear();
    }
    if (has_delete_()) {
      if (delete__ != NULL) delete__->::cockroach::roachpb::DeleteRequest::Clear();
    }
    if (has_delete_range()) {
      if (delete_range_ != NULL) delete_range_->::cockroach::roachpb::DeleteRangeRequest::Clear();
    }
    if (has_scan()) {
      if (scan_ != NULL) scan_->::cockroach::roachpb::ScanRequest::Clear();
    }
    if (has_begin_transaction()) {
      if (begin_transaction_ != NULL) begin_transaction_->::cockroach::roachpb::BeginTransactionRequest::Clear();
    }
  }
  if (_has_bits_[8 / 32] & 65280u) {
    if (has_end_transaction()) {
      if (end_transaction_ != NULL) end_transaction_->::cockroach::roachpb::EndTransactionRequest::Clear();
    }
    if (has_admin_split()) {
      if (admin_split_ != NULL) admin_split_->::cockroach::roachpb::AdminSplitRequest::Clear();
    }
    if (has_admin_merge()) {
      if (admin_merge_ != NULL) admin_merge_->::cockroach::roachpb::AdminMergeRequest::Clear();
    }
    if (has_heartbeat_txn()) {
      if (heartbeat_txn_ != NULL) heartbeat_txn_->::cockroach::roachpb::HeartbeatTxnRequest::Clear();
    }
    if (has_gc()) {
      if (gc_ != NULL) gc_->::cockroach::roachpb::GCRequest::Clear();
    }
    if (has_push_txn()) {
      if (push_txn_ != NULL) push_txn_->::cockroach::roachpb::PushTxnRequest::Clear();
    }
    if (has_range_lookup()) {
      if (range_lookup_ != NULL) range_lookup_->::cockroach::roachpb::RangeLookupRequest::Clear();
    }
    if (has_resolve_intent()) {
      if (resolve_intent_ != NULL) resolve_intent_->::cockroach::roachpb::ResolveIntentRequest::Clear();
    }
  }
  if (_has_bits_[16 / 32] & 16711680u) {
    if (has_resolve_intent_range()) {
      if (resolve_intent_range_ != NULL) resolve_intent_range_->::cockroach::roachpb::ResolveIntentRangeRequest::Clear();
    }
    if (has_merge()) {
      if (merge_ != NULL) merge_->::cockroach::roachpb::MergeRequest::Clear();
    }
    if (has_truncate_log()) {
      if (truncate_log_ != NULL) truncate_log_->::cockroach::roachpb::TruncateLogRequest::Clear();
    }
    if (has_leader_lease()) {
      if (leader_lease_ != NULL) leader_lease_->::cockroach::roachpb::LeaderLeaseRequest::Clear();
    }
    if (has_reverse_scan()) {
      if (reverse_scan_ != NULL) reverse_scan_->::cockroach::roachpb::ReverseScanRequest::Clear();
    }
    if (has_compute_checksum()) {
      if (compute_checksum_ != NULL) compute_checksum_->::cockroach::roachpb::ComputeChecksumRequest::Clear();
    }
    if (has_verify_checksum()) {
      if (verify_checksum_ != NULL) verify_checksum_->::cockroach::roachpb::VerifyChecksumRequest::Clear();
    }
    if (has_check_consistency()) {
      if (check_consistency_ != NULL) check_consistency_->::cockroach::roachpb::CheckConsistencyRequest::Clear();
    }
  }
  if (has_noop()) {
    if (noop_ != NULL) noop_->::cockroach::roachpb::NoopRequest::Clear();
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool RequestUnion::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:cockroach.roachpb.RequestUnion)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(16383);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .cockroach.roachpb.GetRequest get = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_get()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_put;
        break;
      }

      // optional .cockroach.roachpb.PutRequest put = 2;
      case 2: {
        if (tag == 18) {
         parse_put:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_put()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_conditional_put;
        break;
      }

      // optional .cockroach.roachpb.ConditionalPutRequest conditional_put = 3;
      case 3: {
        if (tag == 26) {
         parse_conditional_put:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_conditional_put()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_increment;
        break;
      }

      // optional .cockroach.roachpb.IncrementRequest increment = 4;
      case 4: {
        if (tag == 34) {
         parse_increment:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_increment()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_delete;
        break;
      }

      // optional .cockroach.roachpb.DeleteRequest delete = 5;
      case 5: {
        if (tag == 42) {
         parse_delete:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_delete_()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(50)) goto parse_delete_range;
        break;
      }

      // optional .cockroach.roachpb.DeleteRangeRequest delete_range = 6;
      case 6: {
        if (tag == 50) {
         parse_delete_range:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_delete_range()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(58)) goto parse_scan;
        break;
      }

      // optional .cockroach.roachpb.ScanRequest scan = 7;
      case 7: {
        if (tag == 58) {
         parse_scan:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_scan()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(66)) goto parse_begin_transaction;
        break;
      }

      // optional .cockroach.roachpb.BeginTransactionRequest begin_transaction = 8;
      case 8: {
        if (tag == 66) {
         parse_begin_transaction:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_begin_transaction()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(74)) goto parse_end_transaction;
        break;
      }

      // optional .cockroach.roachpb.EndTransactionRequest end_transaction = 9;
      case 9: {
        if (tag == 74) {
         parse_end_transaction:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_end_transaction()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(82)) goto parse_admin_split;
        break;
      }

      // optional .cockroach.roachpb.AdminSplitRequest admin_split = 10;
      case 10: {
        if (tag == 82) {
         parse_admin_split:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_admin_split()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(90)) goto parse_admin_merge;
        break;
      }

      // optional .cockroach.roachpb.AdminMergeRequest admin_merge = 11;
      case 11: {
        if (tag == 90) {
         parse_admin_merge:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_admin_merge()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(98)) goto parse_heartbeat_txn;
        break;
      }

      // optional .cockroach.roachpb.HeartbeatTxnRequest heartbeat_txn = 12;
      case 12: {
        if (tag == 98) {
         parse_heartbeat_txn:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_heartbeat_txn()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(106)) goto parse_gc;
        break;
      }

      // optional .cockroach.roachpb.GCRequest gc = 13;
      case 13: {
        if (tag == 106) {
         parse_gc:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_gc()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(114)) goto parse_push_txn;
        break;
      }

      // optional .cockroach.roachpb.PushTxnRequest push_txn = 14;
      case 14: {
        if (tag == 114) {
         parse_push_txn:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_push_txn()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(122)) goto parse_range_lookup;
        break;
      }

      // optional .cockroach.roachpb.RangeLookupRequest range_lookup = 15;
      case 15: {
        if (tag == 122) {
         parse_range_lookup:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_range_lookup()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(130)) goto parse_resolve_intent;
        break;
      }

      // optional .cockroach.roachpb.ResolveIntentRequest resolve_intent = 16;
      case 16: {
        if (tag == 130) {
         parse_resolve_intent:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_resolve_intent()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(138)) goto parse_resolve_intent_range;
        break;
      }

      // optional .cockroach.roachpb.ResolveIntentRangeRequest resolve_intent_range = 17;
      case 17: {
        if (tag == 138) {
         parse_resolve_intent_range:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_resolve_intent_range()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(146)) goto parse_merge;
        break;
      }

      // optional .cockroach.roachpb.MergeRequest merge = 18;
      case 18: {
        if (tag == 146) {
         parse_merge:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_merge()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(154)) goto parse_truncate_log;
        break;
      }

      // optional .cockroach.roachpb.TruncateLogRequest truncate_log = 19;
      case 19: {
        if (tag == 154) {
         parse_truncate_log:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_truncate_log()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(162)) goto parse_leader_lease;
        break;
      }

      // optional .cockroach.roachpb.LeaderLeaseRequest leader_lease = 20;
      case 20: {
        if (tag == 162) {
         parse_leader_lease:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_leader_lease()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(170)) goto parse_reverse_scan;
        break;
      }

      // optional .cockroach.roachpb.ReverseScanRequest reverse_scan = 21;
      case 21: {
        if (tag == 170) {
         parse_reverse_scan:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_reverse_scan()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(178)) goto parse_compute_checksum;
        break;
      }

      // optional .cockroach.roachpb.ComputeChecksumRequest compute_checksum = 22;
      case 22: {
        if (tag == 178) {
         parse_compute_checksum:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_compute_checksum()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(186)) goto parse_verify_checksum;
        break;
      }

      // optional .cockroach.roachpb.VerifyChecksumRequest verify_checksum = 23;
      case 23: {
        if (tag == 186) {
         parse_verify_checksum:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_verify_checksum()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(194)) goto parse_check_consistency;
        break;
      }

      // optional .cockroach.roachpb.CheckConsistencyRequest check_consistency = 24;
      case 24: {
        if (tag == 194) {
         parse_check_consistency:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_check_consistency()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(202)) goto parse_noop;
        break;
      }

      // optional .cockroach.roachpb.NoopRequest noop = 25;
      case 25: {
        if (tag == 202) {
         parse_noop:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_noop()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:cockroach.roachpb.RequestUnion)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:cockroach.roachpb.RequestUnion)
  return false;
#undef DO_
}

void RequestUnion::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:cockroach.roachpb.RequestUnion)
  // optional .cockroach.roachpb.GetRequest get = 1;
  if (has_get()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->get_, output);
  }

  // optional .cockroach.roachpb.PutRequest put = 2;
  if (has_put()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, *this->put_, output);
  }

  // optional .cockroach.roachpb.ConditionalPutRequest conditional_put = 3;
  if (has_conditional_put()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, *this->conditional_put_, output);
  }

  // optional .cockroach.roachpb.IncrementRequest increment = 4;
  if (has_increment()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, *this->increment_, output);
  }

  // optional .cockroach.roachpb.DeleteRequest delete = 5;
  if (has_delete_()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      5, *this->delete__, output);
  }

  // optional .cockroach.roachpb.DeleteRangeRequest delete_range = 6;
  if (has_delete_range()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      6, *this->delete_range_, output);
  }

  // optional .cockroach.roachpb.ScanRequest scan = 7;
  if (has_scan()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      7, *this->scan_, output);
  }

  // optional .cockroach.roachpb.BeginTransactionRequest begin_transaction = 8;
  if (has_begin_transaction()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      8, *this->begin_transaction_, output);
  }

  // optional .cockroach.roachpb.EndTransactionRequest end_transaction = 9;
  if (has_end_transaction()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      9, *this->end_transaction_, output);
  }

  // optional .cockroach.roachpb.AdminSplitRequest admin_split = 10;
  if (has_admin_split()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      10, *this->admin_split_, output);
  }

  // optional .cockroach.roachpb.AdminMergeRequest admin_merge = 11;
  if (has_admin_merge()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      11, *this->admin_merge_, output);
  }

  // optional .cockroach.roachpb.HeartbeatTxnRequest heartbeat_txn = 12;
  if (has_heartbeat_txn()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      12, *this->heartbeat_txn_, output);
  }

  // optional .cockroach.roachpb.GCRequest gc = 13;
  if (has_gc()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      13, *this->gc_, output);
  }

  // optional .cockroach.roachpb.PushTxnRequest push_txn = 14;
  if (has_push_txn()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      14, *this->push_txn_, output);
  }

  // optional .cockroach.roachpb.RangeLookupRequest range_lookup = 15;
  if (has_range_lookup()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      15, *this->range_lookup_, output);
  }

  // optional .cockroach.roachpb.ResolveIntentRequest resolve_intent = 16;
  if (has_resolve_intent()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      16, *this->resolve_intent_, output);
  }

  // optional .cockroach.roachpb.ResolveIntentRangeRequest resolve_intent_range = 17;
  if (has_resolve_intent_range()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      17, *this->resolve_intent_range_, output);
  }

  // optional .cockroach.roachpb.MergeRequest merge = 18;
  if (has_merge()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      18, *this->merge_, output);
  }

  // optional .cockroach.roachpb.TruncateLogRequest truncate_log = 19;
  if (has_truncate_log()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      19, *this->truncate_log_, output);
  }

  // optional .cockroach.roachpb.LeaderLeaseRequest leader_lease = 20;
  if (has_leader_lease()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      20, *this->leader_lease_, output);
  }

  // optional .cockroach.roachpb.ReverseScanRequest reverse_scan = 21;
  if (has_reverse_scan()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      21, *this->reverse_scan_, output);
  }

  // optional .cockroach.roachpb.ComputeChecksumRequest compute_checksum = 22;
  if (has_compute_checksum()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      22, *this->compute_checksum_, output);
  }

  // optional .cockroach.roachpb.VerifyChecksumRequest verify_checksum = 23;
  if (has_verify_checksum()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      23, *this->verify_checksum_, output);
  }

  // optional .cockroach.roachpb.CheckConsistencyRequest check_consistency = 24;
  if (has_check_consistency()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      24, *this->check_consistency_, output);
  }

  // optional .cockroach.roachpb.NoopRequest noop = 25;
  if (has_noop()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      25, *this->noop_, output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:cockroach.roachpb.RequestUnion)
}

::google::protobuf::uint8* RequestUnion::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:cockroach.roachpb.RequestUnion)
  // optional .cockroach.roachpb.GetRequest get = 1;
  if (has_get()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, *this->get_, target);
  }

  // optional .cockroach.roachpb.PutRequest put = 2;
  if (has_put()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, *this->put_, target);
  }

  // optional .cockroach.roachpb.ConditionalPutRequest conditional_put = 3;
  if (has_conditional_put()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, *this->conditional_put_, target);
  }

  // optional .cockroach.roachpb.IncrementRequest increment = 4;
  if (has_increment()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        4, *this->increment_, target);
  }

  // optional .cockroach.roachpb.DeleteRequest delete = 5;
  if (has_delete_()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        5, *this->delete__, target);
  }

  // optional .cockroach.roachpb.DeleteRangeRequest delete_range = 6;
  if (has_delete_range()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        6, *this->delete_range_, target);
  }

  // optional .cockroach.roachpb.ScanRequest scan = 7;
  if (has_scan()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        7, *this->scan_, target);
  }

  // optional .cockroach.roachpb.BeginTransactionRequest begin_transaction = 8;
  if (has_begin_transaction()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        8, *this->begin_transaction_, target);
  }

  // optional .cockroach.roachpb.EndTransactionRequest end_transaction = 9;
  if (has_end_transaction()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        9, *this->end_transaction_, target);
  }

  // optional .cockroach.roachpb.AdminSplitRequest admin_split = 10;
  if (has_admin_split()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        10, *this->admin_split_, target);
  }

  // optional .cockroach.roachpb.AdminMergeRequest admin_merge = 11;
  if (has_admin_merge()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        11, *this->admin_merge_, target);
  }

  // optional .cockroach.roachpb.HeartbeatTxnRequest heartbeat_txn = 12;
  if (has_heartbeat_txn()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        12, *this->heartbeat_txn_, target);
  }

  // optional .cockroach.roachpb.GCRequest gc = 13;
  if (has_gc()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        13, *this->gc_, target);
  }

  // optional .cockroach.roachpb.PushTxnRequest push_txn = 14;
  if (has_push_txn()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        14, *this->push_txn_, target);
  }

  // optional .cockroach.roachpb.RangeLookupRequest range_lookup = 15;
  if (has_range_lookup()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        15, *this->range_lookup_, target);
  }

  // optional .cockroach.roachpb.ResolveIntentRequest resolve_intent = 16;
  if (has_resolve_intent()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        16, *this->resolve_intent_, target);
  }

  // optional .cockroach.roachpb.ResolveIntentRangeRequest resolve_intent_range = 17;
  if (has_resolve_intent_range()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        17, *this->resolve_intent_range_, target);
  }

  // optional .cockroach.roachpb.MergeRequest merge = 18;
  if (has_merge()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        18, *this->merge_, target);
  }

  // optional .cockroach.roachpb.TruncateLogRequest truncate_log = 19;
  if (has_truncate_log()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        19, *this->truncate_log_, target);
  }

  // optional .cockroach.roachpb.LeaderLeaseRequest leader_lease = 20;
  if (has_leader_lease()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        20, *this->leader_lease_, target);
  }

  // optional .cockroach.roachpb.ReverseScanRequest reverse_scan = 21;
  if (has_reverse_scan()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        21, *this->reverse_scan_, target);
  }

  // optional .cockroach.roachpb.ComputeChecksumRequest compute_checksum = 22;
  if (has_compute_checksum()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        22, *this->compute_checksum_, target);
  }

  // optional .cockroach.roachpb.VerifyChecksumRequest verify_checksum = 23;
  if (has_verify_checksum()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        23, *this->verify_checksum_, target);
  }

  // optional .cockroach.roachpb.CheckConsistencyRequest check_consistency = 24;
  if (has_check_consistency()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        24, *this->check_consistency_, target);
  }

  // optional .cockroach.roachpb.NoopRequest noop = 25;
  if (has_noop()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        25, *this->noop_, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:cockroach.roachpb.RequestUnion)
  return target;
}

int RequestUnion::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & 255u) {
    // optional .cockroach.roachpb.GetRequest get = 1;
    if (has_get()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->get_);
    }

    // optional .cockroach.roachpb.PutRequest put = 2;
    if (has_put()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->put_);
    }

    // optional .cockroach.roachpb.ConditionalPutRequest conditional_put = 3;
    if (has_conditional_put()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->conditional_put_);
    }

    // optional .cockroach.roachpb.IncrementRequest increment = 4;
    if (has_increment()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->increment_);
    }

    // optional .cockroach.roachpb.DeleteRequest delete = 5;
    if (has_delete_()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->delete__);
    }

    // optional .cockroach.roachpb.DeleteRangeRequest delete_range = 6;
    if (has_delete_range()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->delete_range_);
    }

    // optional .cockroach.roachpb.ScanRequest scan = 7;
    if (has_scan()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->scan_);
    }

    // optional .cockroach.roachpb.BeginTransactionRequest begin_transaction = 8;
    if (has_begin_transaction()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->begin_transaction_);
    }

  }
  if (_has_bits_[8 / 32] & 65280u) {
    // optional .cockroach.roachpb.EndTransactionRequest end_transaction = 9;
    if (has_end_transaction()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->end_transaction_);
    }

    // optional .cockroach.roachpb.AdminSplitRequest admin_split = 10;
    if (has_admin_split()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->admin_split_);
    }

    // optional .cockroach.roachpb.AdminMergeRequest admin_merge = 11;
    if (has_admin_merge()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->admin_merge_);
    }

    // optional .cockroach.roachpb.HeartbeatTxnRequest heartbeat_txn = 12;
    if (has_heartbeat_txn()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->heartbeat_txn_);
    }

    // optional .cockroach.roachpb.GCRequest gc = 13;
    if (has_gc()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->gc_);
    }

    // optional .cockroach.roachpb.PushTxnRequest push_txn = 14;
    if (has_push_txn()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->push_txn_);
    }

    // optional .cockroach.roachpb.RangeLookupRequest range_lookup = 15;
    if (has_range_lookup()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->range_lookup_);
    }

    // optional .cockroach.roachpb.ResolveIntentRequest resolve_intent = 16;
    if (has_resolve_intent()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->resolve_intent_);
    }

  }
  if (_has_bits_[16 / 32] & 16711680u) {
    // optional .cockroach.roachpb.ResolveIntentRangeRequest resolve_intent_range = 17;
    if (has_resolve_intent_range()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->resolve_intent_range_);
    }

    // optional .cockroach.roachpb.MergeRequest merge = 18;
    if (has_merge()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->merge_);
    }

    // optional .cockroach.roachpb.TruncateLogRequest truncate_log = 19;
    if (has_truncate_log()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->truncate_log_);
    }

    // optional .cockroach.roachpb.LeaderLeaseRequest leader_lease = 20;
    if (has_leader_lease()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->leader_lease_);
    }

    // optional .cockroach.roachpb.ReverseScanRequest reverse_scan = 21;
    if (has_reverse_scan()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->reverse_scan_);
    }

    // optional .cockroach.roachpb.ComputeChecksumRequest compute_checksum = 22;
    if (has_compute_checksum()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->compute_checksum_);
    }

    // optional .cockroach.roachpb.VerifyChecksumRequest verify_checksum = 23;
    if (has_verify_checksum()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->verify_checksum_);
    }

    // optional .cockroach.roachpb.CheckConsistencyRequest check_consistency = 24;
    if (has_check_consistency()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->check_consistency_);
    }

  }
  // optional .cockroach.roachpb.NoopRequest noop = 25;
  if (has_noop()) {
    total_size += 2 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->noop_);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RequestUnion::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const RequestUnion* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const RequestUnion>(
          &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void RequestUnion::MergeFrom(const RequestUnion& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_get()) {
      mutable_get()->::cockroach::roachpb::GetRequest::MergeFrom(from.get());
    }
    if (from.has_put()) {
      mutable_put()->::cockroach::roachpb::PutRequest::MergeFrom(from.put());
    }
    if (from.has_conditional_put()) {
      mutable_conditional_put()->::cockroach::roachpb::ConditionalPutRequest::MergeFrom(from.conditional_put());
    }
    if (from.has_increment()) {
      mutable_increment()->::cockroach::roachpb::IncrementRequest::MergeFrom(from.increment());
    }
    if (from.has_delete_()) {
      mutable_delete_()->::cockroach::roachpb::DeleteRequest::MergeFrom(from.delete_());
    }
    if (from.has_delete_range()) {
      mutable_delete_range()->::cockroach::roachpb::DeleteRangeRequest::MergeFrom(from.delete_range());
    }
    if (from.has_scan()) {
      mutable_scan()->::cockroach::roachpb::ScanRequest::MergeFrom(from.scan());
    }
    if (from.has_begin_transaction()) {
      mutable_begin_transaction()->::cockroach::roachpb::BeginTransactionRequest::MergeFrom(from.begin_transaction());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_end_transaction()) {
      mutable_end_transaction()->::cockroach::roachpb::EndTransactionRequest::MergeFrom(from.end_transaction());
    }
    if (from.has_admin_split()) {
      mutable_admin_split()->::cockroach::roachpb::AdminSplitRequest::MergeFrom(from.admin_split());
    }
    if (from.has_admin_merge()) {
      mutable_admin_merge()->::cockroach::roachpb::AdminMergeRequest::MergeFrom(from.admin_merge());
    }
    if (from.has_heartbeat_txn()) {
      mutable_heartbeat_txn()->::cockroach::roachpb::HeartbeatTxnRequest::MergeFrom(from.heartbeat_txn());
    }
    if (from.has_gc()) {
      mutable_gc()->::cockroach::roachpb::GCRequest::MergeFrom(from.gc());
    }
    if (from.has_push_txn()) {
      mutable_push_txn()->::cockroach::roachpb::PushTxnRequest::MergeFrom(from.push_txn());
    }
    if (from.has_range_lookup()) {
      mutable_range_lookup()->::cockroach::roachpb::RangeLookupRequest::MergeFrom(from.range_lookup());
    }
    if (from.has_resolve_intent()) {
      mutable_resolve_intent()->::cockroach::roachpb::ResolveIntentRequest::MergeFrom(from.resolve_intent());
    }
  }
  if (from._has_bits_[16 / 32] & (0xffu << (16 % 32))) {
    if (from.has_resolve_intent_range()) {
      mutable_resolve_intent_range()->::cockroach::roachpb::ResolveIntentRangeRequest::MergeFrom(from.resolve_intent_range());
    }
    if (from.has_merge()) {
      mutable_merge()->::cockroach::roachpb::MergeRequest::MergeFrom(from.merge());
    }
    if (from.has_truncate_log()) {
      mutable_truncate_log()->::cockroach::roachpb::TruncateLogRequest::MergeFrom(from.truncate_log());
    }
    if (from.has_leader_lease()) {
      mutable_leader_lease()->::cockroach::roachpb::LeaderLeaseRequest::MergeFrom(from.leader_lease());
    }
    if (from.has_reverse_scan()) {
      mutable_reverse_scan()->::cockroach::roachpb::ReverseScanRequest::MergeFrom(from.reverse_scan());
    }
    if (from.has_compute_checksum()) {
      mutable_compute_checksum()->::cockroach::roachpb::ComputeChecksumRequest::MergeFrom(from.compute_checksum());
    }
    if (from.has_verify_checksum()) {
      mutable_verify_checksum()->::cockroach::roachpb::VerifyChecksumRequest::MergeFrom(from.verify_checksum());
    }
    if (from.has_check_consistency()) {
      mutable_check_consistency()->::cockroach::roachpb::CheckConsistencyRequest::MergeFrom(from.check_consistency());
    }
  }
  if (from._has_bits_[24 / 32] & (0xffu << (24 % 32))) {
    if (from.has_noop()) {
      mutable_noop()->::cockroach::roachpb::NoopRequest::MergeFrom(from.noop());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void RequestUnion::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void RequestUnion::CopyFrom(const RequestUnion& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RequestUnion::IsInitialized() const {

  return true;
}

void RequestUnion::Swap(RequestUnion* other) {
  if (other == this) return;
  InternalSwap(other);
}
void RequestUnion::InternalSwap(RequestUnion* other) {
  std::swap(get_, other->get_);
  std::swap(put_, other->put_);
  std::swap(conditional_put_, other->conditional_put_);
  std::swap(increment_, other->increment_);
  std::swap(delete__, other->delete__);
  std::swap(delete_range_, other->delete_range_);
  std::swap(scan_, other->scan_);
  std::swap(begin_transaction_, other->begin_transaction_);
  std::swap(end_transaction_, other->end_transaction_);
  std::swap(admin_split_, other->admin_split_);
  std::swap(admin_merge_, other->admin_merge_);
  std::swap(heartbeat_txn_, other->heartbeat_txn_);
  std::swap(gc_, other->gc_);
  std::swap(push_txn_, other->push_txn_);
  std::swap(range_lookup_, other->range_lookup_);
  std::swap(resolve_intent_, other->resolve_intent_);
  std::swap(resolve_intent_range_, other->resolve_intent_range_);
  std::swap(merge_, other->merge_);
  std::swap(truncate_log_, other->truncate_log_);
  std::swap(leader_lease_, other->leader_lease_);
  std::swap(reverse_scan_, other->reverse_scan_);
  std::swap(compute_checksum_, other->compute_checksum_);
  std::swap(verify_checksum_, other->verify_checksum_);
  std::swap(check_consistency_, other->check_consistency_);
  std::swap(noop_, other->noop_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata RequestUnion::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = RequestUnion_descriptor_;
  metadata.reflection = RequestUnion_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// RequestUnion

// optional .cockroach.roachpb.GetRequest get = 1;
bool RequestUnion::has_get() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void RequestUnion::set_has_get() {
  _has_bits_[0] |= 0x00000001u;
}
void RequestUnion::clear_has_get() {
  _has_bits_[0] &= ~0x00000001u;
}
void RequestUnion::clear_get() {
  if (get_ != NULL) get_->::cockroach::roachpb::GetRequest::Clear();
  clear_has_get();
}
const ::cockroach::roachpb::GetRequest& RequestUnion::get() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.RequestUnion.get)
  return get_ != NULL ? *get_ : *default_instance_->get_;
}
::cockroach::roachpb::GetRequest* RequestUnion::mutable_get() {
  set_has_get();
  if (get_ == NULL) {
    get_ = new ::cockroach::roachpb::GetRequest;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.RequestUnion.get)
  return get_;
}
::cockroach::roachpb::GetRequest* RequestUnion::release_get() {
  clear_has_get();
  ::cockroach::roachpb::GetRequest* temp = get_;
  get_ = NULL;
  return temp;
}
void RequestUnion::set_allocated_get(::cockroach::roachpb::GetRequest* get) {
  delete get_;
  get_ = get;
  if (get) {
    set_has_get();
  } else {
    clear_has_get();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.RequestUnion.get)
}

// optional .cockroach.roachpb.PutRequest put = 2;
bool RequestUnion::has_put() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void RequestUnion::set_has_put() {
  _has_bits_[0] |= 0x00000002u;
}
void RequestUnion::clear_has_put() {
  _has_bits_[0] &= ~0x00000002u;
}
void RequestUnion::clear_put() {
  if (put_ != NULL) put_->::cockroach::roachpb::PutRequest::Clear();
  clear_has_put();
}
const ::cockroach::roachpb::PutRequest& RequestUnion::put() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.RequestUnion.put)
  return put_ != NULL ? *put_ : *default_instance_->put_;
}
::cockroach::roachpb::PutRequest* RequestUnion::mutable_put() {
  set_has_put();
  if (put_ == NULL) {
    put_ = new ::cockroach::roachpb::PutRequest;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.RequestUnion.put)
  return put_;
}
::cockroach::roachpb::PutRequest* RequestUnion::release_put() {
  clear_has_put();
  ::cockroach::roachpb::PutRequest* temp = put_;
  put_ = NULL;
  return temp;
}
void RequestUnion::set_allocated_put(::cockroach::roachpb::PutRequest* put) {
  delete put_;
  put_ = put;
  if (put) {
    set_has_put();
  } else {
    clear_has_put();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.RequestUnion.put)
}

// optional .cockroach.roachpb.ConditionalPutRequest conditional_put = 3;
bool RequestUnion::has_conditional_put() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void RequestUnion::set_has_conditional_put() {
  _has_bits_[0] |= 0x00000004u;
}
void RequestUnion::clear_has_conditional_put() {
  _has_bits_[0] &= ~0x00000004u;
}
void RequestUnion::clear_conditional_put() {
  if (conditional_put_ != NULL) conditional_put_->::cockroach::roachpb::ConditionalPutRequest::Clear();
  clear_has_conditional_put();
}
const ::cockroach::roachpb::ConditionalPutRequest& RequestUnion::conditional_put() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.RequestUnion.conditional_put)
  return conditional_put_ != NULL ? *conditional_put_ : *default_instance_->conditional_put_;
}
::cockroach::roachpb::ConditionalPutRequest* RequestUnion::mutable_conditional_put() {
  set_has_conditional_put();
  if (conditional_put_ == NULL) {
    conditional_put_ = new ::cockroach::roachpb::ConditionalPutRequest;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.RequestUnion.conditional_put)
  return conditional_put_;
}
::cockroach::roachpb::ConditionalPutRequest* RequestUnion::release_conditional_put() {
  clear_has_conditional_put();
  ::cockroach::roachpb::ConditionalPutRequest* temp = conditional_put_;
  conditional_put_ = NULL;
  return temp;
}
void RequestUnion::set_allocated_conditional_put(::cockroach::roachpb::ConditionalPutRequest* conditional_put) {
  delete conditional_put_;
  conditional_put_ = conditional_put;
  if (conditional_put) {
    set_has_conditional_put();
  } else {
    clear_has_conditional_put();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.RequestUnion.conditional_put)
}

// optional .cockroach.roachpb.IncrementRequest increment = 4;
bool RequestUnion::has_increment() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void RequestUnion::set_has_increment() {
  _has_bits_[0] |= 0x00000008u;
}
void RequestUnion::clear_has_increment() {
  _has_bits_[0] &= ~0x00000008u;
}
void RequestUnion::clear_increment() {
  if (increment_ != NULL) increment_->::cockroach::roachpb::IncrementRequest::Clear();
  clear_has_increment();
}
const ::cockroach::roachpb::IncrementRequest& RequestUnion::increment() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.RequestUnion.increment)
  return increment_ != NULL ? *increment_ : *default_instance_->increment_;
}
::cockroach::roachpb::IncrementRequest* RequestUnion::mutable_increment() {
  set_has_increment();
  if (increment_ == NULL) {
    increment_ = new ::cockroach::roachpb::IncrementRequest;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.RequestUnion.increment)
  return increment_;
}
::cockroach::roachpb::IncrementRequest* RequestUnion::release_increment() {
  clear_has_increment();
  ::cockroach::roachpb::IncrementRequest* temp = increment_;
  increment_ = NULL;
  return temp;
}
void RequestUnion::set_allocated_increment(::cockroach::roachpb::IncrementRequest* increment) {
  delete increment_;
  increment_ = increment;
  if (increment) {
    set_has_increment();
  } else {
    clear_has_increment();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.RequestUnion.increment)
}

// optional .cockroach.roachpb.DeleteRequest delete = 5;
bool RequestUnion::has_delete_() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
void RequestUnion::set_has_delete_() {
  _has_bits_[0] |= 0x00000010u;
}
void RequestUnion::clear_has_delete_() {
  _has_bits_[0] &= ~0x00000010u;
}
void RequestUnion::clear_delete_() {
  if (delete__ != NULL) delete__->::cockroach::roachpb::DeleteRequest::Clear();
  clear_has_delete_();
}
const ::cockroach::roachpb::DeleteRequest& RequestUnion::delete_() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.RequestUnion.delete)
  return delete__ != NULL ? *delete__ : *default_instance_->delete__;
}
::cockroach::roachpb::DeleteRequest* RequestUnion::mutable_delete_() {
  set_has_delete_();
  if (delete__ == NULL) {
    delete__ = new ::cockroach::roachpb::DeleteRequest;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.RequestUnion.delete)
  return delete__;
}
::cockroach::roachpb::DeleteRequest* RequestUnion::release_delete_() {
  clear_has_delete_();
  ::cockroach::roachpb::DeleteRequest* temp = delete__;
  delete__ = NULL;
  return temp;
}
void RequestUnion::set_allocated_delete_(::cockroach::roachpb::DeleteRequest* delete_) {
  delete delete__;
  delete__ = delete_;
  if (delete_) {
    set_has_delete_();
  } else {
    clear_has_delete_();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.RequestUnion.delete)
}

// optional .cockroach.roachpb.DeleteRangeRequest delete_range = 6;
bool RequestUnion::has_delete_range() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
void RequestUnion::set_has_delete_range() {
  _has_bits_[0] |= 0x00000020u;
}
void RequestUnion::clear_has_delete_range() {
  _has_bits_[0] &= ~0x00000020u;
}
void RequestUnion::clear_delete_range() {
  if (delete_range_ != NULL) delete_range_->::cockroach::roachpb::DeleteRangeRequest::Clear();
  clear_has_delete_range();
}
const ::cockroach::roachpb::DeleteRangeRequest& RequestUnion::delete_range() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.RequestUnion.delete_range)
  return delete_range_ != NULL ? *delete_range_ : *default_instance_->delete_range_;
}
::cockroach::roachpb::DeleteRangeRequest* RequestUnion::mutable_delete_range() {
  set_has_delete_range();
  if (delete_range_ == NULL) {
    delete_range_ = new ::cockroach::roachpb::DeleteRangeRequest;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.RequestUnion.delete_range)
  return delete_range_;
}
::cockroach::roachpb::DeleteRangeRequest* RequestUnion::release_delete_range() {
  clear_has_delete_range();
  ::cockroach::roachpb::DeleteRangeRequest* temp = delete_range_;
  delete_range_ = NULL;
  return temp;
}
void RequestUnion::set_allocated_delete_range(::cockroach::roachpb::DeleteRangeRequest* delete_range) {
  delete delete_range_;
  delete_range_ = delete_range;
  if (delete_range) {
    set_has_delete_range();
  } else {
    clear_has_delete_range();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.RequestUnion.delete_range)
}

// optional .cockroach.roachpb.ScanRequest scan = 7;
bool RequestUnion::has_scan() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
void RequestUnion::set_has_scan() {
  _has_bits_[0] |= 0x00000040u;
}
void RequestUnion::clear_has_scan() {
  _has_bits_[0] &= ~0x00000040u;
}
void RequestUnion::clear_scan() {
  if (scan_ != NULL) scan_->::cockroach::roachpb::ScanRequest::Clear();
  clear_has_scan();
}
const ::cockroach::roachpb::ScanRequest& RequestUnion::scan() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.RequestUnion.scan)
  return scan_ != NULL ? *scan_ : *default_instance_->scan_;
}
::cockroach::roachpb::ScanRequest* RequestUnion::mutable_scan() {
  set_has_scan();
  if (scan_ == NULL) {
    scan_ = new ::cockroach::roachpb::ScanRequest;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.RequestUnion.scan)
  return scan_;
}
::cockroach::roachpb::ScanRequest* RequestUnion::release_scan() {
  clear_has_scan();
  ::cockroach::roachpb::ScanRequest* temp = scan_;
  scan_ = NULL;
  return temp;
}
void RequestUnion::set_allocated_scan(::cockroach::roachpb::ScanRequest* scan) {
  delete scan_;
  scan_ = scan;
  if (scan) {
    set_has_scan();
  } else {
    clear_has_scan();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.RequestUnion.scan)
}

// optional .cockroach.roachpb.BeginTransactionRequest begin_transaction = 8;
bool RequestUnion::has_begin_transaction() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
void RequestUnion::set_has_begin_transaction() {
  _has_bits_[0] |= 0x00000080u;
}
void RequestUnion::clear_has_begin_transaction() {
  _has_bits_[0] &= ~0x00000080u;
}
void RequestUnion::clear_begin_transaction() {
  if (begin_transaction_ != NULL) begin_transaction_->::cockroach::roachpb::BeginTransactionRequest::Clear();
  clear_has_begin_transaction();
}
const ::cockroach::roachpb::BeginTransactionRequest& RequestUnion::begin_transaction() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.RequestUnion.begin_transaction)
  return begin_transaction_ != NULL ? *begin_transaction_ : *default_instance_->begin_transaction_;
}
::cockroach::roachpb::BeginTransactionRequest* RequestUnion::mutable_begin_transaction() {
  set_has_begin_transaction();
  if (begin_transaction_ == NULL) {
    begin_transaction_ = new ::cockroach::roachpb::BeginTransactionRequest;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.RequestUnion.begin_transaction)
  return begin_transaction_;
}
::cockroach::roachpb::BeginTransactionRequest* RequestUnion::release_begin_transaction() {
  clear_has_begin_transaction();
  ::cockroach::roachpb::BeginTransactionRequest* temp = begin_transaction_;
  begin_transaction_ = NULL;
  return temp;
}
void RequestUnion::set_allocated_begin_transaction(::cockroach::roachpb::BeginTransactionRequest* begin_transaction) {
  delete begin_transaction_;
  begin_transaction_ = begin_transaction;
  if (begin_transaction) {
    set_has_begin_transaction();
  } else {
    clear_has_begin_transaction();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.RequestUnion.begin_transaction)
}

// optional .cockroach.roachpb.EndTransactionRequest end_transaction = 9;
bool RequestUnion::has_end_transaction() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
void RequestUnion::set_has_end_transaction() {
  _has_bits_[0] |= 0x00000100u;
}
void RequestUnion::clear_has_end_transaction() {
  _has_bits_[0] &= ~0x00000100u;
}
void RequestUnion::clear_end_transaction() {
  if (end_transaction_ != NULL) end_transaction_->::cockroach::roachpb::EndTransactionRequest::Clear();
  clear_has_end_transaction();
}
const ::cockroach::roachpb::EndTransactionRequest& RequestUnion::end_transaction() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.RequestUnion.end_transaction)
  return end_transaction_ != NULL ? *end_transaction_ : *default_instance_->end_transaction_;
}
::cockroach::roachpb::EndTransactionRequest* RequestUnion::mutable_end_transaction() {
  set_has_end_transaction();
  if (end_transaction_ == NULL) {
    end_transaction_ = new ::cockroach::roachpb::EndTransactionRequest;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.RequestUnion.end_transaction)
  return end_transaction_;
}
::cockroach::roachpb::EndTransactionRequest* RequestUnion::release_end_transaction() {
  clear_has_end_transaction();
  ::cockroach::roachpb::EndTransactionRequest* temp = end_transaction_;
  end_transaction_ = NULL;
  return temp;
}
void RequestUnion::set_allocated_end_transaction(::cockroach::roachpb::EndTransactionRequest* end_transaction) {
  delete end_transaction_;
  end_transaction_ = end_transaction;
  if (end_transaction) {
    set_has_end_transaction();
  } else {
    clear_has_end_transaction();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.RequestUnion.end_transaction)
}

// optional .cockroach.roachpb.AdminSplitRequest admin_split = 10;
bool RequestUnion::has_admin_split() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
void RequestUnion::set_has_admin_split() {
  _has_bits_[0] |= 0x00000200u;
}
void RequestUnion::clear_has_admin_split() {
  _has_bits_[0] &= ~0x00000200u;
}
void RequestUnion::clear_admin_split() {
  if (admin_split_ != NULL) admin_split_->::cockroach::roachpb::AdminSplitRequest::Clear();
  clear_has_admin_split();
}
const ::cockroach::roachpb::AdminSplitRequest& RequestUnion::admin_split() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.RequestUnion.admin_split)
  return admin_split_ != NULL ? *admin_split_ : *default_instance_->admin_split_;
}
::cockroach::roachpb::AdminSplitRequest* RequestUnion::mutable_admin_split() {
  set_has_admin_split();
  if (admin_split_ == NULL) {
    admin_split_ = new ::cockroach::roachpb::AdminSplitRequest;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.RequestUnion.admin_split)
  return admin_split_;
}
::cockroach::roachpb::AdminSplitRequest* RequestUnion::release_admin_split() {
  clear_has_admin_split();
  ::cockroach::roachpb::AdminSplitRequest* temp = admin_split_;
  admin_split_ = NULL;
  return temp;
}
void RequestUnion::set_allocated_admin_split(::cockroach::roachpb::AdminSplitRequest* admin_split) {
  delete admin_split_;
  admin_split_ = admin_split;
  if (admin_split) {
    set_has_admin_split();
  } else {
    clear_has_admin_split();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.RequestUnion.admin_split)
}

// optional .cockroach.roachpb.AdminMergeRequest admin_merge = 11;
bool RequestUnion::has_admin_merge() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
void RequestUnion::set_has_admin_merge() {
  _has_bits_[0] |= 0x00000400u;
}
void RequestUnion::clear_has_admin_merge() {
  _has_bits_[0] &= ~0x00000400u;
}
void RequestUnion::clear_admin_merge() {
  if (admin_merge_ != NULL) admin_merge_->::cockroach::roachpb::AdminMergeRequest::Clear();
  clear_has_admin_merge();
}
const ::cockroach::roachpb::AdminMergeRequest& RequestUnion::admin_merge() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.RequestUnion.admin_merge)
  return admin_merge_ != NULL ? *admin_merge_ : *default_instance_->admin_merge_;
}
::cockroach::roachpb::AdminMergeRequest* RequestUnion::mutable_admin_merge() {
  set_has_admin_merge();
  if (admin_merge_ == NULL) {
    admin_merge_ = new ::cockroach::roachpb::AdminMergeRequest;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.RequestUnion.admin_merge)
  return admin_merge_;
}
::cockroach::roachpb::AdminMergeRequest* RequestUnion::release_admin_merge() {
  clear_has_admin_merge();
  ::cockroach::roachpb::AdminMergeRequest* temp = admin_merge_;
  admin_merge_ = NULL;
  return temp;
}
void RequestUnion::set_allocated_admin_merge(::cockroach::roachpb::AdminMergeRequest* admin_merge) {
  delete admin_merge_;
  admin_merge_ = admin_merge;
  if (admin_merge) {
    set_has_admin_merge();
  } else {
    clear_has_admin_merge();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.RequestUnion.admin_merge)
}

// optional .cockroach.roachpb.HeartbeatTxnRequest heartbeat_txn = 12;
bool RequestUnion::has_heartbeat_txn() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
void RequestUnion::set_has_heartbeat_txn() {
  _has_bits_[0] |= 0x00000800u;
}
void RequestUnion::clear_has_heartbeat_txn() {
  _has_bits_[0] &= ~0x00000800u;
}
void RequestUnion::clear_heartbeat_txn() {
  if (heartbeat_txn_ != NULL) heartbeat_txn_->::cockroach::roachpb::HeartbeatTxnRequest::Clear();
  clear_has_heartbeat_txn();
}
const ::cockroach::roachpb::HeartbeatTxnRequest& RequestUnion::heartbeat_txn() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.RequestUnion.heartbeat_txn)
  return heartbeat_txn_ != NULL ? *heartbeat_txn_ : *default_instance_->heartbeat_txn_;
}
::cockroach::roachpb::HeartbeatTxnRequest* RequestUnion::mutable_heartbeat_txn() {
  set_has_heartbeat_txn();
  if (heartbeat_txn_ == NULL) {
    heartbeat_txn_ = new ::cockroach::roachpb::HeartbeatTxnRequest;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.RequestUnion.heartbeat_txn)
  return heartbeat_txn_;
}
::cockroach::roachpb::HeartbeatTxnRequest* RequestUnion::release_heartbeat_txn() {
  clear_has_heartbeat_txn();
  ::cockroach::roachpb::HeartbeatTxnRequest* temp = heartbeat_txn_;
  heartbeat_txn_ = NULL;
  return temp;
}
void RequestUnion::set_allocated_heartbeat_txn(::cockroach::roachpb::HeartbeatTxnRequest* heartbeat_txn) {
  delete heartbeat_txn_;
  heartbeat_txn_ = heartbeat_txn;
  if (heartbeat_txn) {
    set_has_heartbeat_txn();
  } else {
    clear_has_heartbeat_txn();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.RequestUnion.heartbeat_txn)
}

// optional .cockroach.roachpb.GCRequest gc = 13;
bool RequestUnion::has_gc() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
void RequestUnion::set_has_gc() {
  _has_bits_[0] |= 0x00001000u;
}
void RequestUnion::clear_has_gc() {
  _has_bits_[0] &= ~0x00001000u;
}
void RequestUnion::clear_gc() {
  if (gc_ != NULL) gc_->::cockroach::roachpb::GCRequest::Clear();
  clear_has_gc();
}
const ::cockroach::roachpb::GCRequest& RequestUnion::gc() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.RequestUnion.gc)
  return gc_ != NULL ? *gc_ : *default_instance_->gc_;
}
::cockroach::roachpb::GCRequest* RequestUnion::mutable_gc() {
  set_has_gc();
  if (gc_ == NULL) {
    gc_ = new ::cockroach::roachpb::GCRequest;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.RequestUnion.gc)
  return gc_;
}
::cockroach::roachpb::GCRequest* RequestUnion::release_gc() {
  clear_has_gc();
  ::cockroach::roachpb::GCRequest* temp = gc_;
  gc_ = NULL;
  return temp;
}
void RequestUnion::set_allocated_gc(::cockroach::roachpb::GCRequest* gc) {
  delete gc_;
  gc_ = gc;
  if (gc) {
    set_has_gc();
  } else {
    clear_has_gc();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.RequestUnion.gc)
}

// optional .cockroach.roachpb.PushTxnRequest push_txn = 14;
bool RequestUnion::has_push_txn() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
void RequestUnion::set_has_push_txn() {
  _has_bits_[0] |= 0x00002000u;
}
void RequestUnion::clear_has_push_txn() {
  _has_bits_[0] &= ~0x00002000u;
}
void RequestUnion::clear_push_txn() {
  if (push_txn_ != NULL) push_txn_->::cockroach::roachpb::PushTxnRequest::Clear();
  clear_has_push_txn();
}
const ::cockroach::roachpb::PushTxnRequest& RequestUnion::push_txn() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.RequestUnion.push_txn)
  return push_txn_ != NULL ? *push_txn_ : *default_instance_->push_txn_;
}
::cockroach::roachpb::PushTxnRequest* RequestUnion::mutable_push_txn() {
  set_has_push_txn();
  if (push_txn_ == NULL) {
    push_txn_ = new ::cockroach::roachpb::PushTxnRequest;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.RequestUnion.push_txn)
  return push_txn_;
}
::cockroach::roachpb::PushTxnRequest* RequestUnion::release_push_txn() {
  clear_has_push_txn();
  ::cockroach::roachpb::PushTxnRequest* temp = push_txn_;
  push_txn_ = NULL;
  return temp;
}
void RequestUnion::set_allocated_push_txn(::cockroach::roachpb::PushTxnRequest* push_txn) {
  delete push_txn_;
  push_txn_ = push_txn;
  if (push_txn) {
    set_has_push_txn();
  } else {
    clear_has_push_txn();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.RequestUnion.push_txn)
}

// optional .cockroach.roachpb.RangeLookupRequest range_lookup = 15;
bool RequestUnion::has_range_lookup() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
void RequestUnion::set_has_range_lookup() {
  _has_bits_[0] |= 0x00004000u;
}
void RequestUnion::clear_has_range_lookup() {
  _has_bits_[0] &= ~0x00004000u;
}
void RequestUnion::clear_range_lookup() {
  if (range_lookup_ != NULL) range_lookup_->::cockroach::roachpb::RangeLookupRequest::Clear();
  clear_has_range_lookup();
}
const ::cockroach::roachpb::RangeLookupRequest& RequestUnion::range_lookup() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.RequestUnion.range_lookup)
  return range_lookup_ != NULL ? *range_lookup_ : *default_instance_->range_lookup_;
}
::cockroach::roachpb::RangeLookupRequest* RequestUnion::mutable_range_lookup() {
  set_has_range_lookup();
  if (range_lookup_ == NULL) {
    range_lookup_ = new ::cockroach::roachpb::RangeLookupRequest;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.RequestUnion.range_lookup)
  return range_lookup_;
}
::cockroach::roachpb::RangeLookupRequest* RequestUnion::release_range_lookup() {
  clear_has_range_lookup();
  ::cockroach::roachpb::RangeLookupRequest* temp = range_lookup_;
  range_lookup_ = NULL;
  return temp;
}
void RequestUnion::set_allocated_range_lookup(::cockroach::roachpb::RangeLookupRequest* range_lookup) {
  delete range_lookup_;
  range_lookup_ = range_lookup;
  if (range_lookup) {
    set_has_range_lookup();
  } else {
    clear_has_range_lookup();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.RequestUnion.range_lookup)
}

// optional .cockroach.roachpb.ResolveIntentRequest resolve_intent = 16;
bool RequestUnion::has_resolve_intent() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
void RequestUnion::set_has_resolve_intent() {
  _has_bits_[0] |= 0x00008000u;
}
void RequestUnion::clear_has_resolve_intent() {
  _has_bits_[0] &= ~0x00008000u;
}
void RequestUnion::clear_resolve_intent() {
  if (resolve_intent_ != NULL) resolve_intent_->::cockroach::roachpb::ResolveIntentRequest::Clear();
  clear_has_resolve_intent();
}
const ::cockroach::roachpb::ResolveIntentRequest& RequestUnion::resolve_intent() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.RequestUnion.resolve_intent)
  return resolve_intent_ != NULL ? *resolve_intent_ : *default_instance_->resolve_intent_;
}
::cockroach::roachpb::ResolveIntentRequest* RequestUnion::mutable_resolve_intent() {
  set_has_resolve_intent();
  if (resolve_intent_ == NULL) {
    resolve_intent_ = new ::cockroach::roachpb::ResolveIntentRequest;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.RequestUnion.resolve_intent)
  return resolve_intent_;
}
::cockroach::roachpb::ResolveIntentRequest* RequestUnion::release_resolve_intent() {
  clear_has_resolve_intent();
  ::cockroach::roachpb::ResolveIntentRequest* temp = resolve_intent_;
  resolve_intent_ = NULL;
  return temp;
}
void RequestUnion::set_allocated_resolve_intent(::cockroach::roachpb::ResolveIntentRequest* resolve_intent) {
  delete resolve_intent_;
  resolve_intent_ = resolve_intent;
  if (resolve_intent) {
    set_has_resolve_intent();
  } else {
    clear_has_resolve_intent();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.RequestUnion.resolve_intent)
}

// optional .cockroach.roachpb.ResolveIntentRangeRequest resolve_intent_range = 17;
bool RequestUnion::has_resolve_intent_range() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
void RequestUnion::set_has_resolve_intent_range() {
  _has_bits_[0] |= 0x00010000u;
}
void RequestUnion::clear_has_resolve_intent_range() {
  _has_bits_[0] &= ~0x00010000u;
}
void RequestUnion::clear_resolve_intent_range() {
  if (resolve_intent_range_ != NULL) resolve_intent_range_->::cockroach::roachpb::ResolveIntentRangeRequest::Clear();
  clear_has_resolve_intent_range();
}
const ::cockroach::roachpb::ResolveIntentRangeRequest& RequestUnion::resolve_intent_range() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.RequestUnion.resolve_intent_range)
  return resolve_intent_range_ != NULL ? *resolve_intent_range_ : *default_instance_->resolve_intent_range_;
}
::cockroach::roachpb::ResolveIntentRangeRequest* RequestUnion::mutable_resolve_intent_range() {
  set_has_resolve_intent_range();
  if (resolve_intent_range_ == NULL) {
    resolve_intent_range_ = new ::cockroach::roachpb::ResolveIntentRangeRequest;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.RequestUnion.resolve_intent_range)
  return resolve_intent_range_;
}
::cockroach::roachpb::ResolveIntentRangeRequest* RequestUnion::release_resolve_intent_range() {
  clear_has_resolve_intent_range();
  ::cockroach::roachpb::ResolveIntentRangeRequest* temp = resolve_intent_range_;
  resolve_intent_range_ = NULL;
  return temp;
}
void RequestUnion::set_allocated_resolve_intent_range(::cockroach::roachpb::ResolveIntentRangeRequest* resolve_intent_range) {
  delete resolve_intent_range_;
  resolve_intent_range_ = resolve_intent_range;
  if (resolve_intent_range) {
    set_has_resolve_intent_range();
  } else {
    clear_has_resolve_intent_range();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.RequestUnion.resolve_intent_range)
}

// optional .cockroach.roachpb.MergeRequest merge = 18;
bool RequestUnion::has_merge() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
void RequestUnion::set_has_merge() {
  _has_bits_[0] |= 0x00020000u;
}
void RequestUnion::clear_has_merge() {
  _has_bits_[0] &= ~0x00020000u;
}
void RequestUnion::clear_merge() {
  if (merge_ != NULL) merge_->::cockroach::roachpb::MergeRequest::Clear();
  clear_has_merge();
}
const ::cockroach::roachpb::MergeRequest& RequestUnion::merge() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.RequestUnion.merge)
  return merge_ != NULL ? *merge_ : *default_instance_->merge_;
}
::cockroach::roachpb::MergeRequest* RequestUnion::mutable_merge() {
  set_has_merge();
  if (merge_ == NULL) {
    merge_ = new ::cockroach::roachpb::MergeRequest;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.RequestUnion.merge)
  return merge_;
}
::cockroach::roachpb::MergeRequest* RequestUnion::release_merge() {
  clear_has_merge();
  ::cockroach::roachpb::MergeRequest* temp = merge_;
  merge_ = NULL;
  return temp;
}
void RequestUnion::set_allocated_merge(::cockroach::roachpb::MergeRequest* merge) {
  delete merge_;
  merge_ = merge;
  if (merge) {
    set_has_merge();
  } else {
    clear_has_merge();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.RequestUnion.merge)
}

// optional .cockroach.roachpb.TruncateLogRequest truncate_log = 19;
bool RequestUnion::has_truncate_log() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
void RequestUnion::set_has_truncate_log() {
  _has_bits_[0] |= 0x00040000u;
}
void RequestUnion::clear_has_truncate_log() {
  _has_bits_[0] &= ~0x00040000u;
}
void RequestUnion::clear_truncate_log() {
  if (truncate_log_ != NULL) truncate_log_->::cockroach::roachpb::TruncateLogRequest::Clear();
  clear_has_truncate_log();
}
const ::cockroach::roachpb::TruncateLogRequest& RequestUnion::truncate_log() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.RequestUnion.truncate_log)
  return truncate_log_ != NULL ? *truncate_log_ : *default_instance_->truncate_log_;
}
::cockroach::roachpb::TruncateLogRequest* RequestUnion::mutable_truncate_log() {
  set_has_truncate_log();
  if (truncate_log_ == NULL) {
    truncate_log_ = new ::cockroach::roachpb::TruncateLogRequest;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.RequestUnion.truncate_log)
  return truncate_log_;
}
::cockroach::roachpb::TruncateLogRequest* RequestUnion::release_truncate_log() {
  clear_has_truncate_log();
  ::cockroach::roachpb::TruncateLogRequest* temp = truncate_log_;
  truncate_log_ = NULL;
  return temp;
}
void RequestUnion::set_allocated_truncate_log(::cockroach::roachpb::TruncateLogRequest* truncate_log) {
  delete truncate_log_;
  truncate_log_ = truncate_log;
  if (truncate_log) {
    set_has_truncate_log();
  } else {
    clear_has_truncate_log();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.RequestUnion.truncate_log)
}

// optional .cockroach.roachpb.LeaderLeaseRequest leader_lease = 20;
bool RequestUnion::has_leader_lease() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
void RequestUnion::set_has_leader_lease() {
  _has_bits_[0] |= 0x00080000u;
}
void RequestUnion::clear_has_leader_lease() {
  _has_bits_[0] &= ~0x00080000u;
}
void RequestUnion::clear_leader_lease() {
  if (leader_lease_ != NULL) leader_lease_->::cockroach::roachpb::LeaderLeaseRequest::Clear();
  clear_has_leader_lease();
}
const ::cockroach::roachpb::LeaderLeaseRequest& RequestUnion::leader_lease() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.RequestUnion.leader_lease)
  return leader_lease_ != NULL ? *leader_lease_ : *default_instance_->leader_lease_;
}
::cockroach::roachpb::LeaderLeaseRequest* RequestUnion::mutable_leader_lease() {
  set_has_leader_lease();
  if (leader_lease_ == NULL) {
    leader_lease_ = new ::cockroach::roachpb::LeaderLeaseRequest;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.RequestUnion.leader_lease)
  return leader_lease_;
}
::cockroach::roachpb::LeaderLeaseRequest* RequestUnion::release_leader_lease() {
  clear_has_leader_lease();
  ::cockroach::roachpb::LeaderLeaseRequest* temp = leader_lease_;
  leader_lease_ = NULL;
  return temp;
}
void RequestUnion::set_allocated_leader_lease(::cockroach::roachpb::LeaderLeaseRequest* leader_lease) {
  delete leader_lease_;
  leader_lease_ = leader_lease;
  if (leader_lease) {
    set_has_leader_lease();
  } else {
    clear_has_leader_lease();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.RequestUnion.leader_lease)
}

// optional .cockroach.roachpb.ReverseScanRequest reverse_scan = 21;
bool RequestUnion::has_reverse_scan() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
void RequestUnion::set_has_reverse_scan() {
  _has_bits_[0] |= 0x00100000u;
}
void RequestUnion::clear_has_reverse_scan() {
  _has_bits_[0] &= ~0x00100000u;
}
void RequestUnion::clear_reverse_scan() {
  if (reverse_scan_ != NULL) reverse_scan_->::cockroach::roachpb::ReverseScanRequest::Clear();
  clear_has_reverse_scan();
}
const ::cockroach::roachpb::ReverseScanRequest& RequestUnion::reverse_scan() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.RequestUnion.reverse_scan)
  return reverse_scan_ != NULL ? *reverse_scan_ : *default_instance_->reverse_scan_;
}
::cockroach::roachpb::ReverseScanRequest* RequestUnion::mutable_reverse_scan() {
  set_has_reverse_scan();
  if (reverse_scan_ == NULL) {
    reverse_scan_ = new ::cockroach::roachpb::ReverseScanRequest;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.RequestUnion.reverse_scan)
  return reverse_scan_;
}
::cockroach::roachpb::ReverseScanRequest* RequestUnion::release_reverse_scan() {
  clear_has_reverse_scan();
  ::cockroach::roachpb::ReverseScanRequest* temp = reverse_scan_;
  reverse_scan_ = NULL;
  return temp;
}
void RequestUnion::set_allocated_reverse_scan(::cockroach::roachpb::ReverseScanRequest* reverse_scan) {
  delete reverse_scan_;
  reverse_scan_ = reverse_scan;
  if (reverse_scan) {
    set_has_reverse_scan();
  } else {
    clear_has_reverse_scan();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.RequestUnion.reverse_scan)
}

// optional .cockroach.roachpb.ComputeChecksumRequest compute_checksum = 22;
bool RequestUnion::has_compute_checksum() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
void RequestUnion::set_has_compute_checksum() {
  _has_bits_[0] |= 0x00200000u;
}
void RequestUnion::clear_has_compute_checksum() {
  _has_bits_[0] &= ~0x00200000u;
}
void RequestUnion::clear_compute_checksum() {
  if (compute_checksum_ != NULL) compute_checksum_->::cockroach::roachpb::ComputeChecksumRequest::Clear();
  clear_has_compute_checksum();
}
const ::cockroach::roachpb::ComputeChecksumRequest& RequestUnion::compute_checksum() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.RequestUnion.compute_checksum)
  return compute_checksum_ != NULL ? *compute_checksum_ : *default_instance_->compute_checksum_;
}
::cockroach::roachpb::ComputeChecksumRequest* RequestUnion::mutable_compute_checksum() {
  set_has_compute_checksum();
  if (compute_checksum_ == NULL) {
    compute_checksum_ = new ::cockroach::roachpb::ComputeChecksumRequest;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.RequestUnion.compute_checksum)
  return compute_checksum_;
}
::cockroach::roachpb::ComputeChecksumRequest* RequestUnion::release_compute_checksum() {
  clear_has_compute_checksum();
  ::cockroach::roachpb::ComputeChecksumRequest* temp = compute_checksum_;
  compute_checksum_ = NULL;
  return temp;
}
void RequestUnion::set_allocated_compute_checksum(::cockroach::roachpb::ComputeChecksumRequest* compute_checksum) {
  delete compute_checksum_;
  compute_checksum_ = compute_checksum;
  if (compute_checksum) {
    set_has_compute_checksum();
  } else {
    clear_has_compute_checksum();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.RequestUnion.compute_checksum)
}

// optional .cockroach.roachpb.VerifyChecksumRequest verify_checksum = 23;
bool RequestUnion::has_verify_checksum() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
void RequestUnion::set_has_verify_checksum() {
  _has_bits_[0] |= 0x00400000u;
}
void RequestUnion::clear_has_verify_checksum() {
  _has_bits_[0] &= ~0x00400000u;
}
void RequestUnion::clear_verify_checksum() {
  if (verify_checksum_ != NULL) verify_checksum_->::cockroach::roachpb::VerifyChecksumRequest::Clear();
  clear_has_verify_checksum();
}
const ::cockroach::roachpb::VerifyChecksumRequest& RequestUnion::verify_checksum() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.RequestUnion.verify_checksum)
  return verify_checksum_ != NULL ? *verify_checksum_ : *default_instance_->verify_checksum_;
}
::cockroach::roachpb::VerifyChecksumRequest* RequestUnion::mutable_verify_checksum() {
  set_has_verify_checksum();
  if (verify_checksum_ == NULL) {
    verify_checksum_ = new ::cockroach::roachpb::VerifyChecksumRequest;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.RequestUnion.verify_checksum)
  return verify_checksum_;
}
::cockroach::roachpb::VerifyChecksumRequest* RequestUnion::release_verify_checksum() {
  clear_has_verify_checksum();
  ::cockroach::roachpb::VerifyChecksumRequest* temp = verify_checksum_;
  verify_checksum_ = NULL;
  return temp;
}
void RequestUnion::set_allocated_verify_checksum(::cockroach::roachpb::VerifyChecksumRequest* verify_checksum) {
  delete verify_checksum_;
  verify_checksum_ = verify_checksum;
  if (verify_checksum) {
    set_has_verify_checksum();
  } else {
    clear_has_verify_checksum();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.RequestUnion.verify_checksum)
}

// optional .cockroach.roachpb.CheckConsistencyRequest check_consistency = 24;
bool RequestUnion::has_check_consistency() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
void RequestUnion::set_has_check_consistency() {
  _has_bits_[0] |= 0x00800000u;
}
void RequestUnion::clear_has_check_consistency() {
  _has_bits_[0] &= ~0x00800000u;
}
void RequestUnion::clear_check_consistency() {
  if (check_consistency_ != NULL) check_consistency_->::cockroach::roachpb::CheckConsistencyRequest::Clear();
  clear_has_check_consistency();
}
const ::cockroach::roachpb::CheckConsistencyRequest& RequestUnion::check_consistency() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.RequestUnion.check_consistency)
  return check_consistency_ != NULL ? *check_consistency_ : *default_instance_->check_consistency_;
}
::cockroach::roachpb::CheckConsistencyRequest* RequestUnion::mutable_check_consistency() {
  set_has_check_consistency();
  if (check_consistency_ == NULL) {
    check_consistency_ = new ::cockroach::roachpb::CheckConsistencyRequest;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.RequestUnion.check_consistency)
  return check_consistency_;
}
::cockroach::roachpb::CheckConsistencyRequest* RequestUnion::release_check_consistency() {
  clear_has_check_consistency();
  ::cockroach::roachpb::CheckConsistencyRequest* temp = check_consistency_;
  check_consistency_ = NULL;
  return temp;
}
void RequestUnion::set_allocated_check_consistency(::cockroach::roachpb::CheckConsistencyRequest* check_consistency) {
  delete check_consistency_;
  check_consistency_ = check_consistency;
  if (check_consistency) {
    set_has_check_consistency();
  } else {
    clear_has_check_consistency();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.RequestUnion.check_consistency)
}

// optional .cockroach.roachpb.NoopRequest noop = 25;
bool RequestUnion::has_noop() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
void RequestUnion::set_has_noop() {
  _has_bits_[0] |= 0x01000000u;
}
void RequestUnion::clear_has_noop() {
  _has_bits_[0] &= ~0x01000000u;
}
void RequestUnion::clear_noop() {
  if (noop_ != NULL) noop_->::cockroach::roachpb::NoopRequest::Clear();
  clear_has_noop();
}
const ::cockroach::roachpb::NoopRequest& RequestUnion::noop() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.RequestUnion.noop)
  return noop_ != NULL ? *noop_ : *default_instance_->noop_;
}
::cockroach::roachpb::NoopRequest* RequestUnion::mutable_noop() {
  set_has_noop();
  if (noop_ == NULL) {
    noop_ = new ::cockroach::roachpb::NoopRequest;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.RequestUnion.noop)
  return noop_;
}
::cockroach::roachpb::NoopRequest* RequestUnion::release_noop() {
  clear_has_noop();
  ::cockroach::roachpb::NoopRequest* temp = noop_;
  noop_ = NULL;
  return temp;
}
void RequestUnion::set_allocated_noop(::cockroach::roachpb::NoopRequest* noop) {
  delete noop_;
  noop_ = noop;
  if (noop) {
    set_has_noop();
  } else {
    clear_has_noop();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.RequestUnion.noop)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int ResponseUnion::kGetFieldNumber;
const int ResponseUnion::kPutFieldNumber;
const int ResponseUnion::kConditionalPutFieldNumber;
const int ResponseUnion::kIncrementFieldNumber;
const int ResponseUnion::kDeleteFieldNumber;
const int ResponseUnion::kDeleteRangeFieldNumber;
const int ResponseUnion::kScanFieldNumber;
const int ResponseUnion::kBeginTransactionFieldNumber;
const int ResponseUnion::kEndTransactionFieldNumber;
const int ResponseUnion::kAdminSplitFieldNumber;
const int ResponseUnion::kAdminMergeFieldNumber;
const int ResponseUnion::kHeartbeatTxnFieldNumber;
const int ResponseUnion::kGcFieldNumber;
const int ResponseUnion::kPushTxnFieldNumber;
const int ResponseUnion::kRangeLookupFieldNumber;
const int ResponseUnion::kResolveIntentFieldNumber;
const int ResponseUnion::kResolveIntentRangeFieldNumber;
const int ResponseUnion::kMergeFieldNumber;
const int ResponseUnion::kTruncateLogFieldNumber;
const int ResponseUnion::kLeaderLeaseFieldNumber;
const int ResponseUnion::kReverseScanFieldNumber;
const int ResponseUnion::kComputeChecksumFieldNumber;
const int ResponseUnion::kVerifyChecksumFieldNumber;
const int ResponseUnion::kCheckConsistencyFieldNumber;
const int ResponseUnion::kNoopFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

ResponseUnion::ResponseUnion()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:cockroach.roachpb.ResponseUnion)
}

void ResponseUnion::InitAsDefaultInstance() {
  get_ = const_cast< ::cockroach::roachpb::GetResponse*>(&::cockroach::roachpb::GetResponse::default_instance());
  put_ = const_cast< ::cockroach::roachpb::PutResponse*>(&::cockroach::roachpb::PutResponse::default_instance());
  conditional_put_ = const_cast< ::cockroach::roachpb::ConditionalPutResponse*>(&::cockroach::roachpb::ConditionalPutResponse::default_instance());
  increment_ = const_cast< ::cockroach::roachpb::IncrementResponse*>(&::cockroach::roachpb::IncrementResponse::default_instance());
  delete__ = const_cast< ::cockroach::roachpb::DeleteResponse*>(&::cockroach::roachpb::DeleteResponse::default_instance());
  delete_range_ = const_cast< ::cockroach::roachpb::DeleteRangeResponse*>(&::cockroach::roachpb::DeleteRangeResponse::default_instance());
  scan_ = const_cast< ::cockroach::roachpb::ScanResponse*>(&::cockroach::roachpb::ScanResponse::default_instance());
  begin_transaction_ = const_cast< ::cockroach::roachpb::BeginTransactionResponse*>(&::cockroach::roachpb::BeginTransactionResponse::default_instance());
  end_transaction_ = const_cast< ::cockroach::roachpb::EndTransactionResponse*>(&::cockroach::roachpb::EndTransactionResponse::default_instance());
  admin_split_ = const_cast< ::cockroach::roachpb::AdminSplitResponse*>(&::cockroach::roachpb::AdminSplitResponse::default_instance());
  admin_merge_ = const_cast< ::cockroach::roachpb::AdminMergeResponse*>(&::cockroach::roachpb::AdminMergeResponse::default_instance());
  heartbeat_txn_ = const_cast< ::cockroach::roachpb::HeartbeatTxnResponse*>(&::cockroach::roachpb::HeartbeatTxnResponse::default_instance());
  gc_ = const_cast< ::cockroach::roachpb::GCResponse*>(&::cockroach::roachpb::GCResponse::default_instance());
  push_txn_ = const_cast< ::cockroach::roachpb::PushTxnResponse*>(&::cockroach::roachpb::PushTxnResponse::default_instance());
  range_lookup_ = const_cast< ::cockroach::roachpb::RangeLookupResponse*>(&::cockroach::roachpb::RangeLookupResponse::default_instance());
  resolve_intent_ = const_cast< ::cockroach::roachpb::ResolveIntentResponse*>(&::cockroach::roachpb::ResolveIntentResponse::default_instance());
  resolve_intent_range_ = const_cast< ::cockroach::roachpb::ResolveIntentRangeResponse*>(&::cockroach::roachpb::ResolveIntentRangeResponse::default_instance());
  merge_ = const_cast< ::cockroach::roachpb::MergeResponse*>(&::cockroach::roachpb::MergeResponse::default_instance());
  truncate_log_ = const_cast< ::cockroach::roachpb::TruncateLogResponse*>(&::cockroach::roachpb::TruncateLogResponse::default_instance());
  leader_lease_ = const_cast< ::cockroach::roachpb::LeaderLeaseResponse*>(&::cockroach::roachpb::LeaderLeaseResponse::default_instance());
  reverse_scan_ = const_cast< ::cockroach::roachpb::ReverseScanResponse*>(&::cockroach::roachpb::ReverseScanResponse::default_instance());
  compute_checksum_ = const_cast< ::cockroach::roachpb::ComputeChecksumResponse*>(&::cockroach::roachpb::ComputeChecksumResponse::default_instance());
  verify_checksum_ = const_cast< ::cockroach::roachpb::VerifyChecksumResponse*>(&::cockroach::roachpb::VerifyChecksumResponse::default_instance());
  check_consistency_ = const_cast< ::cockroach::roachpb::CheckConsistencyResponse*>(&::cockroach::roachpb::CheckConsistencyResponse::default_instance());
  noop_ = const_cast< ::cockroach::roachpb::NoopResponse*>(&::cockroach::roachpb::NoopResponse::default_instance());
}

ResponseUnion::ResponseUnion(const ResponseUnion& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:cockroach.roachpb.ResponseUnion)
}

void ResponseUnion::SharedCtor() {
  _cached_size_ = 0;
  get_ = NULL;
  put_ = NULL;
  conditional_put_ = NULL;
  increment_ = NULL;
  delete__ = NULL;
  delete_range_ = NULL;
  scan_ = NULL;
  begin_transaction_ = NULL;
  end_transaction_ = NULL;
  admin_split_ = NULL;
  admin_merge_ = NULL;
  heartbeat_txn_ = NULL;
  gc_ = NULL;
  push_txn_ = NULL;
  range_lookup_ = NULL;
  resolve_intent_ = NULL;
  resolve_intent_range_ = NULL;
  merge_ = NULL;
  truncate_log_ = NULL;
  leader_lease_ = NULL;
  reverse_scan_ = NULL;
  compute_checksum_ = NULL;
  verify_checksum_ = NULL;
  check_consistency_ = NULL;
  noop_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ResponseUnion::~ResponseUnion() {
  // @@protoc_insertion_point(destructor:cockroach.roachpb.ResponseUnion)
  SharedDtor();
}

void ResponseUnion::SharedDtor() {
  if (this != default_instance_) {
    delete get_;
    delete put_;
    delete conditional_put_;
    delete increment_;
    delete delete__;
    delete delete_range_;
    delete scan_;
    delete begin_transaction_;
    delete end_transaction_;
    delete admin_split_;
    delete admin_merge_;
    delete heartbeat_txn_;
    delete gc_;
    delete push_txn_;
    delete range_lookup_;
    delete resolve_intent_;
    delete resolve_intent_range_;
    delete merge_;
    delete truncate_log_;
    delete leader_lease_;
    delete reverse_scan_;
    delete compute_checksum_;
    delete verify_checksum_;
    delete check_consistency_;
    delete noop_;
  }
}

void ResponseUnion::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ResponseUnion::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ResponseUnion_descriptor_;
}

const ResponseUnion& ResponseUnion::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_cockroach_2froachpb_2fapi_2eproto();
  return *default_instance_;
}

ResponseUnion* ResponseUnion::default_instance_ = NULL;

ResponseUnion* ResponseUnion::New(::google::protobuf::Arena* arena) const {
  ResponseUnion* n = new ResponseUnion;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void ResponseUnion::Clear() {
  if (_has_bits_[0 / 32] & 255u) {
    if (has_get()) {
      if (get_ != NULL) get_->::cockroach::roachpb::GetResponse::Clear();
    }
    if (has_put()) {
      if (put_ != NULL) put_->::cockroach::roachpb::PutResponse::Clear();
    }
    if (has_conditional_put()) {
      if (conditional_put_ != NULL) conditional_put_->::cockroach::roachpb::ConditionalPutResponse::Clear();
    }
    if (has_increment()) {
      if (increment_ != NULL) increment_->::cockroach::roachpb::IncrementResponse::Clear();
    }
    if (has_delete_()) {
      if (delete__ != NULL) delete__->::cockroach::roachpb::DeleteResponse::Clear();
    }
    if (has_delete_range()) {
      if (delete_range_ != NULL) delete_range_->::cockroach::roachpb::DeleteRangeResponse::Clear();
    }
    if (has_scan()) {
      if (scan_ != NULL) scan_->::cockroach::roachpb::ScanResponse::Clear();
    }
    if (has_begin_transaction()) {
      if (begin_transaction_ != NULL) begin_transaction_->::cockroach::roachpb::BeginTransactionResponse::Clear();
    }
  }
  if (_has_bits_[8 / 32] & 65280u) {
    if (has_end_transaction()) {
      if (end_transaction_ != NULL) end_transaction_->::cockroach::roachpb::EndTransactionResponse::Clear();
    }
    if (has_admin_split()) {
      if (admin_split_ != NULL) admin_split_->::cockroach::roachpb::AdminSplitResponse::Clear();
    }
    if (has_admin_merge()) {
      if (admin_merge_ != NULL) admin_merge_->::cockroach::roachpb::AdminMergeResponse::Clear();
    }
    if (has_heartbeat_txn()) {
      if (heartbeat_txn_ != NULL) heartbeat_txn_->::cockroach::roachpb::HeartbeatTxnResponse::Clear();
    }
    if (has_gc()) {
      if (gc_ != NULL) gc_->::cockroach::roachpb::GCResponse::Clear();
    }
    if (has_push_txn()) {
      if (push_txn_ != NULL) push_txn_->::cockroach::roachpb::PushTxnResponse::Clear();
    }
    if (has_range_lookup()) {
      if (range_lookup_ != NULL) range_lookup_->::cockroach::roachpb::RangeLookupResponse::Clear();
    }
    if (has_resolve_intent()) {
      if (resolve_intent_ != NULL) resolve_intent_->::cockroach::roachpb::ResolveIntentResponse::Clear();
    }
  }
  if (_has_bits_[16 / 32] & 16711680u) {
    if (has_resolve_intent_range()) {
      if (resolve_intent_range_ != NULL) resolve_intent_range_->::cockroach::roachpb::ResolveIntentRangeResponse::Clear();
    }
    if (has_merge()) {
      if (merge_ != NULL) merge_->::cockroach::roachpb::MergeResponse::Clear();
    }
    if (has_truncate_log()) {
      if (truncate_log_ != NULL) truncate_log_->::cockroach::roachpb::TruncateLogResponse::Clear();
    }
    if (has_leader_lease()) {
      if (leader_lease_ != NULL) leader_lease_->::cockroach::roachpb::LeaderLeaseResponse::Clear();
    }
    if (has_reverse_scan()) {
      if (reverse_scan_ != NULL) reverse_scan_->::cockroach::roachpb::ReverseScanResponse::Clear();
    }
    if (has_compute_checksum()) {
      if (compute_checksum_ != NULL) compute_checksum_->::cockroach::roachpb::ComputeChecksumResponse::Clear();
    }
    if (has_verify_checksum()) {
      if (verify_checksum_ != NULL) verify_checksum_->::cockroach::roachpb::VerifyChecksumResponse::Clear();
    }
    if (has_check_consistency()) {
      if (check_consistency_ != NULL) check_consistency_->::cockroach::roachpb::CheckConsistencyResponse::Clear();
    }
  }
  if (has_noop()) {
    if (noop_ != NULL) noop_->::cockroach::roachpb::NoopResponse::Clear();
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool ResponseUnion::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:cockroach.roachpb.ResponseUnion)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(16383);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .cockroach.roachpb.GetResponse get = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_get()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_put;
        break;
      }

      // optional .cockroach.roachpb.PutResponse put = 2;
      case 2: {
        if (tag == 18) {
         parse_put:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_put()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_conditional_put;
        break;
      }

      // optional .cockroach.roachpb.ConditionalPutResponse conditional_put = 3;
      case 3: {
        if (tag == 26) {
         parse_conditional_put:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_conditional_put()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_increment;
        break;
      }

      // optional .cockroach.roachpb.IncrementResponse increment = 4;
      case 4: {
        if (tag == 34) {
         parse_increment:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_increment()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_delete;
        break;
      }

      // optional .cockroach.roachpb.DeleteResponse delete = 5;
      case 5: {
        if (tag == 42) {
         parse_delete:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_delete_()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(50)) goto parse_delete_range;
        break;
      }

      // optional .cockroach.roachpb.DeleteRangeResponse delete_range = 6;
      case 6: {
        if (tag == 50) {
         parse_delete_range:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_delete_range()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(58)) goto parse_scan;
        break;
      }

      // optional .cockroach.roachpb.ScanResponse scan = 7;
      case 7: {
        if (tag == 58) {
         parse_scan:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_scan()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(66)) goto parse_begin_transaction;
        break;
      }

      // optional .cockroach.roachpb.BeginTransactionResponse begin_transaction = 8;
      case 8: {
        if (tag == 66) {
         parse_begin_transaction:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_begin_transaction()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(74)) goto parse_end_transaction;
        break;
      }

      // optional .cockroach.roachpb.EndTransactionResponse end_transaction = 9;
      case 9: {
        if (tag == 74) {
         parse_end_transaction:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_end_transaction()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(82)) goto parse_admin_split;
        break;
      }

      // optional .cockroach.roachpb.AdminSplitResponse admin_split = 10;
      case 10: {
        if (tag == 82) {
         parse_admin_split:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_admin_split()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(90)) goto parse_admin_merge;
        break;
      }

      // optional .cockroach.roachpb.AdminMergeResponse admin_merge = 11;
      case 11: {
        if (tag == 90) {
         parse_admin_merge:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_admin_merge()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(98)) goto parse_heartbeat_txn;
        break;
      }

      // optional .cockroach.roachpb.HeartbeatTxnResponse heartbeat_txn = 12;
      case 12: {
        if (tag == 98) {
         parse_heartbeat_txn:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_heartbeat_txn()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(106)) goto parse_gc;
        break;
      }

      // optional .cockroach.roachpb.GCResponse gc = 13;
      case 13: {
        if (tag == 106) {
         parse_gc:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_gc()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(114)) goto parse_push_txn;
        break;
      }

      // optional .cockroach.roachpb.PushTxnResponse push_txn = 14;
      case 14: {
        if (tag == 114) {
         parse_push_txn:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_push_txn()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(122)) goto parse_range_lookup;
        break;
      }

      // optional .cockroach.roachpb.RangeLookupResponse range_lookup = 15;
      case 15: {
        if (tag == 122) {
         parse_range_lookup:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_range_lookup()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(130)) goto parse_resolve_intent;
        break;
      }

      // optional .cockroach.roachpb.ResolveIntentResponse resolve_intent = 16;
      case 16: {
        if (tag == 130) {
         parse_resolve_intent:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_resolve_intent()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(138)) goto parse_resolve_intent_range;
        break;
      }

      // optional .cockroach.roachpb.ResolveIntentRangeResponse resolve_intent_range = 17;
      case 17: {
        if (tag == 138) {
         parse_resolve_intent_range:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_resolve_intent_range()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(146)) goto parse_merge;
        break;
      }

      // optional .cockroach.roachpb.MergeResponse merge = 18;
      case 18: {
        if (tag == 146) {
         parse_merge:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_merge()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(154)) goto parse_truncate_log;
        break;
      }

      // optional .cockroach.roachpb.TruncateLogResponse truncate_log = 19;
      case 19: {
        if (tag == 154) {
         parse_truncate_log:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_truncate_log()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(162)) goto parse_leader_lease;
        break;
      }

      // optional .cockroach.roachpb.LeaderLeaseResponse leader_lease = 20;
      case 20: {
        if (tag == 162) {
         parse_leader_lease:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_leader_lease()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(170)) goto parse_reverse_scan;
        break;
      }

      // optional .cockroach.roachpb.ReverseScanResponse reverse_scan = 21;
      case 21: {
        if (tag == 170) {
         parse_reverse_scan:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_reverse_scan()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(178)) goto parse_compute_checksum;
        break;
      }

      // optional .cockroach.roachpb.ComputeChecksumResponse compute_checksum = 22;
      case 22: {
        if (tag == 178) {
         parse_compute_checksum:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_compute_checksum()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(186)) goto parse_verify_checksum;
        break;
      }

      // optional .cockroach.roachpb.VerifyChecksumResponse verify_checksum = 23;
      case 23: {
        if (tag == 186) {
         parse_verify_checksum:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_verify_checksum()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(194)) goto parse_check_consistency;
        break;
      }

      // optional .cockroach.roachpb.CheckConsistencyResponse check_consistency = 24;
      case 24: {
        if (tag == 194) {
         parse_check_consistency:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_check_consistency()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(202)) goto parse_noop;
        break;
      }

      // optional .cockroach.roachpb.NoopResponse noop = 25;
      case 25: {
        if (tag == 202) {
         parse_noop:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_noop()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:cockroach.roachpb.ResponseUnion)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:cockroach.roachpb.ResponseUnion)
  return false;
#undef DO_
}

void ResponseUnion::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:cockroach.roachpb.ResponseUnion)
  // optional .cockroach.roachpb.GetResponse get = 1;
  if (has_get()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->get_, output);
  }

  // optional .cockroach.roachpb.PutResponse put = 2;
  if (has_put()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, *this->put_, output);
  }

  // optional .cockroach.roachpb.ConditionalPutResponse conditional_put = 3;
  if (has_conditional_put()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, *this->conditional_put_, output);
  }

  // optional .cockroach.roachpb.IncrementResponse increment = 4;
  if (has_increment()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, *this->increment_, output);
  }

  // optional .cockroach.roachpb.DeleteResponse delete = 5;
  if (has_delete_()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      5, *this->delete__, output);
  }

  // optional .cockroach.roachpb.DeleteRangeResponse delete_range = 6;
  if (has_delete_range()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      6, *this->delete_range_, output);
  }

  // optional .cockroach.roachpb.ScanResponse scan = 7;
  if (has_scan()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      7, *this->scan_, output);
  }

  // optional .cockroach.roachpb.BeginTransactionResponse begin_transaction = 8;
  if (has_begin_transaction()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      8, *this->begin_transaction_, output);
  }

  // optional .cockroach.roachpb.EndTransactionResponse end_transaction = 9;
  if (has_end_transaction()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      9, *this->end_transaction_, output);
  }

  // optional .cockroach.roachpb.AdminSplitResponse admin_split = 10;
  if (has_admin_split()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      10, *this->admin_split_, output);
  }

  // optional .cockroach.roachpb.AdminMergeResponse admin_merge = 11;
  if (has_admin_merge()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      11, *this->admin_merge_, output);
  }

  // optional .cockroach.roachpb.HeartbeatTxnResponse heartbeat_txn = 12;
  if (has_heartbeat_txn()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      12, *this->heartbeat_txn_, output);
  }

  // optional .cockroach.roachpb.GCResponse gc = 13;
  if (has_gc()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      13, *this->gc_, output);
  }

  // optional .cockroach.roachpb.PushTxnResponse push_txn = 14;
  if (has_push_txn()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      14, *this->push_txn_, output);
  }

  // optional .cockroach.roachpb.RangeLookupResponse range_lookup = 15;
  if (has_range_lookup()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      15, *this->range_lookup_, output);
  }

  // optional .cockroach.roachpb.ResolveIntentResponse resolve_intent = 16;
  if (has_resolve_intent()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      16, *this->resolve_intent_, output);
  }

  // optional .cockroach.roachpb.ResolveIntentRangeResponse resolve_intent_range = 17;
  if (has_resolve_intent_range()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      17, *this->resolve_intent_range_, output);
  }

  // optional .cockroach.roachpb.MergeResponse merge = 18;
  if (has_merge()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      18, *this->merge_, output);
  }

  // optional .cockroach.roachpb.TruncateLogResponse truncate_log = 19;
  if (has_truncate_log()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      19, *this->truncate_log_, output);
  }

  // optional .cockroach.roachpb.LeaderLeaseResponse leader_lease = 20;
  if (has_leader_lease()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      20, *this->leader_lease_, output);
  }

  // optional .cockroach.roachpb.ReverseScanResponse reverse_scan = 21;
  if (has_reverse_scan()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      21, *this->reverse_scan_, output);
  }

  // optional .cockroach.roachpb.ComputeChecksumResponse compute_checksum = 22;
  if (has_compute_checksum()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      22, *this->compute_checksum_, output);
  }

  // optional .cockroach.roachpb.VerifyChecksumResponse verify_checksum = 23;
  if (has_verify_checksum()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      23, *this->verify_checksum_, output);
  }

  // optional .cockroach.roachpb.CheckConsistencyResponse check_consistency = 24;
  if (has_check_consistency()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      24, *this->check_consistency_, output);
  }

  // optional .cockroach.roachpb.NoopResponse noop = 25;
  if (has_noop()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      25, *this->noop_, output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:cockroach.roachpb.ResponseUnion)
}

::google::protobuf::uint8* ResponseUnion::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:cockroach.roachpb.ResponseUnion)
  // optional .cockroach.roachpb.GetResponse get = 1;
  if (has_get()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, *this->get_, target);
  }

  // optional .cockroach.roachpb.PutResponse put = 2;
  if (has_put()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, *this->put_, target);
  }

  // optional .cockroach.roachpb.ConditionalPutResponse conditional_put = 3;
  if (has_conditional_put()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, *this->conditional_put_, target);
  }

  // optional .cockroach.roachpb.IncrementResponse increment = 4;
  if (has_increment()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        4, *this->increment_, target);
  }

  // optional .cockroach.roachpb.DeleteResponse delete = 5;
  if (has_delete_()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        5, *this->delete__, target);
  }

  // optional .cockroach.roachpb.DeleteRangeResponse delete_range = 6;
  if (has_delete_range()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        6, *this->delete_range_, target);
  }

  // optional .cockroach.roachpb.ScanResponse scan = 7;
  if (has_scan()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        7, *this->scan_, target);
  }

  // optional .cockroach.roachpb.BeginTransactionResponse begin_transaction = 8;
  if (has_begin_transaction()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        8, *this->begin_transaction_, target);
  }

  // optional .cockroach.roachpb.EndTransactionResponse end_transaction = 9;
  if (has_end_transaction()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        9, *this->end_transaction_, target);
  }

  // optional .cockroach.roachpb.AdminSplitResponse admin_split = 10;
  if (has_admin_split()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        10, *this->admin_split_, target);
  }

  // optional .cockroach.roachpb.AdminMergeResponse admin_merge = 11;
  if (has_admin_merge()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        11, *this->admin_merge_, target);
  }

  // optional .cockroach.roachpb.HeartbeatTxnResponse heartbeat_txn = 12;
  if (has_heartbeat_txn()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        12, *this->heartbeat_txn_, target);
  }

  // optional .cockroach.roachpb.GCResponse gc = 13;
  if (has_gc()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        13, *this->gc_, target);
  }

  // optional .cockroach.roachpb.PushTxnResponse push_txn = 14;
  if (has_push_txn()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        14, *this->push_txn_, target);
  }

  // optional .cockroach.roachpb.RangeLookupResponse range_lookup = 15;
  if (has_range_lookup()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        15, *this->range_lookup_, target);
  }

  // optional .cockroach.roachpb.ResolveIntentResponse resolve_intent = 16;
  if (has_resolve_intent()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        16, *this->resolve_intent_, target);
  }

  // optional .cockroach.roachpb.ResolveIntentRangeResponse resolve_intent_range = 17;
  if (has_resolve_intent_range()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        17, *this->resolve_intent_range_, target);
  }

  // optional .cockroach.roachpb.MergeResponse merge = 18;
  if (has_merge()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        18, *this->merge_, target);
  }

  // optional .cockroach.roachpb.TruncateLogResponse truncate_log = 19;
  if (has_truncate_log()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        19, *this->truncate_log_, target);
  }

  // optional .cockroach.roachpb.LeaderLeaseResponse leader_lease = 20;
  if (has_leader_lease()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        20, *this->leader_lease_, target);
  }

  // optional .cockroach.roachpb.ReverseScanResponse reverse_scan = 21;
  if (has_reverse_scan()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        21, *this->reverse_scan_, target);
  }

  // optional .cockroach.roachpb.ComputeChecksumResponse compute_checksum = 22;
  if (has_compute_checksum()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        22, *this->compute_checksum_, target);
  }

  // optional .cockroach.roachpb.VerifyChecksumResponse verify_checksum = 23;
  if (has_verify_checksum()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        23, *this->verify_checksum_, target);
  }

  // optional .cockroach.roachpb.CheckConsistencyResponse check_consistency = 24;
  if (has_check_consistency()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        24, *this->check_consistency_, target);
  }

  // optional .cockroach.roachpb.NoopResponse noop = 25;
  if (has_noop()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        25, *this->noop_, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:cockroach.roachpb.ResponseUnion)
  return target;
}

int ResponseUnion::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & 255u) {
    // optional .cockroach.roachpb.GetResponse get = 1;
    if (has_get()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->get_);
    }

    // optional .cockroach.roachpb.PutResponse put = 2;
    if (has_put()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->put_);
    }

    // optional .cockroach.roachpb.ConditionalPutResponse conditional_put = 3;
    if (has_conditional_put()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->conditional_put_);
    }

    // optional .cockroach.roachpb.IncrementResponse increment = 4;
    if (has_increment()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->increment_);
    }

    // optional .cockroach.roachpb.DeleteResponse delete = 5;
    if (has_delete_()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->delete__);
    }

    // optional .cockroach.roachpb.DeleteRangeResponse delete_range = 6;
    if (has_delete_range()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->delete_range_);
    }

    // optional .cockroach.roachpb.ScanResponse scan = 7;
    if (has_scan()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->scan_);
    }

    // optional .cockroach.roachpb.BeginTransactionResponse begin_transaction = 8;
    if (has_begin_transaction()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->begin_transaction_);
    }

  }
  if (_has_bits_[8 / 32] & 65280u) {
    // optional .cockroach.roachpb.EndTransactionResponse end_transaction = 9;
    if (has_end_transaction()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->end_transaction_);
    }

    // optional .cockroach.roachpb.AdminSplitResponse admin_split = 10;
    if (has_admin_split()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->admin_split_);
    }

    // optional .cockroach.roachpb.AdminMergeResponse admin_merge = 11;
    if (has_admin_merge()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->admin_merge_);
    }

    // optional .cockroach.roachpb.HeartbeatTxnResponse heartbeat_txn = 12;
    if (has_heartbeat_txn()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->heartbeat_txn_);
    }

    // optional .cockroach.roachpb.GCResponse gc = 13;
    if (has_gc()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->gc_);
    }

    // optional .cockroach.roachpb.PushTxnResponse push_txn = 14;
    if (has_push_txn()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->push_txn_);
    }

    // optional .cockroach.roachpb.RangeLookupResponse range_lookup = 15;
    if (has_range_lookup()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->range_lookup_);
    }

    // optional .cockroach.roachpb.ResolveIntentResponse resolve_intent = 16;
    if (has_resolve_intent()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->resolve_intent_);
    }

  }
  if (_has_bits_[16 / 32] & 16711680u) {
    // optional .cockroach.roachpb.ResolveIntentRangeResponse resolve_intent_range = 17;
    if (has_resolve_intent_range()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->resolve_intent_range_);
    }

    // optional .cockroach.roachpb.MergeResponse merge = 18;
    if (has_merge()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->merge_);
    }

    // optional .cockroach.roachpb.TruncateLogResponse truncate_log = 19;
    if (has_truncate_log()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->truncate_log_);
    }

    // optional .cockroach.roachpb.LeaderLeaseResponse leader_lease = 20;
    if (has_leader_lease()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->leader_lease_);
    }

    // optional .cockroach.roachpb.ReverseScanResponse reverse_scan = 21;
    if (has_reverse_scan()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->reverse_scan_);
    }

    // optional .cockroach.roachpb.ComputeChecksumResponse compute_checksum = 22;
    if (has_compute_checksum()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->compute_checksum_);
    }

    // optional .cockroach.roachpb.VerifyChecksumResponse verify_checksum = 23;
    if (has_verify_checksum()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->verify_checksum_);
    }

    // optional .cockroach.roachpb.CheckConsistencyResponse check_consistency = 24;
    if (has_check_consistency()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->check_consistency_);
    }

  }
  // optional .cockroach.roachpb.NoopResponse noop = 25;
  if (has_noop()) {
    total_size += 2 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->noop_);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ResponseUnion::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const ResponseUnion* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const ResponseUnion>(
          &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ResponseUnion::MergeFrom(const ResponseUnion& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_get()) {
      mutable_get()->::cockroach::roachpb::GetResponse::MergeFrom(from.get());
    }
    if (from.has_put()) {
      mutable_put()->::cockroach::roachpb::PutResponse::MergeFrom(from.put());
    }
    if (from.has_conditional_put()) {
      mutable_conditional_put()->::cockroach::roachpb::ConditionalPutResponse::MergeFrom(from.conditional_put());
    }
    if (from.has_increment()) {
      mutable_increment()->::cockroach::roachpb::IncrementResponse::MergeFrom(from.increment());
    }
    if (from.has_delete_()) {
      mutable_delete_()->::cockroach::roachpb::DeleteResponse::MergeFrom(from.delete_());
    }
    if (from.has_delete_range()) {
      mutable_delete_range()->::cockroach::roachpb::DeleteRangeResponse::MergeFrom(from.delete_range());
    }
    if (from.has_scan()) {
      mutable_scan()->::cockroach::roachpb::ScanResponse::MergeFrom(from.scan());
    }
    if (from.has_begin_transaction()) {
      mutable_begin_transaction()->::cockroach::roachpb::BeginTransactionResponse::MergeFrom(from.begin_transaction());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_end_transaction()) {
      mutable_end_transaction()->::cockroach::roachpb::EndTransactionResponse::MergeFrom(from.end_transaction());
    }
    if (from.has_admin_split()) {
      mutable_admin_split()->::cockroach::roachpb::AdminSplitResponse::MergeFrom(from.admin_split());
    }
    if (from.has_admin_merge()) {
      mutable_admin_merge()->::cockroach::roachpb::AdminMergeResponse::MergeFrom(from.admin_merge());
    }
    if (from.has_heartbeat_txn()) {
      mutable_heartbeat_txn()->::cockroach::roachpb::HeartbeatTxnResponse::MergeFrom(from.heartbeat_txn());
    }
    if (from.has_gc()) {
      mutable_gc()->::cockroach::roachpb::GCResponse::MergeFrom(from.gc());
    }
    if (from.has_push_txn()) {
      mutable_push_txn()->::cockroach::roachpb::PushTxnResponse::MergeFrom(from.push_txn());
    }
    if (from.has_range_lookup()) {
      mutable_range_lookup()->::cockroach::roachpb::RangeLookupResponse::MergeFrom(from.range_lookup());
    }
    if (from.has_resolve_intent()) {
      mutable_resolve_intent()->::cockroach::roachpb::ResolveIntentResponse::MergeFrom(from.resolve_intent());
    }
  }
  if (from._has_bits_[16 / 32] & (0xffu << (16 % 32))) {
    if (from.has_resolve_intent_range()) {
      mutable_resolve_intent_range()->::cockroach::roachpb::ResolveIntentRangeResponse::MergeFrom(from.resolve_intent_range());
    }
    if (from.has_merge()) {
      mutable_merge()->::cockroach::roachpb::MergeResponse::MergeFrom(from.merge());
    }
    if (from.has_truncate_log()) {
      mutable_truncate_log()->::cockroach::roachpb::TruncateLogResponse::MergeFrom(from.truncate_log());
    }
    if (from.has_leader_lease()) {
      mutable_leader_lease()->::cockroach::roachpb::LeaderLeaseResponse::MergeFrom(from.leader_lease());
    }
    if (from.has_reverse_scan()) {
      mutable_reverse_scan()->::cockroach::roachpb::ReverseScanResponse::MergeFrom(from.reverse_scan());
    }
    if (from.has_compute_checksum()) {
      mutable_compute_checksum()->::cockroach::roachpb::ComputeChecksumResponse::MergeFrom(from.compute_checksum());
    }
    if (from.has_verify_checksum()) {
      mutable_verify_checksum()->::cockroach::roachpb::VerifyChecksumResponse::MergeFrom(from.verify_checksum());
    }
    if (from.has_check_consistency()) {
      mutable_check_consistency()->::cockroach::roachpb::CheckConsistencyResponse::MergeFrom(from.check_consistency());
    }
  }
  if (from._has_bits_[24 / 32] & (0xffu << (24 % 32))) {
    if (from.has_noop()) {
      mutable_noop()->::cockroach::roachpb::NoopResponse::MergeFrom(from.noop());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void ResponseUnion::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ResponseUnion::CopyFrom(const ResponseUnion& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ResponseUnion::IsInitialized() const {

  return true;
}

void ResponseUnion::Swap(ResponseUnion* other) {
  if (other == this) return;
  InternalSwap(other);
}
void ResponseUnion::InternalSwap(ResponseUnion* other) {
  std::swap(get_, other->get_);
  std::swap(put_, other->put_);
  std::swap(conditional_put_, other->conditional_put_);
  std::swap(increment_, other->increment_);
  std::swap(delete__, other->delete__);
  std::swap(delete_range_, other->delete_range_);
  std::swap(scan_, other->scan_);
  std::swap(begin_transaction_, other->begin_transaction_);
  std::swap(end_transaction_, other->end_transaction_);
  std::swap(admin_split_, other->admin_split_);
  std::swap(admin_merge_, other->admin_merge_);
  std::swap(heartbeat_txn_, other->heartbeat_txn_);
  std::swap(gc_, other->gc_);
  std::swap(push_txn_, other->push_txn_);
  std::swap(range_lookup_, other->range_lookup_);
  std::swap(resolve_intent_, other->resolve_intent_);
  std::swap(resolve_intent_range_, other->resolve_intent_range_);
  std::swap(merge_, other->merge_);
  std::swap(truncate_log_, other->truncate_log_);
  std::swap(leader_lease_, other->leader_lease_);
  std::swap(reverse_scan_, other->reverse_scan_);
  std::swap(compute_checksum_, other->compute_checksum_);
  std::swap(verify_checksum_, other->verify_checksum_);
  std::swap(check_consistency_, other->check_consistency_);
  std::swap(noop_, other->noop_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata ResponseUnion::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ResponseUnion_descriptor_;
  metadata.reflection = ResponseUnion_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// ResponseUnion

// optional .cockroach.roachpb.GetResponse get = 1;
bool ResponseUnion::has_get() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void ResponseUnion::set_has_get() {
  _has_bits_[0] |= 0x00000001u;
}
void ResponseUnion::clear_has_get() {
  _has_bits_[0] &= ~0x00000001u;
}
void ResponseUnion::clear_get() {
  if (get_ != NULL) get_->::cockroach::roachpb::GetResponse::Clear();
  clear_has_get();
}
const ::cockroach::roachpb::GetResponse& ResponseUnion::get() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.ResponseUnion.get)
  return get_ != NULL ? *get_ : *default_instance_->get_;
}
::cockroach::roachpb::GetResponse* ResponseUnion::mutable_get() {
  set_has_get();
  if (get_ == NULL) {
    get_ = new ::cockroach::roachpb::GetResponse;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.ResponseUnion.get)
  return get_;
}
::cockroach::roachpb::GetResponse* ResponseUnion::release_get() {
  clear_has_get();
  ::cockroach::roachpb::GetResponse* temp = get_;
  get_ = NULL;
  return temp;
}
void ResponseUnion::set_allocated_get(::cockroach::roachpb::GetResponse* get) {
  delete get_;
  get_ = get;
  if (get) {
    set_has_get();
  } else {
    clear_has_get();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.ResponseUnion.get)
}

// optional .cockroach.roachpb.PutResponse put = 2;
bool ResponseUnion::has_put() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void ResponseUnion::set_has_put() {
  _has_bits_[0] |= 0x00000002u;
}
void ResponseUnion::clear_has_put() {
  _has_bits_[0] &= ~0x00000002u;
}
void ResponseUnion::clear_put() {
  if (put_ != NULL) put_->::cockroach::roachpb::PutResponse::Clear();
  clear_has_put();
}
const ::cockroach::roachpb::PutResponse& ResponseUnion::put() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.ResponseUnion.put)
  return put_ != NULL ? *put_ : *default_instance_->put_;
}
::cockroach::roachpb::PutResponse* ResponseUnion::mutable_put() {
  set_has_put();
  if (put_ == NULL) {
    put_ = new ::cockroach::roachpb::PutResponse;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.ResponseUnion.put)
  return put_;
}
::cockroach::roachpb::PutResponse* ResponseUnion::release_put() {
  clear_has_put();
  ::cockroach::roachpb::PutResponse* temp = put_;
  put_ = NULL;
  return temp;
}
void ResponseUnion::set_allocated_put(::cockroach::roachpb::PutResponse* put) {
  delete put_;
  put_ = put;
  if (put) {
    set_has_put();
  } else {
    clear_has_put();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.ResponseUnion.put)
}

// optional .cockroach.roachpb.ConditionalPutResponse conditional_put = 3;
bool ResponseUnion::has_conditional_put() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void ResponseUnion::set_has_conditional_put() {
  _has_bits_[0] |= 0x00000004u;
}
void ResponseUnion::clear_has_conditional_put() {
  _has_bits_[0] &= ~0x00000004u;
}
void ResponseUnion::clear_conditional_put() {
  if (conditional_put_ != NULL) conditional_put_->::cockroach::roachpb::ConditionalPutResponse::Clear();
  clear_has_conditional_put();
}
const ::cockroach::roachpb::ConditionalPutResponse& ResponseUnion::conditional_put() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.ResponseUnion.conditional_put)
  return conditional_put_ != NULL ? *conditional_put_ : *default_instance_->conditional_put_;
}
::cockroach::roachpb::ConditionalPutResponse* ResponseUnion::mutable_conditional_put() {
  set_has_conditional_put();
  if (conditional_put_ == NULL) {
    conditional_put_ = new ::cockroach::roachpb::ConditionalPutResponse;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.ResponseUnion.conditional_put)
  return conditional_put_;
}
::cockroach::roachpb::ConditionalPutResponse* ResponseUnion::release_conditional_put() {
  clear_has_conditional_put();
  ::cockroach::roachpb::ConditionalPutResponse* temp = conditional_put_;
  conditional_put_ = NULL;
  return temp;
}
void ResponseUnion::set_allocated_conditional_put(::cockroach::roachpb::ConditionalPutResponse* conditional_put) {
  delete conditional_put_;
  conditional_put_ = conditional_put;
  if (conditional_put) {
    set_has_conditional_put();
  } else {
    clear_has_conditional_put();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.ResponseUnion.conditional_put)
}

// optional .cockroach.roachpb.IncrementResponse increment = 4;
bool ResponseUnion::has_increment() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void ResponseUnion::set_has_increment() {
  _has_bits_[0] |= 0x00000008u;
}
void ResponseUnion::clear_has_increment() {
  _has_bits_[0] &= ~0x00000008u;
}
void ResponseUnion::clear_increment() {
  if (increment_ != NULL) increment_->::cockroach::roachpb::IncrementResponse::Clear();
  clear_has_increment();
}
const ::cockroach::roachpb::IncrementResponse& ResponseUnion::increment() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.ResponseUnion.increment)
  return increment_ != NULL ? *increment_ : *default_instance_->increment_;
}
::cockroach::roachpb::IncrementResponse* ResponseUnion::mutable_increment() {
  set_has_increment();
  if (increment_ == NULL) {
    increment_ = new ::cockroach::roachpb::IncrementResponse;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.ResponseUnion.increment)
  return increment_;
}
::cockroach::roachpb::IncrementResponse* ResponseUnion::release_increment() {
  clear_has_increment();
  ::cockroach::roachpb::IncrementResponse* temp = increment_;
  increment_ = NULL;
  return temp;
}
void ResponseUnion::set_allocated_increment(::cockroach::roachpb::IncrementResponse* increment) {
  delete increment_;
  increment_ = increment;
  if (increment) {
    set_has_increment();
  } else {
    clear_has_increment();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.ResponseUnion.increment)
}

// optional .cockroach.roachpb.DeleteResponse delete = 5;
bool ResponseUnion::has_delete_() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
void ResponseUnion::set_has_delete_() {
  _has_bits_[0] |= 0x00000010u;
}
void ResponseUnion::clear_has_delete_() {
  _has_bits_[0] &= ~0x00000010u;
}
void ResponseUnion::clear_delete_() {
  if (delete__ != NULL) delete__->::cockroach::roachpb::DeleteResponse::Clear();
  clear_has_delete_();
}
const ::cockroach::roachpb::DeleteResponse& ResponseUnion::delete_() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.ResponseUnion.delete)
  return delete__ != NULL ? *delete__ : *default_instance_->delete__;
}
::cockroach::roachpb::DeleteResponse* ResponseUnion::mutable_delete_() {
  set_has_delete_();
  if (delete__ == NULL) {
    delete__ = new ::cockroach::roachpb::DeleteResponse;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.ResponseUnion.delete)
  return delete__;
}
::cockroach::roachpb::DeleteResponse* ResponseUnion::release_delete_() {
  clear_has_delete_();
  ::cockroach::roachpb::DeleteResponse* temp = delete__;
  delete__ = NULL;
  return temp;
}
void ResponseUnion::set_allocated_delete_(::cockroach::roachpb::DeleteResponse* delete_) {
  delete delete__;
  delete__ = delete_;
  if (delete_) {
    set_has_delete_();
  } else {
    clear_has_delete_();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.ResponseUnion.delete)
}

// optional .cockroach.roachpb.DeleteRangeResponse delete_range = 6;
bool ResponseUnion::has_delete_range() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
void ResponseUnion::set_has_delete_range() {
  _has_bits_[0] |= 0x00000020u;
}
void ResponseUnion::clear_has_delete_range() {
  _has_bits_[0] &= ~0x00000020u;
}
void ResponseUnion::clear_delete_range() {
  if (delete_range_ != NULL) delete_range_->::cockroach::roachpb::DeleteRangeResponse::Clear();
  clear_has_delete_range();
}
const ::cockroach::roachpb::DeleteRangeResponse& ResponseUnion::delete_range() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.ResponseUnion.delete_range)
  return delete_range_ != NULL ? *delete_range_ : *default_instance_->delete_range_;
}
::cockroach::roachpb::DeleteRangeResponse* ResponseUnion::mutable_delete_range() {
  set_has_delete_range();
  if (delete_range_ == NULL) {
    delete_range_ = new ::cockroach::roachpb::DeleteRangeResponse;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.ResponseUnion.delete_range)
  return delete_range_;
}
::cockroach::roachpb::DeleteRangeResponse* ResponseUnion::release_delete_range() {
  clear_has_delete_range();
  ::cockroach::roachpb::DeleteRangeResponse* temp = delete_range_;
  delete_range_ = NULL;
  return temp;
}
void ResponseUnion::set_allocated_delete_range(::cockroach::roachpb::DeleteRangeResponse* delete_range) {
  delete delete_range_;
  delete_range_ = delete_range;
  if (delete_range) {
    set_has_delete_range();
  } else {
    clear_has_delete_range();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.ResponseUnion.delete_range)
}

// optional .cockroach.roachpb.ScanResponse scan = 7;
bool ResponseUnion::has_scan() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
void ResponseUnion::set_has_scan() {
  _has_bits_[0] |= 0x00000040u;
}
void ResponseUnion::clear_has_scan() {
  _has_bits_[0] &= ~0x00000040u;
}
void ResponseUnion::clear_scan() {
  if (scan_ != NULL) scan_->::cockroach::roachpb::ScanResponse::Clear();
  clear_has_scan();
}
const ::cockroach::roachpb::ScanResponse& ResponseUnion::scan() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.ResponseUnion.scan)
  return scan_ != NULL ? *scan_ : *default_instance_->scan_;
}
::cockroach::roachpb::ScanResponse* ResponseUnion::mutable_scan() {
  set_has_scan();
  if (scan_ == NULL) {
    scan_ = new ::cockroach::roachpb::ScanResponse;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.ResponseUnion.scan)
  return scan_;
}
::cockroach::roachpb::ScanResponse* ResponseUnion::release_scan() {
  clear_has_scan();
  ::cockroach::roachpb::ScanResponse* temp = scan_;
  scan_ = NULL;
  return temp;
}
void ResponseUnion::set_allocated_scan(::cockroach::roachpb::ScanResponse* scan) {
  delete scan_;
  scan_ = scan;
  if (scan) {
    set_has_scan();
  } else {
    clear_has_scan();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.ResponseUnion.scan)
}

// optional .cockroach.roachpb.BeginTransactionResponse begin_transaction = 8;
bool ResponseUnion::has_begin_transaction() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
void ResponseUnion::set_has_begin_transaction() {
  _has_bits_[0] |= 0x00000080u;
}
void ResponseUnion::clear_has_begin_transaction() {
  _has_bits_[0] &= ~0x00000080u;
}
void ResponseUnion::clear_begin_transaction() {
  if (begin_transaction_ != NULL) begin_transaction_->::cockroach::roachpb::BeginTransactionResponse::Clear();
  clear_has_begin_transaction();
}
const ::cockroach::roachpb::BeginTransactionResponse& ResponseUnion::begin_transaction() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.ResponseUnion.begin_transaction)
  return begin_transaction_ != NULL ? *begin_transaction_ : *default_instance_->begin_transaction_;
}
::cockroach::roachpb::BeginTransactionResponse* ResponseUnion::mutable_begin_transaction() {
  set_has_begin_transaction();
  if (begin_transaction_ == NULL) {
    begin_transaction_ = new ::cockroach::roachpb::BeginTransactionResponse;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.ResponseUnion.begin_transaction)
  return begin_transaction_;
}
::cockroach::roachpb::BeginTransactionResponse* ResponseUnion::release_begin_transaction() {
  clear_has_begin_transaction();
  ::cockroach::roachpb::BeginTransactionResponse* temp = begin_transaction_;
  begin_transaction_ = NULL;
  return temp;
}
void ResponseUnion::set_allocated_begin_transaction(::cockroach::roachpb::BeginTransactionResponse* begin_transaction) {
  delete begin_transaction_;
  begin_transaction_ = begin_transaction;
  if (begin_transaction) {
    set_has_begin_transaction();
  } else {
    clear_has_begin_transaction();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.ResponseUnion.begin_transaction)
}

// optional .cockroach.roachpb.EndTransactionResponse end_transaction = 9;
bool ResponseUnion::has_end_transaction() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
void ResponseUnion::set_has_end_transaction() {
  _has_bits_[0] |= 0x00000100u;
}
void ResponseUnion::clear_has_end_transaction() {
  _has_bits_[0] &= ~0x00000100u;
}
void ResponseUnion::clear_end_transaction() {
  if (end_transaction_ != NULL) end_transaction_->::cockroach::roachpb::EndTransactionResponse::Clear();
  clear_has_end_transaction();
}
const ::cockroach::roachpb::EndTransactionResponse& ResponseUnion::end_transaction() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.ResponseUnion.end_transaction)
  return end_transaction_ != NULL ? *end_transaction_ : *default_instance_->end_transaction_;
}
::cockroach::roachpb::EndTransactionResponse* ResponseUnion::mutable_end_transaction() {
  set_has_end_transaction();
  if (end_transaction_ == NULL) {
    end_transaction_ = new ::cockroach::roachpb::EndTransactionResponse;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.ResponseUnion.end_transaction)
  return end_transaction_;
}
::cockroach::roachpb::EndTransactionResponse* ResponseUnion::release_end_transaction() {
  clear_has_end_transaction();
  ::cockroach::roachpb::EndTransactionResponse* temp = end_transaction_;
  end_transaction_ = NULL;
  return temp;
}
void ResponseUnion::set_allocated_end_transaction(::cockroach::roachpb::EndTransactionResponse* end_transaction) {
  delete end_transaction_;
  end_transaction_ = end_transaction;
  if (end_transaction) {
    set_has_end_transaction();
  } else {
    clear_has_end_transaction();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.ResponseUnion.end_transaction)
}

// optional .cockroach.roachpb.AdminSplitResponse admin_split = 10;
bool ResponseUnion::has_admin_split() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
void ResponseUnion::set_has_admin_split() {
  _has_bits_[0] |= 0x00000200u;
}
void ResponseUnion::clear_has_admin_split() {
  _has_bits_[0] &= ~0x00000200u;
}
void ResponseUnion::clear_admin_split() {
  if (admin_split_ != NULL) admin_split_->::cockroach::roachpb::AdminSplitResponse::Clear();
  clear_has_admin_split();
}
const ::cockroach::roachpb::AdminSplitResponse& ResponseUnion::admin_split() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.ResponseUnion.admin_split)
  return admin_split_ != NULL ? *admin_split_ : *default_instance_->admin_split_;
}
::cockroach::roachpb::AdminSplitResponse* ResponseUnion::mutable_admin_split() {
  set_has_admin_split();
  if (admin_split_ == NULL) {
    admin_split_ = new ::cockroach::roachpb::AdminSplitResponse;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.ResponseUnion.admin_split)
  return admin_split_;
}
::cockroach::roachpb::AdminSplitResponse* ResponseUnion::release_admin_split() {
  clear_has_admin_split();
  ::cockroach::roachpb::AdminSplitResponse* temp = admin_split_;
  admin_split_ = NULL;
  return temp;
}
void ResponseUnion::set_allocated_admin_split(::cockroach::roachpb::AdminSplitResponse* admin_split) {
  delete admin_split_;
  admin_split_ = admin_split;
  if (admin_split) {
    set_has_admin_split();
  } else {
    clear_has_admin_split();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.ResponseUnion.admin_split)
}

// optional .cockroach.roachpb.AdminMergeResponse admin_merge = 11;
bool ResponseUnion::has_admin_merge() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
void ResponseUnion::set_has_admin_merge() {
  _has_bits_[0] |= 0x00000400u;
}
void ResponseUnion::clear_has_admin_merge() {
  _has_bits_[0] &= ~0x00000400u;
}
void ResponseUnion::clear_admin_merge() {
  if (admin_merge_ != NULL) admin_merge_->::cockroach::roachpb::AdminMergeResponse::Clear();
  clear_has_admin_merge();
}
const ::cockroach::roachpb::AdminMergeResponse& ResponseUnion::admin_merge() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.ResponseUnion.admin_merge)
  return admin_merge_ != NULL ? *admin_merge_ : *default_instance_->admin_merge_;
}
::cockroach::roachpb::AdminMergeResponse* ResponseUnion::mutable_admin_merge() {
  set_has_admin_merge();
  if (admin_merge_ == NULL) {
    admin_merge_ = new ::cockroach::roachpb::AdminMergeResponse;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.ResponseUnion.admin_merge)
  return admin_merge_;
}
::cockroach::roachpb::AdminMergeResponse* ResponseUnion::release_admin_merge() {
  clear_has_admin_merge();
  ::cockroach::roachpb::AdminMergeResponse* temp = admin_merge_;
  admin_merge_ = NULL;
  return temp;
}
void ResponseUnion::set_allocated_admin_merge(::cockroach::roachpb::AdminMergeResponse* admin_merge) {
  delete admin_merge_;
  admin_merge_ = admin_merge;
  if (admin_merge) {
    set_has_admin_merge();
  } else {
    clear_has_admin_merge();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.ResponseUnion.admin_merge)
}

// optional .cockroach.roachpb.HeartbeatTxnResponse heartbeat_txn = 12;
bool ResponseUnion::has_heartbeat_txn() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
void ResponseUnion::set_has_heartbeat_txn() {
  _has_bits_[0] |= 0x00000800u;
}
void ResponseUnion::clear_has_heartbeat_txn() {
  _has_bits_[0] &= ~0x00000800u;
}
void ResponseUnion::clear_heartbeat_txn() {
  if (heartbeat_txn_ != NULL) heartbeat_txn_->::cockroach::roachpb::HeartbeatTxnResponse::Clear();
  clear_has_heartbeat_txn();
}
const ::cockroach::roachpb::HeartbeatTxnResponse& ResponseUnion::heartbeat_txn() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.ResponseUnion.heartbeat_txn)
  return heartbeat_txn_ != NULL ? *heartbeat_txn_ : *default_instance_->heartbeat_txn_;
}
::cockroach::roachpb::HeartbeatTxnResponse* ResponseUnion::mutable_heartbeat_txn() {
  set_has_heartbeat_txn();
  if (heartbeat_txn_ == NULL) {
    heartbeat_txn_ = new ::cockroach::roachpb::HeartbeatTxnResponse;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.ResponseUnion.heartbeat_txn)
  return heartbeat_txn_;
}
::cockroach::roachpb::HeartbeatTxnResponse* ResponseUnion::release_heartbeat_txn() {
  clear_has_heartbeat_txn();
  ::cockroach::roachpb::HeartbeatTxnResponse* temp = heartbeat_txn_;
  heartbeat_txn_ = NULL;
  return temp;
}
void ResponseUnion::set_allocated_heartbeat_txn(::cockroach::roachpb::HeartbeatTxnResponse* heartbeat_txn) {
  delete heartbeat_txn_;
  heartbeat_txn_ = heartbeat_txn;
  if (heartbeat_txn) {
    set_has_heartbeat_txn();
  } else {
    clear_has_heartbeat_txn();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.ResponseUnion.heartbeat_txn)
}

// optional .cockroach.roachpb.GCResponse gc = 13;
bool ResponseUnion::has_gc() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
void ResponseUnion::set_has_gc() {
  _has_bits_[0] |= 0x00001000u;
}
void ResponseUnion::clear_has_gc() {
  _has_bits_[0] &= ~0x00001000u;
}
void ResponseUnion::clear_gc() {
  if (gc_ != NULL) gc_->::cockroach::roachpb::GCResponse::Clear();
  clear_has_gc();
}
const ::cockroach::roachpb::GCResponse& ResponseUnion::gc() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.ResponseUnion.gc)
  return gc_ != NULL ? *gc_ : *default_instance_->gc_;
}
::cockroach::roachpb::GCResponse* ResponseUnion::mutable_gc() {
  set_has_gc();
  if (gc_ == NULL) {
    gc_ = new ::cockroach::roachpb::GCResponse;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.ResponseUnion.gc)
  return gc_;
}
::cockroach::roachpb::GCResponse* ResponseUnion::release_gc() {
  clear_has_gc();
  ::cockroach::roachpb::GCResponse* temp = gc_;
  gc_ = NULL;
  return temp;
}
void ResponseUnion::set_allocated_gc(::cockroach::roachpb::GCResponse* gc) {
  delete gc_;
  gc_ = gc;
  if (gc) {
    set_has_gc();
  } else {
    clear_has_gc();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.ResponseUnion.gc)
}

// optional .cockroach.roachpb.PushTxnResponse push_txn = 14;
bool ResponseUnion::has_push_txn() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
void ResponseUnion::set_has_push_txn() {
  _has_bits_[0] |= 0x00002000u;
}
void ResponseUnion::clear_has_push_txn() {
  _has_bits_[0] &= ~0x00002000u;
}
void ResponseUnion::clear_push_txn() {
  if (push_txn_ != NULL) push_txn_->::cockroach::roachpb::PushTxnResponse::Clear();
  clear_has_push_txn();
}
const ::cockroach::roachpb::PushTxnResponse& ResponseUnion::push_txn() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.ResponseUnion.push_txn)
  return push_txn_ != NULL ? *push_txn_ : *default_instance_->push_txn_;
}
::cockroach::roachpb::PushTxnResponse* ResponseUnion::mutable_push_txn() {
  set_has_push_txn();
  if (push_txn_ == NULL) {
    push_txn_ = new ::cockroach::roachpb::PushTxnResponse;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.ResponseUnion.push_txn)
  return push_txn_;
}
::cockroach::roachpb::PushTxnResponse* ResponseUnion::release_push_txn() {
  clear_has_push_txn();
  ::cockroach::roachpb::PushTxnResponse* temp = push_txn_;
  push_txn_ = NULL;
  return temp;
}
void ResponseUnion::set_allocated_push_txn(::cockroach::roachpb::PushTxnResponse* push_txn) {
  delete push_txn_;
  push_txn_ = push_txn;
  if (push_txn) {
    set_has_push_txn();
  } else {
    clear_has_push_txn();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.ResponseUnion.push_txn)
}

// optional .cockroach.roachpb.RangeLookupResponse range_lookup = 15;
bool ResponseUnion::has_range_lookup() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
void ResponseUnion::set_has_range_lookup() {
  _has_bits_[0] |= 0x00004000u;
}
void ResponseUnion::clear_has_range_lookup() {
  _has_bits_[0] &= ~0x00004000u;
}
void ResponseUnion::clear_range_lookup() {
  if (range_lookup_ != NULL) range_lookup_->::cockroach::roachpb::RangeLookupResponse::Clear();
  clear_has_range_lookup();
}
const ::cockroach::roachpb::RangeLookupResponse& ResponseUnion::range_lookup() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.ResponseUnion.range_lookup)
  return range_lookup_ != NULL ? *range_lookup_ : *default_instance_->range_lookup_;
}
::cockroach::roachpb::RangeLookupResponse* ResponseUnion::mutable_range_lookup() {
  set_has_range_lookup();
  if (range_lookup_ == NULL) {
    range_lookup_ = new ::cockroach::roachpb::RangeLookupResponse;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.ResponseUnion.range_lookup)
  return range_lookup_;
}
::cockroach::roachpb::RangeLookupResponse* ResponseUnion::release_range_lookup() {
  clear_has_range_lookup();
  ::cockroach::roachpb::RangeLookupResponse* temp = range_lookup_;
  range_lookup_ = NULL;
  return temp;
}
void ResponseUnion::set_allocated_range_lookup(::cockroach::roachpb::RangeLookupResponse* range_lookup) {
  delete range_lookup_;
  range_lookup_ = range_lookup;
  if (range_lookup) {
    set_has_range_lookup();
  } else {
    clear_has_range_lookup();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.ResponseUnion.range_lookup)
}

// optional .cockroach.roachpb.ResolveIntentResponse resolve_intent = 16;
bool ResponseUnion::has_resolve_intent() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
void ResponseUnion::set_has_resolve_intent() {
  _has_bits_[0] |= 0x00008000u;
}
void ResponseUnion::clear_has_resolve_intent() {
  _has_bits_[0] &= ~0x00008000u;
}
void ResponseUnion::clear_resolve_intent() {
  if (resolve_intent_ != NULL) resolve_intent_->::cockroach::roachpb::ResolveIntentResponse::Clear();
  clear_has_resolve_intent();
}
const ::cockroach::roachpb::ResolveIntentResponse& ResponseUnion::resolve_intent() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.ResponseUnion.resolve_intent)
  return resolve_intent_ != NULL ? *resolve_intent_ : *default_instance_->resolve_intent_;
}
::cockroach::roachpb::ResolveIntentResponse* ResponseUnion::mutable_resolve_intent() {
  set_has_resolve_intent();
  if (resolve_intent_ == NULL) {
    resolve_intent_ = new ::cockroach::roachpb::ResolveIntentResponse;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.ResponseUnion.resolve_intent)
  return resolve_intent_;
}
::cockroach::roachpb::ResolveIntentResponse* ResponseUnion::release_resolve_intent() {
  clear_has_resolve_intent();
  ::cockroach::roachpb::ResolveIntentResponse* temp = resolve_intent_;
  resolve_intent_ = NULL;
  return temp;
}
void ResponseUnion::set_allocated_resolve_intent(::cockroach::roachpb::ResolveIntentResponse* resolve_intent) {
  delete resolve_intent_;
  resolve_intent_ = resolve_intent;
  if (resolve_intent) {
    set_has_resolve_intent();
  } else {
    clear_has_resolve_intent();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.ResponseUnion.resolve_intent)
}

// optional .cockroach.roachpb.ResolveIntentRangeResponse resolve_intent_range = 17;
bool ResponseUnion::has_resolve_intent_range() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
void ResponseUnion::set_has_resolve_intent_range() {
  _has_bits_[0] |= 0x00010000u;
}
void ResponseUnion::clear_has_resolve_intent_range() {
  _has_bits_[0] &= ~0x00010000u;
}
void ResponseUnion::clear_resolve_intent_range() {
  if (resolve_intent_range_ != NULL) resolve_intent_range_->::cockroach::roachpb::ResolveIntentRangeResponse::Clear();
  clear_has_resolve_intent_range();
}
const ::cockroach::roachpb::ResolveIntentRangeResponse& ResponseUnion::resolve_intent_range() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.ResponseUnion.resolve_intent_range)
  return resolve_intent_range_ != NULL ? *resolve_intent_range_ : *default_instance_->resolve_intent_range_;
}
::cockroach::roachpb::ResolveIntentRangeResponse* ResponseUnion::mutable_resolve_intent_range() {
  set_has_resolve_intent_range();
  if (resolve_intent_range_ == NULL) {
    resolve_intent_range_ = new ::cockroach::roachpb::ResolveIntentRangeResponse;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.ResponseUnion.resolve_intent_range)
  return resolve_intent_range_;
}
::cockroach::roachpb::ResolveIntentRangeResponse* ResponseUnion::release_resolve_intent_range() {
  clear_has_resolve_intent_range();
  ::cockroach::roachpb::ResolveIntentRangeResponse* temp = resolve_intent_range_;
  resolve_intent_range_ = NULL;
  return temp;
}
void ResponseUnion::set_allocated_resolve_intent_range(::cockroach::roachpb::ResolveIntentRangeResponse* resolve_intent_range) {
  delete resolve_intent_range_;
  resolve_intent_range_ = resolve_intent_range;
  if (resolve_intent_range) {
    set_has_resolve_intent_range();
  } else {
    clear_has_resolve_intent_range();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.ResponseUnion.resolve_intent_range)
}

// optional .cockroach.roachpb.MergeResponse merge = 18;
bool ResponseUnion::has_merge() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
void ResponseUnion::set_has_merge() {
  _has_bits_[0] |= 0x00020000u;
}
void ResponseUnion::clear_has_merge() {
  _has_bits_[0] &= ~0x00020000u;
}
void ResponseUnion::clear_merge() {
  if (merge_ != NULL) merge_->::cockroach::roachpb::MergeResponse::Clear();
  clear_has_merge();
}
const ::cockroach::roachpb::MergeResponse& ResponseUnion::merge() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.ResponseUnion.merge)
  return merge_ != NULL ? *merge_ : *default_instance_->merge_;
}
::cockroach::roachpb::MergeResponse* ResponseUnion::mutable_merge() {
  set_has_merge();
  if (merge_ == NULL) {
    merge_ = new ::cockroach::roachpb::MergeResponse;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.ResponseUnion.merge)
  return merge_;
}
::cockroach::roachpb::MergeResponse* ResponseUnion::release_merge() {
  clear_has_merge();
  ::cockroach::roachpb::MergeResponse* temp = merge_;
  merge_ = NULL;
  return temp;
}
void ResponseUnion::set_allocated_merge(::cockroach::roachpb::MergeResponse* merge) {
  delete merge_;
  merge_ = merge;
  if (merge) {
    set_has_merge();
  } else {
    clear_has_merge();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.ResponseUnion.merge)
}

// optional .cockroach.roachpb.TruncateLogResponse truncate_log = 19;
bool ResponseUnion::has_truncate_log() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
void ResponseUnion::set_has_truncate_log() {
  _has_bits_[0] |= 0x00040000u;
}
void ResponseUnion::clear_has_truncate_log() {
  _has_bits_[0] &= ~0x00040000u;
}
void ResponseUnion::clear_truncate_log() {
  if (truncate_log_ != NULL) truncate_log_->::cockroach::roachpb::TruncateLogResponse::Clear();
  clear_has_truncate_log();
}
const ::cockroach::roachpb::TruncateLogResponse& ResponseUnion::truncate_log() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.ResponseUnion.truncate_log)
  return truncate_log_ != NULL ? *truncate_log_ : *default_instance_->truncate_log_;
}
::cockroach::roachpb::TruncateLogResponse* ResponseUnion::mutable_truncate_log() {
  set_has_truncate_log();
  if (truncate_log_ == NULL) {
    truncate_log_ = new ::cockroach::roachpb::TruncateLogResponse;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.ResponseUnion.truncate_log)
  return truncate_log_;
}
::cockroach::roachpb::TruncateLogResponse* ResponseUnion::release_truncate_log() {
  clear_has_truncate_log();
  ::cockroach::roachpb::TruncateLogResponse* temp = truncate_log_;
  truncate_log_ = NULL;
  return temp;
}
void ResponseUnion::set_allocated_truncate_log(::cockroach::roachpb::TruncateLogResponse* truncate_log) {
  delete truncate_log_;
  truncate_log_ = truncate_log;
  if (truncate_log) {
    set_has_truncate_log();
  } else {
    clear_has_truncate_log();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.ResponseUnion.truncate_log)
}

// optional .cockroach.roachpb.LeaderLeaseResponse leader_lease = 20;
bool ResponseUnion::has_leader_lease() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
void ResponseUnion::set_has_leader_lease() {
  _has_bits_[0] |= 0x00080000u;
}
void ResponseUnion::clear_has_leader_lease() {
  _has_bits_[0] &= ~0x00080000u;
}
void ResponseUnion::clear_leader_lease() {
  if (leader_lease_ != NULL) leader_lease_->::cockroach::roachpb::LeaderLeaseResponse::Clear();
  clear_has_leader_lease();
}
const ::cockroach::roachpb::LeaderLeaseResponse& ResponseUnion::leader_lease() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.ResponseUnion.leader_lease)
  return leader_lease_ != NULL ? *leader_lease_ : *default_instance_->leader_lease_;
}
::cockroach::roachpb::LeaderLeaseResponse* ResponseUnion::mutable_leader_lease() {
  set_has_leader_lease();
  if (leader_lease_ == NULL) {
    leader_lease_ = new ::cockroach::roachpb::LeaderLeaseResponse;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.ResponseUnion.leader_lease)
  return leader_lease_;
}
::cockroach::roachpb::LeaderLeaseResponse* ResponseUnion::release_leader_lease() {
  clear_has_leader_lease();
  ::cockroach::roachpb::LeaderLeaseResponse* temp = leader_lease_;
  leader_lease_ = NULL;
  return temp;
}
void ResponseUnion::set_allocated_leader_lease(::cockroach::roachpb::LeaderLeaseResponse* leader_lease) {
  delete leader_lease_;
  leader_lease_ = leader_lease;
  if (leader_lease) {
    set_has_leader_lease();
  } else {
    clear_has_leader_lease();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.ResponseUnion.leader_lease)
}

// optional .cockroach.roachpb.ReverseScanResponse reverse_scan = 21;
bool ResponseUnion::has_reverse_scan() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
void ResponseUnion::set_has_reverse_scan() {
  _has_bits_[0] |= 0x00100000u;
}
void ResponseUnion::clear_has_reverse_scan() {
  _has_bits_[0] &= ~0x00100000u;
}
void ResponseUnion::clear_reverse_scan() {
  if (reverse_scan_ != NULL) reverse_scan_->::cockroach::roachpb::ReverseScanResponse::Clear();
  clear_has_reverse_scan();
}
const ::cockroach::roachpb::ReverseScanResponse& ResponseUnion::reverse_scan() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.ResponseUnion.reverse_scan)
  return reverse_scan_ != NULL ? *reverse_scan_ : *default_instance_->reverse_scan_;
}
::cockroach::roachpb::ReverseScanResponse* ResponseUnion::mutable_reverse_scan() {
  set_has_reverse_scan();
  if (reverse_scan_ == NULL) {
    reverse_scan_ = new ::cockroach::roachpb::ReverseScanResponse;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.ResponseUnion.reverse_scan)
  return reverse_scan_;
}
::cockroach::roachpb::ReverseScanResponse* ResponseUnion::release_reverse_scan() {
  clear_has_reverse_scan();
  ::cockroach::roachpb::ReverseScanResponse* temp = reverse_scan_;
  reverse_scan_ = NULL;
  return temp;
}
void ResponseUnion::set_allocated_reverse_scan(::cockroach::roachpb::ReverseScanResponse* reverse_scan) {
  delete reverse_scan_;
  reverse_scan_ = reverse_scan;
  if (reverse_scan) {
    set_has_reverse_scan();
  } else {
    clear_has_reverse_scan();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.ResponseUnion.reverse_scan)
}

// optional .cockroach.roachpb.ComputeChecksumResponse compute_checksum = 22;
bool ResponseUnion::has_compute_checksum() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
void ResponseUnion::set_has_compute_checksum() {
  _has_bits_[0] |= 0x00200000u;
}
void ResponseUnion::clear_has_compute_checksum() {
  _has_bits_[0] &= ~0x00200000u;
}
void ResponseUnion::clear_compute_checksum() {
  if (compute_checksum_ != NULL) compute_checksum_->::cockroach::roachpb::ComputeChecksumResponse::Clear();
  clear_has_compute_checksum();
}
const ::cockroach::roachpb::ComputeChecksumResponse& ResponseUnion::compute_checksum() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.ResponseUnion.compute_checksum)
  return compute_checksum_ != NULL ? *compute_checksum_ : *default_instance_->compute_checksum_;
}
::cockroach::roachpb::ComputeChecksumResponse* ResponseUnion::mutable_compute_checksum() {
  set_has_compute_checksum();
  if (compute_checksum_ == NULL) {
    compute_checksum_ = new ::cockroach::roachpb::ComputeChecksumResponse;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.ResponseUnion.compute_checksum)
  return compute_checksum_;
}
::cockroach::roachpb::ComputeChecksumResponse* ResponseUnion::release_compute_checksum() {
  clear_has_compute_checksum();
  ::cockroach::roachpb::ComputeChecksumResponse* temp = compute_checksum_;
  compute_checksum_ = NULL;
  return temp;
}
void ResponseUnion::set_allocated_compute_checksum(::cockroach::roachpb::ComputeChecksumResponse* compute_checksum) {
  delete compute_checksum_;
  compute_checksum_ = compute_checksum;
  if (compute_checksum) {
    set_has_compute_checksum();
  } else {
    clear_has_compute_checksum();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.ResponseUnion.compute_checksum)
}

// optional .cockroach.roachpb.VerifyChecksumResponse verify_checksum = 23;
bool ResponseUnion::has_verify_checksum() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
void ResponseUnion::set_has_verify_checksum() {
  _has_bits_[0] |= 0x00400000u;
}
void ResponseUnion::clear_has_verify_checksum() {
  _has_bits_[0] &= ~0x00400000u;
}
void ResponseUnion::clear_verify_checksum() {
  if (verify_checksum_ != NULL) verify_checksum_->::cockroach::roachpb::VerifyChecksumResponse::Clear();
  clear_has_verify_checksum();
}
const ::cockroach::roachpb::VerifyChecksumResponse& ResponseUnion::verify_checksum() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.ResponseUnion.verify_checksum)
  return verify_checksum_ != NULL ? *verify_checksum_ : *default_instance_->verify_checksum_;
}
::cockroach::roachpb::VerifyChecksumResponse* ResponseUnion::mutable_verify_checksum() {
  set_has_verify_checksum();
  if (verify_checksum_ == NULL) {
    verify_checksum_ = new ::cockroach::roachpb::VerifyChecksumResponse;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.ResponseUnion.verify_checksum)
  return verify_checksum_;
}
::cockroach::roachpb::VerifyChecksumResponse* ResponseUnion::release_verify_checksum() {
  clear_has_verify_checksum();
  ::cockroach::roachpb::VerifyChecksumResponse* temp = verify_checksum_;
  verify_checksum_ = NULL;
  return temp;
}
void ResponseUnion::set_allocated_verify_checksum(::cockroach::roachpb::VerifyChecksumResponse* verify_checksum) {
  delete verify_checksum_;
  verify_checksum_ = verify_checksum;
  if (verify_checksum) {
    set_has_verify_checksum();
  } else {
    clear_has_verify_checksum();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.ResponseUnion.verify_checksum)
}

// optional .cockroach.roachpb.CheckConsistencyResponse check_consistency = 24;
bool ResponseUnion::has_check_consistency() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
void ResponseUnion::set_has_check_consistency() {
  _has_bits_[0] |= 0x00800000u;
}
void ResponseUnion::clear_has_check_consistency() {
  _has_bits_[0] &= ~0x00800000u;
}
void ResponseUnion::clear_check_consistency() {
  if (check_consistency_ != NULL) check_consistency_->::cockroach::roachpb::CheckConsistencyResponse::Clear();
  clear_has_check_consistency();
}
const ::cockroach::roachpb::CheckConsistencyResponse& ResponseUnion::check_consistency() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.ResponseUnion.check_consistency)
  return check_consistency_ != NULL ? *check_consistency_ : *default_instance_->check_consistency_;
}
::cockroach::roachpb::CheckConsistencyResponse* ResponseUnion::mutable_check_consistency() {
  set_has_check_consistency();
  if (check_consistency_ == NULL) {
    check_consistency_ = new ::cockroach::roachpb::CheckConsistencyResponse;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.ResponseUnion.check_consistency)
  return check_consistency_;
}
::cockroach::roachpb::CheckConsistencyResponse* ResponseUnion::release_check_consistency() {
  clear_has_check_consistency();
  ::cockroach::roachpb::CheckConsistencyResponse* temp = check_consistency_;
  check_consistency_ = NULL;
  return temp;
}
void ResponseUnion::set_allocated_check_consistency(::cockroach::roachpb::CheckConsistencyResponse* check_consistency) {
  delete check_consistency_;
  check_consistency_ = check_consistency;
  if (check_consistency) {
    set_has_check_consistency();
  } else {
    clear_has_check_consistency();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.ResponseUnion.check_consistency)
}

// optional .cockroach.roachpb.NoopResponse noop = 25;
bool ResponseUnion::has_noop() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
void ResponseUnion::set_has_noop() {
  _has_bits_[0] |= 0x01000000u;
}
void ResponseUnion::clear_has_noop() {
  _has_bits_[0] &= ~0x01000000u;
}
void ResponseUnion::clear_noop() {
  if (noop_ != NULL) noop_->::cockroach::roachpb::NoopResponse::Clear();
  clear_has_noop();
}
const ::cockroach::roachpb::NoopResponse& ResponseUnion::noop() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.ResponseUnion.noop)
  return noop_ != NULL ? *noop_ : *default_instance_->noop_;
}
::cockroach::roachpb::NoopResponse* ResponseUnion::mutable_noop() {
  set_has_noop();
  if (noop_ == NULL) {
    noop_ = new ::cockroach::roachpb::NoopResponse;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.ResponseUnion.noop)
  return noop_;
}
::cockroach::roachpb::NoopResponse* ResponseUnion::release_noop() {
  clear_has_noop();
  ::cockroach::roachpb::NoopResponse* temp = noop_;
  noop_ = NULL;
  return temp;
}
void ResponseUnion::set_allocated_noop(::cockroach::roachpb::NoopResponse* noop) {
  delete noop_;
  noop_ = noop;
  if (noop) {
    set_has_noop();
  } else {
    clear_has_noop();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.ResponseUnion.noop)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Header::kTimestampFieldNumber;
const int Header::kReplicaFieldNumber;
const int Header::kRangeIdFieldNumber;
const int Header::kUserPriorityFieldNumber;
const int Header::kTxnFieldNumber;
const int Header::kHeartbeatIntervalFieldNumber;
const int Header::kReadConsistencyFieldNumber;
const int Header::kTraceFieldNumber;
const int Header::kMaxScanResultsFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Header::Header()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:cockroach.roachpb.Header)
}

void Header::InitAsDefaultInstance() {
  timestamp_ = const_cast< ::cockroach::roachpb::Timestamp*>(&::cockroach::roachpb::Timestamp::default_instance());
  replica_ = const_cast< ::cockroach::roachpb::ReplicaDescriptor*>(&::cockroach::roachpb::ReplicaDescriptor::default_instance());
  txn_ = const_cast< ::cockroach::roachpb::Transaction*>(&::cockroach::roachpb::Transaction::default_instance());
  trace_ = const_cast< ::cockroach::util::tracing::Span*>(&::cockroach::util::tracing::Span::default_instance());
}

Header::Header(const Header& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:cockroach.roachpb.Header)
}

void Header::SharedCtor() {
  _cached_size_ = 0;
  timestamp_ = NULL;
  replica_ = NULL;
  range_id_ = GOOGLE_LONGLONG(0);
  user_priority_ = 0;
  txn_ = NULL;
  heartbeat_interval_ = GOOGLE_LONGLONG(0);
  read_consistency_ = 0;
  trace_ = NULL;
  max_scan_results_ = GOOGLE_LONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Header::~Header() {
  // @@protoc_insertion_point(destructor:cockroach.roachpb.Header)
  SharedDtor();
}

void Header::SharedDtor() {
  if (this != default_instance_) {
    delete timestamp_;
    delete replica_;
    delete txn_;
    delete trace_;
  }
}

void Header::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Header::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Header_descriptor_;
}

const Header& Header::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_cockroach_2froachpb_2fapi_2eproto();
  return *default_instance_;
}

Header* Header::default_instance_ = NULL;

Header* Header::New(::google::protobuf::Arena* arena) const {
  Header* n = new Header;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Header::Clear() {
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<Header*>(16)->f)

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  if (_has_bits_[0 / 32] & 255u) {
    ZR_(range_id_, user_priority_);
    if (has_timestamp()) {
      if (timestamp_ != NULL) timestamp_->::cockroach::roachpb::Timestamp::Clear();
    }
    if (has_replica()) {
      if (replica_ != NULL) replica_->::cockroach::roachpb::ReplicaDescriptor::Clear();
    }
    if (has_txn()) {
      if (txn_ != NULL) txn_->::cockroach::roachpb::Transaction::Clear();
    }
    heartbeat_interval_ = GOOGLE_LONGLONG(0);
    read_consistency_ = 0;
    if (has_trace()) {
      if (trace_ != NULL) trace_->::cockroach::util::tracing::Span::Clear();
    }
  }
  max_scan_results_ = GOOGLE_LONGLONG(0);

#undef ZR_HELPER_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool Header::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:cockroach.roachpb.Header)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .cockroach.roachpb.Timestamp timestamp = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_timestamp()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_replica;
        break;
      }

      // optional .cockroach.roachpb.ReplicaDescriptor replica = 2;
      case 2: {
        if (tag == 18) {
         parse_replica:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_replica()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_range_id;
        break;
      }

      // optional int64 range_id = 3;
      case 3: {
        if (tag == 24) {
         parse_range_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &range_id_)));
          set_has_range_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(33)) goto parse_user_priority;
        break;
      }

      // optional double user_priority = 4;
      case 4: {
        if (tag == 33) {
         parse_user_priority:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &user_priority_)));
          set_has_user_priority();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_txn;
        break;
      }

      // optional .cockroach.roachpb.Transaction txn = 5;
      case 5: {
        if (tag == 42) {
         parse_txn:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_txn()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(48)) goto parse_read_consistency;
        break;
      }

      // optional .cockroach.roachpb.ReadConsistencyType read_consistency = 6;
      case 6: {
        if (tag == 48) {
         parse_read_consistency:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::cockroach::roachpb::ReadConsistencyType_IsValid(value)) {
            set_read_consistency(static_cast< ::cockroach::roachpb::ReadConsistencyType >(value));
          } else {
            mutable_unknown_fields()->AddVarint(6, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(58)) goto parse_trace;
        break;
      }

      // optional .cockroach.util.tracing.Span trace = 7;
      case 7: {
        if (tag == 58) {
         parse_trace:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_trace()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(64)) goto parse_max_scan_results;
        break;
      }

      // optional int64 max_scan_results = 8;
      case 8: {
        if (tag == 64) {
         parse_max_scan_results:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &max_scan_results_)));
          set_has_max_scan_results();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(72)) goto parse_heartbeat_interval;
        break;
      }

      // optional int64 heartbeat_interval = 9;
      case 9: {
        if (tag == 72) {
         parse_heartbeat_interval:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &heartbeat_interval_)));
          set_has_heartbeat_interval();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:cockroach.roachpb.Header)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:cockroach.roachpb.Header)
  return false;
#undef DO_
}

void Header::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:cockroach.roachpb.Header)
  // optional .cockroach.roachpb.Timestamp timestamp = 1;
  if (has_timestamp()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->timestamp_, output);
  }

  // optional .cockroach.roachpb.ReplicaDescriptor replica = 2;
  if (has_replica()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, *this->replica_, output);
  }

  // optional int64 range_id = 3;
  if (has_range_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(3, this->range_id(), output);
  }

  // optional double user_priority = 4;
  if (has_user_priority()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(4, this->user_priority(), output);
  }

  // optional .cockroach.roachpb.Transaction txn = 5;
  if (has_txn()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      5, *this->txn_, output);
  }

  // optional .cockroach.roachpb.ReadConsistencyType read_consistency = 6;
  if (has_read_consistency()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      6, this->read_consistency(), output);
  }

  // optional .cockroach.util.tracing.Span trace = 7;
  if (has_trace()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      7, *this->trace_, output);
  }

  // optional int64 max_scan_results = 8;
  if (has_max_scan_results()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(8, this->max_scan_results(), output);
  }

  // optional int64 heartbeat_interval = 9;
  if (has_heartbeat_interval()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(9, this->heartbeat_interval(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:cockroach.roachpb.Header)
}

::google::protobuf::uint8* Header::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:cockroach.roachpb.Header)
  // optional .cockroach.roachpb.Timestamp timestamp = 1;
  if (has_timestamp()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, *this->timestamp_, target);
  }

  // optional .cockroach.roachpb.ReplicaDescriptor replica = 2;
  if (has_replica()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, *this->replica_, target);
  }

  // optional int64 range_id = 3;
  if (has_range_id()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(3, this->range_id(), target);
  }

  // optional double user_priority = 4;
  if (has_user_priority()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(4, this->user_priority(), target);
  }

  // optional .cockroach.roachpb.Transaction txn = 5;
  if (has_txn()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        5, *this->txn_, target);
  }

  // optional .cockroach.roachpb.ReadConsistencyType read_consistency = 6;
  if (has_read_consistency()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      6, this->read_consistency(), target);
  }

  // optional .cockroach.util.tracing.Span trace = 7;
  if (has_trace()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        7, *this->trace_, target);
  }

  // optional int64 max_scan_results = 8;
  if (has_max_scan_results()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(8, this->max_scan_results(), target);
  }

  // optional int64 heartbeat_interval = 9;
  if (has_heartbeat_interval()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(9, this->heartbeat_interval(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:cockroach.roachpb.Header)
  return target;
}

int Header::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & 255u) {
    // optional .cockroach.roachpb.Timestamp timestamp = 1;
    if (has_timestamp()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->timestamp_);
    }

    // optional .cockroach.roachpb.ReplicaDescriptor replica = 2;
    if (has_replica()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->replica_);
    }

    // optional int64 range_id = 3;
    if (has_range_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->range_id());
    }

    // optional double user_priority = 4;
    if (has_user_priority()) {
      total_size += 1 + 8;
    }

    // optional .cockroach.roachpb.Transaction txn = 5;
    if (has_txn()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->txn_);
    }

    // optional int64 heartbeat_interval = 9;
    if (has_heartbeat_interval()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->heartbeat_interval());
    }

    // optional .cockroach.roachpb.ReadConsistencyType read_consistency = 6;
    if (has_read_consistency()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->read_consistency());
    }

    // optional .cockroach.util.tracing.Span trace = 7;
    if (has_trace()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->trace_);
    }

  }
  // optional int64 max_scan_results = 8;
  if (has_max_scan_results()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int64Size(
        this->max_scan_results());
  }

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Header::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const Header* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const Header>(
          &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Header::MergeFrom(const Header& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_timestamp()) {
      mutable_timestamp()->::cockroach::roachpb::Timestamp::MergeFrom(from.timestamp());
    }
    if (from.has_replica()) {
      mutable_replica()->::cockroach::roachpb::ReplicaDescriptor::MergeFrom(from.replica());
    }
    if (from.has_range_id()) {
      set_range_id(from.range_id());
    }
    if (from.has_user_priority()) {
      set_user_priority(from.user_priority());
    }
    if (from.has_txn()) {
      mutable_txn()->::cockroach::roachpb::Transaction::MergeFrom(from.txn());
    }
    if (from.has_heartbeat_interval()) {
      set_heartbeat_interval(from.heartbeat_interval());
    }
    if (from.has_read_consistency()) {
      set_read_consistency(from.read_consistency());
    }
    if (from.has_trace()) {
      mutable_trace()->::cockroach::util::tracing::Span::MergeFrom(from.trace());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_max_scan_results()) {
      set_max_scan_results(from.max_scan_results());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void Header::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Header::CopyFrom(const Header& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Header::IsInitialized() const {

  return true;
}

void Header::Swap(Header* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Header::InternalSwap(Header* other) {
  std::swap(timestamp_, other->timestamp_);
  std::swap(replica_, other->replica_);
  std::swap(range_id_, other->range_id_);
  std::swap(user_priority_, other->user_priority_);
  std::swap(txn_, other->txn_);
  std::swap(heartbeat_interval_, other->heartbeat_interval_);
  std::swap(read_consistency_, other->read_consistency_);
  std::swap(trace_, other->trace_);
  std::swap(max_scan_results_, other->max_scan_results_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata Header::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Header_descriptor_;
  metadata.reflection = Header_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// Header

// optional .cockroach.roachpb.Timestamp timestamp = 1;
bool Header::has_timestamp() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void Header::set_has_timestamp() {
  _has_bits_[0] |= 0x00000001u;
}
void Header::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000001u;
}
void Header::clear_timestamp() {
  if (timestamp_ != NULL) timestamp_->::cockroach::roachpb::Timestamp::Clear();
  clear_has_timestamp();
}
const ::cockroach::roachpb::Timestamp& Header::timestamp() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.Header.timestamp)
  return timestamp_ != NULL ? *timestamp_ : *default_instance_->timestamp_;
}
::cockroach::roachpb::Timestamp* Header::mutable_timestamp() {
  set_has_timestamp();
  if (timestamp_ == NULL) {
    timestamp_ = new ::cockroach::roachpb::Timestamp;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.Header.timestamp)
  return timestamp_;
}
::cockroach::roachpb::Timestamp* Header::release_timestamp() {
  clear_has_timestamp();
  ::cockroach::roachpb::Timestamp* temp = timestamp_;
  timestamp_ = NULL;
  return temp;
}
void Header::set_allocated_timestamp(::cockroach::roachpb::Timestamp* timestamp) {
  delete timestamp_;
  timestamp_ = timestamp;
  if (timestamp) {
    set_has_timestamp();
  } else {
    clear_has_timestamp();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.Header.timestamp)
}

// optional .cockroach.roachpb.ReplicaDescriptor replica = 2;
bool Header::has_replica() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void Header::set_has_replica() {
  _has_bits_[0] |= 0x00000002u;
}
void Header::clear_has_replica() {
  _has_bits_[0] &= ~0x00000002u;
}
void Header::clear_replica() {
  if (replica_ != NULL) replica_->::cockroach::roachpb::ReplicaDescriptor::Clear();
  clear_has_replica();
}
const ::cockroach::roachpb::ReplicaDescriptor& Header::replica() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.Header.replica)
  return replica_ != NULL ? *replica_ : *default_instance_->replica_;
}
::cockroach::roachpb::ReplicaDescriptor* Header::mutable_replica() {
  set_has_replica();
  if (replica_ == NULL) {
    replica_ = new ::cockroach::roachpb::ReplicaDescriptor;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.Header.replica)
  return replica_;
}
::cockroach::roachpb::ReplicaDescriptor* Header::release_replica() {
  clear_has_replica();
  ::cockroach::roachpb::ReplicaDescriptor* temp = replica_;
  replica_ = NULL;
  return temp;
}
void Header::set_allocated_replica(::cockroach::roachpb::ReplicaDescriptor* replica) {
  delete replica_;
  replica_ = replica;
  if (replica) {
    set_has_replica();
  } else {
    clear_has_replica();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.Header.replica)
}

// optional int64 range_id = 3;
bool Header::has_range_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void Header::set_has_range_id() {
  _has_bits_[0] |= 0x00000004u;
}
void Header::clear_has_range_id() {
  _has_bits_[0] &= ~0x00000004u;
}
void Header::clear_range_id() {
  range_id_ = GOOGLE_LONGLONG(0);
  clear_has_range_id();
}
 ::google::protobuf::int64 Header::range_id() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.Header.range_id)
  return range_id_;
}
 void Header::set_range_id(::google::protobuf::int64 value) {
  set_has_range_id();
  range_id_ = value;
  // @@protoc_insertion_point(field_set:cockroach.roachpb.Header.range_id)
}

// optional double user_priority = 4;
bool Header::has_user_priority() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void Header::set_has_user_priority() {
  _has_bits_[0] |= 0x00000008u;
}
void Header::clear_has_user_priority() {
  _has_bits_[0] &= ~0x00000008u;
}
void Header::clear_user_priority() {
  user_priority_ = 0;
  clear_has_user_priority();
}
 double Header::user_priority() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.Header.user_priority)
  return user_priority_;
}
 void Header::set_user_priority(double value) {
  set_has_user_priority();
  user_priority_ = value;
  // @@protoc_insertion_point(field_set:cockroach.roachpb.Header.user_priority)
}

// optional .cockroach.roachpb.Transaction txn = 5;
bool Header::has_txn() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
void Header::set_has_txn() {
  _has_bits_[0] |= 0x00000010u;
}
void Header::clear_has_txn() {
  _has_bits_[0] &= ~0x00000010u;
}
void Header::clear_txn() {
  if (txn_ != NULL) txn_->::cockroach::roachpb::Transaction::Clear();
  clear_has_txn();
}
const ::cockroach::roachpb::Transaction& Header::txn() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.Header.txn)
  return txn_ != NULL ? *txn_ : *default_instance_->txn_;
}
::cockroach::roachpb::Transaction* Header::mutable_txn() {
  set_has_txn();
  if (txn_ == NULL) {
    txn_ = new ::cockroach::roachpb::Transaction;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.Header.txn)
  return txn_;
}
::cockroach::roachpb::Transaction* Header::release_txn() {
  clear_has_txn();
  ::cockroach::roachpb::Transaction* temp = txn_;
  txn_ = NULL;
  return temp;
}
void Header::set_allocated_txn(::cockroach::roachpb::Transaction* txn) {
  delete txn_;
  txn_ = txn;
  if (txn) {
    set_has_txn();
  } else {
    clear_has_txn();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.Header.txn)
}

// optional int64 heartbeat_interval = 9;
bool Header::has_heartbeat_interval() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
void Header::set_has_heartbeat_interval() {
  _has_bits_[0] |= 0x00000020u;
}
void Header::clear_has_heartbeat_interval() {
  _has_bits_[0] &= ~0x00000020u;
}
void Header::clear_heartbeat_interval() {
  heartbeat_interval_ = GOOGLE_LONGLONG(0);
  clear_has_heartbeat_interval();
}
 ::google::protobuf::int64 Header::heartbeat_interval() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.Header.heartbeat_interval)
  return heartbeat_interval_;
}
 void Header::set_heartbeat_interval(::google::protobuf::int64 value) {
  set_has_heartbeat_interval();
  heartbeat_interval_ = value;
  // @@protoc_insertion_point(field_set:cockroach.roachpb.Header.heartbeat_interval)
}

// optional .cockroach.roachpb.ReadConsistencyType read_consistency = 6;
bool Header::has_read_consistency() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
void Header::set_has_read_consistency() {
  _has_bits_[0] |= 0x00000040u;
}
void Header::clear_has_read_consistency() {
  _has_bits_[0] &= ~0x00000040u;
}
void Header::clear_read_consistency() {
  read_consistency_ = 0;
  clear_has_read_consistency();
}
 ::cockroach::roachpb::ReadConsistencyType Header::read_consistency() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.Header.read_consistency)
  return static_cast< ::cockroach::roachpb::ReadConsistencyType >(read_consistency_);
}
 void Header::set_read_consistency(::cockroach::roachpb::ReadConsistencyType value) {
  assert(::cockroach::roachpb::ReadConsistencyType_IsValid(value));
  set_has_read_consistency();
  read_consistency_ = value;
  // @@protoc_insertion_point(field_set:cockroach.roachpb.Header.read_consistency)
}

// optional .cockroach.util.tracing.Span trace = 7;
bool Header::has_trace() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
void Header::set_has_trace() {
  _has_bits_[0] |= 0x00000080u;
}
void Header::clear_has_trace() {
  _has_bits_[0] &= ~0x00000080u;
}
void Header::clear_trace() {
  if (trace_ != NULL) trace_->::cockroach::util::tracing::Span::Clear();
  clear_has_trace();
}
const ::cockroach::util::tracing::Span& Header::trace() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.Header.trace)
  return trace_ != NULL ? *trace_ : *default_instance_->trace_;
}
::cockroach::util::tracing::Span* Header::mutable_trace() {
  set_has_trace();
  if (trace_ == NULL) {
    trace_ = new ::cockroach::util::tracing::Span;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.Header.trace)
  return trace_;
}
::cockroach::util::tracing::Span* Header::release_trace() {
  clear_has_trace();
  ::cockroach::util::tracing::Span* temp = trace_;
  trace_ = NULL;
  return temp;
}
void Header::set_allocated_trace(::cockroach::util::tracing::Span* trace) {
  delete trace_;
  trace_ = trace;
  if (trace) {
    set_has_trace();
  } else {
    clear_has_trace();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.Header.trace)
}

// optional int64 max_scan_results = 8;
bool Header::has_max_scan_results() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
void Header::set_has_max_scan_results() {
  _has_bits_[0] |= 0x00000100u;
}
void Header::clear_has_max_scan_results() {
  _has_bits_[0] &= ~0x00000100u;
}
void Header::clear_max_scan_results() {
  max_scan_results_ = GOOGLE_LONGLONG(0);
  clear_has_max_scan_results();
}
 ::google::protobuf::int64 Header::max_scan_results() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.Header.max_scan_results)
  return max_scan_results_;
}
 void Header::set_max_scan_results(::google::protobuf::int64 value) {
  set_has_max_scan_results();
  max_scan_results_ = value;
  // @@protoc_insertion_point(field_set:cockroach.roachpb.Header.max_scan_results)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int BatchRequest::kHeaderFieldNumber;
const int BatchRequest::kRequestsFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

BatchRequest::BatchRequest()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:cockroach.roachpb.BatchRequest)
}

void BatchRequest::InitAsDefaultInstance() {
  header_ = const_cast< ::cockroach::roachpb::Header*>(&::cockroach::roachpb::Header::default_instance());
}

BatchRequest::BatchRequest(const BatchRequest& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:cockroach.roachpb.BatchRequest)
}

void BatchRequest::SharedCtor() {
  _cached_size_ = 0;
  header_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

BatchRequest::~BatchRequest() {
  // @@protoc_insertion_point(destructor:cockroach.roachpb.BatchRequest)
  SharedDtor();
}

void BatchRequest::SharedDtor() {
  if (this != default_instance_) {
    delete header_;
  }
}

void BatchRequest::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* BatchRequest::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return BatchRequest_descriptor_;
}

const BatchRequest& BatchRequest::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_cockroach_2froachpb_2fapi_2eproto();
  return *default_instance_;
}

BatchRequest* BatchRequest::default_instance_ = NULL;

BatchRequest* BatchRequest::New(::google::protobuf::Arena* arena) const {
  BatchRequest* n = new BatchRequest;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void BatchRequest::Clear() {
  if (has_header()) {
    if (header_ != NULL) header_->::cockroach::roachpb::Header::Clear();
  }
  requests_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool BatchRequest::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:cockroach.roachpb.BatchRequest)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .cockroach.roachpb.Header header = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_header()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_requests;
        break;
      }

      // repeated .cockroach.roachpb.RequestUnion requests = 2;
      case 2: {
        if (tag == 18) {
         parse_requests:
          DO_(input->IncrementRecursionDepth());
         parse_loop_requests:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                input, add_requests()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_loop_requests;
        input->UnsafeDecrementRecursionDepth();
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:cockroach.roachpb.BatchRequest)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:cockroach.roachpb.BatchRequest)
  return false;
#undef DO_
}

void BatchRequest::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:cockroach.roachpb.BatchRequest)
  // optional .cockroach.roachpb.Header header = 1;
  if (has_header()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->header_, output);
  }

  // repeated .cockroach.roachpb.RequestUnion requests = 2;
  for (unsigned int i = 0, n = this->requests_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->requests(i), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:cockroach.roachpb.BatchRequest)
}

::google::protobuf::uint8* BatchRequest::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:cockroach.roachpb.BatchRequest)
  // optional .cockroach.roachpb.Header header = 1;
  if (has_header()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, *this->header_, target);
  }

  // repeated .cockroach.roachpb.RequestUnion requests = 2;
  for (unsigned int i = 0, n = this->requests_size(); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->requests(i), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:cockroach.roachpb.BatchRequest)
  return target;
}

int BatchRequest::ByteSize() const {
  int total_size = 0;

  // optional .cockroach.roachpb.Header header = 1;
  if (has_header()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->header_);
  }

  // repeated .cockroach.roachpb.RequestUnion requests = 2;
  total_size += 1 * this->requests_size();
  for (int i = 0; i < this->requests_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->requests(i));
  }

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void BatchRequest::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const BatchRequest* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const BatchRequest>(
          &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void BatchRequest::MergeFrom(const BatchRequest& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  requests_.MergeFrom(from.requests_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_header()) {
      mutable_header()->::cockroach::roachpb::Header::MergeFrom(from.header());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void BatchRequest::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void BatchRequest::CopyFrom(const BatchRequest& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BatchRequest::IsInitialized() const {

  return true;
}

void BatchRequest::Swap(BatchRequest* other) {
  if (other == this) return;
  InternalSwap(other);
}
void BatchRequest::InternalSwap(BatchRequest* other) {
  std::swap(header_, other->header_);
  requests_.UnsafeArenaSwap(&other->requests_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata BatchRequest::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = BatchRequest_descriptor_;
  metadata.reflection = BatchRequest_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// BatchRequest

// optional .cockroach.roachpb.Header header = 1;
bool BatchRequest::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void BatchRequest::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
void BatchRequest::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
void BatchRequest::clear_header() {
  if (header_ != NULL) header_->::cockroach::roachpb::Header::Clear();
  clear_has_header();
}
const ::cockroach::roachpb::Header& BatchRequest::header() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.BatchRequest.header)
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
::cockroach::roachpb::Header* BatchRequest::mutable_header() {
  set_has_header();
  if (header_ == NULL) {
    header_ = new ::cockroach::roachpb::Header;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.BatchRequest.header)
  return header_;
}
::cockroach::roachpb::Header* BatchRequest::release_header() {
  clear_has_header();
  ::cockroach::roachpb::Header* temp = header_;
  header_ = NULL;
  return temp;
}
void BatchRequest::set_allocated_header(::cockroach::roachpb::Header* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.BatchRequest.header)
}

// repeated .cockroach.roachpb.RequestUnion requests = 2;
int BatchRequest::requests_size() const {
  return requests_.size();
}
void BatchRequest::clear_requests() {
  requests_.Clear();
}
const ::cockroach::roachpb::RequestUnion& BatchRequest::requests(int index) const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.BatchRequest.requests)
  return requests_.Get(index);
}
::cockroach::roachpb::RequestUnion* BatchRequest::mutable_requests(int index) {
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.BatchRequest.requests)
  return requests_.Mutable(index);
}
::cockroach::roachpb::RequestUnion* BatchRequest::add_requests() {
  // @@protoc_insertion_point(field_add:cockroach.roachpb.BatchRequest.requests)
  return requests_.Add();
}
::google::protobuf::RepeatedPtrField< ::cockroach::roachpb::RequestUnion >*
BatchRequest::mutable_requests() {
  // @@protoc_insertion_point(field_mutable_list:cockroach.roachpb.BatchRequest.requests)
  return &requests_;
}
const ::google::protobuf::RepeatedPtrField< ::cockroach::roachpb::RequestUnion >&
BatchRequest::requests() const {
  // @@protoc_insertion_point(field_list:cockroach.roachpb.BatchRequest.requests)
  return requests_;
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int BatchResponse_Header::kErrorFieldNumber;
const int BatchResponse_Header::kTxnFieldNumber;
const int BatchResponse_Header::kCollectedSpansFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

BatchResponse_Header::BatchResponse_Header()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:cockroach.roachpb.BatchResponse.Header)
}

void BatchResponse_Header::InitAsDefaultInstance() {
  error_ = const_cast< ::cockroach::roachpb::Error*>(&::cockroach::roachpb::Error::default_instance());
  txn_ = const_cast< ::cockroach::roachpb::Transaction*>(&::cockroach::roachpb::Transaction::default_instance());
}

BatchResponse_Header::BatchResponse_Header(const BatchResponse_Header& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:cockroach.roachpb.BatchResponse.Header)
}

void BatchResponse_Header::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  error_ = NULL;
  txn_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

BatchResponse_Header::~BatchResponse_Header() {
  // @@protoc_insertion_point(destructor:cockroach.roachpb.BatchResponse.Header)
  SharedDtor();
}

void BatchResponse_Header::SharedDtor() {
  if (this != default_instance_) {
    delete error_;
    delete txn_;
  }
}

void BatchResponse_Header::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* BatchResponse_Header::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return BatchResponse_Header_descriptor_;
}

const BatchResponse_Header& BatchResponse_Header::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_cockroach_2froachpb_2fapi_2eproto();
  return *default_instance_;
}

BatchResponse_Header* BatchResponse_Header::default_instance_ = NULL;

BatchResponse_Header* BatchResponse_Header::New(::google::protobuf::Arena* arena) const {
  BatchResponse_Header* n = new BatchResponse_Header;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void BatchResponse_Header::Clear() {
  if (_has_bits_[0 / 32] & 3u) {
    if (has_error()) {
      if (error_ != NULL) error_->::cockroach::roachpb::Error::Clear();
    }
    if (has_txn()) {
      if (txn_ != NULL) txn_->::cockroach::roachpb::Transaction::Clear();
    }
  }
  collected_spans_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool BatchResponse_Header::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:cockroach.roachpb.BatchResponse.Header)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .cockroach.roachpb.Error error = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_error()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_txn;
        break;
      }

      // optional .cockroach.roachpb.Transaction txn = 3;
      case 3: {
        if (tag == 26) {
         parse_txn:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_txn()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_collected_spans;
        break;
      }

      // repeated bytes collected_spans = 4;
      case 4: {
        if (tag == 34) {
         parse_collected_spans:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->add_collected_spans()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_collected_spans;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:cockroach.roachpb.BatchResponse.Header)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:cockroach.roachpb.BatchResponse.Header)
  return false;
#undef DO_
}

void BatchResponse_Header::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:cockroach.roachpb.BatchResponse.Header)
  // optional .cockroach.roachpb.Error error = 1;
  if (has_error()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->error_, output);
  }

  // optional .cockroach.roachpb.Transaction txn = 3;
  if (has_txn()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, *this->txn_, output);
  }

  // repeated bytes collected_spans = 4;
  for (int i = 0; i < this->collected_spans_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      4, this->collected_spans(i), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:cockroach.roachpb.BatchResponse.Header)
}

::google::protobuf::uint8* BatchResponse_Header::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:cockroach.roachpb.BatchResponse.Header)
  // optional .cockroach.roachpb.Error error = 1;
  if (has_error()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, *this->error_, target);
  }

  // optional .cockroach.roachpb.Transaction txn = 3;
  if (has_txn()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, *this->txn_, target);
  }

  // repeated bytes collected_spans = 4;
  for (int i = 0; i < this->collected_spans_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteBytesToArray(4, this->collected_spans(i), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:cockroach.roachpb.BatchResponse.Header)
  return target;
}

int BatchResponse_Header::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & 3u) {
    // optional .cockroach.roachpb.Error error = 1;
    if (has_error()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->error_);
    }

    // optional .cockroach.roachpb.Transaction txn = 3;
    if (has_txn()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->txn_);
    }

  }
  // repeated bytes collected_spans = 4;
  total_size += 1 * this->collected_spans_size();
  for (int i = 0; i < this->collected_spans_size(); i++) {
    total_size += ::google::protobuf::internal::WireFormatLite::BytesSize(
      this->collected_spans(i));
  }

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void BatchResponse_Header::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const BatchResponse_Header* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const BatchResponse_Header>(
          &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void BatchResponse_Header::MergeFrom(const BatchResponse_Header& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  collected_spans_.MergeFrom(from.collected_spans_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_error()) {
      mutable_error()->::cockroach::roachpb::Error::MergeFrom(from.error());
    }
    if (from.has_txn()) {
      mutable_txn()->::cockroach::roachpb::Transaction::MergeFrom(from.txn());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void BatchResponse_Header::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void BatchResponse_Header::CopyFrom(const BatchResponse_Header& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BatchResponse_Header::IsInitialized() const {

  return true;
}

void BatchResponse_Header::Swap(BatchResponse_Header* other) {
  if (other == this) return;
  InternalSwap(other);
}
void BatchResponse_Header::InternalSwap(BatchResponse_Header* other) {
  std::swap(error_, other->error_);
  std::swap(txn_, other->txn_);
  collected_spans_.UnsafeArenaSwap(&other->collected_spans_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata BatchResponse_Header::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = BatchResponse_Header_descriptor_;
  metadata.reflection = BatchResponse_Header_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int BatchResponse::kHeaderFieldNumber;
const int BatchResponse::kResponsesFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

BatchResponse::BatchResponse()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:cockroach.roachpb.BatchResponse)
}

void BatchResponse::InitAsDefaultInstance() {
  header_ = const_cast< ::cockroach::roachpb::BatchResponse_Header*>(&::cockroach::roachpb::BatchResponse_Header::default_instance());
}

BatchResponse::BatchResponse(const BatchResponse& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:cockroach.roachpb.BatchResponse)
}

void BatchResponse::SharedCtor() {
  _cached_size_ = 0;
  header_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

BatchResponse::~BatchResponse() {
  // @@protoc_insertion_point(destructor:cockroach.roachpb.BatchResponse)
  SharedDtor();
}

void BatchResponse::SharedDtor() {
  if (this != default_instance_) {
    delete header_;
  }
}

void BatchResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* BatchResponse::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return BatchResponse_descriptor_;
}

const BatchResponse& BatchResponse::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_cockroach_2froachpb_2fapi_2eproto();
  return *default_instance_;
}

BatchResponse* BatchResponse::default_instance_ = NULL;

BatchResponse* BatchResponse::New(::google::protobuf::Arena* arena) const {
  BatchResponse* n = new BatchResponse;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void BatchResponse::Clear() {
  if (has_header()) {
    if (header_ != NULL) header_->::cockroach::roachpb::BatchResponse_Header::Clear();
  }
  responses_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool BatchResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:cockroach.roachpb.BatchResponse)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .cockroach.roachpb.BatchResponse.Header header = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_header()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_responses;
        break;
      }

      // repeated .cockroach.roachpb.ResponseUnion responses = 2;
      case 2: {
        if (tag == 18) {
         parse_responses:
          DO_(input->IncrementRecursionDepth());
         parse_loop_responses:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                input, add_responses()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_loop_responses;
        input->UnsafeDecrementRecursionDepth();
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:cockroach.roachpb.BatchResponse)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:cockroach.roachpb.BatchResponse)
  return false;
#undef DO_
}

void BatchResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:cockroach.roachpb.BatchResponse)
  // optional .cockroach.roachpb.BatchResponse.Header header = 1;
  if (has_header()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->header_, output);
  }

  // repeated .cockroach.roachpb.ResponseUnion responses = 2;
  for (unsigned int i = 0, n = this->responses_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->responses(i), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:cockroach.roachpb.BatchResponse)
}

::google::protobuf::uint8* BatchResponse::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:cockroach.roachpb.BatchResponse)
  // optional .cockroach.roachpb.BatchResponse.Header header = 1;
  if (has_header()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, *this->header_, target);
  }

  // repeated .cockroach.roachpb.ResponseUnion responses = 2;
  for (unsigned int i = 0, n = this->responses_size(); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->responses(i), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:cockroach.roachpb.BatchResponse)
  return target;
}

int BatchResponse::ByteSize() const {
  int total_size = 0;

  // optional .cockroach.roachpb.BatchResponse.Header header = 1;
  if (has_header()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->header_);
  }

  // repeated .cockroach.roachpb.ResponseUnion responses = 2;
  total_size += 1 * this->responses_size();
  for (int i = 0; i < this->responses_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->responses(i));
  }

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void BatchResponse::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const BatchResponse* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const BatchResponse>(
          &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void BatchResponse::MergeFrom(const BatchResponse& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  responses_.MergeFrom(from.responses_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_header()) {
      mutable_header()->::cockroach::roachpb::BatchResponse_Header::MergeFrom(from.header());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void BatchResponse::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void BatchResponse::CopyFrom(const BatchResponse& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BatchResponse::IsInitialized() const {

  return true;
}

void BatchResponse::Swap(BatchResponse* other) {
  if (other == this) return;
  InternalSwap(other);
}
void BatchResponse::InternalSwap(BatchResponse* other) {
  std::swap(header_, other->header_);
  responses_.UnsafeArenaSwap(&other->responses_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata BatchResponse::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = BatchResponse_descriptor_;
  metadata.reflection = BatchResponse_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// BatchResponse_Header

// optional .cockroach.roachpb.Error error = 1;
bool BatchResponse_Header::has_error() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void BatchResponse_Header::set_has_error() {
  _has_bits_[0] |= 0x00000001u;
}
void BatchResponse_Header::clear_has_error() {
  _has_bits_[0] &= ~0x00000001u;
}
void BatchResponse_Header::clear_error() {
  if (error_ != NULL) error_->::cockroach::roachpb::Error::Clear();
  clear_has_error();
}
const ::cockroach::roachpb::Error& BatchResponse_Header::error() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.BatchResponse.Header.error)
  return error_ != NULL ? *error_ : *default_instance_->error_;
}
::cockroach::roachpb::Error* BatchResponse_Header::mutable_error() {
  set_has_error();
  if (error_ == NULL) {
    error_ = new ::cockroach::roachpb::Error;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.BatchResponse.Header.error)
  return error_;
}
::cockroach::roachpb::Error* BatchResponse_Header::release_error() {
  clear_has_error();
  ::cockroach::roachpb::Error* temp = error_;
  error_ = NULL;
  return temp;
}
void BatchResponse_Header::set_allocated_error(::cockroach::roachpb::Error* error) {
  delete error_;
  error_ = error;
  if (error) {
    set_has_error();
  } else {
    clear_has_error();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.BatchResponse.Header.error)
}

// optional .cockroach.roachpb.Transaction txn = 3;
bool BatchResponse_Header::has_txn() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void BatchResponse_Header::set_has_txn() {
  _has_bits_[0] |= 0x00000002u;
}
void BatchResponse_Header::clear_has_txn() {
  _has_bits_[0] &= ~0x00000002u;
}
void BatchResponse_Header::clear_txn() {
  if (txn_ != NULL) txn_->::cockroach::roachpb::Transaction::Clear();
  clear_has_txn();
}
const ::cockroach::roachpb::Transaction& BatchResponse_Header::txn() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.BatchResponse.Header.txn)
  return txn_ != NULL ? *txn_ : *default_instance_->txn_;
}
::cockroach::roachpb::Transaction* BatchResponse_Header::mutable_txn() {
  set_has_txn();
  if (txn_ == NULL) {
    txn_ = new ::cockroach::roachpb::Transaction;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.BatchResponse.Header.txn)
  return txn_;
}
::cockroach::roachpb::Transaction* BatchResponse_Header::release_txn() {
  clear_has_txn();
  ::cockroach::roachpb::Transaction* temp = txn_;
  txn_ = NULL;
  return temp;
}
void BatchResponse_Header::set_allocated_txn(::cockroach::roachpb::Transaction* txn) {
  delete txn_;
  txn_ = txn;
  if (txn) {
    set_has_txn();
  } else {
    clear_has_txn();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.BatchResponse.Header.txn)
}

// repeated bytes collected_spans = 4;
int BatchResponse_Header::collected_spans_size() const {
  return collected_spans_.size();
}
void BatchResponse_Header::clear_collected_spans() {
  collected_spans_.Clear();
}
 const ::std::string& BatchResponse_Header::collected_spans(int index) const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.BatchResponse.Header.collected_spans)
  return collected_spans_.Get(index);
}
 ::std::string* BatchResponse_Header::mutable_collected_spans(int index) {
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.BatchResponse.Header.collected_spans)
  return collected_spans_.Mutable(index);
}
 void BatchResponse_Header::set_collected_spans(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:cockroach.roachpb.BatchResponse.Header.collected_spans)
  collected_spans_.Mutable(index)->assign(value);
}
 void BatchResponse_Header::set_collected_spans(int index, const char* value) {
  collected_spans_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:cockroach.roachpb.BatchResponse.Header.collected_spans)
}
 void BatchResponse_Header::set_collected_spans(int index, const void* value, size_t size) {
  collected_spans_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:cockroach.roachpb.BatchResponse.Header.collected_spans)
}
 ::std::string* BatchResponse_Header::add_collected_spans() {
  return collected_spans_.Add();
}
 void BatchResponse_Header::add_collected_spans(const ::std::string& value) {
  collected_spans_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:cockroach.roachpb.BatchResponse.Header.collected_spans)
}
 void BatchResponse_Header::add_collected_spans(const char* value) {
  collected_spans_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:cockroach.roachpb.BatchResponse.Header.collected_spans)
}
 void BatchResponse_Header::add_collected_spans(const void* value, size_t size) {
  collected_spans_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:cockroach.roachpb.BatchResponse.Header.collected_spans)
}
 const ::google::protobuf::RepeatedPtrField< ::std::string>&
BatchResponse_Header::collected_spans() const {
  // @@protoc_insertion_point(field_list:cockroach.roachpb.BatchResponse.Header.collected_spans)
  return collected_spans_;
}
 ::google::protobuf::RepeatedPtrField< ::std::string>*
BatchResponse_Header::mutable_collected_spans() {
  // @@protoc_insertion_point(field_mutable_list:cockroach.roachpb.BatchResponse.Header.collected_spans)
  return &collected_spans_;
}

// -------------------------------------------------------------------

// BatchResponse

// optional .cockroach.roachpb.BatchResponse.Header header = 1;
bool BatchResponse::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void BatchResponse::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
void BatchResponse::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
void BatchResponse::clear_header() {
  if (header_ != NULL) header_->::cockroach::roachpb::BatchResponse_Header::Clear();
  clear_has_header();
}
const ::cockroach::roachpb::BatchResponse_Header& BatchResponse::header() const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.BatchResponse.header)
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
::cockroach::roachpb::BatchResponse_Header* BatchResponse::mutable_header() {
  set_has_header();
  if (header_ == NULL) {
    header_ = new ::cockroach::roachpb::BatchResponse_Header;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.BatchResponse.header)
  return header_;
}
::cockroach::roachpb::BatchResponse_Header* BatchResponse::release_header() {
  clear_has_header();
  ::cockroach::roachpb::BatchResponse_Header* temp = header_;
  header_ = NULL;
  return temp;
}
void BatchResponse::set_allocated_header(::cockroach::roachpb::BatchResponse_Header* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.roachpb.BatchResponse.header)
}

// repeated .cockroach.roachpb.ResponseUnion responses = 2;
int BatchResponse::responses_size() const {
  return responses_.size();
}
void BatchResponse::clear_responses() {
  responses_.Clear();
}
const ::cockroach::roachpb::ResponseUnion& BatchResponse::responses(int index) const {
  // @@protoc_insertion_point(field_get:cockroach.roachpb.BatchResponse.responses)
  return responses_.Get(index);
}
::cockroach::roachpb::ResponseUnion* BatchResponse::mutable_responses(int index) {
  // @@protoc_insertion_point(field_mutable:cockroach.roachpb.BatchResponse.responses)
  return responses_.Mutable(index);
}
::cockroach::roachpb::ResponseUnion* BatchResponse::add_responses() {
  // @@protoc_insertion_point(field_add:cockroach.roachpb.BatchResponse.responses)
  return responses_.Add();
}
::google::protobuf::RepeatedPtrField< ::cockroach::roachpb::ResponseUnion >*
BatchResponse::mutable_responses() {
  // @@protoc_insertion_point(field_mutable_list:cockroach.roachpb.BatchResponse.responses)
  return &responses_;
}
const ::google::protobuf::RepeatedPtrField< ::cockroach::roachpb::ResponseUnion >&
BatchResponse::responses() const {
  // @@protoc_insertion_point(field_list:cockroach.roachpb.BatchResponse.responses)
  return responses_;
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// @@protoc_insertion_point(namespace_scope)

}  // namespace roachpb
}  // namespace cockroach

// @@protoc_insertion_point(global_scope)
