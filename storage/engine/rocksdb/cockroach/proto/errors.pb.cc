// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: cockroach/proto/errors.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "cockroach/proto/errors.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)

namespace cockroach {
namespace proto {

namespace {

const ::google::protobuf::Descriptor* NotLeaderError_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  NotLeaderError_reflection_ = NULL;
const ::google::protobuf::Descriptor* NodeUnavailableError_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  NodeUnavailableError_reflection_ = NULL;
const ::google::protobuf::Descriptor* RangeNotFoundError_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  RangeNotFoundError_reflection_ = NULL;
const ::google::protobuf::Descriptor* RangeKeyMismatchError_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  RangeKeyMismatchError_reflection_ = NULL;
const ::google::protobuf::Descriptor* ReadWithinUncertaintyIntervalError_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ReadWithinUncertaintyIntervalError_reflection_ = NULL;
const ::google::protobuf::Descriptor* TransactionAbortedError_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  TransactionAbortedError_reflection_ = NULL;
const ::google::protobuf::Descriptor* TransactionPushError_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  TransactionPushError_reflection_ = NULL;
const ::google::protobuf::Descriptor* TransactionRetryError_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  TransactionRetryError_reflection_ = NULL;
const ::google::protobuf::Descriptor* TransactionStatusError_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  TransactionStatusError_reflection_ = NULL;
const ::google::protobuf::Descriptor* WriteIntentError_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  WriteIntentError_reflection_ = NULL;
const ::google::protobuf::Descriptor* WriteTooOldError_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  WriteTooOldError_reflection_ = NULL;
const ::google::protobuf::Descriptor* OpRequiresTxnError_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  OpRequiresTxnError_reflection_ = NULL;
const ::google::protobuf::Descriptor* ConditionFailedError_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ConditionFailedError_reflection_ = NULL;
const ::google::protobuf::Descriptor* LeaseRejectedError_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  LeaseRejectedError_reflection_ = NULL;
const ::google::protobuf::Descriptor* ErrorDetail_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ErrorDetail_reflection_ = NULL;
const ::google::protobuf::Descriptor* Error_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Error_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* TransactionRestart_descriptor_ = NULL;

}  // namespace


void protobuf_AssignDesc_cockroach_2fproto_2ferrors_2eproto() {
  protobuf_AddDesc_cockroach_2fproto_2ferrors_2eproto();
  const ::google::protobuf::FileDescriptor* file =
    ::google::protobuf::DescriptorPool::generated_pool()->FindFileByName(
      "cockroach/proto/errors.proto");
  GOOGLE_CHECK(file != NULL);
  NotLeaderError_descriptor_ = file->message_type(0);
  static const int NotLeaderError_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NotLeaderError, replica_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NotLeaderError, leader_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NotLeaderError, range_id_),
  };
  NotLeaderError_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      NotLeaderError_descriptor_,
      NotLeaderError::default_instance_,
      NotLeaderError_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NotLeaderError, _has_bits_[0]),
      -1,
      -1,
      sizeof(NotLeaderError),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NotLeaderError, _internal_metadata_),
      -1);
  NodeUnavailableError_descriptor_ = file->message_type(1);
  static const int NodeUnavailableError_offsets_[1] = {
  };
  NodeUnavailableError_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      NodeUnavailableError_descriptor_,
      NodeUnavailableError::default_instance_,
      NodeUnavailableError_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NodeUnavailableError, _has_bits_[0]),
      -1,
      -1,
      sizeof(NodeUnavailableError),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NodeUnavailableError, _internal_metadata_),
      -1);
  RangeNotFoundError_descriptor_ = file->message_type(2);
  static const int RangeNotFoundError_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RangeNotFoundError, range_id_),
  };
  RangeNotFoundError_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      RangeNotFoundError_descriptor_,
      RangeNotFoundError::default_instance_,
      RangeNotFoundError_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RangeNotFoundError, _has_bits_[0]),
      -1,
      -1,
      sizeof(RangeNotFoundError),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RangeNotFoundError, _internal_metadata_),
      -1);
  RangeKeyMismatchError_descriptor_ = file->message_type(3);
  static const int RangeKeyMismatchError_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RangeKeyMismatchError, request_start_key_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RangeKeyMismatchError, request_end_key_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RangeKeyMismatchError, range_),
  };
  RangeKeyMismatchError_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      RangeKeyMismatchError_descriptor_,
      RangeKeyMismatchError::default_instance_,
      RangeKeyMismatchError_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RangeKeyMismatchError, _has_bits_[0]),
      -1,
      -1,
      sizeof(RangeKeyMismatchError),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RangeKeyMismatchError, _internal_metadata_),
      -1);
  ReadWithinUncertaintyIntervalError_descriptor_ = file->message_type(4);
  static const int ReadWithinUncertaintyIntervalError_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReadWithinUncertaintyIntervalError, timestamp_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReadWithinUncertaintyIntervalError, existing_timestamp_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReadWithinUncertaintyIntervalError, node_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReadWithinUncertaintyIntervalError, txn_),
  };
  ReadWithinUncertaintyIntervalError_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      ReadWithinUncertaintyIntervalError_descriptor_,
      ReadWithinUncertaintyIntervalError::default_instance_,
      ReadWithinUncertaintyIntervalError_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReadWithinUncertaintyIntervalError, _has_bits_[0]),
      -1,
      -1,
      sizeof(ReadWithinUncertaintyIntervalError),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReadWithinUncertaintyIntervalError, _internal_metadata_),
      -1);
  TransactionAbortedError_descriptor_ = file->message_type(5);
  static const int TransactionAbortedError_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TransactionAbortedError, txn_),
  };
  TransactionAbortedError_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      TransactionAbortedError_descriptor_,
      TransactionAbortedError::default_instance_,
      TransactionAbortedError_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TransactionAbortedError, _has_bits_[0]),
      -1,
      -1,
      sizeof(TransactionAbortedError),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TransactionAbortedError, _internal_metadata_),
      -1);
  TransactionPushError_descriptor_ = file->message_type(6);
  static const int TransactionPushError_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TransactionPushError, txn_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TransactionPushError, pushee_txn_),
  };
  TransactionPushError_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      TransactionPushError_descriptor_,
      TransactionPushError::default_instance_,
      TransactionPushError_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TransactionPushError, _has_bits_[0]),
      -1,
      -1,
      sizeof(TransactionPushError),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TransactionPushError, _internal_metadata_),
      -1);
  TransactionRetryError_descriptor_ = file->message_type(7);
  static const int TransactionRetryError_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TransactionRetryError, txn_),
  };
  TransactionRetryError_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      TransactionRetryError_descriptor_,
      TransactionRetryError::default_instance_,
      TransactionRetryError_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TransactionRetryError, _has_bits_[0]),
      -1,
      -1,
      sizeof(TransactionRetryError),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TransactionRetryError, _internal_metadata_),
      -1);
  TransactionStatusError_descriptor_ = file->message_type(8);
  static const int TransactionStatusError_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TransactionStatusError, txn_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TransactionStatusError, msg_),
  };
  TransactionStatusError_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      TransactionStatusError_descriptor_,
      TransactionStatusError::default_instance_,
      TransactionStatusError_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TransactionStatusError, _has_bits_[0]),
      -1,
      -1,
      sizeof(TransactionStatusError),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TransactionStatusError, _internal_metadata_),
      -1);
  WriteIntentError_descriptor_ = file->message_type(9);
  static const int WriteIntentError_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(WriteIntentError, intents_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(WriteIntentError, resolved_),
  };
  WriteIntentError_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      WriteIntentError_descriptor_,
      WriteIntentError::default_instance_,
      WriteIntentError_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(WriteIntentError, _has_bits_[0]),
      -1,
      -1,
      sizeof(WriteIntentError),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(WriteIntentError, _internal_metadata_),
      -1);
  WriteTooOldError_descriptor_ = file->message_type(10);
  static const int WriteTooOldError_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(WriteTooOldError, timestamp_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(WriteTooOldError, existing_timestamp_),
  };
  WriteTooOldError_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      WriteTooOldError_descriptor_,
      WriteTooOldError::default_instance_,
      WriteTooOldError_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(WriteTooOldError, _has_bits_[0]),
      -1,
      -1,
      sizeof(WriteTooOldError),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(WriteTooOldError, _internal_metadata_),
      -1);
  OpRequiresTxnError_descriptor_ = file->message_type(11);
  static const int OpRequiresTxnError_offsets_[1] = {
  };
  OpRequiresTxnError_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      OpRequiresTxnError_descriptor_,
      OpRequiresTxnError::default_instance_,
      OpRequiresTxnError_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(OpRequiresTxnError, _has_bits_[0]),
      -1,
      -1,
      sizeof(OpRequiresTxnError),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(OpRequiresTxnError, _internal_metadata_),
      -1);
  ConditionFailedError_descriptor_ = file->message_type(12);
  static const int ConditionFailedError_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ConditionFailedError, actual_value_),
  };
  ConditionFailedError_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      ConditionFailedError_descriptor_,
      ConditionFailedError::default_instance_,
      ConditionFailedError_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ConditionFailedError, _has_bits_[0]),
      -1,
      -1,
      sizeof(ConditionFailedError),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ConditionFailedError, _internal_metadata_),
      -1);
  LeaseRejectedError_descriptor_ = file->message_type(13);
  static const int LeaseRejectedError_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LeaseRejectedError, requested_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LeaseRejectedError, existing_),
  };
  LeaseRejectedError_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      LeaseRejectedError_descriptor_,
      LeaseRejectedError::default_instance_,
      LeaseRejectedError_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LeaseRejectedError, _has_bits_[0]),
      -1,
      -1,
      sizeof(LeaseRejectedError),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LeaseRejectedError, _internal_metadata_),
      -1);
  ErrorDetail_descriptor_ = file->message_type(14);
  static const int ErrorDetail_offsets_[14] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ErrorDetail, not_leader_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ErrorDetail, range_not_found_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ErrorDetail, range_key_mismatch_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ErrorDetail, read_within_uncertainty_interval_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ErrorDetail, transaction_aborted_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ErrorDetail, transaction_push_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ErrorDetail, transaction_retry_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ErrorDetail, transaction_status_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ErrorDetail, write_intent_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ErrorDetail, write_too_old_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ErrorDetail, op_requires_txn_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ErrorDetail, condition_failed_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ErrorDetail, lease_rejected_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ErrorDetail, node_unavailable_),
  };
  ErrorDetail_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      ErrorDetail_descriptor_,
      ErrorDetail::default_instance_,
      ErrorDetail_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ErrorDetail, _has_bits_[0]),
      -1,
      -1,
      sizeof(ErrorDetail),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ErrorDetail, _internal_metadata_),
      -1);
  Error_descriptor_ = file->message_type(15);
  static const int Error_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Error, message_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Error, retryable_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Error, transaction_restart_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Error, detail_),
  };
  Error_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      Error_descriptor_,
      Error::default_instance_,
      Error_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Error, _has_bits_[0]),
      -1,
      -1,
      sizeof(Error),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Error, _internal_metadata_),
      -1);
  TransactionRestart_descriptor_ = file->enum_type(0);
}

namespace {

GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AssignDescriptors_once_);
inline void protobuf_AssignDescriptorsOnce() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AssignDescriptors_once_,
                 &protobuf_AssignDesc_cockroach_2fproto_2ferrors_2eproto);
}

void protobuf_RegisterTypes(const ::std::string&) {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      NotLeaderError_descriptor_, &NotLeaderError::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      NodeUnavailableError_descriptor_, &NodeUnavailableError::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      RangeNotFoundError_descriptor_, &RangeNotFoundError::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      RangeKeyMismatchError_descriptor_, &RangeKeyMismatchError::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      ReadWithinUncertaintyIntervalError_descriptor_, &ReadWithinUncertaintyIntervalError::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      TransactionAbortedError_descriptor_, &TransactionAbortedError::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      TransactionPushError_descriptor_, &TransactionPushError::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      TransactionRetryError_descriptor_, &TransactionRetryError::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      TransactionStatusError_descriptor_, &TransactionStatusError::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      WriteIntentError_descriptor_, &WriteIntentError::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      WriteTooOldError_descriptor_, &WriteTooOldError::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      OpRequiresTxnError_descriptor_, &OpRequiresTxnError::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      ConditionFailedError_descriptor_, &ConditionFailedError::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      LeaseRejectedError_descriptor_, &LeaseRejectedError::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      ErrorDetail_descriptor_, &ErrorDetail::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      Error_descriptor_, &Error::default_instance());
}

}  // namespace

void protobuf_ShutdownFile_cockroach_2fproto_2ferrors_2eproto() {
  delete NotLeaderError::default_instance_;
  delete NotLeaderError_reflection_;
  delete NodeUnavailableError::default_instance_;
  delete NodeUnavailableError_reflection_;
  delete RangeNotFoundError::default_instance_;
  delete RangeNotFoundError_reflection_;
  delete RangeKeyMismatchError::default_instance_;
  delete RangeKeyMismatchError_reflection_;
  delete ReadWithinUncertaintyIntervalError::default_instance_;
  delete ReadWithinUncertaintyIntervalError_reflection_;
  delete TransactionAbortedError::default_instance_;
  delete TransactionAbortedError_reflection_;
  delete TransactionPushError::default_instance_;
  delete TransactionPushError_reflection_;
  delete TransactionRetryError::default_instance_;
  delete TransactionRetryError_reflection_;
  delete TransactionStatusError::default_instance_;
  delete TransactionStatusError_reflection_;
  delete WriteIntentError::default_instance_;
  delete WriteIntentError_reflection_;
  delete WriteTooOldError::default_instance_;
  delete WriteTooOldError_reflection_;
  delete OpRequiresTxnError::default_instance_;
  delete OpRequiresTxnError_reflection_;
  delete ConditionFailedError::default_instance_;
  delete ConditionFailedError_reflection_;
  delete LeaseRejectedError::default_instance_;
  delete LeaseRejectedError_reflection_;
  delete ErrorDetail::default_instance_;
  delete ErrorDetail_reflection_;
  delete Error::default_instance_;
  delete Error_reflection_;
}

void protobuf_AddDesc_cockroach_2fproto_2ferrors_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  ::cockroach::proto::protobuf_AddDesc_cockroach_2fproto_2fmetadata_2eproto();
  ::cockroach::proto::protobuf_AddDesc_cockroach_2fproto_2fdata_2eproto();
  ::gogoproto::protobuf_AddDesc_gogoproto_2fgogo_2eproto();
  ::google::protobuf::DescriptorPool::InternalAddGeneratedFile(
    "\n\034cockroach/proto/errors.proto\022\017cockroac"
    "h.proto\032\036cockroach/proto/metadata.proto\032"
    "\032cockroach/proto/data.proto\032\024gogoproto/g"
    "ogo.proto\"\223\001\n\016NotLeaderError\022)\n\007replica\030"
    "\001 \001(\0132\030.cockroach.proto.Replica\022(\n\006leade"
    "r\030\002 \001(\0132\030.cockroach.proto.Replica\022,\n\010ran"
    "ge_id\030\003 \001(\003B\032\310\336\037\000\342\336\037\007RangeID\372\336\037\007RangeID\""
    "\026\n\024NodeUnavailableError\"B\n\022RangeNotFound"
    "Error\022,\n\010range_id\030\001 \001(\003B\032\310\336\037\000\342\336\037\007RangeID"
    "\372\336\037\007RangeID\"\216\001\n\025RangeKeyMismatchError\022\"\n"
    "\021request_start_key\030\001 \001(\014B\007\372\336\037\003Key\022 \n\017req"
    "uest_end_key\030\002 \001(\014B\007\372\336\037\003Key\022/\n\005range\030\003 \001"
    "(\0132 .cockroach.proto.RangeDescriptor\"\363\001\n"
    "\"ReadWithinUncertaintyIntervalError\0223\n\tt"
    "imestamp\030\001 \001(\0132\032.cockroach.proto.Timesta"
    "mpB\004\310\336\037\000\022<\n\022existing_timestamp\030\002 \001(\0132\032.c"
    "ockroach.proto.TimestampB\004\310\336\037\000\022)\n\007node_i"
    "d\030\003 \001(\005B\030\310\336\037\000\342\336\037\006NodeID\372\336\037\006NodeID\022/\n\003txn"
    "\030\004 \001(\0132\034.cockroach.proto.TransactionB\004\310\336"
    "\037\000\"J\n\027TransactionAbortedError\022/\n\003txn\030\001 \001"
    "(\0132\034.cockroach.proto.TransactionB\004\310\336\037\000\"y"
    "\n\024TransactionPushError\022)\n\003txn\030\001 \001(\0132\034.co"
    "ckroach.proto.Transaction\0226\n\npushee_txn\030"
    "\002 \001(\0132\034.cockroach.proto.TransactionB\004\310\336\037"
    "\000\"H\n\025TransactionRetryError\022/\n\003txn\030\001 \001(\0132"
    "\034.cockroach.proto.TransactionB\004\310\336\037\000\"\\\n\026T"
    "ransactionStatusError\022/\n\003txn\030\001 \001(\0132\034.coc"
    "kroach.proto.TransactionB\004\310\336\037\000\022\021\n\003msg\030\002 "
    "\001(\tB\004\310\336\037\000\"Z\n\020WriteIntentError\022.\n\007intents"
    "\030\001 \003(\0132\027.cockroach.proto.IntentB\004\310\336\037\000\022\026\n"
    "\010resolved\030\002 \001(\010B\004\310\336\037\000\"\205\001\n\020WriteTooOldErr"
    "or\0223\n\ttimestamp\030\001 \001(\0132\032.cockroach.proto."
    "TimestampB\004\310\336\037\000\022<\n\022existing_timestamp\030\002 "
    "\001(\0132\032.cockroach.proto.TimestampB\004\310\336\037\000\"\024\n"
    "\022OpRequiresTxnError\"D\n\024ConditionFailedEr"
    "ror\022,\n\014actual_value\030\001 \001(\0132\026.cockroach.pr"
    "oto.Value\"u\n\022LeaseRejectedError\022/\n\tReque"
    "sted\030\001 \001(\0132\026.cockroach.proto.LeaseB\004\310\336\037\000"
    "\022.\n\010Existing\030\002 \001(\0132\026.cockroach.proto.Lea"
    "seB\004\310\336\037\000\"\251\007\n\013ErrorDetail\0223\n\nnot_leader\030\001"
    " \001(\0132\037.cockroach.proto.NotLeaderError\022<\n"
    "\017range_not_found\030\002 \001(\0132#.cockroach.proto"
    ".RangeNotFoundError\022B\n\022range_key_mismatc"
    "h\030\003 \001(\0132&.cockroach.proto.RangeKeyMismat"
    "chError\022]\n read_within_uncertainty_inter"
    "val\030\004 \001(\01323.cockroach.proto.ReadWithinUn"
    "certaintyIntervalError\022E\n\023transaction_ab"
    "orted\030\005 \001(\0132(.cockroach.proto.Transactio"
    "nAbortedError\022\?\n\020transaction_push\030\006 \001(\0132"
    "%.cockroach.proto.TransactionPushError\022A"
    "\n\021transaction_retry\030\007 \001(\0132&.cockroach.pr"
    "oto.TransactionRetryError\022C\n\022transaction"
    "_status\030\010 \001(\0132\'.cockroach.proto.Transact"
    "ionStatusError\0227\n\014write_intent\030\t \001(\0132!.c"
    "ockroach.proto.WriteIntentError\0228\n\rwrite"
    "_too_old\030\n \001(\0132!.cockroach.proto.WriteTo"
    "oOldError\022<\n\017op_requires_txn\030\013 \001(\0132#.coc"
    "kroach.proto.OpRequiresTxnError\022\?\n\020condi"
    "tion_failed\030\014 \001(\0132%.cockroach.proto.Cond"
    "itionFailedError\022;\n\016lease_rejected\030\r \001(\013"
    "2#.cockroach.proto.LeaseRejectedError\022\?\n"
    "\020node_unavailable\030\016 \001(\0132%.cockroach.prot"
    "o.NodeUnavailableError:\004\310\240\037\001\"\255\001\n\005Error\022\025"
    "\n\007message\030\001 \001(\tB\004\310\336\037\000\022\027\n\tretryable\030\002 \001(\010"
    "B\004\310\336\037\000\022F\n\023transaction_restart\030\004 \001(\0162#.co"
    "ckroach.proto.TransactionRestartB\004\310\336\037\000\022,"
    "\n\006detail\030\003 \001(\0132\034.cockroach.proto.ErrorDe"
    "tail*;\n\022TransactionRestart\022\t\n\005ABORT\020\000\022\013\n"
    "\007BACKOFF\020\001\022\r\n\tIMMEDIATE\020\002B\033Z\005proto\330\341\036\000\340\342"
    "\036\001\310\342\036\001\320\342\036\001\220\343\036\000", 2774);
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedFile(
    "cockroach/proto/errors.proto", &protobuf_RegisterTypes);
  NotLeaderError::default_instance_ = new NotLeaderError();
  NodeUnavailableError::default_instance_ = new NodeUnavailableError();
  RangeNotFoundError::default_instance_ = new RangeNotFoundError();
  RangeKeyMismatchError::default_instance_ = new RangeKeyMismatchError();
  ReadWithinUncertaintyIntervalError::default_instance_ = new ReadWithinUncertaintyIntervalError();
  TransactionAbortedError::default_instance_ = new TransactionAbortedError();
  TransactionPushError::default_instance_ = new TransactionPushError();
  TransactionRetryError::default_instance_ = new TransactionRetryError();
  TransactionStatusError::default_instance_ = new TransactionStatusError();
  WriteIntentError::default_instance_ = new WriteIntentError();
  WriteTooOldError::default_instance_ = new WriteTooOldError();
  OpRequiresTxnError::default_instance_ = new OpRequiresTxnError();
  ConditionFailedError::default_instance_ = new ConditionFailedError();
  LeaseRejectedError::default_instance_ = new LeaseRejectedError();
  ErrorDetail::default_instance_ = new ErrorDetail();
  Error::default_instance_ = new Error();
  NotLeaderError::default_instance_->InitAsDefaultInstance();
  NodeUnavailableError::default_instance_->InitAsDefaultInstance();
  RangeNotFoundError::default_instance_->InitAsDefaultInstance();
  RangeKeyMismatchError::default_instance_->InitAsDefaultInstance();
  ReadWithinUncertaintyIntervalError::default_instance_->InitAsDefaultInstance();
  TransactionAbortedError::default_instance_->InitAsDefaultInstance();
  TransactionPushError::default_instance_->InitAsDefaultInstance();
  TransactionRetryError::default_instance_->InitAsDefaultInstance();
  TransactionStatusError::default_instance_->InitAsDefaultInstance();
  WriteIntentError::default_instance_->InitAsDefaultInstance();
  WriteTooOldError::default_instance_->InitAsDefaultInstance();
  OpRequiresTxnError::default_instance_->InitAsDefaultInstance();
  ConditionFailedError::default_instance_->InitAsDefaultInstance();
  LeaseRejectedError::default_instance_->InitAsDefaultInstance();
  ErrorDetail::default_instance_->InitAsDefaultInstance();
  Error::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_cockroach_2fproto_2ferrors_2eproto);
}

// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_cockroach_2fproto_2ferrors_2eproto {
  StaticDescriptorInitializer_cockroach_2fproto_2ferrors_2eproto() {
    protobuf_AddDesc_cockroach_2fproto_2ferrors_2eproto();
  }
} static_descriptor_initializer_cockroach_2fproto_2ferrors_2eproto_;
const ::google::protobuf::EnumDescriptor* TransactionRestart_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return TransactionRestart_descriptor_;
}
bool TransactionRestart_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}


namespace {

static void MergeFromFail(int line) GOOGLE_ATTRIBUTE_COLD;
static void MergeFromFail(int line) {
  GOOGLE_CHECK(false) << __FILE__ << ":" << line;
}

}  // namespace


// ===================================================================

#ifndef _MSC_VER
const int NotLeaderError::kReplicaFieldNumber;
const int NotLeaderError::kLeaderFieldNumber;
const int NotLeaderError::kRangeIdFieldNumber;
#endif  // !_MSC_VER

NotLeaderError::NotLeaderError()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:cockroach.proto.NotLeaderError)
}

void NotLeaderError::InitAsDefaultInstance() {
  replica_ = const_cast< ::cockroach::proto::Replica*>(&::cockroach::proto::Replica::default_instance());
  leader_ = const_cast< ::cockroach::proto::Replica*>(&::cockroach::proto::Replica::default_instance());
}

NotLeaderError::NotLeaderError(const NotLeaderError& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:cockroach.proto.NotLeaderError)
}

void NotLeaderError::SharedCtor() {
  _cached_size_ = 0;
  replica_ = NULL;
  leader_ = NULL;
  range_id_ = GOOGLE_LONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

NotLeaderError::~NotLeaderError() {
  // @@protoc_insertion_point(destructor:cockroach.proto.NotLeaderError)
  SharedDtor();
}

void NotLeaderError::SharedDtor() {
  if (this != default_instance_) {
    delete replica_;
    delete leader_;
  }
}

void NotLeaderError::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* NotLeaderError::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return NotLeaderError_descriptor_;
}

const NotLeaderError& NotLeaderError::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_cockroach_2fproto_2ferrors_2eproto();
  return *default_instance_;
}

NotLeaderError* NotLeaderError::default_instance_ = NULL;

NotLeaderError* NotLeaderError::New(::google::protobuf::Arena* arena) const {
  NotLeaderError* n = new NotLeaderError;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void NotLeaderError::Clear() {
  if (_has_bits_[0 / 32] & 7u) {
    if (has_replica()) {
      if (replica_ != NULL) replica_->::cockroach::proto::Replica::Clear();
    }
    if (has_leader()) {
      if (leader_ != NULL) leader_->::cockroach::proto::Replica::Clear();
    }
    range_id_ = GOOGLE_LONGLONG(0);
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool NotLeaderError::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:cockroach.proto.NotLeaderError)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .cockroach.proto.Replica replica = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_replica()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_leader;
        break;
      }

      // optional .cockroach.proto.Replica leader = 2;
      case 2: {
        if (tag == 18) {
         parse_leader:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_leader()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_range_id;
        break;
      }

      // optional int64 range_id = 3;
      case 3: {
        if (tag == 24) {
         parse_range_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &range_id_)));
          set_has_range_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:cockroach.proto.NotLeaderError)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:cockroach.proto.NotLeaderError)
  return false;
#undef DO_
}

void NotLeaderError::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:cockroach.proto.NotLeaderError)
  // optional .cockroach.proto.Replica replica = 1;
  if (has_replica()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->replica_, output);
  }

  // optional .cockroach.proto.Replica leader = 2;
  if (has_leader()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, *this->leader_, output);
  }

  // optional int64 range_id = 3;
  if (has_range_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(3, this->range_id(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:cockroach.proto.NotLeaderError)
}

::google::protobuf::uint8* NotLeaderError::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:cockroach.proto.NotLeaderError)
  // optional .cockroach.proto.Replica replica = 1;
  if (has_replica()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, *this->replica_, target);
  }

  // optional .cockroach.proto.Replica leader = 2;
  if (has_leader()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, *this->leader_, target);
  }

  // optional int64 range_id = 3;
  if (has_range_id()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(3, this->range_id(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:cockroach.proto.NotLeaderError)
  return target;
}

int NotLeaderError::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & 7) {
    // optional .cockroach.proto.Replica replica = 1;
    if (has_replica()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->replica_);
    }

    // optional .cockroach.proto.Replica leader = 2;
    if (has_leader()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->leader_);
    }

    // optional int64 range_id = 3;
    if (has_range_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->range_id());
    }

  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void NotLeaderError::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const NotLeaderError* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const NotLeaderError>(
          &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void NotLeaderError::MergeFrom(const NotLeaderError& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_replica()) {
      mutable_replica()->::cockroach::proto::Replica::MergeFrom(from.replica());
    }
    if (from.has_leader()) {
      mutable_leader()->::cockroach::proto::Replica::MergeFrom(from.leader());
    }
    if (from.has_range_id()) {
      set_range_id(from.range_id());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void NotLeaderError::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void NotLeaderError::CopyFrom(const NotLeaderError& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NotLeaderError::IsInitialized() const {

  return true;
}

void NotLeaderError::Swap(NotLeaderError* other) {
  if (other == this) return;
  InternalSwap(other);
}
void NotLeaderError::InternalSwap(NotLeaderError* other) {
  std::swap(replica_, other->replica_);
  std::swap(leader_, other->leader_);
  std::swap(range_id_, other->range_id_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata NotLeaderError::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = NotLeaderError_descriptor_;
  metadata.reflection = NotLeaderError_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// NotLeaderError

// optional .cockroach.proto.Replica replica = 1;
bool NotLeaderError::has_replica() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void NotLeaderError::set_has_replica() {
  _has_bits_[0] |= 0x00000001u;
}
void NotLeaderError::clear_has_replica() {
  _has_bits_[0] &= ~0x00000001u;
}
void NotLeaderError::clear_replica() {
  if (replica_ != NULL) replica_->::cockroach::proto::Replica::Clear();
  clear_has_replica();
}
 const ::cockroach::proto::Replica& NotLeaderError::replica() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.NotLeaderError.replica)
  return replica_ != NULL ? *replica_ : *default_instance_->replica_;
}
 ::cockroach::proto::Replica* NotLeaderError::mutable_replica() {
  set_has_replica();
  if (replica_ == NULL) {
    replica_ = new ::cockroach::proto::Replica;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.proto.NotLeaderError.replica)
  return replica_;
}
 ::cockroach::proto::Replica* NotLeaderError::release_replica() {
  clear_has_replica();
  ::cockroach::proto::Replica* temp = replica_;
  replica_ = NULL;
  return temp;
}
 void NotLeaderError::set_allocated_replica(::cockroach::proto::Replica* replica) {
  delete replica_;
  replica_ = replica;
  if (replica) {
    set_has_replica();
  } else {
    clear_has_replica();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.NotLeaderError.replica)
}

// optional .cockroach.proto.Replica leader = 2;
bool NotLeaderError::has_leader() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void NotLeaderError::set_has_leader() {
  _has_bits_[0] |= 0x00000002u;
}
void NotLeaderError::clear_has_leader() {
  _has_bits_[0] &= ~0x00000002u;
}
void NotLeaderError::clear_leader() {
  if (leader_ != NULL) leader_->::cockroach::proto::Replica::Clear();
  clear_has_leader();
}
 const ::cockroach::proto::Replica& NotLeaderError::leader() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.NotLeaderError.leader)
  return leader_ != NULL ? *leader_ : *default_instance_->leader_;
}
 ::cockroach::proto::Replica* NotLeaderError::mutable_leader() {
  set_has_leader();
  if (leader_ == NULL) {
    leader_ = new ::cockroach::proto::Replica;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.proto.NotLeaderError.leader)
  return leader_;
}
 ::cockroach::proto::Replica* NotLeaderError::release_leader() {
  clear_has_leader();
  ::cockroach::proto::Replica* temp = leader_;
  leader_ = NULL;
  return temp;
}
 void NotLeaderError::set_allocated_leader(::cockroach::proto::Replica* leader) {
  delete leader_;
  leader_ = leader;
  if (leader) {
    set_has_leader();
  } else {
    clear_has_leader();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.NotLeaderError.leader)
}

// optional int64 range_id = 3;
bool NotLeaderError::has_range_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void NotLeaderError::set_has_range_id() {
  _has_bits_[0] |= 0x00000004u;
}
void NotLeaderError::clear_has_range_id() {
  _has_bits_[0] &= ~0x00000004u;
}
void NotLeaderError::clear_range_id() {
  range_id_ = GOOGLE_LONGLONG(0);
  clear_has_range_id();
}
 ::google::protobuf::int64 NotLeaderError::range_id() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.NotLeaderError.range_id)
  return range_id_;
}
 void NotLeaderError::set_range_id(::google::protobuf::int64 value) {
  set_has_range_id();
  range_id_ = value;
  // @@protoc_insertion_point(field_set:cockroach.proto.NotLeaderError.range_id)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

NodeUnavailableError::NodeUnavailableError()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:cockroach.proto.NodeUnavailableError)
}

void NodeUnavailableError::InitAsDefaultInstance() {
}

NodeUnavailableError::NodeUnavailableError(const NodeUnavailableError& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:cockroach.proto.NodeUnavailableError)
}

void NodeUnavailableError::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

NodeUnavailableError::~NodeUnavailableError() {
  // @@protoc_insertion_point(destructor:cockroach.proto.NodeUnavailableError)
  SharedDtor();
}

void NodeUnavailableError::SharedDtor() {
  if (this != default_instance_) {
  }
}

void NodeUnavailableError::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* NodeUnavailableError::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return NodeUnavailableError_descriptor_;
}

const NodeUnavailableError& NodeUnavailableError::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_cockroach_2fproto_2ferrors_2eproto();
  return *default_instance_;
}

NodeUnavailableError* NodeUnavailableError::default_instance_ = NULL;

NodeUnavailableError* NodeUnavailableError::New(::google::protobuf::Arena* arena) const {
  NodeUnavailableError* n = new NodeUnavailableError;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void NodeUnavailableError::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool NodeUnavailableError::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:cockroach.proto.NodeUnavailableError)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormat::SkipField(
          input, tag, mutable_unknown_fields()));
  }
success:
  // @@protoc_insertion_point(parse_success:cockroach.proto.NodeUnavailableError)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:cockroach.proto.NodeUnavailableError)
  return false;
#undef DO_
}

void NodeUnavailableError::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:cockroach.proto.NodeUnavailableError)
  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:cockroach.proto.NodeUnavailableError)
}

::google::protobuf::uint8* NodeUnavailableError::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:cockroach.proto.NodeUnavailableError)
  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:cockroach.proto.NodeUnavailableError)
  return target;
}

int NodeUnavailableError::ByteSize() const {
  int total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void NodeUnavailableError::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const NodeUnavailableError* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const NodeUnavailableError>(
          &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void NodeUnavailableError::MergeFrom(const NodeUnavailableError& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void NodeUnavailableError::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void NodeUnavailableError::CopyFrom(const NodeUnavailableError& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NodeUnavailableError::IsInitialized() const {

  return true;
}

void NodeUnavailableError::Swap(NodeUnavailableError* other) {
  if (other == this) return;
  InternalSwap(other);
}
void NodeUnavailableError::InternalSwap(NodeUnavailableError* other) {
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata NodeUnavailableError::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = NodeUnavailableError_descriptor_;
  metadata.reflection = NodeUnavailableError_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// NodeUnavailableError

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#ifndef _MSC_VER
const int RangeNotFoundError::kRangeIdFieldNumber;
#endif  // !_MSC_VER

RangeNotFoundError::RangeNotFoundError()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:cockroach.proto.RangeNotFoundError)
}

void RangeNotFoundError::InitAsDefaultInstance() {
}

RangeNotFoundError::RangeNotFoundError(const RangeNotFoundError& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:cockroach.proto.RangeNotFoundError)
}

void RangeNotFoundError::SharedCtor() {
  _cached_size_ = 0;
  range_id_ = GOOGLE_LONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RangeNotFoundError::~RangeNotFoundError() {
  // @@protoc_insertion_point(destructor:cockroach.proto.RangeNotFoundError)
  SharedDtor();
}

void RangeNotFoundError::SharedDtor() {
  if (this != default_instance_) {
  }
}

void RangeNotFoundError::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* RangeNotFoundError::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return RangeNotFoundError_descriptor_;
}

const RangeNotFoundError& RangeNotFoundError::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_cockroach_2fproto_2ferrors_2eproto();
  return *default_instance_;
}

RangeNotFoundError* RangeNotFoundError::default_instance_ = NULL;

RangeNotFoundError* RangeNotFoundError::New(::google::protobuf::Arena* arena) const {
  RangeNotFoundError* n = new RangeNotFoundError;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void RangeNotFoundError::Clear() {
  range_id_ = GOOGLE_LONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool RangeNotFoundError::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:cockroach.proto.RangeNotFoundError)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int64 range_id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &range_id_)));
          set_has_range_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:cockroach.proto.RangeNotFoundError)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:cockroach.proto.RangeNotFoundError)
  return false;
#undef DO_
}

void RangeNotFoundError::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:cockroach.proto.RangeNotFoundError)
  // optional int64 range_id = 1;
  if (has_range_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(1, this->range_id(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:cockroach.proto.RangeNotFoundError)
}

::google::protobuf::uint8* RangeNotFoundError::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:cockroach.proto.RangeNotFoundError)
  // optional int64 range_id = 1;
  if (has_range_id()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(1, this->range_id(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:cockroach.proto.RangeNotFoundError)
  return target;
}

int RangeNotFoundError::ByteSize() const {
  int total_size = 0;

  // optional int64 range_id = 1;
  if (has_range_id()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int64Size(
        this->range_id());
  }

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RangeNotFoundError::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const RangeNotFoundError* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const RangeNotFoundError>(
          &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void RangeNotFoundError::MergeFrom(const RangeNotFoundError& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_range_id()) {
      set_range_id(from.range_id());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void RangeNotFoundError::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void RangeNotFoundError::CopyFrom(const RangeNotFoundError& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RangeNotFoundError::IsInitialized() const {

  return true;
}

void RangeNotFoundError::Swap(RangeNotFoundError* other) {
  if (other == this) return;
  InternalSwap(other);
}
void RangeNotFoundError::InternalSwap(RangeNotFoundError* other) {
  std::swap(range_id_, other->range_id_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata RangeNotFoundError::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = RangeNotFoundError_descriptor_;
  metadata.reflection = RangeNotFoundError_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// RangeNotFoundError

// optional int64 range_id = 1;
bool RangeNotFoundError::has_range_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void RangeNotFoundError::set_has_range_id() {
  _has_bits_[0] |= 0x00000001u;
}
void RangeNotFoundError::clear_has_range_id() {
  _has_bits_[0] &= ~0x00000001u;
}
void RangeNotFoundError::clear_range_id() {
  range_id_ = GOOGLE_LONGLONG(0);
  clear_has_range_id();
}
 ::google::protobuf::int64 RangeNotFoundError::range_id() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.RangeNotFoundError.range_id)
  return range_id_;
}
 void RangeNotFoundError::set_range_id(::google::protobuf::int64 value) {
  set_has_range_id();
  range_id_ = value;
  // @@protoc_insertion_point(field_set:cockroach.proto.RangeNotFoundError.range_id)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#ifndef _MSC_VER
const int RangeKeyMismatchError::kRequestStartKeyFieldNumber;
const int RangeKeyMismatchError::kRequestEndKeyFieldNumber;
const int RangeKeyMismatchError::kRangeFieldNumber;
#endif  // !_MSC_VER

RangeKeyMismatchError::RangeKeyMismatchError()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:cockroach.proto.RangeKeyMismatchError)
}

void RangeKeyMismatchError::InitAsDefaultInstance() {
  range_ = const_cast< ::cockroach::proto::RangeDescriptor*>(&::cockroach::proto::RangeDescriptor::default_instance());
}

RangeKeyMismatchError::RangeKeyMismatchError(const RangeKeyMismatchError& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:cockroach.proto.RangeKeyMismatchError)
}

void RangeKeyMismatchError::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  request_start_key_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  request_end_key_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  range_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RangeKeyMismatchError::~RangeKeyMismatchError() {
  // @@protoc_insertion_point(destructor:cockroach.proto.RangeKeyMismatchError)
  SharedDtor();
}

void RangeKeyMismatchError::SharedDtor() {
  request_start_key_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  request_end_key_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != default_instance_) {
    delete range_;
  }
}

void RangeKeyMismatchError::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* RangeKeyMismatchError::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return RangeKeyMismatchError_descriptor_;
}

const RangeKeyMismatchError& RangeKeyMismatchError::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_cockroach_2fproto_2ferrors_2eproto();
  return *default_instance_;
}

RangeKeyMismatchError* RangeKeyMismatchError::default_instance_ = NULL;

RangeKeyMismatchError* RangeKeyMismatchError::New(::google::protobuf::Arena* arena) const {
  RangeKeyMismatchError* n = new RangeKeyMismatchError;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void RangeKeyMismatchError::Clear() {
  if (_has_bits_[0 / 32] & 7u) {
    if (has_request_start_key()) {
      request_start_key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    if (has_request_end_key()) {
      request_end_key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    if (has_range()) {
      if (range_ != NULL) range_->::cockroach::proto::RangeDescriptor::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool RangeKeyMismatchError::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:cockroach.proto.RangeKeyMismatchError)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional bytes request_start_key = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_request_start_key()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_request_end_key;
        break;
      }

      // optional bytes request_end_key = 2;
      case 2: {
        if (tag == 18) {
         parse_request_end_key:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_request_end_key()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_range;
        break;
      }

      // optional .cockroach.proto.RangeDescriptor range = 3;
      case 3: {
        if (tag == 26) {
         parse_range:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_range()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:cockroach.proto.RangeKeyMismatchError)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:cockroach.proto.RangeKeyMismatchError)
  return false;
#undef DO_
}

void RangeKeyMismatchError::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:cockroach.proto.RangeKeyMismatchError)
  // optional bytes request_start_key = 1;
  if (has_request_start_key()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      1, this->request_start_key(), output);
  }

  // optional bytes request_end_key = 2;
  if (has_request_end_key()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      2, this->request_end_key(), output);
  }

  // optional .cockroach.proto.RangeDescriptor range = 3;
  if (has_range()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, *this->range_, output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:cockroach.proto.RangeKeyMismatchError)
}

::google::protobuf::uint8* RangeKeyMismatchError::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:cockroach.proto.RangeKeyMismatchError)
  // optional bytes request_start_key = 1;
  if (has_request_start_key()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        1, this->request_start_key(), target);
  }

  // optional bytes request_end_key = 2;
  if (has_request_end_key()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        2, this->request_end_key(), target);
  }

  // optional .cockroach.proto.RangeDescriptor range = 3;
  if (has_range()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, *this->range_, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:cockroach.proto.RangeKeyMismatchError)
  return target;
}

int RangeKeyMismatchError::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & 7) {
    // optional bytes request_start_key = 1;
    if (has_request_start_key()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->request_start_key());
    }

    // optional bytes request_end_key = 2;
    if (has_request_end_key()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->request_end_key());
    }

    // optional .cockroach.proto.RangeDescriptor range = 3;
    if (has_range()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->range_);
    }

  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RangeKeyMismatchError::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const RangeKeyMismatchError* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const RangeKeyMismatchError>(
          &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void RangeKeyMismatchError::MergeFrom(const RangeKeyMismatchError& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_request_start_key()) {
      set_has_request_start_key();
      request_start_key_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.request_start_key_);
    }
    if (from.has_request_end_key()) {
      set_has_request_end_key();
      request_end_key_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.request_end_key_);
    }
    if (from.has_range()) {
      mutable_range()->::cockroach::proto::RangeDescriptor::MergeFrom(from.range());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void RangeKeyMismatchError::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void RangeKeyMismatchError::CopyFrom(const RangeKeyMismatchError& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RangeKeyMismatchError::IsInitialized() const {

  return true;
}

void RangeKeyMismatchError::Swap(RangeKeyMismatchError* other) {
  if (other == this) return;
  InternalSwap(other);
}
void RangeKeyMismatchError::InternalSwap(RangeKeyMismatchError* other) {
  request_start_key_.Swap(&other->request_start_key_);
  request_end_key_.Swap(&other->request_end_key_);
  std::swap(range_, other->range_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata RangeKeyMismatchError::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = RangeKeyMismatchError_descriptor_;
  metadata.reflection = RangeKeyMismatchError_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// RangeKeyMismatchError

// optional bytes request_start_key = 1;
bool RangeKeyMismatchError::has_request_start_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void RangeKeyMismatchError::set_has_request_start_key() {
  _has_bits_[0] |= 0x00000001u;
}
void RangeKeyMismatchError::clear_has_request_start_key() {
  _has_bits_[0] &= ~0x00000001u;
}
void RangeKeyMismatchError::clear_request_start_key() {
  request_start_key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_request_start_key();
}
 const ::std::string& RangeKeyMismatchError::request_start_key() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.RangeKeyMismatchError.request_start_key)
  return request_start_key_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void RangeKeyMismatchError::set_request_start_key(const ::std::string& value) {
  set_has_request_start_key();
  request_start_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cockroach.proto.RangeKeyMismatchError.request_start_key)
}
 void RangeKeyMismatchError::set_request_start_key(const char* value) {
  set_has_request_start_key();
  request_start_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cockroach.proto.RangeKeyMismatchError.request_start_key)
}
 void RangeKeyMismatchError::set_request_start_key(const void* value, size_t size) {
  set_has_request_start_key();
  request_start_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cockroach.proto.RangeKeyMismatchError.request_start_key)
}
 ::std::string* RangeKeyMismatchError::mutable_request_start_key() {
  set_has_request_start_key();
  // @@protoc_insertion_point(field_mutable:cockroach.proto.RangeKeyMismatchError.request_start_key)
  return request_start_key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* RangeKeyMismatchError::release_request_start_key() {
  clear_has_request_start_key();
  return request_start_key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void RangeKeyMismatchError::set_allocated_request_start_key(::std::string* request_start_key) {
  if (request_start_key != NULL) {
    set_has_request_start_key();
  } else {
    clear_has_request_start_key();
  }
  request_start_key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), request_start_key);
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.RangeKeyMismatchError.request_start_key)
}

// optional bytes request_end_key = 2;
bool RangeKeyMismatchError::has_request_end_key() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void RangeKeyMismatchError::set_has_request_end_key() {
  _has_bits_[0] |= 0x00000002u;
}
void RangeKeyMismatchError::clear_has_request_end_key() {
  _has_bits_[0] &= ~0x00000002u;
}
void RangeKeyMismatchError::clear_request_end_key() {
  request_end_key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_request_end_key();
}
 const ::std::string& RangeKeyMismatchError::request_end_key() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.RangeKeyMismatchError.request_end_key)
  return request_end_key_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void RangeKeyMismatchError::set_request_end_key(const ::std::string& value) {
  set_has_request_end_key();
  request_end_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cockroach.proto.RangeKeyMismatchError.request_end_key)
}
 void RangeKeyMismatchError::set_request_end_key(const char* value) {
  set_has_request_end_key();
  request_end_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cockroach.proto.RangeKeyMismatchError.request_end_key)
}
 void RangeKeyMismatchError::set_request_end_key(const void* value, size_t size) {
  set_has_request_end_key();
  request_end_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cockroach.proto.RangeKeyMismatchError.request_end_key)
}
 ::std::string* RangeKeyMismatchError::mutable_request_end_key() {
  set_has_request_end_key();
  // @@protoc_insertion_point(field_mutable:cockroach.proto.RangeKeyMismatchError.request_end_key)
  return request_end_key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* RangeKeyMismatchError::release_request_end_key() {
  clear_has_request_end_key();
  return request_end_key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void RangeKeyMismatchError::set_allocated_request_end_key(::std::string* request_end_key) {
  if (request_end_key != NULL) {
    set_has_request_end_key();
  } else {
    clear_has_request_end_key();
  }
  request_end_key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), request_end_key);
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.RangeKeyMismatchError.request_end_key)
}

// optional .cockroach.proto.RangeDescriptor range = 3;
bool RangeKeyMismatchError::has_range() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void RangeKeyMismatchError::set_has_range() {
  _has_bits_[0] |= 0x00000004u;
}
void RangeKeyMismatchError::clear_has_range() {
  _has_bits_[0] &= ~0x00000004u;
}
void RangeKeyMismatchError::clear_range() {
  if (range_ != NULL) range_->::cockroach::proto::RangeDescriptor::Clear();
  clear_has_range();
}
 const ::cockroach::proto::RangeDescriptor& RangeKeyMismatchError::range() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.RangeKeyMismatchError.range)
  return range_ != NULL ? *range_ : *default_instance_->range_;
}
 ::cockroach::proto::RangeDescriptor* RangeKeyMismatchError::mutable_range() {
  set_has_range();
  if (range_ == NULL) {
    range_ = new ::cockroach::proto::RangeDescriptor;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.proto.RangeKeyMismatchError.range)
  return range_;
}
 ::cockroach::proto::RangeDescriptor* RangeKeyMismatchError::release_range() {
  clear_has_range();
  ::cockroach::proto::RangeDescriptor* temp = range_;
  range_ = NULL;
  return temp;
}
 void RangeKeyMismatchError::set_allocated_range(::cockroach::proto::RangeDescriptor* range) {
  delete range_;
  range_ = range;
  if (range) {
    set_has_range();
  } else {
    clear_has_range();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.RangeKeyMismatchError.range)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#ifndef _MSC_VER
const int ReadWithinUncertaintyIntervalError::kTimestampFieldNumber;
const int ReadWithinUncertaintyIntervalError::kExistingTimestampFieldNumber;
const int ReadWithinUncertaintyIntervalError::kNodeIdFieldNumber;
const int ReadWithinUncertaintyIntervalError::kTxnFieldNumber;
#endif  // !_MSC_VER

ReadWithinUncertaintyIntervalError::ReadWithinUncertaintyIntervalError()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:cockroach.proto.ReadWithinUncertaintyIntervalError)
}

void ReadWithinUncertaintyIntervalError::InitAsDefaultInstance() {
  timestamp_ = const_cast< ::cockroach::proto::Timestamp*>(&::cockroach::proto::Timestamp::default_instance());
  existing_timestamp_ = const_cast< ::cockroach::proto::Timestamp*>(&::cockroach::proto::Timestamp::default_instance());
  txn_ = const_cast< ::cockroach::proto::Transaction*>(&::cockroach::proto::Transaction::default_instance());
}

ReadWithinUncertaintyIntervalError::ReadWithinUncertaintyIntervalError(const ReadWithinUncertaintyIntervalError& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:cockroach.proto.ReadWithinUncertaintyIntervalError)
}

void ReadWithinUncertaintyIntervalError::SharedCtor() {
  _cached_size_ = 0;
  timestamp_ = NULL;
  existing_timestamp_ = NULL;
  node_id_ = 0;
  txn_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ReadWithinUncertaintyIntervalError::~ReadWithinUncertaintyIntervalError() {
  // @@protoc_insertion_point(destructor:cockroach.proto.ReadWithinUncertaintyIntervalError)
  SharedDtor();
}

void ReadWithinUncertaintyIntervalError::SharedDtor() {
  if (this != default_instance_) {
    delete timestamp_;
    delete existing_timestamp_;
    delete txn_;
  }
}

void ReadWithinUncertaintyIntervalError::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ReadWithinUncertaintyIntervalError::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ReadWithinUncertaintyIntervalError_descriptor_;
}

const ReadWithinUncertaintyIntervalError& ReadWithinUncertaintyIntervalError::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_cockroach_2fproto_2ferrors_2eproto();
  return *default_instance_;
}

ReadWithinUncertaintyIntervalError* ReadWithinUncertaintyIntervalError::default_instance_ = NULL;

ReadWithinUncertaintyIntervalError* ReadWithinUncertaintyIntervalError::New(::google::protobuf::Arena* arena) const {
  ReadWithinUncertaintyIntervalError* n = new ReadWithinUncertaintyIntervalError;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void ReadWithinUncertaintyIntervalError::Clear() {
  if (_has_bits_[0 / 32] & 15u) {
    if (has_timestamp()) {
      if (timestamp_ != NULL) timestamp_->::cockroach::proto::Timestamp::Clear();
    }
    if (has_existing_timestamp()) {
      if (existing_timestamp_ != NULL) existing_timestamp_->::cockroach::proto::Timestamp::Clear();
    }
    node_id_ = 0;
    if (has_txn()) {
      if (txn_ != NULL) txn_->::cockroach::proto::Transaction::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool ReadWithinUncertaintyIntervalError::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:cockroach.proto.ReadWithinUncertaintyIntervalError)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .cockroach.proto.Timestamp timestamp = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_timestamp()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_existing_timestamp;
        break;
      }

      // optional .cockroach.proto.Timestamp existing_timestamp = 2;
      case 2: {
        if (tag == 18) {
         parse_existing_timestamp:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_existing_timestamp()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_node_id;
        break;
      }

      // optional int32 node_id = 3;
      case 3: {
        if (tag == 24) {
         parse_node_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &node_id_)));
          set_has_node_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_txn;
        break;
      }

      // optional .cockroach.proto.Transaction txn = 4;
      case 4: {
        if (tag == 34) {
         parse_txn:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_txn()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:cockroach.proto.ReadWithinUncertaintyIntervalError)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:cockroach.proto.ReadWithinUncertaintyIntervalError)
  return false;
#undef DO_
}

void ReadWithinUncertaintyIntervalError::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:cockroach.proto.ReadWithinUncertaintyIntervalError)
  // optional .cockroach.proto.Timestamp timestamp = 1;
  if (has_timestamp()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->timestamp_, output);
  }

  // optional .cockroach.proto.Timestamp existing_timestamp = 2;
  if (has_existing_timestamp()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, *this->existing_timestamp_, output);
  }

  // optional int32 node_id = 3;
  if (has_node_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->node_id(), output);
  }

  // optional .cockroach.proto.Transaction txn = 4;
  if (has_txn()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, *this->txn_, output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:cockroach.proto.ReadWithinUncertaintyIntervalError)
}

::google::protobuf::uint8* ReadWithinUncertaintyIntervalError::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:cockroach.proto.ReadWithinUncertaintyIntervalError)
  // optional .cockroach.proto.Timestamp timestamp = 1;
  if (has_timestamp()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, *this->timestamp_, target);
  }

  // optional .cockroach.proto.Timestamp existing_timestamp = 2;
  if (has_existing_timestamp()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, *this->existing_timestamp_, target);
  }

  // optional int32 node_id = 3;
  if (has_node_id()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(3, this->node_id(), target);
  }

  // optional .cockroach.proto.Transaction txn = 4;
  if (has_txn()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        4, *this->txn_, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:cockroach.proto.ReadWithinUncertaintyIntervalError)
  return target;
}

int ReadWithinUncertaintyIntervalError::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & 15) {
    // optional .cockroach.proto.Timestamp timestamp = 1;
    if (has_timestamp()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->timestamp_);
    }

    // optional .cockroach.proto.Timestamp existing_timestamp = 2;
    if (has_existing_timestamp()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->existing_timestamp_);
    }

    // optional int32 node_id = 3;
    if (has_node_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->node_id());
    }

    // optional .cockroach.proto.Transaction txn = 4;
    if (has_txn()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->txn_);
    }

  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ReadWithinUncertaintyIntervalError::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const ReadWithinUncertaintyIntervalError* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const ReadWithinUncertaintyIntervalError>(
          &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ReadWithinUncertaintyIntervalError::MergeFrom(const ReadWithinUncertaintyIntervalError& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_timestamp()) {
      mutable_timestamp()->::cockroach::proto::Timestamp::MergeFrom(from.timestamp());
    }
    if (from.has_existing_timestamp()) {
      mutable_existing_timestamp()->::cockroach::proto::Timestamp::MergeFrom(from.existing_timestamp());
    }
    if (from.has_node_id()) {
      set_node_id(from.node_id());
    }
    if (from.has_txn()) {
      mutable_txn()->::cockroach::proto::Transaction::MergeFrom(from.txn());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void ReadWithinUncertaintyIntervalError::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ReadWithinUncertaintyIntervalError::CopyFrom(const ReadWithinUncertaintyIntervalError& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ReadWithinUncertaintyIntervalError::IsInitialized() const {

  return true;
}

void ReadWithinUncertaintyIntervalError::Swap(ReadWithinUncertaintyIntervalError* other) {
  if (other == this) return;
  InternalSwap(other);
}
void ReadWithinUncertaintyIntervalError::InternalSwap(ReadWithinUncertaintyIntervalError* other) {
  std::swap(timestamp_, other->timestamp_);
  std::swap(existing_timestamp_, other->existing_timestamp_);
  std::swap(node_id_, other->node_id_);
  std::swap(txn_, other->txn_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata ReadWithinUncertaintyIntervalError::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ReadWithinUncertaintyIntervalError_descriptor_;
  metadata.reflection = ReadWithinUncertaintyIntervalError_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// ReadWithinUncertaintyIntervalError

// optional .cockroach.proto.Timestamp timestamp = 1;
bool ReadWithinUncertaintyIntervalError::has_timestamp() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void ReadWithinUncertaintyIntervalError::set_has_timestamp() {
  _has_bits_[0] |= 0x00000001u;
}
void ReadWithinUncertaintyIntervalError::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000001u;
}
void ReadWithinUncertaintyIntervalError::clear_timestamp() {
  if (timestamp_ != NULL) timestamp_->::cockroach::proto::Timestamp::Clear();
  clear_has_timestamp();
}
 const ::cockroach::proto::Timestamp& ReadWithinUncertaintyIntervalError::timestamp() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.ReadWithinUncertaintyIntervalError.timestamp)
  return timestamp_ != NULL ? *timestamp_ : *default_instance_->timestamp_;
}
 ::cockroach::proto::Timestamp* ReadWithinUncertaintyIntervalError::mutable_timestamp() {
  set_has_timestamp();
  if (timestamp_ == NULL) {
    timestamp_ = new ::cockroach::proto::Timestamp;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.proto.ReadWithinUncertaintyIntervalError.timestamp)
  return timestamp_;
}
 ::cockroach::proto::Timestamp* ReadWithinUncertaintyIntervalError::release_timestamp() {
  clear_has_timestamp();
  ::cockroach::proto::Timestamp* temp = timestamp_;
  timestamp_ = NULL;
  return temp;
}
 void ReadWithinUncertaintyIntervalError::set_allocated_timestamp(::cockroach::proto::Timestamp* timestamp) {
  delete timestamp_;
  timestamp_ = timestamp;
  if (timestamp) {
    set_has_timestamp();
  } else {
    clear_has_timestamp();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.ReadWithinUncertaintyIntervalError.timestamp)
}

// optional .cockroach.proto.Timestamp existing_timestamp = 2;
bool ReadWithinUncertaintyIntervalError::has_existing_timestamp() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void ReadWithinUncertaintyIntervalError::set_has_existing_timestamp() {
  _has_bits_[0] |= 0x00000002u;
}
void ReadWithinUncertaintyIntervalError::clear_has_existing_timestamp() {
  _has_bits_[0] &= ~0x00000002u;
}
void ReadWithinUncertaintyIntervalError::clear_existing_timestamp() {
  if (existing_timestamp_ != NULL) existing_timestamp_->::cockroach::proto::Timestamp::Clear();
  clear_has_existing_timestamp();
}
 const ::cockroach::proto::Timestamp& ReadWithinUncertaintyIntervalError::existing_timestamp() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.ReadWithinUncertaintyIntervalError.existing_timestamp)
  return existing_timestamp_ != NULL ? *existing_timestamp_ : *default_instance_->existing_timestamp_;
}
 ::cockroach::proto::Timestamp* ReadWithinUncertaintyIntervalError::mutable_existing_timestamp() {
  set_has_existing_timestamp();
  if (existing_timestamp_ == NULL) {
    existing_timestamp_ = new ::cockroach::proto::Timestamp;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.proto.ReadWithinUncertaintyIntervalError.existing_timestamp)
  return existing_timestamp_;
}
 ::cockroach::proto::Timestamp* ReadWithinUncertaintyIntervalError::release_existing_timestamp() {
  clear_has_existing_timestamp();
  ::cockroach::proto::Timestamp* temp = existing_timestamp_;
  existing_timestamp_ = NULL;
  return temp;
}
 void ReadWithinUncertaintyIntervalError::set_allocated_existing_timestamp(::cockroach::proto::Timestamp* existing_timestamp) {
  delete existing_timestamp_;
  existing_timestamp_ = existing_timestamp;
  if (existing_timestamp) {
    set_has_existing_timestamp();
  } else {
    clear_has_existing_timestamp();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.ReadWithinUncertaintyIntervalError.existing_timestamp)
}

// optional int32 node_id = 3;
bool ReadWithinUncertaintyIntervalError::has_node_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void ReadWithinUncertaintyIntervalError::set_has_node_id() {
  _has_bits_[0] |= 0x00000004u;
}
void ReadWithinUncertaintyIntervalError::clear_has_node_id() {
  _has_bits_[0] &= ~0x00000004u;
}
void ReadWithinUncertaintyIntervalError::clear_node_id() {
  node_id_ = 0;
  clear_has_node_id();
}
 ::google::protobuf::int32 ReadWithinUncertaintyIntervalError::node_id() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.ReadWithinUncertaintyIntervalError.node_id)
  return node_id_;
}
 void ReadWithinUncertaintyIntervalError::set_node_id(::google::protobuf::int32 value) {
  set_has_node_id();
  node_id_ = value;
  // @@protoc_insertion_point(field_set:cockroach.proto.ReadWithinUncertaintyIntervalError.node_id)
}

// optional .cockroach.proto.Transaction txn = 4;
bool ReadWithinUncertaintyIntervalError::has_txn() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void ReadWithinUncertaintyIntervalError::set_has_txn() {
  _has_bits_[0] |= 0x00000008u;
}
void ReadWithinUncertaintyIntervalError::clear_has_txn() {
  _has_bits_[0] &= ~0x00000008u;
}
void ReadWithinUncertaintyIntervalError::clear_txn() {
  if (txn_ != NULL) txn_->::cockroach::proto::Transaction::Clear();
  clear_has_txn();
}
 const ::cockroach::proto::Transaction& ReadWithinUncertaintyIntervalError::txn() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.ReadWithinUncertaintyIntervalError.txn)
  return txn_ != NULL ? *txn_ : *default_instance_->txn_;
}
 ::cockroach::proto::Transaction* ReadWithinUncertaintyIntervalError::mutable_txn() {
  set_has_txn();
  if (txn_ == NULL) {
    txn_ = new ::cockroach::proto::Transaction;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.proto.ReadWithinUncertaintyIntervalError.txn)
  return txn_;
}
 ::cockroach::proto::Transaction* ReadWithinUncertaintyIntervalError::release_txn() {
  clear_has_txn();
  ::cockroach::proto::Transaction* temp = txn_;
  txn_ = NULL;
  return temp;
}
 void ReadWithinUncertaintyIntervalError::set_allocated_txn(::cockroach::proto::Transaction* txn) {
  delete txn_;
  txn_ = txn;
  if (txn) {
    set_has_txn();
  } else {
    clear_has_txn();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.ReadWithinUncertaintyIntervalError.txn)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#ifndef _MSC_VER
const int TransactionAbortedError::kTxnFieldNumber;
#endif  // !_MSC_VER

TransactionAbortedError::TransactionAbortedError()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:cockroach.proto.TransactionAbortedError)
}

void TransactionAbortedError::InitAsDefaultInstance() {
  txn_ = const_cast< ::cockroach::proto::Transaction*>(&::cockroach::proto::Transaction::default_instance());
}

TransactionAbortedError::TransactionAbortedError(const TransactionAbortedError& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:cockroach.proto.TransactionAbortedError)
}

void TransactionAbortedError::SharedCtor() {
  _cached_size_ = 0;
  txn_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

TransactionAbortedError::~TransactionAbortedError() {
  // @@protoc_insertion_point(destructor:cockroach.proto.TransactionAbortedError)
  SharedDtor();
}

void TransactionAbortedError::SharedDtor() {
  if (this != default_instance_) {
    delete txn_;
  }
}

void TransactionAbortedError::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* TransactionAbortedError::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return TransactionAbortedError_descriptor_;
}

const TransactionAbortedError& TransactionAbortedError::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_cockroach_2fproto_2ferrors_2eproto();
  return *default_instance_;
}

TransactionAbortedError* TransactionAbortedError::default_instance_ = NULL;

TransactionAbortedError* TransactionAbortedError::New(::google::protobuf::Arena* arena) const {
  TransactionAbortedError* n = new TransactionAbortedError;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void TransactionAbortedError::Clear() {
  if (has_txn()) {
    if (txn_ != NULL) txn_->::cockroach::proto::Transaction::Clear();
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool TransactionAbortedError::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:cockroach.proto.TransactionAbortedError)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .cockroach.proto.Transaction txn = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_txn()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:cockroach.proto.TransactionAbortedError)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:cockroach.proto.TransactionAbortedError)
  return false;
#undef DO_
}

void TransactionAbortedError::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:cockroach.proto.TransactionAbortedError)
  // optional .cockroach.proto.Transaction txn = 1;
  if (has_txn()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->txn_, output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:cockroach.proto.TransactionAbortedError)
}

::google::protobuf::uint8* TransactionAbortedError::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:cockroach.proto.TransactionAbortedError)
  // optional .cockroach.proto.Transaction txn = 1;
  if (has_txn()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, *this->txn_, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:cockroach.proto.TransactionAbortedError)
  return target;
}

int TransactionAbortedError::ByteSize() const {
  int total_size = 0;

  // optional .cockroach.proto.Transaction txn = 1;
  if (has_txn()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->txn_);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TransactionAbortedError::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const TransactionAbortedError* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const TransactionAbortedError>(
          &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void TransactionAbortedError::MergeFrom(const TransactionAbortedError& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_txn()) {
      mutable_txn()->::cockroach::proto::Transaction::MergeFrom(from.txn());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void TransactionAbortedError::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TransactionAbortedError::CopyFrom(const TransactionAbortedError& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TransactionAbortedError::IsInitialized() const {

  return true;
}

void TransactionAbortedError::Swap(TransactionAbortedError* other) {
  if (other == this) return;
  InternalSwap(other);
}
void TransactionAbortedError::InternalSwap(TransactionAbortedError* other) {
  std::swap(txn_, other->txn_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata TransactionAbortedError::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = TransactionAbortedError_descriptor_;
  metadata.reflection = TransactionAbortedError_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// TransactionAbortedError

// optional .cockroach.proto.Transaction txn = 1;
bool TransactionAbortedError::has_txn() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void TransactionAbortedError::set_has_txn() {
  _has_bits_[0] |= 0x00000001u;
}
void TransactionAbortedError::clear_has_txn() {
  _has_bits_[0] &= ~0x00000001u;
}
void TransactionAbortedError::clear_txn() {
  if (txn_ != NULL) txn_->::cockroach::proto::Transaction::Clear();
  clear_has_txn();
}
 const ::cockroach::proto::Transaction& TransactionAbortedError::txn() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.TransactionAbortedError.txn)
  return txn_ != NULL ? *txn_ : *default_instance_->txn_;
}
 ::cockroach::proto::Transaction* TransactionAbortedError::mutable_txn() {
  set_has_txn();
  if (txn_ == NULL) {
    txn_ = new ::cockroach::proto::Transaction;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.proto.TransactionAbortedError.txn)
  return txn_;
}
 ::cockroach::proto::Transaction* TransactionAbortedError::release_txn() {
  clear_has_txn();
  ::cockroach::proto::Transaction* temp = txn_;
  txn_ = NULL;
  return temp;
}
 void TransactionAbortedError::set_allocated_txn(::cockroach::proto::Transaction* txn) {
  delete txn_;
  txn_ = txn;
  if (txn) {
    set_has_txn();
  } else {
    clear_has_txn();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.TransactionAbortedError.txn)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#ifndef _MSC_VER
const int TransactionPushError::kTxnFieldNumber;
const int TransactionPushError::kPusheeTxnFieldNumber;
#endif  // !_MSC_VER

TransactionPushError::TransactionPushError()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:cockroach.proto.TransactionPushError)
}

void TransactionPushError::InitAsDefaultInstance() {
  txn_ = const_cast< ::cockroach::proto::Transaction*>(&::cockroach::proto::Transaction::default_instance());
  pushee_txn_ = const_cast< ::cockroach::proto::Transaction*>(&::cockroach::proto::Transaction::default_instance());
}

TransactionPushError::TransactionPushError(const TransactionPushError& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:cockroach.proto.TransactionPushError)
}

void TransactionPushError::SharedCtor() {
  _cached_size_ = 0;
  txn_ = NULL;
  pushee_txn_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

TransactionPushError::~TransactionPushError() {
  // @@protoc_insertion_point(destructor:cockroach.proto.TransactionPushError)
  SharedDtor();
}

void TransactionPushError::SharedDtor() {
  if (this != default_instance_) {
    delete txn_;
    delete pushee_txn_;
  }
}

void TransactionPushError::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* TransactionPushError::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return TransactionPushError_descriptor_;
}

const TransactionPushError& TransactionPushError::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_cockroach_2fproto_2ferrors_2eproto();
  return *default_instance_;
}

TransactionPushError* TransactionPushError::default_instance_ = NULL;

TransactionPushError* TransactionPushError::New(::google::protobuf::Arena* arena) const {
  TransactionPushError* n = new TransactionPushError;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void TransactionPushError::Clear() {
  if (_has_bits_[0 / 32] & 3u) {
    if (has_txn()) {
      if (txn_ != NULL) txn_->::cockroach::proto::Transaction::Clear();
    }
    if (has_pushee_txn()) {
      if (pushee_txn_ != NULL) pushee_txn_->::cockroach::proto::Transaction::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool TransactionPushError::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:cockroach.proto.TransactionPushError)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .cockroach.proto.Transaction txn = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_txn()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_pushee_txn;
        break;
      }

      // optional .cockroach.proto.Transaction pushee_txn = 2;
      case 2: {
        if (tag == 18) {
         parse_pushee_txn:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_pushee_txn()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:cockroach.proto.TransactionPushError)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:cockroach.proto.TransactionPushError)
  return false;
#undef DO_
}

void TransactionPushError::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:cockroach.proto.TransactionPushError)
  // optional .cockroach.proto.Transaction txn = 1;
  if (has_txn()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->txn_, output);
  }

  // optional .cockroach.proto.Transaction pushee_txn = 2;
  if (has_pushee_txn()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, *this->pushee_txn_, output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:cockroach.proto.TransactionPushError)
}

::google::protobuf::uint8* TransactionPushError::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:cockroach.proto.TransactionPushError)
  // optional .cockroach.proto.Transaction txn = 1;
  if (has_txn()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, *this->txn_, target);
  }

  // optional .cockroach.proto.Transaction pushee_txn = 2;
  if (has_pushee_txn()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, *this->pushee_txn_, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:cockroach.proto.TransactionPushError)
  return target;
}

int TransactionPushError::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & 3) {
    // optional .cockroach.proto.Transaction txn = 1;
    if (has_txn()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->txn_);
    }

    // optional .cockroach.proto.Transaction pushee_txn = 2;
    if (has_pushee_txn()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->pushee_txn_);
    }

  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TransactionPushError::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const TransactionPushError* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const TransactionPushError>(
          &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void TransactionPushError::MergeFrom(const TransactionPushError& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_txn()) {
      mutable_txn()->::cockroach::proto::Transaction::MergeFrom(from.txn());
    }
    if (from.has_pushee_txn()) {
      mutable_pushee_txn()->::cockroach::proto::Transaction::MergeFrom(from.pushee_txn());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void TransactionPushError::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TransactionPushError::CopyFrom(const TransactionPushError& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TransactionPushError::IsInitialized() const {

  return true;
}

void TransactionPushError::Swap(TransactionPushError* other) {
  if (other == this) return;
  InternalSwap(other);
}
void TransactionPushError::InternalSwap(TransactionPushError* other) {
  std::swap(txn_, other->txn_);
  std::swap(pushee_txn_, other->pushee_txn_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata TransactionPushError::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = TransactionPushError_descriptor_;
  metadata.reflection = TransactionPushError_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// TransactionPushError

// optional .cockroach.proto.Transaction txn = 1;
bool TransactionPushError::has_txn() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void TransactionPushError::set_has_txn() {
  _has_bits_[0] |= 0x00000001u;
}
void TransactionPushError::clear_has_txn() {
  _has_bits_[0] &= ~0x00000001u;
}
void TransactionPushError::clear_txn() {
  if (txn_ != NULL) txn_->::cockroach::proto::Transaction::Clear();
  clear_has_txn();
}
 const ::cockroach::proto::Transaction& TransactionPushError::txn() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.TransactionPushError.txn)
  return txn_ != NULL ? *txn_ : *default_instance_->txn_;
}
 ::cockroach::proto::Transaction* TransactionPushError::mutable_txn() {
  set_has_txn();
  if (txn_ == NULL) {
    txn_ = new ::cockroach::proto::Transaction;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.proto.TransactionPushError.txn)
  return txn_;
}
 ::cockroach::proto::Transaction* TransactionPushError::release_txn() {
  clear_has_txn();
  ::cockroach::proto::Transaction* temp = txn_;
  txn_ = NULL;
  return temp;
}
 void TransactionPushError::set_allocated_txn(::cockroach::proto::Transaction* txn) {
  delete txn_;
  txn_ = txn;
  if (txn) {
    set_has_txn();
  } else {
    clear_has_txn();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.TransactionPushError.txn)
}

// optional .cockroach.proto.Transaction pushee_txn = 2;
bool TransactionPushError::has_pushee_txn() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void TransactionPushError::set_has_pushee_txn() {
  _has_bits_[0] |= 0x00000002u;
}
void TransactionPushError::clear_has_pushee_txn() {
  _has_bits_[0] &= ~0x00000002u;
}
void TransactionPushError::clear_pushee_txn() {
  if (pushee_txn_ != NULL) pushee_txn_->::cockroach::proto::Transaction::Clear();
  clear_has_pushee_txn();
}
 const ::cockroach::proto::Transaction& TransactionPushError::pushee_txn() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.TransactionPushError.pushee_txn)
  return pushee_txn_ != NULL ? *pushee_txn_ : *default_instance_->pushee_txn_;
}
 ::cockroach::proto::Transaction* TransactionPushError::mutable_pushee_txn() {
  set_has_pushee_txn();
  if (pushee_txn_ == NULL) {
    pushee_txn_ = new ::cockroach::proto::Transaction;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.proto.TransactionPushError.pushee_txn)
  return pushee_txn_;
}
 ::cockroach::proto::Transaction* TransactionPushError::release_pushee_txn() {
  clear_has_pushee_txn();
  ::cockroach::proto::Transaction* temp = pushee_txn_;
  pushee_txn_ = NULL;
  return temp;
}
 void TransactionPushError::set_allocated_pushee_txn(::cockroach::proto::Transaction* pushee_txn) {
  delete pushee_txn_;
  pushee_txn_ = pushee_txn;
  if (pushee_txn) {
    set_has_pushee_txn();
  } else {
    clear_has_pushee_txn();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.TransactionPushError.pushee_txn)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#ifndef _MSC_VER
const int TransactionRetryError::kTxnFieldNumber;
#endif  // !_MSC_VER

TransactionRetryError::TransactionRetryError()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:cockroach.proto.TransactionRetryError)
}

void TransactionRetryError::InitAsDefaultInstance() {
  txn_ = const_cast< ::cockroach::proto::Transaction*>(&::cockroach::proto::Transaction::default_instance());
}

TransactionRetryError::TransactionRetryError(const TransactionRetryError& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:cockroach.proto.TransactionRetryError)
}

void TransactionRetryError::SharedCtor() {
  _cached_size_ = 0;
  txn_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

TransactionRetryError::~TransactionRetryError() {
  // @@protoc_insertion_point(destructor:cockroach.proto.TransactionRetryError)
  SharedDtor();
}

void TransactionRetryError::SharedDtor() {
  if (this != default_instance_) {
    delete txn_;
  }
}

void TransactionRetryError::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* TransactionRetryError::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return TransactionRetryError_descriptor_;
}

const TransactionRetryError& TransactionRetryError::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_cockroach_2fproto_2ferrors_2eproto();
  return *default_instance_;
}

TransactionRetryError* TransactionRetryError::default_instance_ = NULL;

TransactionRetryError* TransactionRetryError::New(::google::protobuf::Arena* arena) const {
  TransactionRetryError* n = new TransactionRetryError;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void TransactionRetryError::Clear() {
  if (has_txn()) {
    if (txn_ != NULL) txn_->::cockroach::proto::Transaction::Clear();
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool TransactionRetryError::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:cockroach.proto.TransactionRetryError)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .cockroach.proto.Transaction txn = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_txn()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:cockroach.proto.TransactionRetryError)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:cockroach.proto.TransactionRetryError)
  return false;
#undef DO_
}

void TransactionRetryError::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:cockroach.proto.TransactionRetryError)
  // optional .cockroach.proto.Transaction txn = 1;
  if (has_txn()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->txn_, output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:cockroach.proto.TransactionRetryError)
}

::google::protobuf::uint8* TransactionRetryError::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:cockroach.proto.TransactionRetryError)
  // optional .cockroach.proto.Transaction txn = 1;
  if (has_txn()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, *this->txn_, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:cockroach.proto.TransactionRetryError)
  return target;
}

int TransactionRetryError::ByteSize() const {
  int total_size = 0;

  // optional .cockroach.proto.Transaction txn = 1;
  if (has_txn()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->txn_);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TransactionRetryError::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const TransactionRetryError* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const TransactionRetryError>(
          &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void TransactionRetryError::MergeFrom(const TransactionRetryError& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_txn()) {
      mutable_txn()->::cockroach::proto::Transaction::MergeFrom(from.txn());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void TransactionRetryError::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TransactionRetryError::CopyFrom(const TransactionRetryError& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TransactionRetryError::IsInitialized() const {

  return true;
}

void TransactionRetryError::Swap(TransactionRetryError* other) {
  if (other == this) return;
  InternalSwap(other);
}
void TransactionRetryError::InternalSwap(TransactionRetryError* other) {
  std::swap(txn_, other->txn_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata TransactionRetryError::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = TransactionRetryError_descriptor_;
  metadata.reflection = TransactionRetryError_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// TransactionRetryError

// optional .cockroach.proto.Transaction txn = 1;
bool TransactionRetryError::has_txn() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void TransactionRetryError::set_has_txn() {
  _has_bits_[0] |= 0x00000001u;
}
void TransactionRetryError::clear_has_txn() {
  _has_bits_[0] &= ~0x00000001u;
}
void TransactionRetryError::clear_txn() {
  if (txn_ != NULL) txn_->::cockroach::proto::Transaction::Clear();
  clear_has_txn();
}
 const ::cockroach::proto::Transaction& TransactionRetryError::txn() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.TransactionRetryError.txn)
  return txn_ != NULL ? *txn_ : *default_instance_->txn_;
}
 ::cockroach::proto::Transaction* TransactionRetryError::mutable_txn() {
  set_has_txn();
  if (txn_ == NULL) {
    txn_ = new ::cockroach::proto::Transaction;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.proto.TransactionRetryError.txn)
  return txn_;
}
 ::cockroach::proto::Transaction* TransactionRetryError::release_txn() {
  clear_has_txn();
  ::cockroach::proto::Transaction* temp = txn_;
  txn_ = NULL;
  return temp;
}
 void TransactionRetryError::set_allocated_txn(::cockroach::proto::Transaction* txn) {
  delete txn_;
  txn_ = txn;
  if (txn) {
    set_has_txn();
  } else {
    clear_has_txn();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.TransactionRetryError.txn)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#ifndef _MSC_VER
const int TransactionStatusError::kTxnFieldNumber;
const int TransactionStatusError::kMsgFieldNumber;
#endif  // !_MSC_VER

TransactionStatusError::TransactionStatusError()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:cockroach.proto.TransactionStatusError)
}

void TransactionStatusError::InitAsDefaultInstance() {
  txn_ = const_cast< ::cockroach::proto::Transaction*>(&::cockroach::proto::Transaction::default_instance());
}

TransactionStatusError::TransactionStatusError(const TransactionStatusError& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:cockroach.proto.TransactionStatusError)
}

void TransactionStatusError::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  txn_ = NULL;
  msg_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

TransactionStatusError::~TransactionStatusError() {
  // @@protoc_insertion_point(destructor:cockroach.proto.TransactionStatusError)
  SharedDtor();
}

void TransactionStatusError::SharedDtor() {
  msg_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != default_instance_) {
    delete txn_;
  }
}

void TransactionStatusError::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* TransactionStatusError::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return TransactionStatusError_descriptor_;
}

const TransactionStatusError& TransactionStatusError::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_cockroach_2fproto_2ferrors_2eproto();
  return *default_instance_;
}

TransactionStatusError* TransactionStatusError::default_instance_ = NULL;

TransactionStatusError* TransactionStatusError::New(::google::protobuf::Arena* arena) const {
  TransactionStatusError* n = new TransactionStatusError;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void TransactionStatusError::Clear() {
  if (_has_bits_[0 / 32] & 3u) {
    if (has_txn()) {
      if (txn_ != NULL) txn_->::cockroach::proto::Transaction::Clear();
    }
    if (has_msg()) {
      msg_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool TransactionStatusError::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:cockroach.proto.TransactionStatusError)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .cockroach.proto.Transaction txn = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_txn()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_msg;
        break;
      }

      // optional string msg = 2;
      case 2: {
        if (tag == 18) {
         parse_msg:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_msg()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->msg().data(), this->msg().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "cockroach.proto.TransactionStatusError.msg");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:cockroach.proto.TransactionStatusError)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:cockroach.proto.TransactionStatusError)
  return false;
#undef DO_
}

void TransactionStatusError::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:cockroach.proto.TransactionStatusError)
  // optional .cockroach.proto.Transaction txn = 1;
  if (has_txn()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->txn_, output);
  }

  // optional string msg = 2;
  if (has_msg()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->msg().data(), this->msg().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "cockroach.proto.TransactionStatusError.msg");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->msg(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:cockroach.proto.TransactionStatusError)
}

::google::protobuf::uint8* TransactionStatusError::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:cockroach.proto.TransactionStatusError)
  // optional .cockroach.proto.Transaction txn = 1;
  if (has_txn()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, *this->txn_, target);
  }

  // optional string msg = 2;
  if (has_msg()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->msg().data(), this->msg().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "cockroach.proto.TransactionStatusError.msg");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->msg(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:cockroach.proto.TransactionStatusError)
  return target;
}

int TransactionStatusError::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & 3) {
    // optional .cockroach.proto.Transaction txn = 1;
    if (has_txn()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->txn_);
    }

    // optional string msg = 2;
    if (has_msg()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->msg());
    }

  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TransactionStatusError::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const TransactionStatusError* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const TransactionStatusError>(
          &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void TransactionStatusError::MergeFrom(const TransactionStatusError& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_txn()) {
      mutable_txn()->::cockroach::proto::Transaction::MergeFrom(from.txn());
    }
    if (from.has_msg()) {
      set_has_msg();
      msg_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.msg_);
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void TransactionStatusError::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TransactionStatusError::CopyFrom(const TransactionStatusError& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TransactionStatusError::IsInitialized() const {

  return true;
}

void TransactionStatusError::Swap(TransactionStatusError* other) {
  if (other == this) return;
  InternalSwap(other);
}
void TransactionStatusError::InternalSwap(TransactionStatusError* other) {
  std::swap(txn_, other->txn_);
  msg_.Swap(&other->msg_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata TransactionStatusError::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = TransactionStatusError_descriptor_;
  metadata.reflection = TransactionStatusError_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// TransactionStatusError

// optional .cockroach.proto.Transaction txn = 1;
bool TransactionStatusError::has_txn() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void TransactionStatusError::set_has_txn() {
  _has_bits_[0] |= 0x00000001u;
}
void TransactionStatusError::clear_has_txn() {
  _has_bits_[0] &= ~0x00000001u;
}
void TransactionStatusError::clear_txn() {
  if (txn_ != NULL) txn_->::cockroach::proto::Transaction::Clear();
  clear_has_txn();
}
 const ::cockroach::proto::Transaction& TransactionStatusError::txn() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.TransactionStatusError.txn)
  return txn_ != NULL ? *txn_ : *default_instance_->txn_;
}
 ::cockroach::proto::Transaction* TransactionStatusError::mutable_txn() {
  set_has_txn();
  if (txn_ == NULL) {
    txn_ = new ::cockroach::proto::Transaction;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.proto.TransactionStatusError.txn)
  return txn_;
}
 ::cockroach::proto::Transaction* TransactionStatusError::release_txn() {
  clear_has_txn();
  ::cockroach::proto::Transaction* temp = txn_;
  txn_ = NULL;
  return temp;
}
 void TransactionStatusError::set_allocated_txn(::cockroach::proto::Transaction* txn) {
  delete txn_;
  txn_ = txn;
  if (txn) {
    set_has_txn();
  } else {
    clear_has_txn();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.TransactionStatusError.txn)
}

// optional string msg = 2;
bool TransactionStatusError::has_msg() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void TransactionStatusError::set_has_msg() {
  _has_bits_[0] |= 0x00000002u;
}
void TransactionStatusError::clear_has_msg() {
  _has_bits_[0] &= ~0x00000002u;
}
void TransactionStatusError::clear_msg() {
  msg_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_msg();
}
 const ::std::string& TransactionStatusError::msg() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.TransactionStatusError.msg)
  return msg_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void TransactionStatusError::set_msg(const ::std::string& value) {
  set_has_msg();
  msg_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cockroach.proto.TransactionStatusError.msg)
}
 void TransactionStatusError::set_msg(const char* value) {
  set_has_msg();
  msg_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cockroach.proto.TransactionStatusError.msg)
}
 void TransactionStatusError::set_msg(const char* value, size_t size) {
  set_has_msg();
  msg_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cockroach.proto.TransactionStatusError.msg)
}
 ::std::string* TransactionStatusError::mutable_msg() {
  set_has_msg();
  // @@protoc_insertion_point(field_mutable:cockroach.proto.TransactionStatusError.msg)
  return msg_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* TransactionStatusError::release_msg() {
  clear_has_msg();
  return msg_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void TransactionStatusError::set_allocated_msg(::std::string* msg) {
  if (msg != NULL) {
    set_has_msg();
  } else {
    clear_has_msg();
  }
  msg_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), msg);
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.TransactionStatusError.msg)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#ifndef _MSC_VER
const int WriteIntentError::kIntentsFieldNumber;
const int WriteIntentError::kResolvedFieldNumber;
#endif  // !_MSC_VER

WriteIntentError::WriteIntentError()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:cockroach.proto.WriteIntentError)
}

void WriteIntentError::InitAsDefaultInstance() {
}

WriteIntentError::WriteIntentError(const WriteIntentError& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:cockroach.proto.WriteIntentError)
}

void WriteIntentError::SharedCtor() {
  _cached_size_ = 0;
  resolved_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

WriteIntentError::~WriteIntentError() {
  // @@protoc_insertion_point(destructor:cockroach.proto.WriteIntentError)
  SharedDtor();
}

void WriteIntentError::SharedDtor() {
  if (this != default_instance_) {
  }
}

void WriteIntentError::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* WriteIntentError::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return WriteIntentError_descriptor_;
}

const WriteIntentError& WriteIntentError::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_cockroach_2fproto_2ferrors_2eproto();
  return *default_instance_;
}

WriteIntentError* WriteIntentError::default_instance_ = NULL;

WriteIntentError* WriteIntentError::New(::google::protobuf::Arena* arena) const {
  WriteIntentError* n = new WriteIntentError;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void WriteIntentError::Clear() {
  resolved_ = false;
  intents_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool WriteIntentError::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:cockroach.proto.WriteIntentError)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .cockroach.proto.Intent intents = 1;
      case 1: {
        if (tag == 10) {
          DO_(input->IncrementRecursionDepth());
         parse_loop_intents:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                input, add_intents()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(10)) goto parse_loop_intents;
        input->UnsafeDecrementRecursionDepth();
        if (input->ExpectTag(16)) goto parse_resolved;
        break;
      }

      // optional bool resolved = 2;
      case 2: {
        if (tag == 16) {
         parse_resolved:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &resolved_)));
          set_has_resolved();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:cockroach.proto.WriteIntentError)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:cockroach.proto.WriteIntentError)
  return false;
#undef DO_
}

void WriteIntentError::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:cockroach.proto.WriteIntentError)
  // repeated .cockroach.proto.Intent intents = 1;
  for (unsigned int i = 0, n = this->intents_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->intents(i), output);
  }

  // optional bool resolved = 2;
  if (has_resolved()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(2, this->resolved(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:cockroach.proto.WriteIntentError)
}

::google::protobuf::uint8* WriteIntentError::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:cockroach.proto.WriteIntentError)
  // repeated .cockroach.proto.Intent intents = 1;
  for (unsigned int i = 0, n = this->intents_size(); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->intents(i), target);
  }

  // optional bool resolved = 2;
  if (has_resolved()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(2, this->resolved(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:cockroach.proto.WriteIntentError)
  return target;
}

int WriteIntentError::ByteSize() const {
  int total_size = 0;

  // optional bool resolved = 2;
  if (has_resolved()) {
    total_size += 1 + 1;
  }

  // repeated .cockroach.proto.Intent intents = 1;
  total_size += 1 * this->intents_size();
  for (int i = 0; i < this->intents_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->intents(i));
  }

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void WriteIntentError::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const WriteIntentError* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const WriteIntentError>(
          &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void WriteIntentError::MergeFrom(const WriteIntentError& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  intents_.MergeFrom(from.intents_);
  if (from._has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    if (from.has_resolved()) {
      set_resolved(from.resolved());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void WriteIntentError::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void WriteIntentError::CopyFrom(const WriteIntentError& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool WriteIntentError::IsInitialized() const {

  return true;
}

void WriteIntentError::Swap(WriteIntentError* other) {
  if (other == this) return;
  InternalSwap(other);
}
void WriteIntentError::InternalSwap(WriteIntentError* other) {
  intents_.UnsafeArenaSwap(&other->intents_);
  std::swap(resolved_, other->resolved_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata WriteIntentError::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = WriteIntentError_descriptor_;
  metadata.reflection = WriteIntentError_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// WriteIntentError

// repeated .cockroach.proto.Intent intents = 1;
int WriteIntentError::intents_size() const {
  return intents_.size();
}
void WriteIntentError::clear_intents() {
  intents_.Clear();
}
 const ::cockroach::proto::Intent& WriteIntentError::intents(int index) const {
  // @@protoc_insertion_point(field_get:cockroach.proto.WriteIntentError.intents)
  return intents_.Get(index);
}
 ::cockroach::proto::Intent* WriteIntentError::mutable_intents(int index) {
  // @@protoc_insertion_point(field_mutable:cockroach.proto.WriteIntentError.intents)
  return intents_.Mutable(index);
}
 ::cockroach::proto::Intent* WriteIntentError::add_intents() {
  // @@protoc_insertion_point(field_add:cockroach.proto.WriteIntentError.intents)
  return intents_.Add();
}
 const ::google::protobuf::RepeatedPtrField< ::cockroach::proto::Intent >&
WriteIntentError::intents() const {
  // @@protoc_insertion_point(field_list:cockroach.proto.WriteIntentError.intents)
  return intents_;
}
 ::google::protobuf::RepeatedPtrField< ::cockroach::proto::Intent >*
WriteIntentError::mutable_intents() {
  // @@protoc_insertion_point(field_mutable_list:cockroach.proto.WriteIntentError.intents)
  return &intents_;
}

// optional bool resolved = 2;
bool WriteIntentError::has_resolved() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void WriteIntentError::set_has_resolved() {
  _has_bits_[0] |= 0x00000002u;
}
void WriteIntentError::clear_has_resolved() {
  _has_bits_[0] &= ~0x00000002u;
}
void WriteIntentError::clear_resolved() {
  resolved_ = false;
  clear_has_resolved();
}
 bool WriteIntentError::resolved() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.WriteIntentError.resolved)
  return resolved_;
}
 void WriteIntentError::set_resolved(bool value) {
  set_has_resolved();
  resolved_ = value;
  // @@protoc_insertion_point(field_set:cockroach.proto.WriteIntentError.resolved)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#ifndef _MSC_VER
const int WriteTooOldError::kTimestampFieldNumber;
const int WriteTooOldError::kExistingTimestampFieldNumber;
#endif  // !_MSC_VER

WriteTooOldError::WriteTooOldError()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:cockroach.proto.WriteTooOldError)
}

void WriteTooOldError::InitAsDefaultInstance() {
  timestamp_ = const_cast< ::cockroach::proto::Timestamp*>(&::cockroach::proto::Timestamp::default_instance());
  existing_timestamp_ = const_cast< ::cockroach::proto::Timestamp*>(&::cockroach::proto::Timestamp::default_instance());
}

WriteTooOldError::WriteTooOldError(const WriteTooOldError& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:cockroach.proto.WriteTooOldError)
}

void WriteTooOldError::SharedCtor() {
  _cached_size_ = 0;
  timestamp_ = NULL;
  existing_timestamp_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

WriteTooOldError::~WriteTooOldError() {
  // @@protoc_insertion_point(destructor:cockroach.proto.WriteTooOldError)
  SharedDtor();
}

void WriteTooOldError::SharedDtor() {
  if (this != default_instance_) {
    delete timestamp_;
    delete existing_timestamp_;
  }
}

void WriteTooOldError::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* WriteTooOldError::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return WriteTooOldError_descriptor_;
}

const WriteTooOldError& WriteTooOldError::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_cockroach_2fproto_2ferrors_2eproto();
  return *default_instance_;
}

WriteTooOldError* WriteTooOldError::default_instance_ = NULL;

WriteTooOldError* WriteTooOldError::New(::google::protobuf::Arena* arena) const {
  WriteTooOldError* n = new WriteTooOldError;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void WriteTooOldError::Clear() {
  if (_has_bits_[0 / 32] & 3u) {
    if (has_timestamp()) {
      if (timestamp_ != NULL) timestamp_->::cockroach::proto::Timestamp::Clear();
    }
    if (has_existing_timestamp()) {
      if (existing_timestamp_ != NULL) existing_timestamp_->::cockroach::proto::Timestamp::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool WriteTooOldError::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:cockroach.proto.WriteTooOldError)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .cockroach.proto.Timestamp timestamp = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_timestamp()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_existing_timestamp;
        break;
      }

      // optional .cockroach.proto.Timestamp existing_timestamp = 2;
      case 2: {
        if (tag == 18) {
         parse_existing_timestamp:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_existing_timestamp()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:cockroach.proto.WriteTooOldError)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:cockroach.proto.WriteTooOldError)
  return false;
#undef DO_
}

void WriteTooOldError::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:cockroach.proto.WriteTooOldError)
  // optional .cockroach.proto.Timestamp timestamp = 1;
  if (has_timestamp()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->timestamp_, output);
  }

  // optional .cockroach.proto.Timestamp existing_timestamp = 2;
  if (has_existing_timestamp()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, *this->existing_timestamp_, output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:cockroach.proto.WriteTooOldError)
}

::google::protobuf::uint8* WriteTooOldError::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:cockroach.proto.WriteTooOldError)
  // optional .cockroach.proto.Timestamp timestamp = 1;
  if (has_timestamp()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, *this->timestamp_, target);
  }

  // optional .cockroach.proto.Timestamp existing_timestamp = 2;
  if (has_existing_timestamp()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, *this->existing_timestamp_, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:cockroach.proto.WriteTooOldError)
  return target;
}

int WriteTooOldError::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & 3) {
    // optional .cockroach.proto.Timestamp timestamp = 1;
    if (has_timestamp()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->timestamp_);
    }

    // optional .cockroach.proto.Timestamp existing_timestamp = 2;
    if (has_existing_timestamp()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->existing_timestamp_);
    }

  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void WriteTooOldError::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const WriteTooOldError* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const WriteTooOldError>(
          &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void WriteTooOldError::MergeFrom(const WriteTooOldError& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_timestamp()) {
      mutable_timestamp()->::cockroach::proto::Timestamp::MergeFrom(from.timestamp());
    }
    if (from.has_existing_timestamp()) {
      mutable_existing_timestamp()->::cockroach::proto::Timestamp::MergeFrom(from.existing_timestamp());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void WriteTooOldError::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void WriteTooOldError::CopyFrom(const WriteTooOldError& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool WriteTooOldError::IsInitialized() const {

  return true;
}

void WriteTooOldError::Swap(WriteTooOldError* other) {
  if (other == this) return;
  InternalSwap(other);
}
void WriteTooOldError::InternalSwap(WriteTooOldError* other) {
  std::swap(timestamp_, other->timestamp_);
  std::swap(existing_timestamp_, other->existing_timestamp_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata WriteTooOldError::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = WriteTooOldError_descriptor_;
  metadata.reflection = WriteTooOldError_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// WriteTooOldError

// optional .cockroach.proto.Timestamp timestamp = 1;
bool WriteTooOldError::has_timestamp() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void WriteTooOldError::set_has_timestamp() {
  _has_bits_[0] |= 0x00000001u;
}
void WriteTooOldError::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000001u;
}
void WriteTooOldError::clear_timestamp() {
  if (timestamp_ != NULL) timestamp_->::cockroach::proto::Timestamp::Clear();
  clear_has_timestamp();
}
 const ::cockroach::proto::Timestamp& WriteTooOldError::timestamp() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.WriteTooOldError.timestamp)
  return timestamp_ != NULL ? *timestamp_ : *default_instance_->timestamp_;
}
 ::cockroach::proto::Timestamp* WriteTooOldError::mutable_timestamp() {
  set_has_timestamp();
  if (timestamp_ == NULL) {
    timestamp_ = new ::cockroach::proto::Timestamp;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.proto.WriteTooOldError.timestamp)
  return timestamp_;
}
 ::cockroach::proto::Timestamp* WriteTooOldError::release_timestamp() {
  clear_has_timestamp();
  ::cockroach::proto::Timestamp* temp = timestamp_;
  timestamp_ = NULL;
  return temp;
}
 void WriteTooOldError::set_allocated_timestamp(::cockroach::proto::Timestamp* timestamp) {
  delete timestamp_;
  timestamp_ = timestamp;
  if (timestamp) {
    set_has_timestamp();
  } else {
    clear_has_timestamp();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.WriteTooOldError.timestamp)
}

// optional .cockroach.proto.Timestamp existing_timestamp = 2;
bool WriteTooOldError::has_existing_timestamp() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void WriteTooOldError::set_has_existing_timestamp() {
  _has_bits_[0] |= 0x00000002u;
}
void WriteTooOldError::clear_has_existing_timestamp() {
  _has_bits_[0] &= ~0x00000002u;
}
void WriteTooOldError::clear_existing_timestamp() {
  if (existing_timestamp_ != NULL) existing_timestamp_->::cockroach::proto::Timestamp::Clear();
  clear_has_existing_timestamp();
}
 const ::cockroach::proto::Timestamp& WriteTooOldError::existing_timestamp() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.WriteTooOldError.existing_timestamp)
  return existing_timestamp_ != NULL ? *existing_timestamp_ : *default_instance_->existing_timestamp_;
}
 ::cockroach::proto::Timestamp* WriteTooOldError::mutable_existing_timestamp() {
  set_has_existing_timestamp();
  if (existing_timestamp_ == NULL) {
    existing_timestamp_ = new ::cockroach::proto::Timestamp;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.proto.WriteTooOldError.existing_timestamp)
  return existing_timestamp_;
}
 ::cockroach::proto::Timestamp* WriteTooOldError::release_existing_timestamp() {
  clear_has_existing_timestamp();
  ::cockroach::proto::Timestamp* temp = existing_timestamp_;
  existing_timestamp_ = NULL;
  return temp;
}
 void WriteTooOldError::set_allocated_existing_timestamp(::cockroach::proto::Timestamp* existing_timestamp) {
  delete existing_timestamp_;
  existing_timestamp_ = existing_timestamp;
  if (existing_timestamp) {
    set_has_existing_timestamp();
  } else {
    clear_has_existing_timestamp();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.WriteTooOldError.existing_timestamp)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

OpRequiresTxnError::OpRequiresTxnError()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:cockroach.proto.OpRequiresTxnError)
}

void OpRequiresTxnError::InitAsDefaultInstance() {
}

OpRequiresTxnError::OpRequiresTxnError(const OpRequiresTxnError& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:cockroach.proto.OpRequiresTxnError)
}

void OpRequiresTxnError::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

OpRequiresTxnError::~OpRequiresTxnError() {
  // @@protoc_insertion_point(destructor:cockroach.proto.OpRequiresTxnError)
  SharedDtor();
}

void OpRequiresTxnError::SharedDtor() {
  if (this != default_instance_) {
  }
}

void OpRequiresTxnError::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* OpRequiresTxnError::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return OpRequiresTxnError_descriptor_;
}

const OpRequiresTxnError& OpRequiresTxnError::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_cockroach_2fproto_2ferrors_2eproto();
  return *default_instance_;
}

OpRequiresTxnError* OpRequiresTxnError::default_instance_ = NULL;

OpRequiresTxnError* OpRequiresTxnError::New(::google::protobuf::Arena* arena) const {
  OpRequiresTxnError* n = new OpRequiresTxnError;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void OpRequiresTxnError::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool OpRequiresTxnError::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:cockroach.proto.OpRequiresTxnError)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormat::SkipField(
          input, tag, mutable_unknown_fields()));
  }
success:
  // @@protoc_insertion_point(parse_success:cockroach.proto.OpRequiresTxnError)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:cockroach.proto.OpRequiresTxnError)
  return false;
#undef DO_
}

void OpRequiresTxnError::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:cockroach.proto.OpRequiresTxnError)
  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:cockroach.proto.OpRequiresTxnError)
}

::google::protobuf::uint8* OpRequiresTxnError::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:cockroach.proto.OpRequiresTxnError)
  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:cockroach.proto.OpRequiresTxnError)
  return target;
}

int OpRequiresTxnError::ByteSize() const {
  int total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void OpRequiresTxnError::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const OpRequiresTxnError* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const OpRequiresTxnError>(
          &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void OpRequiresTxnError::MergeFrom(const OpRequiresTxnError& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void OpRequiresTxnError::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void OpRequiresTxnError::CopyFrom(const OpRequiresTxnError& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool OpRequiresTxnError::IsInitialized() const {

  return true;
}

void OpRequiresTxnError::Swap(OpRequiresTxnError* other) {
  if (other == this) return;
  InternalSwap(other);
}
void OpRequiresTxnError::InternalSwap(OpRequiresTxnError* other) {
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata OpRequiresTxnError::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = OpRequiresTxnError_descriptor_;
  metadata.reflection = OpRequiresTxnError_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// OpRequiresTxnError

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#ifndef _MSC_VER
const int ConditionFailedError::kActualValueFieldNumber;
#endif  // !_MSC_VER

ConditionFailedError::ConditionFailedError()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:cockroach.proto.ConditionFailedError)
}

void ConditionFailedError::InitAsDefaultInstance() {
  actual_value_ = const_cast< ::cockroach::proto::Value*>(&::cockroach::proto::Value::default_instance());
}

ConditionFailedError::ConditionFailedError(const ConditionFailedError& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:cockroach.proto.ConditionFailedError)
}

void ConditionFailedError::SharedCtor() {
  _cached_size_ = 0;
  actual_value_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ConditionFailedError::~ConditionFailedError() {
  // @@protoc_insertion_point(destructor:cockroach.proto.ConditionFailedError)
  SharedDtor();
}

void ConditionFailedError::SharedDtor() {
  if (this != default_instance_) {
    delete actual_value_;
  }
}

void ConditionFailedError::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ConditionFailedError::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ConditionFailedError_descriptor_;
}

const ConditionFailedError& ConditionFailedError::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_cockroach_2fproto_2ferrors_2eproto();
  return *default_instance_;
}

ConditionFailedError* ConditionFailedError::default_instance_ = NULL;

ConditionFailedError* ConditionFailedError::New(::google::protobuf::Arena* arena) const {
  ConditionFailedError* n = new ConditionFailedError;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void ConditionFailedError::Clear() {
  if (has_actual_value()) {
    if (actual_value_ != NULL) actual_value_->::cockroach::proto::Value::Clear();
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool ConditionFailedError::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:cockroach.proto.ConditionFailedError)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .cockroach.proto.Value actual_value = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_actual_value()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:cockroach.proto.ConditionFailedError)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:cockroach.proto.ConditionFailedError)
  return false;
#undef DO_
}

void ConditionFailedError::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:cockroach.proto.ConditionFailedError)
  // optional .cockroach.proto.Value actual_value = 1;
  if (has_actual_value()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->actual_value_, output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:cockroach.proto.ConditionFailedError)
}

::google::protobuf::uint8* ConditionFailedError::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:cockroach.proto.ConditionFailedError)
  // optional .cockroach.proto.Value actual_value = 1;
  if (has_actual_value()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, *this->actual_value_, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:cockroach.proto.ConditionFailedError)
  return target;
}

int ConditionFailedError::ByteSize() const {
  int total_size = 0;

  // optional .cockroach.proto.Value actual_value = 1;
  if (has_actual_value()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->actual_value_);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ConditionFailedError::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const ConditionFailedError* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const ConditionFailedError>(
          &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ConditionFailedError::MergeFrom(const ConditionFailedError& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_actual_value()) {
      mutable_actual_value()->::cockroach::proto::Value::MergeFrom(from.actual_value());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void ConditionFailedError::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ConditionFailedError::CopyFrom(const ConditionFailedError& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ConditionFailedError::IsInitialized() const {

  return true;
}

void ConditionFailedError::Swap(ConditionFailedError* other) {
  if (other == this) return;
  InternalSwap(other);
}
void ConditionFailedError::InternalSwap(ConditionFailedError* other) {
  std::swap(actual_value_, other->actual_value_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata ConditionFailedError::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ConditionFailedError_descriptor_;
  metadata.reflection = ConditionFailedError_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// ConditionFailedError

// optional .cockroach.proto.Value actual_value = 1;
bool ConditionFailedError::has_actual_value() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void ConditionFailedError::set_has_actual_value() {
  _has_bits_[0] |= 0x00000001u;
}
void ConditionFailedError::clear_has_actual_value() {
  _has_bits_[0] &= ~0x00000001u;
}
void ConditionFailedError::clear_actual_value() {
  if (actual_value_ != NULL) actual_value_->::cockroach::proto::Value::Clear();
  clear_has_actual_value();
}
 const ::cockroach::proto::Value& ConditionFailedError::actual_value() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.ConditionFailedError.actual_value)
  return actual_value_ != NULL ? *actual_value_ : *default_instance_->actual_value_;
}
 ::cockroach::proto::Value* ConditionFailedError::mutable_actual_value() {
  set_has_actual_value();
  if (actual_value_ == NULL) {
    actual_value_ = new ::cockroach::proto::Value;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.proto.ConditionFailedError.actual_value)
  return actual_value_;
}
 ::cockroach::proto::Value* ConditionFailedError::release_actual_value() {
  clear_has_actual_value();
  ::cockroach::proto::Value* temp = actual_value_;
  actual_value_ = NULL;
  return temp;
}
 void ConditionFailedError::set_allocated_actual_value(::cockroach::proto::Value* actual_value) {
  delete actual_value_;
  actual_value_ = actual_value;
  if (actual_value) {
    set_has_actual_value();
  } else {
    clear_has_actual_value();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.ConditionFailedError.actual_value)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#ifndef _MSC_VER
const int LeaseRejectedError::kRequestedFieldNumber;
const int LeaseRejectedError::kExistingFieldNumber;
#endif  // !_MSC_VER

LeaseRejectedError::LeaseRejectedError()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:cockroach.proto.LeaseRejectedError)
}

void LeaseRejectedError::InitAsDefaultInstance() {
  requested_ = const_cast< ::cockroach::proto::Lease*>(&::cockroach::proto::Lease::default_instance());
  existing_ = const_cast< ::cockroach::proto::Lease*>(&::cockroach::proto::Lease::default_instance());
}

LeaseRejectedError::LeaseRejectedError(const LeaseRejectedError& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:cockroach.proto.LeaseRejectedError)
}

void LeaseRejectedError::SharedCtor() {
  _cached_size_ = 0;
  requested_ = NULL;
  existing_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

LeaseRejectedError::~LeaseRejectedError() {
  // @@protoc_insertion_point(destructor:cockroach.proto.LeaseRejectedError)
  SharedDtor();
}

void LeaseRejectedError::SharedDtor() {
  if (this != default_instance_) {
    delete requested_;
    delete existing_;
  }
}

void LeaseRejectedError::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* LeaseRejectedError::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return LeaseRejectedError_descriptor_;
}

const LeaseRejectedError& LeaseRejectedError::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_cockroach_2fproto_2ferrors_2eproto();
  return *default_instance_;
}

LeaseRejectedError* LeaseRejectedError::default_instance_ = NULL;

LeaseRejectedError* LeaseRejectedError::New(::google::protobuf::Arena* arena) const {
  LeaseRejectedError* n = new LeaseRejectedError;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void LeaseRejectedError::Clear() {
  if (_has_bits_[0 / 32] & 3u) {
    if (has_requested()) {
      if (requested_ != NULL) requested_->::cockroach::proto::Lease::Clear();
    }
    if (has_existing()) {
      if (existing_ != NULL) existing_->::cockroach::proto::Lease::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool LeaseRejectedError::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:cockroach.proto.LeaseRejectedError)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .cockroach.proto.Lease Requested = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_requested()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_Existing;
        break;
      }

      // optional .cockroach.proto.Lease Existing = 2;
      case 2: {
        if (tag == 18) {
         parse_Existing:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_existing()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:cockroach.proto.LeaseRejectedError)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:cockroach.proto.LeaseRejectedError)
  return false;
#undef DO_
}

void LeaseRejectedError::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:cockroach.proto.LeaseRejectedError)
  // optional .cockroach.proto.Lease Requested = 1;
  if (has_requested()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->requested_, output);
  }

  // optional .cockroach.proto.Lease Existing = 2;
  if (has_existing()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, *this->existing_, output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:cockroach.proto.LeaseRejectedError)
}

::google::protobuf::uint8* LeaseRejectedError::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:cockroach.proto.LeaseRejectedError)
  // optional .cockroach.proto.Lease Requested = 1;
  if (has_requested()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, *this->requested_, target);
  }

  // optional .cockroach.proto.Lease Existing = 2;
  if (has_existing()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, *this->existing_, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:cockroach.proto.LeaseRejectedError)
  return target;
}

int LeaseRejectedError::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & 3) {
    // optional .cockroach.proto.Lease Requested = 1;
    if (has_requested()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->requested_);
    }

    // optional .cockroach.proto.Lease Existing = 2;
    if (has_existing()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->existing_);
    }

  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void LeaseRejectedError::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const LeaseRejectedError* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const LeaseRejectedError>(
          &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void LeaseRejectedError::MergeFrom(const LeaseRejectedError& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_requested()) {
      mutable_requested()->::cockroach::proto::Lease::MergeFrom(from.requested());
    }
    if (from.has_existing()) {
      mutable_existing()->::cockroach::proto::Lease::MergeFrom(from.existing());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void LeaseRejectedError::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void LeaseRejectedError::CopyFrom(const LeaseRejectedError& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LeaseRejectedError::IsInitialized() const {

  return true;
}

void LeaseRejectedError::Swap(LeaseRejectedError* other) {
  if (other == this) return;
  InternalSwap(other);
}
void LeaseRejectedError::InternalSwap(LeaseRejectedError* other) {
  std::swap(requested_, other->requested_);
  std::swap(existing_, other->existing_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata LeaseRejectedError::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = LeaseRejectedError_descriptor_;
  metadata.reflection = LeaseRejectedError_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// LeaseRejectedError

// optional .cockroach.proto.Lease Requested = 1;
bool LeaseRejectedError::has_requested() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void LeaseRejectedError::set_has_requested() {
  _has_bits_[0] |= 0x00000001u;
}
void LeaseRejectedError::clear_has_requested() {
  _has_bits_[0] &= ~0x00000001u;
}
void LeaseRejectedError::clear_requested() {
  if (requested_ != NULL) requested_->::cockroach::proto::Lease::Clear();
  clear_has_requested();
}
 const ::cockroach::proto::Lease& LeaseRejectedError::requested() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.LeaseRejectedError.Requested)
  return requested_ != NULL ? *requested_ : *default_instance_->requested_;
}
 ::cockroach::proto::Lease* LeaseRejectedError::mutable_requested() {
  set_has_requested();
  if (requested_ == NULL) {
    requested_ = new ::cockroach::proto::Lease;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.proto.LeaseRejectedError.Requested)
  return requested_;
}
 ::cockroach::proto::Lease* LeaseRejectedError::release_requested() {
  clear_has_requested();
  ::cockroach::proto::Lease* temp = requested_;
  requested_ = NULL;
  return temp;
}
 void LeaseRejectedError::set_allocated_requested(::cockroach::proto::Lease* requested) {
  delete requested_;
  requested_ = requested;
  if (requested) {
    set_has_requested();
  } else {
    clear_has_requested();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.LeaseRejectedError.Requested)
}

// optional .cockroach.proto.Lease Existing = 2;
bool LeaseRejectedError::has_existing() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void LeaseRejectedError::set_has_existing() {
  _has_bits_[0] |= 0x00000002u;
}
void LeaseRejectedError::clear_has_existing() {
  _has_bits_[0] &= ~0x00000002u;
}
void LeaseRejectedError::clear_existing() {
  if (existing_ != NULL) existing_->::cockroach::proto::Lease::Clear();
  clear_has_existing();
}
 const ::cockroach::proto::Lease& LeaseRejectedError::existing() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.LeaseRejectedError.Existing)
  return existing_ != NULL ? *existing_ : *default_instance_->existing_;
}
 ::cockroach::proto::Lease* LeaseRejectedError::mutable_existing() {
  set_has_existing();
  if (existing_ == NULL) {
    existing_ = new ::cockroach::proto::Lease;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.proto.LeaseRejectedError.Existing)
  return existing_;
}
 ::cockroach::proto::Lease* LeaseRejectedError::release_existing() {
  clear_has_existing();
  ::cockroach::proto::Lease* temp = existing_;
  existing_ = NULL;
  return temp;
}
 void LeaseRejectedError::set_allocated_existing(::cockroach::proto::Lease* existing) {
  delete existing_;
  existing_ = existing;
  if (existing) {
    set_has_existing();
  } else {
    clear_has_existing();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.LeaseRejectedError.Existing)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#ifndef _MSC_VER
const int ErrorDetail::kNotLeaderFieldNumber;
const int ErrorDetail::kRangeNotFoundFieldNumber;
const int ErrorDetail::kRangeKeyMismatchFieldNumber;
const int ErrorDetail::kReadWithinUncertaintyIntervalFieldNumber;
const int ErrorDetail::kTransactionAbortedFieldNumber;
const int ErrorDetail::kTransactionPushFieldNumber;
const int ErrorDetail::kTransactionRetryFieldNumber;
const int ErrorDetail::kTransactionStatusFieldNumber;
const int ErrorDetail::kWriteIntentFieldNumber;
const int ErrorDetail::kWriteTooOldFieldNumber;
const int ErrorDetail::kOpRequiresTxnFieldNumber;
const int ErrorDetail::kConditionFailedFieldNumber;
const int ErrorDetail::kLeaseRejectedFieldNumber;
const int ErrorDetail::kNodeUnavailableFieldNumber;
#endif  // !_MSC_VER

ErrorDetail::ErrorDetail()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:cockroach.proto.ErrorDetail)
}

void ErrorDetail::InitAsDefaultInstance() {
  not_leader_ = const_cast< ::cockroach::proto::NotLeaderError*>(&::cockroach::proto::NotLeaderError::default_instance());
  range_not_found_ = const_cast< ::cockroach::proto::RangeNotFoundError*>(&::cockroach::proto::RangeNotFoundError::default_instance());
  range_key_mismatch_ = const_cast< ::cockroach::proto::RangeKeyMismatchError*>(&::cockroach::proto::RangeKeyMismatchError::default_instance());
  read_within_uncertainty_interval_ = const_cast< ::cockroach::proto::ReadWithinUncertaintyIntervalError*>(&::cockroach::proto::ReadWithinUncertaintyIntervalError::default_instance());
  transaction_aborted_ = const_cast< ::cockroach::proto::TransactionAbortedError*>(&::cockroach::proto::TransactionAbortedError::default_instance());
  transaction_push_ = const_cast< ::cockroach::proto::TransactionPushError*>(&::cockroach::proto::TransactionPushError::default_instance());
  transaction_retry_ = const_cast< ::cockroach::proto::TransactionRetryError*>(&::cockroach::proto::TransactionRetryError::default_instance());
  transaction_status_ = const_cast< ::cockroach::proto::TransactionStatusError*>(&::cockroach::proto::TransactionStatusError::default_instance());
  write_intent_ = const_cast< ::cockroach::proto::WriteIntentError*>(&::cockroach::proto::WriteIntentError::default_instance());
  write_too_old_ = const_cast< ::cockroach::proto::WriteTooOldError*>(&::cockroach::proto::WriteTooOldError::default_instance());
  op_requires_txn_ = const_cast< ::cockroach::proto::OpRequiresTxnError*>(&::cockroach::proto::OpRequiresTxnError::default_instance());
  condition_failed_ = const_cast< ::cockroach::proto::ConditionFailedError*>(&::cockroach::proto::ConditionFailedError::default_instance());
  lease_rejected_ = const_cast< ::cockroach::proto::LeaseRejectedError*>(&::cockroach::proto::LeaseRejectedError::default_instance());
  node_unavailable_ = const_cast< ::cockroach::proto::NodeUnavailableError*>(&::cockroach::proto::NodeUnavailableError::default_instance());
}

ErrorDetail::ErrorDetail(const ErrorDetail& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:cockroach.proto.ErrorDetail)
}

void ErrorDetail::SharedCtor() {
  _cached_size_ = 0;
  not_leader_ = NULL;
  range_not_found_ = NULL;
  range_key_mismatch_ = NULL;
  read_within_uncertainty_interval_ = NULL;
  transaction_aborted_ = NULL;
  transaction_push_ = NULL;
  transaction_retry_ = NULL;
  transaction_status_ = NULL;
  write_intent_ = NULL;
  write_too_old_ = NULL;
  op_requires_txn_ = NULL;
  condition_failed_ = NULL;
  lease_rejected_ = NULL;
  node_unavailable_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ErrorDetail::~ErrorDetail() {
  // @@protoc_insertion_point(destructor:cockroach.proto.ErrorDetail)
  SharedDtor();
}

void ErrorDetail::SharedDtor() {
  if (this != default_instance_) {
    delete not_leader_;
    delete range_not_found_;
    delete range_key_mismatch_;
    delete read_within_uncertainty_interval_;
    delete transaction_aborted_;
    delete transaction_push_;
    delete transaction_retry_;
    delete transaction_status_;
    delete write_intent_;
    delete write_too_old_;
    delete op_requires_txn_;
    delete condition_failed_;
    delete lease_rejected_;
    delete node_unavailable_;
  }
}

void ErrorDetail::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ErrorDetail::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ErrorDetail_descriptor_;
}

const ErrorDetail& ErrorDetail::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_cockroach_2fproto_2ferrors_2eproto();
  return *default_instance_;
}

ErrorDetail* ErrorDetail::default_instance_ = NULL;

ErrorDetail* ErrorDetail::New(::google::protobuf::Arena* arena) const {
  ErrorDetail* n = new ErrorDetail;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void ErrorDetail::Clear() {
  if (_has_bits_[0 / 32] & 255u) {
    if (has_not_leader()) {
      if (not_leader_ != NULL) not_leader_->::cockroach::proto::NotLeaderError::Clear();
    }
    if (has_range_not_found()) {
      if (range_not_found_ != NULL) range_not_found_->::cockroach::proto::RangeNotFoundError::Clear();
    }
    if (has_range_key_mismatch()) {
      if (range_key_mismatch_ != NULL) range_key_mismatch_->::cockroach::proto::RangeKeyMismatchError::Clear();
    }
    if (has_read_within_uncertainty_interval()) {
      if (read_within_uncertainty_interval_ != NULL) read_within_uncertainty_interval_->::cockroach::proto::ReadWithinUncertaintyIntervalError::Clear();
    }
    if (has_transaction_aborted()) {
      if (transaction_aborted_ != NULL) transaction_aborted_->::cockroach::proto::TransactionAbortedError::Clear();
    }
    if (has_transaction_push()) {
      if (transaction_push_ != NULL) transaction_push_->::cockroach::proto::TransactionPushError::Clear();
    }
    if (has_transaction_retry()) {
      if (transaction_retry_ != NULL) transaction_retry_->::cockroach::proto::TransactionRetryError::Clear();
    }
    if (has_transaction_status()) {
      if (transaction_status_ != NULL) transaction_status_->::cockroach::proto::TransactionStatusError::Clear();
    }
  }
  if (_has_bits_[8 / 32] & 16128u) {
    if (has_write_intent()) {
      if (write_intent_ != NULL) write_intent_->::cockroach::proto::WriteIntentError::Clear();
    }
    if (has_write_too_old()) {
      if (write_too_old_ != NULL) write_too_old_->::cockroach::proto::WriteTooOldError::Clear();
    }
    if (has_op_requires_txn()) {
      if (op_requires_txn_ != NULL) op_requires_txn_->::cockroach::proto::OpRequiresTxnError::Clear();
    }
    if (has_condition_failed()) {
      if (condition_failed_ != NULL) condition_failed_->::cockroach::proto::ConditionFailedError::Clear();
    }
    if (has_lease_rejected()) {
      if (lease_rejected_ != NULL) lease_rejected_->::cockroach::proto::LeaseRejectedError::Clear();
    }
    if (has_node_unavailable()) {
      if (node_unavailable_ != NULL) node_unavailable_->::cockroach::proto::NodeUnavailableError::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool ErrorDetail::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:cockroach.proto.ErrorDetail)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .cockroach.proto.NotLeaderError not_leader = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_not_leader()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_range_not_found;
        break;
      }

      // optional .cockroach.proto.RangeNotFoundError range_not_found = 2;
      case 2: {
        if (tag == 18) {
         parse_range_not_found:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_range_not_found()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_range_key_mismatch;
        break;
      }

      // optional .cockroach.proto.RangeKeyMismatchError range_key_mismatch = 3;
      case 3: {
        if (tag == 26) {
         parse_range_key_mismatch:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_range_key_mismatch()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_read_within_uncertainty_interval;
        break;
      }

      // optional .cockroach.proto.ReadWithinUncertaintyIntervalError read_within_uncertainty_interval = 4;
      case 4: {
        if (tag == 34) {
         parse_read_within_uncertainty_interval:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_read_within_uncertainty_interval()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_transaction_aborted;
        break;
      }

      // optional .cockroach.proto.TransactionAbortedError transaction_aborted = 5;
      case 5: {
        if (tag == 42) {
         parse_transaction_aborted:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_transaction_aborted()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(50)) goto parse_transaction_push;
        break;
      }

      // optional .cockroach.proto.TransactionPushError transaction_push = 6;
      case 6: {
        if (tag == 50) {
         parse_transaction_push:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_transaction_push()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(58)) goto parse_transaction_retry;
        break;
      }

      // optional .cockroach.proto.TransactionRetryError transaction_retry = 7;
      case 7: {
        if (tag == 58) {
         parse_transaction_retry:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_transaction_retry()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(66)) goto parse_transaction_status;
        break;
      }

      // optional .cockroach.proto.TransactionStatusError transaction_status = 8;
      case 8: {
        if (tag == 66) {
         parse_transaction_status:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_transaction_status()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(74)) goto parse_write_intent;
        break;
      }

      // optional .cockroach.proto.WriteIntentError write_intent = 9;
      case 9: {
        if (tag == 74) {
         parse_write_intent:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_write_intent()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(82)) goto parse_write_too_old;
        break;
      }

      // optional .cockroach.proto.WriteTooOldError write_too_old = 10;
      case 10: {
        if (tag == 82) {
         parse_write_too_old:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_write_too_old()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(90)) goto parse_op_requires_txn;
        break;
      }

      // optional .cockroach.proto.OpRequiresTxnError op_requires_txn = 11;
      case 11: {
        if (tag == 90) {
         parse_op_requires_txn:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_op_requires_txn()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(98)) goto parse_condition_failed;
        break;
      }

      // optional .cockroach.proto.ConditionFailedError condition_failed = 12;
      case 12: {
        if (tag == 98) {
         parse_condition_failed:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_condition_failed()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(106)) goto parse_lease_rejected;
        break;
      }

      // optional .cockroach.proto.LeaseRejectedError lease_rejected = 13;
      case 13: {
        if (tag == 106) {
         parse_lease_rejected:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_lease_rejected()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(114)) goto parse_node_unavailable;
        break;
      }

      // optional .cockroach.proto.NodeUnavailableError node_unavailable = 14;
      case 14: {
        if (tag == 114) {
         parse_node_unavailable:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_node_unavailable()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:cockroach.proto.ErrorDetail)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:cockroach.proto.ErrorDetail)
  return false;
#undef DO_
}

void ErrorDetail::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:cockroach.proto.ErrorDetail)
  // optional .cockroach.proto.NotLeaderError not_leader = 1;
  if (has_not_leader()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->not_leader_, output);
  }

  // optional .cockroach.proto.RangeNotFoundError range_not_found = 2;
  if (has_range_not_found()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, *this->range_not_found_, output);
  }

  // optional .cockroach.proto.RangeKeyMismatchError range_key_mismatch = 3;
  if (has_range_key_mismatch()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, *this->range_key_mismatch_, output);
  }

  // optional .cockroach.proto.ReadWithinUncertaintyIntervalError read_within_uncertainty_interval = 4;
  if (has_read_within_uncertainty_interval()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, *this->read_within_uncertainty_interval_, output);
  }

  // optional .cockroach.proto.TransactionAbortedError transaction_aborted = 5;
  if (has_transaction_aborted()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      5, *this->transaction_aborted_, output);
  }

  // optional .cockroach.proto.TransactionPushError transaction_push = 6;
  if (has_transaction_push()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      6, *this->transaction_push_, output);
  }

  // optional .cockroach.proto.TransactionRetryError transaction_retry = 7;
  if (has_transaction_retry()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      7, *this->transaction_retry_, output);
  }

  // optional .cockroach.proto.TransactionStatusError transaction_status = 8;
  if (has_transaction_status()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      8, *this->transaction_status_, output);
  }

  // optional .cockroach.proto.WriteIntentError write_intent = 9;
  if (has_write_intent()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      9, *this->write_intent_, output);
  }

  // optional .cockroach.proto.WriteTooOldError write_too_old = 10;
  if (has_write_too_old()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      10, *this->write_too_old_, output);
  }

  // optional .cockroach.proto.OpRequiresTxnError op_requires_txn = 11;
  if (has_op_requires_txn()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      11, *this->op_requires_txn_, output);
  }

  // optional .cockroach.proto.ConditionFailedError condition_failed = 12;
  if (has_condition_failed()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      12, *this->condition_failed_, output);
  }

  // optional .cockroach.proto.LeaseRejectedError lease_rejected = 13;
  if (has_lease_rejected()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      13, *this->lease_rejected_, output);
  }

  // optional .cockroach.proto.NodeUnavailableError node_unavailable = 14;
  if (has_node_unavailable()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      14, *this->node_unavailable_, output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:cockroach.proto.ErrorDetail)
}

::google::protobuf::uint8* ErrorDetail::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:cockroach.proto.ErrorDetail)
  // optional .cockroach.proto.NotLeaderError not_leader = 1;
  if (has_not_leader()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, *this->not_leader_, target);
  }

  // optional .cockroach.proto.RangeNotFoundError range_not_found = 2;
  if (has_range_not_found()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, *this->range_not_found_, target);
  }

  // optional .cockroach.proto.RangeKeyMismatchError range_key_mismatch = 3;
  if (has_range_key_mismatch()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, *this->range_key_mismatch_, target);
  }

  // optional .cockroach.proto.ReadWithinUncertaintyIntervalError read_within_uncertainty_interval = 4;
  if (has_read_within_uncertainty_interval()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        4, *this->read_within_uncertainty_interval_, target);
  }

  // optional .cockroach.proto.TransactionAbortedError transaction_aborted = 5;
  if (has_transaction_aborted()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        5, *this->transaction_aborted_, target);
  }

  // optional .cockroach.proto.TransactionPushError transaction_push = 6;
  if (has_transaction_push()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        6, *this->transaction_push_, target);
  }

  // optional .cockroach.proto.TransactionRetryError transaction_retry = 7;
  if (has_transaction_retry()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        7, *this->transaction_retry_, target);
  }

  // optional .cockroach.proto.TransactionStatusError transaction_status = 8;
  if (has_transaction_status()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        8, *this->transaction_status_, target);
  }

  // optional .cockroach.proto.WriteIntentError write_intent = 9;
  if (has_write_intent()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        9, *this->write_intent_, target);
  }

  // optional .cockroach.proto.WriteTooOldError write_too_old = 10;
  if (has_write_too_old()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        10, *this->write_too_old_, target);
  }

  // optional .cockroach.proto.OpRequiresTxnError op_requires_txn = 11;
  if (has_op_requires_txn()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        11, *this->op_requires_txn_, target);
  }

  // optional .cockroach.proto.ConditionFailedError condition_failed = 12;
  if (has_condition_failed()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        12, *this->condition_failed_, target);
  }

  // optional .cockroach.proto.LeaseRejectedError lease_rejected = 13;
  if (has_lease_rejected()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        13, *this->lease_rejected_, target);
  }

  // optional .cockroach.proto.NodeUnavailableError node_unavailable = 14;
  if (has_node_unavailable()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        14, *this->node_unavailable_, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:cockroach.proto.ErrorDetail)
  return target;
}

int ErrorDetail::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & 255) {
    // optional .cockroach.proto.NotLeaderError not_leader = 1;
    if (has_not_leader()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->not_leader_);
    }

    // optional .cockroach.proto.RangeNotFoundError range_not_found = 2;
    if (has_range_not_found()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->range_not_found_);
    }

    // optional .cockroach.proto.RangeKeyMismatchError range_key_mismatch = 3;
    if (has_range_key_mismatch()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->range_key_mismatch_);
    }

    // optional .cockroach.proto.ReadWithinUncertaintyIntervalError read_within_uncertainty_interval = 4;
    if (has_read_within_uncertainty_interval()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->read_within_uncertainty_interval_);
    }

    // optional .cockroach.proto.TransactionAbortedError transaction_aborted = 5;
    if (has_transaction_aborted()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->transaction_aborted_);
    }

    // optional .cockroach.proto.TransactionPushError transaction_push = 6;
    if (has_transaction_push()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->transaction_push_);
    }

    // optional .cockroach.proto.TransactionRetryError transaction_retry = 7;
    if (has_transaction_retry()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->transaction_retry_);
    }

    // optional .cockroach.proto.TransactionStatusError transaction_status = 8;
    if (has_transaction_status()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->transaction_status_);
    }

  }
  if (_has_bits_[8 / 32] & 16128) {
    // optional .cockroach.proto.WriteIntentError write_intent = 9;
    if (has_write_intent()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->write_intent_);
    }

    // optional .cockroach.proto.WriteTooOldError write_too_old = 10;
    if (has_write_too_old()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->write_too_old_);
    }

    // optional .cockroach.proto.OpRequiresTxnError op_requires_txn = 11;
    if (has_op_requires_txn()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->op_requires_txn_);
    }

    // optional .cockroach.proto.ConditionFailedError condition_failed = 12;
    if (has_condition_failed()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->condition_failed_);
    }

    // optional .cockroach.proto.LeaseRejectedError lease_rejected = 13;
    if (has_lease_rejected()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->lease_rejected_);
    }

    // optional .cockroach.proto.NodeUnavailableError node_unavailable = 14;
    if (has_node_unavailable()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->node_unavailable_);
    }

  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ErrorDetail::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const ErrorDetail* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const ErrorDetail>(
          &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ErrorDetail::MergeFrom(const ErrorDetail& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_not_leader()) {
      mutable_not_leader()->::cockroach::proto::NotLeaderError::MergeFrom(from.not_leader());
    }
    if (from.has_range_not_found()) {
      mutable_range_not_found()->::cockroach::proto::RangeNotFoundError::MergeFrom(from.range_not_found());
    }
    if (from.has_range_key_mismatch()) {
      mutable_range_key_mismatch()->::cockroach::proto::RangeKeyMismatchError::MergeFrom(from.range_key_mismatch());
    }
    if (from.has_read_within_uncertainty_interval()) {
      mutable_read_within_uncertainty_interval()->::cockroach::proto::ReadWithinUncertaintyIntervalError::MergeFrom(from.read_within_uncertainty_interval());
    }
    if (from.has_transaction_aborted()) {
      mutable_transaction_aborted()->::cockroach::proto::TransactionAbortedError::MergeFrom(from.transaction_aborted());
    }
    if (from.has_transaction_push()) {
      mutable_transaction_push()->::cockroach::proto::TransactionPushError::MergeFrom(from.transaction_push());
    }
    if (from.has_transaction_retry()) {
      mutable_transaction_retry()->::cockroach::proto::TransactionRetryError::MergeFrom(from.transaction_retry());
    }
    if (from.has_transaction_status()) {
      mutable_transaction_status()->::cockroach::proto::TransactionStatusError::MergeFrom(from.transaction_status());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_write_intent()) {
      mutable_write_intent()->::cockroach::proto::WriteIntentError::MergeFrom(from.write_intent());
    }
    if (from.has_write_too_old()) {
      mutable_write_too_old()->::cockroach::proto::WriteTooOldError::MergeFrom(from.write_too_old());
    }
    if (from.has_op_requires_txn()) {
      mutable_op_requires_txn()->::cockroach::proto::OpRequiresTxnError::MergeFrom(from.op_requires_txn());
    }
    if (from.has_condition_failed()) {
      mutable_condition_failed()->::cockroach::proto::ConditionFailedError::MergeFrom(from.condition_failed());
    }
    if (from.has_lease_rejected()) {
      mutable_lease_rejected()->::cockroach::proto::LeaseRejectedError::MergeFrom(from.lease_rejected());
    }
    if (from.has_node_unavailable()) {
      mutable_node_unavailable()->::cockroach::proto::NodeUnavailableError::MergeFrom(from.node_unavailable());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void ErrorDetail::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ErrorDetail::CopyFrom(const ErrorDetail& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ErrorDetail::IsInitialized() const {

  return true;
}

void ErrorDetail::Swap(ErrorDetail* other) {
  if (other == this) return;
  InternalSwap(other);
}
void ErrorDetail::InternalSwap(ErrorDetail* other) {
  std::swap(not_leader_, other->not_leader_);
  std::swap(range_not_found_, other->range_not_found_);
  std::swap(range_key_mismatch_, other->range_key_mismatch_);
  std::swap(read_within_uncertainty_interval_, other->read_within_uncertainty_interval_);
  std::swap(transaction_aborted_, other->transaction_aborted_);
  std::swap(transaction_push_, other->transaction_push_);
  std::swap(transaction_retry_, other->transaction_retry_);
  std::swap(transaction_status_, other->transaction_status_);
  std::swap(write_intent_, other->write_intent_);
  std::swap(write_too_old_, other->write_too_old_);
  std::swap(op_requires_txn_, other->op_requires_txn_);
  std::swap(condition_failed_, other->condition_failed_);
  std::swap(lease_rejected_, other->lease_rejected_);
  std::swap(node_unavailable_, other->node_unavailable_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata ErrorDetail::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ErrorDetail_descriptor_;
  metadata.reflection = ErrorDetail_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// ErrorDetail

// optional .cockroach.proto.NotLeaderError not_leader = 1;
bool ErrorDetail::has_not_leader() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void ErrorDetail::set_has_not_leader() {
  _has_bits_[0] |= 0x00000001u;
}
void ErrorDetail::clear_has_not_leader() {
  _has_bits_[0] &= ~0x00000001u;
}
void ErrorDetail::clear_not_leader() {
  if (not_leader_ != NULL) not_leader_->::cockroach::proto::NotLeaderError::Clear();
  clear_has_not_leader();
}
 const ::cockroach::proto::NotLeaderError& ErrorDetail::not_leader() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.ErrorDetail.not_leader)
  return not_leader_ != NULL ? *not_leader_ : *default_instance_->not_leader_;
}
 ::cockroach::proto::NotLeaderError* ErrorDetail::mutable_not_leader() {
  set_has_not_leader();
  if (not_leader_ == NULL) {
    not_leader_ = new ::cockroach::proto::NotLeaderError;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.proto.ErrorDetail.not_leader)
  return not_leader_;
}
 ::cockroach::proto::NotLeaderError* ErrorDetail::release_not_leader() {
  clear_has_not_leader();
  ::cockroach::proto::NotLeaderError* temp = not_leader_;
  not_leader_ = NULL;
  return temp;
}
 void ErrorDetail::set_allocated_not_leader(::cockroach::proto::NotLeaderError* not_leader) {
  delete not_leader_;
  not_leader_ = not_leader;
  if (not_leader) {
    set_has_not_leader();
  } else {
    clear_has_not_leader();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.ErrorDetail.not_leader)
}

// optional .cockroach.proto.RangeNotFoundError range_not_found = 2;
bool ErrorDetail::has_range_not_found() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void ErrorDetail::set_has_range_not_found() {
  _has_bits_[0] |= 0x00000002u;
}
void ErrorDetail::clear_has_range_not_found() {
  _has_bits_[0] &= ~0x00000002u;
}
void ErrorDetail::clear_range_not_found() {
  if (range_not_found_ != NULL) range_not_found_->::cockroach::proto::RangeNotFoundError::Clear();
  clear_has_range_not_found();
}
 const ::cockroach::proto::RangeNotFoundError& ErrorDetail::range_not_found() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.ErrorDetail.range_not_found)
  return range_not_found_ != NULL ? *range_not_found_ : *default_instance_->range_not_found_;
}
 ::cockroach::proto::RangeNotFoundError* ErrorDetail::mutable_range_not_found() {
  set_has_range_not_found();
  if (range_not_found_ == NULL) {
    range_not_found_ = new ::cockroach::proto::RangeNotFoundError;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.proto.ErrorDetail.range_not_found)
  return range_not_found_;
}
 ::cockroach::proto::RangeNotFoundError* ErrorDetail::release_range_not_found() {
  clear_has_range_not_found();
  ::cockroach::proto::RangeNotFoundError* temp = range_not_found_;
  range_not_found_ = NULL;
  return temp;
}
 void ErrorDetail::set_allocated_range_not_found(::cockroach::proto::RangeNotFoundError* range_not_found) {
  delete range_not_found_;
  range_not_found_ = range_not_found;
  if (range_not_found) {
    set_has_range_not_found();
  } else {
    clear_has_range_not_found();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.ErrorDetail.range_not_found)
}

// optional .cockroach.proto.RangeKeyMismatchError range_key_mismatch = 3;
bool ErrorDetail::has_range_key_mismatch() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void ErrorDetail::set_has_range_key_mismatch() {
  _has_bits_[0] |= 0x00000004u;
}
void ErrorDetail::clear_has_range_key_mismatch() {
  _has_bits_[0] &= ~0x00000004u;
}
void ErrorDetail::clear_range_key_mismatch() {
  if (range_key_mismatch_ != NULL) range_key_mismatch_->::cockroach::proto::RangeKeyMismatchError::Clear();
  clear_has_range_key_mismatch();
}
 const ::cockroach::proto::RangeKeyMismatchError& ErrorDetail::range_key_mismatch() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.ErrorDetail.range_key_mismatch)
  return range_key_mismatch_ != NULL ? *range_key_mismatch_ : *default_instance_->range_key_mismatch_;
}
 ::cockroach::proto::RangeKeyMismatchError* ErrorDetail::mutable_range_key_mismatch() {
  set_has_range_key_mismatch();
  if (range_key_mismatch_ == NULL) {
    range_key_mismatch_ = new ::cockroach::proto::RangeKeyMismatchError;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.proto.ErrorDetail.range_key_mismatch)
  return range_key_mismatch_;
}
 ::cockroach::proto::RangeKeyMismatchError* ErrorDetail::release_range_key_mismatch() {
  clear_has_range_key_mismatch();
  ::cockroach::proto::RangeKeyMismatchError* temp = range_key_mismatch_;
  range_key_mismatch_ = NULL;
  return temp;
}
 void ErrorDetail::set_allocated_range_key_mismatch(::cockroach::proto::RangeKeyMismatchError* range_key_mismatch) {
  delete range_key_mismatch_;
  range_key_mismatch_ = range_key_mismatch;
  if (range_key_mismatch) {
    set_has_range_key_mismatch();
  } else {
    clear_has_range_key_mismatch();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.ErrorDetail.range_key_mismatch)
}

// optional .cockroach.proto.ReadWithinUncertaintyIntervalError read_within_uncertainty_interval = 4;
bool ErrorDetail::has_read_within_uncertainty_interval() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void ErrorDetail::set_has_read_within_uncertainty_interval() {
  _has_bits_[0] |= 0x00000008u;
}
void ErrorDetail::clear_has_read_within_uncertainty_interval() {
  _has_bits_[0] &= ~0x00000008u;
}
void ErrorDetail::clear_read_within_uncertainty_interval() {
  if (read_within_uncertainty_interval_ != NULL) read_within_uncertainty_interval_->::cockroach::proto::ReadWithinUncertaintyIntervalError::Clear();
  clear_has_read_within_uncertainty_interval();
}
 const ::cockroach::proto::ReadWithinUncertaintyIntervalError& ErrorDetail::read_within_uncertainty_interval() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.ErrorDetail.read_within_uncertainty_interval)
  return read_within_uncertainty_interval_ != NULL ? *read_within_uncertainty_interval_ : *default_instance_->read_within_uncertainty_interval_;
}
 ::cockroach::proto::ReadWithinUncertaintyIntervalError* ErrorDetail::mutable_read_within_uncertainty_interval() {
  set_has_read_within_uncertainty_interval();
  if (read_within_uncertainty_interval_ == NULL) {
    read_within_uncertainty_interval_ = new ::cockroach::proto::ReadWithinUncertaintyIntervalError;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.proto.ErrorDetail.read_within_uncertainty_interval)
  return read_within_uncertainty_interval_;
}
 ::cockroach::proto::ReadWithinUncertaintyIntervalError* ErrorDetail::release_read_within_uncertainty_interval() {
  clear_has_read_within_uncertainty_interval();
  ::cockroach::proto::ReadWithinUncertaintyIntervalError* temp = read_within_uncertainty_interval_;
  read_within_uncertainty_interval_ = NULL;
  return temp;
}
 void ErrorDetail::set_allocated_read_within_uncertainty_interval(::cockroach::proto::ReadWithinUncertaintyIntervalError* read_within_uncertainty_interval) {
  delete read_within_uncertainty_interval_;
  read_within_uncertainty_interval_ = read_within_uncertainty_interval;
  if (read_within_uncertainty_interval) {
    set_has_read_within_uncertainty_interval();
  } else {
    clear_has_read_within_uncertainty_interval();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.ErrorDetail.read_within_uncertainty_interval)
}

// optional .cockroach.proto.TransactionAbortedError transaction_aborted = 5;
bool ErrorDetail::has_transaction_aborted() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
void ErrorDetail::set_has_transaction_aborted() {
  _has_bits_[0] |= 0x00000010u;
}
void ErrorDetail::clear_has_transaction_aborted() {
  _has_bits_[0] &= ~0x00000010u;
}
void ErrorDetail::clear_transaction_aborted() {
  if (transaction_aborted_ != NULL) transaction_aborted_->::cockroach::proto::TransactionAbortedError::Clear();
  clear_has_transaction_aborted();
}
 const ::cockroach::proto::TransactionAbortedError& ErrorDetail::transaction_aborted() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.ErrorDetail.transaction_aborted)
  return transaction_aborted_ != NULL ? *transaction_aborted_ : *default_instance_->transaction_aborted_;
}
 ::cockroach::proto::TransactionAbortedError* ErrorDetail::mutable_transaction_aborted() {
  set_has_transaction_aborted();
  if (transaction_aborted_ == NULL) {
    transaction_aborted_ = new ::cockroach::proto::TransactionAbortedError;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.proto.ErrorDetail.transaction_aborted)
  return transaction_aborted_;
}
 ::cockroach::proto::TransactionAbortedError* ErrorDetail::release_transaction_aborted() {
  clear_has_transaction_aborted();
  ::cockroach::proto::TransactionAbortedError* temp = transaction_aborted_;
  transaction_aborted_ = NULL;
  return temp;
}
 void ErrorDetail::set_allocated_transaction_aborted(::cockroach::proto::TransactionAbortedError* transaction_aborted) {
  delete transaction_aborted_;
  transaction_aborted_ = transaction_aborted;
  if (transaction_aborted) {
    set_has_transaction_aborted();
  } else {
    clear_has_transaction_aborted();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.ErrorDetail.transaction_aborted)
}

// optional .cockroach.proto.TransactionPushError transaction_push = 6;
bool ErrorDetail::has_transaction_push() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
void ErrorDetail::set_has_transaction_push() {
  _has_bits_[0] |= 0x00000020u;
}
void ErrorDetail::clear_has_transaction_push() {
  _has_bits_[0] &= ~0x00000020u;
}
void ErrorDetail::clear_transaction_push() {
  if (transaction_push_ != NULL) transaction_push_->::cockroach::proto::TransactionPushError::Clear();
  clear_has_transaction_push();
}
 const ::cockroach::proto::TransactionPushError& ErrorDetail::transaction_push() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.ErrorDetail.transaction_push)
  return transaction_push_ != NULL ? *transaction_push_ : *default_instance_->transaction_push_;
}
 ::cockroach::proto::TransactionPushError* ErrorDetail::mutable_transaction_push() {
  set_has_transaction_push();
  if (transaction_push_ == NULL) {
    transaction_push_ = new ::cockroach::proto::TransactionPushError;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.proto.ErrorDetail.transaction_push)
  return transaction_push_;
}
 ::cockroach::proto::TransactionPushError* ErrorDetail::release_transaction_push() {
  clear_has_transaction_push();
  ::cockroach::proto::TransactionPushError* temp = transaction_push_;
  transaction_push_ = NULL;
  return temp;
}
 void ErrorDetail::set_allocated_transaction_push(::cockroach::proto::TransactionPushError* transaction_push) {
  delete transaction_push_;
  transaction_push_ = transaction_push;
  if (transaction_push) {
    set_has_transaction_push();
  } else {
    clear_has_transaction_push();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.ErrorDetail.transaction_push)
}

// optional .cockroach.proto.TransactionRetryError transaction_retry = 7;
bool ErrorDetail::has_transaction_retry() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
void ErrorDetail::set_has_transaction_retry() {
  _has_bits_[0] |= 0x00000040u;
}
void ErrorDetail::clear_has_transaction_retry() {
  _has_bits_[0] &= ~0x00000040u;
}
void ErrorDetail::clear_transaction_retry() {
  if (transaction_retry_ != NULL) transaction_retry_->::cockroach::proto::TransactionRetryError::Clear();
  clear_has_transaction_retry();
}
 const ::cockroach::proto::TransactionRetryError& ErrorDetail::transaction_retry() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.ErrorDetail.transaction_retry)
  return transaction_retry_ != NULL ? *transaction_retry_ : *default_instance_->transaction_retry_;
}
 ::cockroach::proto::TransactionRetryError* ErrorDetail::mutable_transaction_retry() {
  set_has_transaction_retry();
  if (transaction_retry_ == NULL) {
    transaction_retry_ = new ::cockroach::proto::TransactionRetryError;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.proto.ErrorDetail.transaction_retry)
  return transaction_retry_;
}
 ::cockroach::proto::TransactionRetryError* ErrorDetail::release_transaction_retry() {
  clear_has_transaction_retry();
  ::cockroach::proto::TransactionRetryError* temp = transaction_retry_;
  transaction_retry_ = NULL;
  return temp;
}
 void ErrorDetail::set_allocated_transaction_retry(::cockroach::proto::TransactionRetryError* transaction_retry) {
  delete transaction_retry_;
  transaction_retry_ = transaction_retry;
  if (transaction_retry) {
    set_has_transaction_retry();
  } else {
    clear_has_transaction_retry();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.ErrorDetail.transaction_retry)
}

// optional .cockroach.proto.TransactionStatusError transaction_status = 8;
bool ErrorDetail::has_transaction_status() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
void ErrorDetail::set_has_transaction_status() {
  _has_bits_[0] |= 0x00000080u;
}
void ErrorDetail::clear_has_transaction_status() {
  _has_bits_[0] &= ~0x00000080u;
}
void ErrorDetail::clear_transaction_status() {
  if (transaction_status_ != NULL) transaction_status_->::cockroach::proto::TransactionStatusError::Clear();
  clear_has_transaction_status();
}
 const ::cockroach::proto::TransactionStatusError& ErrorDetail::transaction_status() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.ErrorDetail.transaction_status)
  return transaction_status_ != NULL ? *transaction_status_ : *default_instance_->transaction_status_;
}
 ::cockroach::proto::TransactionStatusError* ErrorDetail::mutable_transaction_status() {
  set_has_transaction_status();
  if (transaction_status_ == NULL) {
    transaction_status_ = new ::cockroach::proto::TransactionStatusError;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.proto.ErrorDetail.transaction_status)
  return transaction_status_;
}
 ::cockroach::proto::TransactionStatusError* ErrorDetail::release_transaction_status() {
  clear_has_transaction_status();
  ::cockroach::proto::TransactionStatusError* temp = transaction_status_;
  transaction_status_ = NULL;
  return temp;
}
 void ErrorDetail::set_allocated_transaction_status(::cockroach::proto::TransactionStatusError* transaction_status) {
  delete transaction_status_;
  transaction_status_ = transaction_status;
  if (transaction_status) {
    set_has_transaction_status();
  } else {
    clear_has_transaction_status();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.ErrorDetail.transaction_status)
}

// optional .cockroach.proto.WriteIntentError write_intent = 9;
bool ErrorDetail::has_write_intent() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
void ErrorDetail::set_has_write_intent() {
  _has_bits_[0] |= 0x00000100u;
}
void ErrorDetail::clear_has_write_intent() {
  _has_bits_[0] &= ~0x00000100u;
}
void ErrorDetail::clear_write_intent() {
  if (write_intent_ != NULL) write_intent_->::cockroach::proto::WriteIntentError::Clear();
  clear_has_write_intent();
}
 const ::cockroach::proto::WriteIntentError& ErrorDetail::write_intent() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.ErrorDetail.write_intent)
  return write_intent_ != NULL ? *write_intent_ : *default_instance_->write_intent_;
}
 ::cockroach::proto::WriteIntentError* ErrorDetail::mutable_write_intent() {
  set_has_write_intent();
  if (write_intent_ == NULL) {
    write_intent_ = new ::cockroach::proto::WriteIntentError;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.proto.ErrorDetail.write_intent)
  return write_intent_;
}
 ::cockroach::proto::WriteIntentError* ErrorDetail::release_write_intent() {
  clear_has_write_intent();
  ::cockroach::proto::WriteIntentError* temp = write_intent_;
  write_intent_ = NULL;
  return temp;
}
 void ErrorDetail::set_allocated_write_intent(::cockroach::proto::WriteIntentError* write_intent) {
  delete write_intent_;
  write_intent_ = write_intent;
  if (write_intent) {
    set_has_write_intent();
  } else {
    clear_has_write_intent();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.ErrorDetail.write_intent)
}

// optional .cockroach.proto.WriteTooOldError write_too_old = 10;
bool ErrorDetail::has_write_too_old() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
void ErrorDetail::set_has_write_too_old() {
  _has_bits_[0] |= 0x00000200u;
}
void ErrorDetail::clear_has_write_too_old() {
  _has_bits_[0] &= ~0x00000200u;
}
void ErrorDetail::clear_write_too_old() {
  if (write_too_old_ != NULL) write_too_old_->::cockroach::proto::WriteTooOldError::Clear();
  clear_has_write_too_old();
}
 const ::cockroach::proto::WriteTooOldError& ErrorDetail::write_too_old() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.ErrorDetail.write_too_old)
  return write_too_old_ != NULL ? *write_too_old_ : *default_instance_->write_too_old_;
}
 ::cockroach::proto::WriteTooOldError* ErrorDetail::mutable_write_too_old() {
  set_has_write_too_old();
  if (write_too_old_ == NULL) {
    write_too_old_ = new ::cockroach::proto::WriteTooOldError;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.proto.ErrorDetail.write_too_old)
  return write_too_old_;
}
 ::cockroach::proto::WriteTooOldError* ErrorDetail::release_write_too_old() {
  clear_has_write_too_old();
  ::cockroach::proto::WriteTooOldError* temp = write_too_old_;
  write_too_old_ = NULL;
  return temp;
}
 void ErrorDetail::set_allocated_write_too_old(::cockroach::proto::WriteTooOldError* write_too_old) {
  delete write_too_old_;
  write_too_old_ = write_too_old;
  if (write_too_old) {
    set_has_write_too_old();
  } else {
    clear_has_write_too_old();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.ErrorDetail.write_too_old)
}

// optional .cockroach.proto.OpRequiresTxnError op_requires_txn = 11;
bool ErrorDetail::has_op_requires_txn() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
void ErrorDetail::set_has_op_requires_txn() {
  _has_bits_[0] |= 0x00000400u;
}
void ErrorDetail::clear_has_op_requires_txn() {
  _has_bits_[0] &= ~0x00000400u;
}
void ErrorDetail::clear_op_requires_txn() {
  if (op_requires_txn_ != NULL) op_requires_txn_->::cockroach::proto::OpRequiresTxnError::Clear();
  clear_has_op_requires_txn();
}
 const ::cockroach::proto::OpRequiresTxnError& ErrorDetail::op_requires_txn() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.ErrorDetail.op_requires_txn)
  return op_requires_txn_ != NULL ? *op_requires_txn_ : *default_instance_->op_requires_txn_;
}
 ::cockroach::proto::OpRequiresTxnError* ErrorDetail::mutable_op_requires_txn() {
  set_has_op_requires_txn();
  if (op_requires_txn_ == NULL) {
    op_requires_txn_ = new ::cockroach::proto::OpRequiresTxnError;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.proto.ErrorDetail.op_requires_txn)
  return op_requires_txn_;
}
 ::cockroach::proto::OpRequiresTxnError* ErrorDetail::release_op_requires_txn() {
  clear_has_op_requires_txn();
  ::cockroach::proto::OpRequiresTxnError* temp = op_requires_txn_;
  op_requires_txn_ = NULL;
  return temp;
}
 void ErrorDetail::set_allocated_op_requires_txn(::cockroach::proto::OpRequiresTxnError* op_requires_txn) {
  delete op_requires_txn_;
  op_requires_txn_ = op_requires_txn;
  if (op_requires_txn) {
    set_has_op_requires_txn();
  } else {
    clear_has_op_requires_txn();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.ErrorDetail.op_requires_txn)
}

// optional .cockroach.proto.ConditionFailedError condition_failed = 12;
bool ErrorDetail::has_condition_failed() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
void ErrorDetail::set_has_condition_failed() {
  _has_bits_[0] |= 0x00000800u;
}
void ErrorDetail::clear_has_condition_failed() {
  _has_bits_[0] &= ~0x00000800u;
}
void ErrorDetail::clear_condition_failed() {
  if (condition_failed_ != NULL) condition_failed_->::cockroach::proto::ConditionFailedError::Clear();
  clear_has_condition_failed();
}
 const ::cockroach::proto::ConditionFailedError& ErrorDetail::condition_failed() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.ErrorDetail.condition_failed)
  return condition_failed_ != NULL ? *condition_failed_ : *default_instance_->condition_failed_;
}
 ::cockroach::proto::ConditionFailedError* ErrorDetail::mutable_condition_failed() {
  set_has_condition_failed();
  if (condition_failed_ == NULL) {
    condition_failed_ = new ::cockroach::proto::ConditionFailedError;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.proto.ErrorDetail.condition_failed)
  return condition_failed_;
}
 ::cockroach::proto::ConditionFailedError* ErrorDetail::release_condition_failed() {
  clear_has_condition_failed();
  ::cockroach::proto::ConditionFailedError* temp = condition_failed_;
  condition_failed_ = NULL;
  return temp;
}
 void ErrorDetail::set_allocated_condition_failed(::cockroach::proto::ConditionFailedError* condition_failed) {
  delete condition_failed_;
  condition_failed_ = condition_failed;
  if (condition_failed) {
    set_has_condition_failed();
  } else {
    clear_has_condition_failed();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.ErrorDetail.condition_failed)
}

// optional .cockroach.proto.LeaseRejectedError lease_rejected = 13;
bool ErrorDetail::has_lease_rejected() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
void ErrorDetail::set_has_lease_rejected() {
  _has_bits_[0] |= 0x00001000u;
}
void ErrorDetail::clear_has_lease_rejected() {
  _has_bits_[0] &= ~0x00001000u;
}
void ErrorDetail::clear_lease_rejected() {
  if (lease_rejected_ != NULL) lease_rejected_->::cockroach::proto::LeaseRejectedError::Clear();
  clear_has_lease_rejected();
}
 const ::cockroach::proto::LeaseRejectedError& ErrorDetail::lease_rejected() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.ErrorDetail.lease_rejected)
  return lease_rejected_ != NULL ? *lease_rejected_ : *default_instance_->lease_rejected_;
}
 ::cockroach::proto::LeaseRejectedError* ErrorDetail::mutable_lease_rejected() {
  set_has_lease_rejected();
  if (lease_rejected_ == NULL) {
    lease_rejected_ = new ::cockroach::proto::LeaseRejectedError;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.proto.ErrorDetail.lease_rejected)
  return lease_rejected_;
}
 ::cockroach::proto::LeaseRejectedError* ErrorDetail::release_lease_rejected() {
  clear_has_lease_rejected();
  ::cockroach::proto::LeaseRejectedError* temp = lease_rejected_;
  lease_rejected_ = NULL;
  return temp;
}
 void ErrorDetail::set_allocated_lease_rejected(::cockroach::proto::LeaseRejectedError* lease_rejected) {
  delete lease_rejected_;
  lease_rejected_ = lease_rejected;
  if (lease_rejected) {
    set_has_lease_rejected();
  } else {
    clear_has_lease_rejected();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.ErrorDetail.lease_rejected)
}

// optional .cockroach.proto.NodeUnavailableError node_unavailable = 14;
bool ErrorDetail::has_node_unavailable() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
void ErrorDetail::set_has_node_unavailable() {
  _has_bits_[0] |= 0x00002000u;
}
void ErrorDetail::clear_has_node_unavailable() {
  _has_bits_[0] &= ~0x00002000u;
}
void ErrorDetail::clear_node_unavailable() {
  if (node_unavailable_ != NULL) node_unavailable_->::cockroach::proto::NodeUnavailableError::Clear();
  clear_has_node_unavailable();
}
 const ::cockroach::proto::NodeUnavailableError& ErrorDetail::node_unavailable() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.ErrorDetail.node_unavailable)
  return node_unavailable_ != NULL ? *node_unavailable_ : *default_instance_->node_unavailable_;
}
 ::cockroach::proto::NodeUnavailableError* ErrorDetail::mutable_node_unavailable() {
  set_has_node_unavailable();
  if (node_unavailable_ == NULL) {
    node_unavailable_ = new ::cockroach::proto::NodeUnavailableError;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.proto.ErrorDetail.node_unavailable)
  return node_unavailable_;
}
 ::cockroach::proto::NodeUnavailableError* ErrorDetail::release_node_unavailable() {
  clear_has_node_unavailable();
  ::cockroach::proto::NodeUnavailableError* temp = node_unavailable_;
  node_unavailable_ = NULL;
  return temp;
}
 void ErrorDetail::set_allocated_node_unavailable(::cockroach::proto::NodeUnavailableError* node_unavailable) {
  delete node_unavailable_;
  node_unavailable_ = node_unavailable;
  if (node_unavailable) {
    set_has_node_unavailable();
  } else {
    clear_has_node_unavailable();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.ErrorDetail.node_unavailable)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#ifndef _MSC_VER
const int Error::kMessageFieldNumber;
const int Error::kRetryableFieldNumber;
const int Error::kTransactionRestartFieldNumber;
const int Error::kDetailFieldNumber;
#endif  // !_MSC_VER

Error::Error()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:cockroach.proto.Error)
}

void Error::InitAsDefaultInstance() {
  detail_ = const_cast< ::cockroach::proto::ErrorDetail*>(&::cockroach::proto::ErrorDetail::default_instance());
}

Error::Error(const Error& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:cockroach.proto.Error)
}

void Error::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  message_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  retryable_ = false;
  transaction_restart_ = 0;
  detail_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Error::~Error() {
  // @@protoc_insertion_point(destructor:cockroach.proto.Error)
  SharedDtor();
}

void Error::SharedDtor() {
  message_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != default_instance_) {
    delete detail_;
  }
}

void Error::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Error::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Error_descriptor_;
}

const Error& Error::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_cockroach_2fproto_2ferrors_2eproto();
  return *default_instance_;
}

Error* Error::default_instance_ = NULL;

Error* Error::New(::google::protobuf::Arena* arena) const {
  Error* n = new Error;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Error::Clear() {
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<Error*>(16)->f)

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  if (_has_bits_[0 / 32] & 15u) {
    ZR_(retryable_, transaction_restart_);
    if (has_message()) {
      message_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    if (has_detail()) {
      if (detail_ != NULL) detail_->::cockroach::proto::ErrorDetail::Clear();
    }
  }

#undef ZR_HELPER_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool Error::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:cockroach.proto.Error)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string message = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_message()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->message().data(), this->message().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "cockroach.proto.Error.message");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_retryable;
        break;
      }

      // optional bool retryable = 2;
      case 2: {
        if (tag == 16) {
         parse_retryable:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &retryable_)));
          set_has_retryable();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_detail;
        break;
      }

      // optional .cockroach.proto.ErrorDetail detail = 3;
      case 3: {
        if (tag == 26) {
         parse_detail:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_detail()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_transaction_restart;
        break;
      }

      // optional .cockroach.proto.TransactionRestart transaction_restart = 4;
      case 4: {
        if (tag == 32) {
         parse_transaction_restart:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::cockroach::proto::TransactionRestart_IsValid(value)) {
            set_transaction_restart(static_cast< ::cockroach::proto::TransactionRestart >(value));
          } else {
            mutable_unknown_fields()->AddVarint(4, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:cockroach.proto.Error)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:cockroach.proto.Error)
  return false;
#undef DO_
}

void Error::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:cockroach.proto.Error)
  // optional string message = 1;
  if (has_message()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->message().data(), this->message().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "cockroach.proto.Error.message");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->message(), output);
  }

  // optional bool retryable = 2;
  if (has_retryable()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(2, this->retryable(), output);
  }

  // optional .cockroach.proto.ErrorDetail detail = 3;
  if (has_detail()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, *this->detail_, output);
  }

  // optional .cockroach.proto.TransactionRestart transaction_restart = 4;
  if (has_transaction_restart()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      4, this->transaction_restart(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:cockroach.proto.Error)
}

::google::protobuf::uint8* Error::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:cockroach.proto.Error)
  // optional string message = 1;
  if (has_message()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->message().data(), this->message().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "cockroach.proto.Error.message");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->message(), target);
  }

  // optional bool retryable = 2;
  if (has_retryable()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(2, this->retryable(), target);
  }

  // optional .cockroach.proto.ErrorDetail detail = 3;
  if (has_detail()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, *this->detail_, target);
  }

  // optional .cockroach.proto.TransactionRestart transaction_restart = 4;
  if (has_transaction_restart()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      4, this->transaction_restart(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:cockroach.proto.Error)
  return target;
}

int Error::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & 15) {
    // optional string message = 1;
    if (has_message()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->message());
    }

    // optional bool retryable = 2;
    if (has_retryable()) {
      total_size += 1 + 1;
    }

    // optional .cockroach.proto.TransactionRestart transaction_restart = 4;
    if (has_transaction_restart()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->transaction_restart());
    }

    // optional .cockroach.proto.ErrorDetail detail = 3;
    if (has_detail()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->detail_);
    }

  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Error::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const Error* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const Error>(
          &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Error::MergeFrom(const Error& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_message()) {
      set_has_message();
      message_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.message_);
    }
    if (from.has_retryable()) {
      set_retryable(from.retryable());
    }
    if (from.has_transaction_restart()) {
      set_transaction_restart(from.transaction_restart());
    }
    if (from.has_detail()) {
      mutable_detail()->::cockroach::proto::ErrorDetail::MergeFrom(from.detail());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void Error::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Error::CopyFrom(const Error& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Error::IsInitialized() const {

  return true;
}

void Error::Swap(Error* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Error::InternalSwap(Error* other) {
  message_.Swap(&other->message_);
  std::swap(retryable_, other->retryable_);
  std::swap(transaction_restart_, other->transaction_restart_);
  std::swap(detail_, other->detail_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata Error::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Error_descriptor_;
  metadata.reflection = Error_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// Error

// optional string message = 1;
bool Error::has_message() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void Error::set_has_message() {
  _has_bits_[0] |= 0x00000001u;
}
void Error::clear_has_message() {
  _has_bits_[0] &= ~0x00000001u;
}
void Error::clear_message() {
  message_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_message();
}
 const ::std::string& Error::message() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.Error.message)
  return message_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Error::set_message(const ::std::string& value) {
  set_has_message();
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cockroach.proto.Error.message)
}
 void Error::set_message(const char* value) {
  set_has_message();
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cockroach.proto.Error.message)
}
 void Error::set_message(const char* value, size_t size) {
  set_has_message();
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cockroach.proto.Error.message)
}
 ::std::string* Error::mutable_message() {
  set_has_message();
  // @@protoc_insertion_point(field_mutable:cockroach.proto.Error.message)
  return message_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* Error::release_message() {
  clear_has_message();
  return message_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Error::set_allocated_message(::std::string* message) {
  if (message != NULL) {
    set_has_message();
  } else {
    clear_has_message();
  }
  message_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), message);
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.Error.message)
}

// optional bool retryable = 2;
bool Error::has_retryable() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void Error::set_has_retryable() {
  _has_bits_[0] |= 0x00000002u;
}
void Error::clear_has_retryable() {
  _has_bits_[0] &= ~0x00000002u;
}
void Error::clear_retryable() {
  retryable_ = false;
  clear_has_retryable();
}
 bool Error::retryable() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.Error.retryable)
  return retryable_;
}
 void Error::set_retryable(bool value) {
  set_has_retryable();
  retryable_ = value;
  // @@protoc_insertion_point(field_set:cockroach.proto.Error.retryable)
}

// optional .cockroach.proto.TransactionRestart transaction_restart = 4;
bool Error::has_transaction_restart() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void Error::set_has_transaction_restart() {
  _has_bits_[0] |= 0x00000004u;
}
void Error::clear_has_transaction_restart() {
  _has_bits_[0] &= ~0x00000004u;
}
void Error::clear_transaction_restart() {
  transaction_restart_ = 0;
  clear_has_transaction_restart();
}
 ::cockroach::proto::TransactionRestart Error::transaction_restart() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.Error.transaction_restart)
  return static_cast< ::cockroach::proto::TransactionRestart >(transaction_restart_);
}
 void Error::set_transaction_restart(::cockroach::proto::TransactionRestart value) {
  assert(::cockroach::proto::TransactionRestart_IsValid(value));
  set_has_transaction_restart();
  transaction_restart_ = value;
  // @@protoc_insertion_point(field_set:cockroach.proto.Error.transaction_restart)
}

// optional .cockroach.proto.ErrorDetail detail = 3;
bool Error::has_detail() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void Error::set_has_detail() {
  _has_bits_[0] |= 0x00000008u;
}
void Error::clear_has_detail() {
  _has_bits_[0] &= ~0x00000008u;
}
void Error::clear_detail() {
  if (detail_ != NULL) detail_->::cockroach::proto::ErrorDetail::Clear();
  clear_has_detail();
}
 const ::cockroach::proto::ErrorDetail& Error::detail() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.Error.detail)
  return detail_ != NULL ? *detail_ : *default_instance_->detail_;
}
 ::cockroach::proto::ErrorDetail* Error::mutable_detail() {
  set_has_detail();
  if (detail_ == NULL) {
    detail_ = new ::cockroach::proto::ErrorDetail;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.proto.Error.detail)
  return detail_;
}
 ::cockroach::proto::ErrorDetail* Error::release_detail() {
  clear_has_detail();
  ::cockroach::proto::ErrorDetail* temp = detail_;
  detail_ = NULL;
  return temp;
}
 void Error::set_allocated_detail(::cockroach::proto::ErrorDetail* detail) {
  delete detail_;
  detail_ = detail;
  if (detail) {
    set_has_detail();
  } else {
    clear_has_detail();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.Error.detail)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// @@protoc_insertion_point(namespace_scope)

}  // namespace proto
}  // namespace cockroach

// @@protoc_insertion_point(global_scope)
