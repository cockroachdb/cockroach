// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: cockroach/proto/api.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "cockroach/proto/api.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)

namespace cockroach {
namespace proto {

namespace {

const ::google::protobuf::Descriptor* ClientCmdID_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ClientCmdID_reflection_ = NULL;
const ::google::protobuf::Descriptor* RequestHeader_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  RequestHeader_reflection_ = NULL;
const ::google::protobuf::Descriptor* ResponseHeader_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ResponseHeader_reflection_ = NULL;
const ::google::protobuf::Descriptor* GetRequest_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  GetRequest_reflection_ = NULL;
const ::google::protobuf::Descriptor* GetResponse_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  GetResponse_reflection_ = NULL;
const ::google::protobuf::Descriptor* PutRequest_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  PutRequest_reflection_ = NULL;
const ::google::protobuf::Descriptor* PutResponse_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  PutResponse_reflection_ = NULL;
const ::google::protobuf::Descriptor* ConditionalPutRequest_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ConditionalPutRequest_reflection_ = NULL;
const ::google::protobuf::Descriptor* ConditionalPutResponse_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ConditionalPutResponse_reflection_ = NULL;
const ::google::protobuf::Descriptor* IncrementRequest_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  IncrementRequest_reflection_ = NULL;
const ::google::protobuf::Descriptor* IncrementResponse_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  IncrementResponse_reflection_ = NULL;
const ::google::protobuf::Descriptor* DeleteRequest_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  DeleteRequest_reflection_ = NULL;
const ::google::protobuf::Descriptor* DeleteResponse_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  DeleteResponse_reflection_ = NULL;
const ::google::protobuf::Descriptor* DeleteRangeRequest_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  DeleteRangeRequest_reflection_ = NULL;
const ::google::protobuf::Descriptor* DeleteRangeResponse_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  DeleteRangeResponse_reflection_ = NULL;
const ::google::protobuf::Descriptor* ScanRequest_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ScanRequest_reflection_ = NULL;
const ::google::protobuf::Descriptor* ScanResponse_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ScanResponse_reflection_ = NULL;
const ::google::protobuf::Descriptor* ReverseScanRequest_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ReverseScanRequest_reflection_ = NULL;
const ::google::protobuf::Descriptor* ReverseScanResponse_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ReverseScanResponse_reflection_ = NULL;
const ::google::protobuf::Descriptor* EndTransactionRequest_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  EndTransactionRequest_reflection_ = NULL;
const ::google::protobuf::Descriptor* EndTransactionResponse_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  EndTransactionResponse_reflection_ = NULL;
const ::google::protobuf::Descriptor* AdminSplitRequest_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  AdminSplitRequest_reflection_ = NULL;
const ::google::protobuf::Descriptor* AdminSplitResponse_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  AdminSplitResponse_reflection_ = NULL;
const ::google::protobuf::Descriptor* AdminMergeRequest_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  AdminMergeRequest_reflection_ = NULL;
const ::google::protobuf::Descriptor* AdminMergeResponse_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  AdminMergeResponse_reflection_ = NULL;
const ::google::protobuf::Descriptor* RangeLookupRequest_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  RangeLookupRequest_reflection_ = NULL;
const ::google::protobuf::Descriptor* RangeLookupResponse_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  RangeLookupResponse_reflection_ = NULL;
const ::google::protobuf::Descriptor* HeartbeatTxnRequest_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  HeartbeatTxnRequest_reflection_ = NULL;
const ::google::protobuf::Descriptor* HeartbeatTxnResponse_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  HeartbeatTxnResponse_reflection_ = NULL;
const ::google::protobuf::Descriptor* GCRequest_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  GCRequest_reflection_ = NULL;
const ::google::protobuf::Descriptor* GCRequest_GCKey_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  GCRequest_GCKey_reflection_ = NULL;
const ::google::protobuf::Descriptor* GCResponse_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  GCResponse_reflection_ = NULL;
const ::google::protobuf::Descriptor* PushTxnRequest_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  PushTxnRequest_reflection_ = NULL;
const ::google::protobuf::Descriptor* PushTxnResponse_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  PushTxnResponse_reflection_ = NULL;
const ::google::protobuf::Descriptor* ResolveIntentRequest_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ResolveIntentRequest_reflection_ = NULL;
const ::google::protobuf::Descriptor* ResolveIntentResponse_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ResolveIntentResponse_reflection_ = NULL;
const ::google::protobuf::Descriptor* ResolveIntentRangeRequest_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ResolveIntentRangeRequest_reflection_ = NULL;
const ::google::protobuf::Descriptor* NoopResponse_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  NoopResponse_reflection_ = NULL;
const ::google::protobuf::Descriptor* NoopRequest_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  NoopRequest_reflection_ = NULL;
const ::google::protobuf::Descriptor* ResolveIntentRangeResponse_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ResolveIntentRangeResponse_reflection_ = NULL;
const ::google::protobuf::Descriptor* MergeRequest_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  MergeRequest_reflection_ = NULL;
const ::google::protobuf::Descriptor* MergeResponse_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  MergeResponse_reflection_ = NULL;
const ::google::protobuf::Descriptor* TruncateLogRequest_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  TruncateLogRequest_reflection_ = NULL;
const ::google::protobuf::Descriptor* TruncateLogResponse_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  TruncateLogResponse_reflection_ = NULL;
const ::google::protobuf::Descriptor* LeaderLeaseRequest_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  LeaderLeaseRequest_reflection_ = NULL;
const ::google::protobuf::Descriptor* LeaderLeaseResponse_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  LeaderLeaseResponse_reflection_ = NULL;
const ::google::protobuf::Descriptor* RequestUnion_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  RequestUnion_reflection_ = NULL;
const ::google::protobuf::Descriptor* ResponseUnion_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ResponseUnion_reflection_ = NULL;
const ::google::protobuf::Descriptor* BatchRequest_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  BatchRequest_reflection_ = NULL;
const ::google::protobuf::Descriptor* BatchResponse_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  BatchResponse_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* ReadConsistencyType_descriptor_ = NULL;
const ::google::protobuf::EnumDescriptor* PushTxnType_descriptor_ = NULL;

}  // namespace


void protobuf_AssignDesc_cockroach_2fproto_2fapi_2eproto() {
  protobuf_AddDesc_cockroach_2fproto_2fapi_2eproto();
  const ::google::protobuf::FileDescriptor* file =
    ::google::protobuf::DescriptorPool::generated_pool()->FindFileByName(
      "cockroach/proto/api.proto");
  GOOGLE_CHECK(file != NULL);
  ClientCmdID_descriptor_ = file->message_type(0);
  static const int ClientCmdID_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ClientCmdID, wall_time_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ClientCmdID, random_),
  };
  ClientCmdID_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      ClientCmdID_descriptor_,
      ClientCmdID::default_instance_,
      ClientCmdID_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ClientCmdID, _has_bits_[0]),
      -1,
      -1,
      sizeof(ClientCmdID),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ClientCmdID, _internal_metadata_),
      -1);
  RequestHeader_descriptor_ = file->message_type(1);
  static const int RequestHeader_offsets_[9] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RequestHeader, timestamp_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RequestHeader, cmd_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RequestHeader, key_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RequestHeader, end_key_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RequestHeader, replica_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RequestHeader, range_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RequestHeader, user_priority_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RequestHeader, txn_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RequestHeader, read_consistency_),
  };
  RequestHeader_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      RequestHeader_descriptor_,
      RequestHeader::default_instance_,
      RequestHeader_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RequestHeader, _has_bits_[0]),
      -1,
      -1,
      sizeof(RequestHeader),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RequestHeader, _internal_metadata_),
      -1);
  ResponseHeader_descriptor_ = file->message_type(2);
  static const int ResponseHeader_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResponseHeader, error_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResponseHeader, timestamp_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResponseHeader, txn_),
  };
  ResponseHeader_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      ResponseHeader_descriptor_,
      ResponseHeader::default_instance_,
      ResponseHeader_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResponseHeader, _has_bits_[0]),
      -1,
      -1,
      sizeof(ResponseHeader),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResponseHeader, _internal_metadata_),
      -1);
  GetRequest_descriptor_ = file->message_type(3);
  static const int GetRequest_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GetRequest, header_),
  };
  GetRequest_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      GetRequest_descriptor_,
      GetRequest::default_instance_,
      GetRequest_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GetRequest, _has_bits_[0]),
      -1,
      -1,
      sizeof(GetRequest),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GetRequest, _internal_metadata_),
      -1);
  GetResponse_descriptor_ = file->message_type(4);
  static const int GetResponse_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GetResponse, header_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GetResponse, value_),
  };
  GetResponse_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      GetResponse_descriptor_,
      GetResponse::default_instance_,
      GetResponse_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GetResponse, _has_bits_[0]),
      -1,
      -1,
      sizeof(GetResponse),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GetResponse, _internal_metadata_),
      -1);
  PutRequest_descriptor_ = file->message_type(5);
  static const int PutRequest_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PutRequest, header_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PutRequest, value_),
  };
  PutRequest_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      PutRequest_descriptor_,
      PutRequest::default_instance_,
      PutRequest_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PutRequest, _has_bits_[0]),
      -1,
      -1,
      sizeof(PutRequest),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PutRequest, _internal_metadata_),
      -1);
  PutResponse_descriptor_ = file->message_type(6);
  static const int PutResponse_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PutResponse, header_),
  };
  PutResponse_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      PutResponse_descriptor_,
      PutResponse::default_instance_,
      PutResponse_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PutResponse, _has_bits_[0]),
      -1,
      -1,
      sizeof(PutResponse),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PutResponse, _internal_metadata_),
      -1);
  ConditionalPutRequest_descriptor_ = file->message_type(7);
  static const int ConditionalPutRequest_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ConditionalPutRequest, header_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ConditionalPutRequest, value_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ConditionalPutRequest, exp_value_),
  };
  ConditionalPutRequest_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      ConditionalPutRequest_descriptor_,
      ConditionalPutRequest::default_instance_,
      ConditionalPutRequest_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ConditionalPutRequest, _has_bits_[0]),
      -1,
      -1,
      sizeof(ConditionalPutRequest),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ConditionalPutRequest, _internal_metadata_),
      -1);
  ConditionalPutResponse_descriptor_ = file->message_type(8);
  static const int ConditionalPutResponse_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ConditionalPutResponse, header_),
  };
  ConditionalPutResponse_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      ConditionalPutResponse_descriptor_,
      ConditionalPutResponse::default_instance_,
      ConditionalPutResponse_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ConditionalPutResponse, _has_bits_[0]),
      -1,
      -1,
      sizeof(ConditionalPutResponse),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ConditionalPutResponse, _internal_metadata_),
      -1);
  IncrementRequest_descriptor_ = file->message_type(9);
  static const int IncrementRequest_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(IncrementRequest, header_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(IncrementRequest, increment_),
  };
  IncrementRequest_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      IncrementRequest_descriptor_,
      IncrementRequest::default_instance_,
      IncrementRequest_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(IncrementRequest, _has_bits_[0]),
      -1,
      -1,
      sizeof(IncrementRequest),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(IncrementRequest, _internal_metadata_),
      -1);
  IncrementResponse_descriptor_ = file->message_type(10);
  static const int IncrementResponse_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(IncrementResponse, header_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(IncrementResponse, new_value_),
  };
  IncrementResponse_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      IncrementResponse_descriptor_,
      IncrementResponse::default_instance_,
      IncrementResponse_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(IncrementResponse, _has_bits_[0]),
      -1,
      -1,
      sizeof(IncrementResponse),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(IncrementResponse, _internal_metadata_),
      -1);
  DeleteRequest_descriptor_ = file->message_type(11);
  static const int DeleteRequest_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DeleteRequest, header_),
  };
  DeleteRequest_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      DeleteRequest_descriptor_,
      DeleteRequest::default_instance_,
      DeleteRequest_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DeleteRequest, _has_bits_[0]),
      -1,
      -1,
      sizeof(DeleteRequest),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DeleteRequest, _internal_metadata_),
      -1);
  DeleteResponse_descriptor_ = file->message_type(12);
  static const int DeleteResponse_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DeleteResponse, header_),
  };
  DeleteResponse_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      DeleteResponse_descriptor_,
      DeleteResponse::default_instance_,
      DeleteResponse_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DeleteResponse, _has_bits_[0]),
      -1,
      -1,
      sizeof(DeleteResponse),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DeleteResponse, _internal_metadata_),
      -1);
  DeleteRangeRequest_descriptor_ = file->message_type(13);
  static const int DeleteRangeRequest_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DeleteRangeRequest, header_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DeleteRangeRequest, max_entries_to_delete_),
  };
  DeleteRangeRequest_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      DeleteRangeRequest_descriptor_,
      DeleteRangeRequest::default_instance_,
      DeleteRangeRequest_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DeleteRangeRequest, _has_bits_[0]),
      -1,
      -1,
      sizeof(DeleteRangeRequest),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DeleteRangeRequest, _internal_metadata_),
      -1);
  DeleteRangeResponse_descriptor_ = file->message_type(14);
  static const int DeleteRangeResponse_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DeleteRangeResponse, header_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DeleteRangeResponse, num_deleted_),
  };
  DeleteRangeResponse_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      DeleteRangeResponse_descriptor_,
      DeleteRangeResponse::default_instance_,
      DeleteRangeResponse_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DeleteRangeResponse, _has_bits_[0]),
      -1,
      -1,
      sizeof(DeleteRangeResponse),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DeleteRangeResponse, _internal_metadata_),
      -1);
  ScanRequest_descriptor_ = file->message_type(15);
  static const int ScanRequest_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ScanRequest, header_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ScanRequest, max_results_),
  };
  ScanRequest_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      ScanRequest_descriptor_,
      ScanRequest::default_instance_,
      ScanRequest_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ScanRequest, _has_bits_[0]),
      -1,
      -1,
      sizeof(ScanRequest),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ScanRequest, _internal_metadata_),
      -1);
  ScanResponse_descriptor_ = file->message_type(16);
  static const int ScanResponse_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ScanResponse, header_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ScanResponse, rows_),
  };
  ScanResponse_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      ScanResponse_descriptor_,
      ScanResponse::default_instance_,
      ScanResponse_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ScanResponse, _has_bits_[0]),
      -1,
      -1,
      sizeof(ScanResponse),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ScanResponse, _internal_metadata_),
      -1);
  ReverseScanRequest_descriptor_ = file->message_type(17);
  static const int ReverseScanRequest_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReverseScanRequest, header_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReverseScanRequest, max_results_),
  };
  ReverseScanRequest_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      ReverseScanRequest_descriptor_,
      ReverseScanRequest::default_instance_,
      ReverseScanRequest_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReverseScanRequest, _has_bits_[0]),
      -1,
      -1,
      sizeof(ReverseScanRequest),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReverseScanRequest, _internal_metadata_),
      -1);
  ReverseScanResponse_descriptor_ = file->message_type(18);
  static const int ReverseScanResponse_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReverseScanResponse, header_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReverseScanResponse, rows_),
  };
  ReverseScanResponse_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      ReverseScanResponse_descriptor_,
      ReverseScanResponse::default_instance_,
      ReverseScanResponse_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReverseScanResponse, _has_bits_[0]),
      -1,
      -1,
      sizeof(ReverseScanResponse),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReverseScanResponse, _internal_metadata_),
      -1);
  EndTransactionRequest_descriptor_ = file->message_type(19);
  static const int EndTransactionRequest_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EndTransactionRequest, header_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EndTransactionRequest, commit_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EndTransactionRequest, internal_commit_trigger_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EndTransactionRequest, intents_),
  };
  EndTransactionRequest_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      EndTransactionRequest_descriptor_,
      EndTransactionRequest::default_instance_,
      EndTransactionRequest_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EndTransactionRequest, _has_bits_[0]),
      -1,
      -1,
      sizeof(EndTransactionRequest),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EndTransactionRequest, _internal_metadata_),
      -1);
  EndTransactionResponse_descriptor_ = file->message_type(20);
  static const int EndTransactionResponse_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EndTransactionResponse, header_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EndTransactionResponse, commit_wait_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EndTransactionResponse, resolved_),
  };
  EndTransactionResponse_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      EndTransactionResponse_descriptor_,
      EndTransactionResponse::default_instance_,
      EndTransactionResponse_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EndTransactionResponse, _has_bits_[0]),
      -1,
      -1,
      sizeof(EndTransactionResponse),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EndTransactionResponse, _internal_metadata_),
      -1);
  AdminSplitRequest_descriptor_ = file->message_type(21);
  static const int AdminSplitRequest_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AdminSplitRequest, header_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AdminSplitRequest, split_key_),
  };
  AdminSplitRequest_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      AdminSplitRequest_descriptor_,
      AdminSplitRequest::default_instance_,
      AdminSplitRequest_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AdminSplitRequest, _has_bits_[0]),
      -1,
      -1,
      sizeof(AdminSplitRequest),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AdminSplitRequest, _internal_metadata_),
      -1);
  AdminSplitResponse_descriptor_ = file->message_type(22);
  static const int AdminSplitResponse_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AdminSplitResponse, header_),
  };
  AdminSplitResponse_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      AdminSplitResponse_descriptor_,
      AdminSplitResponse::default_instance_,
      AdminSplitResponse_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AdminSplitResponse, _has_bits_[0]),
      -1,
      -1,
      sizeof(AdminSplitResponse),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AdminSplitResponse, _internal_metadata_),
      -1);
  AdminMergeRequest_descriptor_ = file->message_type(23);
  static const int AdminMergeRequest_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AdminMergeRequest, header_),
  };
  AdminMergeRequest_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      AdminMergeRequest_descriptor_,
      AdminMergeRequest::default_instance_,
      AdminMergeRequest_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AdminMergeRequest, _has_bits_[0]),
      -1,
      -1,
      sizeof(AdminMergeRequest),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AdminMergeRequest, _internal_metadata_),
      -1);
  AdminMergeResponse_descriptor_ = file->message_type(24);
  static const int AdminMergeResponse_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AdminMergeResponse, header_),
  };
  AdminMergeResponse_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      AdminMergeResponse_descriptor_,
      AdminMergeResponse::default_instance_,
      AdminMergeResponse_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AdminMergeResponse, _has_bits_[0]),
      -1,
      -1,
      sizeof(AdminMergeResponse),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AdminMergeResponse, _internal_metadata_),
      -1);
  RangeLookupRequest_descriptor_ = file->message_type(25);
  static const int RangeLookupRequest_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RangeLookupRequest, header_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RangeLookupRequest, max_ranges_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RangeLookupRequest, consider_intents_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RangeLookupRequest, reverse_),
  };
  RangeLookupRequest_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      RangeLookupRequest_descriptor_,
      RangeLookupRequest::default_instance_,
      RangeLookupRequest_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RangeLookupRequest, _has_bits_[0]),
      -1,
      -1,
      sizeof(RangeLookupRequest),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RangeLookupRequest, _internal_metadata_),
      -1);
  RangeLookupResponse_descriptor_ = file->message_type(26);
  static const int RangeLookupResponse_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RangeLookupResponse, header_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RangeLookupResponse, ranges_),
  };
  RangeLookupResponse_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      RangeLookupResponse_descriptor_,
      RangeLookupResponse::default_instance_,
      RangeLookupResponse_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RangeLookupResponse, _has_bits_[0]),
      -1,
      -1,
      sizeof(RangeLookupResponse),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RangeLookupResponse, _internal_metadata_),
      -1);
  HeartbeatTxnRequest_descriptor_ = file->message_type(27);
  static const int HeartbeatTxnRequest_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HeartbeatTxnRequest, header_),
  };
  HeartbeatTxnRequest_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      HeartbeatTxnRequest_descriptor_,
      HeartbeatTxnRequest::default_instance_,
      HeartbeatTxnRequest_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HeartbeatTxnRequest, _has_bits_[0]),
      -1,
      -1,
      sizeof(HeartbeatTxnRequest),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HeartbeatTxnRequest, _internal_metadata_),
      -1);
  HeartbeatTxnResponse_descriptor_ = file->message_type(28);
  static const int HeartbeatTxnResponse_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HeartbeatTxnResponse, header_),
  };
  HeartbeatTxnResponse_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      HeartbeatTxnResponse_descriptor_,
      HeartbeatTxnResponse::default_instance_,
      HeartbeatTxnResponse_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HeartbeatTxnResponse, _has_bits_[0]),
      -1,
      -1,
      sizeof(HeartbeatTxnResponse),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HeartbeatTxnResponse, _internal_metadata_),
      -1);
  GCRequest_descriptor_ = file->message_type(29);
  static const int GCRequest_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GCRequest, header_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GCRequest, gc_meta_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GCRequest, keys_),
  };
  GCRequest_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      GCRequest_descriptor_,
      GCRequest::default_instance_,
      GCRequest_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GCRequest, _has_bits_[0]),
      -1,
      -1,
      sizeof(GCRequest),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GCRequest, _internal_metadata_),
      -1);
  GCRequest_GCKey_descriptor_ = GCRequest_descriptor_->nested_type(0);
  static const int GCRequest_GCKey_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GCRequest_GCKey, key_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GCRequest_GCKey, timestamp_),
  };
  GCRequest_GCKey_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      GCRequest_GCKey_descriptor_,
      GCRequest_GCKey::default_instance_,
      GCRequest_GCKey_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GCRequest_GCKey, _has_bits_[0]),
      -1,
      -1,
      sizeof(GCRequest_GCKey),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GCRequest_GCKey, _internal_metadata_),
      -1);
  GCResponse_descriptor_ = file->message_type(30);
  static const int GCResponse_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GCResponse, header_),
  };
  GCResponse_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      GCResponse_descriptor_,
      GCResponse::default_instance_,
      GCResponse_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GCResponse, _has_bits_[0]),
      -1,
      -1,
      sizeof(GCResponse),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GCResponse, _internal_metadata_),
      -1);
  PushTxnRequest_descriptor_ = file->message_type(31);
  static const int PushTxnRequest_offsets_[5] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PushTxnRequest, header_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PushTxnRequest, pusher_txn_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PushTxnRequest, pushee_txn_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PushTxnRequest, now_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PushTxnRequest, push_type_),
  };
  PushTxnRequest_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      PushTxnRequest_descriptor_,
      PushTxnRequest::default_instance_,
      PushTxnRequest_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PushTxnRequest, _has_bits_[0]),
      -1,
      -1,
      sizeof(PushTxnRequest),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PushTxnRequest, _internal_metadata_),
      -1);
  PushTxnResponse_descriptor_ = file->message_type(32);
  static const int PushTxnResponse_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PushTxnResponse, header_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PushTxnResponse, pushee_txn_),
  };
  PushTxnResponse_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      PushTxnResponse_descriptor_,
      PushTxnResponse::default_instance_,
      PushTxnResponse_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PushTxnResponse, _has_bits_[0]),
      -1,
      -1,
      sizeof(PushTxnResponse),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PushTxnResponse, _internal_metadata_),
      -1);
  ResolveIntentRequest_descriptor_ = file->message_type(33);
  static const int ResolveIntentRequest_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResolveIntentRequest, header_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResolveIntentRequest, intent_txn_),
  };
  ResolveIntentRequest_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      ResolveIntentRequest_descriptor_,
      ResolveIntentRequest::default_instance_,
      ResolveIntentRequest_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResolveIntentRequest, _has_bits_[0]),
      -1,
      -1,
      sizeof(ResolveIntentRequest),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResolveIntentRequest, _internal_metadata_),
      -1);
  ResolveIntentResponse_descriptor_ = file->message_type(34);
  static const int ResolveIntentResponse_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResolveIntentResponse, header_),
  };
  ResolveIntentResponse_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      ResolveIntentResponse_descriptor_,
      ResolveIntentResponse::default_instance_,
      ResolveIntentResponse_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResolveIntentResponse, _has_bits_[0]),
      -1,
      -1,
      sizeof(ResolveIntentResponse),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResolveIntentResponse, _internal_metadata_),
      -1);
  ResolveIntentRangeRequest_descriptor_ = file->message_type(35);
  static const int ResolveIntentRangeRequest_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResolveIntentRangeRequest, header_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResolveIntentRangeRequest, intent_txn_),
  };
  ResolveIntentRangeRequest_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      ResolveIntentRangeRequest_descriptor_,
      ResolveIntentRangeRequest::default_instance_,
      ResolveIntentRangeRequest_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResolveIntentRangeRequest, _has_bits_[0]),
      -1,
      -1,
      sizeof(ResolveIntentRangeRequest),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResolveIntentRangeRequest, _internal_metadata_),
      -1);
  NoopResponse_descriptor_ = file->message_type(36);
  static const int NoopResponse_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NoopResponse, header_),
  };
  NoopResponse_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      NoopResponse_descriptor_,
      NoopResponse::default_instance_,
      NoopResponse_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NoopResponse, _has_bits_[0]),
      -1,
      -1,
      sizeof(NoopResponse),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NoopResponse, _internal_metadata_),
      -1);
  NoopRequest_descriptor_ = file->message_type(37);
  static const int NoopRequest_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NoopRequest, header_),
  };
  NoopRequest_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      NoopRequest_descriptor_,
      NoopRequest::default_instance_,
      NoopRequest_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NoopRequest, _has_bits_[0]),
      -1,
      -1,
      sizeof(NoopRequest),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NoopRequest, _internal_metadata_),
      -1);
  ResolveIntentRangeResponse_descriptor_ = file->message_type(38);
  static const int ResolveIntentRangeResponse_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResolveIntentRangeResponse, header_),
  };
  ResolveIntentRangeResponse_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      ResolveIntentRangeResponse_descriptor_,
      ResolveIntentRangeResponse::default_instance_,
      ResolveIntentRangeResponse_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResolveIntentRangeResponse, _has_bits_[0]),
      -1,
      -1,
      sizeof(ResolveIntentRangeResponse),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResolveIntentRangeResponse, _internal_metadata_),
      -1);
  MergeRequest_descriptor_ = file->message_type(39);
  static const int MergeRequest_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MergeRequest, header_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MergeRequest, value_),
  };
  MergeRequest_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      MergeRequest_descriptor_,
      MergeRequest::default_instance_,
      MergeRequest_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MergeRequest, _has_bits_[0]),
      -1,
      -1,
      sizeof(MergeRequest),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MergeRequest, _internal_metadata_),
      -1);
  MergeResponse_descriptor_ = file->message_type(40);
  static const int MergeResponse_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MergeResponse, header_),
  };
  MergeResponse_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      MergeResponse_descriptor_,
      MergeResponse::default_instance_,
      MergeResponse_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MergeResponse, _has_bits_[0]),
      -1,
      -1,
      sizeof(MergeResponse),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MergeResponse, _internal_metadata_),
      -1);
  TruncateLogRequest_descriptor_ = file->message_type(41);
  static const int TruncateLogRequest_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TruncateLogRequest, header_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TruncateLogRequest, index_),
  };
  TruncateLogRequest_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      TruncateLogRequest_descriptor_,
      TruncateLogRequest::default_instance_,
      TruncateLogRequest_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TruncateLogRequest, _has_bits_[0]),
      -1,
      -1,
      sizeof(TruncateLogRequest),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TruncateLogRequest, _internal_metadata_),
      -1);
  TruncateLogResponse_descriptor_ = file->message_type(42);
  static const int TruncateLogResponse_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TruncateLogResponse, header_),
  };
  TruncateLogResponse_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      TruncateLogResponse_descriptor_,
      TruncateLogResponse::default_instance_,
      TruncateLogResponse_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TruncateLogResponse, _has_bits_[0]),
      -1,
      -1,
      sizeof(TruncateLogResponse),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TruncateLogResponse, _internal_metadata_),
      -1);
  LeaderLeaseRequest_descriptor_ = file->message_type(43);
  static const int LeaderLeaseRequest_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LeaderLeaseRequest, header_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LeaderLeaseRequest, lease_),
  };
  LeaderLeaseRequest_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      LeaderLeaseRequest_descriptor_,
      LeaderLeaseRequest::default_instance_,
      LeaderLeaseRequest_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LeaderLeaseRequest, _has_bits_[0]),
      -1,
      -1,
      sizeof(LeaderLeaseRequest),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LeaderLeaseRequest, _internal_metadata_),
      -1);
  LeaderLeaseResponse_descriptor_ = file->message_type(44);
  static const int LeaderLeaseResponse_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LeaderLeaseResponse, header_),
  };
  LeaderLeaseResponse_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      LeaderLeaseResponse_descriptor_,
      LeaderLeaseResponse::default_instance_,
      LeaderLeaseResponse_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LeaderLeaseResponse, _has_bits_[0]),
      -1,
      -1,
      sizeof(LeaderLeaseResponse),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LeaderLeaseResponse, _internal_metadata_),
      -1);
  RequestUnion_descriptor_ = file->message_type(45);
  static const int RequestUnion_offsets_[21] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RequestUnion, get_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RequestUnion, put_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RequestUnion, conditional_put_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RequestUnion, increment_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RequestUnion, delete__),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RequestUnion, delete_range_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RequestUnion, scan_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RequestUnion, end_transaction_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RequestUnion, admin_split_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RequestUnion, admin_merge_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RequestUnion, heartbeat_txn_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RequestUnion, gc_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RequestUnion, push_txn_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RequestUnion, range_lookup_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RequestUnion, resolve_intent_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RequestUnion, resolve_intent_range_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RequestUnion, merge_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RequestUnion, truncate_log_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RequestUnion, leader_lease_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RequestUnion, reverse_scan_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RequestUnion, noop_),
  };
  RequestUnion_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      RequestUnion_descriptor_,
      RequestUnion::default_instance_,
      RequestUnion_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RequestUnion, _has_bits_[0]),
      -1,
      -1,
      sizeof(RequestUnion),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RequestUnion, _internal_metadata_),
      -1);
  ResponseUnion_descriptor_ = file->message_type(46);
  static const int ResponseUnion_offsets_[21] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResponseUnion, get_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResponseUnion, put_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResponseUnion, conditional_put_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResponseUnion, increment_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResponseUnion, delete__),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResponseUnion, delete_range_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResponseUnion, scan_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResponseUnion, end_transaction_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResponseUnion, admin_split_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResponseUnion, admin_merge_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResponseUnion, heartbeat_txn_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResponseUnion, gc_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResponseUnion, push_txn_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResponseUnion, range_lookup_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResponseUnion, resolve_intent_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResponseUnion, resolve_intent_range_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResponseUnion, merge_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResponseUnion, truncate_log_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResponseUnion, leader_lease_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResponseUnion, reverse_scan_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResponseUnion, noop_),
  };
  ResponseUnion_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      ResponseUnion_descriptor_,
      ResponseUnion::default_instance_,
      ResponseUnion_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResponseUnion, _has_bits_[0]),
      -1,
      -1,
      sizeof(ResponseUnion),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResponseUnion, _internal_metadata_),
      -1);
  BatchRequest_descriptor_ = file->message_type(47);
  static const int BatchRequest_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BatchRequest, header_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BatchRequest, requests_),
  };
  BatchRequest_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      BatchRequest_descriptor_,
      BatchRequest::default_instance_,
      BatchRequest_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BatchRequest, _has_bits_[0]),
      -1,
      -1,
      sizeof(BatchRequest),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BatchRequest, _internal_metadata_),
      -1);
  BatchResponse_descriptor_ = file->message_type(48);
  static const int BatchResponse_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BatchResponse, header_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BatchResponse, responses_),
  };
  BatchResponse_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      BatchResponse_descriptor_,
      BatchResponse::default_instance_,
      BatchResponse_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BatchResponse, _has_bits_[0]),
      -1,
      -1,
      sizeof(BatchResponse),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BatchResponse, _internal_metadata_),
      -1);
  ReadConsistencyType_descriptor_ = file->enum_type(0);
  PushTxnType_descriptor_ = file->enum_type(1);
}

namespace {

GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AssignDescriptors_once_);
inline void protobuf_AssignDescriptorsOnce() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AssignDescriptors_once_,
                 &protobuf_AssignDesc_cockroach_2fproto_2fapi_2eproto);
}

void protobuf_RegisterTypes(const ::std::string&) {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      ClientCmdID_descriptor_, &ClientCmdID::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      RequestHeader_descriptor_, &RequestHeader::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      ResponseHeader_descriptor_, &ResponseHeader::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      GetRequest_descriptor_, &GetRequest::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      GetResponse_descriptor_, &GetResponse::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      PutRequest_descriptor_, &PutRequest::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      PutResponse_descriptor_, &PutResponse::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      ConditionalPutRequest_descriptor_, &ConditionalPutRequest::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      ConditionalPutResponse_descriptor_, &ConditionalPutResponse::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      IncrementRequest_descriptor_, &IncrementRequest::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      IncrementResponse_descriptor_, &IncrementResponse::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      DeleteRequest_descriptor_, &DeleteRequest::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      DeleteResponse_descriptor_, &DeleteResponse::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      DeleteRangeRequest_descriptor_, &DeleteRangeRequest::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      DeleteRangeResponse_descriptor_, &DeleteRangeResponse::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      ScanRequest_descriptor_, &ScanRequest::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      ScanResponse_descriptor_, &ScanResponse::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      ReverseScanRequest_descriptor_, &ReverseScanRequest::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      ReverseScanResponse_descriptor_, &ReverseScanResponse::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      EndTransactionRequest_descriptor_, &EndTransactionRequest::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      EndTransactionResponse_descriptor_, &EndTransactionResponse::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      AdminSplitRequest_descriptor_, &AdminSplitRequest::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      AdminSplitResponse_descriptor_, &AdminSplitResponse::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      AdminMergeRequest_descriptor_, &AdminMergeRequest::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      AdminMergeResponse_descriptor_, &AdminMergeResponse::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      RangeLookupRequest_descriptor_, &RangeLookupRequest::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      RangeLookupResponse_descriptor_, &RangeLookupResponse::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      HeartbeatTxnRequest_descriptor_, &HeartbeatTxnRequest::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      HeartbeatTxnResponse_descriptor_, &HeartbeatTxnResponse::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      GCRequest_descriptor_, &GCRequest::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      GCRequest_GCKey_descriptor_, &GCRequest_GCKey::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      GCResponse_descriptor_, &GCResponse::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      PushTxnRequest_descriptor_, &PushTxnRequest::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      PushTxnResponse_descriptor_, &PushTxnResponse::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      ResolveIntentRequest_descriptor_, &ResolveIntentRequest::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      ResolveIntentResponse_descriptor_, &ResolveIntentResponse::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      ResolveIntentRangeRequest_descriptor_, &ResolveIntentRangeRequest::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      NoopResponse_descriptor_, &NoopResponse::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      NoopRequest_descriptor_, &NoopRequest::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      ResolveIntentRangeResponse_descriptor_, &ResolveIntentRangeResponse::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      MergeRequest_descriptor_, &MergeRequest::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      MergeResponse_descriptor_, &MergeResponse::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      TruncateLogRequest_descriptor_, &TruncateLogRequest::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      TruncateLogResponse_descriptor_, &TruncateLogResponse::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      LeaderLeaseRequest_descriptor_, &LeaderLeaseRequest::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      LeaderLeaseResponse_descriptor_, &LeaderLeaseResponse::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      RequestUnion_descriptor_, &RequestUnion::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      ResponseUnion_descriptor_, &ResponseUnion::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      BatchRequest_descriptor_, &BatchRequest::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      BatchResponse_descriptor_, &BatchResponse::default_instance());
}

}  // namespace

void protobuf_ShutdownFile_cockroach_2fproto_2fapi_2eproto() {
  delete ClientCmdID::default_instance_;
  delete ClientCmdID_reflection_;
  delete RequestHeader::default_instance_;
  delete RequestHeader_reflection_;
  delete ResponseHeader::default_instance_;
  delete ResponseHeader_reflection_;
  delete GetRequest::default_instance_;
  delete GetRequest_reflection_;
  delete GetResponse::default_instance_;
  delete GetResponse_reflection_;
  delete PutRequest::default_instance_;
  delete PutRequest_reflection_;
  delete PutResponse::default_instance_;
  delete PutResponse_reflection_;
  delete ConditionalPutRequest::default_instance_;
  delete ConditionalPutRequest_reflection_;
  delete ConditionalPutResponse::default_instance_;
  delete ConditionalPutResponse_reflection_;
  delete IncrementRequest::default_instance_;
  delete IncrementRequest_reflection_;
  delete IncrementResponse::default_instance_;
  delete IncrementResponse_reflection_;
  delete DeleteRequest::default_instance_;
  delete DeleteRequest_reflection_;
  delete DeleteResponse::default_instance_;
  delete DeleteResponse_reflection_;
  delete DeleteRangeRequest::default_instance_;
  delete DeleteRangeRequest_reflection_;
  delete DeleteRangeResponse::default_instance_;
  delete DeleteRangeResponse_reflection_;
  delete ScanRequest::default_instance_;
  delete ScanRequest_reflection_;
  delete ScanResponse::default_instance_;
  delete ScanResponse_reflection_;
  delete ReverseScanRequest::default_instance_;
  delete ReverseScanRequest_reflection_;
  delete ReverseScanResponse::default_instance_;
  delete ReverseScanResponse_reflection_;
  delete EndTransactionRequest::default_instance_;
  delete EndTransactionRequest_reflection_;
  delete EndTransactionResponse::default_instance_;
  delete EndTransactionResponse_reflection_;
  delete AdminSplitRequest::default_instance_;
  delete AdminSplitRequest_reflection_;
  delete AdminSplitResponse::default_instance_;
  delete AdminSplitResponse_reflection_;
  delete AdminMergeRequest::default_instance_;
  delete AdminMergeRequest_reflection_;
  delete AdminMergeResponse::default_instance_;
  delete AdminMergeResponse_reflection_;
  delete RangeLookupRequest::default_instance_;
  delete RangeLookupRequest_reflection_;
  delete RangeLookupResponse::default_instance_;
  delete RangeLookupResponse_reflection_;
  delete HeartbeatTxnRequest::default_instance_;
  delete HeartbeatTxnRequest_reflection_;
  delete HeartbeatTxnResponse::default_instance_;
  delete HeartbeatTxnResponse_reflection_;
  delete GCRequest::default_instance_;
  delete GCRequest_reflection_;
  delete GCRequest_GCKey::default_instance_;
  delete GCRequest_GCKey_reflection_;
  delete GCResponse::default_instance_;
  delete GCResponse_reflection_;
  delete PushTxnRequest::default_instance_;
  delete PushTxnRequest_reflection_;
  delete PushTxnResponse::default_instance_;
  delete PushTxnResponse_reflection_;
  delete ResolveIntentRequest::default_instance_;
  delete ResolveIntentRequest_reflection_;
  delete ResolveIntentResponse::default_instance_;
  delete ResolveIntentResponse_reflection_;
  delete ResolveIntentRangeRequest::default_instance_;
  delete ResolveIntentRangeRequest_reflection_;
  delete NoopResponse::default_instance_;
  delete NoopResponse_reflection_;
  delete NoopRequest::default_instance_;
  delete NoopRequest_reflection_;
  delete ResolveIntentRangeResponse::default_instance_;
  delete ResolveIntentRangeResponse_reflection_;
  delete MergeRequest::default_instance_;
  delete MergeRequest_reflection_;
  delete MergeResponse::default_instance_;
  delete MergeResponse_reflection_;
  delete TruncateLogRequest::default_instance_;
  delete TruncateLogRequest_reflection_;
  delete TruncateLogResponse::default_instance_;
  delete TruncateLogResponse_reflection_;
  delete LeaderLeaseRequest::default_instance_;
  delete LeaderLeaseRequest_reflection_;
  delete LeaderLeaseResponse::default_instance_;
  delete LeaderLeaseResponse_reflection_;
  delete RequestUnion::default_instance_;
  delete RequestUnion_reflection_;
  delete ResponseUnion::default_instance_;
  delete ResponseUnion_reflection_;
  delete BatchRequest::default_instance_;
  delete BatchRequest_reflection_;
  delete BatchResponse::default_instance_;
  delete BatchResponse_reflection_;
}

void protobuf_AddDesc_cockroach_2fproto_2fapi_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  ::cockroach::proto::protobuf_AddDesc_cockroach_2fproto_2fmetadata_2eproto();
  ::cockroach::proto::protobuf_AddDesc_cockroach_2fproto_2fdata_2eproto();
  ::cockroach::proto::protobuf_AddDesc_cockroach_2fproto_2ferrors_2eproto();
  ::gogoproto::protobuf_AddDesc_gogoproto_2fgogo_2eproto();
  ::google::protobuf::DescriptorPool::InternalAddGeneratedFile(
    "\n\031cockroach/proto/api.proto\022\017cockroach.p"
    "roto\032\036cockroach/proto/metadata.proto\032\032co"
    "ckroach/proto/data.proto\032\034cockroach/prot"
    "o/errors.proto\032\024gogoproto/gogo.proto\"<\n\013"
    "ClientCmdID\022\027\n\twall_time\030\001 \001(\003B\004\310\336\037\000\022\024\n\006"
    "random\030\002 \001(\003B\004\310\336\037\000\"\233\003\n\rRequestHeader\0223\n\t"
    "timestamp\030\001 \001(\0132\032.cockroach.proto.Timest"
    "ampB\004\310\336\037\000\022;\n\006cmd_id\030\002 \001(\0132\034.cockroach.pr"
    "oto.ClientCmdIDB\r\310\336\037\000\342\336\037\005CmdID\022\024\n\003key\030\003 "
    "\001(\014B\007\372\336\037\003Key\022\030\n\007end_key\030\004 \001(\014B\007\372\336\037\003Key\022/"
    "\n\007replica\030\005 \001(\0132\030.cockroach.proto.Replic"
    "aB\004\310\336\037\000\022,\n\010range_id\030\006 \001(\003B\032\310\336\037\000\342\336\037\007Range"
    "ID\372\336\037\007RangeID\022\030\n\ruser_priority\030\007 \001(\005:\0011\022"
    ")\n\003txn\030\010 \001(\0132\034.cockroach.proto.Transacti"
    "on\022D\n\020read_consistency\030\t \001(\0162$.cockroach"
    ".proto.ReadConsistencyTypeB\004\310\336\037\000\"\227\001\n\016Res"
    "ponseHeader\022%\n\005error\030\001 \001(\0132\026.cockroach.p"
    "roto.Error\0223\n\ttimestamp\030\002 \001(\0132\032.cockroac"
    "h.proto.TimestampB\004\310\336\037\000\022)\n\003txn\030\003 \001(\0132\034.c"
    "ockroach.proto.Transaction\"F\n\nGetRequest"
    "\0228\n\006header\030\001 \001(\0132\036.cockroach.proto.Reque"
    "stHeaderB\010\310\336\037\000\320\336\037\001\"o\n\013GetResponse\0229\n\006hea"
    "der\030\001 \001(\0132\037.cockroach.proto.ResponseHead"
    "erB\010\310\336\037\000\320\336\037\001\022%\n\005value\030\002 \001(\0132\026.cockroach."
    "proto.Value\"s\n\nPutRequest\0228\n\006header\030\001 \001("
    "\0132\036.cockroach.proto.RequestHeaderB\010\310\336\037\000\320"
    "\336\037\001\022+\n\005value\030\002 \001(\0132\026.cockroach.proto.Val"
    "ueB\004\310\336\037\000\"H\n\013PutResponse\0229\n\006header\030\001 \001(\0132"
    "\037.cockroach.proto.ResponseHeaderB\010\310\336\037\000\320\336"
    "\037\001\"\251\001\n\025ConditionalPutRequest\0228\n\006header\030\001"
    " \001(\0132\036.cockroach.proto.RequestHeaderB\010\310\336"
    "\037\000\320\336\037\001\022+\n\005value\030\002 \001(\0132\026.cockroach.proto."
    "ValueB\004\310\336\037\000\022)\n\texp_value\030\003 \001(\0132\026.cockroa"
    "ch.proto.Value\"S\n\026ConditionalPutResponse"
    "\0229\n\006header\030\001 \001(\0132\037.cockroach.proto.Respo"
    "nseHeaderB\010\310\336\037\000\320\336\037\001\"e\n\020IncrementRequest\022"
    "8\n\006header\030\001 \001(\0132\036.cockroach.proto.Reques"
    "tHeaderB\010\310\336\037\000\320\336\037\001\022\027\n\tincrement\030\002 \001(\003B\004\310\336"
    "\037\000\"g\n\021IncrementResponse\0229\n\006header\030\001 \001(\0132"
    "\037.cockroach.proto.ResponseHeaderB\010\310\336\037\000\320\336"
    "\037\001\022\027\n\tnew_value\030\002 \001(\003B\004\310\336\037\000\"I\n\rDeleteReq"
    "uest\0228\n\006header\030\001 \001(\0132\036.cockroach.proto.R"
    "equestHeaderB\010\310\336\037\000\320\336\037\001\"K\n\016DeleteResponse"
    "\0229\n\006header\030\001 \001(\0132\037.cockroach.proto.Respo"
    "nseHeaderB\010\310\336\037\000\320\336\037\001\"s\n\022DeleteRangeReques"
    "t\0228\n\006header\030\001 \001(\0132\036.cockroach.proto.Requ"
    "estHeaderB\010\310\336\037\000\320\336\037\001\022#\n\025max_entries_to_de"
    "lete\030\002 \001(\003B\004\310\336\037\000\"k\n\023DeleteRangeResponse\022"
    "9\n\006header\030\001 \001(\0132\037.cockroach.proto.Respon"
    "seHeaderB\010\310\336\037\000\320\336\037\001\022\031\n\013num_deleted\030\002 \001(\003B"
    "\004\310\336\037\000\"b\n\013ScanRequest\0228\n\006header\030\001 \001(\0132\036.c"
    "ockroach.proto.RequestHeaderB\010\310\336\037\000\320\336\037\001\022\031"
    "\n\013max_results\030\002 \001(\003B\004\310\336\037\000\"x\n\014ScanRespons"
    "e\0229\n\006header\030\001 \001(\0132\037.cockroach.proto.Resp"
    "onseHeaderB\010\310\336\037\000\320\336\037\001\022-\n\004rows\030\002 \003(\0132\031.coc"
    "kroach.proto.KeyValueB\004\310\336\037\000\"i\n\022ReverseSc"
    "anRequest\0228\n\006header\030\001 \001(\0132\036.cockroach.pr"
    "oto.RequestHeaderB\010\310\336\037\000\320\336\037\001\022\031\n\013max_resul"
    "ts\030\002 \001(\003B\004\310\336\037\000\"\177\n\023ReverseScanResponse\0229\n"
    "\006header\030\001 \001(\0132\037.cockroach.proto.Response"
    "HeaderB\010\310\336\037\000\320\336\037\001\022-\n\004rows\030\002 \003(\0132\031.cockroa"
    "ch.proto.KeyValueB\004\310\336\037\000\"\340\001\n\025EndTransacti"
    "onRequest\0228\n\006header\030\001 \001(\0132\036.cockroach.pr"
    "oto.RequestHeaderB\010\310\336\037\000\320\336\037\001\022\024\n\006commit\030\002 "
    "\001(\010B\004\310\336\037\000\022G\n\027internal_commit_trigger\030\003 \001"
    "(\0132&.cockroach.proto.InternalCommitTrigg"
    "er\022.\n\007intents\030\004 \003(\0132\027.cockroach.proto.In"
    "tentB\004\310\336\037\000\"\211\001\n\026EndTransactionResponse\0229\n"
    "\006header\030\001 \001(\0132\037.cockroach.proto.Response"
    "HeaderB\010\310\336\037\000\320\336\037\001\022\031\n\013commit_wait\030\002 \001(\003B\004\310"
    "\336\037\000\022\031\n\010resolved\030\003 \003(\014B\007\372\336\037\003Key\"i\n\021AdminS"
    "plitRequest\0228\n\006header\030\001 \001(\0132\036.cockroach."
    "proto.RequestHeaderB\010\310\336\037\000\320\336\037\001\022\032\n\tsplit_k"
    "ey\030\002 \001(\014B\007\372\336\037\003Key\"O\n\022AdminSplitResponse\022"
    "9\n\006header\030\001 \001(\0132\037.cockroach.proto.Respon"
    "seHeaderB\010\310\336\037\000\320\336\037\001\"M\n\021AdminMergeRequest\022"
    "8\n\006header\030\001 \001(\0132\036.cockroach.proto.Reques"
    "tHeaderB\010\310\336\037\000\320\336\037\001\"O\n\022AdminMergeResponse\022"
    "9\n\006header\030\001 \001(\0132\037.cockroach.proto.Respon"
    "seHeaderB\010\310\336\037\000\320\336\037\001\"\237\001\n\022RangeLookupReques"
    "t\0228\n\006header\030\001 \001(\0132\036.cockroach.proto.Requ"
    "estHeaderB\010\310\336\037\000\320\336\037\001\022\030\n\nmax_ranges\030\002 \001(\005B"
    "\004\310\336\037\000\022\036\n\020consider_intents\030\003 \001(\010B\004\310\336\037\000\022\025\n"
    "\007reverse\030\004 \001(\010B\004\310\336\037\000\"\210\001\n\023RangeLookupResp"
    "onse\0229\n\006header\030\001 \001(\0132\037.cockroach.proto.R"
    "esponseHeaderB\010\310\336\037\000\320\336\037\001\0226\n\006ranges\030\002 \003(\0132"
    " .cockroach.proto.RangeDescriptorB\004\310\336\037\000\""
    "O\n\023HeartbeatTxnRequest\0228\n\006header\030\001 \001(\0132\036"
    ".cockroach.proto.RequestHeaderB\010\310\336\037\000\320\336\037\001"
    "\"Q\n\024HeartbeatTxnResponse\0229\n\006header\030\001 \001(\013"
    "2\037.cockroach.proto.ResponseHeaderB\010\310\336\037\000\320"
    "\336\037\001\"\215\002\n\tGCRequest\0228\n\006header\030\001 \001(\0132\036.cock"
    "roach.proto.RequestHeaderB\010\310\336\037\000\320\336\037\001\022<\n\007g"
    "c_meta\030\002 \001(\0132\033.cockroach.proto.GCMetadat"
    "aB\016\310\336\037\000\342\336\037\006GCMeta\0224\n\004keys\030\003 \003(\0132 .cockro"
    "ach.proto.GCRequest.GCKeyB\004\310\336\037\000\032R\n\005GCKey"
    "\022\024\n\003key\030\001 \001(\014B\007\372\336\037\003Key\0223\n\ttimestamp\030\002 \001("
    "\0132\032.cockroach.proto.TimestampB\004\310\336\037\000\"G\n\nG"
    "CResponse\0229\n\006header\030\001 \001(\0132\037.cockroach.pr"
    "oto.ResponseHeaderB\010\310\336\037\000\320\336\037\001\"\232\002\n\016PushTxn"
    "Request\0228\n\006header\030\001 \001(\0132\036.cockroach.prot"
    "o.RequestHeaderB\010\310\336\037\000\320\336\037\001\0220\n\npusher_txn\030"
    "\002 \001(\0132\034.cockroach.proto.Transaction\0226\n\np"
    "ushee_txn\030\003 \001(\0132\034.cockroach.proto.Transa"
    "ctionB\004\310\336\037\000\022-\n\003now\030\004 \001(\0132\032.cockroach.pro"
    "to.TimestampB\004\310\336\037\000\0225\n\tpush_type\030\005 \001(\0162\034."
    "cockroach.proto.PushTxnTypeB\004\310\336\037\000\"~\n\017Pus"
    "hTxnResponse\0229\n\006header\030\001 \001(\0132\037.cockroach"
    ".proto.ResponseHeaderB\010\310\336\037\000\320\336\037\001\0220\n\npushe"
    "e_txn\030\002 \001(\0132\034.cockroach.proto.Transactio"
    "n\"\210\001\n\024ResolveIntentRequest\0228\n\006header\030\001 \001"
    "(\0132\036.cockroach.proto.RequestHeaderB\010\310\336\037\000"
    "\320\336\037\001\0226\n\nintent_txn\030\002 \001(\0132\034.cockroach.pro"
    "to.TransactionB\004\310\336\037\000\"R\n\025ResolveIntentRes"
    "ponse\0229\n\006header\030\001 \001(\0132\037.cockroach.proto."
    "ResponseHeaderB\010\310\336\037\000\320\336\037\001\"\215\001\n\031ResolveInte"
    "ntRangeRequest\0228\n\006header\030\001 \001(\0132\036.cockroa"
    "ch.proto.RequestHeaderB\010\310\336\037\000\320\336\037\001\0226\n\ninte"
    "nt_txn\030\002 \001(\0132\034.cockroach.proto.Transacti"
    "onB\004\310\336\037\000\"I\n\014NoopResponse\0229\n\006header\030\001 \001(\013"
    "2\037.cockroach.proto.ResponseHeaderB\010\310\336\037\000\320"
    "\336\037\001\"G\n\013NoopRequest\0228\n\006header\030\001 \001(\0132\036.coc"
    "kroach.proto.RequestHeaderB\010\310\336\037\000\320\336\037\001\"W\n\032"
    "ResolveIntentRangeResponse\0229\n\006header\030\001 \001"
    "(\0132\037.cockroach.proto.ResponseHeaderB\010\310\336\037"
    "\000\320\336\037\001\"u\n\014MergeRequest\0228\n\006header\030\001 \001(\0132\036."
    "cockroach.proto.RequestHeaderB\010\310\336\037\000\320\336\037\001\022"
    "+\n\005value\030\002 \001(\0132\026.cockroach.proto.ValueB\004"
    "\310\336\037\000\"J\n\rMergeResponse\0229\n\006header\030\001 \001(\0132\037."
    "cockroach.proto.ResponseHeaderB\010\310\336\037\000\320\336\037\001"
    "\"c\n\022TruncateLogRequest\0228\n\006header\030\001 \001(\0132\036"
    ".cockroach.proto.RequestHeaderB\010\310\336\037\000\320\336\037\001"
    "\022\023\n\005index\030\002 \001(\004B\004\310\336\037\000\"P\n\023TruncateLogResp"
    "onse\0229\n\006header\030\001 \001(\0132\037.cockroach.proto.R"
    "esponseHeaderB\010\310\336\037\000\320\336\037\001\"{\n\022LeaderLeaseRe"
    "quest\0228\n\006header\030\001 \001(\0132\036.cockroach.proto."
    "RequestHeaderB\010\310\336\037\000\320\336\037\001\022+\n\005lease\030\002 \001(\0132\026"
    ".cockroach.proto.LeaseB\004\310\336\037\000\"P\n\023LeaderLe"
    "aseResponse\0229\n\006header\030\001 \001(\0132\037.cockroach."
    "proto.ResponseHeaderB\010\310\336\037\000\320\336\037\001\"\220\t\n\014Reque"
    "stUnion\022(\n\003get\030\001 \001(\0132\033.cockroach.proto.G"
    "etRequest\022(\n\003put\030\002 \001(\0132\033.cockroach.proto"
    ".PutRequest\022\?\n\017conditional_put\030\003 \001(\0132&.c"
    "ockroach.proto.ConditionalPutRequest\0224\n\t"
    "increment\030\004 \001(\0132!.cockroach.proto.Increm"
    "entRequest\022.\n\006delete\030\005 \001(\0132\036.cockroach.p"
    "roto.DeleteRequest\0229\n\014delete_range\030\006 \001(\013"
    "2#.cockroach.proto.DeleteRangeRequest\022*\n"
    "\004scan\030\007 \001(\0132\034.cockroach.proto.ScanReques"
    "t\022\?\n\017end_transaction\030\010 \001(\0132&.cockroach.p"
    "roto.EndTransactionRequest\0227\n\013admin_spli"
    "t\030\t \001(\0132\".cockroach.proto.AdminSplitRequ"
    "est\0227\n\013admin_merge\030\n \001(\0132\".cockroach.pro"
    "to.AdminMergeRequest\022;\n\rheartbeat_txn\030\013 "
    "\001(\0132$.cockroach.proto.HeartbeatTxnReques"
    "t\022&\n\002gc\030\014 \001(\0132\032.cockroach.proto.GCReques"
    "t\0221\n\010push_txn\030\r \001(\0132\037.cockroach.proto.Pu"
    "shTxnRequest\0229\n\014range_lookup\030\016 \001(\0132#.coc"
    "kroach.proto.RangeLookupRequest\022=\n\016resol"
    "ve_intent\030\017 \001(\0132%.cockroach.proto.Resolv"
    "eIntentRequest\022H\n\024resolve_intent_range\030\020"
    " \001(\0132*.cockroach.proto.ResolveIntentRang"
    "eRequest\022,\n\005merge\030\021 \001(\0132\035.cockroach.prot"
    "o.MergeRequest\0229\n\014truncate_log\030\022 \001(\0132#.c"
    "ockroach.proto.TruncateLogRequest\0229\n\014lea"
    "der_lease\030\023 \001(\0132#.cockroach.proto.Leader"
    "LeaseRequest\0229\n\014reverse_scan\030\024 \001(\0132#.coc"
    "kroach.proto.ReverseScanRequest\022*\n\004noop\030"
    "\025 \001(\0132\034.cockroach.proto.NoopRequest:\004\310\240\037"
    "\001\"\246\t\n\rResponseUnion\022)\n\003get\030\001 \001(\0132\034.cockr"
    "oach.proto.GetResponse\022)\n\003put\030\002 \001(\0132\034.co"
    "ckroach.proto.PutResponse\022@\n\017conditional"
    "_put\030\003 \001(\0132\'.cockroach.proto.Conditional"
    "PutResponse\0225\n\tincrement\030\004 \001(\0132\".cockroa"
    "ch.proto.IncrementResponse\022/\n\006delete\030\005 \001"
    "(\0132\037.cockroach.proto.DeleteResponse\022:\n\014d"
    "elete_range\030\006 \001(\0132$.cockroach.proto.Dele"
    "teRangeResponse\022+\n\004scan\030\007 \001(\0132\035.cockroac"
    "h.proto.ScanResponse\022@\n\017end_transaction\030"
    "\010 \001(\0132\'.cockroach.proto.EndTransactionRe"
    "sponse\0228\n\013admin_split\030\t \001(\0132#.cockroach."
    "proto.AdminSplitResponse\0228\n\013admin_merge\030"
    "\n \001(\0132#.cockroach.proto.AdminMergeRespon"
    "se\022<\n\rheartbeat_txn\030\013 \001(\0132%.cockroach.pr"
    "oto.HeartbeatTxnResponse\022\'\n\002gc\030\014 \001(\0132\033.c"
    "ockroach.proto.GCResponse\0222\n\010push_txn\030\r "
    "\001(\0132 .cockroach.proto.PushTxnResponse\022:\n"
    "\014range_lookup\030\016 \001(\0132$.cockroach.proto.Ra"
    "ngeLookupResponse\022>\n\016resolve_intent\030\017 \001("
    "\0132&.cockroach.proto.ResolveIntentRespons"
    "e\022I\n\024resolve_intent_range\030\020 \001(\0132+.cockro"
    "ach.proto.ResolveIntentRangeResponse\022-\n\005"
    "merge\030\021 \001(\0132\036.cockroach.proto.MergeRespo"
    "nse\022:\n\014truncate_log\030\022 \001(\0132$.cockroach.pr"
    "oto.TruncateLogResponse\022:\n\014leader_lease\030"
    "\023 \001(\0132$.cockroach.proto.LeaderLeaseRespo"
    "nse\022:\n\014reverse_scan\030\024 \001(\0132$.cockroach.pr"
    "oto.ReverseScanResponse\022+\n\004noop\030\025 \001(\0132\035."
    "cockroach.proto.NoopResponse:\004\310\240\037\001\"\205\001\n\014B"
    "atchRequest\0228\n\006header\030\001 \001(\0132\036.cockroach."
    "proto.RequestHeaderB\010\310\336\037\000\320\336\037\001\0225\n\010request"
    "s\030\002 \003(\0132\035.cockroach.proto.RequestUnionB\004"
    "\310\336\037\000:\004\230\240\037\000\"\203\001\n\rBatchResponse\0229\n\006header\030\001"
    " \001(\0132\037.cockroach.proto.ResponseHeaderB\010\310"
    "\336\037\000\320\336\037\001\0227\n\tresponses\030\002 \003(\0132\036.cockroach.p"
    "roto.ResponseUnionB\004\310\336\037\000*L\n\023ReadConsiste"
    "ncyType\022\016\n\nCONSISTENT\020\000\022\r\n\tCONSENSUS\020\001\022\020"
    "\n\014INCONSISTENT\020\002\032\004\210\243\036\000*G\n\013PushTxnType\022\022\n"
    "\016PUSH_TIMESTAMP\020\000\022\r\n\tABORT_TXN\020\001\022\017\n\013CLEA"
    "NUP_TXN\020\002\032\004\210\243\036\000B\027Z\005proto\340\342\036\001\310\342\036\001\320\342\036\001\220\343\036\000", 8400);
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedFile(
    "cockroach/proto/api.proto", &protobuf_RegisterTypes);
  ClientCmdID::default_instance_ = new ClientCmdID();
  RequestHeader::default_instance_ = new RequestHeader();
  ResponseHeader::default_instance_ = new ResponseHeader();
  GetRequest::default_instance_ = new GetRequest();
  GetResponse::default_instance_ = new GetResponse();
  PutRequest::default_instance_ = new PutRequest();
  PutResponse::default_instance_ = new PutResponse();
  ConditionalPutRequest::default_instance_ = new ConditionalPutRequest();
  ConditionalPutResponse::default_instance_ = new ConditionalPutResponse();
  IncrementRequest::default_instance_ = new IncrementRequest();
  IncrementResponse::default_instance_ = new IncrementResponse();
  DeleteRequest::default_instance_ = new DeleteRequest();
  DeleteResponse::default_instance_ = new DeleteResponse();
  DeleteRangeRequest::default_instance_ = new DeleteRangeRequest();
  DeleteRangeResponse::default_instance_ = new DeleteRangeResponse();
  ScanRequest::default_instance_ = new ScanRequest();
  ScanResponse::default_instance_ = new ScanResponse();
  ReverseScanRequest::default_instance_ = new ReverseScanRequest();
  ReverseScanResponse::default_instance_ = new ReverseScanResponse();
  EndTransactionRequest::default_instance_ = new EndTransactionRequest();
  EndTransactionResponse::default_instance_ = new EndTransactionResponse();
  AdminSplitRequest::default_instance_ = new AdminSplitRequest();
  AdminSplitResponse::default_instance_ = new AdminSplitResponse();
  AdminMergeRequest::default_instance_ = new AdminMergeRequest();
  AdminMergeResponse::default_instance_ = new AdminMergeResponse();
  RangeLookupRequest::default_instance_ = new RangeLookupRequest();
  RangeLookupResponse::default_instance_ = new RangeLookupResponse();
  HeartbeatTxnRequest::default_instance_ = new HeartbeatTxnRequest();
  HeartbeatTxnResponse::default_instance_ = new HeartbeatTxnResponse();
  GCRequest::default_instance_ = new GCRequest();
  GCRequest_GCKey::default_instance_ = new GCRequest_GCKey();
  GCResponse::default_instance_ = new GCResponse();
  PushTxnRequest::default_instance_ = new PushTxnRequest();
  PushTxnResponse::default_instance_ = new PushTxnResponse();
  ResolveIntentRequest::default_instance_ = new ResolveIntentRequest();
  ResolveIntentResponse::default_instance_ = new ResolveIntentResponse();
  ResolveIntentRangeRequest::default_instance_ = new ResolveIntentRangeRequest();
  NoopResponse::default_instance_ = new NoopResponse();
  NoopRequest::default_instance_ = new NoopRequest();
  ResolveIntentRangeResponse::default_instance_ = new ResolveIntentRangeResponse();
  MergeRequest::default_instance_ = new MergeRequest();
  MergeResponse::default_instance_ = new MergeResponse();
  TruncateLogRequest::default_instance_ = new TruncateLogRequest();
  TruncateLogResponse::default_instance_ = new TruncateLogResponse();
  LeaderLeaseRequest::default_instance_ = new LeaderLeaseRequest();
  LeaderLeaseResponse::default_instance_ = new LeaderLeaseResponse();
  RequestUnion::default_instance_ = new RequestUnion();
  ResponseUnion::default_instance_ = new ResponseUnion();
  BatchRequest::default_instance_ = new BatchRequest();
  BatchResponse::default_instance_ = new BatchResponse();
  ClientCmdID::default_instance_->InitAsDefaultInstance();
  RequestHeader::default_instance_->InitAsDefaultInstance();
  ResponseHeader::default_instance_->InitAsDefaultInstance();
  GetRequest::default_instance_->InitAsDefaultInstance();
  GetResponse::default_instance_->InitAsDefaultInstance();
  PutRequest::default_instance_->InitAsDefaultInstance();
  PutResponse::default_instance_->InitAsDefaultInstance();
  ConditionalPutRequest::default_instance_->InitAsDefaultInstance();
  ConditionalPutResponse::default_instance_->InitAsDefaultInstance();
  IncrementRequest::default_instance_->InitAsDefaultInstance();
  IncrementResponse::default_instance_->InitAsDefaultInstance();
  DeleteRequest::default_instance_->InitAsDefaultInstance();
  DeleteResponse::default_instance_->InitAsDefaultInstance();
  DeleteRangeRequest::default_instance_->InitAsDefaultInstance();
  DeleteRangeResponse::default_instance_->InitAsDefaultInstance();
  ScanRequest::default_instance_->InitAsDefaultInstance();
  ScanResponse::default_instance_->InitAsDefaultInstance();
  ReverseScanRequest::default_instance_->InitAsDefaultInstance();
  ReverseScanResponse::default_instance_->InitAsDefaultInstance();
  EndTransactionRequest::default_instance_->InitAsDefaultInstance();
  EndTransactionResponse::default_instance_->InitAsDefaultInstance();
  AdminSplitRequest::default_instance_->InitAsDefaultInstance();
  AdminSplitResponse::default_instance_->InitAsDefaultInstance();
  AdminMergeRequest::default_instance_->InitAsDefaultInstance();
  AdminMergeResponse::default_instance_->InitAsDefaultInstance();
  RangeLookupRequest::default_instance_->InitAsDefaultInstance();
  RangeLookupResponse::default_instance_->InitAsDefaultInstance();
  HeartbeatTxnRequest::default_instance_->InitAsDefaultInstance();
  HeartbeatTxnResponse::default_instance_->InitAsDefaultInstance();
  GCRequest::default_instance_->InitAsDefaultInstance();
  GCRequest_GCKey::default_instance_->InitAsDefaultInstance();
  GCResponse::default_instance_->InitAsDefaultInstance();
  PushTxnRequest::default_instance_->InitAsDefaultInstance();
  PushTxnResponse::default_instance_->InitAsDefaultInstance();
  ResolveIntentRequest::default_instance_->InitAsDefaultInstance();
  ResolveIntentResponse::default_instance_->InitAsDefaultInstance();
  ResolveIntentRangeRequest::default_instance_->InitAsDefaultInstance();
  NoopResponse::default_instance_->InitAsDefaultInstance();
  NoopRequest::default_instance_->InitAsDefaultInstance();
  ResolveIntentRangeResponse::default_instance_->InitAsDefaultInstance();
  MergeRequest::default_instance_->InitAsDefaultInstance();
  MergeResponse::default_instance_->InitAsDefaultInstance();
  TruncateLogRequest::default_instance_->InitAsDefaultInstance();
  TruncateLogResponse::default_instance_->InitAsDefaultInstance();
  LeaderLeaseRequest::default_instance_->InitAsDefaultInstance();
  LeaderLeaseResponse::default_instance_->InitAsDefaultInstance();
  RequestUnion::default_instance_->InitAsDefaultInstance();
  ResponseUnion::default_instance_->InitAsDefaultInstance();
  BatchRequest::default_instance_->InitAsDefaultInstance();
  BatchResponse::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_cockroach_2fproto_2fapi_2eproto);
}

// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_cockroach_2fproto_2fapi_2eproto {
  StaticDescriptorInitializer_cockroach_2fproto_2fapi_2eproto() {
    protobuf_AddDesc_cockroach_2fproto_2fapi_2eproto();
  }
} static_descriptor_initializer_cockroach_2fproto_2fapi_2eproto_;
const ::google::protobuf::EnumDescriptor* ReadConsistencyType_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ReadConsistencyType_descriptor_;
}
bool ReadConsistencyType_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

const ::google::protobuf::EnumDescriptor* PushTxnType_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return PushTxnType_descriptor_;
}
bool PushTxnType_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}


namespace {

static void MergeFromFail(int line) GOOGLE_ATTRIBUTE_COLD;
static void MergeFromFail(int line) {
  GOOGLE_CHECK(false) << __FILE__ << ":" << line;
}

}  // namespace


// ===================================================================

#ifndef _MSC_VER
const int ClientCmdID::kWallTimeFieldNumber;
const int ClientCmdID::kRandomFieldNumber;
#endif  // !_MSC_VER

ClientCmdID::ClientCmdID()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:cockroach.proto.ClientCmdID)
}

void ClientCmdID::InitAsDefaultInstance() {
}

ClientCmdID::ClientCmdID(const ClientCmdID& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:cockroach.proto.ClientCmdID)
}

void ClientCmdID::SharedCtor() {
  _cached_size_ = 0;
  wall_time_ = GOOGLE_LONGLONG(0);
  random_ = GOOGLE_LONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ClientCmdID::~ClientCmdID() {
  // @@protoc_insertion_point(destructor:cockroach.proto.ClientCmdID)
  SharedDtor();
}

void ClientCmdID::SharedDtor() {
  if (this != default_instance_) {
  }
}

void ClientCmdID::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ClientCmdID::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ClientCmdID_descriptor_;
}

const ClientCmdID& ClientCmdID::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_cockroach_2fproto_2fapi_2eproto();
  return *default_instance_;
}

ClientCmdID* ClientCmdID::default_instance_ = NULL;

ClientCmdID* ClientCmdID::New(::google::protobuf::Arena* arena) const {
  ClientCmdID* n = new ClientCmdID;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void ClientCmdID::Clear() {
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<ClientCmdID*>(16)->f)

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  ZR_(wall_time_, random_);

#undef ZR_HELPER_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool ClientCmdID::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:cockroach.proto.ClientCmdID)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int64 wall_time = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &wall_time_)));
          set_has_wall_time();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_random;
        break;
      }

      // optional int64 random = 2;
      case 2: {
        if (tag == 16) {
         parse_random:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &random_)));
          set_has_random();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:cockroach.proto.ClientCmdID)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:cockroach.proto.ClientCmdID)
  return false;
#undef DO_
}

void ClientCmdID::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:cockroach.proto.ClientCmdID)
  // optional int64 wall_time = 1;
  if (has_wall_time()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(1, this->wall_time(), output);
  }

  // optional int64 random = 2;
  if (has_random()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(2, this->random(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:cockroach.proto.ClientCmdID)
}

::google::protobuf::uint8* ClientCmdID::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:cockroach.proto.ClientCmdID)
  // optional int64 wall_time = 1;
  if (has_wall_time()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(1, this->wall_time(), target);
  }

  // optional int64 random = 2;
  if (has_random()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(2, this->random(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:cockroach.proto.ClientCmdID)
  return target;
}

int ClientCmdID::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & 3) {
    // optional int64 wall_time = 1;
    if (has_wall_time()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->wall_time());
    }

    // optional int64 random = 2;
    if (has_random()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->random());
    }

  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ClientCmdID::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const ClientCmdID* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const ClientCmdID>(
          &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ClientCmdID::MergeFrom(const ClientCmdID& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_wall_time()) {
      set_wall_time(from.wall_time());
    }
    if (from.has_random()) {
      set_random(from.random());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void ClientCmdID::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ClientCmdID::CopyFrom(const ClientCmdID& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ClientCmdID::IsInitialized() const {

  return true;
}

void ClientCmdID::Swap(ClientCmdID* other) {
  if (other == this) return;
  InternalSwap(other);
}
void ClientCmdID::InternalSwap(ClientCmdID* other) {
  std::swap(wall_time_, other->wall_time_);
  std::swap(random_, other->random_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata ClientCmdID::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ClientCmdID_descriptor_;
  metadata.reflection = ClientCmdID_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// ClientCmdID

// optional int64 wall_time = 1;
bool ClientCmdID::has_wall_time() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void ClientCmdID::set_has_wall_time() {
  _has_bits_[0] |= 0x00000001u;
}
void ClientCmdID::clear_has_wall_time() {
  _has_bits_[0] &= ~0x00000001u;
}
void ClientCmdID::clear_wall_time() {
  wall_time_ = GOOGLE_LONGLONG(0);
  clear_has_wall_time();
}
 ::google::protobuf::int64 ClientCmdID::wall_time() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.ClientCmdID.wall_time)
  return wall_time_;
}
 void ClientCmdID::set_wall_time(::google::protobuf::int64 value) {
  set_has_wall_time();
  wall_time_ = value;
  // @@protoc_insertion_point(field_set:cockroach.proto.ClientCmdID.wall_time)
}

// optional int64 random = 2;
bool ClientCmdID::has_random() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void ClientCmdID::set_has_random() {
  _has_bits_[0] |= 0x00000002u;
}
void ClientCmdID::clear_has_random() {
  _has_bits_[0] &= ~0x00000002u;
}
void ClientCmdID::clear_random() {
  random_ = GOOGLE_LONGLONG(0);
  clear_has_random();
}
 ::google::protobuf::int64 ClientCmdID::random() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.ClientCmdID.random)
  return random_;
}
 void ClientCmdID::set_random(::google::protobuf::int64 value) {
  set_has_random();
  random_ = value;
  // @@protoc_insertion_point(field_set:cockroach.proto.ClientCmdID.random)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#ifndef _MSC_VER
const int RequestHeader::kTimestampFieldNumber;
const int RequestHeader::kCmdIdFieldNumber;
const int RequestHeader::kKeyFieldNumber;
const int RequestHeader::kEndKeyFieldNumber;
const int RequestHeader::kReplicaFieldNumber;
const int RequestHeader::kRangeIdFieldNumber;
const int RequestHeader::kUserPriorityFieldNumber;
const int RequestHeader::kTxnFieldNumber;
const int RequestHeader::kReadConsistencyFieldNumber;
#endif  // !_MSC_VER

RequestHeader::RequestHeader()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:cockroach.proto.RequestHeader)
}

void RequestHeader::InitAsDefaultInstance() {
  timestamp_ = const_cast< ::cockroach::proto::Timestamp*>(&::cockroach::proto::Timestamp::default_instance());
  cmd_id_ = const_cast< ::cockroach::proto::ClientCmdID*>(&::cockroach::proto::ClientCmdID::default_instance());
  replica_ = const_cast< ::cockroach::proto::Replica*>(&::cockroach::proto::Replica::default_instance());
  txn_ = const_cast< ::cockroach::proto::Transaction*>(&::cockroach::proto::Transaction::default_instance());
}

RequestHeader::RequestHeader(const RequestHeader& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:cockroach.proto.RequestHeader)
}

void RequestHeader::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  timestamp_ = NULL;
  cmd_id_ = NULL;
  key_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  end_key_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  replica_ = NULL;
  range_id_ = GOOGLE_LONGLONG(0);
  user_priority_ = 1;
  txn_ = NULL;
  read_consistency_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RequestHeader::~RequestHeader() {
  // @@protoc_insertion_point(destructor:cockroach.proto.RequestHeader)
  SharedDtor();
}

void RequestHeader::SharedDtor() {
  key_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  end_key_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != default_instance_) {
    delete timestamp_;
    delete cmd_id_;
    delete replica_;
    delete txn_;
  }
}

void RequestHeader::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* RequestHeader::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return RequestHeader_descriptor_;
}

const RequestHeader& RequestHeader::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_cockroach_2fproto_2fapi_2eproto();
  return *default_instance_;
}

RequestHeader* RequestHeader::default_instance_ = NULL;

RequestHeader* RequestHeader::New(::google::protobuf::Arena* arena) const {
  RequestHeader* n = new RequestHeader;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void RequestHeader::Clear() {
  if (_has_bits_[0 / 32] & 255u) {
    if (has_timestamp()) {
      if (timestamp_ != NULL) timestamp_->::cockroach::proto::Timestamp::Clear();
    }
    if (has_cmd_id()) {
      if (cmd_id_ != NULL) cmd_id_->::cockroach::proto::ClientCmdID::Clear();
    }
    if (has_key()) {
      key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    if (has_end_key()) {
      end_key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    if (has_replica()) {
      if (replica_ != NULL) replica_->::cockroach::proto::Replica::Clear();
    }
    range_id_ = GOOGLE_LONGLONG(0);
    user_priority_ = 1;
    if (has_txn()) {
      if (txn_ != NULL) txn_->::cockroach::proto::Transaction::Clear();
    }
  }
  read_consistency_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool RequestHeader::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:cockroach.proto.RequestHeader)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .cockroach.proto.Timestamp timestamp = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_timestamp()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_cmd_id;
        break;
      }

      // optional .cockroach.proto.ClientCmdID cmd_id = 2;
      case 2: {
        if (tag == 18) {
         parse_cmd_id:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_cmd_id()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_key;
        break;
      }

      // optional bytes key = 3;
      case 3: {
        if (tag == 26) {
         parse_key:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_key()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_end_key;
        break;
      }

      // optional bytes end_key = 4;
      case 4: {
        if (tag == 34) {
         parse_end_key:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_end_key()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_replica;
        break;
      }

      // optional .cockroach.proto.Replica replica = 5;
      case 5: {
        if (tag == 42) {
         parse_replica:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_replica()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(48)) goto parse_range_id;
        break;
      }

      // optional int64 range_id = 6;
      case 6: {
        if (tag == 48) {
         parse_range_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &range_id_)));
          set_has_range_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(56)) goto parse_user_priority;
        break;
      }

      // optional int32 user_priority = 7 [default = 1];
      case 7: {
        if (tag == 56) {
         parse_user_priority:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &user_priority_)));
          set_has_user_priority();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(66)) goto parse_txn;
        break;
      }

      // optional .cockroach.proto.Transaction txn = 8;
      case 8: {
        if (tag == 66) {
         parse_txn:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_txn()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(72)) goto parse_read_consistency;
        break;
      }

      // optional .cockroach.proto.ReadConsistencyType read_consistency = 9;
      case 9: {
        if (tag == 72) {
         parse_read_consistency:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::cockroach::proto::ReadConsistencyType_IsValid(value)) {
            set_read_consistency(static_cast< ::cockroach::proto::ReadConsistencyType >(value));
          } else {
            mutable_unknown_fields()->AddVarint(9, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:cockroach.proto.RequestHeader)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:cockroach.proto.RequestHeader)
  return false;
#undef DO_
}

void RequestHeader::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:cockroach.proto.RequestHeader)
  // optional .cockroach.proto.Timestamp timestamp = 1;
  if (has_timestamp()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->timestamp_, output);
  }

  // optional .cockroach.proto.ClientCmdID cmd_id = 2;
  if (has_cmd_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, *this->cmd_id_, output);
  }

  // optional bytes key = 3;
  if (has_key()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      3, this->key(), output);
  }

  // optional bytes end_key = 4;
  if (has_end_key()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      4, this->end_key(), output);
  }

  // optional .cockroach.proto.Replica replica = 5;
  if (has_replica()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      5, *this->replica_, output);
  }

  // optional int64 range_id = 6;
  if (has_range_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(6, this->range_id(), output);
  }

  // optional int32 user_priority = 7 [default = 1];
  if (has_user_priority()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(7, this->user_priority(), output);
  }

  // optional .cockroach.proto.Transaction txn = 8;
  if (has_txn()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      8, *this->txn_, output);
  }

  // optional .cockroach.proto.ReadConsistencyType read_consistency = 9;
  if (has_read_consistency()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      9, this->read_consistency(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:cockroach.proto.RequestHeader)
}

::google::protobuf::uint8* RequestHeader::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:cockroach.proto.RequestHeader)
  // optional .cockroach.proto.Timestamp timestamp = 1;
  if (has_timestamp()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, *this->timestamp_, target);
  }

  // optional .cockroach.proto.ClientCmdID cmd_id = 2;
  if (has_cmd_id()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, *this->cmd_id_, target);
  }

  // optional bytes key = 3;
  if (has_key()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        3, this->key(), target);
  }

  // optional bytes end_key = 4;
  if (has_end_key()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        4, this->end_key(), target);
  }

  // optional .cockroach.proto.Replica replica = 5;
  if (has_replica()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        5, *this->replica_, target);
  }

  // optional int64 range_id = 6;
  if (has_range_id()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(6, this->range_id(), target);
  }

  // optional int32 user_priority = 7 [default = 1];
  if (has_user_priority()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(7, this->user_priority(), target);
  }

  // optional .cockroach.proto.Transaction txn = 8;
  if (has_txn()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        8, *this->txn_, target);
  }

  // optional .cockroach.proto.ReadConsistencyType read_consistency = 9;
  if (has_read_consistency()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      9, this->read_consistency(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:cockroach.proto.RequestHeader)
  return target;
}

int RequestHeader::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & 255) {
    // optional .cockroach.proto.Timestamp timestamp = 1;
    if (has_timestamp()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->timestamp_);
    }

    // optional .cockroach.proto.ClientCmdID cmd_id = 2;
    if (has_cmd_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->cmd_id_);
    }

    // optional bytes key = 3;
    if (has_key()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->key());
    }

    // optional bytes end_key = 4;
    if (has_end_key()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->end_key());
    }

    // optional .cockroach.proto.Replica replica = 5;
    if (has_replica()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->replica_);
    }

    // optional int64 range_id = 6;
    if (has_range_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->range_id());
    }

    // optional int32 user_priority = 7 [default = 1];
    if (has_user_priority()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->user_priority());
    }

    // optional .cockroach.proto.Transaction txn = 8;
    if (has_txn()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->txn_);
    }

  }
  // optional .cockroach.proto.ReadConsistencyType read_consistency = 9;
  if (has_read_consistency()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->read_consistency());
  }

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RequestHeader::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const RequestHeader* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const RequestHeader>(
          &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void RequestHeader::MergeFrom(const RequestHeader& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_timestamp()) {
      mutable_timestamp()->::cockroach::proto::Timestamp::MergeFrom(from.timestamp());
    }
    if (from.has_cmd_id()) {
      mutable_cmd_id()->::cockroach::proto::ClientCmdID::MergeFrom(from.cmd_id());
    }
    if (from.has_key()) {
      set_has_key();
      key_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.key_);
    }
    if (from.has_end_key()) {
      set_has_end_key();
      end_key_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.end_key_);
    }
    if (from.has_replica()) {
      mutable_replica()->::cockroach::proto::Replica::MergeFrom(from.replica());
    }
    if (from.has_range_id()) {
      set_range_id(from.range_id());
    }
    if (from.has_user_priority()) {
      set_user_priority(from.user_priority());
    }
    if (from.has_txn()) {
      mutable_txn()->::cockroach::proto::Transaction::MergeFrom(from.txn());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_read_consistency()) {
      set_read_consistency(from.read_consistency());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void RequestHeader::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void RequestHeader::CopyFrom(const RequestHeader& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RequestHeader::IsInitialized() const {

  return true;
}

void RequestHeader::Swap(RequestHeader* other) {
  if (other == this) return;
  InternalSwap(other);
}
void RequestHeader::InternalSwap(RequestHeader* other) {
  std::swap(timestamp_, other->timestamp_);
  std::swap(cmd_id_, other->cmd_id_);
  key_.Swap(&other->key_);
  end_key_.Swap(&other->end_key_);
  std::swap(replica_, other->replica_);
  std::swap(range_id_, other->range_id_);
  std::swap(user_priority_, other->user_priority_);
  std::swap(txn_, other->txn_);
  std::swap(read_consistency_, other->read_consistency_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata RequestHeader::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = RequestHeader_descriptor_;
  metadata.reflection = RequestHeader_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// RequestHeader

// optional .cockroach.proto.Timestamp timestamp = 1;
bool RequestHeader::has_timestamp() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void RequestHeader::set_has_timestamp() {
  _has_bits_[0] |= 0x00000001u;
}
void RequestHeader::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000001u;
}
void RequestHeader::clear_timestamp() {
  if (timestamp_ != NULL) timestamp_->::cockroach::proto::Timestamp::Clear();
  clear_has_timestamp();
}
 const ::cockroach::proto::Timestamp& RequestHeader::timestamp() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.RequestHeader.timestamp)
  return timestamp_ != NULL ? *timestamp_ : *default_instance_->timestamp_;
}
 ::cockroach::proto::Timestamp* RequestHeader::mutable_timestamp() {
  set_has_timestamp();
  if (timestamp_ == NULL) {
    timestamp_ = new ::cockroach::proto::Timestamp;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.proto.RequestHeader.timestamp)
  return timestamp_;
}
 ::cockroach::proto::Timestamp* RequestHeader::release_timestamp() {
  clear_has_timestamp();
  ::cockroach::proto::Timestamp* temp = timestamp_;
  timestamp_ = NULL;
  return temp;
}
 void RequestHeader::set_allocated_timestamp(::cockroach::proto::Timestamp* timestamp) {
  delete timestamp_;
  timestamp_ = timestamp;
  if (timestamp) {
    set_has_timestamp();
  } else {
    clear_has_timestamp();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.RequestHeader.timestamp)
}

// optional .cockroach.proto.ClientCmdID cmd_id = 2;
bool RequestHeader::has_cmd_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void RequestHeader::set_has_cmd_id() {
  _has_bits_[0] |= 0x00000002u;
}
void RequestHeader::clear_has_cmd_id() {
  _has_bits_[0] &= ~0x00000002u;
}
void RequestHeader::clear_cmd_id() {
  if (cmd_id_ != NULL) cmd_id_->::cockroach::proto::ClientCmdID::Clear();
  clear_has_cmd_id();
}
 const ::cockroach::proto::ClientCmdID& RequestHeader::cmd_id() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.RequestHeader.cmd_id)
  return cmd_id_ != NULL ? *cmd_id_ : *default_instance_->cmd_id_;
}
 ::cockroach::proto::ClientCmdID* RequestHeader::mutable_cmd_id() {
  set_has_cmd_id();
  if (cmd_id_ == NULL) {
    cmd_id_ = new ::cockroach::proto::ClientCmdID;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.proto.RequestHeader.cmd_id)
  return cmd_id_;
}
 ::cockroach::proto::ClientCmdID* RequestHeader::release_cmd_id() {
  clear_has_cmd_id();
  ::cockroach::proto::ClientCmdID* temp = cmd_id_;
  cmd_id_ = NULL;
  return temp;
}
 void RequestHeader::set_allocated_cmd_id(::cockroach::proto::ClientCmdID* cmd_id) {
  delete cmd_id_;
  cmd_id_ = cmd_id;
  if (cmd_id) {
    set_has_cmd_id();
  } else {
    clear_has_cmd_id();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.RequestHeader.cmd_id)
}

// optional bytes key = 3;
bool RequestHeader::has_key() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void RequestHeader::set_has_key() {
  _has_bits_[0] |= 0x00000004u;
}
void RequestHeader::clear_has_key() {
  _has_bits_[0] &= ~0x00000004u;
}
void RequestHeader::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_key();
}
 const ::std::string& RequestHeader::key() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.RequestHeader.key)
  return key_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void RequestHeader::set_key(const ::std::string& value) {
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cockroach.proto.RequestHeader.key)
}
 void RequestHeader::set_key(const char* value) {
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cockroach.proto.RequestHeader.key)
}
 void RequestHeader::set_key(const void* value, size_t size) {
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cockroach.proto.RequestHeader.key)
}
 ::std::string* RequestHeader::mutable_key() {
  set_has_key();
  // @@protoc_insertion_point(field_mutable:cockroach.proto.RequestHeader.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* RequestHeader::release_key() {
  clear_has_key();
  return key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void RequestHeader::set_allocated_key(::std::string* key) {
  if (key != NULL) {
    set_has_key();
  } else {
    clear_has_key();
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.RequestHeader.key)
}

// optional bytes end_key = 4;
bool RequestHeader::has_end_key() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void RequestHeader::set_has_end_key() {
  _has_bits_[0] |= 0x00000008u;
}
void RequestHeader::clear_has_end_key() {
  _has_bits_[0] &= ~0x00000008u;
}
void RequestHeader::clear_end_key() {
  end_key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_end_key();
}
 const ::std::string& RequestHeader::end_key() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.RequestHeader.end_key)
  return end_key_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void RequestHeader::set_end_key(const ::std::string& value) {
  set_has_end_key();
  end_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cockroach.proto.RequestHeader.end_key)
}
 void RequestHeader::set_end_key(const char* value) {
  set_has_end_key();
  end_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cockroach.proto.RequestHeader.end_key)
}
 void RequestHeader::set_end_key(const void* value, size_t size) {
  set_has_end_key();
  end_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cockroach.proto.RequestHeader.end_key)
}
 ::std::string* RequestHeader::mutable_end_key() {
  set_has_end_key();
  // @@protoc_insertion_point(field_mutable:cockroach.proto.RequestHeader.end_key)
  return end_key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* RequestHeader::release_end_key() {
  clear_has_end_key();
  return end_key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void RequestHeader::set_allocated_end_key(::std::string* end_key) {
  if (end_key != NULL) {
    set_has_end_key();
  } else {
    clear_has_end_key();
  }
  end_key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), end_key);
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.RequestHeader.end_key)
}

// optional .cockroach.proto.Replica replica = 5;
bool RequestHeader::has_replica() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
void RequestHeader::set_has_replica() {
  _has_bits_[0] |= 0x00000010u;
}
void RequestHeader::clear_has_replica() {
  _has_bits_[0] &= ~0x00000010u;
}
void RequestHeader::clear_replica() {
  if (replica_ != NULL) replica_->::cockroach::proto::Replica::Clear();
  clear_has_replica();
}
 const ::cockroach::proto::Replica& RequestHeader::replica() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.RequestHeader.replica)
  return replica_ != NULL ? *replica_ : *default_instance_->replica_;
}
 ::cockroach::proto::Replica* RequestHeader::mutable_replica() {
  set_has_replica();
  if (replica_ == NULL) {
    replica_ = new ::cockroach::proto::Replica;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.proto.RequestHeader.replica)
  return replica_;
}
 ::cockroach::proto::Replica* RequestHeader::release_replica() {
  clear_has_replica();
  ::cockroach::proto::Replica* temp = replica_;
  replica_ = NULL;
  return temp;
}
 void RequestHeader::set_allocated_replica(::cockroach::proto::Replica* replica) {
  delete replica_;
  replica_ = replica;
  if (replica) {
    set_has_replica();
  } else {
    clear_has_replica();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.RequestHeader.replica)
}

// optional int64 range_id = 6;
bool RequestHeader::has_range_id() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
void RequestHeader::set_has_range_id() {
  _has_bits_[0] |= 0x00000020u;
}
void RequestHeader::clear_has_range_id() {
  _has_bits_[0] &= ~0x00000020u;
}
void RequestHeader::clear_range_id() {
  range_id_ = GOOGLE_LONGLONG(0);
  clear_has_range_id();
}
 ::google::protobuf::int64 RequestHeader::range_id() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.RequestHeader.range_id)
  return range_id_;
}
 void RequestHeader::set_range_id(::google::protobuf::int64 value) {
  set_has_range_id();
  range_id_ = value;
  // @@protoc_insertion_point(field_set:cockroach.proto.RequestHeader.range_id)
}

// optional int32 user_priority = 7 [default = 1];
bool RequestHeader::has_user_priority() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
void RequestHeader::set_has_user_priority() {
  _has_bits_[0] |= 0x00000040u;
}
void RequestHeader::clear_has_user_priority() {
  _has_bits_[0] &= ~0x00000040u;
}
void RequestHeader::clear_user_priority() {
  user_priority_ = 1;
  clear_has_user_priority();
}
 ::google::protobuf::int32 RequestHeader::user_priority() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.RequestHeader.user_priority)
  return user_priority_;
}
 void RequestHeader::set_user_priority(::google::protobuf::int32 value) {
  set_has_user_priority();
  user_priority_ = value;
  // @@protoc_insertion_point(field_set:cockroach.proto.RequestHeader.user_priority)
}

// optional .cockroach.proto.Transaction txn = 8;
bool RequestHeader::has_txn() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
void RequestHeader::set_has_txn() {
  _has_bits_[0] |= 0x00000080u;
}
void RequestHeader::clear_has_txn() {
  _has_bits_[0] &= ~0x00000080u;
}
void RequestHeader::clear_txn() {
  if (txn_ != NULL) txn_->::cockroach::proto::Transaction::Clear();
  clear_has_txn();
}
 const ::cockroach::proto::Transaction& RequestHeader::txn() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.RequestHeader.txn)
  return txn_ != NULL ? *txn_ : *default_instance_->txn_;
}
 ::cockroach::proto::Transaction* RequestHeader::mutable_txn() {
  set_has_txn();
  if (txn_ == NULL) {
    txn_ = new ::cockroach::proto::Transaction;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.proto.RequestHeader.txn)
  return txn_;
}
 ::cockroach::proto::Transaction* RequestHeader::release_txn() {
  clear_has_txn();
  ::cockroach::proto::Transaction* temp = txn_;
  txn_ = NULL;
  return temp;
}
 void RequestHeader::set_allocated_txn(::cockroach::proto::Transaction* txn) {
  delete txn_;
  txn_ = txn;
  if (txn) {
    set_has_txn();
  } else {
    clear_has_txn();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.RequestHeader.txn)
}

// optional .cockroach.proto.ReadConsistencyType read_consistency = 9;
bool RequestHeader::has_read_consistency() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
void RequestHeader::set_has_read_consistency() {
  _has_bits_[0] |= 0x00000100u;
}
void RequestHeader::clear_has_read_consistency() {
  _has_bits_[0] &= ~0x00000100u;
}
void RequestHeader::clear_read_consistency() {
  read_consistency_ = 0;
  clear_has_read_consistency();
}
 ::cockroach::proto::ReadConsistencyType RequestHeader::read_consistency() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.RequestHeader.read_consistency)
  return static_cast< ::cockroach::proto::ReadConsistencyType >(read_consistency_);
}
 void RequestHeader::set_read_consistency(::cockroach::proto::ReadConsistencyType value) {
  assert(::cockroach::proto::ReadConsistencyType_IsValid(value));
  set_has_read_consistency();
  read_consistency_ = value;
  // @@protoc_insertion_point(field_set:cockroach.proto.RequestHeader.read_consistency)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#ifndef _MSC_VER
const int ResponseHeader::kErrorFieldNumber;
const int ResponseHeader::kTimestampFieldNumber;
const int ResponseHeader::kTxnFieldNumber;
#endif  // !_MSC_VER

ResponseHeader::ResponseHeader()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:cockroach.proto.ResponseHeader)
}

void ResponseHeader::InitAsDefaultInstance() {
  error_ = const_cast< ::cockroach::proto::Error*>(&::cockroach::proto::Error::default_instance());
  timestamp_ = const_cast< ::cockroach::proto::Timestamp*>(&::cockroach::proto::Timestamp::default_instance());
  txn_ = const_cast< ::cockroach::proto::Transaction*>(&::cockroach::proto::Transaction::default_instance());
}

ResponseHeader::ResponseHeader(const ResponseHeader& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:cockroach.proto.ResponseHeader)
}

void ResponseHeader::SharedCtor() {
  _cached_size_ = 0;
  error_ = NULL;
  timestamp_ = NULL;
  txn_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ResponseHeader::~ResponseHeader() {
  // @@protoc_insertion_point(destructor:cockroach.proto.ResponseHeader)
  SharedDtor();
}

void ResponseHeader::SharedDtor() {
  if (this != default_instance_) {
    delete error_;
    delete timestamp_;
    delete txn_;
  }
}

void ResponseHeader::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ResponseHeader::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ResponseHeader_descriptor_;
}

const ResponseHeader& ResponseHeader::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_cockroach_2fproto_2fapi_2eproto();
  return *default_instance_;
}

ResponseHeader* ResponseHeader::default_instance_ = NULL;

ResponseHeader* ResponseHeader::New(::google::protobuf::Arena* arena) const {
  ResponseHeader* n = new ResponseHeader;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void ResponseHeader::Clear() {
  if (_has_bits_[0 / 32] & 7u) {
    if (has_error()) {
      if (error_ != NULL) error_->::cockroach::proto::Error::Clear();
    }
    if (has_timestamp()) {
      if (timestamp_ != NULL) timestamp_->::cockroach::proto::Timestamp::Clear();
    }
    if (has_txn()) {
      if (txn_ != NULL) txn_->::cockroach::proto::Transaction::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool ResponseHeader::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:cockroach.proto.ResponseHeader)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .cockroach.proto.Error error = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_error()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_timestamp;
        break;
      }

      // optional .cockroach.proto.Timestamp timestamp = 2;
      case 2: {
        if (tag == 18) {
         parse_timestamp:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_timestamp()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_txn;
        break;
      }

      // optional .cockroach.proto.Transaction txn = 3;
      case 3: {
        if (tag == 26) {
         parse_txn:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_txn()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:cockroach.proto.ResponseHeader)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:cockroach.proto.ResponseHeader)
  return false;
#undef DO_
}

void ResponseHeader::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:cockroach.proto.ResponseHeader)
  // optional .cockroach.proto.Error error = 1;
  if (has_error()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->error_, output);
  }

  // optional .cockroach.proto.Timestamp timestamp = 2;
  if (has_timestamp()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, *this->timestamp_, output);
  }

  // optional .cockroach.proto.Transaction txn = 3;
  if (has_txn()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, *this->txn_, output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:cockroach.proto.ResponseHeader)
}

::google::protobuf::uint8* ResponseHeader::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:cockroach.proto.ResponseHeader)
  // optional .cockroach.proto.Error error = 1;
  if (has_error()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, *this->error_, target);
  }

  // optional .cockroach.proto.Timestamp timestamp = 2;
  if (has_timestamp()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, *this->timestamp_, target);
  }

  // optional .cockroach.proto.Transaction txn = 3;
  if (has_txn()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, *this->txn_, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:cockroach.proto.ResponseHeader)
  return target;
}

int ResponseHeader::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & 7) {
    // optional .cockroach.proto.Error error = 1;
    if (has_error()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->error_);
    }

    // optional .cockroach.proto.Timestamp timestamp = 2;
    if (has_timestamp()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->timestamp_);
    }

    // optional .cockroach.proto.Transaction txn = 3;
    if (has_txn()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->txn_);
    }

  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ResponseHeader::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const ResponseHeader* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const ResponseHeader>(
          &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ResponseHeader::MergeFrom(const ResponseHeader& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_error()) {
      mutable_error()->::cockroach::proto::Error::MergeFrom(from.error());
    }
    if (from.has_timestamp()) {
      mutable_timestamp()->::cockroach::proto::Timestamp::MergeFrom(from.timestamp());
    }
    if (from.has_txn()) {
      mutable_txn()->::cockroach::proto::Transaction::MergeFrom(from.txn());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void ResponseHeader::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ResponseHeader::CopyFrom(const ResponseHeader& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ResponseHeader::IsInitialized() const {

  return true;
}

void ResponseHeader::Swap(ResponseHeader* other) {
  if (other == this) return;
  InternalSwap(other);
}
void ResponseHeader::InternalSwap(ResponseHeader* other) {
  std::swap(error_, other->error_);
  std::swap(timestamp_, other->timestamp_);
  std::swap(txn_, other->txn_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata ResponseHeader::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ResponseHeader_descriptor_;
  metadata.reflection = ResponseHeader_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// ResponseHeader

// optional .cockroach.proto.Error error = 1;
bool ResponseHeader::has_error() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void ResponseHeader::set_has_error() {
  _has_bits_[0] |= 0x00000001u;
}
void ResponseHeader::clear_has_error() {
  _has_bits_[0] &= ~0x00000001u;
}
void ResponseHeader::clear_error() {
  if (error_ != NULL) error_->::cockroach::proto::Error::Clear();
  clear_has_error();
}
 const ::cockroach::proto::Error& ResponseHeader::error() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.ResponseHeader.error)
  return error_ != NULL ? *error_ : *default_instance_->error_;
}
 ::cockroach::proto::Error* ResponseHeader::mutable_error() {
  set_has_error();
  if (error_ == NULL) {
    error_ = new ::cockroach::proto::Error;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.proto.ResponseHeader.error)
  return error_;
}
 ::cockroach::proto::Error* ResponseHeader::release_error() {
  clear_has_error();
  ::cockroach::proto::Error* temp = error_;
  error_ = NULL;
  return temp;
}
 void ResponseHeader::set_allocated_error(::cockroach::proto::Error* error) {
  delete error_;
  error_ = error;
  if (error) {
    set_has_error();
  } else {
    clear_has_error();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.ResponseHeader.error)
}

// optional .cockroach.proto.Timestamp timestamp = 2;
bool ResponseHeader::has_timestamp() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void ResponseHeader::set_has_timestamp() {
  _has_bits_[0] |= 0x00000002u;
}
void ResponseHeader::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000002u;
}
void ResponseHeader::clear_timestamp() {
  if (timestamp_ != NULL) timestamp_->::cockroach::proto::Timestamp::Clear();
  clear_has_timestamp();
}
 const ::cockroach::proto::Timestamp& ResponseHeader::timestamp() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.ResponseHeader.timestamp)
  return timestamp_ != NULL ? *timestamp_ : *default_instance_->timestamp_;
}
 ::cockroach::proto::Timestamp* ResponseHeader::mutable_timestamp() {
  set_has_timestamp();
  if (timestamp_ == NULL) {
    timestamp_ = new ::cockroach::proto::Timestamp;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.proto.ResponseHeader.timestamp)
  return timestamp_;
}
 ::cockroach::proto::Timestamp* ResponseHeader::release_timestamp() {
  clear_has_timestamp();
  ::cockroach::proto::Timestamp* temp = timestamp_;
  timestamp_ = NULL;
  return temp;
}
 void ResponseHeader::set_allocated_timestamp(::cockroach::proto::Timestamp* timestamp) {
  delete timestamp_;
  timestamp_ = timestamp;
  if (timestamp) {
    set_has_timestamp();
  } else {
    clear_has_timestamp();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.ResponseHeader.timestamp)
}

// optional .cockroach.proto.Transaction txn = 3;
bool ResponseHeader::has_txn() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void ResponseHeader::set_has_txn() {
  _has_bits_[0] |= 0x00000004u;
}
void ResponseHeader::clear_has_txn() {
  _has_bits_[0] &= ~0x00000004u;
}
void ResponseHeader::clear_txn() {
  if (txn_ != NULL) txn_->::cockroach::proto::Transaction::Clear();
  clear_has_txn();
}
 const ::cockroach::proto::Transaction& ResponseHeader::txn() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.ResponseHeader.txn)
  return txn_ != NULL ? *txn_ : *default_instance_->txn_;
}
 ::cockroach::proto::Transaction* ResponseHeader::mutable_txn() {
  set_has_txn();
  if (txn_ == NULL) {
    txn_ = new ::cockroach::proto::Transaction;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.proto.ResponseHeader.txn)
  return txn_;
}
 ::cockroach::proto::Transaction* ResponseHeader::release_txn() {
  clear_has_txn();
  ::cockroach::proto::Transaction* temp = txn_;
  txn_ = NULL;
  return temp;
}
 void ResponseHeader::set_allocated_txn(::cockroach::proto::Transaction* txn) {
  delete txn_;
  txn_ = txn;
  if (txn) {
    set_has_txn();
  } else {
    clear_has_txn();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.ResponseHeader.txn)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#ifndef _MSC_VER
const int GetRequest::kHeaderFieldNumber;
#endif  // !_MSC_VER

GetRequest::GetRequest()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:cockroach.proto.GetRequest)
}

void GetRequest::InitAsDefaultInstance() {
  header_ = const_cast< ::cockroach::proto::RequestHeader*>(&::cockroach::proto::RequestHeader::default_instance());
}

GetRequest::GetRequest(const GetRequest& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:cockroach.proto.GetRequest)
}

void GetRequest::SharedCtor() {
  _cached_size_ = 0;
  header_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GetRequest::~GetRequest() {
  // @@protoc_insertion_point(destructor:cockroach.proto.GetRequest)
  SharedDtor();
}

void GetRequest::SharedDtor() {
  if (this != default_instance_) {
    delete header_;
  }
}

void GetRequest::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* GetRequest::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return GetRequest_descriptor_;
}

const GetRequest& GetRequest::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_cockroach_2fproto_2fapi_2eproto();
  return *default_instance_;
}

GetRequest* GetRequest::default_instance_ = NULL;

GetRequest* GetRequest::New(::google::protobuf::Arena* arena) const {
  GetRequest* n = new GetRequest;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void GetRequest::Clear() {
  if (has_header()) {
    if (header_ != NULL) header_->::cockroach::proto::RequestHeader::Clear();
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool GetRequest::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:cockroach.proto.GetRequest)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .cockroach.proto.RequestHeader header = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_header()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:cockroach.proto.GetRequest)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:cockroach.proto.GetRequest)
  return false;
#undef DO_
}

void GetRequest::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:cockroach.proto.GetRequest)
  // optional .cockroach.proto.RequestHeader header = 1;
  if (has_header()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->header_, output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:cockroach.proto.GetRequest)
}

::google::protobuf::uint8* GetRequest::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:cockroach.proto.GetRequest)
  // optional .cockroach.proto.RequestHeader header = 1;
  if (has_header()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, *this->header_, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:cockroach.proto.GetRequest)
  return target;
}

int GetRequest::ByteSize() const {
  int total_size = 0;

  // optional .cockroach.proto.RequestHeader header = 1;
  if (has_header()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->header_);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GetRequest::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const GetRequest* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const GetRequest>(
          &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void GetRequest::MergeFrom(const GetRequest& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_header()) {
      mutable_header()->::cockroach::proto::RequestHeader::MergeFrom(from.header());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void GetRequest::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void GetRequest::CopyFrom(const GetRequest& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GetRequest::IsInitialized() const {

  return true;
}

void GetRequest::Swap(GetRequest* other) {
  if (other == this) return;
  InternalSwap(other);
}
void GetRequest::InternalSwap(GetRequest* other) {
  std::swap(header_, other->header_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata GetRequest::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = GetRequest_descriptor_;
  metadata.reflection = GetRequest_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// GetRequest

// optional .cockroach.proto.RequestHeader header = 1;
bool GetRequest::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void GetRequest::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
void GetRequest::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
void GetRequest::clear_header() {
  if (header_ != NULL) header_->::cockroach::proto::RequestHeader::Clear();
  clear_has_header();
}
 const ::cockroach::proto::RequestHeader& GetRequest::header() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.GetRequest.header)
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
 ::cockroach::proto::RequestHeader* GetRequest::mutable_header() {
  set_has_header();
  if (header_ == NULL) {
    header_ = new ::cockroach::proto::RequestHeader;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.proto.GetRequest.header)
  return header_;
}
 ::cockroach::proto::RequestHeader* GetRequest::release_header() {
  clear_has_header();
  ::cockroach::proto::RequestHeader* temp = header_;
  header_ = NULL;
  return temp;
}
 void GetRequest::set_allocated_header(::cockroach::proto::RequestHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.GetRequest.header)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#ifndef _MSC_VER
const int GetResponse::kHeaderFieldNumber;
const int GetResponse::kValueFieldNumber;
#endif  // !_MSC_VER

GetResponse::GetResponse()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:cockroach.proto.GetResponse)
}

void GetResponse::InitAsDefaultInstance() {
  header_ = const_cast< ::cockroach::proto::ResponseHeader*>(&::cockroach::proto::ResponseHeader::default_instance());
  value_ = const_cast< ::cockroach::proto::Value*>(&::cockroach::proto::Value::default_instance());
}

GetResponse::GetResponse(const GetResponse& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:cockroach.proto.GetResponse)
}

void GetResponse::SharedCtor() {
  _cached_size_ = 0;
  header_ = NULL;
  value_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GetResponse::~GetResponse() {
  // @@protoc_insertion_point(destructor:cockroach.proto.GetResponse)
  SharedDtor();
}

void GetResponse::SharedDtor() {
  if (this != default_instance_) {
    delete header_;
    delete value_;
  }
}

void GetResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* GetResponse::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return GetResponse_descriptor_;
}

const GetResponse& GetResponse::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_cockroach_2fproto_2fapi_2eproto();
  return *default_instance_;
}

GetResponse* GetResponse::default_instance_ = NULL;

GetResponse* GetResponse::New(::google::protobuf::Arena* arena) const {
  GetResponse* n = new GetResponse;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void GetResponse::Clear() {
  if (_has_bits_[0 / 32] & 3u) {
    if (has_header()) {
      if (header_ != NULL) header_->::cockroach::proto::ResponseHeader::Clear();
    }
    if (has_value()) {
      if (value_ != NULL) value_->::cockroach::proto::Value::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool GetResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:cockroach.proto.GetResponse)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .cockroach.proto.ResponseHeader header = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_header()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_value;
        break;
      }

      // optional .cockroach.proto.Value value = 2;
      case 2: {
        if (tag == 18) {
         parse_value:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_value()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:cockroach.proto.GetResponse)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:cockroach.proto.GetResponse)
  return false;
#undef DO_
}

void GetResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:cockroach.proto.GetResponse)
  // optional .cockroach.proto.ResponseHeader header = 1;
  if (has_header()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->header_, output);
  }

  // optional .cockroach.proto.Value value = 2;
  if (has_value()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, *this->value_, output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:cockroach.proto.GetResponse)
}

::google::protobuf::uint8* GetResponse::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:cockroach.proto.GetResponse)
  // optional .cockroach.proto.ResponseHeader header = 1;
  if (has_header()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, *this->header_, target);
  }

  // optional .cockroach.proto.Value value = 2;
  if (has_value()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, *this->value_, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:cockroach.proto.GetResponse)
  return target;
}

int GetResponse::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & 3) {
    // optional .cockroach.proto.ResponseHeader header = 1;
    if (has_header()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->header_);
    }

    // optional .cockroach.proto.Value value = 2;
    if (has_value()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->value_);
    }

  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GetResponse::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const GetResponse* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const GetResponse>(
          &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void GetResponse::MergeFrom(const GetResponse& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_header()) {
      mutable_header()->::cockroach::proto::ResponseHeader::MergeFrom(from.header());
    }
    if (from.has_value()) {
      mutable_value()->::cockroach::proto::Value::MergeFrom(from.value());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void GetResponse::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void GetResponse::CopyFrom(const GetResponse& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GetResponse::IsInitialized() const {

  return true;
}

void GetResponse::Swap(GetResponse* other) {
  if (other == this) return;
  InternalSwap(other);
}
void GetResponse::InternalSwap(GetResponse* other) {
  std::swap(header_, other->header_);
  std::swap(value_, other->value_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata GetResponse::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = GetResponse_descriptor_;
  metadata.reflection = GetResponse_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// GetResponse

// optional .cockroach.proto.ResponseHeader header = 1;
bool GetResponse::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void GetResponse::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
void GetResponse::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
void GetResponse::clear_header() {
  if (header_ != NULL) header_->::cockroach::proto::ResponseHeader::Clear();
  clear_has_header();
}
 const ::cockroach::proto::ResponseHeader& GetResponse::header() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.GetResponse.header)
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
 ::cockroach::proto::ResponseHeader* GetResponse::mutable_header() {
  set_has_header();
  if (header_ == NULL) {
    header_ = new ::cockroach::proto::ResponseHeader;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.proto.GetResponse.header)
  return header_;
}
 ::cockroach::proto::ResponseHeader* GetResponse::release_header() {
  clear_has_header();
  ::cockroach::proto::ResponseHeader* temp = header_;
  header_ = NULL;
  return temp;
}
 void GetResponse::set_allocated_header(::cockroach::proto::ResponseHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.GetResponse.header)
}

// optional .cockroach.proto.Value value = 2;
bool GetResponse::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void GetResponse::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
void GetResponse::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
void GetResponse::clear_value() {
  if (value_ != NULL) value_->::cockroach::proto::Value::Clear();
  clear_has_value();
}
 const ::cockroach::proto::Value& GetResponse::value() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.GetResponse.value)
  return value_ != NULL ? *value_ : *default_instance_->value_;
}
 ::cockroach::proto::Value* GetResponse::mutable_value() {
  set_has_value();
  if (value_ == NULL) {
    value_ = new ::cockroach::proto::Value;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.proto.GetResponse.value)
  return value_;
}
 ::cockroach::proto::Value* GetResponse::release_value() {
  clear_has_value();
  ::cockroach::proto::Value* temp = value_;
  value_ = NULL;
  return temp;
}
 void GetResponse::set_allocated_value(::cockroach::proto::Value* value) {
  delete value_;
  value_ = value;
  if (value) {
    set_has_value();
  } else {
    clear_has_value();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.GetResponse.value)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#ifndef _MSC_VER
const int PutRequest::kHeaderFieldNumber;
const int PutRequest::kValueFieldNumber;
#endif  // !_MSC_VER

PutRequest::PutRequest()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:cockroach.proto.PutRequest)
}

void PutRequest::InitAsDefaultInstance() {
  header_ = const_cast< ::cockroach::proto::RequestHeader*>(&::cockroach::proto::RequestHeader::default_instance());
  value_ = const_cast< ::cockroach::proto::Value*>(&::cockroach::proto::Value::default_instance());
}

PutRequest::PutRequest(const PutRequest& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:cockroach.proto.PutRequest)
}

void PutRequest::SharedCtor() {
  _cached_size_ = 0;
  header_ = NULL;
  value_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

PutRequest::~PutRequest() {
  // @@protoc_insertion_point(destructor:cockroach.proto.PutRequest)
  SharedDtor();
}

void PutRequest::SharedDtor() {
  if (this != default_instance_) {
    delete header_;
    delete value_;
  }
}

void PutRequest::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* PutRequest::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return PutRequest_descriptor_;
}

const PutRequest& PutRequest::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_cockroach_2fproto_2fapi_2eproto();
  return *default_instance_;
}

PutRequest* PutRequest::default_instance_ = NULL;

PutRequest* PutRequest::New(::google::protobuf::Arena* arena) const {
  PutRequest* n = new PutRequest;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void PutRequest::Clear() {
  if (_has_bits_[0 / 32] & 3u) {
    if (has_header()) {
      if (header_ != NULL) header_->::cockroach::proto::RequestHeader::Clear();
    }
    if (has_value()) {
      if (value_ != NULL) value_->::cockroach::proto::Value::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool PutRequest::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:cockroach.proto.PutRequest)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .cockroach.proto.RequestHeader header = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_header()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_value;
        break;
      }

      // optional .cockroach.proto.Value value = 2;
      case 2: {
        if (tag == 18) {
         parse_value:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_value()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:cockroach.proto.PutRequest)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:cockroach.proto.PutRequest)
  return false;
#undef DO_
}

void PutRequest::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:cockroach.proto.PutRequest)
  // optional .cockroach.proto.RequestHeader header = 1;
  if (has_header()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->header_, output);
  }

  // optional .cockroach.proto.Value value = 2;
  if (has_value()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, *this->value_, output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:cockroach.proto.PutRequest)
}

::google::protobuf::uint8* PutRequest::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:cockroach.proto.PutRequest)
  // optional .cockroach.proto.RequestHeader header = 1;
  if (has_header()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, *this->header_, target);
  }

  // optional .cockroach.proto.Value value = 2;
  if (has_value()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, *this->value_, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:cockroach.proto.PutRequest)
  return target;
}

int PutRequest::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & 3) {
    // optional .cockroach.proto.RequestHeader header = 1;
    if (has_header()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->header_);
    }

    // optional .cockroach.proto.Value value = 2;
    if (has_value()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->value_);
    }

  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void PutRequest::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const PutRequest* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const PutRequest>(
          &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void PutRequest::MergeFrom(const PutRequest& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_header()) {
      mutable_header()->::cockroach::proto::RequestHeader::MergeFrom(from.header());
    }
    if (from.has_value()) {
      mutable_value()->::cockroach::proto::Value::MergeFrom(from.value());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void PutRequest::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void PutRequest::CopyFrom(const PutRequest& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PutRequest::IsInitialized() const {

  return true;
}

void PutRequest::Swap(PutRequest* other) {
  if (other == this) return;
  InternalSwap(other);
}
void PutRequest::InternalSwap(PutRequest* other) {
  std::swap(header_, other->header_);
  std::swap(value_, other->value_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata PutRequest::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = PutRequest_descriptor_;
  metadata.reflection = PutRequest_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// PutRequest

// optional .cockroach.proto.RequestHeader header = 1;
bool PutRequest::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void PutRequest::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
void PutRequest::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
void PutRequest::clear_header() {
  if (header_ != NULL) header_->::cockroach::proto::RequestHeader::Clear();
  clear_has_header();
}
 const ::cockroach::proto::RequestHeader& PutRequest::header() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.PutRequest.header)
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
 ::cockroach::proto::RequestHeader* PutRequest::mutable_header() {
  set_has_header();
  if (header_ == NULL) {
    header_ = new ::cockroach::proto::RequestHeader;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.proto.PutRequest.header)
  return header_;
}
 ::cockroach::proto::RequestHeader* PutRequest::release_header() {
  clear_has_header();
  ::cockroach::proto::RequestHeader* temp = header_;
  header_ = NULL;
  return temp;
}
 void PutRequest::set_allocated_header(::cockroach::proto::RequestHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.PutRequest.header)
}

// optional .cockroach.proto.Value value = 2;
bool PutRequest::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void PutRequest::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
void PutRequest::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
void PutRequest::clear_value() {
  if (value_ != NULL) value_->::cockroach::proto::Value::Clear();
  clear_has_value();
}
 const ::cockroach::proto::Value& PutRequest::value() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.PutRequest.value)
  return value_ != NULL ? *value_ : *default_instance_->value_;
}
 ::cockroach::proto::Value* PutRequest::mutable_value() {
  set_has_value();
  if (value_ == NULL) {
    value_ = new ::cockroach::proto::Value;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.proto.PutRequest.value)
  return value_;
}
 ::cockroach::proto::Value* PutRequest::release_value() {
  clear_has_value();
  ::cockroach::proto::Value* temp = value_;
  value_ = NULL;
  return temp;
}
 void PutRequest::set_allocated_value(::cockroach::proto::Value* value) {
  delete value_;
  value_ = value;
  if (value) {
    set_has_value();
  } else {
    clear_has_value();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.PutRequest.value)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#ifndef _MSC_VER
const int PutResponse::kHeaderFieldNumber;
#endif  // !_MSC_VER

PutResponse::PutResponse()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:cockroach.proto.PutResponse)
}

void PutResponse::InitAsDefaultInstance() {
  header_ = const_cast< ::cockroach::proto::ResponseHeader*>(&::cockroach::proto::ResponseHeader::default_instance());
}

PutResponse::PutResponse(const PutResponse& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:cockroach.proto.PutResponse)
}

void PutResponse::SharedCtor() {
  _cached_size_ = 0;
  header_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

PutResponse::~PutResponse() {
  // @@protoc_insertion_point(destructor:cockroach.proto.PutResponse)
  SharedDtor();
}

void PutResponse::SharedDtor() {
  if (this != default_instance_) {
    delete header_;
  }
}

void PutResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* PutResponse::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return PutResponse_descriptor_;
}

const PutResponse& PutResponse::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_cockroach_2fproto_2fapi_2eproto();
  return *default_instance_;
}

PutResponse* PutResponse::default_instance_ = NULL;

PutResponse* PutResponse::New(::google::protobuf::Arena* arena) const {
  PutResponse* n = new PutResponse;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void PutResponse::Clear() {
  if (has_header()) {
    if (header_ != NULL) header_->::cockroach::proto::ResponseHeader::Clear();
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool PutResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:cockroach.proto.PutResponse)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .cockroach.proto.ResponseHeader header = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_header()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:cockroach.proto.PutResponse)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:cockroach.proto.PutResponse)
  return false;
#undef DO_
}

void PutResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:cockroach.proto.PutResponse)
  // optional .cockroach.proto.ResponseHeader header = 1;
  if (has_header()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->header_, output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:cockroach.proto.PutResponse)
}

::google::protobuf::uint8* PutResponse::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:cockroach.proto.PutResponse)
  // optional .cockroach.proto.ResponseHeader header = 1;
  if (has_header()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, *this->header_, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:cockroach.proto.PutResponse)
  return target;
}

int PutResponse::ByteSize() const {
  int total_size = 0;

  // optional .cockroach.proto.ResponseHeader header = 1;
  if (has_header()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->header_);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void PutResponse::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const PutResponse* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const PutResponse>(
          &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void PutResponse::MergeFrom(const PutResponse& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_header()) {
      mutable_header()->::cockroach::proto::ResponseHeader::MergeFrom(from.header());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void PutResponse::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void PutResponse::CopyFrom(const PutResponse& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PutResponse::IsInitialized() const {

  return true;
}

void PutResponse::Swap(PutResponse* other) {
  if (other == this) return;
  InternalSwap(other);
}
void PutResponse::InternalSwap(PutResponse* other) {
  std::swap(header_, other->header_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata PutResponse::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = PutResponse_descriptor_;
  metadata.reflection = PutResponse_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// PutResponse

// optional .cockroach.proto.ResponseHeader header = 1;
bool PutResponse::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void PutResponse::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
void PutResponse::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
void PutResponse::clear_header() {
  if (header_ != NULL) header_->::cockroach::proto::ResponseHeader::Clear();
  clear_has_header();
}
 const ::cockroach::proto::ResponseHeader& PutResponse::header() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.PutResponse.header)
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
 ::cockroach::proto::ResponseHeader* PutResponse::mutable_header() {
  set_has_header();
  if (header_ == NULL) {
    header_ = new ::cockroach::proto::ResponseHeader;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.proto.PutResponse.header)
  return header_;
}
 ::cockroach::proto::ResponseHeader* PutResponse::release_header() {
  clear_has_header();
  ::cockroach::proto::ResponseHeader* temp = header_;
  header_ = NULL;
  return temp;
}
 void PutResponse::set_allocated_header(::cockroach::proto::ResponseHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.PutResponse.header)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#ifndef _MSC_VER
const int ConditionalPutRequest::kHeaderFieldNumber;
const int ConditionalPutRequest::kValueFieldNumber;
const int ConditionalPutRequest::kExpValueFieldNumber;
#endif  // !_MSC_VER

ConditionalPutRequest::ConditionalPutRequest()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:cockroach.proto.ConditionalPutRequest)
}

void ConditionalPutRequest::InitAsDefaultInstance() {
  header_ = const_cast< ::cockroach::proto::RequestHeader*>(&::cockroach::proto::RequestHeader::default_instance());
  value_ = const_cast< ::cockroach::proto::Value*>(&::cockroach::proto::Value::default_instance());
  exp_value_ = const_cast< ::cockroach::proto::Value*>(&::cockroach::proto::Value::default_instance());
}

ConditionalPutRequest::ConditionalPutRequest(const ConditionalPutRequest& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:cockroach.proto.ConditionalPutRequest)
}

void ConditionalPutRequest::SharedCtor() {
  _cached_size_ = 0;
  header_ = NULL;
  value_ = NULL;
  exp_value_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ConditionalPutRequest::~ConditionalPutRequest() {
  // @@protoc_insertion_point(destructor:cockroach.proto.ConditionalPutRequest)
  SharedDtor();
}

void ConditionalPutRequest::SharedDtor() {
  if (this != default_instance_) {
    delete header_;
    delete value_;
    delete exp_value_;
  }
}

void ConditionalPutRequest::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ConditionalPutRequest::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ConditionalPutRequest_descriptor_;
}

const ConditionalPutRequest& ConditionalPutRequest::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_cockroach_2fproto_2fapi_2eproto();
  return *default_instance_;
}

ConditionalPutRequest* ConditionalPutRequest::default_instance_ = NULL;

ConditionalPutRequest* ConditionalPutRequest::New(::google::protobuf::Arena* arena) const {
  ConditionalPutRequest* n = new ConditionalPutRequest;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void ConditionalPutRequest::Clear() {
  if (_has_bits_[0 / 32] & 7u) {
    if (has_header()) {
      if (header_ != NULL) header_->::cockroach::proto::RequestHeader::Clear();
    }
    if (has_value()) {
      if (value_ != NULL) value_->::cockroach::proto::Value::Clear();
    }
    if (has_exp_value()) {
      if (exp_value_ != NULL) exp_value_->::cockroach::proto::Value::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool ConditionalPutRequest::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:cockroach.proto.ConditionalPutRequest)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .cockroach.proto.RequestHeader header = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_header()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_value;
        break;
      }

      // optional .cockroach.proto.Value value = 2;
      case 2: {
        if (tag == 18) {
         parse_value:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_value()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_exp_value;
        break;
      }

      // optional .cockroach.proto.Value exp_value = 3;
      case 3: {
        if (tag == 26) {
         parse_exp_value:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_exp_value()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:cockroach.proto.ConditionalPutRequest)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:cockroach.proto.ConditionalPutRequest)
  return false;
#undef DO_
}

void ConditionalPutRequest::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:cockroach.proto.ConditionalPutRequest)
  // optional .cockroach.proto.RequestHeader header = 1;
  if (has_header()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->header_, output);
  }

  // optional .cockroach.proto.Value value = 2;
  if (has_value()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, *this->value_, output);
  }

  // optional .cockroach.proto.Value exp_value = 3;
  if (has_exp_value()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, *this->exp_value_, output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:cockroach.proto.ConditionalPutRequest)
}

::google::protobuf::uint8* ConditionalPutRequest::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:cockroach.proto.ConditionalPutRequest)
  // optional .cockroach.proto.RequestHeader header = 1;
  if (has_header()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, *this->header_, target);
  }

  // optional .cockroach.proto.Value value = 2;
  if (has_value()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, *this->value_, target);
  }

  // optional .cockroach.proto.Value exp_value = 3;
  if (has_exp_value()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, *this->exp_value_, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:cockroach.proto.ConditionalPutRequest)
  return target;
}

int ConditionalPutRequest::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & 7) {
    // optional .cockroach.proto.RequestHeader header = 1;
    if (has_header()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->header_);
    }

    // optional .cockroach.proto.Value value = 2;
    if (has_value()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->value_);
    }

    // optional .cockroach.proto.Value exp_value = 3;
    if (has_exp_value()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->exp_value_);
    }

  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ConditionalPutRequest::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const ConditionalPutRequest* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const ConditionalPutRequest>(
          &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ConditionalPutRequest::MergeFrom(const ConditionalPutRequest& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_header()) {
      mutable_header()->::cockroach::proto::RequestHeader::MergeFrom(from.header());
    }
    if (from.has_value()) {
      mutable_value()->::cockroach::proto::Value::MergeFrom(from.value());
    }
    if (from.has_exp_value()) {
      mutable_exp_value()->::cockroach::proto::Value::MergeFrom(from.exp_value());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void ConditionalPutRequest::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ConditionalPutRequest::CopyFrom(const ConditionalPutRequest& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ConditionalPutRequest::IsInitialized() const {

  return true;
}

void ConditionalPutRequest::Swap(ConditionalPutRequest* other) {
  if (other == this) return;
  InternalSwap(other);
}
void ConditionalPutRequest::InternalSwap(ConditionalPutRequest* other) {
  std::swap(header_, other->header_);
  std::swap(value_, other->value_);
  std::swap(exp_value_, other->exp_value_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata ConditionalPutRequest::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ConditionalPutRequest_descriptor_;
  metadata.reflection = ConditionalPutRequest_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// ConditionalPutRequest

// optional .cockroach.proto.RequestHeader header = 1;
bool ConditionalPutRequest::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void ConditionalPutRequest::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
void ConditionalPutRequest::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
void ConditionalPutRequest::clear_header() {
  if (header_ != NULL) header_->::cockroach::proto::RequestHeader::Clear();
  clear_has_header();
}
 const ::cockroach::proto::RequestHeader& ConditionalPutRequest::header() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.ConditionalPutRequest.header)
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
 ::cockroach::proto::RequestHeader* ConditionalPutRequest::mutable_header() {
  set_has_header();
  if (header_ == NULL) {
    header_ = new ::cockroach::proto::RequestHeader;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.proto.ConditionalPutRequest.header)
  return header_;
}
 ::cockroach::proto::RequestHeader* ConditionalPutRequest::release_header() {
  clear_has_header();
  ::cockroach::proto::RequestHeader* temp = header_;
  header_ = NULL;
  return temp;
}
 void ConditionalPutRequest::set_allocated_header(::cockroach::proto::RequestHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.ConditionalPutRequest.header)
}

// optional .cockroach.proto.Value value = 2;
bool ConditionalPutRequest::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void ConditionalPutRequest::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
void ConditionalPutRequest::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
void ConditionalPutRequest::clear_value() {
  if (value_ != NULL) value_->::cockroach::proto::Value::Clear();
  clear_has_value();
}
 const ::cockroach::proto::Value& ConditionalPutRequest::value() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.ConditionalPutRequest.value)
  return value_ != NULL ? *value_ : *default_instance_->value_;
}
 ::cockroach::proto::Value* ConditionalPutRequest::mutable_value() {
  set_has_value();
  if (value_ == NULL) {
    value_ = new ::cockroach::proto::Value;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.proto.ConditionalPutRequest.value)
  return value_;
}
 ::cockroach::proto::Value* ConditionalPutRequest::release_value() {
  clear_has_value();
  ::cockroach::proto::Value* temp = value_;
  value_ = NULL;
  return temp;
}
 void ConditionalPutRequest::set_allocated_value(::cockroach::proto::Value* value) {
  delete value_;
  value_ = value;
  if (value) {
    set_has_value();
  } else {
    clear_has_value();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.ConditionalPutRequest.value)
}

// optional .cockroach.proto.Value exp_value = 3;
bool ConditionalPutRequest::has_exp_value() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void ConditionalPutRequest::set_has_exp_value() {
  _has_bits_[0] |= 0x00000004u;
}
void ConditionalPutRequest::clear_has_exp_value() {
  _has_bits_[0] &= ~0x00000004u;
}
void ConditionalPutRequest::clear_exp_value() {
  if (exp_value_ != NULL) exp_value_->::cockroach::proto::Value::Clear();
  clear_has_exp_value();
}
 const ::cockroach::proto::Value& ConditionalPutRequest::exp_value() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.ConditionalPutRequest.exp_value)
  return exp_value_ != NULL ? *exp_value_ : *default_instance_->exp_value_;
}
 ::cockroach::proto::Value* ConditionalPutRequest::mutable_exp_value() {
  set_has_exp_value();
  if (exp_value_ == NULL) {
    exp_value_ = new ::cockroach::proto::Value;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.proto.ConditionalPutRequest.exp_value)
  return exp_value_;
}
 ::cockroach::proto::Value* ConditionalPutRequest::release_exp_value() {
  clear_has_exp_value();
  ::cockroach::proto::Value* temp = exp_value_;
  exp_value_ = NULL;
  return temp;
}
 void ConditionalPutRequest::set_allocated_exp_value(::cockroach::proto::Value* exp_value) {
  delete exp_value_;
  exp_value_ = exp_value;
  if (exp_value) {
    set_has_exp_value();
  } else {
    clear_has_exp_value();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.ConditionalPutRequest.exp_value)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#ifndef _MSC_VER
const int ConditionalPutResponse::kHeaderFieldNumber;
#endif  // !_MSC_VER

ConditionalPutResponse::ConditionalPutResponse()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:cockroach.proto.ConditionalPutResponse)
}

void ConditionalPutResponse::InitAsDefaultInstance() {
  header_ = const_cast< ::cockroach::proto::ResponseHeader*>(&::cockroach::proto::ResponseHeader::default_instance());
}

ConditionalPutResponse::ConditionalPutResponse(const ConditionalPutResponse& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:cockroach.proto.ConditionalPutResponse)
}

void ConditionalPutResponse::SharedCtor() {
  _cached_size_ = 0;
  header_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ConditionalPutResponse::~ConditionalPutResponse() {
  // @@protoc_insertion_point(destructor:cockroach.proto.ConditionalPutResponse)
  SharedDtor();
}

void ConditionalPutResponse::SharedDtor() {
  if (this != default_instance_) {
    delete header_;
  }
}

void ConditionalPutResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ConditionalPutResponse::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ConditionalPutResponse_descriptor_;
}

const ConditionalPutResponse& ConditionalPutResponse::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_cockroach_2fproto_2fapi_2eproto();
  return *default_instance_;
}

ConditionalPutResponse* ConditionalPutResponse::default_instance_ = NULL;

ConditionalPutResponse* ConditionalPutResponse::New(::google::protobuf::Arena* arena) const {
  ConditionalPutResponse* n = new ConditionalPutResponse;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void ConditionalPutResponse::Clear() {
  if (has_header()) {
    if (header_ != NULL) header_->::cockroach::proto::ResponseHeader::Clear();
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool ConditionalPutResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:cockroach.proto.ConditionalPutResponse)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .cockroach.proto.ResponseHeader header = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_header()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:cockroach.proto.ConditionalPutResponse)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:cockroach.proto.ConditionalPutResponse)
  return false;
#undef DO_
}

void ConditionalPutResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:cockroach.proto.ConditionalPutResponse)
  // optional .cockroach.proto.ResponseHeader header = 1;
  if (has_header()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->header_, output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:cockroach.proto.ConditionalPutResponse)
}

::google::protobuf::uint8* ConditionalPutResponse::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:cockroach.proto.ConditionalPutResponse)
  // optional .cockroach.proto.ResponseHeader header = 1;
  if (has_header()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, *this->header_, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:cockroach.proto.ConditionalPutResponse)
  return target;
}

int ConditionalPutResponse::ByteSize() const {
  int total_size = 0;

  // optional .cockroach.proto.ResponseHeader header = 1;
  if (has_header()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->header_);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ConditionalPutResponse::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const ConditionalPutResponse* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const ConditionalPutResponse>(
          &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ConditionalPutResponse::MergeFrom(const ConditionalPutResponse& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_header()) {
      mutable_header()->::cockroach::proto::ResponseHeader::MergeFrom(from.header());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void ConditionalPutResponse::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ConditionalPutResponse::CopyFrom(const ConditionalPutResponse& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ConditionalPutResponse::IsInitialized() const {

  return true;
}

void ConditionalPutResponse::Swap(ConditionalPutResponse* other) {
  if (other == this) return;
  InternalSwap(other);
}
void ConditionalPutResponse::InternalSwap(ConditionalPutResponse* other) {
  std::swap(header_, other->header_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata ConditionalPutResponse::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ConditionalPutResponse_descriptor_;
  metadata.reflection = ConditionalPutResponse_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// ConditionalPutResponse

// optional .cockroach.proto.ResponseHeader header = 1;
bool ConditionalPutResponse::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void ConditionalPutResponse::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
void ConditionalPutResponse::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
void ConditionalPutResponse::clear_header() {
  if (header_ != NULL) header_->::cockroach::proto::ResponseHeader::Clear();
  clear_has_header();
}
 const ::cockroach::proto::ResponseHeader& ConditionalPutResponse::header() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.ConditionalPutResponse.header)
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
 ::cockroach::proto::ResponseHeader* ConditionalPutResponse::mutable_header() {
  set_has_header();
  if (header_ == NULL) {
    header_ = new ::cockroach::proto::ResponseHeader;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.proto.ConditionalPutResponse.header)
  return header_;
}
 ::cockroach::proto::ResponseHeader* ConditionalPutResponse::release_header() {
  clear_has_header();
  ::cockroach::proto::ResponseHeader* temp = header_;
  header_ = NULL;
  return temp;
}
 void ConditionalPutResponse::set_allocated_header(::cockroach::proto::ResponseHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.ConditionalPutResponse.header)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#ifndef _MSC_VER
const int IncrementRequest::kHeaderFieldNumber;
const int IncrementRequest::kIncrementFieldNumber;
#endif  // !_MSC_VER

IncrementRequest::IncrementRequest()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:cockroach.proto.IncrementRequest)
}

void IncrementRequest::InitAsDefaultInstance() {
  header_ = const_cast< ::cockroach::proto::RequestHeader*>(&::cockroach::proto::RequestHeader::default_instance());
}

IncrementRequest::IncrementRequest(const IncrementRequest& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:cockroach.proto.IncrementRequest)
}

void IncrementRequest::SharedCtor() {
  _cached_size_ = 0;
  header_ = NULL;
  increment_ = GOOGLE_LONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

IncrementRequest::~IncrementRequest() {
  // @@protoc_insertion_point(destructor:cockroach.proto.IncrementRequest)
  SharedDtor();
}

void IncrementRequest::SharedDtor() {
  if (this != default_instance_) {
    delete header_;
  }
}

void IncrementRequest::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* IncrementRequest::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return IncrementRequest_descriptor_;
}

const IncrementRequest& IncrementRequest::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_cockroach_2fproto_2fapi_2eproto();
  return *default_instance_;
}

IncrementRequest* IncrementRequest::default_instance_ = NULL;

IncrementRequest* IncrementRequest::New(::google::protobuf::Arena* arena) const {
  IncrementRequest* n = new IncrementRequest;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void IncrementRequest::Clear() {
  if (_has_bits_[0 / 32] & 3u) {
    if (has_header()) {
      if (header_ != NULL) header_->::cockroach::proto::RequestHeader::Clear();
    }
    increment_ = GOOGLE_LONGLONG(0);
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool IncrementRequest::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:cockroach.proto.IncrementRequest)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .cockroach.proto.RequestHeader header = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_header()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_increment;
        break;
      }

      // optional int64 increment = 2;
      case 2: {
        if (tag == 16) {
         parse_increment:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &increment_)));
          set_has_increment();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:cockroach.proto.IncrementRequest)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:cockroach.proto.IncrementRequest)
  return false;
#undef DO_
}

void IncrementRequest::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:cockroach.proto.IncrementRequest)
  // optional .cockroach.proto.RequestHeader header = 1;
  if (has_header()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->header_, output);
  }

  // optional int64 increment = 2;
  if (has_increment()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(2, this->increment(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:cockroach.proto.IncrementRequest)
}

::google::protobuf::uint8* IncrementRequest::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:cockroach.proto.IncrementRequest)
  // optional .cockroach.proto.RequestHeader header = 1;
  if (has_header()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, *this->header_, target);
  }

  // optional int64 increment = 2;
  if (has_increment()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(2, this->increment(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:cockroach.proto.IncrementRequest)
  return target;
}

int IncrementRequest::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & 3) {
    // optional .cockroach.proto.RequestHeader header = 1;
    if (has_header()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->header_);
    }

    // optional int64 increment = 2;
    if (has_increment()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->increment());
    }

  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void IncrementRequest::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const IncrementRequest* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const IncrementRequest>(
          &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void IncrementRequest::MergeFrom(const IncrementRequest& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_header()) {
      mutable_header()->::cockroach::proto::RequestHeader::MergeFrom(from.header());
    }
    if (from.has_increment()) {
      set_increment(from.increment());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void IncrementRequest::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void IncrementRequest::CopyFrom(const IncrementRequest& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IncrementRequest::IsInitialized() const {

  return true;
}

void IncrementRequest::Swap(IncrementRequest* other) {
  if (other == this) return;
  InternalSwap(other);
}
void IncrementRequest::InternalSwap(IncrementRequest* other) {
  std::swap(header_, other->header_);
  std::swap(increment_, other->increment_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata IncrementRequest::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = IncrementRequest_descriptor_;
  metadata.reflection = IncrementRequest_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// IncrementRequest

// optional .cockroach.proto.RequestHeader header = 1;
bool IncrementRequest::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void IncrementRequest::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
void IncrementRequest::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
void IncrementRequest::clear_header() {
  if (header_ != NULL) header_->::cockroach::proto::RequestHeader::Clear();
  clear_has_header();
}
 const ::cockroach::proto::RequestHeader& IncrementRequest::header() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.IncrementRequest.header)
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
 ::cockroach::proto::RequestHeader* IncrementRequest::mutable_header() {
  set_has_header();
  if (header_ == NULL) {
    header_ = new ::cockroach::proto::RequestHeader;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.proto.IncrementRequest.header)
  return header_;
}
 ::cockroach::proto::RequestHeader* IncrementRequest::release_header() {
  clear_has_header();
  ::cockroach::proto::RequestHeader* temp = header_;
  header_ = NULL;
  return temp;
}
 void IncrementRequest::set_allocated_header(::cockroach::proto::RequestHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.IncrementRequest.header)
}

// optional int64 increment = 2;
bool IncrementRequest::has_increment() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void IncrementRequest::set_has_increment() {
  _has_bits_[0] |= 0x00000002u;
}
void IncrementRequest::clear_has_increment() {
  _has_bits_[0] &= ~0x00000002u;
}
void IncrementRequest::clear_increment() {
  increment_ = GOOGLE_LONGLONG(0);
  clear_has_increment();
}
 ::google::protobuf::int64 IncrementRequest::increment() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.IncrementRequest.increment)
  return increment_;
}
 void IncrementRequest::set_increment(::google::protobuf::int64 value) {
  set_has_increment();
  increment_ = value;
  // @@protoc_insertion_point(field_set:cockroach.proto.IncrementRequest.increment)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#ifndef _MSC_VER
const int IncrementResponse::kHeaderFieldNumber;
const int IncrementResponse::kNewValueFieldNumber;
#endif  // !_MSC_VER

IncrementResponse::IncrementResponse()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:cockroach.proto.IncrementResponse)
}

void IncrementResponse::InitAsDefaultInstance() {
  header_ = const_cast< ::cockroach::proto::ResponseHeader*>(&::cockroach::proto::ResponseHeader::default_instance());
}

IncrementResponse::IncrementResponse(const IncrementResponse& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:cockroach.proto.IncrementResponse)
}

void IncrementResponse::SharedCtor() {
  _cached_size_ = 0;
  header_ = NULL;
  new_value_ = GOOGLE_LONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

IncrementResponse::~IncrementResponse() {
  // @@protoc_insertion_point(destructor:cockroach.proto.IncrementResponse)
  SharedDtor();
}

void IncrementResponse::SharedDtor() {
  if (this != default_instance_) {
    delete header_;
  }
}

void IncrementResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* IncrementResponse::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return IncrementResponse_descriptor_;
}

const IncrementResponse& IncrementResponse::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_cockroach_2fproto_2fapi_2eproto();
  return *default_instance_;
}

IncrementResponse* IncrementResponse::default_instance_ = NULL;

IncrementResponse* IncrementResponse::New(::google::protobuf::Arena* arena) const {
  IncrementResponse* n = new IncrementResponse;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void IncrementResponse::Clear() {
  if (_has_bits_[0 / 32] & 3u) {
    if (has_header()) {
      if (header_ != NULL) header_->::cockroach::proto::ResponseHeader::Clear();
    }
    new_value_ = GOOGLE_LONGLONG(0);
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool IncrementResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:cockroach.proto.IncrementResponse)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .cockroach.proto.ResponseHeader header = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_header()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_new_value;
        break;
      }

      // optional int64 new_value = 2;
      case 2: {
        if (tag == 16) {
         parse_new_value:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &new_value_)));
          set_has_new_value();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:cockroach.proto.IncrementResponse)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:cockroach.proto.IncrementResponse)
  return false;
#undef DO_
}

void IncrementResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:cockroach.proto.IncrementResponse)
  // optional .cockroach.proto.ResponseHeader header = 1;
  if (has_header()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->header_, output);
  }

  // optional int64 new_value = 2;
  if (has_new_value()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(2, this->new_value(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:cockroach.proto.IncrementResponse)
}

::google::protobuf::uint8* IncrementResponse::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:cockroach.proto.IncrementResponse)
  // optional .cockroach.proto.ResponseHeader header = 1;
  if (has_header()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, *this->header_, target);
  }

  // optional int64 new_value = 2;
  if (has_new_value()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(2, this->new_value(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:cockroach.proto.IncrementResponse)
  return target;
}

int IncrementResponse::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & 3) {
    // optional .cockroach.proto.ResponseHeader header = 1;
    if (has_header()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->header_);
    }

    // optional int64 new_value = 2;
    if (has_new_value()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->new_value());
    }

  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void IncrementResponse::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const IncrementResponse* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const IncrementResponse>(
          &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void IncrementResponse::MergeFrom(const IncrementResponse& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_header()) {
      mutable_header()->::cockroach::proto::ResponseHeader::MergeFrom(from.header());
    }
    if (from.has_new_value()) {
      set_new_value(from.new_value());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void IncrementResponse::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void IncrementResponse::CopyFrom(const IncrementResponse& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IncrementResponse::IsInitialized() const {

  return true;
}

void IncrementResponse::Swap(IncrementResponse* other) {
  if (other == this) return;
  InternalSwap(other);
}
void IncrementResponse::InternalSwap(IncrementResponse* other) {
  std::swap(header_, other->header_);
  std::swap(new_value_, other->new_value_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata IncrementResponse::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = IncrementResponse_descriptor_;
  metadata.reflection = IncrementResponse_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// IncrementResponse

// optional .cockroach.proto.ResponseHeader header = 1;
bool IncrementResponse::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void IncrementResponse::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
void IncrementResponse::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
void IncrementResponse::clear_header() {
  if (header_ != NULL) header_->::cockroach::proto::ResponseHeader::Clear();
  clear_has_header();
}
 const ::cockroach::proto::ResponseHeader& IncrementResponse::header() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.IncrementResponse.header)
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
 ::cockroach::proto::ResponseHeader* IncrementResponse::mutable_header() {
  set_has_header();
  if (header_ == NULL) {
    header_ = new ::cockroach::proto::ResponseHeader;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.proto.IncrementResponse.header)
  return header_;
}
 ::cockroach::proto::ResponseHeader* IncrementResponse::release_header() {
  clear_has_header();
  ::cockroach::proto::ResponseHeader* temp = header_;
  header_ = NULL;
  return temp;
}
 void IncrementResponse::set_allocated_header(::cockroach::proto::ResponseHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.IncrementResponse.header)
}

// optional int64 new_value = 2;
bool IncrementResponse::has_new_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void IncrementResponse::set_has_new_value() {
  _has_bits_[0] |= 0x00000002u;
}
void IncrementResponse::clear_has_new_value() {
  _has_bits_[0] &= ~0x00000002u;
}
void IncrementResponse::clear_new_value() {
  new_value_ = GOOGLE_LONGLONG(0);
  clear_has_new_value();
}
 ::google::protobuf::int64 IncrementResponse::new_value() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.IncrementResponse.new_value)
  return new_value_;
}
 void IncrementResponse::set_new_value(::google::protobuf::int64 value) {
  set_has_new_value();
  new_value_ = value;
  // @@protoc_insertion_point(field_set:cockroach.proto.IncrementResponse.new_value)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#ifndef _MSC_VER
const int DeleteRequest::kHeaderFieldNumber;
#endif  // !_MSC_VER

DeleteRequest::DeleteRequest()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:cockroach.proto.DeleteRequest)
}

void DeleteRequest::InitAsDefaultInstance() {
  header_ = const_cast< ::cockroach::proto::RequestHeader*>(&::cockroach::proto::RequestHeader::default_instance());
}

DeleteRequest::DeleteRequest(const DeleteRequest& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:cockroach.proto.DeleteRequest)
}

void DeleteRequest::SharedCtor() {
  _cached_size_ = 0;
  header_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

DeleteRequest::~DeleteRequest() {
  // @@protoc_insertion_point(destructor:cockroach.proto.DeleteRequest)
  SharedDtor();
}

void DeleteRequest::SharedDtor() {
  if (this != default_instance_) {
    delete header_;
  }
}

void DeleteRequest::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* DeleteRequest::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return DeleteRequest_descriptor_;
}

const DeleteRequest& DeleteRequest::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_cockroach_2fproto_2fapi_2eproto();
  return *default_instance_;
}

DeleteRequest* DeleteRequest::default_instance_ = NULL;

DeleteRequest* DeleteRequest::New(::google::protobuf::Arena* arena) const {
  DeleteRequest* n = new DeleteRequest;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void DeleteRequest::Clear() {
  if (has_header()) {
    if (header_ != NULL) header_->::cockroach::proto::RequestHeader::Clear();
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool DeleteRequest::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:cockroach.proto.DeleteRequest)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .cockroach.proto.RequestHeader header = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_header()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:cockroach.proto.DeleteRequest)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:cockroach.proto.DeleteRequest)
  return false;
#undef DO_
}

void DeleteRequest::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:cockroach.proto.DeleteRequest)
  // optional .cockroach.proto.RequestHeader header = 1;
  if (has_header()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->header_, output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:cockroach.proto.DeleteRequest)
}

::google::protobuf::uint8* DeleteRequest::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:cockroach.proto.DeleteRequest)
  // optional .cockroach.proto.RequestHeader header = 1;
  if (has_header()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, *this->header_, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:cockroach.proto.DeleteRequest)
  return target;
}

int DeleteRequest::ByteSize() const {
  int total_size = 0;

  // optional .cockroach.proto.RequestHeader header = 1;
  if (has_header()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->header_);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void DeleteRequest::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const DeleteRequest* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const DeleteRequest>(
          &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void DeleteRequest::MergeFrom(const DeleteRequest& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_header()) {
      mutable_header()->::cockroach::proto::RequestHeader::MergeFrom(from.header());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void DeleteRequest::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void DeleteRequest::CopyFrom(const DeleteRequest& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DeleteRequest::IsInitialized() const {

  return true;
}

void DeleteRequest::Swap(DeleteRequest* other) {
  if (other == this) return;
  InternalSwap(other);
}
void DeleteRequest::InternalSwap(DeleteRequest* other) {
  std::swap(header_, other->header_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata DeleteRequest::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = DeleteRequest_descriptor_;
  metadata.reflection = DeleteRequest_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// DeleteRequest

// optional .cockroach.proto.RequestHeader header = 1;
bool DeleteRequest::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void DeleteRequest::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
void DeleteRequest::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
void DeleteRequest::clear_header() {
  if (header_ != NULL) header_->::cockroach::proto::RequestHeader::Clear();
  clear_has_header();
}
 const ::cockroach::proto::RequestHeader& DeleteRequest::header() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.DeleteRequest.header)
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
 ::cockroach::proto::RequestHeader* DeleteRequest::mutable_header() {
  set_has_header();
  if (header_ == NULL) {
    header_ = new ::cockroach::proto::RequestHeader;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.proto.DeleteRequest.header)
  return header_;
}
 ::cockroach::proto::RequestHeader* DeleteRequest::release_header() {
  clear_has_header();
  ::cockroach::proto::RequestHeader* temp = header_;
  header_ = NULL;
  return temp;
}
 void DeleteRequest::set_allocated_header(::cockroach::proto::RequestHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.DeleteRequest.header)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#ifndef _MSC_VER
const int DeleteResponse::kHeaderFieldNumber;
#endif  // !_MSC_VER

DeleteResponse::DeleteResponse()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:cockroach.proto.DeleteResponse)
}

void DeleteResponse::InitAsDefaultInstance() {
  header_ = const_cast< ::cockroach::proto::ResponseHeader*>(&::cockroach::proto::ResponseHeader::default_instance());
}

DeleteResponse::DeleteResponse(const DeleteResponse& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:cockroach.proto.DeleteResponse)
}

void DeleteResponse::SharedCtor() {
  _cached_size_ = 0;
  header_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

DeleteResponse::~DeleteResponse() {
  // @@protoc_insertion_point(destructor:cockroach.proto.DeleteResponse)
  SharedDtor();
}

void DeleteResponse::SharedDtor() {
  if (this != default_instance_) {
    delete header_;
  }
}

void DeleteResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* DeleteResponse::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return DeleteResponse_descriptor_;
}

const DeleteResponse& DeleteResponse::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_cockroach_2fproto_2fapi_2eproto();
  return *default_instance_;
}

DeleteResponse* DeleteResponse::default_instance_ = NULL;

DeleteResponse* DeleteResponse::New(::google::protobuf::Arena* arena) const {
  DeleteResponse* n = new DeleteResponse;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void DeleteResponse::Clear() {
  if (has_header()) {
    if (header_ != NULL) header_->::cockroach::proto::ResponseHeader::Clear();
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool DeleteResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:cockroach.proto.DeleteResponse)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .cockroach.proto.ResponseHeader header = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_header()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:cockroach.proto.DeleteResponse)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:cockroach.proto.DeleteResponse)
  return false;
#undef DO_
}

void DeleteResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:cockroach.proto.DeleteResponse)
  // optional .cockroach.proto.ResponseHeader header = 1;
  if (has_header()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->header_, output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:cockroach.proto.DeleteResponse)
}

::google::protobuf::uint8* DeleteResponse::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:cockroach.proto.DeleteResponse)
  // optional .cockroach.proto.ResponseHeader header = 1;
  if (has_header()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, *this->header_, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:cockroach.proto.DeleteResponse)
  return target;
}

int DeleteResponse::ByteSize() const {
  int total_size = 0;

  // optional .cockroach.proto.ResponseHeader header = 1;
  if (has_header()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->header_);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void DeleteResponse::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const DeleteResponse* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const DeleteResponse>(
          &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void DeleteResponse::MergeFrom(const DeleteResponse& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_header()) {
      mutable_header()->::cockroach::proto::ResponseHeader::MergeFrom(from.header());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void DeleteResponse::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void DeleteResponse::CopyFrom(const DeleteResponse& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DeleteResponse::IsInitialized() const {

  return true;
}

void DeleteResponse::Swap(DeleteResponse* other) {
  if (other == this) return;
  InternalSwap(other);
}
void DeleteResponse::InternalSwap(DeleteResponse* other) {
  std::swap(header_, other->header_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata DeleteResponse::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = DeleteResponse_descriptor_;
  metadata.reflection = DeleteResponse_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// DeleteResponse

// optional .cockroach.proto.ResponseHeader header = 1;
bool DeleteResponse::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void DeleteResponse::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
void DeleteResponse::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
void DeleteResponse::clear_header() {
  if (header_ != NULL) header_->::cockroach::proto::ResponseHeader::Clear();
  clear_has_header();
}
 const ::cockroach::proto::ResponseHeader& DeleteResponse::header() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.DeleteResponse.header)
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
 ::cockroach::proto::ResponseHeader* DeleteResponse::mutable_header() {
  set_has_header();
  if (header_ == NULL) {
    header_ = new ::cockroach::proto::ResponseHeader;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.proto.DeleteResponse.header)
  return header_;
}
 ::cockroach::proto::ResponseHeader* DeleteResponse::release_header() {
  clear_has_header();
  ::cockroach::proto::ResponseHeader* temp = header_;
  header_ = NULL;
  return temp;
}
 void DeleteResponse::set_allocated_header(::cockroach::proto::ResponseHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.DeleteResponse.header)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#ifndef _MSC_VER
const int DeleteRangeRequest::kHeaderFieldNumber;
const int DeleteRangeRequest::kMaxEntriesToDeleteFieldNumber;
#endif  // !_MSC_VER

DeleteRangeRequest::DeleteRangeRequest()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:cockroach.proto.DeleteRangeRequest)
}

void DeleteRangeRequest::InitAsDefaultInstance() {
  header_ = const_cast< ::cockroach::proto::RequestHeader*>(&::cockroach::proto::RequestHeader::default_instance());
}

DeleteRangeRequest::DeleteRangeRequest(const DeleteRangeRequest& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:cockroach.proto.DeleteRangeRequest)
}

void DeleteRangeRequest::SharedCtor() {
  _cached_size_ = 0;
  header_ = NULL;
  max_entries_to_delete_ = GOOGLE_LONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

DeleteRangeRequest::~DeleteRangeRequest() {
  // @@protoc_insertion_point(destructor:cockroach.proto.DeleteRangeRequest)
  SharedDtor();
}

void DeleteRangeRequest::SharedDtor() {
  if (this != default_instance_) {
    delete header_;
  }
}

void DeleteRangeRequest::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* DeleteRangeRequest::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return DeleteRangeRequest_descriptor_;
}

const DeleteRangeRequest& DeleteRangeRequest::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_cockroach_2fproto_2fapi_2eproto();
  return *default_instance_;
}

DeleteRangeRequest* DeleteRangeRequest::default_instance_ = NULL;

DeleteRangeRequest* DeleteRangeRequest::New(::google::protobuf::Arena* arena) const {
  DeleteRangeRequest* n = new DeleteRangeRequest;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void DeleteRangeRequest::Clear() {
  if (_has_bits_[0 / 32] & 3u) {
    if (has_header()) {
      if (header_ != NULL) header_->::cockroach::proto::RequestHeader::Clear();
    }
    max_entries_to_delete_ = GOOGLE_LONGLONG(0);
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool DeleteRangeRequest::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:cockroach.proto.DeleteRangeRequest)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .cockroach.proto.RequestHeader header = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_header()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_max_entries_to_delete;
        break;
      }

      // optional int64 max_entries_to_delete = 2;
      case 2: {
        if (tag == 16) {
         parse_max_entries_to_delete:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &max_entries_to_delete_)));
          set_has_max_entries_to_delete();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:cockroach.proto.DeleteRangeRequest)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:cockroach.proto.DeleteRangeRequest)
  return false;
#undef DO_
}

void DeleteRangeRequest::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:cockroach.proto.DeleteRangeRequest)
  // optional .cockroach.proto.RequestHeader header = 1;
  if (has_header()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->header_, output);
  }

  // optional int64 max_entries_to_delete = 2;
  if (has_max_entries_to_delete()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(2, this->max_entries_to_delete(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:cockroach.proto.DeleteRangeRequest)
}

::google::protobuf::uint8* DeleteRangeRequest::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:cockroach.proto.DeleteRangeRequest)
  // optional .cockroach.proto.RequestHeader header = 1;
  if (has_header()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, *this->header_, target);
  }

  // optional int64 max_entries_to_delete = 2;
  if (has_max_entries_to_delete()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(2, this->max_entries_to_delete(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:cockroach.proto.DeleteRangeRequest)
  return target;
}

int DeleteRangeRequest::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & 3) {
    // optional .cockroach.proto.RequestHeader header = 1;
    if (has_header()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->header_);
    }

    // optional int64 max_entries_to_delete = 2;
    if (has_max_entries_to_delete()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->max_entries_to_delete());
    }

  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void DeleteRangeRequest::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const DeleteRangeRequest* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const DeleteRangeRequest>(
          &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void DeleteRangeRequest::MergeFrom(const DeleteRangeRequest& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_header()) {
      mutable_header()->::cockroach::proto::RequestHeader::MergeFrom(from.header());
    }
    if (from.has_max_entries_to_delete()) {
      set_max_entries_to_delete(from.max_entries_to_delete());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void DeleteRangeRequest::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void DeleteRangeRequest::CopyFrom(const DeleteRangeRequest& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DeleteRangeRequest::IsInitialized() const {

  return true;
}

void DeleteRangeRequest::Swap(DeleteRangeRequest* other) {
  if (other == this) return;
  InternalSwap(other);
}
void DeleteRangeRequest::InternalSwap(DeleteRangeRequest* other) {
  std::swap(header_, other->header_);
  std::swap(max_entries_to_delete_, other->max_entries_to_delete_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata DeleteRangeRequest::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = DeleteRangeRequest_descriptor_;
  metadata.reflection = DeleteRangeRequest_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// DeleteRangeRequest

// optional .cockroach.proto.RequestHeader header = 1;
bool DeleteRangeRequest::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void DeleteRangeRequest::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
void DeleteRangeRequest::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
void DeleteRangeRequest::clear_header() {
  if (header_ != NULL) header_->::cockroach::proto::RequestHeader::Clear();
  clear_has_header();
}
 const ::cockroach::proto::RequestHeader& DeleteRangeRequest::header() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.DeleteRangeRequest.header)
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
 ::cockroach::proto::RequestHeader* DeleteRangeRequest::mutable_header() {
  set_has_header();
  if (header_ == NULL) {
    header_ = new ::cockroach::proto::RequestHeader;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.proto.DeleteRangeRequest.header)
  return header_;
}
 ::cockroach::proto::RequestHeader* DeleteRangeRequest::release_header() {
  clear_has_header();
  ::cockroach::proto::RequestHeader* temp = header_;
  header_ = NULL;
  return temp;
}
 void DeleteRangeRequest::set_allocated_header(::cockroach::proto::RequestHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.DeleteRangeRequest.header)
}

// optional int64 max_entries_to_delete = 2;
bool DeleteRangeRequest::has_max_entries_to_delete() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void DeleteRangeRequest::set_has_max_entries_to_delete() {
  _has_bits_[0] |= 0x00000002u;
}
void DeleteRangeRequest::clear_has_max_entries_to_delete() {
  _has_bits_[0] &= ~0x00000002u;
}
void DeleteRangeRequest::clear_max_entries_to_delete() {
  max_entries_to_delete_ = GOOGLE_LONGLONG(0);
  clear_has_max_entries_to_delete();
}
 ::google::protobuf::int64 DeleteRangeRequest::max_entries_to_delete() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.DeleteRangeRequest.max_entries_to_delete)
  return max_entries_to_delete_;
}
 void DeleteRangeRequest::set_max_entries_to_delete(::google::protobuf::int64 value) {
  set_has_max_entries_to_delete();
  max_entries_to_delete_ = value;
  // @@protoc_insertion_point(field_set:cockroach.proto.DeleteRangeRequest.max_entries_to_delete)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#ifndef _MSC_VER
const int DeleteRangeResponse::kHeaderFieldNumber;
const int DeleteRangeResponse::kNumDeletedFieldNumber;
#endif  // !_MSC_VER

DeleteRangeResponse::DeleteRangeResponse()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:cockroach.proto.DeleteRangeResponse)
}

void DeleteRangeResponse::InitAsDefaultInstance() {
  header_ = const_cast< ::cockroach::proto::ResponseHeader*>(&::cockroach::proto::ResponseHeader::default_instance());
}

DeleteRangeResponse::DeleteRangeResponse(const DeleteRangeResponse& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:cockroach.proto.DeleteRangeResponse)
}

void DeleteRangeResponse::SharedCtor() {
  _cached_size_ = 0;
  header_ = NULL;
  num_deleted_ = GOOGLE_LONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

DeleteRangeResponse::~DeleteRangeResponse() {
  // @@protoc_insertion_point(destructor:cockroach.proto.DeleteRangeResponse)
  SharedDtor();
}

void DeleteRangeResponse::SharedDtor() {
  if (this != default_instance_) {
    delete header_;
  }
}

void DeleteRangeResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* DeleteRangeResponse::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return DeleteRangeResponse_descriptor_;
}

const DeleteRangeResponse& DeleteRangeResponse::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_cockroach_2fproto_2fapi_2eproto();
  return *default_instance_;
}

DeleteRangeResponse* DeleteRangeResponse::default_instance_ = NULL;

DeleteRangeResponse* DeleteRangeResponse::New(::google::protobuf::Arena* arena) const {
  DeleteRangeResponse* n = new DeleteRangeResponse;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void DeleteRangeResponse::Clear() {
  if (_has_bits_[0 / 32] & 3u) {
    if (has_header()) {
      if (header_ != NULL) header_->::cockroach::proto::ResponseHeader::Clear();
    }
    num_deleted_ = GOOGLE_LONGLONG(0);
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool DeleteRangeResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:cockroach.proto.DeleteRangeResponse)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .cockroach.proto.ResponseHeader header = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_header()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_num_deleted;
        break;
      }

      // optional int64 num_deleted = 2;
      case 2: {
        if (tag == 16) {
         parse_num_deleted:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &num_deleted_)));
          set_has_num_deleted();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:cockroach.proto.DeleteRangeResponse)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:cockroach.proto.DeleteRangeResponse)
  return false;
#undef DO_
}

void DeleteRangeResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:cockroach.proto.DeleteRangeResponse)
  // optional .cockroach.proto.ResponseHeader header = 1;
  if (has_header()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->header_, output);
  }

  // optional int64 num_deleted = 2;
  if (has_num_deleted()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(2, this->num_deleted(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:cockroach.proto.DeleteRangeResponse)
}

::google::protobuf::uint8* DeleteRangeResponse::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:cockroach.proto.DeleteRangeResponse)
  // optional .cockroach.proto.ResponseHeader header = 1;
  if (has_header()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, *this->header_, target);
  }

  // optional int64 num_deleted = 2;
  if (has_num_deleted()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(2, this->num_deleted(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:cockroach.proto.DeleteRangeResponse)
  return target;
}

int DeleteRangeResponse::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & 3) {
    // optional .cockroach.proto.ResponseHeader header = 1;
    if (has_header()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->header_);
    }

    // optional int64 num_deleted = 2;
    if (has_num_deleted()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->num_deleted());
    }

  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void DeleteRangeResponse::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const DeleteRangeResponse* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const DeleteRangeResponse>(
          &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void DeleteRangeResponse::MergeFrom(const DeleteRangeResponse& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_header()) {
      mutable_header()->::cockroach::proto::ResponseHeader::MergeFrom(from.header());
    }
    if (from.has_num_deleted()) {
      set_num_deleted(from.num_deleted());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void DeleteRangeResponse::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void DeleteRangeResponse::CopyFrom(const DeleteRangeResponse& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DeleteRangeResponse::IsInitialized() const {

  return true;
}

void DeleteRangeResponse::Swap(DeleteRangeResponse* other) {
  if (other == this) return;
  InternalSwap(other);
}
void DeleteRangeResponse::InternalSwap(DeleteRangeResponse* other) {
  std::swap(header_, other->header_);
  std::swap(num_deleted_, other->num_deleted_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata DeleteRangeResponse::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = DeleteRangeResponse_descriptor_;
  metadata.reflection = DeleteRangeResponse_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// DeleteRangeResponse

// optional .cockroach.proto.ResponseHeader header = 1;
bool DeleteRangeResponse::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void DeleteRangeResponse::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
void DeleteRangeResponse::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
void DeleteRangeResponse::clear_header() {
  if (header_ != NULL) header_->::cockroach::proto::ResponseHeader::Clear();
  clear_has_header();
}
 const ::cockroach::proto::ResponseHeader& DeleteRangeResponse::header() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.DeleteRangeResponse.header)
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
 ::cockroach::proto::ResponseHeader* DeleteRangeResponse::mutable_header() {
  set_has_header();
  if (header_ == NULL) {
    header_ = new ::cockroach::proto::ResponseHeader;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.proto.DeleteRangeResponse.header)
  return header_;
}
 ::cockroach::proto::ResponseHeader* DeleteRangeResponse::release_header() {
  clear_has_header();
  ::cockroach::proto::ResponseHeader* temp = header_;
  header_ = NULL;
  return temp;
}
 void DeleteRangeResponse::set_allocated_header(::cockroach::proto::ResponseHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.DeleteRangeResponse.header)
}

// optional int64 num_deleted = 2;
bool DeleteRangeResponse::has_num_deleted() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void DeleteRangeResponse::set_has_num_deleted() {
  _has_bits_[0] |= 0x00000002u;
}
void DeleteRangeResponse::clear_has_num_deleted() {
  _has_bits_[0] &= ~0x00000002u;
}
void DeleteRangeResponse::clear_num_deleted() {
  num_deleted_ = GOOGLE_LONGLONG(0);
  clear_has_num_deleted();
}
 ::google::protobuf::int64 DeleteRangeResponse::num_deleted() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.DeleteRangeResponse.num_deleted)
  return num_deleted_;
}
 void DeleteRangeResponse::set_num_deleted(::google::protobuf::int64 value) {
  set_has_num_deleted();
  num_deleted_ = value;
  // @@protoc_insertion_point(field_set:cockroach.proto.DeleteRangeResponse.num_deleted)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#ifndef _MSC_VER
const int ScanRequest::kHeaderFieldNumber;
const int ScanRequest::kMaxResultsFieldNumber;
#endif  // !_MSC_VER

ScanRequest::ScanRequest()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:cockroach.proto.ScanRequest)
}

void ScanRequest::InitAsDefaultInstance() {
  header_ = const_cast< ::cockroach::proto::RequestHeader*>(&::cockroach::proto::RequestHeader::default_instance());
}

ScanRequest::ScanRequest(const ScanRequest& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:cockroach.proto.ScanRequest)
}

void ScanRequest::SharedCtor() {
  _cached_size_ = 0;
  header_ = NULL;
  max_results_ = GOOGLE_LONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ScanRequest::~ScanRequest() {
  // @@protoc_insertion_point(destructor:cockroach.proto.ScanRequest)
  SharedDtor();
}

void ScanRequest::SharedDtor() {
  if (this != default_instance_) {
    delete header_;
  }
}

void ScanRequest::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ScanRequest::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ScanRequest_descriptor_;
}

const ScanRequest& ScanRequest::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_cockroach_2fproto_2fapi_2eproto();
  return *default_instance_;
}

ScanRequest* ScanRequest::default_instance_ = NULL;

ScanRequest* ScanRequest::New(::google::protobuf::Arena* arena) const {
  ScanRequest* n = new ScanRequest;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void ScanRequest::Clear() {
  if (_has_bits_[0 / 32] & 3u) {
    if (has_header()) {
      if (header_ != NULL) header_->::cockroach::proto::RequestHeader::Clear();
    }
    max_results_ = GOOGLE_LONGLONG(0);
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool ScanRequest::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:cockroach.proto.ScanRequest)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .cockroach.proto.RequestHeader header = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_header()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_max_results;
        break;
      }

      // optional int64 max_results = 2;
      case 2: {
        if (tag == 16) {
         parse_max_results:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &max_results_)));
          set_has_max_results();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:cockroach.proto.ScanRequest)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:cockroach.proto.ScanRequest)
  return false;
#undef DO_
}

void ScanRequest::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:cockroach.proto.ScanRequest)
  // optional .cockroach.proto.RequestHeader header = 1;
  if (has_header()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->header_, output);
  }

  // optional int64 max_results = 2;
  if (has_max_results()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(2, this->max_results(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:cockroach.proto.ScanRequest)
}

::google::protobuf::uint8* ScanRequest::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:cockroach.proto.ScanRequest)
  // optional .cockroach.proto.RequestHeader header = 1;
  if (has_header()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, *this->header_, target);
  }

  // optional int64 max_results = 2;
  if (has_max_results()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(2, this->max_results(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:cockroach.proto.ScanRequest)
  return target;
}

int ScanRequest::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & 3) {
    // optional .cockroach.proto.RequestHeader header = 1;
    if (has_header()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->header_);
    }

    // optional int64 max_results = 2;
    if (has_max_results()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->max_results());
    }

  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ScanRequest::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const ScanRequest* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const ScanRequest>(
          &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ScanRequest::MergeFrom(const ScanRequest& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_header()) {
      mutable_header()->::cockroach::proto::RequestHeader::MergeFrom(from.header());
    }
    if (from.has_max_results()) {
      set_max_results(from.max_results());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void ScanRequest::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ScanRequest::CopyFrom(const ScanRequest& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ScanRequest::IsInitialized() const {

  return true;
}

void ScanRequest::Swap(ScanRequest* other) {
  if (other == this) return;
  InternalSwap(other);
}
void ScanRequest::InternalSwap(ScanRequest* other) {
  std::swap(header_, other->header_);
  std::swap(max_results_, other->max_results_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata ScanRequest::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ScanRequest_descriptor_;
  metadata.reflection = ScanRequest_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// ScanRequest

// optional .cockroach.proto.RequestHeader header = 1;
bool ScanRequest::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void ScanRequest::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
void ScanRequest::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
void ScanRequest::clear_header() {
  if (header_ != NULL) header_->::cockroach::proto::RequestHeader::Clear();
  clear_has_header();
}
 const ::cockroach::proto::RequestHeader& ScanRequest::header() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.ScanRequest.header)
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
 ::cockroach::proto::RequestHeader* ScanRequest::mutable_header() {
  set_has_header();
  if (header_ == NULL) {
    header_ = new ::cockroach::proto::RequestHeader;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.proto.ScanRequest.header)
  return header_;
}
 ::cockroach::proto::RequestHeader* ScanRequest::release_header() {
  clear_has_header();
  ::cockroach::proto::RequestHeader* temp = header_;
  header_ = NULL;
  return temp;
}
 void ScanRequest::set_allocated_header(::cockroach::proto::RequestHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.ScanRequest.header)
}

// optional int64 max_results = 2;
bool ScanRequest::has_max_results() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void ScanRequest::set_has_max_results() {
  _has_bits_[0] |= 0x00000002u;
}
void ScanRequest::clear_has_max_results() {
  _has_bits_[0] &= ~0x00000002u;
}
void ScanRequest::clear_max_results() {
  max_results_ = GOOGLE_LONGLONG(0);
  clear_has_max_results();
}
 ::google::protobuf::int64 ScanRequest::max_results() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.ScanRequest.max_results)
  return max_results_;
}
 void ScanRequest::set_max_results(::google::protobuf::int64 value) {
  set_has_max_results();
  max_results_ = value;
  // @@protoc_insertion_point(field_set:cockroach.proto.ScanRequest.max_results)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#ifndef _MSC_VER
const int ScanResponse::kHeaderFieldNumber;
const int ScanResponse::kRowsFieldNumber;
#endif  // !_MSC_VER

ScanResponse::ScanResponse()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:cockroach.proto.ScanResponse)
}

void ScanResponse::InitAsDefaultInstance() {
  header_ = const_cast< ::cockroach::proto::ResponseHeader*>(&::cockroach::proto::ResponseHeader::default_instance());
}

ScanResponse::ScanResponse(const ScanResponse& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:cockroach.proto.ScanResponse)
}

void ScanResponse::SharedCtor() {
  _cached_size_ = 0;
  header_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ScanResponse::~ScanResponse() {
  // @@protoc_insertion_point(destructor:cockroach.proto.ScanResponse)
  SharedDtor();
}

void ScanResponse::SharedDtor() {
  if (this != default_instance_) {
    delete header_;
  }
}

void ScanResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ScanResponse::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ScanResponse_descriptor_;
}

const ScanResponse& ScanResponse::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_cockroach_2fproto_2fapi_2eproto();
  return *default_instance_;
}

ScanResponse* ScanResponse::default_instance_ = NULL;

ScanResponse* ScanResponse::New(::google::protobuf::Arena* arena) const {
  ScanResponse* n = new ScanResponse;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void ScanResponse::Clear() {
  if (has_header()) {
    if (header_ != NULL) header_->::cockroach::proto::ResponseHeader::Clear();
  }
  rows_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool ScanResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:cockroach.proto.ScanResponse)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .cockroach.proto.ResponseHeader header = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_header()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_rows;
        break;
      }

      // repeated .cockroach.proto.KeyValue rows = 2;
      case 2: {
        if (tag == 18) {
         parse_rows:
          DO_(input->IncrementRecursionDepth());
         parse_loop_rows:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                input, add_rows()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_loop_rows;
        input->UnsafeDecrementRecursionDepth();
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:cockroach.proto.ScanResponse)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:cockroach.proto.ScanResponse)
  return false;
#undef DO_
}

void ScanResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:cockroach.proto.ScanResponse)
  // optional .cockroach.proto.ResponseHeader header = 1;
  if (has_header()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->header_, output);
  }

  // repeated .cockroach.proto.KeyValue rows = 2;
  for (unsigned int i = 0, n = this->rows_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->rows(i), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:cockroach.proto.ScanResponse)
}

::google::protobuf::uint8* ScanResponse::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:cockroach.proto.ScanResponse)
  // optional .cockroach.proto.ResponseHeader header = 1;
  if (has_header()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, *this->header_, target);
  }

  // repeated .cockroach.proto.KeyValue rows = 2;
  for (unsigned int i = 0, n = this->rows_size(); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->rows(i), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:cockroach.proto.ScanResponse)
  return target;
}

int ScanResponse::ByteSize() const {
  int total_size = 0;

  // optional .cockroach.proto.ResponseHeader header = 1;
  if (has_header()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->header_);
  }

  // repeated .cockroach.proto.KeyValue rows = 2;
  total_size += 1 * this->rows_size();
  for (int i = 0; i < this->rows_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->rows(i));
  }

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ScanResponse::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const ScanResponse* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const ScanResponse>(
          &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ScanResponse::MergeFrom(const ScanResponse& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  rows_.MergeFrom(from.rows_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_header()) {
      mutable_header()->::cockroach::proto::ResponseHeader::MergeFrom(from.header());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void ScanResponse::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ScanResponse::CopyFrom(const ScanResponse& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ScanResponse::IsInitialized() const {

  return true;
}

void ScanResponse::Swap(ScanResponse* other) {
  if (other == this) return;
  InternalSwap(other);
}
void ScanResponse::InternalSwap(ScanResponse* other) {
  std::swap(header_, other->header_);
  rows_.UnsafeArenaSwap(&other->rows_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata ScanResponse::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ScanResponse_descriptor_;
  metadata.reflection = ScanResponse_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// ScanResponse

// optional .cockroach.proto.ResponseHeader header = 1;
bool ScanResponse::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void ScanResponse::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
void ScanResponse::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
void ScanResponse::clear_header() {
  if (header_ != NULL) header_->::cockroach::proto::ResponseHeader::Clear();
  clear_has_header();
}
 const ::cockroach::proto::ResponseHeader& ScanResponse::header() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.ScanResponse.header)
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
 ::cockroach::proto::ResponseHeader* ScanResponse::mutable_header() {
  set_has_header();
  if (header_ == NULL) {
    header_ = new ::cockroach::proto::ResponseHeader;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.proto.ScanResponse.header)
  return header_;
}
 ::cockroach::proto::ResponseHeader* ScanResponse::release_header() {
  clear_has_header();
  ::cockroach::proto::ResponseHeader* temp = header_;
  header_ = NULL;
  return temp;
}
 void ScanResponse::set_allocated_header(::cockroach::proto::ResponseHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.ScanResponse.header)
}

// repeated .cockroach.proto.KeyValue rows = 2;
int ScanResponse::rows_size() const {
  return rows_.size();
}
void ScanResponse::clear_rows() {
  rows_.Clear();
}
 const ::cockroach::proto::KeyValue& ScanResponse::rows(int index) const {
  // @@protoc_insertion_point(field_get:cockroach.proto.ScanResponse.rows)
  return rows_.Get(index);
}
 ::cockroach::proto::KeyValue* ScanResponse::mutable_rows(int index) {
  // @@protoc_insertion_point(field_mutable:cockroach.proto.ScanResponse.rows)
  return rows_.Mutable(index);
}
 ::cockroach::proto::KeyValue* ScanResponse::add_rows() {
  // @@protoc_insertion_point(field_add:cockroach.proto.ScanResponse.rows)
  return rows_.Add();
}
 const ::google::protobuf::RepeatedPtrField< ::cockroach::proto::KeyValue >&
ScanResponse::rows() const {
  // @@protoc_insertion_point(field_list:cockroach.proto.ScanResponse.rows)
  return rows_;
}
 ::google::protobuf::RepeatedPtrField< ::cockroach::proto::KeyValue >*
ScanResponse::mutable_rows() {
  // @@protoc_insertion_point(field_mutable_list:cockroach.proto.ScanResponse.rows)
  return &rows_;
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#ifndef _MSC_VER
const int ReverseScanRequest::kHeaderFieldNumber;
const int ReverseScanRequest::kMaxResultsFieldNumber;
#endif  // !_MSC_VER

ReverseScanRequest::ReverseScanRequest()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:cockroach.proto.ReverseScanRequest)
}

void ReverseScanRequest::InitAsDefaultInstance() {
  header_ = const_cast< ::cockroach::proto::RequestHeader*>(&::cockroach::proto::RequestHeader::default_instance());
}

ReverseScanRequest::ReverseScanRequest(const ReverseScanRequest& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:cockroach.proto.ReverseScanRequest)
}

void ReverseScanRequest::SharedCtor() {
  _cached_size_ = 0;
  header_ = NULL;
  max_results_ = GOOGLE_LONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ReverseScanRequest::~ReverseScanRequest() {
  // @@protoc_insertion_point(destructor:cockroach.proto.ReverseScanRequest)
  SharedDtor();
}

void ReverseScanRequest::SharedDtor() {
  if (this != default_instance_) {
    delete header_;
  }
}

void ReverseScanRequest::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ReverseScanRequest::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ReverseScanRequest_descriptor_;
}

const ReverseScanRequest& ReverseScanRequest::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_cockroach_2fproto_2fapi_2eproto();
  return *default_instance_;
}

ReverseScanRequest* ReverseScanRequest::default_instance_ = NULL;

ReverseScanRequest* ReverseScanRequest::New(::google::protobuf::Arena* arena) const {
  ReverseScanRequest* n = new ReverseScanRequest;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void ReverseScanRequest::Clear() {
  if (_has_bits_[0 / 32] & 3u) {
    if (has_header()) {
      if (header_ != NULL) header_->::cockroach::proto::RequestHeader::Clear();
    }
    max_results_ = GOOGLE_LONGLONG(0);
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool ReverseScanRequest::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:cockroach.proto.ReverseScanRequest)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .cockroach.proto.RequestHeader header = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_header()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_max_results;
        break;
      }

      // optional int64 max_results = 2;
      case 2: {
        if (tag == 16) {
         parse_max_results:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &max_results_)));
          set_has_max_results();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:cockroach.proto.ReverseScanRequest)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:cockroach.proto.ReverseScanRequest)
  return false;
#undef DO_
}

void ReverseScanRequest::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:cockroach.proto.ReverseScanRequest)
  // optional .cockroach.proto.RequestHeader header = 1;
  if (has_header()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->header_, output);
  }

  // optional int64 max_results = 2;
  if (has_max_results()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(2, this->max_results(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:cockroach.proto.ReverseScanRequest)
}

::google::protobuf::uint8* ReverseScanRequest::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:cockroach.proto.ReverseScanRequest)
  // optional .cockroach.proto.RequestHeader header = 1;
  if (has_header()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, *this->header_, target);
  }

  // optional int64 max_results = 2;
  if (has_max_results()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(2, this->max_results(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:cockroach.proto.ReverseScanRequest)
  return target;
}

int ReverseScanRequest::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & 3) {
    // optional .cockroach.proto.RequestHeader header = 1;
    if (has_header()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->header_);
    }

    // optional int64 max_results = 2;
    if (has_max_results()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->max_results());
    }

  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ReverseScanRequest::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const ReverseScanRequest* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const ReverseScanRequest>(
          &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ReverseScanRequest::MergeFrom(const ReverseScanRequest& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_header()) {
      mutable_header()->::cockroach::proto::RequestHeader::MergeFrom(from.header());
    }
    if (from.has_max_results()) {
      set_max_results(from.max_results());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void ReverseScanRequest::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ReverseScanRequest::CopyFrom(const ReverseScanRequest& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ReverseScanRequest::IsInitialized() const {

  return true;
}

void ReverseScanRequest::Swap(ReverseScanRequest* other) {
  if (other == this) return;
  InternalSwap(other);
}
void ReverseScanRequest::InternalSwap(ReverseScanRequest* other) {
  std::swap(header_, other->header_);
  std::swap(max_results_, other->max_results_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata ReverseScanRequest::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ReverseScanRequest_descriptor_;
  metadata.reflection = ReverseScanRequest_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// ReverseScanRequest

// optional .cockroach.proto.RequestHeader header = 1;
bool ReverseScanRequest::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void ReverseScanRequest::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
void ReverseScanRequest::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
void ReverseScanRequest::clear_header() {
  if (header_ != NULL) header_->::cockroach::proto::RequestHeader::Clear();
  clear_has_header();
}
 const ::cockroach::proto::RequestHeader& ReverseScanRequest::header() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.ReverseScanRequest.header)
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
 ::cockroach::proto::RequestHeader* ReverseScanRequest::mutable_header() {
  set_has_header();
  if (header_ == NULL) {
    header_ = new ::cockroach::proto::RequestHeader;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.proto.ReverseScanRequest.header)
  return header_;
}
 ::cockroach::proto::RequestHeader* ReverseScanRequest::release_header() {
  clear_has_header();
  ::cockroach::proto::RequestHeader* temp = header_;
  header_ = NULL;
  return temp;
}
 void ReverseScanRequest::set_allocated_header(::cockroach::proto::RequestHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.ReverseScanRequest.header)
}

// optional int64 max_results = 2;
bool ReverseScanRequest::has_max_results() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void ReverseScanRequest::set_has_max_results() {
  _has_bits_[0] |= 0x00000002u;
}
void ReverseScanRequest::clear_has_max_results() {
  _has_bits_[0] &= ~0x00000002u;
}
void ReverseScanRequest::clear_max_results() {
  max_results_ = GOOGLE_LONGLONG(0);
  clear_has_max_results();
}
 ::google::protobuf::int64 ReverseScanRequest::max_results() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.ReverseScanRequest.max_results)
  return max_results_;
}
 void ReverseScanRequest::set_max_results(::google::protobuf::int64 value) {
  set_has_max_results();
  max_results_ = value;
  // @@protoc_insertion_point(field_set:cockroach.proto.ReverseScanRequest.max_results)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#ifndef _MSC_VER
const int ReverseScanResponse::kHeaderFieldNumber;
const int ReverseScanResponse::kRowsFieldNumber;
#endif  // !_MSC_VER

ReverseScanResponse::ReverseScanResponse()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:cockroach.proto.ReverseScanResponse)
}

void ReverseScanResponse::InitAsDefaultInstance() {
  header_ = const_cast< ::cockroach::proto::ResponseHeader*>(&::cockroach::proto::ResponseHeader::default_instance());
}

ReverseScanResponse::ReverseScanResponse(const ReverseScanResponse& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:cockroach.proto.ReverseScanResponse)
}

void ReverseScanResponse::SharedCtor() {
  _cached_size_ = 0;
  header_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ReverseScanResponse::~ReverseScanResponse() {
  // @@protoc_insertion_point(destructor:cockroach.proto.ReverseScanResponse)
  SharedDtor();
}

void ReverseScanResponse::SharedDtor() {
  if (this != default_instance_) {
    delete header_;
  }
}

void ReverseScanResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ReverseScanResponse::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ReverseScanResponse_descriptor_;
}

const ReverseScanResponse& ReverseScanResponse::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_cockroach_2fproto_2fapi_2eproto();
  return *default_instance_;
}

ReverseScanResponse* ReverseScanResponse::default_instance_ = NULL;

ReverseScanResponse* ReverseScanResponse::New(::google::protobuf::Arena* arena) const {
  ReverseScanResponse* n = new ReverseScanResponse;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void ReverseScanResponse::Clear() {
  if (has_header()) {
    if (header_ != NULL) header_->::cockroach::proto::ResponseHeader::Clear();
  }
  rows_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool ReverseScanResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:cockroach.proto.ReverseScanResponse)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .cockroach.proto.ResponseHeader header = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_header()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_rows;
        break;
      }

      // repeated .cockroach.proto.KeyValue rows = 2;
      case 2: {
        if (tag == 18) {
         parse_rows:
          DO_(input->IncrementRecursionDepth());
         parse_loop_rows:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                input, add_rows()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_loop_rows;
        input->UnsafeDecrementRecursionDepth();
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:cockroach.proto.ReverseScanResponse)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:cockroach.proto.ReverseScanResponse)
  return false;
#undef DO_
}

void ReverseScanResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:cockroach.proto.ReverseScanResponse)
  // optional .cockroach.proto.ResponseHeader header = 1;
  if (has_header()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->header_, output);
  }

  // repeated .cockroach.proto.KeyValue rows = 2;
  for (unsigned int i = 0, n = this->rows_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->rows(i), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:cockroach.proto.ReverseScanResponse)
}

::google::protobuf::uint8* ReverseScanResponse::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:cockroach.proto.ReverseScanResponse)
  // optional .cockroach.proto.ResponseHeader header = 1;
  if (has_header()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, *this->header_, target);
  }

  // repeated .cockroach.proto.KeyValue rows = 2;
  for (unsigned int i = 0, n = this->rows_size(); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->rows(i), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:cockroach.proto.ReverseScanResponse)
  return target;
}

int ReverseScanResponse::ByteSize() const {
  int total_size = 0;

  // optional .cockroach.proto.ResponseHeader header = 1;
  if (has_header()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->header_);
  }

  // repeated .cockroach.proto.KeyValue rows = 2;
  total_size += 1 * this->rows_size();
  for (int i = 0; i < this->rows_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->rows(i));
  }

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ReverseScanResponse::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const ReverseScanResponse* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const ReverseScanResponse>(
          &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ReverseScanResponse::MergeFrom(const ReverseScanResponse& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  rows_.MergeFrom(from.rows_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_header()) {
      mutable_header()->::cockroach::proto::ResponseHeader::MergeFrom(from.header());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void ReverseScanResponse::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ReverseScanResponse::CopyFrom(const ReverseScanResponse& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ReverseScanResponse::IsInitialized() const {

  return true;
}

void ReverseScanResponse::Swap(ReverseScanResponse* other) {
  if (other == this) return;
  InternalSwap(other);
}
void ReverseScanResponse::InternalSwap(ReverseScanResponse* other) {
  std::swap(header_, other->header_);
  rows_.UnsafeArenaSwap(&other->rows_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata ReverseScanResponse::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ReverseScanResponse_descriptor_;
  metadata.reflection = ReverseScanResponse_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// ReverseScanResponse

// optional .cockroach.proto.ResponseHeader header = 1;
bool ReverseScanResponse::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void ReverseScanResponse::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
void ReverseScanResponse::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
void ReverseScanResponse::clear_header() {
  if (header_ != NULL) header_->::cockroach::proto::ResponseHeader::Clear();
  clear_has_header();
}
 const ::cockroach::proto::ResponseHeader& ReverseScanResponse::header() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.ReverseScanResponse.header)
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
 ::cockroach::proto::ResponseHeader* ReverseScanResponse::mutable_header() {
  set_has_header();
  if (header_ == NULL) {
    header_ = new ::cockroach::proto::ResponseHeader;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.proto.ReverseScanResponse.header)
  return header_;
}
 ::cockroach::proto::ResponseHeader* ReverseScanResponse::release_header() {
  clear_has_header();
  ::cockroach::proto::ResponseHeader* temp = header_;
  header_ = NULL;
  return temp;
}
 void ReverseScanResponse::set_allocated_header(::cockroach::proto::ResponseHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.ReverseScanResponse.header)
}

// repeated .cockroach.proto.KeyValue rows = 2;
int ReverseScanResponse::rows_size() const {
  return rows_.size();
}
void ReverseScanResponse::clear_rows() {
  rows_.Clear();
}
 const ::cockroach::proto::KeyValue& ReverseScanResponse::rows(int index) const {
  // @@protoc_insertion_point(field_get:cockroach.proto.ReverseScanResponse.rows)
  return rows_.Get(index);
}
 ::cockroach::proto::KeyValue* ReverseScanResponse::mutable_rows(int index) {
  // @@protoc_insertion_point(field_mutable:cockroach.proto.ReverseScanResponse.rows)
  return rows_.Mutable(index);
}
 ::cockroach::proto::KeyValue* ReverseScanResponse::add_rows() {
  // @@protoc_insertion_point(field_add:cockroach.proto.ReverseScanResponse.rows)
  return rows_.Add();
}
 const ::google::protobuf::RepeatedPtrField< ::cockroach::proto::KeyValue >&
ReverseScanResponse::rows() const {
  // @@protoc_insertion_point(field_list:cockroach.proto.ReverseScanResponse.rows)
  return rows_;
}
 ::google::protobuf::RepeatedPtrField< ::cockroach::proto::KeyValue >*
ReverseScanResponse::mutable_rows() {
  // @@protoc_insertion_point(field_mutable_list:cockroach.proto.ReverseScanResponse.rows)
  return &rows_;
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#ifndef _MSC_VER
const int EndTransactionRequest::kHeaderFieldNumber;
const int EndTransactionRequest::kCommitFieldNumber;
const int EndTransactionRequest::kInternalCommitTriggerFieldNumber;
const int EndTransactionRequest::kIntentsFieldNumber;
#endif  // !_MSC_VER

EndTransactionRequest::EndTransactionRequest()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:cockroach.proto.EndTransactionRequest)
}

void EndTransactionRequest::InitAsDefaultInstance() {
  header_ = const_cast< ::cockroach::proto::RequestHeader*>(&::cockroach::proto::RequestHeader::default_instance());
  internal_commit_trigger_ = const_cast< ::cockroach::proto::InternalCommitTrigger*>(&::cockroach::proto::InternalCommitTrigger::default_instance());
}

EndTransactionRequest::EndTransactionRequest(const EndTransactionRequest& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:cockroach.proto.EndTransactionRequest)
}

void EndTransactionRequest::SharedCtor() {
  _cached_size_ = 0;
  header_ = NULL;
  commit_ = false;
  internal_commit_trigger_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

EndTransactionRequest::~EndTransactionRequest() {
  // @@protoc_insertion_point(destructor:cockroach.proto.EndTransactionRequest)
  SharedDtor();
}

void EndTransactionRequest::SharedDtor() {
  if (this != default_instance_) {
    delete header_;
    delete internal_commit_trigger_;
  }
}

void EndTransactionRequest::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* EndTransactionRequest::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return EndTransactionRequest_descriptor_;
}

const EndTransactionRequest& EndTransactionRequest::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_cockroach_2fproto_2fapi_2eproto();
  return *default_instance_;
}

EndTransactionRequest* EndTransactionRequest::default_instance_ = NULL;

EndTransactionRequest* EndTransactionRequest::New(::google::protobuf::Arena* arena) const {
  EndTransactionRequest* n = new EndTransactionRequest;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void EndTransactionRequest::Clear() {
  if (_has_bits_[0 / 32] & 7u) {
    if (has_header()) {
      if (header_ != NULL) header_->::cockroach::proto::RequestHeader::Clear();
    }
    commit_ = false;
    if (has_internal_commit_trigger()) {
      if (internal_commit_trigger_ != NULL) internal_commit_trigger_->::cockroach::proto::InternalCommitTrigger::Clear();
    }
  }
  intents_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool EndTransactionRequest::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:cockroach.proto.EndTransactionRequest)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .cockroach.proto.RequestHeader header = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_header()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_commit;
        break;
      }

      // optional bool commit = 2;
      case 2: {
        if (tag == 16) {
         parse_commit:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &commit_)));
          set_has_commit();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_internal_commit_trigger;
        break;
      }

      // optional .cockroach.proto.InternalCommitTrigger internal_commit_trigger = 3;
      case 3: {
        if (tag == 26) {
         parse_internal_commit_trigger:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_internal_commit_trigger()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_intents;
        break;
      }

      // repeated .cockroach.proto.Intent intents = 4;
      case 4: {
        if (tag == 34) {
         parse_intents:
          DO_(input->IncrementRecursionDepth());
         parse_loop_intents:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                input, add_intents()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_loop_intents;
        input->UnsafeDecrementRecursionDepth();
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:cockroach.proto.EndTransactionRequest)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:cockroach.proto.EndTransactionRequest)
  return false;
#undef DO_
}

void EndTransactionRequest::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:cockroach.proto.EndTransactionRequest)
  // optional .cockroach.proto.RequestHeader header = 1;
  if (has_header()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->header_, output);
  }

  // optional bool commit = 2;
  if (has_commit()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(2, this->commit(), output);
  }

  // optional .cockroach.proto.InternalCommitTrigger internal_commit_trigger = 3;
  if (has_internal_commit_trigger()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, *this->internal_commit_trigger_, output);
  }

  // repeated .cockroach.proto.Intent intents = 4;
  for (unsigned int i = 0, n = this->intents_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, this->intents(i), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:cockroach.proto.EndTransactionRequest)
}

::google::protobuf::uint8* EndTransactionRequest::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:cockroach.proto.EndTransactionRequest)
  // optional .cockroach.proto.RequestHeader header = 1;
  if (has_header()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, *this->header_, target);
  }

  // optional bool commit = 2;
  if (has_commit()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(2, this->commit(), target);
  }

  // optional .cockroach.proto.InternalCommitTrigger internal_commit_trigger = 3;
  if (has_internal_commit_trigger()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, *this->internal_commit_trigger_, target);
  }

  // repeated .cockroach.proto.Intent intents = 4;
  for (unsigned int i = 0, n = this->intents_size(); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        4, this->intents(i), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:cockroach.proto.EndTransactionRequest)
  return target;
}

int EndTransactionRequest::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & 7) {
    // optional .cockroach.proto.RequestHeader header = 1;
    if (has_header()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->header_);
    }

    // optional bool commit = 2;
    if (has_commit()) {
      total_size += 1 + 1;
    }

    // optional .cockroach.proto.InternalCommitTrigger internal_commit_trigger = 3;
    if (has_internal_commit_trigger()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->internal_commit_trigger_);
    }

  }
  // repeated .cockroach.proto.Intent intents = 4;
  total_size += 1 * this->intents_size();
  for (int i = 0; i < this->intents_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->intents(i));
  }

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void EndTransactionRequest::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const EndTransactionRequest* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const EndTransactionRequest>(
          &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void EndTransactionRequest::MergeFrom(const EndTransactionRequest& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  intents_.MergeFrom(from.intents_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_header()) {
      mutable_header()->::cockroach::proto::RequestHeader::MergeFrom(from.header());
    }
    if (from.has_commit()) {
      set_commit(from.commit());
    }
    if (from.has_internal_commit_trigger()) {
      mutable_internal_commit_trigger()->::cockroach::proto::InternalCommitTrigger::MergeFrom(from.internal_commit_trigger());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void EndTransactionRequest::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void EndTransactionRequest::CopyFrom(const EndTransactionRequest& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EndTransactionRequest::IsInitialized() const {

  return true;
}

void EndTransactionRequest::Swap(EndTransactionRequest* other) {
  if (other == this) return;
  InternalSwap(other);
}
void EndTransactionRequest::InternalSwap(EndTransactionRequest* other) {
  std::swap(header_, other->header_);
  std::swap(commit_, other->commit_);
  std::swap(internal_commit_trigger_, other->internal_commit_trigger_);
  intents_.UnsafeArenaSwap(&other->intents_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata EndTransactionRequest::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = EndTransactionRequest_descriptor_;
  metadata.reflection = EndTransactionRequest_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// EndTransactionRequest

// optional .cockroach.proto.RequestHeader header = 1;
bool EndTransactionRequest::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void EndTransactionRequest::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
void EndTransactionRequest::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
void EndTransactionRequest::clear_header() {
  if (header_ != NULL) header_->::cockroach::proto::RequestHeader::Clear();
  clear_has_header();
}
 const ::cockroach::proto::RequestHeader& EndTransactionRequest::header() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.EndTransactionRequest.header)
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
 ::cockroach::proto::RequestHeader* EndTransactionRequest::mutable_header() {
  set_has_header();
  if (header_ == NULL) {
    header_ = new ::cockroach::proto::RequestHeader;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.proto.EndTransactionRequest.header)
  return header_;
}
 ::cockroach::proto::RequestHeader* EndTransactionRequest::release_header() {
  clear_has_header();
  ::cockroach::proto::RequestHeader* temp = header_;
  header_ = NULL;
  return temp;
}
 void EndTransactionRequest::set_allocated_header(::cockroach::proto::RequestHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.EndTransactionRequest.header)
}

// optional bool commit = 2;
bool EndTransactionRequest::has_commit() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void EndTransactionRequest::set_has_commit() {
  _has_bits_[0] |= 0x00000002u;
}
void EndTransactionRequest::clear_has_commit() {
  _has_bits_[0] &= ~0x00000002u;
}
void EndTransactionRequest::clear_commit() {
  commit_ = false;
  clear_has_commit();
}
 bool EndTransactionRequest::commit() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.EndTransactionRequest.commit)
  return commit_;
}
 void EndTransactionRequest::set_commit(bool value) {
  set_has_commit();
  commit_ = value;
  // @@protoc_insertion_point(field_set:cockroach.proto.EndTransactionRequest.commit)
}

// optional .cockroach.proto.InternalCommitTrigger internal_commit_trigger = 3;
bool EndTransactionRequest::has_internal_commit_trigger() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void EndTransactionRequest::set_has_internal_commit_trigger() {
  _has_bits_[0] |= 0x00000004u;
}
void EndTransactionRequest::clear_has_internal_commit_trigger() {
  _has_bits_[0] &= ~0x00000004u;
}
void EndTransactionRequest::clear_internal_commit_trigger() {
  if (internal_commit_trigger_ != NULL) internal_commit_trigger_->::cockroach::proto::InternalCommitTrigger::Clear();
  clear_has_internal_commit_trigger();
}
 const ::cockroach::proto::InternalCommitTrigger& EndTransactionRequest::internal_commit_trigger() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.EndTransactionRequest.internal_commit_trigger)
  return internal_commit_trigger_ != NULL ? *internal_commit_trigger_ : *default_instance_->internal_commit_trigger_;
}
 ::cockroach::proto::InternalCommitTrigger* EndTransactionRequest::mutable_internal_commit_trigger() {
  set_has_internal_commit_trigger();
  if (internal_commit_trigger_ == NULL) {
    internal_commit_trigger_ = new ::cockroach::proto::InternalCommitTrigger;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.proto.EndTransactionRequest.internal_commit_trigger)
  return internal_commit_trigger_;
}
 ::cockroach::proto::InternalCommitTrigger* EndTransactionRequest::release_internal_commit_trigger() {
  clear_has_internal_commit_trigger();
  ::cockroach::proto::InternalCommitTrigger* temp = internal_commit_trigger_;
  internal_commit_trigger_ = NULL;
  return temp;
}
 void EndTransactionRequest::set_allocated_internal_commit_trigger(::cockroach::proto::InternalCommitTrigger* internal_commit_trigger) {
  delete internal_commit_trigger_;
  internal_commit_trigger_ = internal_commit_trigger;
  if (internal_commit_trigger) {
    set_has_internal_commit_trigger();
  } else {
    clear_has_internal_commit_trigger();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.EndTransactionRequest.internal_commit_trigger)
}

// repeated .cockroach.proto.Intent intents = 4;
int EndTransactionRequest::intents_size() const {
  return intents_.size();
}
void EndTransactionRequest::clear_intents() {
  intents_.Clear();
}
 const ::cockroach::proto::Intent& EndTransactionRequest::intents(int index) const {
  // @@protoc_insertion_point(field_get:cockroach.proto.EndTransactionRequest.intents)
  return intents_.Get(index);
}
 ::cockroach::proto::Intent* EndTransactionRequest::mutable_intents(int index) {
  // @@protoc_insertion_point(field_mutable:cockroach.proto.EndTransactionRequest.intents)
  return intents_.Mutable(index);
}
 ::cockroach::proto::Intent* EndTransactionRequest::add_intents() {
  // @@protoc_insertion_point(field_add:cockroach.proto.EndTransactionRequest.intents)
  return intents_.Add();
}
 const ::google::protobuf::RepeatedPtrField< ::cockroach::proto::Intent >&
EndTransactionRequest::intents() const {
  // @@protoc_insertion_point(field_list:cockroach.proto.EndTransactionRequest.intents)
  return intents_;
}
 ::google::protobuf::RepeatedPtrField< ::cockroach::proto::Intent >*
EndTransactionRequest::mutable_intents() {
  // @@protoc_insertion_point(field_mutable_list:cockroach.proto.EndTransactionRequest.intents)
  return &intents_;
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#ifndef _MSC_VER
const int EndTransactionResponse::kHeaderFieldNumber;
const int EndTransactionResponse::kCommitWaitFieldNumber;
const int EndTransactionResponse::kResolvedFieldNumber;
#endif  // !_MSC_VER

EndTransactionResponse::EndTransactionResponse()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:cockroach.proto.EndTransactionResponse)
}

void EndTransactionResponse::InitAsDefaultInstance() {
  header_ = const_cast< ::cockroach::proto::ResponseHeader*>(&::cockroach::proto::ResponseHeader::default_instance());
}

EndTransactionResponse::EndTransactionResponse(const EndTransactionResponse& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:cockroach.proto.EndTransactionResponse)
}

void EndTransactionResponse::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  header_ = NULL;
  commit_wait_ = GOOGLE_LONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

EndTransactionResponse::~EndTransactionResponse() {
  // @@protoc_insertion_point(destructor:cockroach.proto.EndTransactionResponse)
  SharedDtor();
}

void EndTransactionResponse::SharedDtor() {
  if (this != default_instance_) {
    delete header_;
  }
}

void EndTransactionResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* EndTransactionResponse::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return EndTransactionResponse_descriptor_;
}

const EndTransactionResponse& EndTransactionResponse::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_cockroach_2fproto_2fapi_2eproto();
  return *default_instance_;
}

EndTransactionResponse* EndTransactionResponse::default_instance_ = NULL;

EndTransactionResponse* EndTransactionResponse::New(::google::protobuf::Arena* arena) const {
  EndTransactionResponse* n = new EndTransactionResponse;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void EndTransactionResponse::Clear() {
  if (_has_bits_[0 / 32] & 3u) {
    if (has_header()) {
      if (header_ != NULL) header_->::cockroach::proto::ResponseHeader::Clear();
    }
    commit_wait_ = GOOGLE_LONGLONG(0);
  }
  resolved_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool EndTransactionResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:cockroach.proto.EndTransactionResponse)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .cockroach.proto.ResponseHeader header = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_header()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_commit_wait;
        break;
      }

      // optional int64 commit_wait = 2;
      case 2: {
        if (tag == 16) {
         parse_commit_wait:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &commit_wait_)));
          set_has_commit_wait();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_resolved;
        break;
      }

      // repeated bytes resolved = 3;
      case 3: {
        if (tag == 26) {
         parse_resolved:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->add_resolved()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_resolved;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:cockroach.proto.EndTransactionResponse)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:cockroach.proto.EndTransactionResponse)
  return false;
#undef DO_
}

void EndTransactionResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:cockroach.proto.EndTransactionResponse)
  // optional .cockroach.proto.ResponseHeader header = 1;
  if (has_header()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->header_, output);
  }

  // optional int64 commit_wait = 2;
  if (has_commit_wait()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(2, this->commit_wait(), output);
  }

  // repeated bytes resolved = 3;
  for (int i = 0; i < this->resolved_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      3, this->resolved(i), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:cockroach.proto.EndTransactionResponse)
}

::google::protobuf::uint8* EndTransactionResponse::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:cockroach.proto.EndTransactionResponse)
  // optional .cockroach.proto.ResponseHeader header = 1;
  if (has_header()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, *this->header_, target);
  }

  // optional int64 commit_wait = 2;
  if (has_commit_wait()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(2, this->commit_wait(), target);
  }

  // repeated bytes resolved = 3;
  for (int i = 0; i < this->resolved_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteBytesToArray(3, this->resolved(i), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:cockroach.proto.EndTransactionResponse)
  return target;
}

int EndTransactionResponse::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & 3) {
    // optional .cockroach.proto.ResponseHeader header = 1;
    if (has_header()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->header_);
    }

    // optional int64 commit_wait = 2;
    if (has_commit_wait()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->commit_wait());
    }

  }
  // repeated bytes resolved = 3;
  total_size += 1 * this->resolved_size();
  for (int i = 0; i < this->resolved_size(); i++) {
    total_size += ::google::protobuf::internal::WireFormatLite::BytesSize(
      this->resolved(i));
  }

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void EndTransactionResponse::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const EndTransactionResponse* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const EndTransactionResponse>(
          &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void EndTransactionResponse::MergeFrom(const EndTransactionResponse& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  resolved_.MergeFrom(from.resolved_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_header()) {
      mutable_header()->::cockroach::proto::ResponseHeader::MergeFrom(from.header());
    }
    if (from.has_commit_wait()) {
      set_commit_wait(from.commit_wait());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void EndTransactionResponse::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void EndTransactionResponse::CopyFrom(const EndTransactionResponse& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EndTransactionResponse::IsInitialized() const {

  return true;
}

void EndTransactionResponse::Swap(EndTransactionResponse* other) {
  if (other == this) return;
  InternalSwap(other);
}
void EndTransactionResponse::InternalSwap(EndTransactionResponse* other) {
  std::swap(header_, other->header_);
  std::swap(commit_wait_, other->commit_wait_);
  resolved_.UnsafeArenaSwap(&other->resolved_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata EndTransactionResponse::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = EndTransactionResponse_descriptor_;
  metadata.reflection = EndTransactionResponse_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// EndTransactionResponse

// optional .cockroach.proto.ResponseHeader header = 1;
bool EndTransactionResponse::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void EndTransactionResponse::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
void EndTransactionResponse::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
void EndTransactionResponse::clear_header() {
  if (header_ != NULL) header_->::cockroach::proto::ResponseHeader::Clear();
  clear_has_header();
}
 const ::cockroach::proto::ResponseHeader& EndTransactionResponse::header() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.EndTransactionResponse.header)
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
 ::cockroach::proto::ResponseHeader* EndTransactionResponse::mutable_header() {
  set_has_header();
  if (header_ == NULL) {
    header_ = new ::cockroach::proto::ResponseHeader;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.proto.EndTransactionResponse.header)
  return header_;
}
 ::cockroach::proto::ResponseHeader* EndTransactionResponse::release_header() {
  clear_has_header();
  ::cockroach::proto::ResponseHeader* temp = header_;
  header_ = NULL;
  return temp;
}
 void EndTransactionResponse::set_allocated_header(::cockroach::proto::ResponseHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.EndTransactionResponse.header)
}

// optional int64 commit_wait = 2;
bool EndTransactionResponse::has_commit_wait() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void EndTransactionResponse::set_has_commit_wait() {
  _has_bits_[0] |= 0x00000002u;
}
void EndTransactionResponse::clear_has_commit_wait() {
  _has_bits_[0] &= ~0x00000002u;
}
void EndTransactionResponse::clear_commit_wait() {
  commit_wait_ = GOOGLE_LONGLONG(0);
  clear_has_commit_wait();
}
 ::google::protobuf::int64 EndTransactionResponse::commit_wait() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.EndTransactionResponse.commit_wait)
  return commit_wait_;
}
 void EndTransactionResponse::set_commit_wait(::google::protobuf::int64 value) {
  set_has_commit_wait();
  commit_wait_ = value;
  // @@protoc_insertion_point(field_set:cockroach.proto.EndTransactionResponse.commit_wait)
}

// repeated bytes resolved = 3;
int EndTransactionResponse::resolved_size() const {
  return resolved_.size();
}
void EndTransactionResponse::clear_resolved() {
  resolved_.Clear();
}
 const ::std::string& EndTransactionResponse::resolved(int index) const {
  // @@protoc_insertion_point(field_get:cockroach.proto.EndTransactionResponse.resolved)
  return resolved_.Get(index);
}
 ::std::string* EndTransactionResponse::mutable_resolved(int index) {
  // @@protoc_insertion_point(field_mutable:cockroach.proto.EndTransactionResponse.resolved)
  return resolved_.Mutable(index);
}
 void EndTransactionResponse::set_resolved(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:cockroach.proto.EndTransactionResponse.resolved)
  resolved_.Mutable(index)->assign(value);
}
 void EndTransactionResponse::set_resolved(int index, const char* value) {
  resolved_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:cockroach.proto.EndTransactionResponse.resolved)
}
 void EndTransactionResponse::set_resolved(int index, const void* value, size_t size) {
  resolved_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:cockroach.proto.EndTransactionResponse.resolved)
}
 ::std::string* EndTransactionResponse::add_resolved() {
  return resolved_.Add();
}
 void EndTransactionResponse::add_resolved(const ::std::string& value) {
  resolved_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:cockroach.proto.EndTransactionResponse.resolved)
}
 void EndTransactionResponse::add_resolved(const char* value) {
  resolved_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:cockroach.proto.EndTransactionResponse.resolved)
}
 void EndTransactionResponse::add_resolved(const void* value, size_t size) {
  resolved_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:cockroach.proto.EndTransactionResponse.resolved)
}
 const ::google::protobuf::RepeatedPtrField< ::std::string>&
EndTransactionResponse::resolved() const {
  // @@protoc_insertion_point(field_list:cockroach.proto.EndTransactionResponse.resolved)
  return resolved_;
}
 ::google::protobuf::RepeatedPtrField< ::std::string>*
EndTransactionResponse::mutable_resolved() {
  // @@protoc_insertion_point(field_mutable_list:cockroach.proto.EndTransactionResponse.resolved)
  return &resolved_;
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#ifndef _MSC_VER
const int AdminSplitRequest::kHeaderFieldNumber;
const int AdminSplitRequest::kSplitKeyFieldNumber;
#endif  // !_MSC_VER

AdminSplitRequest::AdminSplitRequest()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:cockroach.proto.AdminSplitRequest)
}

void AdminSplitRequest::InitAsDefaultInstance() {
  header_ = const_cast< ::cockroach::proto::RequestHeader*>(&::cockroach::proto::RequestHeader::default_instance());
}

AdminSplitRequest::AdminSplitRequest(const AdminSplitRequest& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:cockroach.proto.AdminSplitRequest)
}

void AdminSplitRequest::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  header_ = NULL;
  split_key_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

AdminSplitRequest::~AdminSplitRequest() {
  // @@protoc_insertion_point(destructor:cockroach.proto.AdminSplitRequest)
  SharedDtor();
}

void AdminSplitRequest::SharedDtor() {
  split_key_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != default_instance_) {
    delete header_;
  }
}

void AdminSplitRequest::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* AdminSplitRequest::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return AdminSplitRequest_descriptor_;
}

const AdminSplitRequest& AdminSplitRequest::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_cockroach_2fproto_2fapi_2eproto();
  return *default_instance_;
}

AdminSplitRequest* AdminSplitRequest::default_instance_ = NULL;

AdminSplitRequest* AdminSplitRequest::New(::google::protobuf::Arena* arena) const {
  AdminSplitRequest* n = new AdminSplitRequest;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void AdminSplitRequest::Clear() {
  if (_has_bits_[0 / 32] & 3u) {
    if (has_header()) {
      if (header_ != NULL) header_->::cockroach::proto::RequestHeader::Clear();
    }
    if (has_split_key()) {
      split_key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool AdminSplitRequest::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:cockroach.proto.AdminSplitRequest)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .cockroach.proto.RequestHeader header = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_header()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_split_key;
        break;
      }

      // optional bytes split_key = 2;
      case 2: {
        if (tag == 18) {
         parse_split_key:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_split_key()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:cockroach.proto.AdminSplitRequest)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:cockroach.proto.AdminSplitRequest)
  return false;
#undef DO_
}

void AdminSplitRequest::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:cockroach.proto.AdminSplitRequest)
  // optional .cockroach.proto.RequestHeader header = 1;
  if (has_header()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->header_, output);
  }

  // optional bytes split_key = 2;
  if (has_split_key()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      2, this->split_key(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:cockroach.proto.AdminSplitRequest)
}

::google::protobuf::uint8* AdminSplitRequest::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:cockroach.proto.AdminSplitRequest)
  // optional .cockroach.proto.RequestHeader header = 1;
  if (has_header()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, *this->header_, target);
  }

  // optional bytes split_key = 2;
  if (has_split_key()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        2, this->split_key(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:cockroach.proto.AdminSplitRequest)
  return target;
}

int AdminSplitRequest::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & 3) {
    // optional .cockroach.proto.RequestHeader header = 1;
    if (has_header()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->header_);
    }

    // optional bytes split_key = 2;
    if (has_split_key()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->split_key());
    }

  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void AdminSplitRequest::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const AdminSplitRequest* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const AdminSplitRequest>(
          &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void AdminSplitRequest::MergeFrom(const AdminSplitRequest& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_header()) {
      mutable_header()->::cockroach::proto::RequestHeader::MergeFrom(from.header());
    }
    if (from.has_split_key()) {
      set_has_split_key();
      split_key_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.split_key_);
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void AdminSplitRequest::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void AdminSplitRequest::CopyFrom(const AdminSplitRequest& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AdminSplitRequest::IsInitialized() const {

  return true;
}

void AdminSplitRequest::Swap(AdminSplitRequest* other) {
  if (other == this) return;
  InternalSwap(other);
}
void AdminSplitRequest::InternalSwap(AdminSplitRequest* other) {
  std::swap(header_, other->header_);
  split_key_.Swap(&other->split_key_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata AdminSplitRequest::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = AdminSplitRequest_descriptor_;
  metadata.reflection = AdminSplitRequest_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// AdminSplitRequest

// optional .cockroach.proto.RequestHeader header = 1;
bool AdminSplitRequest::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void AdminSplitRequest::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
void AdminSplitRequest::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
void AdminSplitRequest::clear_header() {
  if (header_ != NULL) header_->::cockroach::proto::RequestHeader::Clear();
  clear_has_header();
}
 const ::cockroach::proto::RequestHeader& AdminSplitRequest::header() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.AdminSplitRequest.header)
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
 ::cockroach::proto::RequestHeader* AdminSplitRequest::mutable_header() {
  set_has_header();
  if (header_ == NULL) {
    header_ = new ::cockroach::proto::RequestHeader;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.proto.AdminSplitRequest.header)
  return header_;
}
 ::cockroach::proto::RequestHeader* AdminSplitRequest::release_header() {
  clear_has_header();
  ::cockroach::proto::RequestHeader* temp = header_;
  header_ = NULL;
  return temp;
}
 void AdminSplitRequest::set_allocated_header(::cockroach::proto::RequestHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.AdminSplitRequest.header)
}

// optional bytes split_key = 2;
bool AdminSplitRequest::has_split_key() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void AdminSplitRequest::set_has_split_key() {
  _has_bits_[0] |= 0x00000002u;
}
void AdminSplitRequest::clear_has_split_key() {
  _has_bits_[0] &= ~0x00000002u;
}
void AdminSplitRequest::clear_split_key() {
  split_key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_split_key();
}
 const ::std::string& AdminSplitRequest::split_key() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.AdminSplitRequest.split_key)
  return split_key_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void AdminSplitRequest::set_split_key(const ::std::string& value) {
  set_has_split_key();
  split_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cockroach.proto.AdminSplitRequest.split_key)
}
 void AdminSplitRequest::set_split_key(const char* value) {
  set_has_split_key();
  split_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cockroach.proto.AdminSplitRequest.split_key)
}
 void AdminSplitRequest::set_split_key(const void* value, size_t size) {
  set_has_split_key();
  split_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cockroach.proto.AdminSplitRequest.split_key)
}
 ::std::string* AdminSplitRequest::mutable_split_key() {
  set_has_split_key();
  // @@protoc_insertion_point(field_mutable:cockroach.proto.AdminSplitRequest.split_key)
  return split_key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* AdminSplitRequest::release_split_key() {
  clear_has_split_key();
  return split_key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void AdminSplitRequest::set_allocated_split_key(::std::string* split_key) {
  if (split_key != NULL) {
    set_has_split_key();
  } else {
    clear_has_split_key();
  }
  split_key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), split_key);
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.AdminSplitRequest.split_key)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#ifndef _MSC_VER
const int AdminSplitResponse::kHeaderFieldNumber;
#endif  // !_MSC_VER

AdminSplitResponse::AdminSplitResponse()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:cockroach.proto.AdminSplitResponse)
}

void AdminSplitResponse::InitAsDefaultInstance() {
  header_ = const_cast< ::cockroach::proto::ResponseHeader*>(&::cockroach::proto::ResponseHeader::default_instance());
}

AdminSplitResponse::AdminSplitResponse(const AdminSplitResponse& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:cockroach.proto.AdminSplitResponse)
}

void AdminSplitResponse::SharedCtor() {
  _cached_size_ = 0;
  header_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

AdminSplitResponse::~AdminSplitResponse() {
  // @@protoc_insertion_point(destructor:cockroach.proto.AdminSplitResponse)
  SharedDtor();
}

void AdminSplitResponse::SharedDtor() {
  if (this != default_instance_) {
    delete header_;
  }
}

void AdminSplitResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* AdminSplitResponse::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return AdminSplitResponse_descriptor_;
}

const AdminSplitResponse& AdminSplitResponse::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_cockroach_2fproto_2fapi_2eproto();
  return *default_instance_;
}

AdminSplitResponse* AdminSplitResponse::default_instance_ = NULL;

AdminSplitResponse* AdminSplitResponse::New(::google::protobuf::Arena* arena) const {
  AdminSplitResponse* n = new AdminSplitResponse;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void AdminSplitResponse::Clear() {
  if (has_header()) {
    if (header_ != NULL) header_->::cockroach::proto::ResponseHeader::Clear();
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool AdminSplitResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:cockroach.proto.AdminSplitResponse)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .cockroach.proto.ResponseHeader header = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_header()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:cockroach.proto.AdminSplitResponse)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:cockroach.proto.AdminSplitResponse)
  return false;
#undef DO_
}

void AdminSplitResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:cockroach.proto.AdminSplitResponse)
  // optional .cockroach.proto.ResponseHeader header = 1;
  if (has_header()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->header_, output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:cockroach.proto.AdminSplitResponse)
}

::google::protobuf::uint8* AdminSplitResponse::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:cockroach.proto.AdminSplitResponse)
  // optional .cockroach.proto.ResponseHeader header = 1;
  if (has_header()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, *this->header_, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:cockroach.proto.AdminSplitResponse)
  return target;
}

int AdminSplitResponse::ByteSize() const {
  int total_size = 0;

  // optional .cockroach.proto.ResponseHeader header = 1;
  if (has_header()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->header_);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void AdminSplitResponse::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const AdminSplitResponse* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const AdminSplitResponse>(
          &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void AdminSplitResponse::MergeFrom(const AdminSplitResponse& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_header()) {
      mutable_header()->::cockroach::proto::ResponseHeader::MergeFrom(from.header());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void AdminSplitResponse::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void AdminSplitResponse::CopyFrom(const AdminSplitResponse& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AdminSplitResponse::IsInitialized() const {

  return true;
}

void AdminSplitResponse::Swap(AdminSplitResponse* other) {
  if (other == this) return;
  InternalSwap(other);
}
void AdminSplitResponse::InternalSwap(AdminSplitResponse* other) {
  std::swap(header_, other->header_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata AdminSplitResponse::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = AdminSplitResponse_descriptor_;
  metadata.reflection = AdminSplitResponse_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// AdminSplitResponse

// optional .cockroach.proto.ResponseHeader header = 1;
bool AdminSplitResponse::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void AdminSplitResponse::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
void AdminSplitResponse::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
void AdminSplitResponse::clear_header() {
  if (header_ != NULL) header_->::cockroach::proto::ResponseHeader::Clear();
  clear_has_header();
}
 const ::cockroach::proto::ResponseHeader& AdminSplitResponse::header() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.AdminSplitResponse.header)
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
 ::cockroach::proto::ResponseHeader* AdminSplitResponse::mutable_header() {
  set_has_header();
  if (header_ == NULL) {
    header_ = new ::cockroach::proto::ResponseHeader;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.proto.AdminSplitResponse.header)
  return header_;
}
 ::cockroach::proto::ResponseHeader* AdminSplitResponse::release_header() {
  clear_has_header();
  ::cockroach::proto::ResponseHeader* temp = header_;
  header_ = NULL;
  return temp;
}
 void AdminSplitResponse::set_allocated_header(::cockroach::proto::ResponseHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.AdminSplitResponse.header)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#ifndef _MSC_VER
const int AdminMergeRequest::kHeaderFieldNumber;
#endif  // !_MSC_VER

AdminMergeRequest::AdminMergeRequest()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:cockroach.proto.AdminMergeRequest)
}

void AdminMergeRequest::InitAsDefaultInstance() {
  header_ = const_cast< ::cockroach::proto::RequestHeader*>(&::cockroach::proto::RequestHeader::default_instance());
}

AdminMergeRequest::AdminMergeRequest(const AdminMergeRequest& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:cockroach.proto.AdminMergeRequest)
}

void AdminMergeRequest::SharedCtor() {
  _cached_size_ = 0;
  header_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

AdminMergeRequest::~AdminMergeRequest() {
  // @@protoc_insertion_point(destructor:cockroach.proto.AdminMergeRequest)
  SharedDtor();
}

void AdminMergeRequest::SharedDtor() {
  if (this != default_instance_) {
    delete header_;
  }
}

void AdminMergeRequest::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* AdminMergeRequest::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return AdminMergeRequest_descriptor_;
}

const AdminMergeRequest& AdminMergeRequest::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_cockroach_2fproto_2fapi_2eproto();
  return *default_instance_;
}

AdminMergeRequest* AdminMergeRequest::default_instance_ = NULL;

AdminMergeRequest* AdminMergeRequest::New(::google::protobuf::Arena* arena) const {
  AdminMergeRequest* n = new AdminMergeRequest;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void AdminMergeRequest::Clear() {
  if (has_header()) {
    if (header_ != NULL) header_->::cockroach::proto::RequestHeader::Clear();
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool AdminMergeRequest::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:cockroach.proto.AdminMergeRequest)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .cockroach.proto.RequestHeader header = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_header()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:cockroach.proto.AdminMergeRequest)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:cockroach.proto.AdminMergeRequest)
  return false;
#undef DO_
}

void AdminMergeRequest::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:cockroach.proto.AdminMergeRequest)
  // optional .cockroach.proto.RequestHeader header = 1;
  if (has_header()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->header_, output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:cockroach.proto.AdminMergeRequest)
}

::google::protobuf::uint8* AdminMergeRequest::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:cockroach.proto.AdminMergeRequest)
  // optional .cockroach.proto.RequestHeader header = 1;
  if (has_header()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, *this->header_, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:cockroach.proto.AdminMergeRequest)
  return target;
}

int AdminMergeRequest::ByteSize() const {
  int total_size = 0;

  // optional .cockroach.proto.RequestHeader header = 1;
  if (has_header()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->header_);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void AdminMergeRequest::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const AdminMergeRequest* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const AdminMergeRequest>(
          &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void AdminMergeRequest::MergeFrom(const AdminMergeRequest& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_header()) {
      mutable_header()->::cockroach::proto::RequestHeader::MergeFrom(from.header());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void AdminMergeRequest::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void AdminMergeRequest::CopyFrom(const AdminMergeRequest& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AdminMergeRequest::IsInitialized() const {

  return true;
}

void AdminMergeRequest::Swap(AdminMergeRequest* other) {
  if (other == this) return;
  InternalSwap(other);
}
void AdminMergeRequest::InternalSwap(AdminMergeRequest* other) {
  std::swap(header_, other->header_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata AdminMergeRequest::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = AdminMergeRequest_descriptor_;
  metadata.reflection = AdminMergeRequest_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// AdminMergeRequest

// optional .cockroach.proto.RequestHeader header = 1;
bool AdminMergeRequest::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void AdminMergeRequest::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
void AdminMergeRequest::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
void AdminMergeRequest::clear_header() {
  if (header_ != NULL) header_->::cockroach::proto::RequestHeader::Clear();
  clear_has_header();
}
 const ::cockroach::proto::RequestHeader& AdminMergeRequest::header() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.AdminMergeRequest.header)
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
 ::cockroach::proto::RequestHeader* AdminMergeRequest::mutable_header() {
  set_has_header();
  if (header_ == NULL) {
    header_ = new ::cockroach::proto::RequestHeader;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.proto.AdminMergeRequest.header)
  return header_;
}
 ::cockroach::proto::RequestHeader* AdminMergeRequest::release_header() {
  clear_has_header();
  ::cockroach::proto::RequestHeader* temp = header_;
  header_ = NULL;
  return temp;
}
 void AdminMergeRequest::set_allocated_header(::cockroach::proto::RequestHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.AdminMergeRequest.header)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#ifndef _MSC_VER
const int AdminMergeResponse::kHeaderFieldNumber;
#endif  // !_MSC_VER

AdminMergeResponse::AdminMergeResponse()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:cockroach.proto.AdminMergeResponse)
}

void AdminMergeResponse::InitAsDefaultInstance() {
  header_ = const_cast< ::cockroach::proto::ResponseHeader*>(&::cockroach::proto::ResponseHeader::default_instance());
}

AdminMergeResponse::AdminMergeResponse(const AdminMergeResponse& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:cockroach.proto.AdminMergeResponse)
}

void AdminMergeResponse::SharedCtor() {
  _cached_size_ = 0;
  header_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

AdminMergeResponse::~AdminMergeResponse() {
  // @@protoc_insertion_point(destructor:cockroach.proto.AdminMergeResponse)
  SharedDtor();
}

void AdminMergeResponse::SharedDtor() {
  if (this != default_instance_) {
    delete header_;
  }
}

void AdminMergeResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* AdminMergeResponse::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return AdminMergeResponse_descriptor_;
}

const AdminMergeResponse& AdminMergeResponse::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_cockroach_2fproto_2fapi_2eproto();
  return *default_instance_;
}

AdminMergeResponse* AdminMergeResponse::default_instance_ = NULL;

AdminMergeResponse* AdminMergeResponse::New(::google::protobuf::Arena* arena) const {
  AdminMergeResponse* n = new AdminMergeResponse;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void AdminMergeResponse::Clear() {
  if (has_header()) {
    if (header_ != NULL) header_->::cockroach::proto::ResponseHeader::Clear();
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool AdminMergeResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:cockroach.proto.AdminMergeResponse)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .cockroach.proto.ResponseHeader header = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_header()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:cockroach.proto.AdminMergeResponse)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:cockroach.proto.AdminMergeResponse)
  return false;
#undef DO_
}

void AdminMergeResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:cockroach.proto.AdminMergeResponse)
  // optional .cockroach.proto.ResponseHeader header = 1;
  if (has_header()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->header_, output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:cockroach.proto.AdminMergeResponse)
}

::google::protobuf::uint8* AdminMergeResponse::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:cockroach.proto.AdminMergeResponse)
  // optional .cockroach.proto.ResponseHeader header = 1;
  if (has_header()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, *this->header_, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:cockroach.proto.AdminMergeResponse)
  return target;
}

int AdminMergeResponse::ByteSize() const {
  int total_size = 0;

  // optional .cockroach.proto.ResponseHeader header = 1;
  if (has_header()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->header_);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void AdminMergeResponse::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const AdminMergeResponse* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const AdminMergeResponse>(
          &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void AdminMergeResponse::MergeFrom(const AdminMergeResponse& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_header()) {
      mutable_header()->::cockroach::proto::ResponseHeader::MergeFrom(from.header());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void AdminMergeResponse::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void AdminMergeResponse::CopyFrom(const AdminMergeResponse& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AdminMergeResponse::IsInitialized() const {

  return true;
}

void AdminMergeResponse::Swap(AdminMergeResponse* other) {
  if (other == this) return;
  InternalSwap(other);
}
void AdminMergeResponse::InternalSwap(AdminMergeResponse* other) {
  std::swap(header_, other->header_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata AdminMergeResponse::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = AdminMergeResponse_descriptor_;
  metadata.reflection = AdminMergeResponse_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// AdminMergeResponse

// optional .cockroach.proto.ResponseHeader header = 1;
bool AdminMergeResponse::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void AdminMergeResponse::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
void AdminMergeResponse::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
void AdminMergeResponse::clear_header() {
  if (header_ != NULL) header_->::cockroach::proto::ResponseHeader::Clear();
  clear_has_header();
}
 const ::cockroach::proto::ResponseHeader& AdminMergeResponse::header() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.AdminMergeResponse.header)
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
 ::cockroach::proto::ResponseHeader* AdminMergeResponse::mutable_header() {
  set_has_header();
  if (header_ == NULL) {
    header_ = new ::cockroach::proto::ResponseHeader;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.proto.AdminMergeResponse.header)
  return header_;
}
 ::cockroach::proto::ResponseHeader* AdminMergeResponse::release_header() {
  clear_has_header();
  ::cockroach::proto::ResponseHeader* temp = header_;
  header_ = NULL;
  return temp;
}
 void AdminMergeResponse::set_allocated_header(::cockroach::proto::ResponseHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.AdminMergeResponse.header)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#ifndef _MSC_VER
const int RangeLookupRequest::kHeaderFieldNumber;
const int RangeLookupRequest::kMaxRangesFieldNumber;
const int RangeLookupRequest::kConsiderIntentsFieldNumber;
const int RangeLookupRequest::kReverseFieldNumber;
#endif  // !_MSC_VER

RangeLookupRequest::RangeLookupRequest()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:cockroach.proto.RangeLookupRequest)
}

void RangeLookupRequest::InitAsDefaultInstance() {
  header_ = const_cast< ::cockroach::proto::RequestHeader*>(&::cockroach::proto::RequestHeader::default_instance());
}

RangeLookupRequest::RangeLookupRequest(const RangeLookupRequest& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:cockroach.proto.RangeLookupRequest)
}

void RangeLookupRequest::SharedCtor() {
  _cached_size_ = 0;
  header_ = NULL;
  max_ranges_ = 0;
  consider_intents_ = false;
  reverse_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RangeLookupRequest::~RangeLookupRequest() {
  // @@protoc_insertion_point(destructor:cockroach.proto.RangeLookupRequest)
  SharedDtor();
}

void RangeLookupRequest::SharedDtor() {
  if (this != default_instance_) {
    delete header_;
  }
}

void RangeLookupRequest::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* RangeLookupRequest::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return RangeLookupRequest_descriptor_;
}

const RangeLookupRequest& RangeLookupRequest::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_cockroach_2fproto_2fapi_2eproto();
  return *default_instance_;
}

RangeLookupRequest* RangeLookupRequest::default_instance_ = NULL;

RangeLookupRequest* RangeLookupRequest::New(::google::protobuf::Arena* arena) const {
  RangeLookupRequest* n = new RangeLookupRequest;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void RangeLookupRequest::Clear() {
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<RangeLookupRequest*>(16)->f)

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  if (_has_bits_[0 / 32] & 15u) {
    ZR_(max_ranges_, reverse_);
    if (has_header()) {
      if (header_ != NULL) header_->::cockroach::proto::RequestHeader::Clear();
    }
  }

#undef ZR_HELPER_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool RangeLookupRequest::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:cockroach.proto.RangeLookupRequest)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .cockroach.proto.RequestHeader header = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_header()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_max_ranges;
        break;
      }

      // optional int32 max_ranges = 2;
      case 2: {
        if (tag == 16) {
         parse_max_ranges:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &max_ranges_)));
          set_has_max_ranges();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_consider_intents;
        break;
      }

      // optional bool consider_intents = 3;
      case 3: {
        if (tag == 24) {
         parse_consider_intents:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &consider_intents_)));
          set_has_consider_intents();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_reverse;
        break;
      }

      // optional bool reverse = 4;
      case 4: {
        if (tag == 32) {
         parse_reverse:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &reverse_)));
          set_has_reverse();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:cockroach.proto.RangeLookupRequest)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:cockroach.proto.RangeLookupRequest)
  return false;
#undef DO_
}

void RangeLookupRequest::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:cockroach.proto.RangeLookupRequest)
  // optional .cockroach.proto.RequestHeader header = 1;
  if (has_header()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->header_, output);
  }

  // optional int32 max_ranges = 2;
  if (has_max_ranges()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->max_ranges(), output);
  }

  // optional bool consider_intents = 3;
  if (has_consider_intents()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(3, this->consider_intents(), output);
  }

  // optional bool reverse = 4;
  if (has_reverse()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(4, this->reverse(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:cockroach.proto.RangeLookupRequest)
}

::google::protobuf::uint8* RangeLookupRequest::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:cockroach.proto.RangeLookupRequest)
  // optional .cockroach.proto.RequestHeader header = 1;
  if (has_header()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, *this->header_, target);
  }

  // optional int32 max_ranges = 2;
  if (has_max_ranges()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->max_ranges(), target);
  }

  // optional bool consider_intents = 3;
  if (has_consider_intents()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(3, this->consider_intents(), target);
  }

  // optional bool reverse = 4;
  if (has_reverse()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(4, this->reverse(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:cockroach.proto.RangeLookupRequest)
  return target;
}

int RangeLookupRequest::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & 15) {
    // optional .cockroach.proto.RequestHeader header = 1;
    if (has_header()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->header_);
    }

    // optional int32 max_ranges = 2;
    if (has_max_ranges()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->max_ranges());
    }

    // optional bool consider_intents = 3;
    if (has_consider_intents()) {
      total_size += 1 + 1;
    }

    // optional bool reverse = 4;
    if (has_reverse()) {
      total_size += 1 + 1;
    }

  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RangeLookupRequest::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const RangeLookupRequest* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const RangeLookupRequest>(
          &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void RangeLookupRequest::MergeFrom(const RangeLookupRequest& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_header()) {
      mutable_header()->::cockroach::proto::RequestHeader::MergeFrom(from.header());
    }
    if (from.has_max_ranges()) {
      set_max_ranges(from.max_ranges());
    }
    if (from.has_consider_intents()) {
      set_consider_intents(from.consider_intents());
    }
    if (from.has_reverse()) {
      set_reverse(from.reverse());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void RangeLookupRequest::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void RangeLookupRequest::CopyFrom(const RangeLookupRequest& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RangeLookupRequest::IsInitialized() const {

  return true;
}

void RangeLookupRequest::Swap(RangeLookupRequest* other) {
  if (other == this) return;
  InternalSwap(other);
}
void RangeLookupRequest::InternalSwap(RangeLookupRequest* other) {
  std::swap(header_, other->header_);
  std::swap(max_ranges_, other->max_ranges_);
  std::swap(consider_intents_, other->consider_intents_);
  std::swap(reverse_, other->reverse_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata RangeLookupRequest::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = RangeLookupRequest_descriptor_;
  metadata.reflection = RangeLookupRequest_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// RangeLookupRequest

// optional .cockroach.proto.RequestHeader header = 1;
bool RangeLookupRequest::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void RangeLookupRequest::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
void RangeLookupRequest::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
void RangeLookupRequest::clear_header() {
  if (header_ != NULL) header_->::cockroach::proto::RequestHeader::Clear();
  clear_has_header();
}
 const ::cockroach::proto::RequestHeader& RangeLookupRequest::header() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.RangeLookupRequest.header)
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
 ::cockroach::proto::RequestHeader* RangeLookupRequest::mutable_header() {
  set_has_header();
  if (header_ == NULL) {
    header_ = new ::cockroach::proto::RequestHeader;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.proto.RangeLookupRequest.header)
  return header_;
}
 ::cockroach::proto::RequestHeader* RangeLookupRequest::release_header() {
  clear_has_header();
  ::cockroach::proto::RequestHeader* temp = header_;
  header_ = NULL;
  return temp;
}
 void RangeLookupRequest::set_allocated_header(::cockroach::proto::RequestHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.RangeLookupRequest.header)
}

// optional int32 max_ranges = 2;
bool RangeLookupRequest::has_max_ranges() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void RangeLookupRequest::set_has_max_ranges() {
  _has_bits_[0] |= 0x00000002u;
}
void RangeLookupRequest::clear_has_max_ranges() {
  _has_bits_[0] &= ~0x00000002u;
}
void RangeLookupRequest::clear_max_ranges() {
  max_ranges_ = 0;
  clear_has_max_ranges();
}
 ::google::protobuf::int32 RangeLookupRequest::max_ranges() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.RangeLookupRequest.max_ranges)
  return max_ranges_;
}
 void RangeLookupRequest::set_max_ranges(::google::protobuf::int32 value) {
  set_has_max_ranges();
  max_ranges_ = value;
  // @@protoc_insertion_point(field_set:cockroach.proto.RangeLookupRequest.max_ranges)
}

// optional bool consider_intents = 3;
bool RangeLookupRequest::has_consider_intents() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void RangeLookupRequest::set_has_consider_intents() {
  _has_bits_[0] |= 0x00000004u;
}
void RangeLookupRequest::clear_has_consider_intents() {
  _has_bits_[0] &= ~0x00000004u;
}
void RangeLookupRequest::clear_consider_intents() {
  consider_intents_ = false;
  clear_has_consider_intents();
}
 bool RangeLookupRequest::consider_intents() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.RangeLookupRequest.consider_intents)
  return consider_intents_;
}
 void RangeLookupRequest::set_consider_intents(bool value) {
  set_has_consider_intents();
  consider_intents_ = value;
  // @@protoc_insertion_point(field_set:cockroach.proto.RangeLookupRequest.consider_intents)
}

// optional bool reverse = 4;
bool RangeLookupRequest::has_reverse() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void RangeLookupRequest::set_has_reverse() {
  _has_bits_[0] |= 0x00000008u;
}
void RangeLookupRequest::clear_has_reverse() {
  _has_bits_[0] &= ~0x00000008u;
}
void RangeLookupRequest::clear_reverse() {
  reverse_ = false;
  clear_has_reverse();
}
 bool RangeLookupRequest::reverse() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.RangeLookupRequest.reverse)
  return reverse_;
}
 void RangeLookupRequest::set_reverse(bool value) {
  set_has_reverse();
  reverse_ = value;
  // @@protoc_insertion_point(field_set:cockroach.proto.RangeLookupRequest.reverse)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#ifndef _MSC_VER
const int RangeLookupResponse::kHeaderFieldNumber;
const int RangeLookupResponse::kRangesFieldNumber;
#endif  // !_MSC_VER

RangeLookupResponse::RangeLookupResponse()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:cockroach.proto.RangeLookupResponse)
}

void RangeLookupResponse::InitAsDefaultInstance() {
  header_ = const_cast< ::cockroach::proto::ResponseHeader*>(&::cockroach::proto::ResponseHeader::default_instance());
}

RangeLookupResponse::RangeLookupResponse(const RangeLookupResponse& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:cockroach.proto.RangeLookupResponse)
}

void RangeLookupResponse::SharedCtor() {
  _cached_size_ = 0;
  header_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RangeLookupResponse::~RangeLookupResponse() {
  // @@protoc_insertion_point(destructor:cockroach.proto.RangeLookupResponse)
  SharedDtor();
}

void RangeLookupResponse::SharedDtor() {
  if (this != default_instance_) {
    delete header_;
  }
}

void RangeLookupResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* RangeLookupResponse::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return RangeLookupResponse_descriptor_;
}

const RangeLookupResponse& RangeLookupResponse::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_cockroach_2fproto_2fapi_2eproto();
  return *default_instance_;
}

RangeLookupResponse* RangeLookupResponse::default_instance_ = NULL;

RangeLookupResponse* RangeLookupResponse::New(::google::protobuf::Arena* arena) const {
  RangeLookupResponse* n = new RangeLookupResponse;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void RangeLookupResponse::Clear() {
  if (has_header()) {
    if (header_ != NULL) header_->::cockroach::proto::ResponseHeader::Clear();
  }
  ranges_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool RangeLookupResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:cockroach.proto.RangeLookupResponse)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .cockroach.proto.ResponseHeader header = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_header()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_ranges;
        break;
      }

      // repeated .cockroach.proto.RangeDescriptor ranges = 2;
      case 2: {
        if (tag == 18) {
         parse_ranges:
          DO_(input->IncrementRecursionDepth());
         parse_loop_ranges:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                input, add_ranges()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_loop_ranges;
        input->UnsafeDecrementRecursionDepth();
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:cockroach.proto.RangeLookupResponse)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:cockroach.proto.RangeLookupResponse)
  return false;
#undef DO_
}

void RangeLookupResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:cockroach.proto.RangeLookupResponse)
  // optional .cockroach.proto.ResponseHeader header = 1;
  if (has_header()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->header_, output);
  }

  // repeated .cockroach.proto.RangeDescriptor ranges = 2;
  for (unsigned int i = 0, n = this->ranges_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->ranges(i), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:cockroach.proto.RangeLookupResponse)
}

::google::protobuf::uint8* RangeLookupResponse::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:cockroach.proto.RangeLookupResponse)
  // optional .cockroach.proto.ResponseHeader header = 1;
  if (has_header()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, *this->header_, target);
  }

  // repeated .cockroach.proto.RangeDescriptor ranges = 2;
  for (unsigned int i = 0, n = this->ranges_size(); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->ranges(i), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:cockroach.proto.RangeLookupResponse)
  return target;
}

int RangeLookupResponse::ByteSize() const {
  int total_size = 0;

  // optional .cockroach.proto.ResponseHeader header = 1;
  if (has_header()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->header_);
  }

  // repeated .cockroach.proto.RangeDescriptor ranges = 2;
  total_size += 1 * this->ranges_size();
  for (int i = 0; i < this->ranges_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->ranges(i));
  }

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RangeLookupResponse::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const RangeLookupResponse* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const RangeLookupResponse>(
          &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void RangeLookupResponse::MergeFrom(const RangeLookupResponse& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  ranges_.MergeFrom(from.ranges_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_header()) {
      mutable_header()->::cockroach::proto::ResponseHeader::MergeFrom(from.header());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void RangeLookupResponse::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void RangeLookupResponse::CopyFrom(const RangeLookupResponse& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RangeLookupResponse::IsInitialized() const {

  return true;
}

void RangeLookupResponse::Swap(RangeLookupResponse* other) {
  if (other == this) return;
  InternalSwap(other);
}
void RangeLookupResponse::InternalSwap(RangeLookupResponse* other) {
  std::swap(header_, other->header_);
  ranges_.UnsafeArenaSwap(&other->ranges_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata RangeLookupResponse::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = RangeLookupResponse_descriptor_;
  metadata.reflection = RangeLookupResponse_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// RangeLookupResponse

// optional .cockroach.proto.ResponseHeader header = 1;
bool RangeLookupResponse::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void RangeLookupResponse::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
void RangeLookupResponse::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
void RangeLookupResponse::clear_header() {
  if (header_ != NULL) header_->::cockroach::proto::ResponseHeader::Clear();
  clear_has_header();
}
 const ::cockroach::proto::ResponseHeader& RangeLookupResponse::header() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.RangeLookupResponse.header)
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
 ::cockroach::proto::ResponseHeader* RangeLookupResponse::mutable_header() {
  set_has_header();
  if (header_ == NULL) {
    header_ = new ::cockroach::proto::ResponseHeader;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.proto.RangeLookupResponse.header)
  return header_;
}
 ::cockroach::proto::ResponseHeader* RangeLookupResponse::release_header() {
  clear_has_header();
  ::cockroach::proto::ResponseHeader* temp = header_;
  header_ = NULL;
  return temp;
}
 void RangeLookupResponse::set_allocated_header(::cockroach::proto::ResponseHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.RangeLookupResponse.header)
}

// repeated .cockroach.proto.RangeDescriptor ranges = 2;
int RangeLookupResponse::ranges_size() const {
  return ranges_.size();
}
void RangeLookupResponse::clear_ranges() {
  ranges_.Clear();
}
 const ::cockroach::proto::RangeDescriptor& RangeLookupResponse::ranges(int index) const {
  // @@protoc_insertion_point(field_get:cockroach.proto.RangeLookupResponse.ranges)
  return ranges_.Get(index);
}
 ::cockroach::proto::RangeDescriptor* RangeLookupResponse::mutable_ranges(int index) {
  // @@protoc_insertion_point(field_mutable:cockroach.proto.RangeLookupResponse.ranges)
  return ranges_.Mutable(index);
}
 ::cockroach::proto::RangeDescriptor* RangeLookupResponse::add_ranges() {
  // @@protoc_insertion_point(field_add:cockroach.proto.RangeLookupResponse.ranges)
  return ranges_.Add();
}
 const ::google::protobuf::RepeatedPtrField< ::cockroach::proto::RangeDescriptor >&
RangeLookupResponse::ranges() const {
  // @@protoc_insertion_point(field_list:cockroach.proto.RangeLookupResponse.ranges)
  return ranges_;
}
 ::google::protobuf::RepeatedPtrField< ::cockroach::proto::RangeDescriptor >*
RangeLookupResponse::mutable_ranges() {
  // @@protoc_insertion_point(field_mutable_list:cockroach.proto.RangeLookupResponse.ranges)
  return &ranges_;
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#ifndef _MSC_VER
const int HeartbeatTxnRequest::kHeaderFieldNumber;
#endif  // !_MSC_VER

HeartbeatTxnRequest::HeartbeatTxnRequest()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:cockroach.proto.HeartbeatTxnRequest)
}

void HeartbeatTxnRequest::InitAsDefaultInstance() {
  header_ = const_cast< ::cockroach::proto::RequestHeader*>(&::cockroach::proto::RequestHeader::default_instance());
}

HeartbeatTxnRequest::HeartbeatTxnRequest(const HeartbeatTxnRequest& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:cockroach.proto.HeartbeatTxnRequest)
}

void HeartbeatTxnRequest::SharedCtor() {
  _cached_size_ = 0;
  header_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

HeartbeatTxnRequest::~HeartbeatTxnRequest() {
  // @@protoc_insertion_point(destructor:cockroach.proto.HeartbeatTxnRequest)
  SharedDtor();
}

void HeartbeatTxnRequest::SharedDtor() {
  if (this != default_instance_) {
    delete header_;
  }
}

void HeartbeatTxnRequest::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* HeartbeatTxnRequest::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return HeartbeatTxnRequest_descriptor_;
}

const HeartbeatTxnRequest& HeartbeatTxnRequest::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_cockroach_2fproto_2fapi_2eproto();
  return *default_instance_;
}

HeartbeatTxnRequest* HeartbeatTxnRequest::default_instance_ = NULL;

HeartbeatTxnRequest* HeartbeatTxnRequest::New(::google::protobuf::Arena* arena) const {
  HeartbeatTxnRequest* n = new HeartbeatTxnRequest;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void HeartbeatTxnRequest::Clear() {
  if (has_header()) {
    if (header_ != NULL) header_->::cockroach::proto::RequestHeader::Clear();
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool HeartbeatTxnRequest::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:cockroach.proto.HeartbeatTxnRequest)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .cockroach.proto.RequestHeader header = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_header()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:cockroach.proto.HeartbeatTxnRequest)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:cockroach.proto.HeartbeatTxnRequest)
  return false;
#undef DO_
}

void HeartbeatTxnRequest::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:cockroach.proto.HeartbeatTxnRequest)
  // optional .cockroach.proto.RequestHeader header = 1;
  if (has_header()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->header_, output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:cockroach.proto.HeartbeatTxnRequest)
}

::google::protobuf::uint8* HeartbeatTxnRequest::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:cockroach.proto.HeartbeatTxnRequest)
  // optional .cockroach.proto.RequestHeader header = 1;
  if (has_header()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, *this->header_, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:cockroach.proto.HeartbeatTxnRequest)
  return target;
}

int HeartbeatTxnRequest::ByteSize() const {
  int total_size = 0;

  // optional .cockroach.proto.RequestHeader header = 1;
  if (has_header()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->header_);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void HeartbeatTxnRequest::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const HeartbeatTxnRequest* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const HeartbeatTxnRequest>(
          &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void HeartbeatTxnRequest::MergeFrom(const HeartbeatTxnRequest& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_header()) {
      mutable_header()->::cockroach::proto::RequestHeader::MergeFrom(from.header());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void HeartbeatTxnRequest::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void HeartbeatTxnRequest::CopyFrom(const HeartbeatTxnRequest& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool HeartbeatTxnRequest::IsInitialized() const {

  return true;
}

void HeartbeatTxnRequest::Swap(HeartbeatTxnRequest* other) {
  if (other == this) return;
  InternalSwap(other);
}
void HeartbeatTxnRequest::InternalSwap(HeartbeatTxnRequest* other) {
  std::swap(header_, other->header_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata HeartbeatTxnRequest::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = HeartbeatTxnRequest_descriptor_;
  metadata.reflection = HeartbeatTxnRequest_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// HeartbeatTxnRequest

// optional .cockroach.proto.RequestHeader header = 1;
bool HeartbeatTxnRequest::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void HeartbeatTxnRequest::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
void HeartbeatTxnRequest::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
void HeartbeatTxnRequest::clear_header() {
  if (header_ != NULL) header_->::cockroach::proto::RequestHeader::Clear();
  clear_has_header();
}
 const ::cockroach::proto::RequestHeader& HeartbeatTxnRequest::header() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.HeartbeatTxnRequest.header)
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
 ::cockroach::proto::RequestHeader* HeartbeatTxnRequest::mutable_header() {
  set_has_header();
  if (header_ == NULL) {
    header_ = new ::cockroach::proto::RequestHeader;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.proto.HeartbeatTxnRequest.header)
  return header_;
}
 ::cockroach::proto::RequestHeader* HeartbeatTxnRequest::release_header() {
  clear_has_header();
  ::cockroach::proto::RequestHeader* temp = header_;
  header_ = NULL;
  return temp;
}
 void HeartbeatTxnRequest::set_allocated_header(::cockroach::proto::RequestHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.HeartbeatTxnRequest.header)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#ifndef _MSC_VER
const int HeartbeatTxnResponse::kHeaderFieldNumber;
#endif  // !_MSC_VER

HeartbeatTxnResponse::HeartbeatTxnResponse()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:cockroach.proto.HeartbeatTxnResponse)
}

void HeartbeatTxnResponse::InitAsDefaultInstance() {
  header_ = const_cast< ::cockroach::proto::ResponseHeader*>(&::cockroach::proto::ResponseHeader::default_instance());
}

HeartbeatTxnResponse::HeartbeatTxnResponse(const HeartbeatTxnResponse& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:cockroach.proto.HeartbeatTxnResponse)
}

void HeartbeatTxnResponse::SharedCtor() {
  _cached_size_ = 0;
  header_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

HeartbeatTxnResponse::~HeartbeatTxnResponse() {
  // @@protoc_insertion_point(destructor:cockroach.proto.HeartbeatTxnResponse)
  SharedDtor();
}

void HeartbeatTxnResponse::SharedDtor() {
  if (this != default_instance_) {
    delete header_;
  }
}

void HeartbeatTxnResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* HeartbeatTxnResponse::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return HeartbeatTxnResponse_descriptor_;
}

const HeartbeatTxnResponse& HeartbeatTxnResponse::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_cockroach_2fproto_2fapi_2eproto();
  return *default_instance_;
}

HeartbeatTxnResponse* HeartbeatTxnResponse::default_instance_ = NULL;

HeartbeatTxnResponse* HeartbeatTxnResponse::New(::google::protobuf::Arena* arena) const {
  HeartbeatTxnResponse* n = new HeartbeatTxnResponse;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void HeartbeatTxnResponse::Clear() {
  if (has_header()) {
    if (header_ != NULL) header_->::cockroach::proto::ResponseHeader::Clear();
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool HeartbeatTxnResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:cockroach.proto.HeartbeatTxnResponse)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .cockroach.proto.ResponseHeader header = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_header()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:cockroach.proto.HeartbeatTxnResponse)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:cockroach.proto.HeartbeatTxnResponse)
  return false;
#undef DO_
}

void HeartbeatTxnResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:cockroach.proto.HeartbeatTxnResponse)
  // optional .cockroach.proto.ResponseHeader header = 1;
  if (has_header()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->header_, output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:cockroach.proto.HeartbeatTxnResponse)
}

::google::protobuf::uint8* HeartbeatTxnResponse::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:cockroach.proto.HeartbeatTxnResponse)
  // optional .cockroach.proto.ResponseHeader header = 1;
  if (has_header()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, *this->header_, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:cockroach.proto.HeartbeatTxnResponse)
  return target;
}

int HeartbeatTxnResponse::ByteSize() const {
  int total_size = 0;

  // optional .cockroach.proto.ResponseHeader header = 1;
  if (has_header()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->header_);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void HeartbeatTxnResponse::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const HeartbeatTxnResponse* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const HeartbeatTxnResponse>(
          &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void HeartbeatTxnResponse::MergeFrom(const HeartbeatTxnResponse& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_header()) {
      mutable_header()->::cockroach::proto::ResponseHeader::MergeFrom(from.header());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void HeartbeatTxnResponse::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void HeartbeatTxnResponse::CopyFrom(const HeartbeatTxnResponse& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool HeartbeatTxnResponse::IsInitialized() const {

  return true;
}

void HeartbeatTxnResponse::Swap(HeartbeatTxnResponse* other) {
  if (other == this) return;
  InternalSwap(other);
}
void HeartbeatTxnResponse::InternalSwap(HeartbeatTxnResponse* other) {
  std::swap(header_, other->header_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata HeartbeatTxnResponse::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = HeartbeatTxnResponse_descriptor_;
  metadata.reflection = HeartbeatTxnResponse_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// HeartbeatTxnResponse

// optional .cockroach.proto.ResponseHeader header = 1;
bool HeartbeatTxnResponse::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void HeartbeatTxnResponse::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
void HeartbeatTxnResponse::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
void HeartbeatTxnResponse::clear_header() {
  if (header_ != NULL) header_->::cockroach::proto::ResponseHeader::Clear();
  clear_has_header();
}
 const ::cockroach::proto::ResponseHeader& HeartbeatTxnResponse::header() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.HeartbeatTxnResponse.header)
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
 ::cockroach::proto::ResponseHeader* HeartbeatTxnResponse::mutable_header() {
  set_has_header();
  if (header_ == NULL) {
    header_ = new ::cockroach::proto::ResponseHeader;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.proto.HeartbeatTxnResponse.header)
  return header_;
}
 ::cockroach::proto::ResponseHeader* HeartbeatTxnResponse::release_header() {
  clear_has_header();
  ::cockroach::proto::ResponseHeader* temp = header_;
  header_ = NULL;
  return temp;
}
 void HeartbeatTxnResponse::set_allocated_header(::cockroach::proto::ResponseHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.HeartbeatTxnResponse.header)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#ifndef _MSC_VER
const int GCRequest_GCKey::kKeyFieldNumber;
const int GCRequest_GCKey::kTimestampFieldNumber;
#endif  // !_MSC_VER

GCRequest_GCKey::GCRequest_GCKey()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:cockroach.proto.GCRequest.GCKey)
}

void GCRequest_GCKey::InitAsDefaultInstance() {
  timestamp_ = const_cast< ::cockroach::proto::Timestamp*>(&::cockroach::proto::Timestamp::default_instance());
}

GCRequest_GCKey::GCRequest_GCKey(const GCRequest_GCKey& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:cockroach.proto.GCRequest.GCKey)
}

void GCRequest_GCKey::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  key_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  timestamp_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GCRequest_GCKey::~GCRequest_GCKey() {
  // @@protoc_insertion_point(destructor:cockroach.proto.GCRequest.GCKey)
  SharedDtor();
}

void GCRequest_GCKey::SharedDtor() {
  key_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != default_instance_) {
    delete timestamp_;
  }
}

void GCRequest_GCKey::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* GCRequest_GCKey::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return GCRequest_GCKey_descriptor_;
}

const GCRequest_GCKey& GCRequest_GCKey::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_cockroach_2fproto_2fapi_2eproto();
  return *default_instance_;
}

GCRequest_GCKey* GCRequest_GCKey::default_instance_ = NULL;

GCRequest_GCKey* GCRequest_GCKey::New(::google::protobuf::Arena* arena) const {
  GCRequest_GCKey* n = new GCRequest_GCKey;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void GCRequest_GCKey::Clear() {
  if (_has_bits_[0 / 32] & 3u) {
    if (has_key()) {
      key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    if (has_timestamp()) {
      if (timestamp_ != NULL) timestamp_->::cockroach::proto::Timestamp::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool GCRequest_GCKey::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:cockroach.proto.GCRequest.GCKey)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional bytes key = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_key()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_timestamp;
        break;
      }

      // optional .cockroach.proto.Timestamp timestamp = 2;
      case 2: {
        if (tag == 18) {
         parse_timestamp:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_timestamp()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:cockroach.proto.GCRequest.GCKey)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:cockroach.proto.GCRequest.GCKey)
  return false;
#undef DO_
}

void GCRequest_GCKey::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:cockroach.proto.GCRequest.GCKey)
  // optional bytes key = 1;
  if (has_key()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      1, this->key(), output);
  }

  // optional .cockroach.proto.Timestamp timestamp = 2;
  if (has_timestamp()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, *this->timestamp_, output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:cockroach.proto.GCRequest.GCKey)
}

::google::protobuf::uint8* GCRequest_GCKey::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:cockroach.proto.GCRequest.GCKey)
  // optional bytes key = 1;
  if (has_key()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        1, this->key(), target);
  }

  // optional .cockroach.proto.Timestamp timestamp = 2;
  if (has_timestamp()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, *this->timestamp_, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:cockroach.proto.GCRequest.GCKey)
  return target;
}

int GCRequest_GCKey::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & 3) {
    // optional bytes key = 1;
    if (has_key()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->key());
    }

    // optional .cockroach.proto.Timestamp timestamp = 2;
    if (has_timestamp()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->timestamp_);
    }

  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GCRequest_GCKey::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const GCRequest_GCKey* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const GCRequest_GCKey>(
          &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void GCRequest_GCKey::MergeFrom(const GCRequest_GCKey& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_key()) {
      set_has_key();
      key_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.key_);
    }
    if (from.has_timestamp()) {
      mutable_timestamp()->::cockroach::proto::Timestamp::MergeFrom(from.timestamp());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void GCRequest_GCKey::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void GCRequest_GCKey::CopyFrom(const GCRequest_GCKey& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GCRequest_GCKey::IsInitialized() const {

  return true;
}

void GCRequest_GCKey::Swap(GCRequest_GCKey* other) {
  if (other == this) return;
  InternalSwap(other);
}
void GCRequest_GCKey::InternalSwap(GCRequest_GCKey* other) {
  key_.Swap(&other->key_);
  std::swap(timestamp_, other->timestamp_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata GCRequest_GCKey::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = GCRequest_GCKey_descriptor_;
  metadata.reflection = GCRequest_GCKey_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int GCRequest::kHeaderFieldNumber;
const int GCRequest::kGcMetaFieldNumber;
const int GCRequest::kKeysFieldNumber;
#endif  // !_MSC_VER

GCRequest::GCRequest()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:cockroach.proto.GCRequest)
}

void GCRequest::InitAsDefaultInstance() {
  header_ = const_cast< ::cockroach::proto::RequestHeader*>(&::cockroach::proto::RequestHeader::default_instance());
  gc_meta_ = const_cast< ::cockroach::proto::GCMetadata*>(&::cockroach::proto::GCMetadata::default_instance());
}

GCRequest::GCRequest(const GCRequest& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:cockroach.proto.GCRequest)
}

void GCRequest::SharedCtor() {
  _cached_size_ = 0;
  header_ = NULL;
  gc_meta_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GCRequest::~GCRequest() {
  // @@protoc_insertion_point(destructor:cockroach.proto.GCRequest)
  SharedDtor();
}

void GCRequest::SharedDtor() {
  if (this != default_instance_) {
    delete header_;
    delete gc_meta_;
  }
}

void GCRequest::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* GCRequest::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return GCRequest_descriptor_;
}

const GCRequest& GCRequest::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_cockroach_2fproto_2fapi_2eproto();
  return *default_instance_;
}

GCRequest* GCRequest::default_instance_ = NULL;

GCRequest* GCRequest::New(::google::protobuf::Arena* arena) const {
  GCRequest* n = new GCRequest;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void GCRequest::Clear() {
  if (_has_bits_[0 / 32] & 3u) {
    if (has_header()) {
      if (header_ != NULL) header_->::cockroach::proto::RequestHeader::Clear();
    }
    if (has_gc_meta()) {
      if (gc_meta_ != NULL) gc_meta_->::cockroach::proto::GCMetadata::Clear();
    }
  }
  keys_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool GCRequest::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:cockroach.proto.GCRequest)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .cockroach.proto.RequestHeader header = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_header()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_gc_meta;
        break;
      }

      // optional .cockroach.proto.GCMetadata gc_meta = 2;
      case 2: {
        if (tag == 18) {
         parse_gc_meta:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_gc_meta()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_keys;
        break;
      }

      // repeated .cockroach.proto.GCRequest.GCKey keys = 3;
      case 3: {
        if (tag == 26) {
         parse_keys:
          DO_(input->IncrementRecursionDepth());
         parse_loop_keys:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                input, add_keys()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_loop_keys;
        input->UnsafeDecrementRecursionDepth();
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:cockroach.proto.GCRequest)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:cockroach.proto.GCRequest)
  return false;
#undef DO_
}

void GCRequest::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:cockroach.proto.GCRequest)
  // optional .cockroach.proto.RequestHeader header = 1;
  if (has_header()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->header_, output);
  }

  // optional .cockroach.proto.GCMetadata gc_meta = 2;
  if (has_gc_meta()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, *this->gc_meta_, output);
  }

  // repeated .cockroach.proto.GCRequest.GCKey keys = 3;
  for (unsigned int i = 0, n = this->keys_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->keys(i), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:cockroach.proto.GCRequest)
}

::google::protobuf::uint8* GCRequest::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:cockroach.proto.GCRequest)
  // optional .cockroach.proto.RequestHeader header = 1;
  if (has_header()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, *this->header_, target);
  }

  // optional .cockroach.proto.GCMetadata gc_meta = 2;
  if (has_gc_meta()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, *this->gc_meta_, target);
  }

  // repeated .cockroach.proto.GCRequest.GCKey keys = 3;
  for (unsigned int i = 0, n = this->keys_size(); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->keys(i), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:cockroach.proto.GCRequest)
  return target;
}

int GCRequest::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & 3) {
    // optional .cockroach.proto.RequestHeader header = 1;
    if (has_header()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->header_);
    }

    // optional .cockroach.proto.GCMetadata gc_meta = 2;
    if (has_gc_meta()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->gc_meta_);
    }

  }
  // repeated .cockroach.proto.GCRequest.GCKey keys = 3;
  total_size += 1 * this->keys_size();
  for (int i = 0; i < this->keys_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->keys(i));
  }

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GCRequest::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const GCRequest* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const GCRequest>(
          &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void GCRequest::MergeFrom(const GCRequest& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  keys_.MergeFrom(from.keys_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_header()) {
      mutable_header()->::cockroach::proto::RequestHeader::MergeFrom(from.header());
    }
    if (from.has_gc_meta()) {
      mutable_gc_meta()->::cockroach::proto::GCMetadata::MergeFrom(from.gc_meta());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void GCRequest::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void GCRequest::CopyFrom(const GCRequest& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GCRequest::IsInitialized() const {

  return true;
}

void GCRequest::Swap(GCRequest* other) {
  if (other == this) return;
  InternalSwap(other);
}
void GCRequest::InternalSwap(GCRequest* other) {
  std::swap(header_, other->header_);
  std::swap(gc_meta_, other->gc_meta_);
  keys_.UnsafeArenaSwap(&other->keys_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata GCRequest::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = GCRequest_descriptor_;
  metadata.reflection = GCRequest_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// GCRequest_GCKey

// optional bytes key = 1;
bool GCRequest_GCKey::has_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void GCRequest_GCKey::set_has_key() {
  _has_bits_[0] |= 0x00000001u;
}
void GCRequest_GCKey::clear_has_key() {
  _has_bits_[0] &= ~0x00000001u;
}
void GCRequest_GCKey::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_key();
}
 const ::std::string& GCRequest_GCKey::key() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.GCRequest.GCKey.key)
  return key_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void GCRequest_GCKey::set_key(const ::std::string& value) {
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cockroach.proto.GCRequest.GCKey.key)
}
 void GCRequest_GCKey::set_key(const char* value) {
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cockroach.proto.GCRequest.GCKey.key)
}
 void GCRequest_GCKey::set_key(const void* value, size_t size) {
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cockroach.proto.GCRequest.GCKey.key)
}
 ::std::string* GCRequest_GCKey::mutable_key() {
  set_has_key();
  // @@protoc_insertion_point(field_mutable:cockroach.proto.GCRequest.GCKey.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* GCRequest_GCKey::release_key() {
  clear_has_key();
  return key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void GCRequest_GCKey::set_allocated_key(::std::string* key) {
  if (key != NULL) {
    set_has_key();
  } else {
    clear_has_key();
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.GCRequest.GCKey.key)
}

// optional .cockroach.proto.Timestamp timestamp = 2;
bool GCRequest_GCKey::has_timestamp() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void GCRequest_GCKey::set_has_timestamp() {
  _has_bits_[0] |= 0x00000002u;
}
void GCRequest_GCKey::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000002u;
}
void GCRequest_GCKey::clear_timestamp() {
  if (timestamp_ != NULL) timestamp_->::cockroach::proto::Timestamp::Clear();
  clear_has_timestamp();
}
 const ::cockroach::proto::Timestamp& GCRequest_GCKey::timestamp() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.GCRequest.GCKey.timestamp)
  return timestamp_ != NULL ? *timestamp_ : *default_instance_->timestamp_;
}
 ::cockroach::proto::Timestamp* GCRequest_GCKey::mutable_timestamp() {
  set_has_timestamp();
  if (timestamp_ == NULL) {
    timestamp_ = new ::cockroach::proto::Timestamp;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.proto.GCRequest.GCKey.timestamp)
  return timestamp_;
}
 ::cockroach::proto::Timestamp* GCRequest_GCKey::release_timestamp() {
  clear_has_timestamp();
  ::cockroach::proto::Timestamp* temp = timestamp_;
  timestamp_ = NULL;
  return temp;
}
 void GCRequest_GCKey::set_allocated_timestamp(::cockroach::proto::Timestamp* timestamp) {
  delete timestamp_;
  timestamp_ = timestamp;
  if (timestamp) {
    set_has_timestamp();
  } else {
    clear_has_timestamp();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.GCRequest.GCKey.timestamp)
}

// -------------------------------------------------------------------

// GCRequest

// optional .cockroach.proto.RequestHeader header = 1;
bool GCRequest::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void GCRequest::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
void GCRequest::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
void GCRequest::clear_header() {
  if (header_ != NULL) header_->::cockroach::proto::RequestHeader::Clear();
  clear_has_header();
}
 const ::cockroach::proto::RequestHeader& GCRequest::header() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.GCRequest.header)
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
 ::cockroach::proto::RequestHeader* GCRequest::mutable_header() {
  set_has_header();
  if (header_ == NULL) {
    header_ = new ::cockroach::proto::RequestHeader;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.proto.GCRequest.header)
  return header_;
}
 ::cockroach::proto::RequestHeader* GCRequest::release_header() {
  clear_has_header();
  ::cockroach::proto::RequestHeader* temp = header_;
  header_ = NULL;
  return temp;
}
 void GCRequest::set_allocated_header(::cockroach::proto::RequestHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.GCRequest.header)
}

// optional .cockroach.proto.GCMetadata gc_meta = 2;
bool GCRequest::has_gc_meta() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void GCRequest::set_has_gc_meta() {
  _has_bits_[0] |= 0x00000002u;
}
void GCRequest::clear_has_gc_meta() {
  _has_bits_[0] &= ~0x00000002u;
}
void GCRequest::clear_gc_meta() {
  if (gc_meta_ != NULL) gc_meta_->::cockroach::proto::GCMetadata::Clear();
  clear_has_gc_meta();
}
 const ::cockroach::proto::GCMetadata& GCRequest::gc_meta() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.GCRequest.gc_meta)
  return gc_meta_ != NULL ? *gc_meta_ : *default_instance_->gc_meta_;
}
 ::cockroach::proto::GCMetadata* GCRequest::mutable_gc_meta() {
  set_has_gc_meta();
  if (gc_meta_ == NULL) {
    gc_meta_ = new ::cockroach::proto::GCMetadata;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.proto.GCRequest.gc_meta)
  return gc_meta_;
}
 ::cockroach::proto::GCMetadata* GCRequest::release_gc_meta() {
  clear_has_gc_meta();
  ::cockroach::proto::GCMetadata* temp = gc_meta_;
  gc_meta_ = NULL;
  return temp;
}
 void GCRequest::set_allocated_gc_meta(::cockroach::proto::GCMetadata* gc_meta) {
  delete gc_meta_;
  gc_meta_ = gc_meta;
  if (gc_meta) {
    set_has_gc_meta();
  } else {
    clear_has_gc_meta();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.GCRequest.gc_meta)
}

// repeated .cockroach.proto.GCRequest.GCKey keys = 3;
int GCRequest::keys_size() const {
  return keys_.size();
}
void GCRequest::clear_keys() {
  keys_.Clear();
}
 const ::cockroach::proto::GCRequest_GCKey& GCRequest::keys(int index) const {
  // @@protoc_insertion_point(field_get:cockroach.proto.GCRequest.keys)
  return keys_.Get(index);
}
 ::cockroach::proto::GCRequest_GCKey* GCRequest::mutable_keys(int index) {
  // @@protoc_insertion_point(field_mutable:cockroach.proto.GCRequest.keys)
  return keys_.Mutable(index);
}
 ::cockroach::proto::GCRequest_GCKey* GCRequest::add_keys() {
  // @@protoc_insertion_point(field_add:cockroach.proto.GCRequest.keys)
  return keys_.Add();
}
 const ::google::protobuf::RepeatedPtrField< ::cockroach::proto::GCRequest_GCKey >&
GCRequest::keys() const {
  // @@protoc_insertion_point(field_list:cockroach.proto.GCRequest.keys)
  return keys_;
}
 ::google::protobuf::RepeatedPtrField< ::cockroach::proto::GCRequest_GCKey >*
GCRequest::mutable_keys() {
  // @@protoc_insertion_point(field_mutable_list:cockroach.proto.GCRequest.keys)
  return &keys_;
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#ifndef _MSC_VER
const int GCResponse::kHeaderFieldNumber;
#endif  // !_MSC_VER

GCResponse::GCResponse()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:cockroach.proto.GCResponse)
}

void GCResponse::InitAsDefaultInstance() {
  header_ = const_cast< ::cockroach::proto::ResponseHeader*>(&::cockroach::proto::ResponseHeader::default_instance());
}

GCResponse::GCResponse(const GCResponse& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:cockroach.proto.GCResponse)
}

void GCResponse::SharedCtor() {
  _cached_size_ = 0;
  header_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GCResponse::~GCResponse() {
  // @@protoc_insertion_point(destructor:cockroach.proto.GCResponse)
  SharedDtor();
}

void GCResponse::SharedDtor() {
  if (this != default_instance_) {
    delete header_;
  }
}

void GCResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* GCResponse::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return GCResponse_descriptor_;
}

const GCResponse& GCResponse::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_cockroach_2fproto_2fapi_2eproto();
  return *default_instance_;
}

GCResponse* GCResponse::default_instance_ = NULL;

GCResponse* GCResponse::New(::google::protobuf::Arena* arena) const {
  GCResponse* n = new GCResponse;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void GCResponse::Clear() {
  if (has_header()) {
    if (header_ != NULL) header_->::cockroach::proto::ResponseHeader::Clear();
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool GCResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:cockroach.proto.GCResponse)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .cockroach.proto.ResponseHeader header = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_header()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:cockroach.proto.GCResponse)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:cockroach.proto.GCResponse)
  return false;
#undef DO_
}

void GCResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:cockroach.proto.GCResponse)
  // optional .cockroach.proto.ResponseHeader header = 1;
  if (has_header()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->header_, output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:cockroach.proto.GCResponse)
}

::google::protobuf::uint8* GCResponse::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:cockroach.proto.GCResponse)
  // optional .cockroach.proto.ResponseHeader header = 1;
  if (has_header()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, *this->header_, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:cockroach.proto.GCResponse)
  return target;
}

int GCResponse::ByteSize() const {
  int total_size = 0;

  // optional .cockroach.proto.ResponseHeader header = 1;
  if (has_header()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->header_);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GCResponse::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const GCResponse* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const GCResponse>(
          &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void GCResponse::MergeFrom(const GCResponse& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_header()) {
      mutable_header()->::cockroach::proto::ResponseHeader::MergeFrom(from.header());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void GCResponse::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void GCResponse::CopyFrom(const GCResponse& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GCResponse::IsInitialized() const {

  return true;
}

void GCResponse::Swap(GCResponse* other) {
  if (other == this) return;
  InternalSwap(other);
}
void GCResponse::InternalSwap(GCResponse* other) {
  std::swap(header_, other->header_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata GCResponse::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = GCResponse_descriptor_;
  metadata.reflection = GCResponse_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// GCResponse

// optional .cockroach.proto.ResponseHeader header = 1;
bool GCResponse::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void GCResponse::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
void GCResponse::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
void GCResponse::clear_header() {
  if (header_ != NULL) header_->::cockroach::proto::ResponseHeader::Clear();
  clear_has_header();
}
 const ::cockroach::proto::ResponseHeader& GCResponse::header() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.GCResponse.header)
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
 ::cockroach::proto::ResponseHeader* GCResponse::mutable_header() {
  set_has_header();
  if (header_ == NULL) {
    header_ = new ::cockroach::proto::ResponseHeader;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.proto.GCResponse.header)
  return header_;
}
 ::cockroach::proto::ResponseHeader* GCResponse::release_header() {
  clear_has_header();
  ::cockroach::proto::ResponseHeader* temp = header_;
  header_ = NULL;
  return temp;
}
 void GCResponse::set_allocated_header(::cockroach::proto::ResponseHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.GCResponse.header)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#ifndef _MSC_VER
const int PushTxnRequest::kHeaderFieldNumber;
const int PushTxnRequest::kPusherTxnFieldNumber;
const int PushTxnRequest::kPusheeTxnFieldNumber;
const int PushTxnRequest::kNowFieldNumber;
const int PushTxnRequest::kPushTypeFieldNumber;
#endif  // !_MSC_VER

PushTxnRequest::PushTxnRequest()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:cockroach.proto.PushTxnRequest)
}

void PushTxnRequest::InitAsDefaultInstance() {
  header_ = const_cast< ::cockroach::proto::RequestHeader*>(&::cockroach::proto::RequestHeader::default_instance());
  pusher_txn_ = const_cast< ::cockroach::proto::Transaction*>(&::cockroach::proto::Transaction::default_instance());
  pushee_txn_ = const_cast< ::cockroach::proto::Transaction*>(&::cockroach::proto::Transaction::default_instance());
  now_ = const_cast< ::cockroach::proto::Timestamp*>(&::cockroach::proto::Timestamp::default_instance());
}

PushTxnRequest::PushTxnRequest(const PushTxnRequest& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:cockroach.proto.PushTxnRequest)
}

void PushTxnRequest::SharedCtor() {
  _cached_size_ = 0;
  header_ = NULL;
  pusher_txn_ = NULL;
  pushee_txn_ = NULL;
  now_ = NULL;
  push_type_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

PushTxnRequest::~PushTxnRequest() {
  // @@protoc_insertion_point(destructor:cockroach.proto.PushTxnRequest)
  SharedDtor();
}

void PushTxnRequest::SharedDtor() {
  if (this != default_instance_) {
    delete header_;
    delete pusher_txn_;
    delete pushee_txn_;
    delete now_;
  }
}

void PushTxnRequest::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* PushTxnRequest::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return PushTxnRequest_descriptor_;
}

const PushTxnRequest& PushTxnRequest::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_cockroach_2fproto_2fapi_2eproto();
  return *default_instance_;
}

PushTxnRequest* PushTxnRequest::default_instance_ = NULL;

PushTxnRequest* PushTxnRequest::New(::google::protobuf::Arena* arena) const {
  PushTxnRequest* n = new PushTxnRequest;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void PushTxnRequest::Clear() {
  if (_has_bits_[0 / 32] & 31u) {
    if (has_header()) {
      if (header_ != NULL) header_->::cockroach::proto::RequestHeader::Clear();
    }
    if (has_pusher_txn()) {
      if (pusher_txn_ != NULL) pusher_txn_->::cockroach::proto::Transaction::Clear();
    }
    if (has_pushee_txn()) {
      if (pushee_txn_ != NULL) pushee_txn_->::cockroach::proto::Transaction::Clear();
    }
    if (has_now()) {
      if (now_ != NULL) now_->::cockroach::proto::Timestamp::Clear();
    }
    push_type_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool PushTxnRequest::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:cockroach.proto.PushTxnRequest)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .cockroach.proto.RequestHeader header = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_header()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_pusher_txn;
        break;
      }

      // optional .cockroach.proto.Transaction pusher_txn = 2;
      case 2: {
        if (tag == 18) {
         parse_pusher_txn:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_pusher_txn()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_pushee_txn;
        break;
      }

      // optional .cockroach.proto.Transaction pushee_txn = 3;
      case 3: {
        if (tag == 26) {
         parse_pushee_txn:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_pushee_txn()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_now;
        break;
      }

      // optional .cockroach.proto.Timestamp now = 4;
      case 4: {
        if (tag == 34) {
         parse_now:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_now()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_push_type;
        break;
      }

      // optional .cockroach.proto.PushTxnType push_type = 5;
      case 5: {
        if (tag == 40) {
         parse_push_type:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::cockroach::proto::PushTxnType_IsValid(value)) {
            set_push_type(static_cast< ::cockroach::proto::PushTxnType >(value));
          } else {
            mutable_unknown_fields()->AddVarint(5, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:cockroach.proto.PushTxnRequest)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:cockroach.proto.PushTxnRequest)
  return false;
#undef DO_
}

void PushTxnRequest::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:cockroach.proto.PushTxnRequest)
  // optional .cockroach.proto.RequestHeader header = 1;
  if (has_header()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->header_, output);
  }

  // optional .cockroach.proto.Transaction pusher_txn = 2;
  if (has_pusher_txn()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, *this->pusher_txn_, output);
  }

  // optional .cockroach.proto.Transaction pushee_txn = 3;
  if (has_pushee_txn()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, *this->pushee_txn_, output);
  }

  // optional .cockroach.proto.Timestamp now = 4;
  if (has_now()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, *this->now_, output);
  }

  // optional .cockroach.proto.PushTxnType push_type = 5;
  if (has_push_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      5, this->push_type(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:cockroach.proto.PushTxnRequest)
}

::google::protobuf::uint8* PushTxnRequest::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:cockroach.proto.PushTxnRequest)
  // optional .cockroach.proto.RequestHeader header = 1;
  if (has_header()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, *this->header_, target);
  }

  // optional .cockroach.proto.Transaction pusher_txn = 2;
  if (has_pusher_txn()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, *this->pusher_txn_, target);
  }

  // optional .cockroach.proto.Transaction pushee_txn = 3;
  if (has_pushee_txn()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, *this->pushee_txn_, target);
  }

  // optional .cockroach.proto.Timestamp now = 4;
  if (has_now()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        4, *this->now_, target);
  }

  // optional .cockroach.proto.PushTxnType push_type = 5;
  if (has_push_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      5, this->push_type(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:cockroach.proto.PushTxnRequest)
  return target;
}

int PushTxnRequest::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & 31) {
    // optional .cockroach.proto.RequestHeader header = 1;
    if (has_header()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->header_);
    }

    // optional .cockroach.proto.Transaction pusher_txn = 2;
    if (has_pusher_txn()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->pusher_txn_);
    }

    // optional .cockroach.proto.Transaction pushee_txn = 3;
    if (has_pushee_txn()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->pushee_txn_);
    }

    // optional .cockroach.proto.Timestamp now = 4;
    if (has_now()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->now_);
    }

    // optional .cockroach.proto.PushTxnType push_type = 5;
    if (has_push_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->push_type());
    }

  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void PushTxnRequest::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const PushTxnRequest* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const PushTxnRequest>(
          &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void PushTxnRequest::MergeFrom(const PushTxnRequest& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_header()) {
      mutable_header()->::cockroach::proto::RequestHeader::MergeFrom(from.header());
    }
    if (from.has_pusher_txn()) {
      mutable_pusher_txn()->::cockroach::proto::Transaction::MergeFrom(from.pusher_txn());
    }
    if (from.has_pushee_txn()) {
      mutable_pushee_txn()->::cockroach::proto::Transaction::MergeFrom(from.pushee_txn());
    }
    if (from.has_now()) {
      mutable_now()->::cockroach::proto::Timestamp::MergeFrom(from.now());
    }
    if (from.has_push_type()) {
      set_push_type(from.push_type());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void PushTxnRequest::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void PushTxnRequest::CopyFrom(const PushTxnRequest& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PushTxnRequest::IsInitialized() const {

  return true;
}

void PushTxnRequest::Swap(PushTxnRequest* other) {
  if (other == this) return;
  InternalSwap(other);
}
void PushTxnRequest::InternalSwap(PushTxnRequest* other) {
  std::swap(header_, other->header_);
  std::swap(pusher_txn_, other->pusher_txn_);
  std::swap(pushee_txn_, other->pushee_txn_);
  std::swap(now_, other->now_);
  std::swap(push_type_, other->push_type_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata PushTxnRequest::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = PushTxnRequest_descriptor_;
  metadata.reflection = PushTxnRequest_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// PushTxnRequest

// optional .cockroach.proto.RequestHeader header = 1;
bool PushTxnRequest::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void PushTxnRequest::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
void PushTxnRequest::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
void PushTxnRequest::clear_header() {
  if (header_ != NULL) header_->::cockroach::proto::RequestHeader::Clear();
  clear_has_header();
}
 const ::cockroach::proto::RequestHeader& PushTxnRequest::header() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.PushTxnRequest.header)
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
 ::cockroach::proto::RequestHeader* PushTxnRequest::mutable_header() {
  set_has_header();
  if (header_ == NULL) {
    header_ = new ::cockroach::proto::RequestHeader;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.proto.PushTxnRequest.header)
  return header_;
}
 ::cockroach::proto::RequestHeader* PushTxnRequest::release_header() {
  clear_has_header();
  ::cockroach::proto::RequestHeader* temp = header_;
  header_ = NULL;
  return temp;
}
 void PushTxnRequest::set_allocated_header(::cockroach::proto::RequestHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.PushTxnRequest.header)
}

// optional .cockroach.proto.Transaction pusher_txn = 2;
bool PushTxnRequest::has_pusher_txn() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void PushTxnRequest::set_has_pusher_txn() {
  _has_bits_[0] |= 0x00000002u;
}
void PushTxnRequest::clear_has_pusher_txn() {
  _has_bits_[0] &= ~0x00000002u;
}
void PushTxnRequest::clear_pusher_txn() {
  if (pusher_txn_ != NULL) pusher_txn_->::cockroach::proto::Transaction::Clear();
  clear_has_pusher_txn();
}
 const ::cockroach::proto::Transaction& PushTxnRequest::pusher_txn() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.PushTxnRequest.pusher_txn)
  return pusher_txn_ != NULL ? *pusher_txn_ : *default_instance_->pusher_txn_;
}
 ::cockroach::proto::Transaction* PushTxnRequest::mutable_pusher_txn() {
  set_has_pusher_txn();
  if (pusher_txn_ == NULL) {
    pusher_txn_ = new ::cockroach::proto::Transaction;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.proto.PushTxnRequest.pusher_txn)
  return pusher_txn_;
}
 ::cockroach::proto::Transaction* PushTxnRequest::release_pusher_txn() {
  clear_has_pusher_txn();
  ::cockroach::proto::Transaction* temp = pusher_txn_;
  pusher_txn_ = NULL;
  return temp;
}
 void PushTxnRequest::set_allocated_pusher_txn(::cockroach::proto::Transaction* pusher_txn) {
  delete pusher_txn_;
  pusher_txn_ = pusher_txn;
  if (pusher_txn) {
    set_has_pusher_txn();
  } else {
    clear_has_pusher_txn();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.PushTxnRequest.pusher_txn)
}

// optional .cockroach.proto.Transaction pushee_txn = 3;
bool PushTxnRequest::has_pushee_txn() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void PushTxnRequest::set_has_pushee_txn() {
  _has_bits_[0] |= 0x00000004u;
}
void PushTxnRequest::clear_has_pushee_txn() {
  _has_bits_[0] &= ~0x00000004u;
}
void PushTxnRequest::clear_pushee_txn() {
  if (pushee_txn_ != NULL) pushee_txn_->::cockroach::proto::Transaction::Clear();
  clear_has_pushee_txn();
}
 const ::cockroach::proto::Transaction& PushTxnRequest::pushee_txn() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.PushTxnRequest.pushee_txn)
  return pushee_txn_ != NULL ? *pushee_txn_ : *default_instance_->pushee_txn_;
}
 ::cockroach::proto::Transaction* PushTxnRequest::mutable_pushee_txn() {
  set_has_pushee_txn();
  if (pushee_txn_ == NULL) {
    pushee_txn_ = new ::cockroach::proto::Transaction;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.proto.PushTxnRequest.pushee_txn)
  return pushee_txn_;
}
 ::cockroach::proto::Transaction* PushTxnRequest::release_pushee_txn() {
  clear_has_pushee_txn();
  ::cockroach::proto::Transaction* temp = pushee_txn_;
  pushee_txn_ = NULL;
  return temp;
}
 void PushTxnRequest::set_allocated_pushee_txn(::cockroach::proto::Transaction* pushee_txn) {
  delete pushee_txn_;
  pushee_txn_ = pushee_txn;
  if (pushee_txn) {
    set_has_pushee_txn();
  } else {
    clear_has_pushee_txn();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.PushTxnRequest.pushee_txn)
}

// optional .cockroach.proto.Timestamp now = 4;
bool PushTxnRequest::has_now() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void PushTxnRequest::set_has_now() {
  _has_bits_[0] |= 0x00000008u;
}
void PushTxnRequest::clear_has_now() {
  _has_bits_[0] &= ~0x00000008u;
}
void PushTxnRequest::clear_now() {
  if (now_ != NULL) now_->::cockroach::proto::Timestamp::Clear();
  clear_has_now();
}
 const ::cockroach::proto::Timestamp& PushTxnRequest::now() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.PushTxnRequest.now)
  return now_ != NULL ? *now_ : *default_instance_->now_;
}
 ::cockroach::proto::Timestamp* PushTxnRequest::mutable_now() {
  set_has_now();
  if (now_ == NULL) {
    now_ = new ::cockroach::proto::Timestamp;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.proto.PushTxnRequest.now)
  return now_;
}
 ::cockroach::proto::Timestamp* PushTxnRequest::release_now() {
  clear_has_now();
  ::cockroach::proto::Timestamp* temp = now_;
  now_ = NULL;
  return temp;
}
 void PushTxnRequest::set_allocated_now(::cockroach::proto::Timestamp* now) {
  delete now_;
  now_ = now;
  if (now) {
    set_has_now();
  } else {
    clear_has_now();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.PushTxnRequest.now)
}

// optional .cockroach.proto.PushTxnType push_type = 5;
bool PushTxnRequest::has_push_type() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
void PushTxnRequest::set_has_push_type() {
  _has_bits_[0] |= 0x00000010u;
}
void PushTxnRequest::clear_has_push_type() {
  _has_bits_[0] &= ~0x00000010u;
}
void PushTxnRequest::clear_push_type() {
  push_type_ = 0;
  clear_has_push_type();
}
 ::cockroach::proto::PushTxnType PushTxnRequest::push_type() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.PushTxnRequest.push_type)
  return static_cast< ::cockroach::proto::PushTxnType >(push_type_);
}
 void PushTxnRequest::set_push_type(::cockroach::proto::PushTxnType value) {
  assert(::cockroach::proto::PushTxnType_IsValid(value));
  set_has_push_type();
  push_type_ = value;
  // @@protoc_insertion_point(field_set:cockroach.proto.PushTxnRequest.push_type)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#ifndef _MSC_VER
const int PushTxnResponse::kHeaderFieldNumber;
const int PushTxnResponse::kPusheeTxnFieldNumber;
#endif  // !_MSC_VER

PushTxnResponse::PushTxnResponse()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:cockroach.proto.PushTxnResponse)
}

void PushTxnResponse::InitAsDefaultInstance() {
  header_ = const_cast< ::cockroach::proto::ResponseHeader*>(&::cockroach::proto::ResponseHeader::default_instance());
  pushee_txn_ = const_cast< ::cockroach::proto::Transaction*>(&::cockroach::proto::Transaction::default_instance());
}

PushTxnResponse::PushTxnResponse(const PushTxnResponse& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:cockroach.proto.PushTxnResponse)
}

void PushTxnResponse::SharedCtor() {
  _cached_size_ = 0;
  header_ = NULL;
  pushee_txn_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

PushTxnResponse::~PushTxnResponse() {
  // @@protoc_insertion_point(destructor:cockroach.proto.PushTxnResponse)
  SharedDtor();
}

void PushTxnResponse::SharedDtor() {
  if (this != default_instance_) {
    delete header_;
    delete pushee_txn_;
  }
}

void PushTxnResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* PushTxnResponse::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return PushTxnResponse_descriptor_;
}

const PushTxnResponse& PushTxnResponse::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_cockroach_2fproto_2fapi_2eproto();
  return *default_instance_;
}

PushTxnResponse* PushTxnResponse::default_instance_ = NULL;

PushTxnResponse* PushTxnResponse::New(::google::protobuf::Arena* arena) const {
  PushTxnResponse* n = new PushTxnResponse;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void PushTxnResponse::Clear() {
  if (_has_bits_[0 / 32] & 3u) {
    if (has_header()) {
      if (header_ != NULL) header_->::cockroach::proto::ResponseHeader::Clear();
    }
    if (has_pushee_txn()) {
      if (pushee_txn_ != NULL) pushee_txn_->::cockroach::proto::Transaction::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool PushTxnResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:cockroach.proto.PushTxnResponse)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .cockroach.proto.ResponseHeader header = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_header()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_pushee_txn;
        break;
      }

      // optional .cockroach.proto.Transaction pushee_txn = 2;
      case 2: {
        if (tag == 18) {
         parse_pushee_txn:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_pushee_txn()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:cockroach.proto.PushTxnResponse)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:cockroach.proto.PushTxnResponse)
  return false;
#undef DO_
}

void PushTxnResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:cockroach.proto.PushTxnResponse)
  // optional .cockroach.proto.ResponseHeader header = 1;
  if (has_header()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->header_, output);
  }

  // optional .cockroach.proto.Transaction pushee_txn = 2;
  if (has_pushee_txn()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, *this->pushee_txn_, output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:cockroach.proto.PushTxnResponse)
}

::google::protobuf::uint8* PushTxnResponse::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:cockroach.proto.PushTxnResponse)
  // optional .cockroach.proto.ResponseHeader header = 1;
  if (has_header()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, *this->header_, target);
  }

  // optional .cockroach.proto.Transaction pushee_txn = 2;
  if (has_pushee_txn()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, *this->pushee_txn_, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:cockroach.proto.PushTxnResponse)
  return target;
}

int PushTxnResponse::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & 3) {
    // optional .cockroach.proto.ResponseHeader header = 1;
    if (has_header()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->header_);
    }

    // optional .cockroach.proto.Transaction pushee_txn = 2;
    if (has_pushee_txn()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->pushee_txn_);
    }

  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void PushTxnResponse::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const PushTxnResponse* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const PushTxnResponse>(
          &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void PushTxnResponse::MergeFrom(const PushTxnResponse& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_header()) {
      mutable_header()->::cockroach::proto::ResponseHeader::MergeFrom(from.header());
    }
    if (from.has_pushee_txn()) {
      mutable_pushee_txn()->::cockroach::proto::Transaction::MergeFrom(from.pushee_txn());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void PushTxnResponse::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void PushTxnResponse::CopyFrom(const PushTxnResponse& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PushTxnResponse::IsInitialized() const {

  return true;
}

void PushTxnResponse::Swap(PushTxnResponse* other) {
  if (other == this) return;
  InternalSwap(other);
}
void PushTxnResponse::InternalSwap(PushTxnResponse* other) {
  std::swap(header_, other->header_);
  std::swap(pushee_txn_, other->pushee_txn_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata PushTxnResponse::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = PushTxnResponse_descriptor_;
  metadata.reflection = PushTxnResponse_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// PushTxnResponse

// optional .cockroach.proto.ResponseHeader header = 1;
bool PushTxnResponse::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void PushTxnResponse::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
void PushTxnResponse::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
void PushTxnResponse::clear_header() {
  if (header_ != NULL) header_->::cockroach::proto::ResponseHeader::Clear();
  clear_has_header();
}
 const ::cockroach::proto::ResponseHeader& PushTxnResponse::header() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.PushTxnResponse.header)
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
 ::cockroach::proto::ResponseHeader* PushTxnResponse::mutable_header() {
  set_has_header();
  if (header_ == NULL) {
    header_ = new ::cockroach::proto::ResponseHeader;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.proto.PushTxnResponse.header)
  return header_;
}
 ::cockroach::proto::ResponseHeader* PushTxnResponse::release_header() {
  clear_has_header();
  ::cockroach::proto::ResponseHeader* temp = header_;
  header_ = NULL;
  return temp;
}
 void PushTxnResponse::set_allocated_header(::cockroach::proto::ResponseHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.PushTxnResponse.header)
}

// optional .cockroach.proto.Transaction pushee_txn = 2;
bool PushTxnResponse::has_pushee_txn() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void PushTxnResponse::set_has_pushee_txn() {
  _has_bits_[0] |= 0x00000002u;
}
void PushTxnResponse::clear_has_pushee_txn() {
  _has_bits_[0] &= ~0x00000002u;
}
void PushTxnResponse::clear_pushee_txn() {
  if (pushee_txn_ != NULL) pushee_txn_->::cockroach::proto::Transaction::Clear();
  clear_has_pushee_txn();
}
 const ::cockroach::proto::Transaction& PushTxnResponse::pushee_txn() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.PushTxnResponse.pushee_txn)
  return pushee_txn_ != NULL ? *pushee_txn_ : *default_instance_->pushee_txn_;
}
 ::cockroach::proto::Transaction* PushTxnResponse::mutable_pushee_txn() {
  set_has_pushee_txn();
  if (pushee_txn_ == NULL) {
    pushee_txn_ = new ::cockroach::proto::Transaction;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.proto.PushTxnResponse.pushee_txn)
  return pushee_txn_;
}
 ::cockroach::proto::Transaction* PushTxnResponse::release_pushee_txn() {
  clear_has_pushee_txn();
  ::cockroach::proto::Transaction* temp = pushee_txn_;
  pushee_txn_ = NULL;
  return temp;
}
 void PushTxnResponse::set_allocated_pushee_txn(::cockroach::proto::Transaction* pushee_txn) {
  delete pushee_txn_;
  pushee_txn_ = pushee_txn;
  if (pushee_txn) {
    set_has_pushee_txn();
  } else {
    clear_has_pushee_txn();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.PushTxnResponse.pushee_txn)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#ifndef _MSC_VER
const int ResolveIntentRequest::kHeaderFieldNumber;
const int ResolveIntentRequest::kIntentTxnFieldNumber;
#endif  // !_MSC_VER

ResolveIntentRequest::ResolveIntentRequest()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:cockroach.proto.ResolveIntentRequest)
}

void ResolveIntentRequest::InitAsDefaultInstance() {
  header_ = const_cast< ::cockroach::proto::RequestHeader*>(&::cockroach::proto::RequestHeader::default_instance());
  intent_txn_ = const_cast< ::cockroach::proto::Transaction*>(&::cockroach::proto::Transaction::default_instance());
}

ResolveIntentRequest::ResolveIntentRequest(const ResolveIntentRequest& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:cockroach.proto.ResolveIntentRequest)
}

void ResolveIntentRequest::SharedCtor() {
  _cached_size_ = 0;
  header_ = NULL;
  intent_txn_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ResolveIntentRequest::~ResolveIntentRequest() {
  // @@protoc_insertion_point(destructor:cockroach.proto.ResolveIntentRequest)
  SharedDtor();
}

void ResolveIntentRequest::SharedDtor() {
  if (this != default_instance_) {
    delete header_;
    delete intent_txn_;
  }
}

void ResolveIntentRequest::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ResolveIntentRequest::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ResolveIntentRequest_descriptor_;
}

const ResolveIntentRequest& ResolveIntentRequest::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_cockroach_2fproto_2fapi_2eproto();
  return *default_instance_;
}

ResolveIntentRequest* ResolveIntentRequest::default_instance_ = NULL;

ResolveIntentRequest* ResolveIntentRequest::New(::google::protobuf::Arena* arena) const {
  ResolveIntentRequest* n = new ResolveIntentRequest;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void ResolveIntentRequest::Clear() {
  if (_has_bits_[0 / 32] & 3u) {
    if (has_header()) {
      if (header_ != NULL) header_->::cockroach::proto::RequestHeader::Clear();
    }
    if (has_intent_txn()) {
      if (intent_txn_ != NULL) intent_txn_->::cockroach::proto::Transaction::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool ResolveIntentRequest::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:cockroach.proto.ResolveIntentRequest)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .cockroach.proto.RequestHeader header = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_header()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_intent_txn;
        break;
      }

      // optional .cockroach.proto.Transaction intent_txn = 2;
      case 2: {
        if (tag == 18) {
         parse_intent_txn:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_intent_txn()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:cockroach.proto.ResolveIntentRequest)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:cockroach.proto.ResolveIntentRequest)
  return false;
#undef DO_
}

void ResolveIntentRequest::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:cockroach.proto.ResolveIntentRequest)
  // optional .cockroach.proto.RequestHeader header = 1;
  if (has_header()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->header_, output);
  }

  // optional .cockroach.proto.Transaction intent_txn = 2;
  if (has_intent_txn()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, *this->intent_txn_, output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:cockroach.proto.ResolveIntentRequest)
}

::google::protobuf::uint8* ResolveIntentRequest::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:cockroach.proto.ResolveIntentRequest)
  // optional .cockroach.proto.RequestHeader header = 1;
  if (has_header()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, *this->header_, target);
  }

  // optional .cockroach.proto.Transaction intent_txn = 2;
  if (has_intent_txn()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, *this->intent_txn_, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:cockroach.proto.ResolveIntentRequest)
  return target;
}

int ResolveIntentRequest::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & 3) {
    // optional .cockroach.proto.RequestHeader header = 1;
    if (has_header()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->header_);
    }

    // optional .cockroach.proto.Transaction intent_txn = 2;
    if (has_intent_txn()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->intent_txn_);
    }

  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ResolveIntentRequest::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const ResolveIntentRequest* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const ResolveIntentRequest>(
          &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ResolveIntentRequest::MergeFrom(const ResolveIntentRequest& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_header()) {
      mutable_header()->::cockroach::proto::RequestHeader::MergeFrom(from.header());
    }
    if (from.has_intent_txn()) {
      mutable_intent_txn()->::cockroach::proto::Transaction::MergeFrom(from.intent_txn());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void ResolveIntentRequest::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ResolveIntentRequest::CopyFrom(const ResolveIntentRequest& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ResolveIntentRequest::IsInitialized() const {

  return true;
}

void ResolveIntentRequest::Swap(ResolveIntentRequest* other) {
  if (other == this) return;
  InternalSwap(other);
}
void ResolveIntentRequest::InternalSwap(ResolveIntentRequest* other) {
  std::swap(header_, other->header_);
  std::swap(intent_txn_, other->intent_txn_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata ResolveIntentRequest::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ResolveIntentRequest_descriptor_;
  metadata.reflection = ResolveIntentRequest_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// ResolveIntentRequest

// optional .cockroach.proto.RequestHeader header = 1;
bool ResolveIntentRequest::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void ResolveIntentRequest::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
void ResolveIntentRequest::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
void ResolveIntentRequest::clear_header() {
  if (header_ != NULL) header_->::cockroach::proto::RequestHeader::Clear();
  clear_has_header();
}
 const ::cockroach::proto::RequestHeader& ResolveIntentRequest::header() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.ResolveIntentRequest.header)
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
 ::cockroach::proto::RequestHeader* ResolveIntentRequest::mutable_header() {
  set_has_header();
  if (header_ == NULL) {
    header_ = new ::cockroach::proto::RequestHeader;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.proto.ResolveIntentRequest.header)
  return header_;
}
 ::cockroach::proto::RequestHeader* ResolveIntentRequest::release_header() {
  clear_has_header();
  ::cockroach::proto::RequestHeader* temp = header_;
  header_ = NULL;
  return temp;
}
 void ResolveIntentRequest::set_allocated_header(::cockroach::proto::RequestHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.ResolveIntentRequest.header)
}

// optional .cockroach.proto.Transaction intent_txn = 2;
bool ResolveIntentRequest::has_intent_txn() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void ResolveIntentRequest::set_has_intent_txn() {
  _has_bits_[0] |= 0x00000002u;
}
void ResolveIntentRequest::clear_has_intent_txn() {
  _has_bits_[0] &= ~0x00000002u;
}
void ResolveIntentRequest::clear_intent_txn() {
  if (intent_txn_ != NULL) intent_txn_->::cockroach::proto::Transaction::Clear();
  clear_has_intent_txn();
}
 const ::cockroach::proto::Transaction& ResolveIntentRequest::intent_txn() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.ResolveIntentRequest.intent_txn)
  return intent_txn_ != NULL ? *intent_txn_ : *default_instance_->intent_txn_;
}
 ::cockroach::proto::Transaction* ResolveIntentRequest::mutable_intent_txn() {
  set_has_intent_txn();
  if (intent_txn_ == NULL) {
    intent_txn_ = new ::cockroach::proto::Transaction;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.proto.ResolveIntentRequest.intent_txn)
  return intent_txn_;
}
 ::cockroach::proto::Transaction* ResolveIntentRequest::release_intent_txn() {
  clear_has_intent_txn();
  ::cockroach::proto::Transaction* temp = intent_txn_;
  intent_txn_ = NULL;
  return temp;
}
 void ResolveIntentRequest::set_allocated_intent_txn(::cockroach::proto::Transaction* intent_txn) {
  delete intent_txn_;
  intent_txn_ = intent_txn;
  if (intent_txn) {
    set_has_intent_txn();
  } else {
    clear_has_intent_txn();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.ResolveIntentRequest.intent_txn)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#ifndef _MSC_VER
const int ResolveIntentResponse::kHeaderFieldNumber;
#endif  // !_MSC_VER

ResolveIntentResponse::ResolveIntentResponse()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:cockroach.proto.ResolveIntentResponse)
}

void ResolveIntentResponse::InitAsDefaultInstance() {
  header_ = const_cast< ::cockroach::proto::ResponseHeader*>(&::cockroach::proto::ResponseHeader::default_instance());
}

ResolveIntentResponse::ResolveIntentResponse(const ResolveIntentResponse& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:cockroach.proto.ResolveIntentResponse)
}

void ResolveIntentResponse::SharedCtor() {
  _cached_size_ = 0;
  header_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ResolveIntentResponse::~ResolveIntentResponse() {
  // @@protoc_insertion_point(destructor:cockroach.proto.ResolveIntentResponse)
  SharedDtor();
}

void ResolveIntentResponse::SharedDtor() {
  if (this != default_instance_) {
    delete header_;
  }
}

void ResolveIntentResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ResolveIntentResponse::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ResolveIntentResponse_descriptor_;
}

const ResolveIntentResponse& ResolveIntentResponse::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_cockroach_2fproto_2fapi_2eproto();
  return *default_instance_;
}

ResolveIntentResponse* ResolveIntentResponse::default_instance_ = NULL;

ResolveIntentResponse* ResolveIntentResponse::New(::google::protobuf::Arena* arena) const {
  ResolveIntentResponse* n = new ResolveIntentResponse;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void ResolveIntentResponse::Clear() {
  if (has_header()) {
    if (header_ != NULL) header_->::cockroach::proto::ResponseHeader::Clear();
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool ResolveIntentResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:cockroach.proto.ResolveIntentResponse)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .cockroach.proto.ResponseHeader header = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_header()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:cockroach.proto.ResolveIntentResponse)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:cockroach.proto.ResolveIntentResponse)
  return false;
#undef DO_
}

void ResolveIntentResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:cockroach.proto.ResolveIntentResponse)
  // optional .cockroach.proto.ResponseHeader header = 1;
  if (has_header()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->header_, output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:cockroach.proto.ResolveIntentResponse)
}

::google::protobuf::uint8* ResolveIntentResponse::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:cockroach.proto.ResolveIntentResponse)
  // optional .cockroach.proto.ResponseHeader header = 1;
  if (has_header()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, *this->header_, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:cockroach.proto.ResolveIntentResponse)
  return target;
}

int ResolveIntentResponse::ByteSize() const {
  int total_size = 0;

  // optional .cockroach.proto.ResponseHeader header = 1;
  if (has_header()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->header_);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ResolveIntentResponse::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const ResolveIntentResponse* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const ResolveIntentResponse>(
          &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ResolveIntentResponse::MergeFrom(const ResolveIntentResponse& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_header()) {
      mutable_header()->::cockroach::proto::ResponseHeader::MergeFrom(from.header());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void ResolveIntentResponse::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ResolveIntentResponse::CopyFrom(const ResolveIntentResponse& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ResolveIntentResponse::IsInitialized() const {

  return true;
}

void ResolveIntentResponse::Swap(ResolveIntentResponse* other) {
  if (other == this) return;
  InternalSwap(other);
}
void ResolveIntentResponse::InternalSwap(ResolveIntentResponse* other) {
  std::swap(header_, other->header_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata ResolveIntentResponse::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ResolveIntentResponse_descriptor_;
  metadata.reflection = ResolveIntentResponse_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// ResolveIntentResponse

// optional .cockroach.proto.ResponseHeader header = 1;
bool ResolveIntentResponse::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void ResolveIntentResponse::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
void ResolveIntentResponse::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
void ResolveIntentResponse::clear_header() {
  if (header_ != NULL) header_->::cockroach::proto::ResponseHeader::Clear();
  clear_has_header();
}
 const ::cockroach::proto::ResponseHeader& ResolveIntentResponse::header() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.ResolveIntentResponse.header)
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
 ::cockroach::proto::ResponseHeader* ResolveIntentResponse::mutable_header() {
  set_has_header();
  if (header_ == NULL) {
    header_ = new ::cockroach::proto::ResponseHeader;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.proto.ResolveIntentResponse.header)
  return header_;
}
 ::cockroach::proto::ResponseHeader* ResolveIntentResponse::release_header() {
  clear_has_header();
  ::cockroach::proto::ResponseHeader* temp = header_;
  header_ = NULL;
  return temp;
}
 void ResolveIntentResponse::set_allocated_header(::cockroach::proto::ResponseHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.ResolveIntentResponse.header)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#ifndef _MSC_VER
const int ResolveIntentRangeRequest::kHeaderFieldNumber;
const int ResolveIntentRangeRequest::kIntentTxnFieldNumber;
#endif  // !_MSC_VER

ResolveIntentRangeRequest::ResolveIntentRangeRequest()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:cockroach.proto.ResolveIntentRangeRequest)
}

void ResolveIntentRangeRequest::InitAsDefaultInstance() {
  header_ = const_cast< ::cockroach::proto::RequestHeader*>(&::cockroach::proto::RequestHeader::default_instance());
  intent_txn_ = const_cast< ::cockroach::proto::Transaction*>(&::cockroach::proto::Transaction::default_instance());
}

ResolveIntentRangeRequest::ResolveIntentRangeRequest(const ResolveIntentRangeRequest& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:cockroach.proto.ResolveIntentRangeRequest)
}

void ResolveIntentRangeRequest::SharedCtor() {
  _cached_size_ = 0;
  header_ = NULL;
  intent_txn_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ResolveIntentRangeRequest::~ResolveIntentRangeRequest() {
  // @@protoc_insertion_point(destructor:cockroach.proto.ResolveIntentRangeRequest)
  SharedDtor();
}

void ResolveIntentRangeRequest::SharedDtor() {
  if (this != default_instance_) {
    delete header_;
    delete intent_txn_;
  }
}

void ResolveIntentRangeRequest::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ResolveIntentRangeRequest::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ResolveIntentRangeRequest_descriptor_;
}

const ResolveIntentRangeRequest& ResolveIntentRangeRequest::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_cockroach_2fproto_2fapi_2eproto();
  return *default_instance_;
}

ResolveIntentRangeRequest* ResolveIntentRangeRequest::default_instance_ = NULL;

ResolveIntentRangeRequest* ResolveIntentRangeRequest::New(::google::protobuf::Arena* arena) const {
  ResolveIntentRangeRequest* n = new ResolveIntentRangeRequest;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void ResolveIntentRangeRequest::Clear() {
  if (_has_bits_[0 / 32] & 3u) {
    if (has_header()) {
      if (header_ != NULL) header_->::cockroach::proto::RequestHeader::Clear();
    }
    if (has_intent_txn()) {
      if (intent_txn_ != NULL) intent_txn_->::cockroach::proto::Transaction::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool ResolveIntentRangeRequest::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:cockroach.proto.ResolveIntentRangeRequest)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .cockroach.proto.RequestHeader header = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_header()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_intent_txn;
        break;
      }

      // optional .cockroach.proto.Transaction intent_txn = 2;
      case 2: {
        if (tag == 18) {
         parse_intent_txn:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_intent_txn()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:cockroach.proto.ResolveIntentRangeRequest)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:cockroach.proto.ResolveIntentRangeRequest)
  return false;
#undef DO_
}

void ResolveIntentRangeRequest::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:cockroach.proto.ResolveIntentRangeRequest)
  // optional .cockroach.proto.RequestHeader header = 1;
  if (has_header()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->header_, output);
  }

  // optional .cockroach.proto.Transaction intent_txn = 2;
  if (has_intent_txn()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, *this->intent_txn_, output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:cockroach.proto.ResolveIntentRangeRequest)
}

::google::protobuf::uint8* ResolveIntentRangeRequest::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:cockroach.proto.ResolveIntentRangeRequest)
  // optional .cockroach.proto.RequestHeader header = 1;
  if (has_header()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, *this->header_, target);
  }

  // optional .cockroach.proto.Transaction intent_txn = 2;
  if (has_intent_txn()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, *this->intent_txn_, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:cockroach.proto.ResolveIntentRangeRequest)
  return target;
}

int ResolveIntentRangeRequest::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & 3) {
    // optional .cockroach.proto.RequestHeader header = 1;
    if (has_header()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->header_);
    }

    // optional .cockroach.proto.Transaction intent_txn = 2;
    if (has_intent_txn()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->intent_txn_);
    }

  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ResolveIntentRangeRequest::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const ResolveIntentRangeRequest* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const ResolveIntentRangeRequest>(
          &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ResolveIntentRangeRequest::MergeFrom(const ResolveIntentRangeRequest& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_header()) {
      mutable_header()->::cockroach::proto::RequestHeader::MergeFrom(from.header());
    }
    if (from.has_intent_txn()) {
      mutable_intent_txn()->::cockroach::proto::Transaction::MergeFrom(from.intent_txn());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void ResolveIntentRangeRequest::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ResolveIntentRangeRequest::CopyFrom(const ResolveIntentRangeRequest& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ResolveIntentRangeRequest::IsInitialized() const {

  return true;
}

void ResolveIntentRangeRequest::Swap(ResolveIntentRangeRequest* other) {
  if (other == this) return;
  InternalSwap(other);
}
void ResolveIntentRangeRequest::InternalSwap(ResolveIntentRangeRequest* other) {
  std::swap(header_, other->header_);
  std::swap(intent_txn_, other->intent_txn_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata ResolveIntentRangeRequest::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ResolveIntentRangeRequest_descriptor_;
  metadata.reflection = ResolveIntentRangeRequest_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// ResolveIntentRangeRequest

// optional .cockroach.proto.RequestHeader header = 1;
bool ResolveIntentRangeRequest::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void ResolveIntentRangeRequest::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
void ResolveIntentRangeRequest::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
void ResolveIntentRangeRequest::clear_header() {
  if (header_ != NULL) header_->::cockroach::proto::RequestHeader::Clear();
  clear_has_header();
}
 const ::cockroach::proto::RequestHeader& ResolveIntentRangeRequest::header() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.ResolveIntentRangeRequest.header)
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
 ::cockroach::proto::RequestHeader* ResolveIntentRangeRequest::mutable_header() {
  set_has_header();
  if (header_ == NULL) {
    header_ = new ::cockroach::proto::RequestHeader;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.proto.ResolveIntentRangeRequest.header)
  return header_;
}
 ::cockroach::proto::RequestHeader* ResolveIntentRangeRequest::release_header() {
  clear_has_header();
  ::cockroach::proto::RequestHeader* temp = header_;
  header_ = NULL;
  return temp;
}
 void ResolveIntentRangeRequest::set_allocated_header(::cockroach::proto::RequestHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.ResolveIntentRangeRequest.header)
}

// optional .cockroach.proto.Transaction intent_txn = 2;
bool ResolveIntentRangeRequest::has_intent_txn() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void ResolveIntentRangeRequest::set_has_intent_txn() {
  _has_bits_[0] |= 0x00000002u;
}
void ResolveIntentRangeRequest::clear_has_intent_txn() {
  _has_bits_[0] &= ~0x00000002u;
}
void ResolveIntentRangeRequest::clear_intent_txn() {
  if (intent_txn_ != NULL) intent_txn_->::cockroach::proto::Transaction::Clear();
  clear_has_intent_txn();
}
 const ::cockroach::proto::Transaction& ResolveIntentRangeRequest::intent_txn() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.ResolveIntentRangeRequest.intent_txn)
  return intent_txn_ != NULL ? *intent_txn_ : *default_instance_->intent_txn_;
}
 ::cockroach::proto::Transaction* ResolveIntentRangeRequest::mutable_intent_txn() {
  set_has_intent_txn();
  if (intent_txn_ == NULL) {
    intent_txn_ = new ::cockroach::proto::Transaction;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.proto.ResolveIntentRangeRequest.intent_txn)
  return intent_txn_;
}
 ::cockroach::proto::Transaction* ResolveIntentRangeRequest::release_intent_txn() {
  clear_has_intent_txn();
  ::cockroach::proto::Transaction* temp = intent_txn_;
  intent_txn_ = NULL;
  return temp;
}
 void ResolveIntentRangeRequest::set_allocated_intent_txn(::cockroach::proto::Transaction* intent_txn) {
  delete intent_txn_;
  intent_txn_ = intent_txn;
  if (intent_txn) {
    set_has_intent_txn();
  } else {
    clear_has_intent_txn();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.ResolveIntentRangeRequest.intent_txn)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#ifndef _MSC_VER
const int NoopResponse::kHeaderFieldNumber;
#endif  // !_MSC_VER

NoopResponse::NoopResponse()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:cockroach.proto.NoopResponse)
}

void NoopResponse::InitAsDefaultInstance() {
  header_ = const_cast< ::cockroach::proto::ResponseHeader*>(&::cockroach::proto::ResponseHeader::default_instance());
}

NoopResponse::NoopResponse(const NoopResponse& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:cockroach.proto.NoopResponse)
}

void NoopResponse::SharedCtor() {
  _cached_size_ = 0;
  header_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

NoopResponse::~NoopResponse() {
  // @@protoc_insertion_point(destructor:cockroach.proto.NoopResponse)
  SharedDtor();
}

void NoopResponse::SharedDtor() {
  if (this != default_instance_) {
    delete header_;
  }
}

void NoopResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* NoopResponse::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return NoopResponse_descriptor_;
}

const NoopResponse& NoopResponse::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_cockroach_2fproto_2fapi_2eproto();
  return *default_instance_;
}

NoopResponse* NoopResponse::default_instance_ = NULL;

NoopResponse* NoopResponse::New(::google::protobuf::Arena* arena) const {
  NoopResponse* n = new NoopResponse;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void NoopResponse::Clear() {
  if (has_header()) {
    if (header_ != NULL) header_->::cockroach::proto::ResponseHeader::Clear();
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool NoopResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:cockroach.proto.NoopResponse)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .cockroach.proto.ResponseHeader header = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_header()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:cockroach.proto.NoopResponse)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:cockroach.proto.NoopResponse)
  return false;
#undef DO_
}

void NoopResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:cockroach.proto.NoopResponse)
  // optional .cockroach.proto.ResponseHeader header = 1;
  if (has_header()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->header_, output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:cockroach.proto.NoopResponse)
}

::google::protobuf::uint8* NoopResponse::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:cockroach.proto.NoopResponse)
  // optional .cockroach.proto.ResponseHeader header = 1;
  if (has_header()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, *this->header_, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:cockroach.proto.NoopResponse)
  return target;
}

int NoopResponse::ByteSize() const {
  int total_size = 0;

  // optional .cockroach.proto.ResponseHeader header = 1;
  if (has_header()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->header_);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void NoopResponse::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const NoopResponse* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const NoopResponse>(
          &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void NoopResponse::MergeFrom(const NoopResponse& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_header()) {
      mutable_header()->::cockroach::proto::ResponseHeader::MergeFrom(from.header());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void NoopResponse::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void NoopResponse::CopyFrom(const NoopResponse& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NoopResponse::IsInitialized() const {

  return true;
}

void NoopResponse::Swap(NoopResponse* other) {
  if (other == this) return;
  InternalSwap(other);
}
void NoopResponse::InternalSwap(NoopResponse* other) {
  std::swap(header_, other->header_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata NoopResponse::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = NoopResponse_descriptor_;
  metadata.reflection = NoopResponse_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// NoopResponse

// optional .cockroach.proto.ResponseHeader header = 1;
bool NoopResponse::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void NoopResponse::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
void NoopResponse::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
void NoopResponse::clear_header() {
  if (header_ != NULL) header_->::cockroach::proto::ResponseHeader::Clear();
  clear_has_header();
}
 const ::cockroach::proto::ResponseHeader& NoopResponse::header() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.NoopResponse.header)
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
 ::cockroach::proto::ResponseHeader* NoopResponse::mutable_header() {
  set_has_header();
  if (header_ == NULL) {
    header_ = new ::cockroach::proto::ResponseHeader;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.proto.NoopResponse.header)
  return header_;
}
 ::cockroach::proto::ResponseHeader* NoopResponse::release_header() {
  clear_has_header();
  ::cockroach::proto::ResponseHeader* temp = header_;
  header_ = NULL;
  return temp;
}
 void NoopResponse::set_allocated_header(::cockroach::proto::ResponseHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.NoopResponse.header)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#ifndef _MSC_VER
const int NoopRequest::kHeaderFieldNumber;
#endif  // !_MSC_VER

NoopRequest::NoopRequest()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:cockroach.proto.NoopRequest)
}

void NoopRequest::InitAsDefaultInstance() {
  header_ = const_cast< ::cockroach::proto::RequestHeader*>(&::cockroach::proto::RequestHeader::default_instance());
}

NoopRequest::NoopRequest(const NoopRequest& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:cockroach.proto.NoopRequest)
}

void NoopRequest::SharedCtor() {
  _cached_size_ = 0;
  header_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

NoopRequest::~NoopRequest() {
  // @@protoc_insertion_point(destructor:cockroach.proto.NoopRequest)
  SharedDtor();
}

void NoopRequest::SharedDtor() {
  if (this != default_instance_) {
    delete header_;
  }
}

void NoopRequest::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* NoopRequest::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return NoopRequest_descriptor_;
}

const NoopRequest& NoopRequest::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_cockroach_2fproto_2fapi_2eproto();
  return *default_instance_;
}

NoopRequest* NoopRequest::default_instance_ = NULL;

NoopRequest* NoopRequest::New(::google::protobuf::Arena* arena) const {
  NoopRequest* n = new NoopRequest;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void NoopRequest::Clear() {
  if (has_header()) {
    if (header_ != NULL) header_->::cockroach::proto::RequestHeader::Clear();
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool NoopRequest::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:cockroach.proto.NoopRequest)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .cockroach.proto.RequestHeader header = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_header()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:cockroach.proto.NoopRequest)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:cockroach.proto.NoopRequest)
  return false;
#undef DO_
}

void NoopRequest::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:cockroach.proto.NoopRequest)
  // optional .cockroach.proto.RequestHeader header = 1;
  if (has_header()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->header_, output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:cockroach.proto.NoopRequest)
}

::google::protobuf::uint8* NoopRequest::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:cockroach.proto.NoopRequest)
  // optional .cockroach.proto.RequestHeader header = 1;
  if (has_header()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, *this->header_, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:cockroach.proto.NoopRequest)
  return target;
}

int NoopRequest::ByteSize() const {
  int total_size = 0;

  // optional .cockroach.proto.RequestHeader header = 1;
  if (has_header()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->header_);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void NoopRequest::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const NoopRequest* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const NoopRequest>(
          &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void NoopRequest::MergeFrom(const NoopRequest& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_header()) {
      mutable_header()->::cockroach::proto::RequestHeader::MergeFrom(from.header());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void NoopRequest::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void NoopRequest::CopyFrom(const NoopRequest& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NoopRequest::IsInitialized() const {

  return true;
}

void NoopRequest::Swap(NoopRequest* other) {
  if (other == this) return;
  InternalSwap(other);
}
void NoopRequest::InternalSwap(NoopRequest* other) {
  std::swap(header_, other->header_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata NoopRequest::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = NoopRequest_descriptor_;
  metadata.reflection = NoopRequest_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// NoopRequest

// optional .cockroach.proto.RequestHeader header = 1;
bool NoopRequest::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void NoopRequest::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
void NoopRequest::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
void NoopRequest::clear_header() {
  if (header_ != NULL) header_->::cockroach::proto::RequestHeader::Clear();
  clear_has_header();
}
 const ::cockroach::proto::RequestHeader& NoopRequest::header() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.NoopRequest.header)
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
 ::cockroach::proto::RequestHeader* NoopRequest::mutable_header() {
  set_has_header();
  if (header_ == NULL) {
    header_ = new ::cockroach::proto::RequestHeader;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.proto.NoopRequest.header)
  return header_;
}
 ::cockroach::proto::RequestHeader* NoopRequest::release_header() {
  clear_has_header();
  ::cockroach::proto::RequestHeader* temp = header_;
  header_ = NULL;
  return temp;
}
 void NoopRequest::set_allocated_header(::cockroach::proto::RequestHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.NoopRequest.header)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#ifndef _MSC_VER
const int ResolveIntentRangeResponse::kHeaderFieldNumber;
#endif  // !_MSC_VER

ResolveIntentRangeResponse::ResolveIntentRangeResponse()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:cockroach.proto.ResolveIntentRangeResponse)
}

void ResolveIntentRangeResponse::InitAsDefaultInstance() {
  header_ = const_cast< ::cockroach::proto::ResponseHeader*>(&::cockroach::proto::ResponseHeader::default_instance());
}

ResolveIntentRangeResponse::ResolveIntentRangeResponse(const ResolveIntentRangeResponse& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:cockroach.proto.ResolveIntentRangeResponse)
}

void ResolveIntentRangeResponse::SharedCtor() {
  _cached_size_ = 0;
  header_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ResolveIntentRangeResponse::~ResolveIntentRangeResponse() {
  // @@protoc_insertion_point(destructor:cockroach.proto.ResolveIntentRangeResponse)
  SharedDtor();
}

void ResolveIntentRangeResponse::SharedDtor() {
  if (this != default_instance_) {
    delete header_;
  }
}

void ResolveIntentRangeResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ResolveIntentRangeResponse::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ResolveIntentRangeResponse_descriptor_;
}

const ResolveIntentRangeResponse& ResolveIntentRangeResponse::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_cockroach_2fproto_2fapi_2eproto();
  return *default_instance_;
}

ResolveIntentRangeResponse* ResolveIntentRangeResponse::default_instance_ = NULL;

ResolveIntentRangeResponse* ResolveIntentRangeResponse::New(::google::protobuf::Arena* arena) const {
  ResolveIntentRangeResponse* n = new ResolveIntentRangeResponse;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void ResolveIntentRangeResponse::Clear() {
  if (has_header()) {
    if (header_ != NULL) header_->::cockroach::proto::ResponseHeader::Clear();
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool ResolveIntentRangeResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:cockroach.proto.ResolveIntentRangeResponse)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .cockroach.proto.ResponseHeader header = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_header()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:cockroach.proto.ResolveIntentRangeResponse)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:cockroach.proto.ResolveIntentRangeResponse)
  return false;
#undef DO_
}

void ResolveIntentRangeResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:cockroach.proto.ResolveIntentRangeResponse)
  // optional .cockroach.proto.ResponseHeader header = 1;
  if (has_header()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->header_, output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:cockroach.proto.ResolveIntentRangeResponse)
}

::google::protobuf::uint8* ResolveIntentRangeResponse::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:cockroach.proto.ResolveIntentRangeResponse)
  // optional .cockroach.proto.ResponseHeader header = 1;
  if (has_header()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, *this->header_, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:cockroach.proto.ResolveIntentRangeResponse)
  return target;
}

int ResolveIntentRangeResponse::ByteSize() const {
  int total_size = 0;

  // optional .cockroach.proto.ResponseHeader header = 1;
  if (has_header()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->header_);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ResolveIntentRangeResponse::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const ResolveIntentRangeResponse* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const ResolveIntentRangeResponse>(
          &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ResolveIntentRangeResponse::MergeFrom(const ResolveIntentRangeResponse& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_header()) {
      mutable_header()->::cockroach::proto::ResponseHeader::MergeFrom(from.header());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void ResolveIntentRangeResponse::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ResolveIntentRangeResponse::CopyFrom(const ResolveIntentRangeResponse& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ResolveIntentRangeResponse::IsInitialized() const {

  return true;
}

void ResolveIntentRangeResponse::Swap(ResolveIntentRangeResponse* other) {
  if (other == this) return;
  InternalSwap(other);
}
void ResolveIntentRangeResponse::InternalSwap(ResolveIntentRangeResponse* other) {
  std::swap(header_, other->header_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata ResolveIntentRangeResponse::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ResolveIntentRangeResponse_descriptor_;
  metadata.reflection = ResolveIntentRangeResponse_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// ResolveIntentRangeResponse

// optional .cockroach.proto.ResponseHeader header = 1;
bool ResolveIntentRangeResponse::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void ResolveIntentRangeResponse::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
void ResolveIntentRangeResponse::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
void ResolveIntentRangeResponse::clear_header() {
  if (header_ != NULL) header_->::cockroach::proto::ResponseHeader::Clear();
  clear_has_header();
}
 const ::cockroach::proto::ResponseHeader& ResolveIntentRangeResponse::header() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.ResolveIntentRangeResponse.header)
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
 ::cockroach::proto::ResponseHeader* ResolveIntentRangeResponse::mutable_header() {
  set_has_header();
  if (header_ == NULL) {
    header_ = new ::cockroach::proto::ResponseHeader;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.proto.ResolveIntentRangeResponse.header)
  return header_;
}
 ::cockroach::proto::ResponseHeader* ResolveIntentRangeResponse::release_header() {
  clear_has_header();
  ::cockroach::proto::ResponseHeader* temp = header_;
  header_ = NULL;
  return temp;
}
 void ResolveIntentRangeResponse::set_allocated_header(::cockroach::proto::ResponseHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.ResolveIntentRangeResponse.header)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#ifndef _MSC_VER
const int MergeRequest::kHeaderFieldNumber;
const int MergeRequest::kValueFieldNumber;
#endif  // !_MSC_VER

MergeRequest::MergeRequest()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:cockroach.proto.MergeRequest)
}

void MergeRequest::InitAsDefaultInstance() {
  header_ = const_cast< ::cockroach::proto::RequestHeader*>(&::cockroach::proto::RequestHeader::default_instance());
  value_ = const_cast< ::cockroach::proto::Value*>(&::cockroach::proto::Value::default_instance());
}

MergeRequest::MergeRequest(const MergeRequest& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:cockroach.proto.MergeRequest)
}

void MergeRequest::SharedCtor() {
  _cached_size_ = 0;
  header_ = NULL;
  value_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

MergeRequest::~MergeRequest() {
  // @@protoc_insertion_point(destructor:cockroach.proto.MergeRequest)
  SharedDtor();
}

void MergeRequest::SharedDtor() {
  if (this != default_instance_) {
    delete header_;
    delete value_;
  }
}

void MergeRequest::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* MergeRequest::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return MergeRequest_descriptor_;
}

const MergeRequest& MergeRequest::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_cockroach_2fproto_2fapi_2eproto();
  return *default_instance_;
}

MergeRequest* MergeRequest::default_instance_ = NULL;

MergeRequest* MergeRequest::New(::google::protobuf::Arena* arena) const {
  MergeRequest* n = new MergeRequest;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void MergeRequest::Clear() {
  if (_has_bits_[0 / 32] & 3u) {
    if (has_header()) {
      if (header_ != NULL) header_->::cockroach::proto::RequestHeader::Clear();
    }
    if (has_value()) {
      if (value_ != NULL) value_->::cockroach::proto::Value::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool MergeRequest::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:cockroach.proto.MergeRequest)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .cockroach.proto.RequestHeader header = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_header()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_value;
        break;
      }

      // optional .cockroach.proto.Value value = 2;
      case 2: {
        if (tag == 18) {
         parse_value:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_value()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:cockroach.proto.MergeRequest)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:cockroach.proto.MergeRequest)
  return false;
#undef DO_
}

void MergeRequest::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:cockroach.proto.MergeRequest)
  // optional .cockroach.proto.RequestHeader header = 1;
  if (has_header()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->header_, output);
  }

  // optional .cockroach.proto.Value value = 2;
  if (has_value()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, *this->value_, output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:cockroach.proto.MergeRequest)
}

::google::protobuf::uint8* MergeRequest::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:cockroach.proto.MergeRequest)
  // optional .cockroach.proto.RequestHeader header = 1;
  if (has_header()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, *this->header_, target);
  }

  // optional .cockroach.proto.Value value = 2;
  if (has_value()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, *this->value_, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:cockroach.proto.MergeRequest)
  return target;
}

int MergeRequest::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & 3) {
    // optional .cockroach.proto.RequestHeader header = 1;
    if (has_header()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->header_);
    }

    // optional .cockroach.proto.Value value = 2;
    if (has_value()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->value_);
    }

  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void MergeRequest::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const MergeRequest* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const MergeRequest>(
          &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void MergeRequest::MergeFrom(const MergeRequest& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_header()) {
      mutable_header()->::cockroach::proto::RequestHeader::MergeFrom(from.header());
    }
    if (from.has_value()) {
      mutable_value()->::cockroach::proto::Value::MergeFrom(from.value());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void MergeRequest::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void MergeRequest::CopyFrom(const MergeRequest& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MergeRequest::IsInitialized() const {

  return true;
}

void MergeRequest::Swap(MergeRequest* other) {
  if (other == this) return;
  InternalSwap(other);
}
void MergeRequest::InternalSwap(MergeRequest* other) {
  std::swap(header_, other->header_);
  std::swap(value_, other->value_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata MergeRequest::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = MergeRequest_descriptor_;
  metadata.reflection = MergeRequest_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// MergeRequest

// optional .cockroach.proto.RequestHeader header = 1;
bool MergeRequest::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void MergeRequest::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
void MergeRequest::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
void MergeRequest::clear_header() {
  if (header_ != NULL) header_->::cockroach::proto::RequestHeader::Clear();
  clear_has_header();
}
 const ::cockroach::proto::RequestHeader& MergeRequest::header() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.MergeRequest.header)
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
 ::cockroach::proto::RequestHeader* MergeRequest::mutable_header() {
  set_has_header();
  if (header_ == NULL) {
    header_ = new ::cockroach::proto::RequestHeader;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.proto.MergeRequest.header)
  return header_;
}
 ::cockroach::proto::RequestHeader* MergeRequest::release_header() {
  clear_has_header();
  ::cockroach::proto::RequestHeader* temp = header_;
  header_ = NULL;
  return temp;
}
 void MergeRequest::set_allocated_header(::cockroach::proto::RequestHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.MergeRequest.header)
}

// optional .cockroach.proto.Value value = 2;
bool MergeRequest::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void MergeRequest::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
void MergeRequest::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
void MergeRequest::clear_value() {
  if (value_ != NULL) value_->::cockroach::proto::Value::Clear();
  clear_has_value();
}
 const ::cockroach::proto::Value& MergeRequest::value() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.MergeRequest.value)
  return value_ != NULL ? *value_ : *default_instance_->value_;
}
 ::cockroach::proto::Value* MergeRequest::mutable_value() {
  set_has_value();
  if (value_ == NULL) {
    value_ = new ::cockroach::proto::Value;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.proto.MergeRequest.value)
  return value_;
}
 ::cockroach::proto::Value* MergeRequest::release_value() {
  clear_has_value();
  ::cockroach::proto::Value* temp = value_;
  value_ = NULL;
  return temp;
}
 void MergeRequest::set_allocated_value(::cockroach::proto::Value* value) {
  delete value_;
  value_ = value;
  if (value) {
    set_has_value();
  } else {
    clear_has_value();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.MergeRequest.value)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#ifndef _MSC_VER
const int MergeResponse::kHeaderFieldNumber;
#endif  // !_MSC_VER

MergeResponse::MergeResponse()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:cockroach.proto.MergeResponse)
}

void MergeResponse::InitAsDefaultInstance() {
  header_ = const_cast< ::cockroach::proto::ResponseHeader*>(&::cockroach::proto::ResponseHeader::default_instance());
}

MergeResponse::MergeResponse(const MergeResponse& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:cockroach.proto.MergeResponse)
}

void MergeResponse::SharedCtor() {
  _cached_size_ = 0;
  header_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

MergeResponse::~MergeResponse() {
  // @@protoc_insertion_point(destructor:cockroach.proto.MergeResponse)
  SharedDtor();
}

void MergeResponse::SharedDtor() {
  if (this != default_instance_) {
    delete header_;
  }
}

void MergeResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* MergeResponse::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return MergeResponse_descriptor_;
}

const MergeResponse& MergeResponse::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_cockroach_2fproto_2fapi_2eproto();
  return *default_instance_;
}

MergeResponse* MergeResponse::default_instance_ = NULL;

MergeResponse* MergeResponse::New(::google::protobuf::Arena* arena) const {
  MergeResponse* n = new MergeResponse;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void MergeResponse::Clear() {
  if (has_header()) {
    if (header_ != NULL) header_->::cockroach::proto::ResponseHeader::Clear();
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool MergeResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:cockroach.proto.MergeResponse)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .cockroach.proto.ResponseHeader header = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_header()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:cockroach.proto.MergeResponse)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:cockroach.proto.MergeResponse)
  return false;
#undef DO_
}

void MergeResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:cockroach.proto.MergeResponse)
  // optional .cockroach.proto.ResponseHeader header = 1;
  if (has_header()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->header_, output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:cockroach.proto.MergeResponse)
}

::google::protobuf::uint8* MergeResponse::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:cockroach.proto.MergeResponse)
  // optional .cockroach.proto.ResponseHeader header = 1;
  if (has_header()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, *this->header_, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:cockroach.proto.MergeResponse)
  return target;
}

int MergeResponse::ByteSize() const {
  int total_size = 0;

  // optional .cockroach.proto.ResponseHeader header = 1;
  if (has_header()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->header_);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void MergeResponse::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const MergeResponse* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const MergeResponse>(
          &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void MergeResponse::MergeFrom(const MergeResponse& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_header()) {
      mutable_header()->::cockroach::proto::ResponseHeader::MergeFrom(from.header());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void MergeResponse::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void MergeResponse::CopyFrom(const MergeResponse& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MergeResponse::IsInitialized() const {

  return true;
}

void MergeResponse::Swap(MergeResponse* other) {
  if (other == this) return;
  InternalSwap(other);
}
void MergeResponse::InternalSwap(MergeResponse* other) {
  std::swap(header_, other->header_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata MergeResponse::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = MergeResponse_descriptor_;
  metadata.reflection = MergeResponse_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// MergeResponse

// optional .cockroach.proto.ResponseHeader header = 1;
bool MergeResponse::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void MergeResponse::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
void MergeResponse::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
void MergeResponse::clear_header() {
  if (header_ != NULL) header_->::cockroach::proto::ResponseHeader::Clear();
  clear_has_header();
}
 const ::cockroach::proto::ResponseHeader& MergeResponse::header() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.MergeResponse.header)
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
 ::cockroach::proto::ResponseHeader* MergeResponse::mutable_header() {
  set_has_header();
  if (header_ == NULL) {
    header_ = new ::cockroach::proto::ResponseHeader;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.proto.MergeResponse.header)
  return header_;
}
 ::cockroach::proto::ResponseHeader* MergeResponse::release_header() {
  clear_has_header();
  ::cockroach::proto::ResponseHeader* temp = header_;
  header_ = NULL;
  return temp;
}
 void MergeResponse::set_allocated_header(::cockroach::proto::ResponseHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.MergeResponse.header)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#ifndef _MSC_VER
const int TruncateLogRequest::kHeaderFieldNumber;
const int TruncateLogRequest::kIndexFieldNumber;
#endif  // !_MSC_VER

TruncateLogRequest::TruncateLogRequest()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:cockroach.proto.TruncateLogRequest)
}

void TruncateLogRequest::InitAsDefaultInstance() {
  header_ = const_cast< ::cockroach::proto::RequestHeader*>(&::cockroach::proto::RequestHeader::default_instance());
}

TruncateLogRequest::TruncateLogRequest(const TruncateLogRequest& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:cockroach.proto.TruncateLogRequest)
}

void TruncateLogRequest::SharedCtor() {
  _cached_size_ = 0;
  header_ = NULL;
  index_ = GOOGLE_ULONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

TruncateLogRequest::~TruncateLogRequest() {
  // @@protoc_insertion_point(destructor:cockroach.proto.TruncateLogRequest)
  SharedDtor();
}

void TruncateLogRequest::SharedDtor() {
  if (this != default_instance_) {
    delete header_;
  }
}

void TruncateLogRequest::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* TruncateLogRequest::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return TruncateLogRequest_descriptor_;
}

const TruncateLogRequest& TruncateLogRequest::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_cockroach_2fproto_2fapi_2eproto();
  return *default_instance_;
}

TruncateLogRequest* TruncateLogRequest::default_instance_ = NULL;

TruncateLogRequest* TruncateLogRequest::New(::google::protobuf::Arena* arena) const {
  TruncateLogRequest* n = new TruncateLogRequest;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void TruncateLogRequest::Clear() {
  if (_has_bits_[0 / 32] & 3u) {
    if (has_header()) {
      if (header_ != NULL) header_->::cockroach::proto::RequestHeader::Clear();
    }
    index_ = GOOGLE_ULONGLONG(0);
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool TruncateLogRequest::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:cockroach.proto.TruncateLogRequest)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .cockroach.proto.RequestHeader header = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_header()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_index;
        break;
      }

      // optional uint64 index = 2;
      case 2: {
        if (tag == 16) {
         parse_index:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &index_)));
          set_has_index();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:cockroach.proto.TruncateLogRequest)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:cockroach.proto.TruncateLogRequest)
  return false;
#undef DO_
}

void TruncateLogRequest::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:cockroach.proto.TruncateLogRequest)
  // optional .cockroach.proto.RequestHeader header = 1;
  if (has_header()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->header_, output);
  }

  // optional uint64 index = 2;
  if (has_index()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(2, this->index(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:cockroach.proto.TruncateLogRequest)
}

::google::protobuf::uint8* TruncateLogRequest::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:cockroach.proto.TruncateLogRequest)
  // optional .cockroach.proto.RequestHeader header = 1;
  if (has_header()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, *this->header_, target);
  }

  // optional uint64 index = 2;
  if (has_index()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(2, this->index(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:cockroach.proto.TruncateLogRequest)
  return target;
}

int TruncateLogRequest::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & 3) {
    // optional .cockroach.proto.RequestHeader header = 1;
    if (has_header()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->header_);
    }

    // optional uint64 index = 2;
    if (has_index()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->index());
    }

  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TruncateLogRequest::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const TruncateLogRequest* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const TruncateLogRequest>(
          &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void TruncateLogRequest::MergeFrom(const TruncateLogRequest& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_header()) {
      mutable_header()->::cockroach::proto::RequestHeader::MergeFrom(from.header());
    }
    if (from.has_index()) {
      set_index(from.index());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void TruncateLogRequest::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TruncateLogRequest::CopyFrom(const TruncateLogRequest& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TruncateLogRequest::IsInitialized() const {

  return true;
}

void TruncateLogRequest::Swap(TruncateLogRequest* other) {
  if (other == this) return;
  InternalSwap(other);
}
void TruncateLogRequest::InternalSwap(TruncateLogRequest* other) {
  std::swap(header_, other->header_);
  std::swap(index_, other->index_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata TruncateLogRequest::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = TruncateLogRequest_descriptor_;
  metadata.reflection = TruncateLogRequest_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// TruncateLogRequest

// optional .cockroach.proto.RequestHeader header = 1;
bool TruncateLogRequest::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void TruncateLogRequest::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
void TruncateLogRequest::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
void TruncateLogRequest::clear_header() {
  if (header_ != NULL) header_->::cockroach::proto::RequestHeader::Clear();
  clear_has_header();
}
 const ::cockroach::proto::RequestHeader& TruncateLogRequest::header() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.TruncateLogRequest.header)
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
 ::cockroach::proto::RequestHeader* TruncateLogRequest::mutable_header() {
  set_has_header();
  if (header_ == NULL) {
    header_ = new ::cockroach::proto::RequestHeader;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.proto.TruncateLogRequest.header)
  return header_;
}
 ::cockroach::proto::RequestHeader* TruncateLogRequest::release_header() {
  clear_has_header();
  ::cockroach::proto::RequestHeader* temp = header_;
  header_ = NULL;
  return temp;
}
 void TruncateLogRequest::set_allocated_header(::cockroach::proto::RequestHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.TruncateLogRequest.header)
}

// optional uint64 index = 2;
bool TruncateLogRequest::has_index() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void TruncateLogRequest::set_has_index() {
  _has_bits_[0] |= 0x00000002u;
}
void TruncateLogRequest::clear_has_index() {
  _has_bits_[0] &= ~0x00000002u;
}
void TruncateLogRequest::clear_index() {
  index_ = GOOGLE_ULONGLONG(0);
  clear_has_index();
}
 ::google::protobuf::uint64 TruncateLogRequest::index() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.TruncateLogRequest.index)
  return index_;
}
 void TruncateLogRequest::set_index(::google::protobuf::uint64 value) {
  set_has_index();
  index_ = value;
  // @@protoc_insertion_point(field_set:cockroach.proto.TruncateLogRequest.index)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#ifndef _MSC_VER
const int TruncateLogResponse::kHeaderFieldNumber;
#endif  // !_MSC_VER

TruncateLogResponse::TruncateLogResponse()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:cockroach.proto.TruncateLogResponse)
}

void TruncateLogResponse::InitAsDefaultInstance() {
  header_ = const_cast< ::cockroach::proto::ResponseHeader*>(&::cockroach::proto::ResponseHeader::default_instance());
}

TruncateLogResponse::TruncateLogResponse(const TruncateLogResponse& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:cockroach.proto.TruncateLogResponse)
}

void TruncateLogResponse::SharedCtor() {
  _cached_size_ = 0;
  header_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

TruncateLogResponse::~TruncateLogResponse() {
  // @@protoc_insertion_point(destructor:cockroach.proto.TruncateLogResponse)
  SharedDtor();
}

void TruncateLogResponse::SharedDtor() {
  if (this != default_instance_) {
    delete header_;
  }
}

void TruncateLogResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* TruncateLogResponse::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return TruncateLogResponse_descriptor_;
}

const TruncateLogResponse& TruncateLogResponse::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_cockroach_2fproto_2fapi_2eproto();
  return *default_instance_;
}

TruncateLogResponse* TruncateLogResponse::default_instance_ = NULL;

TruncateLogResponse* TruncateLogResponse::New(::google::protobuf::Arena* arena) const {
  TruncateLogResponse* n = new TruncateLogResponse;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void TruncateLogResponse::Clear() {
  if (has_header()) {
    if (header_ != NULL) header_->::cockroach::proto::ResponseHeader::Clear();
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool TruncateLogResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:cockroach.proto.TruncateLogResponse)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .cockroach.proto.ResponseHeader header = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_header()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:cockroach.proto.TruncateLogResponse)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:cockroach.proto.TruncateLogResponse)
  return false;
#undef DO_
}

void TruncateLogResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:cockroach.proto.TruncateLogResponse)
  // optional .cockroach.proto.ResponseHeader header = 1;
  if (has_header()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->header_, output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:cockroach.proto.TruncateLogResponse)
}

::google::protobuf::uint8* TruncateLogResponse::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:cockroach.proto.TruncateLogResponse)
  // optional .cockroach.proto.ResponseHeader header = 1;
  if (has_header()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, *this->header_, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:cockroach.proto.TruncateLogResponse)
  return target;
}

int TruncateLogResponse::ByteSize() const {
  int total_size = 0;

  // optional .cockroach.proto.ResponseHeader header = 1;
  if (has_header()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->header_);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TruncateLogResponse::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const TruncateLogResponse* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const TruncateLogResponse>(
          &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void TruncateLogResponse::MergeFrom(const TruncateLogResponse& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_header()) {
      mutable_header()->::cockroach::proto::ResponseHeader::MergeFrom(from.header());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void TruncateLogResponse::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TruncateLogResponse::CopyFrom(const TruncateLogResponse& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TruncateLogResponse::IsInitialized() const {

  return true;
}

void TruncateLogResponse::Swap(TruncateLogResponse* other) {
  if (other == this) return;
  InternalSwap(other);
}
void TruncateLogResponse::InternalSwap(TruncateLogResponse* other) {
  std::swap(header_, other->header_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata TruncateLogResponse::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = TruncateLogResponse_descriptor_;
  metadata.reflection = TruncateLogResponse_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// TruncateLogResponse

// optional .cockroach.proto.ResponseHeader header = 1;
bool TruncateLogResponse::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void TruncateLogResponse::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
void TruncateLogResponse::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
void TruncateLogResponse::clear_header() {
  if (header_ != NULL) header_->::cockroach::proto::ResponseHeader::Clear();
  clear_has_header();
}
 const ::cockroach::proto::ResponseHeader& TruncateLogResponse::header() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.TruncateLogResponse.header)
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
 ::cockroach::proto::ResponseHeader* TruncateLogResponse::mutable_header() {
  set_has_header();
  if (header_ == NULL) {
    header_ = new ::cockroach::proto::ResponseHeader;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.proto.TruncateLogResponse.header)
  return header_;
}
 ::cockroach::proto::ResponseHeader* TruncateLogResponse::release_header() {
  clear_has_header();
  ::cockroach::proto::ResponseHeader* temp = header_;
  header_ = NULL;
  return temp;
}
 void TruncateLogResponse::set_allocated_header(::cockroach::proto::ResponseHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.TruncateLogResponse.header)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#ifndef _MSC_VER
const int LeaderLeaseRequest::kHeaderFieldNumber;
const int LeaderLeaseRequest::kLeaseFieldNumber;
#endif  // !_MSC_VER

LeaderLeaseRequest::LeaderLeaseRequest()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:cockroach.proto.LeaderLeaseRequest)
}

void LeaderLeaseRequest::InitAsDefaultInstance() {
  header_ = const_cast< ::cockroach::proto::RequestHeader*>(&::cockroach::proto::RequestHeader::default_instance());
  lease_ = const_cast< ::cockroach::proto::Lease*>(&::cockroach::proto::Lease::default_instance());
}

LeaderLeaseRequest::LeaderLeaseRequest(const LeaderLeaseRequest& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:cockroach.proto.LeaderLeaseRequest)
}

void LeaderLeaseRequest::SharedCtor() {
  _cached_size_ = 0;
  header_ = NULL;
  lease_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

LeaderLeaseRequest::~LeaderLeaseRequest() {
  // @@protoc_insertion_point(destructor:cockroach.proto.LeaderLeaseRequest)
  SharedDtor();
}

void LeaderLeaseRequest::SharedDtor() {
  if (this != default_instance_) {
    delete header_;
    delete lease_;
  }
}

void LeaderLeaseRequest::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* LeaderLeaseRequest::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return LeaderLeaseRequest_descriptor_;
}

const LeaderLeaseRequest& LeaderLeaseRequest::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_cockroach_2fproto_2fapi_2eproto();
  return *default_instance_;
}

LeaderLeaseRequest* LeaderLeaseRequest::default_instance_ = NULL;

LeaderLeaseRequest* LeaderLeaseRequest::New(::google::protobuf::Arena* arena) const {
  LeaderLeaseRequest* n = new LeaderLeaseRequest;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void LeaderLeaseRequest::Clear() {
  if (_has_bits_[0 / 32] & 3u) {
    if (has_header()) {
      if (header_ != NULL) header_->::cockroach::proto::RequestHeader::Clear();
    }
    if (has_lease()) {
      if (lease_ != NULL) lease_->::cockroach::proto::Lease::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool LeaderLeaseRequest::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:cockroach.proto.LeaderLeaseRequest)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .cockroach.proto.RequestHeader header = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_header()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_lease;
        break;
      }

      // optional .cockroach.proto.Lease lease = 2;
      case 2: {
        if (tag == 18) {
         parse_lease:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_lease()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:cockroach.proto.LeaderLeaseRequest)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:cockroach.proto.LeaderLeaseRequest)
  return false;
#undef DO_
}

void LeaderLeaseRequest::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:cockroach.proto.LeaderLeaseRequest)
  // optional .cockroach.proto.RequestHeader header = 1;
  if (has_header()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->header_, output);
  }

  // optional .cockroach.proto.Lease lease = 2;
  if (has_lease()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, *this->lease_, output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:cockroach.proto.LeaderLeaseRequest)
}

::google::protobuf::uint8* LeaderLeaseRequest::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:cockroach.proto.LeaderLeaseRequest)
  // optional .cockroach.proto.RequestHeader header = 1;
  if (has_header()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, *this->header_, target);
  }

  // optional .cockroach.proto.Lease lease = 2;
  if (has_lease()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, *this->lease_, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:cockroach.proto.LeaderLeaseRequest)
  return target;
}

int LeaderLeaseRequest::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & 3) {
    // optional .cockroach.proto.RequestHeader header = 1;
    if (has_header()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->header_);
    }

    // optional .cockroach.proto.Lease lease = 2;
    if (has_lease()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->lease_);
    }

  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void LeaderLeaseRequest::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const LeaderLeaseRequest* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const LeaderLeaseRequest>(
          &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void LeaderLeaseRequest::MergeFrom(const LeaderLeaseRequest& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_header()) {
      mutable_header()->::cockroach::proto::RequestHeader::MergeFrom(from.header());
    }
    if (from.has_lease()) {
      mutable_lease()->::cockroach::proto::Lease::MergeFrom(from.lease());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void LeaderLeaseRequest::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void LeaderLeaseRequest::CopyFrom(const LeaderLeaseRequest& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LeaderLeaseRequest::IsInitialized() const {

  return true;
}

void LeaderLeaseRequest::Swap(LeaderLeaseRequest* other) {
  if (other == this) return;
  InternalSwap(other);
}
void LeaderLeaseRequest::InternalSwap(LeaderLeaseRequest* other) {
  std::swap(header_, other->header_);
  std::swap(lease_, other->lease_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata LeaderLeaseRequest::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = LeaderLeaseRequest_descriptor_;
  metadata.reflection = LeaderLeaseRequest_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// LeaderLeaseRequest

// optional .cockroach.proto.RequestHeader header = 1;
bool LeaderLeaseRequest::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void LeaderLeaseRequest::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
void LeaderLeaseRequest::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
void LeaderLeaseRequest::clear_header() {
  if (header_ != NULL) header_->::cockroach::proto::RequestHeader::Clear();
  clear_has_header();
}
 const ::cockroach::proto::RequestHeader& LeaderLeaseRequest::header() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.LeaderLeaseRequest.header)
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
 ::cockroach::proto::RequestHeader* LeaderLeaseRequest::mutable_header() {
  set_has_header();
  if (header_ == NULL) {
    header_ = new ::cockroach::proto::RequestHeader;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.proto.LeaderLeaseRequest.header)
  return header_;
}
 ::cockroach::proto::RequestHeader* LeaderLeaseRequest::release_header() {
  clear_has_header();
  ::cockroach::proto::RequestHeader* temp = header_;
  header_ = NULL;
  return temp;
}
 void LeaderLeaseRequest::set_allocated_header(::cockroach::proto::RequestHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.LeaderLeaseRequest.header)
}

// optional .cockroach.proto.Lease lease = 2;
bool LeaderLeaseRequest::has_lease() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void LeaderLeaseRequest::set_has_lease() {
  _has_bits_[0] |= 0x00000002u;
}
void LeaderLeaseRequest::clear_has_lease() {
  _has_bits_[0] &= ~0x00000002u;
}
void LeaderLeaseRequest::clear_lease() {
  if (lease_ != NULL) lease_->::cockroach::proto::Lease::Clear();
  clear_has_lease();
}
 const ::cockroach::proto::Lease& LeaderLeaseRequest::lease() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.LeaderLeaseRequest.lease)
  return lease_ != NULL ? *lease_ : *default_instance_->lease_;
}
 ::cockroach::proto::Lease* LeaderLeaseRequest::mutable_lease() {
  set_has_lease();
  if (lease_ == NULL) {
    lease_ = new ::cockroach::proto::Lease;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.proto.LeaderLeaseRequest.lease)
  return lease_;
}
 ::cockroach::proto::Lease* LeaderLeaseRequest::release_lease() {
  clear_has_lease();
  ::cockroach::proto::Lease* temp = lease_;
  lease_ = NULL;
  return temp;
}
 void LeaderLeaseRequest::set_allocated_lease(::cockroach::proto::Lease* lease) {
  delete lease_;
  lease_ = lease;
  if (lease) {
    set_has_lease();
  } else {
    clear_has_lease();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.LeaderLeaseRequest.lease)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#ifndef _MSC_VER
const int LeaderLeaseResponse::kHeaderFieldNumber;
#endif  // !_MSC_VER

LeaderLeaseResponse::LeaderLeaseResponse()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:cockroach.proto.LeaderLeaseResponse)
}

void LeaderLeaseResponse::InitAsDefaultInstance() {
  header_ = const_cast< ::cockroach::proto::ResponseHeader*>(&::cockroach::proto::ResponseHeader::default_instance());
}

LeaderLeaseResponse::LeaderLeaseResponse(const LeaderLeaseResponse& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:cockroach.proto.LeaderLeaseResponse)
}

void LeaderLeaseResponse::SharedCtor() {
  _cached_size_ = 0;
  header_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

LeaderLeaseResponse::~LeaderLeaseResponse() {
  // @@protoc_insertion_point(destructor:cockroach.proto.LeaderLeaseResponse)
  SharedDtor();
}

void LeaderLeaseResponse::SharedDtor() {
  if (this != default_instance_) {
    delete header_;
  }
}

void LeaderLeaseResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* LeaderLeaseResponse::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return LeaderLeaseResponse_descriptor_;
}

const LeaderLeaseResponse& LeaderLeaseResponse::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_cockroach_2fproto_2fapi_2eproto();
  return *default_instance_;
}

LeaderLeaseResponse* LeaderLeaseResponse::default_instance_ = NULL;

LeaderLeaseResponse* LeaderLeaseResponse::New(::google::protobuf::Arena* arena) const {
  LeaderLeaseResponse* n = new LeaderLeaseResponse;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void LeaderLeaseResponse::Clear() {
  if (has_header()) {
    if (header_ != NULL) header_->::cockroach::proto::ResponseHeader::Clear();
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool LeaderLeaseResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:cockroach.proto.LeaderLeaseResponse)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .cockroach.proto.ResponseHeader header = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_header()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:cockroach.proto.LeaderLeaseResponse)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:cockroach.proto.LeaderLeaseResponse)
  return false;
#undef DO_
}

void LeaderLeaseResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:cockroach.proto.LeaderLeaseResponse)
  // optional .cockroach.proto.ResponseHeader header = 1;
  if (has_header()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->header_, output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:cockroach.proto.LeaderLeaseResponse)
}

::google::protobuf::uint8* LeaderLeaseResponse::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:cockroach.proto.LeaderLeaseResponse)
  // optional .cockroach.proto.ResponseHeader header = 1;
  if (has_header()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, *this->header_, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:cockroach.proto.LeaderLeaseResponse)
  return target;
}

int LeaderLeaseResponse::ByteSize() const {
  int total_size = 0;

  // optional .cockroach.proto.ResponseHeader header = 1;
  if (has_header()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->header_);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void LeaderLeaseResponse::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const LeaderLeaseResponse* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const LeaderLeaseResponse>(
          &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void LeaderLeaseResponse::MergeFrom(const LeaderLeaseResponse& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_header()) {
      mutable_header()->::cockroach::proto::ResponseHeader::MergeFrom(from.header());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void LeaderLeaseResponse::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void LeaderLeaseResponse::CopyFrom(const LeaderLeaseResponse& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LeaderLeaseResponse::IsInitialized() const {

  return true;
}

void LeaderLeaseResponse::Swap(LeaderLeaseResponse* other) {
  if (other == this) return;
  InternalSwap(other);
}
void LeaderLeaseResponse::InternalSwap(LeaderLeaseResponse* other) {
  std::swap(header_, other->header_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata LeaderLeaseResponse::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = LeaderLeaseResponse_descriptor_;
  metadata.reflection = LeaderLeaseResponse_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// LeaderLeaseResponse

// optional .cockroach.proto.ResponseHeader header = 1;
bool LeaderLeaseResponse::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void LeaderLeaseResponse::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
void LeaderLeaseResponse::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
void LeaderLeaseResponse::clear_header() {
  if (header_ != NULL) header_->::cockroach::proto::ResponseHeader::Clear();
  clear_has_header();
}
 const ::cockroach::proto::ResponseHeader& LeaderLeaseResponse::header() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.LeaderLeaseResponse.header)
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
 ::cockroach::proto::ResponseHeader* LeaderLeaseResponse::mutable_header() {
  set_has_header();
  if (header_ == NULL) {
    header_ = new ::cockroach::proto::ResponseHeader;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.proto.LeaderLeaseResponse.header)
  return header_;
}
 ::cockroach::proto::ResponseHeader* LeaderLeaseResponse::release_header() {
  clear_has_header();
  ::cockroach::proto::ResponseHeader* temp = header_;
  header_ = NULL;
  return temp;
}
 void LeaderLeaseResponse::set_allocated_header(::cockroach::proto::ResponseHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.LeaderLeaseResponse.header)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#ifndef _MSC_VER
const int RequestUnion::kGetFieldNumber;
const int RequestUnion::kPutFieldNumber;
const int RequestUnion::kConditionalPutFieldNumber;
const int RequestUnion::kIncrementFieldNumber;
const int RequestUnion::kDeleteFieldNumber;
const int RequestUnion::kDeleteRangeFieldNumber;
const int RequestUnion::kScanFieldNumber;
const int RequestUnion::kEndTransactionFieldNumber;
const int RequestUnion::kAdminSplitFieldNumber;
const int RequestUnion::kAdminMergeFieldNumber;
const int RequestUnion::kHeartbeatTxnFieldNumber;
const int RequestUnion::kGcFieldNumber;
const int RequestUnion::kPushTxnFieldNumber;
const int RequestUnion::kRangeLookupFieldNumber;
const int RequestUnion::kResolveIntentFieldNumber;
const int RequestUnion::kResolveIntentRangeFieldNumber;
const int RequestUnion::kMergeFieldNumber;
const int RequestUnion::kTruncateLogFieldNumber;
const int RequestUnion::kLeaderLeaseFieldNumber;
const int RequestUnion::kReverseScanFieldNumber;
const int RequestUnion::kNoopFieldNumber;
#endif  // !_MSC_VER

RequestUnion::RequestUnion()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:cockroach.proto.RequestUnion)
}

void RequestUnion::InitAsDefaultInstance() {
  get_ = const_cast< ::cockroach::proto::GetRequest*>(&::cockroach::proto::GetRequest::default_instance());
  put_ = const_cast< ::cockroach::proto::PutRequest*>(&::cockroach::proto::PutRequest::default_instance());
  conditional_put_ = const_cast< ::cockroach::proto::ConditionalPutRequest*>(&::cockroach::proto::ConditionalPutRequest::default_instance());
  increment_ = const_cast< ::cockroach::proto::IncrementRequest*>(&::cockroach::proto::IncrementRequest::default_instance());
  delete__ = const_cast< ::cockroach::proto::DeleteRequest*>(&::cockroach::proto::DeleteRequest::default_instance());
  delete_range_ = const_cast< ::cockroach::proto::DeleteRangeRequest*>(&::cockroach::proto::DeleteRangeRequest::default_instance());
  scan_ = const_cast< ::cockroach::proto::ScanRequest*>(&::cockroach::proto::ScanRequest::default_instance());
  end_transaction_ = const_cast< ::cockroach::proto::EndTransactionRequest*>(&::cockroach::proto::EndTransactionRequest::default_instance());
  admin_split_ = const_cast< ::cockroach::proto::AdminSplitRequest*>(&::cockroach::proto::AdminSplitRequest::default_instance());
  admin_merge_ = const_cast< ::cockroach::proto::AdminMergeRequest*>(&::cockroach::proto::AdminMergeRequest::default_instance());
  heartbeat_txn_ = const_cast< ::cockroach::proto::HeartbeatTxnRequest*>(&::cockroach::proto::HeartbeatTxnRequest::default_instance());
  gc_ = const_cast< ::cockroach::proto::GCRequest*>(&::cockroach::proto::GCRequest::default_instance());
  push_txn_ = const_cast< ::cockroach::proto::PushTxnRequest*>(&::cockroach::proto::PushTxnRequest::default_instance());
  range_lookup_ = const_cast< ::cockroach::proto::RangeLookupRequest*>(&::cockroach::proto::RangeLookupRequest::default_instance());
  resolve_intent_ = const_cast< ::cockroach::proto::ResolveIntentRequest*>(&::cockroach::proto::ResolveIntentRequest::default_instance());
  resolve_intent_range_ = const_cast< ::cockroach::proto::ResolveIntentRangeRequest*>(&::cockroach::proto::ResolveIntentRangeRequest::default_instance());
  merge_ = const_cast< ::cockroach::proto::MergeRequest*>(&::cockroach::proto::MergeRequest::default_instance());
  truncate_log_ = const_cast< ::cockroach::proto::TruncateLogRequest*>(&::cockroach::proto::TruncateLogRequest::default_instance());
  leader_lease_ = const_cast< ::cockroach::proto::LeaderLeaseRequest*>(&::cockroach::proto::LeaderLeaseRequest::default_instance());
  reverse_scan_ = const_cast< ::cockroach::proto::ReverseScanRequest*>(&::cockroach::proto::ReverseScanRequest::default_instance());
  noop_ = const_cast< ::cockroach::proto::NoopRequest*>(&::cockroach::proto::NoopRequest::default_instance());
}

RequestUnion::RequestUnion(const RequestUnion& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:cockroach.proto.RequestUnion)
}

void RequestUnion::SharedCtor() {
  _cached_size_ = 0;
  get_ = NULL;
  put_ = NULL;
  conditional_put_ = NULL;
  increment_ = NULL;
  delete__ = NULL;
  delete_range_ = NULL;
  scan_ = NULL;
  end_transaction_ = NULL;
  admin_split_ = NULL;
  admin_merge_ = NULL;
  heartbeat_txn_ = NULL;
  gc_ = NULL;
  push_txn_ = NULL;
  range_lookup_ = NULL;
  resolve_intent_ = NULL;
  resolve_intent_range_ = NULL;
  merge_ = NULL;
  truncate_log_ = NULL;
  leader_lease_ = NULL;
  reverse_scan_ = NULL;
  noop_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RequestUnion::~RequestUnion() {
  // @@protoc_insertion_point(destructor:cockroach.proto.RequestUnion)
  SharedDtor();
}

void RequestUnion::SharedDtor() {
  if (this != default_instance_) {
    delete get_;
    delete put_;
    delete conditional_put_;
    delete increment_;
    delete delete__;
    delete delete_range_;
    delete scan_;
    delete end_transaction_;
    delete admin_split_;
    delete admin_merge_;
    delete heartbeat_txn_;
    delete gc_;
    delete push_txn_;
    delete range_lookup_;
    delete resolve_intent_;
    delete resolve_intent_range_;
    delete merge_;
    delete truncate_log_;
    delete leader_lease_;
    delete reverse_scan_;
    delete noop_;
  }
}

void RequestUnion::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* RequestUnion::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return RequestUnion_descriptor_;
}

const RequestUnion& RequestUnion::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_cockroach_2fproto_2fapi_2eproto();
  return *default_instance_;
}

RequestUnion* RequestUnion::default_instance_ = NULL;

RequestUnion* RequestUnion::New(::google::protobuf::Arena* arena) const {
  RequestUnion* n = new RequestUnion;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void RequestUnion::Clear() {
  if (_has_bits_[0 / 32] & 255u) {
    if (has_get()) {
      if (get_ != NULL) get_->::cockroach::proto::GetRequest::Clear();
    }
    if (has_put()) {
      if (put_ != NULL) put_->::cockroach::proto::PutRequest::Clear();
    }
    if (has_conditional_put()) {
      if (conditional_put_ != NULL) conditional_put_->::cockroach::proto::ConditionalPutRequest::Clear();
    }
    if (has_increment()) {
      if (increment_ != NULL) increment_->::cockroach::proto::IncrementRequest::Clear();
    }
    if (has_delete_()) {
      if (delete__ != NULL) delete__->::cockroach::proto::DeleteRequest::Clear();
    }
    if (has_delete_range()) {
      if (delete_range_ != NULL) delete_range_->::cockroach::proto::DeleteRangeRequest::Clear();
    }
    if (has_scan()) {
      if (scan_ != NULL) scan_->::cockroach::proto::ScanRequest::Clear();
    }
    if (has_end_transaction()) {
      if (end_transaction_ != NULL) end_transaction_->::cockroach::proto::EndTransactionRequest::Clear();
    }
  }
  if (_has_bits_[8 / 32] & 65280u) {
    if (has_admin_split()) {
      if (admin_split_ != NULL) admin_split_->::cockroach::proto::AdminSplitRequest::Clear();
    }
    if (has_admin_merge()) {
      if (admin_merge_ != NULL) admin_merge_->::cockroach::proto::AdminMergeRequest::Clear();
    }
    if (has_heartbeat_txn()) {
      if (heartbeat_txn_ != NULL) heartbeat_txn_->::cockroach::proto::HeartbeatTxnRequest::Clear();
    }
    if (has_gc()) {
      if (gc_ != NULL) gc_->::cockroach::proto::GCRequest::Clear();
    }
    if (has_push_txn()) {
      if (push_txn_ != NULL) push_txn_->::cockroach::proto::PushTxnRequest::Clear();
    }
    if (has_range_lookup()) {
      if (range_lookup_ != NULL) range_lookup_->::cockroach::proto::RangeLookupRequest::Clear();
    }
    if (has_resolve_intent()) {
      if (resolve_intent_ != NULL) resolve_intent_->::cockroach::proto::ResolveIntentRequest::Clear();
    }
    if (has_resolve_intent_range()) {
      if (resolve_intent_range_ != NULL) resolve_intent_range_->::cockroach::proto::ResolveIntentRangeRequest::Clear();
    }
  }
  if (_has_bits_[16 / 32] & 2031616u) {
    if (has_merge()) {
      if (merge_ != NULL) merge_->::cockroach::proto::MergeRequest::Clear();
    }
    if (has_truncate_log()) {
      if (truncate_log_ != NULL) truncate_log_->::cockroach::proto::TruncateLogRequest::Clear();
    }
    if (has_leader_lease()) {
      if (leader_lease_ != NULL) leader_lease_->::cockroach::proto::LeaderLeaseRequest::Clear();
    }
    if (has_reverse_scan()) {
      if (reverse_scan_ != NULL) reverse_scan_->::cockroach::proto::ReverseScanRequest::Clear();
    }
    if (has_noop()) {
      if (noop_ != NULL) noop_->::cockroach::proto::NoopRequest::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool RequestUnion::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:cockroach.proto.RequestUnion)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(16383);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .cockroach.proto.GetRequest get = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_get()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_put;
        break;
      }

      // optional .cockroach.proto.PutRequest put = 2;
      case 2: {
        if (tag == 18) {
         parse_put:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_put()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_conditional_put;
        break;
      }

      // optional .cockroach.proto.ConditionalPutRequest conditional_put = 3;
      case 3: {
        if (tag == 26) {
         parse_conditional_put:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_conditional_put()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_increment;
        break;
      }

      // optional .cockroach.proto.IncrementRequest increment = 4;
      case 4: {
        if (tag == 34) {
         parse_increment:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_increment()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_delete;
        break;
      }

      // optional .cockroach.proto.DeleteRequest delete = 5;
      case 5: {
        if (tag == 42) {
         parse_delete:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_delete_()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(50)) goto parse_delete_range;
        break;
      }

      // optional .cockroach.proto.DeleteRangeRequest delete_range = 6;
      case 6: {
        if (tag == 50) {
         parse_delete_range:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_delete_range()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(58)) goto parse_scan;
        break;
      }

      // optional .cockroach.proto.ScanRequest scan = 7;
      case 7: {
        if (tag == 58) {
         parse_scan:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_scan()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(66)) goto parse_end_transaction;
        break;
      }

      // optional .cockroach.proto.EndTransactionRequest end_transaction = 8;
      case 8: {
        if (tag == 66) {
         parse_end_transaction:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_end_transaction()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(74)) goto parse_admin_split;
        break;
      }

      // optional .cockroach.proto.AdminSplitRequest admin_split = 9;
      case 9: {
        if (tag == 74) {
         parse_admin_split:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_admin_split()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(82)) goto parse_admin_merge;
        break;
      }

      // optional .cockroach.proto.AdminMergeRequest admin_merge = 10;
      case 10: {
        if (tag == 82) {
         parse_admin_merge:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_admin_merge()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(90)) goto parse_heartbeat_txn;
        break;
      }

      // optional .cockroach.proto.HeartbeatTxnRequest heartbeat_txn = 11;
      case 11: {
        if (tag == 90) {
         parse_heartbeat_txn:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_heartbeat_txn()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(98)) goto parse_gc;
        break;
      }

      // optional .cockroach.proto.GCRequest gc = 12;
      case 12: {
        if (tag == 98) {
         parse_gc:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_gc()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(106)) goto parse_push_txn;
        break;
      }

      // optional .cockroach.proto.PushTxnRequest push_txn = 13;
      case 13: {
        if (tag == 106) {
         parse_push_txn:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_push_txn()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(114)) goto parse_range_lookup;
        break;
      }

      // optional .cockroach.proto.RangeLookupRequest range_lookup = 14;
      case 14: {
        if (tag == 114) {
         parse_range_lookup:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_range_lookup()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(122)) goto parse_resolve_intent;
        break;
      }

      // optional .cockroach.proto.ResolveIntentRequest resolve_intent = 15;
      case 15: {
        if (tag == 122) {
         parse_resolve_intent:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_resolve_intent()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(130)) goto parse_resolve_intent_range;
        break;
      }

      // optional .cockroach.proto.ResolveIntentRangeRequest resolve_intent_range = 16;
      case 16: {
        if (tag == 130) {
         parse_resolve_intent_range:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_resolve_intent_range()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(138)) goto parse_merge;
        break;
      }

      // optional .cockroach.proto.MergeRequest merge = 17;
      case 17: {
        if (tag == 138) {
         parse_merge:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_merge()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(146)) goto parse_truncate_log;
        break;
      }

      // optional .cockroach.proto.TruncateLogRequest truncate_log = 18;
      case 18: {
        if (tag == 146) {
         parse_truncate_log:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_truncate_log()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(154)) goto parse_leader_lease;
        break;
      }

      // optional .cockroach.proto.LeaderLeaseRequest leader_lease = 19;
      case 19: {
        if (tag == 154) {
         parse_leader_lease:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_leader_lease()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(162)) goto parse_reverse_scan;
        break;
      }

      // optional .cockroach.proto.ReverseScanRequest reverse_scan = 20;
      case 20: {
        if (tag == 162) {
         parse_reverse_scan:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_reverse_scan()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(170)) goto parse_noop;
        break;
      }

      // optional .cockroach.proto.NoopRequest noop = 21;
      case 21: {
        if (tag == 170) {
         parse_noop:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_noop()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:cockroach.proto.RequestUnion)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:cockroach.proto.RequestUnion)
  return false;
#undef DO_
}

void RequestUnion::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:cockroach.proto.RequestUnion)
  // optional .cockroach.proto.GetRequest get = 1;
  if (has_get()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->get_, output);
  }

  // optional .cockroach.proto.PutRequest put = 2;
  if (has_put()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, *this->put_, output);
  }

  // optional .cockroach.proto.ConditionalPutRequest conditional_put = 3;
  if (has_conditional_put()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, *this->conditional_put_, output);
  }

  // optional .cockroach.proto.IncrementRequest increment = 4;
  if (has_increment()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, *this->increment_, output);
  }

  // optional .cockroach.proto.DeleteRequest delete = 5;
  if (has_delete_()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      5, *this->delete__, output);
  }

  // optional .cockroach.proto.DeleteRangeRequest delete_range = 6;
  if (has_delete_range()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      6, *this->delete_range_, output);
  }

  // optional .cockroach.proto.ScanRequest scan = 7;
  if (has_scan()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      7, *this->scan_, output);
  }

  // optional .cockroach.proto.EndTransactionRequest end_transaction = 8;
  if (has_end_transaction()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      8, *this->end_transaction_, output);
  }

  // optional .cockroach.proto.AdminSplitRequest admin_split = 9;
  if (has_admin_split()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      9, *this->admin_split_, output);
  }

  // optional .cockroach.proto.AdminMergeRequest admin_merge = 10;
  if (has_admin_merge()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      10, *this->admin_merge_, output);
  }

  // optional .cockroach.proto.HeartbeatTxnRequest heartbeat_txn = 11;
  if (has_heartbeat_txn()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      11, *this->heartbeat_txn_, output);
  }

  // optional .cockroach.proto.GCRequest gc = 12;
  if (has_gc()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      12, *this->gc_, output);
  }

  // optional .cockroach.proto.PushTxnRequest push_txn = 13;
  if (has_push_txn()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      13, *this->push_txn_, output);
  }

  // optional .cockroach.proto.RangeLookupRequest range_lookup = 14;
  if (has_range_lookup()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      14, *this->range_lookup_, output);
  }

  // optional .cockroach.proto.ResolveIntentRequest resolve_intent = 15;
  if (has_resolve_intent()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      15, *this->resolve_intent_, output);
  }

  // optional .cockroach.proto.ResolveIntentRangeRequest resolve_intent_range = 16;
  if (has_resolve_intent_range()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      16, *this->resolve_intent_range_, output);
  }

  // optional .cockroach.proto.MergeRequest merge = 17;
  if (has_merge()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      17, *this->merge_, output);
  }

  // optional .cockroach.proto.TruncateLogRequest truncate_log = 18;
  if (has_truncate_log()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      18, *this->truncate_log_, output);
  }

  // optional .cockroach.proto.LeaderLeaseRequest leader_lease = 19;
  if (has_leader_lease()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      19, *this->leader_lease_, output);
  }

  // optional .cockroach.proto.ReverseScanRequest reverse_scan = 20;
  if (has_reverse_scan()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      20, *this->reverse_scan_, output);
  }

  // optional .cockroach.proto.NoopRequest noop = 21;
  if (has_noop()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      21, *this->noop_, output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:cockroach.proto.RequestUnion)
}

::google::protobuf::uint8* RequestUnion::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:cockroach.proto.RequestUnion)
  // optional .cockroach.proto.GetRequest get = 1;
  if (has_get()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, *this->get_, target);
  }

  // optional .cockroach.proto.PutRequest put = 2;
  if (has_put()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, *this->put_, target);
  }

  // optional .cockroach.proto.ConditionalPutRequest conditional_put = 3;
  if (has_conditional_put()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, *this->conditional_put_, target);
  }

  // optional .cockroach.proto.IncrementRequest increment = 4;
  if (has_increment()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        4, *this->increment_, target);
  }

  // optional .cockroach.proto.DeleteRequest delete = 5;
  if (has_delete_()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        5, *this->delete__, target);
  }

  // optional .cockroach.proto.DeleteRangeRequest delete_range = 6;
  if (has_delete_range()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        6, *this->delete_range_, target);
  }

  // optional .cockroach.proto.ScanRequest scan = 7;
  if (has_scan()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        7, *this->scan_, target);
  }

  // optional .cockroach.proto.EndTransactionRequest end_transaction = 8;
  if (has_end_transaction()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        8, *this->end_transaction_, target);
  }

  // optional .cockroach.proto.AdminSplitRequest admin_split = 9;
  if (has_admin_split()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        9, *this->admin_split_, target);
  }

  // optional .cockroach.proto.AdminMergeRequest admin_merge = 10;
  if (has_admin_merge()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        10, *this->admin_merge_, target);
  }

  // optional .cockroach.proto.HeartbeatTxnRequest heartbeat_txn = 11;
  if (has_heartbeat_txn()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        11, *this->heartbeat_txn_, target);
  }

  // optional .cockroach.proto.GCRequest gc = 12;
  if (has_gc()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        12, *this->gc_, target);
  }

  // optional .cockroach.proto.PushTxnRequest push_txn = 13;
  if (has_push_txn()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        13, *this->push_txn_, target);
  }

  // optional .cockroach.proto.RangeLookupRequest range_lookup = 14;
  if (has_range_lookup()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        14, *this->range_lookup_, target);
  }

  // optional .cockroach.proto.ResolveIntentRequest resolve_intent = 15;
  if (has_resolve_intent()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        15, *this->resolve_intent_, target);
  }

  // optional .cockroach.proto.ResolveIntentRangeRequest resolve_intent_range = 16;
  if (has_resolve_intent_range()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        16, *this->resolve_intent_range_, target);
  }

  // optional .cockroach.proto.MergeRequest merge = 17;
  if (has_merge()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        17, *this->merge_, target);
  }

  // optional .cockroach.proto.TruncateLogRequest truncate_log = 18;
  if (has_truncate_log()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        18, *this->truncate_log_, target);
  }

  // optional .cockroach.proto.LeaderLeaseRequest leader_lease = 19;
  if (has_leader_lease()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        19, *this->leader_lease_, target);
  }

  // optional .cockroach.proto.ReverseScanRequest reverse_scan = 20;
  if (has_reverse_scan()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        20, *this->reverse_scan_, target);
  }

  // optional .cockroach.proto.NoopRequest noop = 21;
  if (has_noop()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        21, *this->noop_, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:cockroach.proto.RequestUnion)
  return target;
}

int RequestUnion::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & 255) {
    // optional .cockroach.proto.GetRequest get = 1;
    if (has_get()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->get_);
    }

    // optional .cockroach.proto.PutRequest put = 2;
    if (has_put()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->put_);
    }

    // optional .cockroach.proto.ConditionalPutRequest conditional_put = 3;
    if (has_conditional_put()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->conditional_put_);
    }

    // optional .cockroach.proto.IncrementRequest increment = 4;
    if (has_increment()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->increment_);
    }

    // optional .cockroach.proto.DeleteRequest delete = 5;
    if (has_delete_()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->delete__);
    }

    // optional .cockroach.proto.DeleteRangeRequest delete_range = 6;
    if (has_delete_range()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->delete_range_);
    }

    // optional .cockroach.proto.ScanRequest scan = 7;
    if (has_scan()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->scan_);
    }

    // optional .cockroach.proto.EndTransactionRequest end_transaction = 8;
    if (has_end_transaction()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->end_transaction_);
    }

  }
  if (_has_bits_[8 / 32] & 65280) {
    // optional .cockroach.proto.AdminSplitRequest admin_split = 9;
    if (has_admin_split()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->admin_split_);
    }

    // optional .cockroach.proto.AdminMergeRequest admin_merge = 10;
    if (has_admin_merge()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->admin_merge_);
    }

    // optional .cockroach.proto.HeartbeatTxnRequest heartbeat_txn = 11;
    if (has_heartbeat_txn()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->heartbeat_txn_);
    }

    // optional .cockroach.proto.GCRequest gc = 12;
    if (has_gc()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->gc_);
    }

    // optional .cockroach.proto.PushTxnRequest push_txn = 13;
    if (has_push_txn()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->push_txn_);
    }

    // optional .cockroach.proto.RangeLookupRequest range_lookup = 14;
    if (has_range_lookup()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->range_lookup_);
    }

    // optional .cockroach.proto.ResolveIntentRequest resolve_intent = 15;
    if (has_resolve_intent()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->resolve_intent_);
    }

    // optional .cockroach.proto.ResolveIntentRangeRequest resolve_intent_range = 16;
    if (has_resolve_intent_range()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->resolve_intent_range_);
    }

  }
  if (_has_bits_[16 / 32] & 2031616) {
    // optional .cockroach.proto.MergeRequest merge = 17;
    if (has_merge()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->merge_);
    }

    // optional .cockroach.proto.TruncateLogRequest truncate_log = 18;
    if (has_truncate_log()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->truncate_log_);
    }

    // optional .cockroach.proto.LeaderLeaseRequest leader_lease = 19;
    if (has_leader_lease()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->leader_lease_);
    }

    // optional .cockroach.proto.ReverseScanRequest reverse_scan = 20;
    if (has_reverse_scan()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->reverse_scan_);
    }

    // optional .cockroach.proto.NoopRequest noop = 21;
    if (has_noop()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->noop_);
    }

  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RequestUnion::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const RequestUnion* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const RequestUnion>(
          &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void RequestUnion::MergeFrom(const RequestUnion& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_get()) {
      mutable_get()->::cockroach::proto::GetRequest::MergeFrom(from.get());
    }
    if (from.has_put()) {
      mutable_put()->::cockroach::proto::PutRequest::MergeFrom(from.put());
    }
    if (from.has_conditional_put()) {
      mutable_conditional_put()->::cockroach::proto::ConditionalPutRequest::MergeFrom(from.conditional_put());
    }
    if (from.has_increment()) {
      mutable_increment()->::cockroach::proto::IncrementRequest::MergeFrom(from.increment());
    }
    if (from.has_delete_()) {
      mutable_delete_()->::cockroach::proto::DeleteRequest::MergeFrom(from.delete_());
    }
    if (from.has_delete_range()) {
      mutable_delete_range()->::cockroach::proto::DeleteRangeRequest::MergeFrom(from.delete_range());
    }
    if (from.has_scan()) {
      mutable_scan()->::cockroach::proto::ScanRequest::MergeFrom(from.scan());
    }
    if (from.has_end_transaction()) {
      mutable_end_transaction()->::cockroach::proto::EndTransactionRequest::MergeFrom(from.end_transaction());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_admin_split()) {
      mutable_admin_split()->::cockroach::proto::AdminSplitRequest::MergeFrom(from.admin_split());
    }
    if (from.has_admin_merge()) {
      mutable_admin_merge()->::cockroach::proto::AdminMergeRequest::MergeFrom(from.admin_merge());
    }
    if (from.has_heartbeat_txn()) {
      mutable_heartbeat_txn()->::cockroach::proto::HeartbeatTxnRequest::MergeFrom(from.heartbeat_txn());
    }
    if (from.has_gc()) {
      mutable_gc()->::cockroach::proto::GCRequest::MergeFrom(from.gc());
    }
    if (from.has_push_txn()) {
      mutable_push_txn()->::cockroach::proto::PushTxnRequest::MergeFrom(from.push_txn());
    }
    if (from.has_range_lookup()) {
      mutable_range_lookup()->::cockroach::proto::RangeLookupRequest::MergeFrom(from.range_lookup());
    }
    if (from.has_resolve_intent()) {
      mutable_resolve_intent()->::cockroach::proto::ResolveIntentRequest::MergeFrom(from.resolve_intent());
    }
    if (from.has_resolve_intent_range()) {
      mutable_resolve_intent_range()->::cockroach::proto::ResolveIntentRangeRequest::MergeFrom(from.resolve_intent_range());
    }
  }
  if (from._has_bits_[16 / 32] & (0xffu << (16 % 32))) {
    if (from.has_merge()) {
      mutable_merge()->::cockroach::proto::MergeRequest::MergeFrom(from.merge());
    }
    if (from.has_truncate_log()) {
      mutable_truncate_log()->::cockroach::proto::TruncateLogRequest::MergeFrom(from.truncate_log());
    }
    if (from.has_leader_lease()) {
      mutable_leader_lease()->::cockroach::proto::LeaderLeaseRequest::MergeFrom(from.leader_lease());
    }
    if (from.has_reverse_scan()) {
      mutable_reverse_scan()->::cockroach::proto::ReverseScanRequest::MergeFrom(from.reverse_scan());
    }
    if (from.has_noop()) {
      mutable_noop()->::cockroach::proto::NoopRequest::MergeFrom(from.noop());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void RequestUnion::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void RequestUnion::CopyFrom(const RequestUnion& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RequestUnion::IsInitialized() const {

  return true;
}

void RequestUnion::Swap(RequestUnion* other) {
  if (other == this) return;
  InternalSwap(other);
}
void RequestUnion::InternalSwap(RequestUnion* other) {
  std::swap(get_, other->get_);
  std::swap(put_, other->put_);
  std::swap(conditional_put_, other->conditional_put_);
  std::swap(increment_, other->increment_);
  std::swap(delete__, other->delete__);
  std::swap(delete_range_, other->delete_range_);
  std::swap(scan_, other->scan_);
  std::swap(end_transaction_, other->end_transaction_);
  std::swap(admin_split_, other->admin_split_);
  std::swap(admin_merge_, other->admin_merge_);
  std::swap(heartbeat_txn_, other->heartbeat_txn_);
  std::swap(gc_, other->gc_);
  std::swap(push_txn_, other->push_txn_);
  std::swap(range_lookup_, other->range_lookup_);
  std::swap(resolve_intent_, other->resolve_intent_);
  std::swap(resolve_intent_range_, other->resolve_intent_range_);
  std::swap(merge_, other->merge_);
  std::swap(truncate_log_, other->truncate_log_);
  std::swap(leader_lease_, other->leader_lease_);
  std::swap(reverse_scan_, other->reverse_scan_);
  std::swap(noop_, other->noop_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata RequestUnion::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = RequestUnion_descriptor_;
  metadata.reflection = RequestUnion_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// RequestUnion

// optional .cockroach.proto.GetRequest get = 1;
bool RequestUnion::has_get() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void RequestUnion::set_has_get() {
  _has_bits_[0] |= 0x00000001u;
}
void RequestUnion::clear_has_get() {
  _has_bits_[0] &= ~0x00000001u;
}
void RequestUnion::clear_get() {
  if (get_ != NULL) get_->::cockroach::proto::GetRequest::Clear();
  clear_has_get();
}
 const ::cockroach::proto::GetRequest& RequestUnion::get() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.RequestUnion.get)
  return get_ != NULL ? *get_ : *default_instance_->get_;
}
 ::cockroach::proto::GetRequest* RequestUnion::mutable_get() {
  set_has_get();
  if (get_ == NULL) {
    get_ = new ::cockroach::proto::GetRequest;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.proto.RequestUnion.get)
  return get_;
}
 ::cockroach::proto::GetRequest* RequestUnion::release_get() {
  clear_has_get();
  ::cockroach::proto::GetRequest* temp = get_;
  get_ = NULL;
  return temp;
}
 void RequestUnion::set_allocated_get(::cockroach::proto::GetRequest* get) {
  delete get_;
  get_ = get;
  if (get) {
    set_has_get();
  } else {
    clear_has_get();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.RequestUnion.get)
}

// optional .cockroach.proto.PutRequest put = 2;
bool RequestUnion::has_put() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void RequestUnion::set_has_put() {
  _has_bits_[0] |= 0x00000002u;
}
void RequestUnion::clear_has_put() {
  _has_bits_[0] &= ~0x00000002u;
}
void RequestUnion::clear_put() {
  if (put_ != NULL) put_->::cockroach::proto::PutRequest::Clear();
  clear_has_put();
}
 const ::cockroach::proto::PutRequest& RequestUnion::put() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.RequestUnion.put)
  return put_ != NULL ? *put_ : *default_instance_->put_;
}
 ::cockroach::proto::PutRequest* RequestUnion::mutable_put() {
  set_has_put();
  if (put_ == NULL) {
    put_ = new ::cockroach::proto::PutRequest;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.proto.RequestUnion.put)
  return put_;
}
 ::cockroach::proto::PutRequest* RequestUnion::release_put() {
  clear_has_put();
  ::cockroach::proto::PutRequest* temp = put_;
  put_ = NULL;
  return temp;
}
 void RequestUnion::set_allocated_put(::cockroach::proto::PutRequest* put) {
  delete put_;
  put_ = put;
  if (put) {
    set_has_put();
  } else {
    clear_has_put();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.RequestUnion.put)
}

// optional .cockroach.proto.ConditionalPutRequest conditional_put = 3;
bool RequestUnion::has_conditional_put() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void RequestUnion::set_has_conditional_put() {
  _has_bits_[0] |= 0x00000004u;
}
void RequestUnion::clear_has_conditional_put() {
  _has_bits_[0] &= ~0x00000004u;
}
void RequestUnion::clear_conditional_put() {
  if (conditional_put_ != NULL) conditional_put_->::cockroach::proto::ConditionalPutRequest::Clear();
  clear_has_conditional_put();
}
 const ::cockroach::proto::ConditionalPutRequest& RequestUnion::conditional_put() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.RequestUnion.conditional_put)
  return conditional_put_ != NULL ? *conditional_put_ : *default_instance_->conditional_put_;
}
 ::cockroach::proto::ConditionalPutRequest* RequestUnion::mutable_conditional_put() {
  set_has_conditional_put();
  if (conditional_put_ == NULL) {
    conditional_put_ = new ::cockroach::proto::ConditionalPutRequest;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.proto.RequestUnion.conditional_put)
  return conditional_put_;
}
 ::cockroach::proto::ConditionalPutRequest* RequestUnion::release_conditional_put() {
  clear_has_conditional_put();
  ::cockroach::proto::ConditionalPutRequest* temp = conditional_put_;
  conditional_put_ = NULL;
  return temp;
}
 void RequestUnion::set_allocated_conditional_put(::cockroach::proto::ConditionalPutRequest* conditional_put) {
  delete conditional_put_;
  conditional_put_ = conditional_put;
  if (conditional_put) {
    set_has_conditional_put();
  } else {
    clear_has_conditional_put();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.RequestUnion.conditional_put)
}

// optional .cockroach.proto.IncrementRequest increment = 4;
bool RequestUnion::has_increment() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void RequestUnion::set_has_increment() {
  _has_bits_[0] |= 0x00000008u;
}
void RequestUnion::clear_has_increment() {
  _has_bits_[0] &= ~0x00000008u;
}
void RequestUnion::clear_increment() {
  if (increment_ != NULL) increment_->::cockroach::proto::IncrementRequest::Clear();
  clear_has_increment();
}
 const ::cockroach::proto::IncrementRequest& RequestUnion::increment() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.RequestUnion.increment)
  return increment_ != NULL ? *increment_ : *default_instance_->increment_;
}
 ::cockroach::proto::IncrementRequest* RequestUnion::mutable_increment() {
  set_has_increment();
  if (increment_ == NULL) {
    increment_ = new ::cockroach::proto::IncrementRequest;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.proto.RequestUnion.increment)
  return increment_;
}
 ::cockroach::proto::IncrementRequest* RequestUnion::release_increment() {
  clear_has_increment();
  ::cockroach::proto::IncrementRequest* temp = increment_;
  increment_ = NULL;
  return temp;
}
 void RequestUnion::set_allocated_increment(::cockroach::proto::IncrementRequest* increment) {
  delete increment_;
  increment_ = increment;
  if (increment) {
    set_has_increment();
  } else {
    clear_has_increment();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.RequestUnion.increment)
}

// optional .cockroach.proto.DeleteRequest delete = 5;
bool RequestUnion::has_delete_() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
void RequestUnion::set_has_delete_() {
  _has_bits_[0] |= 0x00000010u;
}
void RequestUnion::clear_has_delete_() {
  _has_bits_[0] &= ~0x00000010u;
}
void RequestUnion::clear_delete_() {
  if (delete__ != NULL) delete__->::cockroach::proto::DeleteRequest::Clear();
  clear_has_delete_();
}
 const ::cockroach::proto::DeleteRequest& RequestUnion::delete_() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.RequestUnion.delete)
  return delete__ != NULL ? *delete__ : *default_instance_->delete__;
}
 ::cockroach::proto::DeleteRequest* RequestUnion::mutable_delete_() {
  set_has_delete_();
  if (delete__ == NULL) {
    delete__ = new ::cockroach::proto::DeleteRequest;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.proto.RequestUnion.delete)
  return delete__;
}
 ::cockroach::proto::DeleteRequest* RequestUnion::release_delete_() {
  clear_has_delete_();
  ::cockroach::proto::DeleteRequest* temp = delete__;
  delete__ = NULL;
  return temp;
}
 void RequestUnion::set_allocated_delete_(::cockroach::proto::DeleteRequest* delete_) {
  delete delete__;
  delete__ = delete_;
  if (delete_) {
    set_has_delete_();
  } else {
    clear_has_delete_();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.RequestUnion.delete)
}

// optional .cockroach.proto.DeleteRangeRequest delete_range = 6;
bool RequestUnion::has_delete_range() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
void RequestUnion::set_has_delete_range() {
  _has_bits_[0] |= 0x00000020u;
}
void RequestUnion::clear_has_delete_range() {
  _has_bits_[0] &= ~0x00000020u;
}
void RequestUnion::clear_delete_range() {
  if (delete_range_ != NULL) delete_range_->::cockroach::proto::DeleteRangeRequest::Clear();
  clear_has_delete_range();
}
 const ::cockroach::proto::DeleteRangeRequest& RequestUnion::delete_range() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.RequestUnion.delete_range)
  return delete_range_ != NULL ? *delete_range_ : *default_instance_->delete_range_;
}
 ::cockroach::proto::DeleteRangeRequest* RequestUnion::mutable_delete_range() {
  set_has_delete_range();
  if (delete_range_ == NULL) {
    delete_range_ = new ::cockroach::proto::DeleteRangeRequest;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.proto.RequestUnion.delete_range)
  return delete_range_;
}
 ::cockroach::proto::DeleteRangeRequest* RequestUnion::release_delete_range() {
  clear_has_delete_range();
  ::cockroach::proto::DeleteRangeRequest* temp = delete_range_;
  delete_range_ = NULL;
  return temp;
}
 void RequestUnion::set_allocated_delete_range(::cockroach::proto::DeleteRangeRequest* delete_range) {
  delete delete_range_;
  delete_range_ = delete_range;
  if (delete_range) {
    set_has_delete_range();
  } else {
    clear_has_delete_range();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.RequestUnion.delete_range)
}

// optional .cockroach.proto.ScanRequest scan = 7;
bool RequestUnion::has_scan() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
void RequestUnion::set_has_scan() {
  _has_bits_[0] |= 0x00000040u;
}
void RequestUnion::clear_has_scan() {
  _has_bits_[0] &= ~0x00000040u;
}
void RequestUnion::clear_scan() {
  if (scan_ != NULL) scan_->::cockroach::proto::ScanRequest::Clear();
  clear_has_scan();
}
 const ::cockroach::proto::ScanRequest& RequestUnion::scan() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.RequestUnion.scan)
  return scan_ != NULL ? *scan_ : *default_instance_->scan_;
}
 ::cockroach::proto::ScanRequest* RequestUnion::mutable_scan() {
  set_has_scan();
  if (scan_ == NULL) {
    scan_ = new ::cockroach::proto::ScanRequest;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.proto.RequestUnion.scan)
  return scan_;
}
 ::cockroach::proto::ScanRequest* RequestUnion::release_scan() {
  clear_has_scan();
  ::cockroach::proto::ScanRequest* temp = scan_;
  scan_ = NULL;
  return temp;
}
 void RequestUnion::set_allocated_scan(::cockroach::proto::ScanRequest* scan) {
  delete scan_;
  scan_ = scan;
  if (scan) {
    set_has_scan();
  } else {
    clear_has_scan();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.RequestUnion.scan)
}

// optional .cockroach.proto.EndTransactionRequest end_transaction = 8;
bool RequestUnion::has_end_transaction() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
void RequestUnion::set_has_end_transaction() {
  _has_bits_[0] |= 0x00000080u;
}
void RequestUnion::clear_has_end_transaction() {
  _has_bits_[0] &= ~0x00000080u;
}
void RequestUnion::clear_end_transaction() {
  if (end_transaction_ != NULL) end_transaction_->::cockroach::proto::EndTransactionRequest::Clear();
  clear_has_end_transaction();
}
 const ::cockroach::proto::EndTransactionRequest& RequestUnion::end_transaction() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.RequestUnion.end_transaction)
  return end_transaction_ != NULL ? *end_transaction_ : *default_instance_->end_transaction_;
}
 ::cockroach::proto::EndTransactionRequest* RequestUnion::mutable_end_transaction() {
  set_has_end_transaction();
  if (end_transaction_ == NULL) {
    end_transaction_ = new ::cockroach::proto::EndTransactionRequest;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.proto.RequestUnion.end_transaction)
  return end_transaction_;
}
 ::cockroach::proto::EndTransactionRequest* RequestUnion::release_end_transaction() {
  clear_has_end_transaction();
  ::cockroach::proto::EndTransactionRequest* temp = end_transaction_;
  end_transaction_ = NULL;
  return temp;
}
 void RequestUnion::set_allocated_end_transaction(::cockroach::proto::EndTransactionRequest* end_transaction) {
  delete end_transaction_;
  end_transaction_ = end_transaction;
  if (end_transaction) {
    set_has_end_transaction();
  } else {
    clear_has_end_transaction();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.RequestUnion.end_transaction)
}

// optional .cockroach.proto.AdminSplitRequest admin_split = 9;
bool RequestUnion::has_admin_split() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
void RequestUnion::set_has_admin_split() {
  _has_bits_[0] |= 0x00000100u;
}
void RequestUnion::clear_has_admin_split() {
  _has_bits_[0] &= ~0x00000100u;
}
void RequestUnion::clear_admin_split() {
  if (admin_split_ != NULL) admin_split_->::cockroach::proto::AdminSplitRequest::Clear();
  clear_has_admin_split();
}
 const ::cockroach::proto::AdminSplitRequest& RequestUnion::admin_split() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.RequestUnion.admin_split)
  return admin_split_ != NULL ? *admin_split_ : *default_instance_->admin_split_;
}
 ::cockroach::proto::AdminSplitRequest* RequestUnion::mutable_admin_split() {
  set_has_admin_split();
  if (admin_split_ == NULL) {
    admin_split_ = new ::cockroach::proto::AdminSplitRequest;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.proto.RequestUnion.admin_split)
  return admin_split_;
}
 ::cockroach::proto::AdminSplitRequest* RequestUnion::release_admin_split() {
  clear_has_admin_split();
  ::cockroach::proto::AdminSplitRequest* temp = admin_split_;
  admin_split_ = NULL;
  return temp;
}
 void RequestUnion::set_allocated_admin_split(::cockroach::proto::AdminSplitRequest* admin_split) {
  delete admin_split_;
  admin_split_ = admin_split;
  if (admin_split) {
    set_has_admin_split();
  } else {
    clear_has_admin_split();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.RequestUnion.admin_split)
}

// optional .cockroach.proto.AdminMergeRequest admin_merge = 10;
bool RequestUnion::has_admin_merge() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
void RequestUnion::set_has_admin_merge() {
  _has_bits_[0] |= 0x00000200u;
}
void RequestUnion::clear_has_admin_merge() {
  _has_bits_[0] &= ~0x00000200u;
}
void RequestUnion::clear_admin_merge() {
  if (admin_merge_ != NULL) admin_merge_->::cockroach::proto::AdminMergeRequest::Clear();
  clear_has_admin_merge();
}
 const ::cockroach::proto::AdminMergeRequest& RequestUnion::admin_merge() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.RequestUnion.admin_merge)
  return admin_merge_ != NULL ? *admin_merge_ : *default_instance_->admin_merge_;
}
 ::cockroach::proto::AdminMergeRequest* RequestUnion::mutable_admin_merge() {
  set_has_admin_merge();
  if (admin_merge_ == NULL) {
    admin_merge_ = new ::cockroach::proto::AdminMergeRequest;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.proto.RequestUnion.admin_merge)
  return admin_merge_;
}
 ::cockroach::proto::AdminMergeRequest* RequestUnion::release_admin_merge() {
  clear_has_admin_merge();
  ::cockroach::proto::AdminMergeRequest* temp = admin_merge_;
  admin_merge_ = NULL;
  return temp;
}
 void RequestUnion::set_allocated_admin_merge(::cockroach::proto::AdminMergeRequest* admin_merge) {
  delete admin_merge_;
  admin_merge_ = admin_merge;
  if (admin_merge) {
    set_has_admin_merge();
  } else {
    clear_has_admin_merge();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.RequestUnion.admin_merge)
}

// optional .cockroach.proto.HeartbeatTxnRequest heartbeat_txn = 11;
bool RequestUnion::has_heartbeat_txn() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
void RequestUnion::set_has_heartbeat_txn() {
  _has_bits_[0] |= 0x00000400u;
}
void RequestUnion::clear_has_heartbeat_txn() {
  _has_bits_[0] &= ~0x00000400u;
}
void RequestUnion::clear_heartbeat_txn() {
  if (heartbeat_txn_ != NULL) heartbeat_txn_->::cockroach::proto::HeartbeatTxnRequest::Clear();
  clear_has_heartbeat_txn();
}
 const ::cockroach::proto::HeartbeatTxnRequest& RequestUnion::heartbeat_txn() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.RequestUnion.heartbeat_txn)
  return heartbeat_txn_ != NULL ? *heartbeat_txn_ : *default_instance_->heartbeat_txn_;
}
 ::cockroach::proto::HeartbeatTxnRequest* RequestUnion::mutable_heartbeat_txn() {
  set_has_heartbeat_txn();
  if (heartbeat_txn_ == NULL) {
    heartbeat_txn_ = new ::cockroach::proto::HeartbeatTxnRequest;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.proto.RequestUnion.heartbeat_txn)
  return heartbeat_txn_;
}
 ::cockroach::proto::HeartbeatTxnRequest* RequestUnion::release_heartbeat_txn() {
  clear_has_heartbeat_txn();
  ::cockroach::proto::HeartbeatTxnRequest* temp = heartbeat_txn_;
  heartbeat_txn_ = NULL;
  return temp;
}
 void RequestUnion::set_allocated_heartbeat_txn(::cockroach::proto::HeartbeatTxnRequest* heartbeat_txn) {
  delete heartbeat_txn_;
  heartbeat_txn_ = heartbeat_txn;
  if (heartbeat_txn) {
    set_has_heartbeat_txn();
  } else {
    clear_has_heartbeat_txn();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.RequestUnion.heartbeat_txn)
}

// optional .cockroach.proto.GCRequest gc = 12;
bool RequestUnion::has_gc() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
void RequestUnion::set_has_gc() {
  _has_bits_[0] |= 0x00000800u;
}
void RequestUnion::clear_has_gc() {
  _has_bits_[0] &= ~0x00000800u;
}
void RequestUnion::clear_gc() {
  if (gc_ != NULL) gc_->::cockroach::proto::GCRequest::Clear();
  clear_has_gc();
}
 const ::cockroach::proto::GCRequest& RequestUnion::gc() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.RequestUnion.gc)
  return gc_ != NULL ? *gc_ : *default_instance_->gc_;
}
 ::cockroach::proto::GCRequest* RequestUnion::mutable_gc() {
  set_has_gc();
  if (gc_ == NULL) {
    gc_ = new ::cockroach::proto::GCRequest;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.proto.RequestUnion.gc)
  return gc_;
}
 ::cockroach::proto::GCRequest* RequestUnion::release_gc() {
  clear_has_gc();
  ::cockroach::proto::GCRequest* temp = gc_;
  gc_ = NULL;
  return temp;
}
 void RequestUnion::set_allocated_gc(::cockroach::proto::GCRequest* gc) {
  delete gc_;
  gc_ = gc;
  if (gc) {
    set_has_gc();
  } else {
    clear_has_gc();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.RequestUnion.gc)
}

// optional .cockroach.proto.PushTxnRequest push_txn = 13;
bool RequestUnion::has_push_txn() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
void RequestUnion::set_has_push_txn() {
  _has_bits_[0] |= 0x00001000u;
}
void RequestUnion::clear_has_push_txn() {
  _has_bits_[0] &= ~0x00001000u;
}
void RequestUnion::clear_push_txn() {
  if (push_txn_ != NULL) push_txn_->::cockroach::proto::PushTxnRequest::Clear();
  clear_has_push_txn();
}
 const ::cockroach::proto::PushTxnRequest& RequestUnion::push_txn() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.RequestUnion.push_txn)
  return push_txn_ != NULL ? *push_txn_ : *default_instance_->push_txn_;
}
 ::cockroach::proto::PushTxnRequest* RequestUnion::mutable_push_txn() {
  set_has_push_txn();
  if (push_txn_ == NULL) {
    push_txn_ = new ::cockroach::proto::PushTxnRequest;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.proto.RequestUnion.push_txn)
  return push_txn_;
}
 ::cockroach::proto::PushTxnRequest* RequestUnion::release_push_txn() {
  clear_has_push_txn();
  ::cockroach::proto::PushTxnRequest* temp = push_txn_;
  push_txn_ = NULL;
  return temp;
}
 void RequestUnion::set_allocated_push_txn(::cockroach::proto::PushTxnRequest* push_txn) {
  delete push_txn_;
  push_txn_ = push_txn;
  if (push_txn) {
    set_has_push_txn();
  } else {
    clear_has_push_txn();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.RequestUnion.push_txn)
}

// optional .cockroach.proto.RangeLookupRequest range_lookup = 14;
bool RequestUnion::has_range_lookup() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
void RequestUnion::set_has_range_lookup() {
  _has_bits_[0] |= 0x00002000u;
}
void RequestUnion::clear_has_range_lookup() {
  _has_bits_[0] &= ~0x00002000u;
}
void RequestUnion::clear_range_lookup() {
  if (range_lookup_ != NULL) range_lookup_->::cockroach::proto::RangeLookupRequest::Clear();
  clear_has_range_lookup();
}
 const ::cockroach::proto::RangeLookupRequest& RequestUnion::range_lookup() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.RequestUnion.range_lookup)
  return range_lookup_ != NULL ? *range_lookup_ : *default_instance_->range_lookup_;
}
 ::cockroach::proto::RangeLookupRequest* RequestUnion::mutable_range_lookup() {
  set_has_range_lookup();
  if (range_lookup_ == NULL) {
    range_lookup_ = new ::cockroach::proto::RangeLookupRequest;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.proto.RequestUnion.range_lookup)
  return range_lookup_;
}
 ::cockroach::proto::RangeLookupRequest* RequestUnion::release_range_lookup() {
  clear_has_range_lookup();
  ::cockroach::proto::RangeLookupRequest* temp = range_lookup_;
  range_lookup_ = NULL;
  return temp;
}
 void RequestUnion::set_allocated_range_lookup(::cockroach::proto::RangeLookupRequest* range_lookup) {
  delete range_lookup_;
  range_lookup_ = range_lookup;
  if (range_lookup) {
    set_has_range_lookup();
  } else {
    clear_has_range_lookup();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.RequestUnion.range_lookup)
}

// optional .cockroach.proto.ResolveIntentRequest resolve_intent = 15;
bool RequestUnion::has_resolve_intent() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
void RequestUnion::set_has_resolve_intent() {
  _has_bits_[0] |= 0x00004000u;
}
void RequestUnion::clear_has_resolve_intent() {
  _has_bits_[0] &= ~0x00004000u;
}
void RequestUnion::clear_resolve_intent() {
  if (resolve_intent_ != NULL) resolve_intent_->::cockroach::proto::ResolveIntentRequest::Clear();
  clear_has_resolve_intent();
}
 const ::cockroach::proto::ResolveIntentRequest& RequestUnion::resolve_intent() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.RequestUnion.resolve_intent)
  return resolve_intent_ != NULL ? *resolve_intent_ : *default_instance_->resolve_intent_;
}
 ::cockroach::proto::ResolveIntentRequest* RequestUnion::mutable_resolve_intent() {
  set_has_resolve_intent();
  if (resolve_intent_ == NULL) {
    resolve_intent_ = new ::cockroach::proto::ResolveIntentRequest;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.proto.RequestUnion.resolve_intent)
  return resolve_intent_;
}
 ::cockroach::proto::ResolveIntentRequest* RequestUnion::release_resolve_intent() {
  clear_has_resolve_intent();
  ::cockroach::proto::ResolveIntentRequest* temp = resolve_intent_;
  resolve_intent_ = NULL;
  return temp;
}
 void RequestUnion::set_allocated_resolve_intent(::cockroach::proto::ResolveIntentRequest* resolve_intent) {
  delete resolve_intent_;
  resolve_intent_ = resolve_intent;
  if (resolve_intent) {
    set_has_resolve_intent();
  } else {
    clear_has_resolve_intent();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.RequestUnion.resolve_intent)
}

// optional .cockroach.proto.ResolveIntentRangeRequest resolve_intent_range = 16;
bool RequestUnion::has_resolve_intent_range() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
void RequestUnion::set_has_resolve_intent_range() {
  _has_bits_[0] |= 0x00008000u;
}
void RequestUnion::clear_has_resolve_intent_range() {
  _has_bits_[0] &= ~0x00008000u;
}
void RequestUnion::clear_resolve_intent_range() {
  if (resolve_intent_range_ != NULL) resolve_intent_range_->::cockroach::proto::ResolveIntentRangeRequest::Clear();
  clear_has_resolve_intent_range();
}
 const ::cockroach::proto::ResolveIntentRangeRequest& RequestUnion::resolve_intent_range() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.RequestUnion.resolve_intent_range)
  return resolve_intent_range_ != NULL ? *resolve_intent_range_ : *default_instance_->resolve_intent_range_;
}
 ::cockroach::proto::ResolveIntentRangeRequest* RequestUnion::mutable_resolve_intent_range() {
  set_has_resolve_intent_range();
  if (resolve_intent_range_ == NULL) {
    resolve_intent_range_ = new ::cockroach::proto::ResolveIntentRangeRequest;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.proto.RequestUnion.resolve_intent_range)
  return resolve_intent_range_;
}
 ::cockroach::proto::ResolveIntentRangeRequest* RequestUnion::release_resolve_intent_range() {
  clear_has_resolve_intent_range();
  ::cockroach::proto::ResolveIntentRangeRequest* temp = resolve_intent_range_;
  resolve_intent_range_ = NULL;
  return temp;
}
 void RequestUnion::set_allocated_resolve_intent_range(::cockroach::proto::ResolveIntentRangeRequest* resolve_intent_range) {
  delete resolve_intent_range_;
  resolve_intent_range_ = resolve_intent_range;
  if (resolve_intent_range) {
    set_has_resolve_intent_range();
  } else {
    clear_has_resolve_intent_range();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.RequestUnion.resolve_intent_range)
}

// optional .cockroach.proto.MergeRequest merge = 17;
bool RequestUnion::has_merge() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
void RequestUnion::set_has_merge() {
  _has_bits_[0] |= 0x00010000u;
}
void RequestUnion::clear_has_merge() {
  _has_bits_[0] &= ~0x00010000u;
}
void RequestUnion::clear_merge() {
  if (merge_ != NULL) merge_->::cockroach::proto::MergeRequest::Clear();
  clear_has_merge();
}
 const ::cockroach::proto::MergeRequest& RequestUnion::merge() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.RequestUnion.merge)
  return merge_ != NULL ? *merge_ : *default_instance_->merge_;
}
 ::cockroach::proto::MergeRequest* RequestUnion::mutable_merge() {
  set_has_merge();
  if (merge_ == NULL) {
    merge_ = new ::cockroach::proto::MergeRequest;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.proto.RequestUnion.merge)
  return merge_;
}
 ::cockroach::proto::MergeRequest* RequestUnion::release_merge() {
  clear_has_merge();
  ::cockroach::proto::MergeRequest* temp = merge_;
  merge_ = NULL;
  return temp;
}
 void RequestUnion::set_allocated_merge(::cockroach::proto::MergeRequest* merge) {
  delete merge_;
  merge_ = merge;
  if (merge) {
    set_has_merge();
  } else {
    clear_has_merge();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.RequestUnion.merge)
}

// optional .cockroach.proto.TruncateLogRequest truncate_log = 18;
bool RequestUnion::has_truncate_log() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
void RequestUnion::set_has_truncate_log() {
  _has_bits_[0] |= 0x00020000u;
}
void RequestUnion::clear_has_truncate_log() {
  _has_bits_[0] &= ~0x00020000u;
}
void RequestUnion::clear_truncate_log() {
  if (truncate_log_ != NULL) truncate_log_->::cockroach::proto::TruncateLogRequest::Clear();
  clear_has_truncate_log();
}
 const ::cockroach::proto::TruncateLogRequest& RequestUnion::truncate_log() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.RequestUnion.truncate_log)
  return truncate_log_ != NULL ? *truncate_log_ : *default_instance_->truncate_log_;
}
 ::cockroach::proto::TruncateLogRequest* RequestUnion::mutable_truncate_log() {
  set_has_truncate_log();
  if (truncate_log_ == NULL) {
    truncate_log_ = new ::cockroach::proto::TruncateLogRequest;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.proto.RequestUnion.truncate_log)
  return truncate_log_;
}
 ::cockroach::proto::TruncateLogRequest* RequestUnion::release_truncate_log() {
  clear_has_truncate_log();
  ::cockroach::proto::TruncateLogRequest* temp = truncate_log_;
  truncate_log_ = NULL;
  return temp;
}
 void RequestUnion::set_allocated_truncate_log(::cockroach::proto::TruncateLogRequest* truncate_log) {
  delete truncate_log_;
  truncate_log_ = truncate_log;
  if (truncate_log) {
    set_has_truncate_log();
  } else {
    clear_has_truncate_log();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.RequestUnion.truncate_log)
}

// optional .cockroach.proto.LeaderLeaseRequest leader_lease = 19;
bool RequestUnion::has_leader_lease() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
void RequestUnion::set_has_leader_lease() {
  _has_bits_[0] |= 0x00040000u;
}
void RequestUnion::clear_has_leader_lease() {
  _has_bits_[0] &= ~0x00040000u;
}
void RequestUnion::clear_leader_lease() {
  if (leader_lease_ != NULL) leader_lease_->::cockroach::proto::LeaderLeaseRequest::Clear();
  clear_has_leader_lease();
}
 const ::cockroach::proto::LeaderLeaseRequest& RequestUnion::leader_lease() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.RequestUnion.leader_lease)
  return leader_lease_ != NULL ? *leader_lease_ : *default_instance_->leader_lease_;
}
 ::cockroach::proto::LeaderLeaseRequest* RequestUnion::mutable_leader_lease() {
  set_has_leader_lease();
  if (leader_lease_ == NULL) {
    leader_lease_ = new ::cockroach::proto::LeaderLeaseRequest;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.proto.RequestUnion.leader_lease)
  return leader_lease_;
}
 ::cockroach::proto::LeaderLeaseRequest* RequestUnion::release_leader_lease() {
  clear_has_leader_lease();
  ::cockroach::proto::LeaderLeaseRequest* temp = leader_lease_;
  leader_lease_ = NULL;
  return temp;
}
 void RequestUnion::set_allocated_leader_lease(::cockroach::proto::LeaderLeaseRequest* leader_lease) {
  delete leader_lease_;
  leader_lease_ = leader_lease;
  if (leader_lease) {
    set_has_leader_lease();
  } else {
    clear_has_leader_lease();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.RequestUnion.leader_lease)
}

// optional .cockroach.proto.ReverseScanRequest reverse_scan = 20;
bool RequestUnion::has_reverse_scan() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
void RequestUnion::set_has_reverse_scan() {
  _has_bits_[0] |= 0x00080000u;
}
void RequestUnion::clear_has_reverse_scan() {
  _has_bits_[0] &= ~0x00080000u;
}
void RequestUnion::clear_reverse_scan() {
  if (reverse_scan_ != NULL) reverse_scan_->::cockroach::proto::ReverseScanRequest::Clear();
  clear_has_reverse_scan();
}
 const ::cockroach::proto::ReverseScanRequest& RequestUnion::reverse_scan() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.RequestUnion.reverse_scan)
  return reverse_scan_ != NULL ? *reverse_scan_ : *default_instance_->reverse_scan_;
}
 ::cockroach::proto::ReverseScanRequest* RequestUnion::mutable_reverse_scan() {
  set_has_reverse_scan();
  if (reverse_scan_ == NULL) {
    reverse_scan_ = new ::cockroach::proto::ReverseScanRequest;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.proto.RequestUnion.reverse_scan)
  return reverse_scan_;
}
 ::cockroach::proto::ReverseScanRequest* RequestUnion::release_reverse_scan() {
  clear_has_reverse_scan();
  ::cockroach::proto::ReverseScanRequest* temp = reverse_scan_;
  reverse_scan_ = NULL;
  return temp;
}
 void RequestUnion::set_allocated_reverse_scan(::cockroach::proto::ReverseScanRequest* reverse_scan) {
  delete reverse_scan_;
  reverse_scan_ = reverse_scan;
  if (reverse_scan) {
    set_has_reverse_scan();
  } else {
    clear_has_reverse_scan();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.RequestUnion.reverse_scan)
}

// optional .cockroach.proto.NoopRequest noop = 21;
bool RequestUnion::has_noop() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
void RequestUnion::set_has_noop() {
  _has_bits_[0] |= 0x00100000u;
}
void RequestUnion::clear_has_noop() {
  _has_bits_[0] &= ~0x00100000u;
}
void RequestUnion::clear_noop() {
  if (noop_ != NULL) noop_->::cockroach::proto::NoopRequest::Clear();
  clear_has_noop();
}
 const ::cockroach::proto::NoopRequest& RequestUnion::noop() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.RequestUnion.noop)
  return noop_ != NULL ? *noop_ : *default_instance_->noop_;
}
 ::cockroach::proto::NoopRequest* RequestUnion::mutable_noop() {
  set_has_noop();
  if (noop_ == NULL) {
    noop_ = new ::cockroach::proto::NoopRequest;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.proto.RequestUnion.noop)
  return noop_;
}
 ::cockroach::proto::NoopRequest* RequestUnion::release_noop() {
  clear_has_noop();
  ::cockroach::proto::NoopRequest* temp = noop_;
  noop_ = NULL;
  return temp;
}
 void RequestUnion::set_allocated_noop(::cockroach::proto::NoopRequest* noop) {
  delete noop_;
  noop_ = noop;
  if (noop) {
    set_has_noop();
  } else {
    clear_has_noop();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.RequestUnion.noop)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#ifndef _MSC_VER
const int ResponseUnion::kGetFieldNumber;
const int ResponseUnion::kPutFieldNumber;
const int ResponseUnion::kConditionalPutFieldNumber;
const int ResponseUnion::kIncrementFieldNumber;
const int ResponseUnion::kDeleteFieldNumber;
const int ResponseUnion::kDeleteRangeFieldNumber;
const int ResponseUnion::kScanFieldNumber;
const int ResponseUnion::kEndTransactionFieldNumber;
const int ResponseUnion::kAdminSplitFieldNumber;
const int ResponseUnion::kAdminMergeFieldNumber;
const int ResponseUnion::kHeartbeatTxnFieldNumber;
const int ResponseUnion::kGcFieldNumber;
const int ResponseUnion::kPushTxnFieldNumber;
const int ResponseUnion::kRangeLookupFieldNumber;
const int ResponseUnion::kResolveIntentFieldNumber;
const int ResponseUnion::kResolveIntentRangeFieldNumber;
const int ResponseUnion::kMergeFieldNumber;
const int ResponseUnion::kTruncateLogFieldNumber;
const int ResponseUnion::kLeaderLeaseFieldNumber;
const int ResponseUnion::kReverseScanFieldNumber;
const int ResponseUnion::kNoopFieldNumber;
#endif  // !_MSC_VER

ResponseUnion::ResponseUnion()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:cockroach.proto.ResponseUnion)
}

void ResponseUnion::InitAsDefaultInstance() {
  get_ = const_cast< ::cockroach::proto::GetResponse*>(&::cockroach::proto::GetResponse::default_instance());
  put_ = const_cast< ::cockroach::proto::PutResponse*>(&::cockroach::proto::PutResponse::default_instance());
  conditional_put_ = const_cast< ::cockroach::proto::ConditionalPutResponse*>(&::cockroach::proto::ConditionalPutResponse::default_instance());
  increment_ = const_cast< ::cockroach::proto::IncrementResponse*>(&::cockroach::proto::IncrementResponse::default_instance());
  delete__ = const_cast< ::cockroach::proto::DeleteResponse*>(&::cockroach::proto::DeleteResponse::default_instance());
  delete_range_ = const_cast< ::cockroach::proto::DeleteRangeResponse*>(&::cockroach::proto::DeleteRangeResponse::default_instance());
  scan_ = const_cast< ::cockroach::proto::ScanResponse*>(&::cockroach::proto::ScanResponse::default_instance());
  end_transaction_ = const_cast< ::cockroach::proto::EndTransactionResponse*>(&::cockroach::proto::EndTransactionResponse::default_instance());
  admin_split_ = const_cast< ::cockroach::proto::AdminSplitResponse*>(&::cockroach::proto::AdminSplitResponse::default_instance());
  admin_merge_ = const_cast< ::cockroach::proto::AdminMergeResponse*>(&::cockroach::proto::AdminMergeResponse::default_instance());
  heartbeat_txn_ = const_cast< ::cockroach::proto::HeartbeatTxnResponse*>(&::cockroach::proto::HeartbeatTxnResponse::default_instance());
  gc_ = const_cast< ::cockroach::proto::GCResponse*>(&::cockroach::proto::GCResponse::default_instance());
  push_txn_ = const_cast< ::cockroach::proto::PushTxnResponse*>(&::cockroach::proto::PushTxnResponse::default_instance());
  range_lookup_ = const_cast< ::cockroach::proto::RangeLookupResponse*>(&::cockroach::proto::RangeLookupResponse::default_instance());
  resolve_intent_ = const_cast< ::cockroach::proto::ResolveIntentResponse*>(&::cockroach::proto::ResolveIntentResponse::default_instance());
  resolve_intent_range_ = const_cast< ::cockroach::proto::ResolveIntentRangeResponse*>(&::cockroach::proto::ResolveIntentRangeResponse::default_instance());
  merge_ = const_cast< ::cockroach::proto::MergeResponse*>(&::cockroach::proto::MergeResponse::default_instance());
  truncate_log_ = const_cast< ::cockroach::proto::TruncateLogResponse*>(&::cockroach::proto::TruncateLogResponse::default_instance());
  leader_lease_ = const_cast< ::cockroach::proto::LeaderLeaseResponse*>(&::cockroach::proto::LeaderLeaseResponse::default_instance());
  reverse_scan_ = const_cast< ::cockroach::proto::ReverseScanResponse*>(&::cockroach::proto::ReverseScanResponse::default_instance());
  noop_ = const_cast< ::cockroach::proto::NoopResponse*>(&::cockroach::proto::NoopResponse::default_instance());
}

ResponseUnion::ResponseUnion(const ResponseUnion& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:cockroach.proto.ResponseUnion)
}

void ResponseUnion::SharedCtor() {
  _cached_size_ = 0;
  get_ = NULL;
  put_ = NULL;
  conditional_put_ = NULL;
  increment_ = NULL;
  delete__ = NULL;
  delete_range_ = NULL;
  scan_ = NULL;
  end_transaction_ = NULL;
  admin_split_ = NULL;
  admin_merge_ = NULL;
  heartbeat_txn_ = NULL;
  gc_ = NULL;
  push_txn_ = NULL;
  range_lookup_ = NULL;
  resolve_intent_ = NULL;
  resolve_intent_range_ = NULL;
  merge_ = NULL;
  truncate_log_ = NULL;
  leader_lease_ = NULL;
  reverse_scan_ = NULL;
  noop_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ResponseUnion::~ResponseUnion() {
  // @@protoc_insertion_point(destructor:cockroach.proto.ResponseUnion)
  SharedDtor();
}

void ResponseUnion::SharedDtor() {
  if (this != default_instance_) {
    delete get_;
    delete put_;
    delete conditional_put_;
    delete increment_;
    delete delete__;
    delete delete_range_;
    delete scan_;
    delete end_transaction_;
    delete admin_split_;
    delete admin_merge_;
    delete heartbeat_txn_;
    delete gc_;
    delete push_txn_;
    delete range_lookup_;
    delete resolve_intent_;
    delete resolve_intent_range_;
    delete merge_;
    delete truncate_log_;
    delete leader_lease_;
    delete reverse_scan_;
    delete noop_;
  }
}

void ResponseUnion::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ResponseUnion::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ResponseUnion_descriptor_;
}

const ResponseUnion& ResponseUnion::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_cockroach_2fproto_2fapi_2eproto();
  return *default_instance_;
}

ResponseUnion* ResponseUnion::default_instance_ = NULL;

ResponseUnion* ResponseUnion::New(::google::protobuf::Arena* arena) const {
  ResponseUnion* n = new ResponseUnion;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void ResponseUnion::Clear() {
  if (_has_bits_[0 / 32] & 255u) {
    if (has_get()) {
      if (get_ != NULL) get_->::cockroach::proto::GetResponse::Clear();
    }
    if (has_put()) {
      if (put_ != NULL) put_->::cockroach::proto::PutResponse::Clear();
    }
    if (has_conditional_put()) {
      if (conditional_put_ != NULL) conditional_put_->::cockroach::proto::ConditionalPutResponse::Clear();
    }
    if (has_increment()) {
      if (increment_ != NULL) increment_->::cockroach::proto::IncrementResponse::Clear();
    }
    if (has_delete_()) {
      if (delete__ != NULL) delete__->::cockroach::proto::DeleteResponse::Clear();
    }
    if (has_delete_range()) {
      if (delete_range_ != NULL) delete_range_->::cockroach::proto::DeleteRangeResponse::Clear();
    }
    if (has_scan()) {
      if (scan_ != NULL) scan_->::cockroach::proto::ScanResponse::Clear();
    }
    if (has_end_transaction()) {
      if (end_transaction_ != NULL) end_transaction_->::cockroach::proto::EndTransactionResponse::Clear();
    }
  }
  if (_has_bits_[8 / 32] & 65280u) {
    if (has_admin_split()) {
      if (admin_split_ != NULL) admin_split_->::cockroach::proto::AdminSplitResponse::Clear();
    }
    if (has_admin_merge()) {
      if (admin_merge_ != NULL) admin_merge_->::cockroach::proto::AdminMergeResponse::Clear();
    }
    if (has_heartbeat_txn()) {
      if (heartbeat_txn_ != NULL) heartbeat_txn_->::cockroach::proto::HeartbeatTxnResponse::Clear();
    }
    if (has_gc()) {
      if (gc_ != NULL) gc_->::cockroach::proto::GCResponse::Clear();
    }
    if (has_push_txn()) {
      if (push_txn_ != NULL) push_txn_->::cockroach::proto::PushTxnResponse::Clear();
    }
    if (has_range_lookup()) {
      if (range_lookup_ != NULL) range_lookup_->::cockroach::proto::RangeLookupResponse::Clear();
    }
    if (has_resolve_intent()) {
      if (resolve_intent_ != NULL) resolve_intent_->::cockroach::proto::ResolveIntentResponse::Clear();
    }
    if (has_resolve_intent_range()) {
      if (resolve_intent_range_ != NULL) resolve_intent_range_->::cockroach::proto::ResolveIntentRangeResponse::Clear();
    }
  }
  if (_has_bits_[16 / 32] & 2031616u) {
    if (has_merge()) {
      if (merge_ != NULL) merge_->::cockroach::proto::MergeResponse::Clear();
    }
    if (has_truncate_log()) {
      if (truncate_log_ != NULL) truncate_log_->::cockroach::proto::TruncateLogResponse::Clear();
    }
    if (has_leader_lease()) {
      if (leader_lease_ != NULL) leader_lease_->::cockroach::proto::LeaderLeaseResponse::Clear();
    }
    if (has_reverse_scan()) {
      if (reverse_scan_ != NULL) reverse_scan_->::cockroach::proto::ReverseScanResponse::Clear();
    }
    if (has_noop()) {
      if (noop_ != NULL) noop_->::cockroach::proto::NoopResponse::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool ResponseUnion::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:cockroach.proto.ResponseUnion)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(16383);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .cockroach.proto.GetResponse get = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_get()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_put;
        break;
      }

      // optional .cockroach.proto.PutResponse put = 2;
      case 2: {
        if (tag == 18) {
         parse_put:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_put()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_conditional_put;
        break;
      }

      // optional .cockroach.proto.ConditionalPutResponse conditional_put = 3;
      case 3: {
        if (tag == 26) {
         parse_conditional_put:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_conditional_put()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_increment;
        break;
      }

      // optional .cockroach.proto.IncrementResponse increment = 4;
      case 4: {
        if (tag == 34) {
         parse_increment:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_increment()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_delete;
        break;
      }

      // optional .cockroach.proto.DeleteResponse delete = 5;
      case 5: {
        if (tag == 42) {
         parse_delete:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_delete_()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(50)) goto parse_delete_range;
        break;
      }

      // optional .cockroach.proto.DeleteRangeResponse delete_range = 6;
      case 6: {
        if (tag == 50) {
         parse_delete_range:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_delete_range()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(58)) goto parse_scan;
        break;
      }

      // optional .cockroach.proto.ScanResponse scan = 7;
      case 7: {
        if (tag == 58) {
         parse_scan:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_scan()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(66)) goto parse_end_transaction;
        break;
      }

      // optional .cockroach.proto.EndTransactionResponse end_transaction = 8;
      case 8: {
        if (tag == 66) {
         parse_end_transaction:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_end_transaction()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(74)) goto parse_admin_split;
        break;
      }

      // optional .cockroach.proto.AdminSplitResponse admin_split = 9;
      case 9: {
        if (tag == 74) {
         parse_admin_split:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_admin_split()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(82)) goto parse_admin_merge;
        break;
      }

      // optional .cockroach.proto.AdminMergeResponse admin_merge = 10;
      case 10: {
        if (tag == 82) {
         parse_admin_merge:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_admin_merge()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(90)) goto parse_heartbeat_txn;
        break;
      }

      // optional .cockroach.proto.HeartbeatTxnResponse heartbeat_txn = 11;
      case 11: {
        if (tag == 90) {
         parse_heartbeat_txn:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_heartbeat_txn()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(98)) goto parse_gc;
        break;
      }

      // optional .cockroach.proto.GCResponse gc = 12;
      case 12: {
        if (tag == 98) {
         parse_gc:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_gc()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(106)) goto parse_push_txn;
        break;
      }

      // optional .cockroach.proto.PushTxnResponse push_txn = 13;
      case 13: {
        if (tag == 106) {
         parse_push_txn:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_push_txn()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(114)) goto parse_range_lookup;
        break;
      }

      // optional .cockroach.proto.RangeLookupResponse range_lookup = 14;
      case 14: {
        if (tag == 114) {
         parse_range_lookup:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_range_lookup()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(122)) goto parse_resolve_intent;
        break;
      }

      // optional .cockroach.proto.ResolveIntentResponse resolve_intent = 15;
      case 15: {
        if (tag == 122) {
         parse_resolve_intent:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_resolve_intent()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(130)) goto parse_resolve_intent_range;
        break;
      }

      // optional .cockroach.proto.ResolveIntentRangeResponse resolve_intent_range = 16;
      case 16: {
        if (tag == 130) {
         parse_resolve_intent_range:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_resolve_intent_range()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(138)) goto parse_merge;
        break;
      }

      // optional .cockroach.proto.MergeResponse merge = 17;
      case 17: {
        if (tag == 138) {
         parse_merge:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_merge()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(146)) goto parse_truncate_log;
        break;
      }

      // optional .cockroach.proto.TruncateLogResponse truncate_log = 18;
      case 18: {
        if (tag == 146) {
         parse_truncate_log:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_truncate_log()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(154)) goto parse_leader_lease;
        break;
      }

      // optional .cockroach.proto.LeaderLeaseResponse leader_lease = 19;
      case 19: {
        if (tag == 154) {
         parse_leader_lease:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_leader_lease()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(162)) goto parse_reverse_scan;
        break;
      }

      // optional .cockroach.proto.ReverseScanResponse reverse_scan = 20;
      case 20: {
        if (tag == 162) {
         parse_reverse_scan:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_reverse_scan()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(170)) goto parse_noop;
        break;
      }

      // optional .cockroach.proto.NoopResponse noop = 21;
      case 21: {
        if (tag == 170) {
         parse_noop:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_noop()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:cockroach.proto.ResponseUnion)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:cockroach.proto.ResponseUnion)
  return false;
#undef DO_
}

void ResponseUnion::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:cockroach.proto.ResponseUnion)
  // optional .cockroach.proto.GetResponse get = 1;
  if (has_get()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->get_, output);
  }

  // optional .cockroach.proto.PutResponse put = 2;
  if (has_put()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, *this->put_, output);
  }

  // optional .cockroach.proto.ConditionalPutResponse conditional_put = 3;
  if (has_conditional_put()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, *this->conditional_put_, output);
  }

  // optional .cockroach.proto.IncrementResponse increment = 4;
  if (has_increment()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, *this->increment_, output);
  }

  // optional .cockroach.proto.DeleteResponse delete = 5;
  if (has_delete_()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      5, *this->delete__, output);
  }

  // optional .cockroach.proto.DeleteRangeResponse delete_range = 6;
  if (has_delete_range()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      6, *this->delete_range_, output);
  }

  // optional .cockroach.proto.ScanResponse scan = 7;
  if (has_scan()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      7, *this->scan_, output);
  }

  // optional .cockroach.proto.EndTransactionResponse end_transaction = 8;
  if (has_end_transaction()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      8, *this->end_transaction_, output);
  }

  // optional .cockroach.proto.AdminSplitResponse admin_split = 9;
  if (has_admin_split()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      9, *this->admin_split_, output);
  }

  // optional .cockroach.proto.AdminMergeResponse admin_merge = 10;
  if (has_admin_merge()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      10, *this->admin_merge_, output);
  }

  // optional .cockroach.proto.HeartbeatTxnResponse heartbeat_txn = 11;
  if (has_heartbeat_txn()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      11, *this->heartbeat_txn_, output);
  }

  // optional .cockroach.proto.GCResponse gc = 12;
  if (has_gc()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      12, *this->gc_, output);
  }

  // optional .cockroach.proto.PushTxnResponse push_txn = 13;
  if (has_push_txn()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      13, *this->push_txn_, output);
  }

  // optional .cockroach.proto.RangeLookupResponse range_lookup = 14;
  if (has_range_lookup()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      14, *this->range_lookup_, output);
  }

  // optional .cockroach.proto.ResolveIntentResponse resolve_intent = 15;
  if (has_resolve_intent()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      15, *this->resolve_intent_, output);
  }

  // optional .cockroach.proto.ResolveIntentRangeResponse resolve_intent_range = 16;
  if (has_resolve_intent_range()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      16, *this->resolve_intent_range_, output);
  }

  // optional .cockroach.proto.MergeResponse merge = 17;
  if (has_merge()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      17, *this->merge_, output);
  }

  // optional .cockroach.proto.TruncateLogResponse truncate_log = 18;
  if (has_truncate_log()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      18, *this->truncate_log_, output);
  }

  // optional .cockroach.proto.LeaderLeaseResponse leader_lease = 19;
  if (has_leader_lease()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      19, *this->leader_lease_, output);
  }

  // optional .cockroach.proto.ReverseScanResponse reverse_scan = 20;
  if (has_reverse_scan()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      20, *this->reverse_scan_, output);
  }

  // optional .cockroach.proto.NoopResponse noop = 21;
  if (has_noop()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      21, *this->noop_, output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:cockroach.proto.ResponseUnion)
}

::google::protobuf::uint8* ResponseUnion::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:cockroach.proto.ResponseUnion)
  // optional .cockroach.proto.GetResponse get = 1;
  if (has_get()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, *this->get_, target);
  }

  // optional .cockroach.proto.PutResponse put = 2;
  if (has_put()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, *this->put_, target);
  }

  // optional .cockroach.proto.ConditionalPutResponse conditional_put = 3;
  if (has_conditional_put()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, *this->conditional_put_, target);
  }

  // optional .cockroach.proto.IncrementResponse increment = 4;
  if (has_increment()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        4, *this->increment_, target);
  }

  // optional .cockroach.proto.DeleteResponse delete = 5;
  if (has_delete_()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        5, *this->delete__, target);
  }

  // optional .cockroach.proto.DeleteRangeResponse delete_range = 6;
  if (has_delete_range()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        6, *this->delete_range_, target);
  }

  // optional .cockroach.proto.ScanResponse scan = 7;
  if (has_scan()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        7, *this->scan_, target);
  }

  // optional .cockroach.proto.EndTransactionResponse end_transaction = 8;
  if (has_end_transaction()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        8, *this->end_transaction_, target);
  }

  // optional .cockroach.proto.AdminSplitResponse admin_split = 9;
  if (has_admin_split()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        9, *this->admin_split_, target);
  }

  // optional .cockroach.proto.AdminMergeResponse admin_merge = 10;
  if (has_admin_merge()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        10, *this->admin_merge_, target);
  }

  // optional .cockroach.proto.HeartbeatTxnResponse heartbeat_txn = 11;
  if (has_heartbeat_txn()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        11, *this->heartbeat_txn_, target);
  }

  // optional .cockroach.proto.GCResponse gc = 12;
  if (has_gc()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        12, *this->gc_, target);
  }

  // optional .cockroach.proto.PushTxnResponse push_txn = 13;
  if (has_push_txn()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        13, *this->push_txn_, target);
  }

  // optional .cockroach.proto.RangeLookupResponse range_lookup = 14;
  if (has_range_lookup()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        14, *this->range_lookup_, target);
  }

  // optional .cockroach.proto.ResolveIntentResponse resolve_intent = 15;
  if (has_resolve_intent()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        15, *this->resolve_intent_, target);
  }

  // optional .cockroach.proto.ResolveIntentRangeResponse resolve_intent_range = 16;
  if (has_resolve_intent_range()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        16, *this->resolve_intent_range_, target);
  }

  // optional .cockroach.proto.MergeResponse merge = 17;
  if (has_merge()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        17, *this->merge_, target);
  }

  // optional .cockroach.proto.TruncateLogResponse truncate_log = 18;
  if (has_truncate_log()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        18, *this->truncate_log_, target);
  }

  // optional .cockroach.proto.LeaderLeaseResponse leader_lease = 19;
  if (has_leader_lease()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        19, *this->leader_lease_, target);
  }

  // optional .cockroach.proto.ReverseScanResponse reverse_scan = 20;
  if (has_reverse_scan()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        20, *this->reverse_scan_, target);
  }

  // optional .cockroach.proto.NoopResponse noop = 21;
  if (has_noop()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        21, *this->noop_, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:cockroach.proto.ResponseUnion)
  return target;
}

int ResponseUnion::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & 255) {
    // optional .cockroach.proto.GetResponse get = 1;
    if (has_get()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->get_);
    }

    // optional .cockroach.proto.PutResponse put = 2;
    if (has_put()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->put_);
    }

    // optional .cockroach.proto.ConditionalPutResponse conditional_put = 3;
    if (has_conditional_put()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->conditional_put_);
    }

    // optional .cockroach.proto.IncrementResponse increment = 4;
    if (has_increment()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->increment_);
    }

    // optional .cockroach.proto.DeleteResponse delete = 5;
    if (has_delete_()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->delete__);
    }

    // optional .cockroach.proto.DeleteRangeResponse delete_range = 6;
    if (has_delete_range()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->delete_range_);
    }

    // optional .cockroach.proto.ScanResponse scan = 7;
    if (has_scan()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->scan_);
    }

    // optional .cockroach.proto.EndTransactionResponse end_transaction = 8;
    if (has_end_transaction()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->end_transaction_);
    }

  }
  if (_has_bits_[8 / 32] & 65280) {
    // optional .cockroach.proto.AdminSplitResponse admin_split = 9;
    if (has_admin_split()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->admin_split_);
    }

    // optional .cockroach.proto.AdminMergeResponse admin_merge = 10;
    if (has_admin_merge()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->admin_merge_);
    }

    // optional .cockroach.proto.HeartbeatTxnResponse heartbeat_txn = 11;
    if (has_heartbeat_txn()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->heartbeat_txn_);
    }

    // optional .cockroach.proto.GCResponse gc = 12;
    if (has_gc()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->gc_);
    }

    // optional .cockroach.proto.PushTxnResponse push_txn = 13;
    if (has_push_txn()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->push_txn_);
    }

    // optional .cockroach.proto.RangeLookupResponse range_lookup = 14;
    if (has_range_lookup()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->range_lookup_);
    }

    // optional .cockroach.proto.ResolveIntentResponse resolve_intent = 15;
    if (has_resolve_intent()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->resolve_intent_);
    }

    // optional .cockroach.proto.ResolveIntentRangeResponse resolve_intent_range = 16;
    if (has_resolve_intent_range()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->resolve_intent_range_);
    }

  }
  if (_has_bits_[16 / 32] & 2031616) {
    // optional .cockroach.proto.MergeResponse merge = 17;
    if (has_merge()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->merge_);
    }

    // optional .cockroach.proto.TruncateLogResponse truncate_log = 18;
    if (has_truncate_log()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->truncate_log_);
    }

    // optional .cockroach.proto.LeaderLeaseResponse leader_lease = 19;
    if (has_leader_lease()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->leader_lease_);
    }

    // optional .cockroach.proto.ReverseScanResponse reverse_scan = 20;
    if (has_reverse_scan()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->reverse_scan_);
    }

    // optional .cockroach.proto.NoopResponse noop = 21;
    if (has_noop()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->noop_);
    }

  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ResponseUnion::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const ResponseUnion* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const ResponseUnion>(
          &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ResponseUnion::MergeFrom(const ResponseUnion& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_get()) {
      mutable_get()->::cockroach::proto::GetResponse::MergeFrom(from.get());
    }
    if (from.has_put()) {
      mutable_put()->::cockroach::proto::PutResponse::MergeFrom(from.put());
    }
    if (from.has_conditional_put()) {
      mutable_conditional_put()->::cockroach::proto::ConditionalPutResponse::MergeFrom(from.conditional_put());
    }
    if (from.has_increment()) {
      mutable_increment()->::cockroach::proto::IncrementResponse::MergeFrom(from.increment());
    }
    if (from.has_delete_()) {
      mutable_delete_()->::cockroach::proto::DeleteResponse::MergeFrom(from.delete_());
    }
    if (from.has_delete_range()) {
      mutable_delete_range()->::cockroach::proto::DeleteRangeResponse::MergeFrom(from.delete_range());
    }
    if (from.has_scan()) {
      mutable_scan()->::cockroach::proto::ScanResponse::MergeFrom(from.scan());
    }
    if (from.has_end_transaction()) {
      mutable_end_transaction()->::cockroach::proto::EndTransactionResponse::MergeFrom(from.end_transaction());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_admin_split()) {
      mutable_admin_split()->::cockroach::proto::AdminSplitResponse::MergeFrom(from.admin_split());
    }
    if (from.has_admin_merge()) {
      mutable_admin_merge()->::cockroach::proto::AdminMergeResponse::MergeFrom(from.admin_merge());
    }
    if (from.has_heartbeat_txn()) {
      mutable_heartbeat_txn()->::cockroach::proto::HeartbeatTxnResponse::MergeFrom(from.heartbeat_txn());
    }
    if (from.has_gc()) {
      mutable_gc()->::cockroach::proto::GCResponse::MergeFrom(from.gc());
    }
    if (from.has_push_txn()) {
      mutable_push_txn()->::cockroach::proto::PushTxnResponse::MergeFrom(from.push_txn());
    }
    if (from.has_range_lookup()) {
      mutable_range_lookup()->::cockroach::proto::RangeLookupResponse::MergeFrom(from.range_lookup());
    }
    if (from.has_resolve_intent()) {
      mutable_resolve_intent()->::cockroach::proto::ResolveIntentResponse::MergeFrom(from.resolve_intent());
    }
    if (from.has_resolve_intent_range()) {
      mutable_resolve_intent_range()->::cockroach::proto::ResolveIntentRangeResponse::MergeFrom(from.resolve_intent_range());
    }
  }
  if (from._has_bits_[16 / 32] & (0xffu << (16 % 32))) {
    if (from.has_merge()) {
      mutable_merge()->::cockroach::proto::MergeResponse::MergeFrom(from.merge());
    }
    if (from.has_truncate_log()) {
      mutable_truncate_log()->::cockroach::proto::TruncateLogResponse::MergeFrom(from.truncate_log());
    }
    if (from.has_leader_lease()) {
      mutable_leader_lease()->::cockroach::proto::LeaderLeaseResponse::MergeFrom(from.leader_lease());
    }
    if (from.has_reverse_scan()) {
      mutable_reverse_scan()->::cockroach::proto::ReverseScanResponse::MergeFrom(from.reverse_scan());
    }
    if (from.has_noop()) {
      mutable_noop()->::cockroach::proto::NoopResponse::MergeFrom(from.noop());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void ResponseUnion::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ResponseUnion::CopyFrom(const ResponseUnion& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ResponseUnion::IsInitialized() const {

  return true;
}

void ResponseUnion::Swap(ResponseUnion* other) {
  if (other == this) return;
  InternalSwap(other);
}
void ResponseUnion::InternalSwap(ResponseUnion* other) {
  std::swap(get_, other->get_);
  std::swap(put_, other->put_);
  std::swap(conditional_put_, other->conditional_put_);
  std::swap(increment_, other->increment_);
  std::swap(delete__, other->delete__);
  std::swap(delete_range_, other->delete_range_);
  std::swap(scan_, other->scan_);
  std::swap(end_transaction_, other->end_transaction_);
  std::swap(admin_split_, other->admin_split_);
  std::swap(admin_merge_, other->admin_merge_);
  std::swap(heartbeat_txn_, other->heartbeat_txn_);
  std::swap(gc_, other->gc_);
  std::swap(push_txn_, other->push_txn_);
  std::swap(range_lookup_, other->range_lookup_);
  std::swap(resolve_intent_, other->resolve_intent_);
  std::swap(resolve_intent_range_, other->resolve_intent_range_);
  std::swap(merge_, other->merge_);
  std::swap(truncate_log_, other->truncate_log_);
  std::swap(leader_lease_, other->leader_lease_);
  std::swap(reverse_scan_, other->reverse_scan_);
  std::swap(noop_, other->noop_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata ResponseUnion::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ResponseUnion_descriptor_;
  metadata.reflection = ResponseUnion_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// ResponseUnion

// optional .cockroach.proto.GetResponse get = 1;
bool ResponseUnion::has_get() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void ResponseUnion::set_has_get() {
  _has_bits_[0] |= 0x00000001u;
}
void ResponseUnion::clear_has_get() {
  _has_bits_[0] &= ~0x00000001u;
}
void ResponseUnion::clear_get() {
  if (get_ != NULL) get_->::cockroach::proto::GetResponse::Clear();
  clear_has_get();
}
 const ::cockroach::proto::GetResponse& ResponseUnion::get() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.ResponseUnion.get)
  return get_ != NULL ? *get_ : *default_instance_->get_;
}
 ::cockroach::proto::GetResponse* ResponseUnion::mutable_get() {
  set_has_get();
  if (get_ == NULL) {
    get_ = new ::cockroach::proto::GetResponse;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.proto.ResponseUnion.get)
  return get_;
}
 ::cockroach::proto::GetResponse* ResponseUnion::release_get() {
  clear_has_get();
  ::cockroach::proto::GetResponse* temp = get_;
  get_ = NULL;
  return temp;
}
 void ResponseUnion::set_allocated_get(::cockroach::proto::GetResponse* get) {
  delete get_;
  get_ = get;
  if (get) {
    set_has_get();
  } else {
    clear_has_get();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.ResponseUnion.get)
}

// optional .cockroach.proto.PutResponse put = 2;
bool ResponseUnion::has_put() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void ResponseUnion::set_has_put() {
  _has_bits_[0] |= 0x00000002u;
}
void ResponseUnion::clear_has_put() {
  _has_bits_[0] &= ~0x00000002u;
}
void ResponseUnion::clear_put() {
  if (put_ != NULL) put_->::cockroach::proto::PutResponse::Clear();
  clear_has_put();
}
 const ::cockroach::proto::PutResponse& ResponseUnion::put() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.ResponseUnion.put)
  return put_ != NULL ? *put_ : *default_instance_->put_;
}
 ::cockroach::proto::PutResponse* ResponseUnion::mutable_put() {
  set_has_put();
  if (put_ == NULL) {
    put_ = new ::cockroach::proto::PutResponse;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.proto.ResponseUnion.put)
  return put_;
}
 ::cockroach::proto::PutResponse* ResponseUnion::release_put() {
  clear_has_put();
  ::cockroach::proto::PutResponse* temp = put_;
  put_ = NULL;
  return temp;
}
 void ResponseUnion::set_allocated_put(::cockroach::proto::PutResponse* put) {
  delete put_;
  put_ = put;
  if (put) {
    set_has_put();
  } else {
    clear_has_put();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.ResponseUnion.put)
}

// optional .cockroach.proto.ConditionalPutResponse conditional_put = 3;
bool ResponseUnion::has_conditional_put() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void ResponseUnion::set_has_conditional_put() {
  _has_bits_[0] |= 0x00000004u;
}
void ResponseUnion::clear_has_conditional_put() {
  _has_bits_[0] &= ~0x00000004u;
}
void ResponseUnion::clear_conditional_put() {
  if (conditional_put_ != NULL) conditional_put_->::cockroach::proto::ConditionalPutResponse::Clear();
  clear_has_conditional_put();
}
 const ::cockroach::proto::ConditionalPutResponse& ResponseUnion::conditional_put() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.ResponseUnion.conditional_put)
  return conditional_put_ != NULL ? *conditional_put_ : *default_instance_->conditional_put_;
}
 ::cockroach::proto::ConditionalPutResponse* ResponseUnion::mutable_conditional_put() {
  set_has_conditional_put();
  if (conditional_put_ == NULL) {
    conditional_put_ = new ::cockroach::proto::ConditionalPutResponse;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.proto.ResponseUnion.conditional_put)
  return conditional_put_;
}
 ::cockroach::proto::ConditionalPutResponse* ResponseUnion::release_conditional_put() {
  clear_has_conditional_put();
  ::cockroach::proto::ConditionalPutResponse* temp = conditional_put_;
  conditional_put_ = NULL;
  return temp;
}
 void ResponseUnion::set_allocated_conditional_put(::cockroach::proto::ConditionalPutResponse* conditional_put) {
  delete conditional_put_;
  conditional_put_ = conditional_put;
  if (conditional_put) {
    set_has_conditional_put();
  } else {
    clear_has_conditional_put();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.ResponseUnion.conditional_put)
}

// optional .cockroach.proto.IncrementResponse increment = 4;
bool ResponseUnion::has_increment() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void ResponseUnion::set_has_increment() {
  _has_bits_[0] |= 0x00000008u;
}
void ResponseUnion::clear_has_increment() {
  _has_bits_[0] &= ~0x00000008u;
}
void ResponseUnion::clear_increment() {
  if (increment_ != NULL) increment_->::cockroach::proto::IncrementResponse::Clear();
  clear_has_increment();
}
 const ::cockroach::proto::IncrementResponse& ResponseUnion::increment() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.ResponseUnion.increment)
  return increment_ != NULL ? *increment_ : *default_instance_->increment_;
}
 ::cockroach::proto::IncrementResponse* ResponseUnion::mutable_increment() {
  set_has_increment();
  if (increment_ == NULL) {
    increment_ = new ::cockroach::proto::IncrementResponse;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.proto.ResponseUnion.increment)
  return increment_;
}
 ::cockroach::proto::IncrementResponse* ResponseUnion::release_increment() {
  clear_has_increment();
  ::cockroach::proto::IncrementResponse* temp = increment_;
  increment_ = NULL;
  return temp;
}
 void ResponseUnion::set_allocated_increment(::cockroach::proto::IncrementResponse* increment) {
  delete increment_;
  increment_ = increment;
  if (increment) {
    set_has_increment();
  } else {
    clear_has_increment();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.ResponseUnion.increment)
}

// optional .cockroach.proto.DeleteResponse delete = 5;
bool ResponseUnion::has_delete_() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
void ResponseUnion::set_has_delete_() {
  _has_bits_[0] |= 0x00000010u;
}
void ResponseUnion::clear_has_delete_() {
  _has_bits_[0] &= ~0x00000010u;
}
void ResponseUnion::clear_delete_() {
  if (delete__ != NULL) delete__->::cockroach::proto::DeleteResponse::Clear();
  clear_has_delete_();
}
 const ::cockroach::proto::DeleteResponse& ResponseUnion::delete_() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.ResponseUnion.delete)
  return delete__ != NULL ? *delete__ : *default_instance_->delete__;
}
 ::cockroach::proto::DeleteResponse* ResponseUnion::mutable_delete_() {
  set_has_delete_();
  if (delete__ == NULL) {
    delete__ = new ::cockroach::proto::DeleteResponse;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.proto.ResponseUnion.delete)
  return delete__;
}
 ::cockroach::proto::DeleteResponse* ResponseUnion::release_delete_() {
  clear_has_delete_();
  ::cockroach::proto::DeleteResponse* temp = delete__;
  delete__ = NULL;
  return temp;
}
 void ResponseUnion::set_allocated_delete_(::cockroach::proto::DeleteResponse* delete_) {
  delete delete__;
  delete__ = delete_;
  if (delete_) {
    set_has_delete_();
  } else {
    clear_has_delete_();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.ResponseUnion.delete)
}

// optional .cockroach.proto.DeleteRangeResponse delete_range = 6;
bool ResponseUnion::has_delete_range() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
void ResponseUnion::set_has_delete_range() {
  _has_bits_[0] |= 0x00000020u;
}
void ResponseUnion::clear_has_delete_range() {
  _has_bits_[0] &= ~0x00000020u;
}
void ResponseUnion::clear_delete_range() {
  if (delete_range_ != NULL) delete_range_->::cockroach::proto::DeleteRangeResponse::Clear();
  clear_has_delete_range();
}
 const ::cockroach::proto::DeleteRangeResponse& ResponseUnion::delete_range() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.ResponseUnion.delete_range)
  return delete_range_ != NULL ? *delete_range_ : *default_instance_->delete_range_;
}
 ::cockroach::proto::DeleteRangeResponse* ResponseUnion::mutable_delete_range() {
  set_has_delete_range();
  if (delete_range_ == NULL) {
    delete_range_ = new ::cockroach::proto::DeleteRangeResponse;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.proto.ResponseUnion.delete_range)
  return delete_range_;
}
 ::cockroach::proto::DeleteRangeResponse* ResponseUnion::release_delete_range() {
  clear_has_delete_range();
  ::cockroach::proto::DeleteRangeResponse* temp = delete_range_;
  delete_range_ = NULL;
  return temp;
}
 void ResponseUnion::set_allocated_delete_range(::cockroach::proto::DeleteRangeResponse* delete_range) {
  delete delete_range_;
  delete_range_ = delete_range;
  if (delete_range) {
    set_has_delete_range();
  } else {
    clear_has_delete_range();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.ResponseUnion.delete_range)
}

// optional .cockroach.proto.ScanResponse scan = 7;
bool ResponseUnion::has_scan() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
void ResponseUnion::set_has_scan() {
  _has_bits_[0] |= 0x00000040u;
}
void ResponseUnion::clear_has_scan() {
  _has_bits_[0] &= ~0x00000040u;
}
void ResponseUnion::clear_scan() {
  if (scan_ != NULL) scan_->::cockroach::proto::ScanResponse::Clear();
  clear_has_scan();
}
 const ::cockroach::proto::ScanResponse& ResponseUnion::scan() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.ResponseUnion.scan)
  return scan_ != NULL ? *scan_ : *default_instance_->scan_;
}
 ::cockroach::proto::ScanResponse* ResponseUnion::mutable_scan() {
  set_has_scan();
  if (scan_ == NULL) {
    scan_ = new ::cockroach::proto::ScanResponse;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.proto.ResponseUnion.scan)
  return scan_;
}
 ::cockroach::proto::ScanResponse* ResponseUnion::release_scan() {
  clear_has_scan();
  ::cockroach::proto::ScanResponse* temp = scan_;
  scan_ = NULL;
  return temp;
}
 void ResponseUnion::set_allocated_scan(::cockroach::proto::ScanResponse* scan) {
  delete scan_;
  scan_ = scan;
  if (scan) {
    set_has_scan();
  } else {
    clear_has_scan();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.ResponseUnion.scan)
}

// optional .cockroach.proto.EndTransactionResponse end_transaction = 8;
bool ResponseUnion::has_end_transaction() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
void ResponseUnion::set_has_end_transaction() {
  _has_bits_[0] |= 0x00000080u;
}
void ResponseUnion::clear_has_end_transaction() {
  _has_bits_[0] &= ~0x00000080u;
}
void ResponseUnion::clear_end_transaction() {
  if (end_transaction_ != NULL) end_transaction_->::cockroach::proto::EndTransactionResponse::Clear();
  clear_has_end_transaction();
}
 const ::cockroach::proto::EndTransactionResponse& ResponseUnion::end_transaction() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.ResponseUnion.end_transaction)
  return end_transaction_ != NULL ? *end_transaction_ : *default_instance_->end_transaction_;
}
 ::cockroach::proto::EndTransactionResponse* ResponseUnion::mutable_end_transaction() {
  set_has_end_transaction();
  if (end_transaction_ == NULL) {
    end_transaction_ = new ::cockroach::proto::EndTransactionResponse;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.proto.ResponseUnion.end_transaction)
  return end_transaction_;
}
 ::cockroach::proto::EndTransactionResponse* ResponseUnion::release_end_transaction() {
  clear_has_end_transaction();
  ::cockroach::proto::EndTransactionResponse* temp = end_transaction_;
  end_transaction_ = NULL;
  return temp;
}
 void ResponseUnion::set_allocated_end_transaction(::cockroach::proto::EndTransactionResponse* end_transaction) {
  delete end_transaction_;
  end_transaction_ = end_transaction;
  if (end_transaction) {
    set_has_end_transaction();
  } else {
    clear_has_end_transaction();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.ResponseUnion.end_transaction)
}

// optional .cockroach.proto.AdminSplitResponse admin_split = 9;
bool ResponseUnion::has_admin_split() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
void ResponseUnion::set_has_admin_split() {
  _has_bits_[0] |= 0x00000100u;
}
void ResponseUnion::clear_has_admin_split() {
  _has_bits_[0] &= ~0x00000100u;
}
void ResponseUnion::clear_admin_split() {
  if (admin_split_ != NULL) admin_split_->::cockroach::proto::AdminSplitResponse::Clear();
  clear_has_admin_split();
}
 const ::cockroach::proto::AdminSplitResponse& ResponseUnion::admin_split() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.ResponseUnion.admin_split)
  return admin_split_ != NULL ? *admin_split_ : *default_instance_->admin_split_;
}
 ::cockroach::proto::AdminSplitResponse* ResponseUnion::mutable_admin_split() {
  set_has_admin_split();
  if (admin_split_ == NULL) {
    admin_split_ = new ::cockroach::proto::AdminSplitResponse;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.proto.ResponseUnion.admin_split)
  return admin_split_;
}
 ::cockroach::proto::AdminSplitResponse* ResponseUnion::release_admin_split() {
  clear_has_admin_split();
  ::cockroach::proto::AdminSplitResponse* temp = admin_split_;
  admin_split_ = NULL;
  return temp;
}
 void ResponseUnion::set_allocated_admin_split(::cockroach::proto::AdminSplitResponse* admin_split) {
  delete admin_split_;
  admin_split_ = admin_split;
  if (admin_split) {
    set_has_admin_split();
  } else {
    clear_has_admin_split();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.ResponseUnion.admin_split)
}

// optional .cockroach.proto.AdminMergeResponse admin_merge = 10;
bool ResponseUnion::has_admin_merge() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
void ResponseUnion::set_has_admin_merge() {
  _has_bits_[0] |= 0x00000200u;
}
void ResponseUnion::clear_has_admin_merge() {
  _has_bits_[0] &= ~0x00000200u;
}
void ResponseUnion::clear_admin_merge() {
  if (admin_merge_ != NULL) admin_merge_->::cockroach::proto::AdminMergeResponse::Clear();
  clear_has_admin_merge();
}
 const ::cockroach::proto::AdminMergeResponse& ResponseUnion::admin_merge() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.ResponseUnion.admin_merge)
  return admin_merge_ != NULL ? *admin_merge_ : *default_instance_->admin_merge_;
}
 ::cockroach::proto::AdminMergeResponse* ResponseUnion::mutable_admin_merge() {
  set_has_admin_merge();
  if (admin_merge_ == NULL) {
    admin_merge_ = new ::cockroach::proto::AdminMergeResponse;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.proto.ResponseUnion.admin_merge)
  return admin_merge_;
}
 ::cockroach::proto::AdminMergeResponse* ResponseUnion::release_admin_merge() {
  clear_has_admin_merge();
  ::cockroach::proto::AdminMergeResponse* temp = admin_merge_;
  admin_merge_ = NULL;
  return temp;
}
 void ResponseUnion::set_allocated_admin_merge(::cockroach::proto::AdminMergeResponse* admin_merge) {
  delete admin_merge_;
  admin_merge_ = admin_merge;
  if (admin_merge) {
    set_has_admin_merge();
  } else {
    clear_has_admin_merge();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.ResponseUnion.admin_merge)
}

// optional .cockroach.proto.HeartbeatTxnResponse heartbeat_txn = 11;
bool ResponseUnion::has_heartbeat_txn() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
void ResponseUnion::set_has_heartbeat_txn() {
  _has_bits_[0] |= 0x00000400u;
}
void ResponseUnion::clear_has_heartbeat_txn() {
  _has_bits_[0] &= ~0x00000400u;
}
void ResponseUnion::clear_heartbeat_txn() {
  if (heartbeat_txn_ != NULL) heartbeat_txn_->::cockroach::proto::HeartbeatTxnResponse::Clear();
  clear_has_heartbeat_txn();
}
 const ::cockroach::proto::HeartbeatTxnResponse& ResponseUnion::heartbeat_txn() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.ResponseUnion.heartbeat_txn)
  return heartbeat_txn_ != NULL ? *heartbeat_txn_ : *default_instance_->heartbeat_txn_;
}
 ::cockroach::proto::HeartbeatTxnResponse* ResponseUnion::mutable_heartbeat_txn() {
  set_has_heartbeat_txn();
  if (heartbeat_txn_ == NULL) {
    heartbeat_txn_ = new ::cockroach::proto::HeartbeatTxnResponse;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.proto.ResponseUnion.heartbeat_txn)
  return heartbeat_txn_;
}
 ::cockroach::proto::HeartbeatTxnResponse* ResponseUnion::release_heartbeat_txn() {
  clear_has_heartbeat_txn();
  ::cockroach::proto::HeartbeatTxnResponse* temp = heartbeat_txn_;
  heartbeat_txn_ = NULL;
  return temp;
}
 void ResponseUnion::set_allocated_heartbeat_txn(::cockroach::proto::HeartbeatTxnResponse* heartbeat_txn) {
  delete heartbeat_txn_;
  heartbeat_txn_ = heartbeat_txn;
  if (heartbeat_txn) {
    set_has_heartbeat_txn();
  } else {
    clear_has_heartbeat_txn();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.ResponseUnion.heartbeat_txn)
}

// optional .cockroach.proto.GCResponse gc = 12;
bool ResponseUnion::has_gc() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
void ResponseUnion::set_has_gc() {
  _has_bits_[0] |= 0x00000800u;
}
void ResponseUnion::clear_has_gc() {
  _has_bits_[0] &= ~0x00000800u;
}
void ResponseUnion::clear_gc() {
  if (gc_ != NULL) gc_->::cockroach::proto::GCResponse::Clear();
  clear_has_gc();
}
 const ::cockroach::proto::GCResponse& ResponseUnion::gc() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.ResponseUnion.gc)
  return gc_ != NULL ? *gc_ : *default_instance_->gc_;
}
 ::cockroach::proto::GCResponse* ResponseUnion::mutable_gc() {
  set_has_gc();
  if (gc_ == NULL) {
    gc_ = new ::cockroach::proto::GCResponse;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.proto.ResponseUnion.gc)
  return gc_;
}
 ::cockroach::proto::GCResponse* ResponseUnion::release_gc() {
  clear_has_gc();
  ::cockroach::proto::GCResponse* temp = gc_;
  gc_ = NULL;
  return temp;
}
 void ResponseUnion::set_allocated_gc(::cockroach::proto::GCResponse* gc) {
  delete gc_;
  gc_ = gc;
  if (gc) {
    set_has_gc();
  } else {
    clear_has_gc();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.ResponseUnion.gc)
}

// optional .cockroach.proto.PushTxnResponse push_txn = 13;
bool ResponseUnion::has_push_txn() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
void ResponseUnion::set_has_push_txn() {
  _has_bits_[0] |= 0x00001000u;
}
void ResponseUnion::clear_has_push_txn() {
  _has_bits_[0] &= ~0x00001000u;
}
void ResponseUnion::clear_push_txn() {
  if (push_txn_ != NULL) push_txn_->::cockroach::proto::PushTxnResponse::Clear();
  clear_has_push_txn();
}
 const ::cockroach::proto::PushTxnResponse& ResponseUnion::push_txn() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.ResponseUnion.push_txn)
  return push_txn_ != NULL ? *push_txn_ : *default_instance_->push_txn_;
}
 ::cockroach::proto::PushTxnResponse* ResponseUnion::mutable_push_txn() {
  set_has_push_txn();
  if (push_txn_ == NULL) {
    push_txn_ = new ::cockroach::proto::PushTxnResponse;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.proto.ResponseUnion.push_txn)
  return push_txn_;
}
 ::cockroach::proto::PushTxnResponse* ResponseUnion::release_push_txn() {
  clear_has_push_txn();
  ::cockroach::proto::PushTxnResponse* temp = push_txn_;
  push_txn_ = NULL;
  return temp;
}
 void ResponseUnion::set_allocated_push_txn(::cockroach::proto::PushTxnResponse* push_txn) {
  delete push_txn_;
  push_txn_ = push_txn;
  if (push_txn) {
    set_has_push_txn();
  } else {
    clear_has_push_txn();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.ResponseUnion.push_txn)
}

// optional .cockroach.proto.RangeLookupResponse range_lookup = 14;
bool ResponseUnion::has_range_lookup() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
void ResponseUnion::set_has_range_lookup() {
  _has_bits_[0] |= 0x00002000u;
}
void ResponseUnion::clear_has_range_lookup() {
  _has_bits_[0] &= ~0x00002000u;
}
void ResponseUnion::clear_range_lookup() {
  if (range_lookup_ != NULL) range_lookup_->::cockroach::proto::RangeLookupResponse::Clear();
  clear_has_range_lookup();
}
 const ::cockroach::proto::RangeLookupResponse& ResponseUnion::range_lookup() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.ResponseUnion.range_lookup)
  return range_lookup_ != NULL ? *range_lookup_ : *default_instance_->range_lookup_;
}
 ::cockroach::proto::RangeLookupResponse* ResponseUnion::mutable_range_lookup() {
  set_has_range_lookup();
  if (range_lookup_ == NULL) {
    range_lookup_ = new ::cockroach::proto::RangeLookupResponse;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.proto.ResponseUnion.range_lookup)
  return range_lookup_;
}
 ::cockroach::proto::RangeLookupResponse* ResponseUnion::release_range_lookup() {
  clear_has_range_lookup();
  ::cockroach::proto::RangeLookupResponse* temp = range_lookup_;
  range_lookup_ = NULL;
  return temp;
}
 void ResponseUnion::set_allocated_range_lookup(::cockroach::proto::RangeLookupResponse* range_lookup) {
  delete range_lookup_;
  range_lookup_ = range_lookup;
  if (range_lookup) {
    set_has_range_lookup();
  } else {
    clear_has_range_lookup();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.ResponseUnion.range_lookup)
}

// optional .cockroach.proto.ResolveIntentResponse resolve_intent = 15;
bool ResponseUnion::has_resolve_intent() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
void ResponseUnion::set_has_resolve_intent() {
  _has_bits_[0] |= 0x00004000u;
}
void ResponseUnion::clear_has_resolve_intent() {
  _has_bits_[0] &= ~0x00004000u;
}
void ResponseUnion::clear_resolve_intent() {
  if (resolve_intent_ != NULL) resolve_intent_->::cockroach::proto::ResolveIntentResponse::Clear();
  clear_has_resolve_intent();
}
 const ::cockroach::proto::ResolveIntentResponse& ResponseUnion::resolve_intent() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.ResponseUnion.resolve_intent)
  return resolve_intent_ != NULL ? *resolve_intent_ : *default_instance_->resolve_intent_;
}
 ::cockroach::proto::ResolveIntentResponse* ResponseUnion::mutable_resolve_intent() {
  set_has_resolve_intent();
  if (resolve_intent_ == NULL) {
    resolve_intent_ = new ::cockroach::proto::ResolveIntentResponse;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.proto.ResponseUnion.resolve_intent)
  return resolve_intent_;
}
 ::cockroach::proto::ResolveIntentResponse* ResponseUnion::release_resolve_intent() {
  clear_has_resolve_intent();
  ::cockroach::proto::ResolveIntentResponse* temp = resolve_intent_;
  resolve_intent_ = NULL;
  return temp;
}
 void ResponseUnion::set_allocated_resolve_intent(::cockroach::proto::ResolveIntentResponse* resolve_intent) {
  delete resolve_intent_;
  resolve_intent_ = resolve_intent;
  if (resolve_intent) {
    set_has_resolve_intent();
  } else {
    clear_has_resolve_intent();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.ResponseUnion.resolve_intent)
}

// optional .cockroach.proto.ResolveIntentRangeResponse resolve_intent_range = 16;
bool ResponseUnion::has_resolve_intent_range() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
void ResponseUnion::set_has_resolve_intent_range() {
  _has_bits_[0] |= 0x00008000u;
}
void ResponseUnion::clear_has_resolve_intent_range() {
  _has_bits_[0] &= ~0x00008000u;
}
void ResponseUnion::clear_resolve_intent_range() {
  if (resolve_intent_range_ != NULL) resolve_intent_range_->::cockroach::proto::ResolveIntentRangeResponse::Clear();
  clear_has_resolve_intent_range();
}
 const ::cockroach::proto::ResolveIntentRangeResponse& ResponseUnion::resolve_intent_range() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.ResponseUnion.resolve_intent_range)
  return resolve_intent_range_ != NULL ? *resolve_intent_range_ : *default_instance_->resolve_intent_range_;
}
 ::cockroach::proto::ResolveIntentRangeResponse* ResponseUnion::mutable_resolve_intent_range() {
  set_has_resolve_intent_range();
  if (resolve_intent_range_ == NULL) {
    resolve_intent_range_ = new ::cockroach::proto::ResolveIntentRangeResponse;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.proto.ResponseUnion.resolve_intent_range)
  return resolve_intent_range_;
}
 ::cockroach::proto::ResolveIntentRangeResponse* ResponseUnion::release_resolve_intent_range() {
  clear_has_resolve_intent_range();
  ::cockroach::proto::ResolveIntentRangeResponse* temp = resolve_intent_range_;
  resolve_intent_range_ = NULL;
  return temp;
}
 void ResponseUnion::set_allocated_resolve_intent_range(::cockroach::proto::ResolveIntentRangeResponse* resolve_intent_range) {
  delete resolve_intent_range_;
  resolve_intent_range_ = resolve_intent_range;
  if (resolve_intent_range) {
    set_has_resolve_intent_range();
  } else {
    clear_has_resolve_intent_range();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.ResponseUnion.resolve_intent_range)
}

// optional .cockroach.proto.MergeResponse merge = 17;
bool ResponseUnion::has_merge() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
void ResponseUnion::set_has_merge() {
  _has_bits_[0] |= 0x00010000u;
}
void ResponseUnion::clear_has_merge() {
  _has_bits_[0] &= ~0x00010000u;
}
void ResponseUnion::clear_merge() {
  if (merge_ != NULL) merge_->::cockroach::proto::MergeResponse::Clear();
  clear_has_merge();
}
 const ::cockroach::proto::MergeResponse& ResponseUnion::merge() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.ResponseUnion.merge)
  return merge_ != NULL ? *merge_ : *default_instance_->merge_;
}
 ::cockroach::proto::MergeResponse* ResponseUnion::mutable_merge() {
  set_has_merge();
  if (merge_ == NULL) {
    merge_ = new ::cockroach::proto::MergeResponse;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.proto.ResponseUnion.merge)
  return merge_;
}
 ::cockroach::proto::MergeResponse* ResponseUnion::release_merge() {
  clear_has_merge();
  ::cockroach::proto::MergeResponse* temp = merge_;
  merge_ = NULL;
  return temp;
}
 void ResponseUnion::set_allocated_merge(::cockroach::proto::MergeResponse* merge) {
  delete merge_;
  merge_ = merge;
  if (merge) {
    set_has_merge();
  } else {
    clear_has_merge();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.ResponseUnion.merge)
}

// optional .cockroach.proto.TruncateLogResponse truncate_log = 18;
bool ResponseUnion::has_truncate_log() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
void ResponseUnion::set_has_truncate_log() {
  _has_bits_[0] |= 0x00020000u;
}
void ResponseUnion::clear_has_truncate_log() {
  _has_bits_[0] &= ~0x00020000u;
}
void ResponseUnion::clear_truncate_log() {
  if (truncate_log_ != NULL) truncate_log_->::cockroach::proto::TruncateLogResponse::Clear();
  clear_has_truncate_log();
}
 const ::cockroach::proto::TruncateLogResponse& ResponseUnion::truncate_log() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.ResponseUnion.truncate_log)
  return truncate_log_ != NULL ? *truncate_log_ : *default_instance_->truncate_log_;
}
 ::cockroach::proto::TruncateLogResponse* ResponseUnion::mutable_truncate_log() {
  set_has_truncate_log();
  if (truncate_log_ == NULL) {
    truncate_log_ = new ::cockroach::proto::TruncateLogResponse;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.proto.ResponseUnion.truncate_log)
  return truncate_log_;
}
 ::cockroach::proto::TruncateLogResponse* ResponseUnion::release_truncate_log() {
  clear_has_truncate_log();
  ::cockroach::proto::TruncateLogResponse* temp = truncate_log_;
  truncate_log_ = NULL;
  return temp;
}
 void ResponseUnion::set_allocated_truncate_log(::cockroach::proto::TruncateLogResponse* truncate_log) {
  delete truncate_log_;
  truncate_log_ = truncate_log;
  if (truncate_log) {
    set_has_truncate_log();
  } else {
    clear_has_truncate_log();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.ResponseUnion.truncate_log)
}

// optional .cockroach.proto.LeaderLeaseResponse leader_lease = 19;
bool ResponseUnion::has_leader_lease() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
void ResponseUnion::set_has_leader_lease() {
  _has_bits_[0] |= 0x00040000u;
}
void ResponseUnion::clear_has_leader_lease() {
  _has_bits_[0] &= ~0x00040000u;
}
void ResponseUnion::clear_leader_lease() {
  if (leader_lease_ != NULL) leader_lease_->::cockroach::proto::LeaderLeaseResponse::Clear();
  clear_has_leader_lease();
}
 const ::cockroach::proto::LeaderLeaseResponse& ResponseUnion::leader_lease() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.ResponseUnion.leader_lease)
  return leader_lease_ != NULL ? *leader_lease_ : *default_instance_->leader_lease_;
}
 ::cockroach::proto::LeaderLeaseResponse* ResponseUnion::mutable_leader_lease() {
  set_has_leader_lease();
  if (leader_lease_ == NULL) {
    leader_lease_ = new ::cockroach::proto::LeaderLeaseResponse;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.proto.ResponseUnion.leader_lease)
  return leader_lease_;
}
 ::cockroach::proto::LeaderLeaseResponse* ResponseUnion::release_leader_lease() {
  clear_has_leader_lease();
  ::cockroach::proto::LeaderLeaseResponse* temp = leader_lease_;
  leader_lease_ = NULL;
  return temp;
}
 void ResponseUnion::set_allocated_leader_lease(::cockroach::proto::LeaderLeaseResponse* leader_lease) {
  delete leader_lease_;
  leader_lease_ = leader_lease;
  if (leader_lease) {
    set_has_leader_lease();
  } else {
    clear_has_leader_lease();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.ResponseUnion.leader_lease)
}

// optional .cockroach.proto.ReverseScanResponse reverse_scan = 20;
bool ResponseUnion::has_reverse_scan() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
void ResponseUnion::set_has_reverse_scan() {
  _has_bits_[0] |= 0x00080000u;
}
void ResponseUnion::clear_has_reverse_scan() {
  _has_bits_[0] &= ~0x00080000u;
}
void ResponseUnion::clear_reverse_scan() {
  if (reverse_scan_ != NULL) reverse_scan_->::cockroach::proto::ReverseScanResponse::Clear();
  clear_has_reverse_scan();
}
 const ::cockroach::proto::ReverseScanResponse& ResponseUnion::reverse_scan() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.ResponseUnion.reverse_scan)
  return reverse_scan_ != NULL ? *reverse_scan_ : *default_instance_->reverse_scan_;
}
 ::cockroach::proto::ReverseScanResponse* ResponseUnion::mutable_reverse_scan() {
  set_has_reverse_scan();
  if (reverse_scan_ == NULL) {
    reverse_scan_ = new ::cockroach::proto::ReverseScanResponse;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.proto.ResponseUnion.reverse_scan)
  return reverse_scan_;
}
 ::cockroach::proto::ReverseScanResponse* ResponseUnion::release_reverse_scan() {
  clear_has_reverse_scan();
  ::cockroach::proto::ReverseScanResponse* temp = reverse_scan_;
  reverse_scan_ = NULL;
  return temp;
}
 void ResponseUnion::set_allocated_reverse_scan(::cockroach::proto::ReverseScanResponse* reverse_scan) {
  delete reverse_scan_;
  reverse_scan_ = reverse_scan;
  if (reverse_scan) {
    set_has_reverse_scan();
  } else {
    clear_has_reverse_scan();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.ResponseUnion.reverse_scan)
}

// optional .cockroach.proto.NoopResponse noop = 21;
bool ResponseUnion::has_noop() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
void ResponseUnion::set_has_noop() {
  _has_bits_[0] |= 0x00100000u;
}
void ResponseUnion::clear_has_noop() {
  _has_bits_[0] &= ~0x00100000u;
}
void ResponseUnion::clear_noop() {
  if (noop_ != NULL) noop_->::cockroach::proto::NoopResponse::Clear();
  clear_has_noop();
}
 const ::cockroach::proto::NoopResponse& ResponseUnion::noop() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.ResponseUnion.noop)
  return noop_ != NULL ? *noop_ : *default_instance_->noop_;
}
 ::cockroach::proto::NoopResponse* ResponseUnion::mutable_noop() {
  set_has_noop();
  if (noop_ == NULL) {
    noop_ = new ::cockroach::proto::NoopResponse;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.proto.ResponseUnion.noop)
  return noop_;
}
 ::cockroach::proto::NoopResponse* ResponseUnion::release_noop() {
  clear_has_noop();
  ::cockroach::proto::NoopResponse* temp = noop_;
  noop_ = NULL;
  return temp;
}
 void ResponseUnion::set_allocated_noop(::cockroach::proto::NoopResponse* noop) {
  delete noop_;
  noop_ = noop;
  if (noop) {
    set_has_noop();
  } else {
    clear_has_noop();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.ResponseUnion.noop)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#ifndef _MSC_VER
const int BatchRequest::kHeaderFieldNumber;
const int BatchRequest::kRequestsFieldNumber;
#endif  // !_MSC_VER

BatchRequest::BatchRequest()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:cockroach.proto.BatchRequest)
}

void BatchRequest::InitAsDefaultInstance() {
  header_ = const_cast< ::cockroach::proto::RequestHeader*>(&::cockroach::proto::RequestHeader::default_instance());
}

BatchRequest::BatchRequest(const BatchRequest& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:cockroach.proto.BatchRequest)
}

void BatchRequest::SharedCtor() {
  _cached_size_ = 0;
  header_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

BatchRequest::~BatchRequest() {
  // @@protoc_insertion_point(destructor:cockroach.proto.BatchRequest)
  SharedDtor();
}

void BatchRequest::SharedDtor() {
  if (this != default_instance_) {
    delete header_;
  }
}

void BatchRequest::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* BatchRequest::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return BatchRequest_descriptor_;
}

const BatchRequest& BatchRequest::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_cockroach_2fproto_2fapi_2eproto();
  return *default_instance_;
}

BatchRequest* BatchRequest::default_instance_ = NULL;

BatchRequest* BatchRequest::New(::google::protobuf::Arena* arena) const {
  BatchRequest* n = new BatchRequest;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void BatchRequest::Clear() {
  if (has_header()) {
    if (header_ != NULL) header_->::cockroach::proto::RequestHeader::Clear();
  }
  requests_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool BatchRequest::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:cockroach.proto.BatchRequest)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .cockroach.proto.RequestHeader header = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_header()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_requests;
        break;
      }

      // repeated .cockroach.proto.RequestUnion requests = 2;
      case 2: {
        if (tag == 18) {
         parse_requests:
          DO_(input->IncrementRecursionDepth());
         parse_loop_requests:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                input, add_requests()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_loop_requests;
        input->UnsafeDecrementRecursionDepth();
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:cockroach.proto.BatchRequest)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:cockroach.proto.BatchRequest)
  return false;
#undef DO_
}

void BatchRequest::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:cockroach.proto.BatchRequest)
  // optional .cockroach.proto.RequestHeader header = 1;
  if (has_header()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->header_, output);
  }

  // repeated .cockroach.proto.RequestUnion requests = 2;
  for (unsigned int i = 0, n = this->requests_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->requests(i), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:cockroach.proto.BatchRequest)
}

::google::protobuf::uint8* BatchRequest::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:cockroach.proto.BatchRequest)
  // optional .cockroach.proto.RequestHeader header = 1;
  if (has_header()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, *this->header_, target);
  }

  // repeated .cockroach.proto.RequestUnion requests = 2;
  for (unsigned int i = 0, n = this->requests_size(); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->requests(i), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:cockroach.proto.BatchRequest)
  return target;
}

int BatchRequest::ByteSize() const {
  int total_size = 0;

  // optional .cockroach.proto.RequestHeader header = 1;
  if (has_header()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->header_);
  }

  // repeated .cockroach.proto.RequestUnion requests = 2;
  total_size += 1 * this->requests_size();
  for (int i = 0; i < this->requests_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->requests(i));
  }

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void BatchRequest::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const BatchRequest* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const BatchRequest>(
          &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void BatchRequest::MergeFrom(const BatchRequest& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  requests_.MergeFrom(from.requests_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_header()) {
      mutable_header()->::cockroach::proto::RequestHeader::MergeFrom(from.header());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void BatchRequest::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void BatchRequest::CopyFrom(const BatchRequest& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BatchRequest::IsInitialized() const {

  return true;
}

void BatchRequest::Swap(BatchRequest* other) {
  if (other == this) return;
  InternalSwap(other);
}
void BatchRequest::InternalSwap(BatchRequest* other) {
  std::swap(header_, other->header_);
  requests_.UnsafeArenaSwap(&other->requests_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata BatchRequest::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = BatchRequest_descriptor_;
  metadata.reflection = BatchRequest_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// BatchRequest

// optional .cockroach.proto.RequestHeader header = 1;
bool BatchRequest::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void BatchRequest::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
void BatchRequest::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
void BatchRequest::clear_header() {
  if (header_ != NULL) header_->::cockroach::proto::RequestHeader::Clear();
  clear_has_header();
}
 const ::cockroach::proto::RequestHeader& BatchRequest::header() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.BatchRequest.header)
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
 ::cockroach::proto::RequestHeader* BatchRequest::mutable_header() {
  set_has_header();
  if (header_ == NULL) {
    header_ = new ::cockroach::proto::RequestHeader;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.proto.BatchRequest.header)
  return header_;
}
 ::cockroach::proto::RequestHeader* BatchRequest::release_header() {
  clear_has_header();
  ::cockroach::proto::RequestHeader* temp = header_;
  header_ = NULL;
  return temp;
}
 void BatchRequest::set_allocated_header(::cockroach::proto::RequestHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.BatchRequest.header)
}

// repeated .cockroach.proto.RequestUnion requests = 2;
int BatchRequest::requests_size() const {
  return requests_.size();
}
void BatchRequest::clear_requests() {
  requests_.Clear();
}
 const ::cockroach::proto::RequestUnion& BatchRequest::requests(int index) const {
  // @@protoc_insertion_point(field_get:cockroach.proto.BatchRequest.requests)
  return requests_.Get(index);
}
 ::cockroach::proto::RequestUnion* BatchRequest::mutable_requests(int index) {
  // @@protoc_insertion_point(field_mutable:cockroach.proto.BatchRequest.requests)
  return requests_.Mutable(index);
}
 ::cockroach::proto::RequestUnion* BatchRequest::add_requests() {
  // @@protoc_insertion_point(field_add:cockroach.proto.BatchRequest.requests)
  return requests_.Add();
}
 const ::google::protobuf::RepeatedPtrField< ::cockroach::proto::RequestUnion >&
BatchRequest::requests() const {
  // @@protoc_insertion_point(field_list:cockroach.proto.BatchRequest.requests)
  return requests_;
}
 ::google::protobuf::RepeatedPtrField< ::cockroach::proto::RequestUnion >*
BatchRequest::mutable_requests() {
  // @@protoc_insertion_point(field_mutable_list:cockroach.proto.BatchRequest.requests)
  return &requests_;
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#ifndef _MSC_VER
const int BatchResponse::kHeaderFieldNumber;
const int BatchResponse::kResponsesFieldNumber;
#endif  // !_MSC_VER

BatchResponse::BatchResponse()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:cockroach.proto.BatchResponse)
}

void BatchResponse::InitAsDefaultInstance() {
  header_ = const_cast< ::cockroach::proto::ResponseHeader*>(&::cockroach::proto::ResponseHeader::default_instance());
}

BatchResponse::BatchResponse(const BatchResponse& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:cockroach.proto.BatchResponse)
}

void BatchResponse::SharedCtor() {
  _cached_size_ = 0;
  header_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

BatchResponse::~BatchResponse() {
  // @@protoc_insertion_point(destructor:cockroach.proto.BatchResponse)
  SharedDtor();
}

void BatchResponse::SharedDtor() {
  if (this != default_instance_) {
    delete header_;
  }
}

void BatchResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* BatchResponse::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return BatchResponse_descriptor_;
}

const BatchResponse& BatchResponse::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_cockroach_2fproto_2fapi_2eproto();
  return *default_instance_;
}

BatchResponse* BatchResponse::default_instance_ = NULL;

BatchResponse* BatchResponse::New(::google::protobuf::Arena* arena) const {
  BatchResponse* n = new BatchResponse;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void BatchResponse::Clear() {
  if (has_header()) {
    if (header_ != NULL) header_->::cockroach::proto::ResponseHeader::Clear();
  }
  responses_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool BatchResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:cockroach.proto.BatchResponse)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .cockroach.proto.ResponseHeader header = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_header()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_responses;
        break;
      }

      // repeated .cockroach.proto.ResponseUnion responses = 2;
      case 2: {
        if (tag == 18) {
         parse_responses:
          DO_(input->IncrementRecursionDepth());
         parse_loop_responses:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                input, add_responses()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_loop_responses;
        input->UnsafeDecrementRecursionDepth();
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:cockroach.proto.BatchResponse)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:cockroach.proto.BatchResponse)
  return false;
#undef DO_
}

void BatchResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:cockroach.proto.BatchResponse)
  // optional .cockroach.proto.ResponseHeader header = 1;
  if (has_header()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->header_, output);
  }

  // repeated .cockroach.proto.ResponseUnion responses = 2;
  for (unsigned int i = 0, n = this->responses_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->responses(i), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:cockroach.proto.BatchResponse)
}

::google::protobuf::uint8* BatchResponse::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:cockroach.proto.BatchResponse)
  // optional .cockroach.proto.ResponseHeader header = 1;
  if (has_header()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, *this->header_, target);
  }

  // repeated .cockroach.proto.ResponseUnion responses = 2;
  for (unsigned int i = 0, n = this->responses_size(); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->responses(i), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:cockroach.proto.BatchResponse)
  return target;
}

int BatchResponse::ByteSize() const {
  int total_size = 0;

  // optional .cockroach.proto.ResponseHeader header = 1;
  if (has_header()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->header_);
  }

  // repeated .cockroach.proto.ResponseUnion responses = 2;
  total_size += 1 * this->responses_size();
  for (int i = 0; i < this->responses_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->responses(i));
  }

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void BatchResponse::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const BatchResponse* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const BatchResponse>(
          &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void BatchResponse::MergeFrom(const BatchResponse& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  responses_.MergeFrom(from.responses_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_header()) {
      mutable_header()->::cockroach::proto::ResponseHeader::MergeFrom(from.header());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void BatchResponse::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void BatchResponse::CopyFrom(const BatchResponse& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BatchResponse::IsInitialized() const {

  return true;
}

void BatchResponse::Swap(BatchResponse* other) {
  if (other == this) return;
  InternalSwap(other);
}
void BatchResponse::InternalSwap(BatchResponse* other) {
  std::swap(header_, other->header_);
  responses_.UnsafeArenaSwap(&other->responses_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata BatchResponse::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = BatchResponse_descriptor_;
  metadata.reflection = BatchResponse_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// BatchResponse

// optional .cockroach.proto.ResponseHeader header = 1;
bool BatchResponse::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void BatchResponse::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
void BatchResponse::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
void BatchResponse::clear_header() {
  if (header_ != NULL) header_->::cockroach::proto::ResponseHeader::Clear();
  clear_has_header();
}
 const ::cockroach::proto::ResponseHeader& BatchResponse::header() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.BatchResponse.header)
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
 ::cockroach::proto::ResponseHeader* BatchResponse::mutable_header() {
  set_has_header();
  if (header_ == NULL) {
    header_ = new ::cockroach::proto::ResponseHeader;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.proto.BatchResponse.header)
  return header_;
}
 ::cockroach::proto::ResponseHeader* BatchResponse::release_header() {
  clear_has_header();
  ::cockroach::proto::ResponseHeader* temp = header_;
  header_ = NULL;
  return temp;
}
 void BatchResponse::set_allocated_header(::cockroach::proto::ResponseHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.BatchResponse.header)
}

// repeated .cockroach.proto.ResponseUnion responses = 2;
int BatchResponse::responses_size() const {
  return responses_.size();
}
void BatchResponse::clear_responses() {
  responses_.Clear();
}
 const ::cockroach::proto::ResponseUnion& BatchResponse::responses(int index) const {
  // @@protoc_insertion_point(field_get:cockroach.proto.BatchResponse.responses)
  return responses_.Get(index);
}
 ::cockroach::proto::ResponseUnion* BatchResponse::mutable_responses(int index) {
  // @@protoc_insertion_point(field_mutable:cockroach.proto.BatchResponse.responses)
  return responses_.Mutable(index);
}
 ::cockroach::proto::ResponseUnion* BatchResponse::add_responses() {
  // @@protoc_insertion_point(field_add:cockroach.proto.BatchResponse.responses)
  return responses_.Add();
}
 const ::google::protobuf::RepeatedPtrField< ::cockroach::proto::ResponseUnion >&
BatchResponse::responses() const {
  // @@protoc_insertion_point(field_list:cockroach.proto.BatchResponse.responses)
  return responses_;
}
 ::google::protobuf::RepeatedPtrField< ::cockroach::proto::ResponseUnion >*
BatchResponse::mutable_responses() {
  // @@protoc_insertion_point(field_mutable_list:cockroach.proto.BatchResponse.responses)
  return &responses_;
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// @@protoc_insertion_point(namespace_scope)

}  // namespace proto
}  // namespace cockroach

// @@protoc_insertion_point(global_scope)
