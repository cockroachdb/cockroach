// Code generated by protoc-gen-gogo.
// source: cockroach/storage/engine/mvcc.proto
// DO NOT EDIT!

/*
	Package engine is a generated protocol buffer package.

	It is generated from these files:
		cockroach/storage/engine/mvcc.proto

	It has these top-level messages:
		MVCCMetadata
		MVCCStats
*/
package engine

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import cockroach_roachpb1 "github.com/cockroachdb/cockroach/roachpb"

// skipping weak import gogoproto "github.com/cockroachdb/gogoproto"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
const _ = proto.GoGoProtoPackageIsVersion1

// MVCCMetadata holds MVCC metadata for a key. Used by storage/engine/mvcc.go.
type MVCCMetadata struct {
	Txn *cockroach_roachpb1.TxnMeta `protobuf:"bytes,1,opt,name=txn" json:"txn,omitempty"`
	// The timestamp of the most recent versioned value if this is a
	// value that may have multiple versions. For values which may have
	// only one version, the data is stored inline (via raw_bytes), and
	// timestamp is set to zero.
	Timestamp cockroach_roachpb1.Timestamp `protobuf:"bytes,2,opt,name=timestamp" json:"timestamp"`
	// Is the most recent value a deletion tombstone?
	Deleted bool `protobuf:"varint,3,opt,name=deleted" json:"deleted"`
	// The size in bytes of the most recent encoded key.
	KeyBytes int64 `protobuf:"varint,4,opt,name=key_bytes,json=keyBytes" json:"key_bytes"`
	// The size in bytes of the most recent versioned value.
	ValBytes int64 `protobuf:"varint,5,opt,name=val_bytes,json=valBytes" json:"val_bytes"`
	// Inline value, used for non-versioned values with zero
	// timestamp. This provides an efficient short circuit of the normal
	// MVCC metadata sentinel and subsequent version rows. If timestamp
	// == (0, 0), then there is only a single MVCC metadata row with
	// value inlined, and with empty timestamp, key_bytes, and
	// val_bytes.
	RawBytes []byte `protobuf:"bytes,6,opt,name=raw_bytes,json=rawBytes" json:"raw_bytes,omitempty"`
	// This provides a measure of protection against replays caused by
	// Raft duplicating merge commands.
	MergeTimestamp *cockroach_roachpb1.Timestamp `protobuf:"bytes,7,opt,name=merge_timestamp,json=mergeTimestamp" json:"merge_timestamp,omitempty"`
}

func (m *MVCCMetadata) Reset()                    { *m = MVCCMetadata{} }
func (m *MVCCMetadata) String() string            { return proto.CompactTextString(m) }
func (*MVCCMetadata) ProtoMessage()               {}
func (*MVCCMetadata) Descriptor() ([]byte, []int) { return fileDescriptorMvcc, []int{0} }

// MVCCStats tracks byte and instance counts for various groups of keys,
// values, or key-value pairs; see the field comments for details.
//
// It also tracks two cumulative ages, namely that of intents and non-live
// (i.e. GC-able) bytes. This computation is intrinsically linked to
// last_update_nanos and is easy to get wrong. Updates happen only once every
// full second, as measured by last_update_nanos/1e9. That is, forward updates
// don't change last_update_nanos until an update at a timestamp which,
// truncated to the second, is ahead of last_update_nanos/1e9. Then, that
// difference in seconds times the base quantity (excluding the currently
// running update) is added to the age. It gets more complicated when data is
// accounted for with a timestamp behind last_update_nanos. In this case, if
// more than a second has passed (computed via truncation above), the ages have
// to be adjusted to account for this late addition. This isn't hard: add the
// new data's base quantity times the (truncated) number of seconds behind.
// Important to keep in mind with those computations is that (x/1e9 - y/1e9)
// does not equal (x-y)/1e9 in most cases.
//
// Note that this struct must be kept at a fixed size by using fixed-size
// encodings for all fields and by making all fields non-nullable. This is
// so that it can predict its own impact on the size of the system-local
// kv-pairs.
type MVCCStats struct {
	// last_update_nanos is a timestamp at which the ages were last
	// updated. See the comment on MVCCStats.
	LastUpdateNanos int64 `protobuf:"fixed64,1,opt,name=last_update_nanos,json=lastUpdateNanos" json:"last_update_nanos"`
	// intent_age is the cumulative age of the tracked intents.
	// See the comment on MVCCStats.
	IntentAge int64 `protobuf:"fixed64,2,opt,name=intent_age,json=intentAge" json:"intent_age"`
	// gc_bytes_age is the cumulative age of the non-live data (i.e.
	// data included in key_bytes and val_bytes, but not live_bytes).
	// See the comment on MVCCStats.
	GCBytesAge int64 `protobuf:"fixed64,3,opt,name=gc_bytes_age,json=gcBytesAge" json:"gc_bytes_age"`
	// live_bytes is the number of bytes stored in keys and values which can in
	// principle be read by means of a Scan or Get, including intents but not
	// deletion tombstones (or their intents). Note that the size of the meta kv
	// pair (which could be explicit or implicit) is included in this.
	// Only the meta kv pair counts for the actual length of the encoded key
	// (regular pairs only count the timestamp suffix).
	LiveBytes int64 `protobuf:"fixed64,4,opt,name=live_bytes,json=liveBytes" json:"live_bytes"`
	// live_count is the number of meta keys tracked under live_bytes.
	LiveCount int64 `protobuf:"fixed64,5,opt,name=live_count,json=liveCount" json:"live_count"`
	// key_bytes is the number of bytes stored in all non-system
	// keys, including live, meta, old, and deleted keys.
	// Only meta keys really account for the "full" key; value
	// keys only for the timestamp suffix.
	KeyBytes int64 `protobuf:"fixed64,6,opt,name=key_bytes,json=keyBytes" json:"key_bytes"`
	// key_count is the number of meta keys tracked under key_bytes.
	KeyCount int64 `protobuf:"fixed64,7,opt,name=key_count,json=keyCount" json:"key_count"`
	// value_bytes is the number of bytes in all non-system version
	// values, including meta values.
	ValBytes int64 `protobuf:"fixed64,8,opt,name=val_bytes,json=valBytes" json:"val_bytes"`
	// val_count is the number of meta values tracked under val_bytes.
	ValCount int64 `protobuf:"fixed64,9,opt,name=val_count,json=valCount" json:"val_count"`
	// intent_bytes is the number of bytes in intent key-value
	// pairs (without their meta keys).
	IntentBytes int64 `protobuf:"fixed64,10,opt,name=intent_bytes,json=intentBytes" json:"intent_bytes"`
	// intent_count is the number of keys tracked under intent_bytes.
	// It is equal to the number of meta keys in the system with
	// a non-empty Transaction proto.
	IntentCount int64 `protobuf:"fixed64,11,opt,name=intent_count,json=intentCount" json:"intent_count"`
	// sys_bytes is the number of bytes stored in system-local kv-pairs.
	// This tracks the same quantity as (key_bytes + val_bytes), but
	// for system-local metadata keys (which aren't counted in either
	// key_bytes or val_bytes). Each of the keys falling into this group
	// is documented in keys/constants.go under the localPrefix constant
	// and is prefixed by either LocalRangeIDPrefix or LocalRangePrefix.
	SysBytes int64 `protobuf:"fixed64,12,opt,name=sys_bytes,json=sysBytes" json:"sys_bytes"`
	// sys_count is the number of meta keys tracked under sys_bytes.
	SysCount int64 `protobuf:"fixed64,13,opt,name=sys_count,json=sysCount" json:"sys_count"`
}

func (m *MVCCStats) Reset()                    { *m = MVCCStats{} }
func (m *MVCCStats) String() string            { return proto.CompactTextString(m) }
func (*MVCCStats) ProtoMessage()               {}
func (*MVCCStats) Descriptor() ([]byte, []int) { return fileDescriptorMvcc, []int{1} }

func init() {
	proto.RegisterType((*MVCCMetadata)(nil), "cockroach.storage.engine.MVCCMetadata")
	proto.RegisterType((*MVCCStats)(nil), "cockroach.storage.engine.MVCCStats")
}
func (m *MVCCMetadata) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *MVCCMetadata) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Txn != nil {
		data[i] = 0xa
		i++
		i = encodeVarintMvcc(data, i, uint64(m.Txn.Size()))
		n1, err := m.Txn.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	data[i] = 0x12
	i++
	i = encodeVarintMvcc(data, i, uint64(m.Timestamp.Size()))
	n2, err := m.Timestamp.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n2
	data[i] = 0x18
	i++
	if m.Deleted {
		data[i] = 1
	} else {
		data[i] = 0
	}
	i++
	data[i] = 0x20
	i++
	i = encodeVarintMvcc(data, i, uint64(m.KeyBytes))
	data[i] = 0x28
	i++
	i = encodeVarintMvcc(data, i, uint64(m.ValBytes))
	if m.RawBytes != nil {
		data[i] = 0x32
		i++
		i = encodeVarintMvcc(data, i, uint64(len(m.RawBytes)))
		i += copy(data[i:], m.RawBytes)
	}
	if m.MergeTimestamp != nil {
		data[i] = 0x3a
		i++
		i = encodeVarintMvcc(data, i, uint64(m.MergeTimestamp.Size()))
		n3, err := m.MergeTimestamp.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	return i, nil
}

func (m *MVCCStats) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *MVCCStats) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	data[i] = 0x9
	i++
	i = encodeFixed64Mvcc(data, i, uint64(m.LastUpdateNanos))
	data[i] = 0x11
	i++
	i = encodeFixed64Mvcc(data, i, uint64(m.IntentAge))
	data[i] = 0x19
	i++
	i = encodeFixed64Mvcc(data, i, uint64(m.GCBytesAge))
	data[i] = 0x21
	i++
	i = encodeFixed64Mvcc(data, i, uint64(m.LiveBytes))
	data[i] = 0x29
	i++
	i = encodeFixed64Mvcc(data, i, uint64(m.LiveCount))
	data[i] = 0x31
	i++
	i = encodeFixed64Mvcc(data, i, uint64(m.KeyBytes))
	data[i] = 0x39
	i++
	i = encodeFixed64Mvcc(data, i, uint64(m.KeyCount))
	data[i] = 0x41
	i++
	i = encodeFixed64Mvcc(data, i, uint64(m.ValBytes))
	data[i] = 0x49
	i++
	i = encodeFixed64Mvcc(data, i, uint64(m.ValCount))
	data[i] = 0x51
	i++
	i = encodeFixed64Mvcc(data, i, uint64(m.IntentBytes))
	data[i] = 0x59
	i++
	i = encodeFixed64Mvcc(data, i, uint64(m.IntentCount))
	data[i] = 0x61
	i++
	i = encodeFixed64Mvcc(data, i, uint64(m.SysBytes))
	data[i] = 0x69
	i++
	i = encodeFixed64Mvcc(data, i, uint64(m.SysCount))
	return i, nil
}

func encodeFixed64Mvcc(data []byte, offset int, v uint64) int {
	data[offset] = uint8(v)
	data[offset+1] = uint8(v >> 8)
	data[offset+2] = uint8(v >> 16)
	data[offset+3] = uint8(v >> 24)
	data[offset+4] = uint8(v >> 32)
	data[offset+5] = uint8(v >> 40)
	data[offset+6] = uint8(v >> 48)
	data[offset+7] = uint8(v >> 56)
	return offset + 8
}
func encodeFixed32Mvcc(data []byte, offset int, v uint32) int {
	data[offset] = uint8(v)
	data[offset+1] = uint8(v >> 8)
	data[offset+2] = uint8(v >> 16)
	data[offset+3] = uint8(v >> 24)
	return offset + 4
}
func encodeVarintMvcc(data []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		data[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	data[offset] = uint8(v)
	return offset + 1
}
func NewPopulatedMVCCMetadata(r randyMvcc, easy bool) *MVCCMetadata {
	this := &MVCCMetadata{}
	if r.Intn(10) != 0 {
		this.Txn = cockroach_roachpb1.NewPopulatedTxnMeta(r, easy)
	}
	v1 := cockroach_roachpb1.NewPopulatedTimestamp(r, easy)
	this.Timestamp = *v1
	this.Deleted = bool(bool(r.Intn(2) == 0))
	this.KeyBytes = int64(r.Int63())
	if r.Intn(2) == 0 {
		this.KeyBytes *= -1
	}
	this.ValBytes = int64(r.Int63())
	if r.Intn(2) == 0 {
		this.ValBytes *= -1
	}
	if r.Intn(10) != 0 {
		v2 := r.Intn(100)
		this.RawBytes = make([]byte, v2)
		for i := 0; i < v2; i++ {
			this.RawBytes[i] = byte(r.Intn(256))
		}
	}
	if r.Intn(10) != 0 {
		this.MergeTimestamp = cockroach_roachpb1.NewPopulatedTimestamp(r, easy)
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedMVCCStats(r randyMvcc, easy bool) *MVCCStats {
	this := &MVCCStats{}
	this.LastUpdateNanos = int64(r.Int63())
	if r.Intn(2) == 0 {
		this.LastUpdateNanos *= -1
	}
	this.IntentAge = int64(r.Int63())
	if r.Intn(2) == 0 {
		this.IntentAge *= -1
	}
	this.GCBytesAge = int64(r.Int63())
	if r.Intn(2) == 0 {
		this.GCBytesAge *= -1
	}
	this.LiveBytes = int64(r.Int63())
	if r.Intn(2) == 0 {
		this.LiveBytes *= -1
	}
	this.LiveCount = int64(r.Int63())
	if r.Intn(2) == 0 {
		this.LiveCount *= -1
	}
	this.KeyBytes = int64(r.Int63())
	if r.Intn(2) == 0 {
		this.KeyBytes *= -1
	}
	this.KeyCount = int64(r.Int63())
	if r.Intn(2) == 0 {
		this.KeyCount *= -1
	}
	this.ValBytes = int64(r.Int63())
	if r.Intn(2) == 0 {
		this.ValBytes *= -1
	}
	this.ValCount = int64(r.Int63())
	if r.Intn(2) == 0 {
		this.ValCount *= -1
	}
	this.IntentBytes = int64(r.Int63())
	if r.Intn(2) == 0 {
		this.IntentBytes *= -1
	}
	this.IntentCount = int64(r.Int63())
	if r.Intn(2) == 0 {
		this.IntentCount *= -1
	}
	this.SysBytes = int64(r.Int63())
	if r.Intn(2) == 0 {
		this.SysBytes *= -1
	}
	this.SysCount = int64(r.Int63())
	if r.Intn(2) == 0 {
		this.SysCount *= -1
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

type randyMvcc interface {
	Float32() float32
	Float64() float64
	Int63() int64
	Int31() int32
	Uint32() uint32
	Intn(n int) int
}

func randUTF8RuneMvcc(r randyMvcc) rune {
	ru := r.Intn(62)
	if ru < 10 {
		return rune(ru + 48)
	} else if ru < 36 {
		return rune(ru + 55)
	}
	return rune(ru + 61)
}
func randStringMvcc(r randyMvcc) string {
	v3 := r.Intn(100)
	tmps := make([]rune, v3)
	for i := 0; i < v3; i++ {
		tmps[i] = randUTF8RuneMvcc(r)
	}
	return string(tmps)
}
func randUnrecognizedMvcc(r randyMvcc, maxFieldNumber int) (data []byte) {
	l := r.Intn(5)
	for i := 0; i < l; i++ {
		wire := r.Intn(4)
		if wire == 3 {
			wire = 5
		}
		fieldNumber := maxFieldNumber + r.Intn(100)
		data = randFieldMvcc(data, r, fieldNumber, wire)
	}
	return data
}
func randFieldMvcc(data []byte, r randyMvcc, fieldNumber int, wire int) []byte {
	key := uint32(fieldNumber)<<3 | uint32(wire)
	switch wire {
	case 0:
		data = encodeVarintPopulateMvcc(data, uint64(key))
		v4 := r.Int63()
		if r.Intn(2) == 0 {
			v4 *= -1
		}
		data = encodeVarintPopulateMvcc(data, uint64(v4))
	case 1:
		data = encodeVarintPopulateMvcc(data, uint64(key))
		data = append(data, byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)))
	case 2:
		data = encodeVarintPopulateMvcc(data, uint64(key))
		ll := r.Intn(100)
		data = encodeVarintPopulateMvcc(data, uint64(ll))
		for j := 0; j < ll; j++ {
			data = append(data, byte(r.Intn(256)))
		}
	default:
		data = encodeVarintPopulateMvcc(data, uint64(key))
		data = append(data, byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)))
	}
	return data
}
func encodeVarintPopulateMvcc(data []byte, v uint64) []byte {
	for v >= 1<<7 {
		data = append(data, uint8(uint64(v)&0x7f|0x80))
		v >>= 7
	}
	data = append(data, uint8(v))
	return data
}
func (m *MVCCMetadata) Size() (n int) {
	var l int
	_ = l
	if m.Txn != nil {
		l = m.Txn.Size()
		n += 1 + l + sovMvcc(uint64(l))
	}
	l = m.Timestamp.Size()
	n += 1 + l + sovMvcc(uint64(l))
	n += 2
	n += 1 + sovMvcc(uint64(m.KeyBytes))
	n += 1 + sovMvcc(uint64(m.ValBytes))
	if m.RawBytes != nil {
		l = len(m.RawBytes)
		n += 1 + l + sovMvcc(uint64(l))
	}
	if m.MergeTimestamp != nil {
		l = m.MergeTimestamp.Size()
		n += 1 + l + sovMvcc(uint64(l))
	}
	return n
}

func (m *MVCCStats) Size() (n int) {
	var l int
	_ = l
	n += 9
	n += 9
	n += 9
	n += 9
	n += 9
	n += 9
	n += 9
	n += 9
	n += 9
	n += 9
	n += 9
	n += 9
	n += 9
	return n
}

func sovMvcc(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozMvcc(x uint64) (n int) {
	return sovMvcc(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *MVCCMetadata) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMvcc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MVCCMetadata: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MVCCMetadata: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Txn", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMvcc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMvcc
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Txn == nil {
				m.Txn = &cockroach_roachpb1.TxnMeta{}
			}
			if err := m.Txn.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMvcc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMvcc
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Timestamp.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Deleted", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMvcc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Deleted = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyBytes", wireType)
			}
			m.KeyBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMvcc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.KeyBytes |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValBytes", wireType)
			}
			m.ValBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMvcc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.ValBytes |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RawBytes", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMvcc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMvcc
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RawBytes = append(m.RawBytes[:0], data[iNdEx:postIndex]...)
			if m.RawBytes == nil {
				m.RawBytes = []byte{}
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MergeTimestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMvcc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMvcc
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MergeTimestamp == nil {
				m.MergeTimestamp = &cockroach_roachpb1.Timestamp{}
			}
			if err := m.MergeTimestamp.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMvcc(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMvcc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MVCCStats) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMvcc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MVCCStats: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MVCCStats: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastUpdateNanos", wireType)
			}
			m.LastUpdateNanos = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			m.LastUpdateNanos = int64(data[iNdEx-8])
			m.LastUpdateNanos |= int64(data[iNdEx-7]) << 8
			m.LastUpdateNanos |= int64(data[iNdEx-6]) << 16
			m.LastUpdateNanos |= int64(data[iNdEx-5]) << 24
			m.LastUpdateNanos |= int64(data[iNdEx-4]) << 32
			m.LastUpdateNanos |= int64(data[iNdEx-3]) << 40
			m.LastUpdateNanos |= int64(data[iNdEx-2]) << 48
			m.LastUpdateNanos |= int64(data[iNdEx-1]) << 56
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field IntentAge", wireType)
			}
			m.IntentAge = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			m.IntentAge = int64(data[iNdEx-8])
			m.IntentAge |= int64(data[iNdEx-7]) << 8
			m.IntentAge |= int64(data[iNdEx-6]) << 16
			m.IntentAge |= int64(data[iNdEx-5]) << 24
			m.IntentAge |= int64(data[iNdEx-4]) << 32
			m.IntentAge |= int64(data[iNdEx-3]) << 40
			m.IntentAge |= int64(data[iNdEx-2]) << 48
			m.IntentAge |= int64(data[iNdEx-1]) << 56
		case 3:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field GCBytesAge", wireType)
			}
			m.GCBytesAge = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			m.GCBytesAge = int64(data[iNdEx-8])
			m.GCBytesAge |= int64(data[iNdEx-7]) << 8
			m.GCBytesAge |= int64(data[iNdEx-6]) << 16
			m.GCBytesAge |= int64(data[iNdEx-5]) << 24
			m.GCBytesAge |= int64(data[iNdEx-4]) << 32
			m.GCBytesAge |= int64(data[iNdEx-3]) << 40
			m.GCBytesAge |= int64(data[iNdEx-2]) << 48
			m.GCBytesAge |= int64(data[iNdEx-1]) << 56
		case 4:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field LiveBytes", wireType)
			}
			m.LiveBytes = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			m.LiveBytes = int64(data[iNdEx-8])
			m.LiveBytes |= int64(data[iNdEx-7]) << 8
			m.LiveBytes |= int64(data[iNdEx-6]) << 16
			m.LiveBytes |= int64(data[iNdEx-5]) << 24
			m.LiveBytes |= int64(data[iNdEx-4]) << 32
			m.LiveBytes |= int64(data[iNdEx-3]) << 40
			m.LiveBytes |= int64(data[iNdEx-2]) << 48
			m.LiveBytes |= int64(data[iNdEx-1]) << 56
		case 5:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field LiveCount", wireType)
			}
			m.LiveCount = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			m.LiveCount = int64(data[iNdEx-8])
			m.LiveCount |= int64(data[iNdEx-7]) << 8
			m.LiveCount |= int64(data[iNdEx-6]) << 16
			m.LiveCount |= int64(data[iNdEx-5]) << 24
			m.LiveCount |= int64(data[iNdEx-4]) << 32
			m.LiveCount |= int64(data[iNdEx-3]) << 40
			m.LiveCount |= int64(data[iNdEx-2]) << 48
			m.LiveCount |= int64(data[iNdEx-1]) << 56
		case 6:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyBytes", wireType)
			}
			m.KeyBytes = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			m.KeyBytes = int64(data[iNdEx-8])
			m.KeyBytes |= int64(data[iNdEx-7]) << 8
			m.KeyBytes |= int64(data[iNdEx-6]) << 16
			m.KeyBytes |= int64(data[iNdEx-5]) << 24
			m.KeyBytes |= int64(data[iNdEx-4]) << 32
			m.KeyBytes |= int64(data[iNdEx-3]) << 40
			m.KeyBytes |= int64(data[iNdEx-2]) << 48
			m.KeyBytes |= int64(data[iNdEx-1]) << 56
		case 7:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyCount", wireType)
			}
			m.KeyCount = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			m.KeyCount = int64(data[iNdEx-8])
			m.KeyCount |= int64(data[iNdEx-7]) << 8
			m.KeyCount |= int64(data[iNdEx-6]) << 16
			m.KeyCount |= int64(data[iNdEx-5]) << 24
			m.KeyCount |= int64(data[iNdEx-4]) << 32
			m.KeyCount |= int64(data[iNdEx-3]) << 40
			m.KeyCount |= int64(data[iNdEx-2]) << 48
			m.KeyCount |= int64(data[iNdEx-1]) << 56
		case 8:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValBytes", wireType)
			}
			m.ValBytes = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			m.ValBytes = int64(data[iNdEx-8])
			m.ValBytes |= int64(data[iNdEx-7]) << 8
			m.ValBytes |= int64(data[iNdEx-6]) << 16
			m.ValBytes |= int64(data[iNdEx-5]) << 24
			m.ValBytes |= int64(data[iNdEx-4]) << 32
			m.ValBytes |= int64(data[iNdEx-3]) << 40
			m.ValBytes |= int64(data[iNdEx-2]) << 48
			m.ValBytes |= int64(data[iNdEx-1]) << 56
		case 9:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValCount", wireType)
			}
			m.ValCount = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			m.ValCount = int64(data[iNdEx-8])
			m.ValCount |= int64(data[iNdEx-7]) << 8
			m.ValCount |= int64(data[iNdEx-6]) << 16
			m.ValCount |= int64(data[iNdEx-5]) << 24
			m.ValCount |= int64(data[iNdEx-4]) << 32
			m.ValCount |= int64(data[iNdEx-3]) << 40
			m.ValCount |= int64(data[iNdEx-2]) << 48
			m.ValCount |= int64(data[iNdEx-1]) << 56
		case 10:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field IntentBytes", wireType)
			}
			m.IntentBytes = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			m.IntentBytes = int64(data[iNdEx-8])
			m.IntentBytes |= int64(data[iNdEx-7]) << 8
			m.IntentBytes |= int64(data[iNdEx-6]) << 16
			m.IntentBytes |= int64(data[iNdEx-5]) << 24
			m.IntentBytes |= int64(data[iNdEx-4]) << 32
			m.IntentBytes |= int64(data[iNdEx-3]) << 40
			m.IntentBytes |= int64(data[iNdEx-2]) << 48
			m.IntentBytes |= int64(data[iNdEx-1]) << 56
		case 11:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field IntentCount", wireType)
			}
			m.IntentCount = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			m.IntentCount = int64(data[iNdEx-8])
			m.IntentCount |= int64(data[iNdEx-7]) << 8
			m.IntentCount |= int64(data[iNdEx-6]) << 16
			m.IntentCount |= int64(data[iNdEx-5]) << 24
			m.IntentCount |= int64(data[iNdEx-4]) << 32
			m.IntentCount |= int64(data[iNdEx-3]) << 40
			m.IntentCount |= int64(data[iNdEx-2]) << 48
			m.IntentCount |= int64(data[iNdEx-1]) << 56
		case 12:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field SysBytes", wireType)
			}
			m.SysBytes = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			m.SysBytes = int64(data[iNdEx-8])
			m.SysBytes |= int64(data[iNdEx-7]) << 8
			m.SysBytes |= int64(data[iNdEx-6]) << 16
			m.SysBytes |= int64(data[iNdEx-5]) << 24
			m.SysBytes |= int64(data[iNdEx-4]) << 32
			m.SysBytes |= int64(data[iNdEx-3]) << 40
			m.SysBytes |= int64(data[iNdEx-2]) << 48
			m.SysBytes |= int64(data[iNdEx-1]) << 56
		case 13:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field SysCount", wireType)
			}
			m.SysCount = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			m.SysCount = int64(data[iNdEx-8])
			m.SysCount |= int64(data[iNdEx-7]) << 8
			m.SysCount |= int64(data[iNdEx-6]) << 16
			m.SysCount |= int64(data[iNdEx-5]) << 24
			m.SysCount |= int64(data[iNdEx-4]) << 32
			m.SysCount |= int64(data[iNdEx-3]) << 40
			m.SysCount |= int64(data[iNdEx-2]) << 48
			m.SysCount |= int64(data[iNdEx-1]) << 56
		default:
			iNdEx = preIndex
			skippy, err := skipMvcc(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMvcc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipMvcc(data []byte) (n int, err error) {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowMvcc
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowMvcc
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if data[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowMvcc
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthMvcc
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowMvcc
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipMvcc(data[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthMvcc = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowMvcc   = fmt.Errorf("proto: integer overflow")
)

var fileDescriptorMvcc = []byte{
	// 501 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0x84, 0x93, 0xcd, 0x8e, 0xd3, 0x30,
	0x14, 0x85, 0x9b, 0x69, 0x69, 0x9b, 0xdb, 0xc0, 0x80, 0xc5, 0x22, 0x2a, 0xa3, 0x76, 0x98, 0x59,
	0xc0, 0x02, 0x25, 0x08, 0xb1, 0x62, 0x05, 0xad, 0x10, 0xab, 0x61, 0x11, 0x7e, 0x84, 0xd8, 0x44,
	0x9e, 0xd4, 0x0a, 0xd5, 0xb4, 0x76, 0x94, 0x78, 0xca, 0xf4, 0x1d, 0x58, 0xf0, 0x08, 0x3c, 0x06,
	0x8f, 0xd0, 0x15, 0x62, 0xc9, 0x6a, 0x04, 0xc3, 0x8b, 0x60, 0xfb, 0x3a, 0x3f, 0x2d, 0x48, 0x2c,
	0x5c, 0xb9, 0xe7, 0x7e, 0xf7, 0xd8, 0x3e, 0xb7, 0x85, 0xe3, 0x44, 0x24, 0x67, 0xb9, 0xa0, 0xc9,
	0x87, 0xb0, 0x90, 0x22, 0xa7, 0x29, 0x0b, 0x19, 0x4f, 0xe7, 0x9c, 0x85, 0xcb, 0x55, 0x92, 0x04,
	0x59, 0x2e, 0xa4, 0x20, 0x7e, 0x05, 0x05, 0x16, 0x0a, 0x10, 0x1a, 0x1e, 0xd4, 0xed, 0xe6, 0x33,
	0x3b, 0x0d, 0x67, 0x54, 0x52, 0xec, 0x1b, 0xde, 0x4e, 0x45, 0x2a, 0xcc, 0x36, 0xd4, 0x3b, 0x54,
	0x8f, 0xbe, 0xed, 0x81, 0x77, 0xf2, 0x76, 0x3a, 0x3d, 0x61, 0x92, 0x6a, 0x98, 0x3c, 0x80, 0xb6,
	0xbc, 0xe0, 0xbe, 0x73, 0xe8, 0xdc, 0x1f, 0x3c, 0x1a, 0x06, 0xf5, 0x61, 0xd6, 0x32, 0x78, 0x7d,
	0xc1, 0x35, 0x1c, 0x69, 0x8c, 0x3c, 0x05, 0x57, 0xce, 0x97, 0xac, 0x90, 0x74, 0x99, 0xf9, 0x7b,
	0xa6, 0xe7, 0xe0, 0x5f, 0x3d, 0x25, 0x33, 0xe9, 0x6c, 0x2e, 0xc7, 0xad, 0xa8, 0x6e, 0x22, 0x23,
	0xe8, 0xcd, 0xd8, 0x82, 0x49, 0x36, 0xf3, 0xdb, 0xaa, 0xbf, 0x6f, 0x89, 0x52, 0x24, 0x77, 0xc1,
	0x3d, 0x63, 0xeb, 0xf8, 0x74, 0x2d, 0x59, 0xe1, 0x77, 0x14, 0xd1, 0xb6, 0x44, 0x5f, 0xc9, 0x13,
	0xad, 0x6a, 0x64, 0x45, 0x17, 0x16, 0xb9, 0xd6, 0x44, 0x94, 0x8c, 0xc8, 0x1d, 0x70, 0x73, 0xfa,
	0xd1, 0x22, 0x5d, 0x85, 0x78, 0x51, 0x5f, 0x09, 0x58, 0x7c, 0x0e, 0xfb, 0x4b, 0x96, 0xa7, 0x2c,
	0xae, 0x9f, 0xd2, 0xfb, 0xff, 0x53, 0xa2, 0x1b, 0xa6, 0xa9, 0xfa, 0xfe, 0xa4, 0xf3, 0xf5, 0xcb,
	0xd8, 0x39, 0xfa, 0xd4, 0x01, 0x57, 0x07, 0xfa, 0x4a, 0x52, 0x59, 0x90, 0x87, 0x70, 0x6b, 0x41,
	0x0b, 0x19, 0x9f, 0x67, 0x2a, 0x5c, 0x16, 0x73, 0xca, 0x45, 0x61, 0xb2, 0xbd, 0x69, 0xaf, 0xb8,
	0xaf, 0xcb, 0x6f, 0x4c, 0xf5, 0xa5, 0x2e, 0x92, 0x63, 0x80, 0x39, 0x97, 0x8c, 0xcb, 0x58, 0x4d,
	0xd6, 0x44, 0x5a, 0xa2, 0x2e, 0xea, 0xcf, 0x52, 0x46, 0x1e, 0x83, 0x97, 0x26, 0xf8, 0x1a, 0x83,
	0xb5, 0x0d, 0x46, 0x34, 0x76, 0x75, 0x39, 0x86, 0x17, 0x53, 0xf3, 0x30, 0x45, 0x46, 0x90, 0x26,
	0xe5, 0x5e, 0x5b, 0x2f, 0xe6, 0x2b, 0xd6, 0xc8, 0xb2, 0xb2, 0xd6, 0x3a, 0x86, 0x51, 0x42, 0x89,
	0x38, 0xe7, 0xd2, 0xa4, 0xb9, 0x05, 0x4d, 0xb5, 0xbc, 0x3d, 0x94, 0x6e, 0x83, 0xd9, 0x1a, 0x8a,
	0x46, 0xd0, 0xa6, 0xb7, 0x83, 0x54, 0x2e, 0xf5, 0xdc, 0xfa, 0x4d, 0xa4, 0x9a, 0x9b, 0x45, 0xd0,
	0xc5, 0xdd, 0x41, 0xd0, 0xe5, 0x1e, 0x78, 0x36, 0x30, 0x34, 0x82, 0x06, 0x35, 0xc0, 0x0a, 0x7a,
	0xd5, 0x20, 0xda, 0x0d, 0xfe, 0x06, 0xab, 0x7b, 0x15, 0xeb, 0xc2, 0xda, 0x79, 0xcd, 0x43, 0x95,
	0x5c, 0xdd, 0x4b, 0x23, 0x68, 0x74, 0x7d, 0x07, 0x31, 0x2e, 0xf8, 0x73, 0x98, 0x1c, 0x6e, 0x7e,
	0x8d, 0x5a, 0x9b, 0xab, 0x91, 0xf3, 0x5d, 0xad, 0x1f, 0x6a, 0xfd, 0x54, 0xeb, 0xf3, 0xef, 0x51,
	0xeb, 0x7d, 0x17, 0xff, 0xb5, 0xef, 0x9c, 0x3f, 0x01, 0x00, 0x00, 0xff, 0xff, 0x09, 0xbe, 0xcc,
	0x36, 0xf7, 0x03, 0x00, 0x00,
}
