// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: cockroach/proto/internal.proto

#ifndef PROTOBUF_cockroach_2fproto_2finternal_2eproto__INCLUDED
#define PROTOBUF_cockroach_2fproto_2finternal_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "cockroach/proto/api.pb.h"
#include "cockroach/proto/config.pb.h"
#include "cockroach/proto/data.pb.h"
#include "gogoproto/gogo.pb.h"
// @@protoc_insertion_point(includes)

namespace cockroach {
namespace proto {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_cockroach_2fproto_2finternal_2eproto();
void protobuf_AssignDesc_cockroach_2fproto_2finternal_2eproto();
void protobuf_ShutdownFile_cockroach_2fproto_2finternal_2eproto();

class InternalRangeLookupRequest;
class InternalRangeLookupResponse;
class InternalHeartbeatTxnRequest;
class InternalHeartbeatTxnResponse;
class InternalGCRequest;
class InternalGCRequest_GCKey;
class InternalGCResponse;
class InternalPushTxnRequest;
class InternalPushTxnResponse;
class InternalResolveIntentRequest;
class InternalResolveIntentResponse;
class InternalResolveIntentRangeRequest;
class InternalResolveIntentRangeResponse;
class InternalMergeRequest;
class InternalMergeResponse;
class InternalTruncateLogRequest;
class InternalTruncateLogResponse;
class InternalLeaderLeaseRequest;
class InternalLeaderLeaseResponse;
class InternalRequestUnion;
class InternalResponseUnion;
class InternalBatchRequest;
class InternalBatchResponse;
class ReadWriteCmdResponse;
class InternalRaftCommandUnion;
class InternalRaftCommand;
class RaftMessageRequest;
class RaftMessageResponse;
class InternalTimeSeriesData;
class InternalTimeSeriesSample;
class RaftTruncatedState;
class RaftSnapshotData;
class RaftSnapshotData_KeyValue;

enum PushTxnType {
  PUSH_TIMESTAMP = 0,
  ABORT_TXN = 1,
  CLEANUP_TXN = 2
};
bool PushTxnType_IsValid(int value);
const PushTxnType PushTxnType_MIN = PUSH_TIMESTAMP;
const PushTxnType PushTxnType_MAX = CLEANUP_TXN;
const int PushTxnType_ARRAYSIZE = PushTxnType_MAX + 1;

const ::google::protobuf::EnumDescriptor* PushTxnType_descriptor();
inline const ::std::string& PushTxnType_Name(PushTxnType value) {
  return ::google::protobuf::internal::NameOfEnum(
    PushTxnType_descriptor(), value);
}
inline bool PushTxnType_Parse(
    const ::std::string& name, PushTxnType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<PushTxnType>(
    PushTxnType_descriptor(), name, value);
}
enum InternalValueType {
  _CR_TS = 1
};
bool InternalValueType_IsValid(int value);
const InternalValueType InternalValueType_MIN = _CR_TS;
const InternalValueType InternalValueType_MAX = _CR_TS;
const int InternalValueType_ARRAYSIZE = InternalValueType_MAX + 1;

const ::google::protobuf::EnumDescriptor* InternalValueType_descriptor();
inline const ::std::string& InternalValueType_Name(InternalValueType value) {
  return ::google::protobuf::internal::NameOfEnum(
    InternalValueType_descriptor(), value);
}
inline bool InternalValueType_Parse(
    const ::std::string& name, InternalValueType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<InternalValueType>(
    InternalValueType_descriptor(), name, value);
}
// ===================================================================

class InternalRangeLookupRequest : public ::google::protobuf::Message {
 public:
  InternalRangeLookupRequest();
  virtual ~InternalRangeLookupRequest();

  InternalRangeLookupRequest(const InternalRangeLookupRequest& from);

  inline InternalRangeLookupRequest& operator=(const InternalRangeLookupRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const InternalRangeLookupRequest& default_instance();

  void Swap(InternalRangeLookupRequest* other);

  // implements Message ----------------------------------------------

  InternalRangeLookupRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const InternalRangeLookupRequest& from);
  void MergeFrom(const InternalRangeLookupRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .cockroach.proto.RequestHeader header = 1;
  inline bool has_header() const;
  inline void clear_header();
  static const int kHeaderFieldNumber = 1;
  inline const ::cockroach::proto::RequestHeader& header() const;
  inline ::cockroach::proto::RequestHeader* mutable_header();
  inline ::cockroach::proto::RequestHeader* release_header();
  inline void set_allocated_header(::cockroach::proto::RequestHeader* header);

  // optional int32 max_ranges = 2;
  inline bool has_max_ranges() const;
  inline void clear_max_ranges();
  static const int kMaxRangesFieldNumber = 2;
  inline ::google::protobuf::int32 max_ranges() const;
  inline void set_max_ranges(::google::protobuf::int32 value);

  // optional bool ignore_intents = 3;
  inline bool has_ignore_intents() const;
  inline void clear_ignore_intents();
  static const int kIgnoreIntentsFieldNumber = 3;
  inline bool ignore_intents() const;
  inline void set_ignore_intents(bool value);

  // @@protoc_insertion_point(class_scope:cockroach.proto.InternalRangeLookupRequest)
 private:
  inline void set_has_header();
  inline void clear_has_header();
  inline void set_has_max_ranges();
  inline void clear_has_max_ranges();
  inline void set_has_ignore_intents();
  inline void clear_has_ignore_intents();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::cockroach::proto::RequestHeader* header_;
  ::google::protobuf::int32 max_ranges_;
  bool ignore_intents_;
  friend void  protobuf_AddDesc_cockroach_2fproto_2finternal_2eproto();
  friend void protobuf_AssignDesc_cockroach_2fproto_2finternal_2eproto();
  friend void protobuf_ShutdownFile_cockroach_2fproto_2finternal_2eproto();

  void InitAsDefaultInstance();
  static InternalRangeLookupRequest* default_instance_;
};
// -------------------------------------------------------------------

class InternalRangeLookupResponse : public ::google::protobuf::Message {
 public:
  InternalRangeLookupResponse();
  virtual ~InternalRangeLookupResponse();

  InternalRangeLookupResponse(const InternalRangeLookupResponse& from);

  inline InternalRangeLookupResponse& operator=(const InternalRangeLookupResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const InternalRangeLookupResponse& default_instance();

  void Swap(InternalRangeLookupResponse* other);

  // implements Message ----------------------------------------------

  InternalRangeLookupResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const InternalRangeLookupResponse& from);
  void MergeFrom(const InternalRangeLookupResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .cockroach.proto.ResponseHeader header = 1;
  inline bool has_header() const;
  inline void clear_header();
  static const int kHeaderFieldNumber = 1;
  inline const ::cockroach::proto::ResponseHeader& header() const;
  inline ::cockroach::proto::ResponseHeader* mutable_header();
  inline ::cockroach::proto::ResponseHeader* release_header();
  inline void set_allocated_header(::cockroach::proto::ResponseHeader* header);

  // repeated .cockroach.proto.RangeDescriptor ranges = 2;
  inline int ranges_size() const;
  inline void clear_ranges();
  static const int kRangesFieldNumber = 2;
  inline const ::cockroach::proto::RangeDescriptor& ranges(int index) const;
  inline ::cockroach::proto::RangeDescriptor* mutable_ranges(int index);
  inline ::cockroach::proto::RangeDescriptor* add_ranges();
  inline const ::google::protobuf::RepeatedPtrField< ::cockroach::proto::RangeDescriptor >&
      ranges() const;
  inline ::google::protobuf::RepeatedPtrField< ::cockroach::proto::RangeDescriptor >*
      mutable_ranges();

  // @@protoc_insertion_point(class_scope:cockroach.proto.InternalRangeLookupResponse)
 private:
  inline void set_has_header();
  inline void clear_has_header();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::cockroach::proto::ResponseHeader* header_;
  ::google::protobuf::RepeatedPtrField< ::cockroach::proto::RangeDescriptor > ranges_;
  friend void  protobuf_AddDesc_cockroach_2fproto_2finternal_2eproto();
  friend void protobuf_AssignDesc_cockroach_2fproto_2finternal_2eproto();
  friend void protobuf_ShutdownFile_cockroach_2fproto_2finternal_2eproto();

  void InitAsDefaultInstance();
  static InternalRangeLookupResponse* default_instance_;
};
// -------------------------------------------------------------------

class InternalHeartbeatTxnRequest : public ::google::protobuf::Message {
 public:
  InternalHeartbeatTxnRequest();
  virtual ~InternalHeartbeatTxnRequest();

  InternalHeartbeatTxnRequest(const InternalHeartbeatTxnRequest& from);

  inline InternalHeartbeatTxnRequest& operator=(const InternalHeartbeatTxnRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const InternalHeartbeatTxnRequest& default_instance();

  void Swap(InternalHeartbeatTxnRequest* other);

  // implements Message ----------------------------------------------

  InternalHeartbeatTxnRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const InternalHeartbeatTxnRequest& from);
  void MergeFrom(const InternalHeartbeatTxnRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .cockroach.proto.RequestHeader header = 1;
  inline bool has_header() const;
  inline void clear_header();
  static const int kHeaderFieldNumber = 1;
  inline const ::cockroach::proto::RequestHeader& header() const;
  inline ::cockroach::proto::RequestHeader* mutable_header();
  inline ::cockroach::proto::RequestHeader* release_header();
  inline void set_allocated_header(::cockroach::proto::RequestHeader* header);

  // @@protoc_insertion_point(class_scope:cockroach.proto.InternalHeartbeatTxnRequest)
 private:
  inline void set_has_header();
  inline void clear_has_header();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::cockroach::proto::RequestHeader* header_;
  friend void  protobuf_AddDesc_cockroach_2fproto_2finternal_2eproto();
  friend void protobuf_AssignDesc_cockroach_2fproto_2finternal_2eproto();
  friend void protobuf_ShutdownFile_cockroach_2fproto_2finternal_2eproto();

  void InitAsDefaultInstance();
  static InternalHeartbeatTxnRequest* default_instance_;
};
// -------------------------------------------------------------------

class InternalHeartbeatTxnResponse : public ::google::protobuf::Message {
 public:
  InternalHeartbeatTxnResponse();
  virtual ~InternalHeartbeatTxnResponse();

  InternalHeartbeatTxnResponse(const InternalHeartbeatTxnResponse& from);

  inline InternalHeartbeatTxnResponse& operator=(const InternalHeartbeatTxnResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const InternalHeartbeatTxnResponse& default_instance();

  void Swap(InternalHeartbeatTxnResponse* other);

  // implements Message ----------------------------------------------

  InternalHeartbeatTxnResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const InternalHeartbeatTxnResponse& from);
  void MergeFrom(const InternalHeartbeatTxnResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .cockroach.proto.ResponseHeader header = 1;
  inline bool has_header() const;
  inline void clear_header();
  static const int kHeaderFieldNumber = 1;
  inline const ::cockroach::proto::ResponseHeader& header() const;
  inline ::cockroach::proto::ResponseHeader* mutable_header();
  inline ::cockroach::proto::ResponseHeader* release_header();
  inline void set_allocated_header(::cockroach::proto::ResponseHeader* header);

  // @@protoc_insertion_point(class_scope:cockroach.proto.InternalHeartbeatTxnResponse)
 private:
  inline void set_has_header();
  inline void clear_has_header();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::cockroach::proto::ResponseHeader* header_;
  friend void  protobuf_AddDesc_cockroach_2fproto_2finternal_2eproto();
  friend void protobuf_AssignDesc_cockroach_2fproto_2finternal_2eproto();
  friend void protobuf_ShutdownFile_cockroach_2fproto_2finternal_2eproto();

  void InitAsDefaultInstance();
  static InternalHeartbeatTxnResponse* default_instance_;
};
// -------------------------------------------------------------------

class InternalGCRequest_GCKey : public ::google::protobuf::Message {
 public:
  InternalGCRequest_GCKey();
  virtual ~InternalGCRequest_GCKey();

  InternalGCRequest_GCKey(const InternalGCRequest_GCKey& from);

  inline InternalGCRequest_GCKey& operator=(const InternalGCRequest_GCKey& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const InternalGCRequest_GCKey& default_instance();

  void Swap(InternalGCRequest_GCKey* other);

  // implements Message ----------------------------------------------

  InternalGCRequest_GCKey* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const InternalGCRequest_GCKey& from);
  void MergeFrom(const InternalGCRequest_GCKey& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes key = 1;
  inline bool has_key() const;
  inline void clear_key();
  static const int kKeyFieldNumber = 1;
  inline const ::std::string& key() const;
  inline void set_key(const ::std::string& value);
  inline void set_key(const char* value);
  inline void set_key(const void* value, size_t size);
  inline ::std::string* mutable_key();
  inline ::std::string* release_key();
  inline void set_allocated_key(::std::string* key);

  // optional .cockroach.proto.Timestamp timestamp = 2;
  inline bool has_timestamp() const;
  inline void clear_timestamp();
  static const int kTimestampFieldNumber = 2;
  inline const ::cockroach::proto::Timestamp& timestamp() const;
  inline ::cockroach::proto::Timestamp* mutable_timestamp();
  inline ::cockroach::proto::Timestamp* release_timestamp();
  inline void set_allocated_timestamp(::cockroach::proto::Timestamp* timestamp);

  // @@protoc_insertion_point(class_scope:cockroach.proto.InternalGCRequest.GCKey)
 private:
  inline void set_has_key();
  inline void clear_has_key();
  inline void set_has_timestamp();
  inline void clear_has_timestamp();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* key_;
  ::cockroach::proto::Timestamp* timestamp_;
  friend void  protobuf_AddDesc_cockroach_2fproto_2finternal_2eproto();
  friend void protobuf_AssignDesc_cockroach_2fproto_2finternal_2eproto();
  friend void protobuf_ShutdownFile_cockroach_2fproto_2finternal_2eproto();

  void InitAsDefaultInstance();
  static InternalGCRequest_GCKey* default_instance_;
};
// -------------------------------------------------------------------

class InternalGCRequest : public ::google::protobuf::Message {
 public:
  InternalGCRequest();
  virtual ~InternalGCRequest();

  InternalGCRequest(const InternalGCRequest& from);

  inline InternalGCRequest& operator=(const InternalGCRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const InternalGCRequest& default_instance();

  void Swap(InternalGCRequest* other);

  // implements Message ----------------------------------------------

  InternalGCRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const InternalGCRequest& from);
  void MergeFrom(const InternalGCRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef InternalGCRequest_GCKey GCKey;

  // accessors -------------------------------------------------------

  // optional .cockroach.proto.RequestHeader header = 1;
  inline bool has_header() const;
  inline void clear_header();
  static const int kHeaderFieldNumber = 1;
  inline const ::cockroach::proto::RequestHeader& header() const;
  inline ::cockroach::proto::RequestHeader* mutable_header();
  inline ::cockroach::proto::RequestHeader* release_header();
  inline void set_allocated_header(::cockroach::proto::RequestHeader* header);

  // optional .cockroach.proto.GCMetadata gc_meta = 2;
  inline bool has_gc_meta() const;
  inline void clear_gc_meta();
  static const int kGcMetaFieldNumber = 2;
  inline const ::cockroach::proto::GCMetadata& gc_meta() const;
  inline ::cockroach::proto::GCMetadata* mutable_gc_meta();
  inline ::cockroach::proto::GCMetadata* release_gc_meta();
  inline void set_allocated_gc_meta(::cockroach::proto::GCMetadata* gc_meta);

  // repeated .cockroach.proto.InternalGCRequest.GCKey keys = 3;
  inline int keys_size() const;
  inline void clear_keys();
  static const int kKeysFieldNumber = 3;
  inline const ::cockroach::proto::InternalGCRequest_GCKey& keys(int index) const;
  inline ::cockroach::proto::InternalGCRequest_GCKey* mutable_keys(int index);
  inline ::cockroach::proto::InternalGCRequest_GCKey* add_keys();
  inline const ::google::protobuf::RepeatedPtrField< ::cockroach::proto::InternalGCRequest_GCKey >&
      keys() const;
  inline ::google::protobuf::RepeatedPtrField< ::cockroach::proto::InternalGCRequest_GCKey >*
      mutable_keys();

  // @@protoc_insertion_point(class_scope:cockroach.proto.InternalGCRequest)
 private:
  inline void set_has_header();
  inline void clear_has_header();
  inline void set_has_gc_meta();
  inline void clear_has_gc_meta();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::cockroach::proto::RequestHeader* header_;
  ::cockroach::proto::GCMetadata* gc_meta_;
  ::google::protobuf::RepeatedPtrField< ::cockroach::proto::InternalGCRequest_GCKey > keys_;
  friend void  protobuf_AddDesc_cockroach_2fproto_2finternal_2eproto();
  friend void protobuf_AssignDesc_cockroach_2fproto_2finternal_2eproto();
  friend void protobuf_ShutdownFile_cockroach_2fproto_2finternal_2eproto();

  void InitAsDefaultInstance();
  static InternalGCRequest* default_instance_;
};
// -------------------------------------------------------------------

class InternalGCResponse : public ::google::protobuf::Message {
 public:
  InternalGCResponse();
  virtual ~InternalGCResponse();

  InternalGCResponse(const InternalGCResponse& from);

  inline InternalGCResponse& operator=(const InternalGCResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const InternalGCResponse& default_instance();

  void Swap(InternalGCResponse* other);

  // implements Message ----------------------------------------------

  InternalGCResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const InternalGCResponse& from);
  void MergeFrom(const InternalGCResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .cockroach.proto.ResponseHeader header = 1;
  inline bool has_header() const;
  inline void clear_header();
  static const int kHeaderFieldNumber = 1;
  inline const ::cockroach::proto::ResponseHeader& header() const;
  inline ::cockroach::proto::ResponseHeader* mutable_header();
  inline ::cockroach::proto::ResponseHeader* release_header();
  inline void set_allocated_header(::cockroach::proto::ResponseHeader* header);

  // @@protoc_insertion_point(class_scope:cockroach.proto.InternalGCResponse)
 private:
  inline void set_has_header();
  inline void clear_has_header();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::cockroach::proto::ResponseHeader* header_;
  friend void  protobuf_AddDesc_cockroach_2fproto_2finternal_2eproto();
  friend void protobuf_AssignDesc_cockroach_2fproto_2finternal_2eproto();
  friend void protobuf_ShutdownFile_cockroach_2fproto_2finternal_2eproto();

  void InitAsDefaultInstance();
  static InternalGCResponse* default_instance_;
};
// -------------------------------------------------------------------

class InternalPushTxnRequest : public ::google::protobuf::Message {
 public:
  InternalPushTxnRequest();
  virtual ~InternalPushTxnRequest();

  InternalPushTxnRequest(const InternalPushTxnRequest& from);

  inline InternalPushTxnRequest& operator=(const InternalPushTxnRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const InternalPushTxnRequest& default_instance();

  void Swap(InternalPushTxnRequest* other);

  // implements Message ----------------------------------------------

  InternalPushTxnRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const InternalPushTxnRequest& from);
  void MergeFrom(const InternalPushTxnRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .cockroach.proto.RequestHeader header = 1;
  inline bool has_header() const;
  inline void clear_header();
  static const int kHeaderFieldNumber = 1;
  inline const ::cockroach::proto::RequestHeader& header() const;
  inline ::cockroach::proto::RequestHeader* mutable_header();
  inline ::cockroach::proto::RequestHeader* release_header();
  inline void set_allocated_header(::cockroach::proto::RequestHeader* header);

  // optional .cockroach.proto.Transaction pushee_txn = 2;
  inline bool has_pushee_txn() const;
  inline void clear_pushee_txn();
  static const int kPusheeTxnFieldNumber = 2;
  inline const ::cockroach::proto::Transaction& pushee_txn() const;
  inline ::cockroach::proto::Transaction* mutable_pushee_txn();
  inline ::cockroach::proto::Transaction* release_pushee_txn();
  inline void set_allocated_pushee_txn(::cockroach::proto::Transaction* pushee_txn);

  // optional .cockroach.proto.Timestamp now = 3;
  inline bool has_now() const;
  inline void clear_now();
  static const int kNowFieldNumber = 3;
  inline const ::cockroach::proto::Timestamp& now() const;
  inline ::cockroach::proto::Timestamp* mutable_now();
  inline ::cockroach::proto::Timestamp* release_now();
  inline void set_allocated_now(::cockroach::proto::Timestamp* now);

  // optional .cockroach.proto.PushTxnType push_type = 4;
  inline bool has_push_type() const;
  inline void clear_push_type();
  static const int kPushTypeFieldNumber = 4;
  inline ::cockroach::proto::PushTxnType push_type() const;
  inline void set_push_type(::cockroach::proto::PushTxnType value);

  // optional bool range_lookup = 5;
  inline bool has_range_lookup() const;
  inline void clear_range_lookup();
  static const int kRangeLookupFieldNumber = 5;
  inline bool range_lookup() const;
  inline void set_range_lookup(bool value);

  // @@protoc_insertion_point(class_scope:cockroach.proto.InternalPushTxnRequest)
 private:
  inline void set_has_header();
  inline void clear_has_header();
  inline void set_has_pushee_txn();
  inline void clear_has_pushee_txn();
  inline void set_has_now();
  inline void clear_has_now();
  inline void set_has_push_type();
  inline void clear_has_push_type();
  inline void set_has_range_lookup();
  inline void clear_has_range_lookup();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::cockroach::proto::RequestHeader* header_;
  ::cockroach::proto::Transaction* pushee_txn_;
  ::cockroach::proto::Timestamp* now_;
  int push_type_;
  bool range_lookup_;
  friend void  protobuf_AddDesc_cockroach_2fproto_2finternal_2eproto();
  friend void protobuf_AssignDesc_cockroach_2fproto_2finternal_2eproto();
  friend void protobuf_ShutdownFile_cockroach_2fproto_2finternal_2eproto();

  void InitAsDefaultInstance();
  static InternalPushTxnRequest* default_instance_;
};
// -------------------------------------------------------------------

class InternalPushTxnResponse : public ::google::protobuf::Message {
 public:
  InternalPushTxnResponse();
  virtual ~InternalPushTxnResponse();

  InternalPushTxnResponse(const InternalPushTxnResponse& from);

  inline InternalPushTxnResponse& operator=(const InternalPushTxnResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const InternalPushTxnResponse& default_instance();

  void Swap(InternalPushTxnResponse* other);

  // implements Message ----------------------------------------------

  InternalPushTxnResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const InternalPushTxnResponse& from);
  void MergeFrom(const InternalPushTxnResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .cockroach.proto.ResponseHeader header = 1;
  inline bool has_header() const;
  inline void clear_header();
  static const int kHeaderFieldNumber = 1;
  inline const ::cockroach::proto::ResponseHeader& header() const;
  inline ::cockroach::proto::ResponseHeader* mutable_header();
  inline ::cockroach::proto::ResponseHeader* release_header();
  inline void set_allocated_header(::cockroach::proto::ResponseHeader* header);

  // optional .cockroach.proto.Transaction pushee_txn = 2;
  inline bool has_pushee_txn() const;
  inline void clear_pushee_txn();
  static const int kPusheeTxnFieldNumber = 2;
  inline const ::cockroach::proto::Transaction& pushee_txn() const;
  inline ::cockroach::proto::Transaction* mutable_pushee_txn();
  inline ::cockroach::proto::Transaction* release_pushee_txn();
  inline void set_allocated_pushee_txn(::cockroach::proto::Transaction* pushee_txn);

  // @@protoc_insertion_point(class_scope:cockroach.proto.InternalPushTxnResponse)
 private:
  inline void set_has_header();
  inline void clear_has_header();
  inline void set_has_pushee_txn();
  inline void clear_has_pushee_txn();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::cockroach::proto::ResponseHeader* header_;
  ::cockroach::proto::Transaction* pushee_txn_;
  friend void  protobuf_AddDesc_cockroach_2fproto_2finternal_2eproto();
  friend void protobuf_AssignDesc_cockroach_2fproto_2finternal_2eproto();
  friend void protobuf_ShutdownFile_cockroach_2fproto_2finternal_2eproto();

  void InitAsDefaultInstance();
  static InternalPushTxnResponse* default_instance_;
};
// -------------------------------------------------------------------

class InternalResolveIntentRequest : public ::google::protobuf::Message {
 public:
  InternalResolveIntentRequest();
  virtual ~InternalResolveIntentRequest();

  InternalResolveIntentRequest(const InternalResolveIntentRequest& from);

  inline InternalResolveIntentRequest& operator=(const InternalResolveIntentRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const InternalResolveIntentRequest& default_instance();

  void Swap(InternalResolveIntentRequest* other);

  // implements Message ----------------------------------------------

  InternalResolveIntentRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const InternalResolveIntentRequest& from);
  void MergeFrom(const InternalResolveIntentRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .cockroach.proto.RequestHeader header = 1;
  inline bool has_header() const;
  inline void clear_header();
  static const int kHeaderFieldNumber = 1;
  inline const ::cockroach::proto::RequestHeader& header() const;
  inline ::cockroach::proto::RequestHeader* mutable_header();
  inline ::cockroach::proto::RequestHeader* release_header();
  inline void set_allocated_header(::cockroach::proto::RequestHeader* header);

  // @@protoc_insertion_point(class_scope:cockroach.proto.InternalResolveIntentRequest)
 private:
  inline void set_has_header();
  inline void clear_has_header();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::cockroach::proto::RequestHeader* header_;
  friend void  protobuf_AddDesc_cockroach_2fproto_2finternal_2eproto();
  friend void protobuf_AssignDesc_cockroach_2fproto_2finternal_2eproto();
  friend void protobuf_ShutdownFile_cockroach_2fproto_2finternal_2eproto();

  void InitAsDefaultInstance();
  static InternalResolveIntentRequest* default_instance_;
};
// -------------------------------------------------------------------

class InternalResolveIntentResponse : public ::google::protobuf::Message {
 public:
  InternalResolveIntentResponse();
  virtual ~InternalResolveIntentResponse();

  InternalResolveIntentResponse(const InternalResolveIntentResponse& from);

  inline InternalResolveIntentResponse& operator=(const InternalResolveIntentResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const InternalResolveIntentResponse& default_instance();

  void Swap(InternalResolveIntentResponse* other);

  // implements Message ----------------------------------------------

  InternalResolveIntentResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const InternalResolveIntentResponse& from);
  void MergeFrom(const InternalResolveIntentResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .cockroach.proto.ResponseHeader header = 1;
  inline bool has_header() const;
  inline void clear_header();
  static const int kHeaderFieldNumber = 1;
  inline const ::cockroach::proto::ResponseHeader& header() const;
  inline ::cockroach::proto::ResponseHeader* mutable_header();
  inline ::cockroach::proto::ResponseHeader* release_header();
  inline void set_allocated_header(::cockroach::proto::ResponseHeader* header);

  // @@protoc_insertion_point(class_scope:cockroach.proto.InternalResolveIntentResponse)
 private:
  inline void set_has_header();
  inline void clear_has_header();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::cockroach::proto::ResponseHeader* header_;
  friend void  protobuf_AddDesc_cockroach_2fproto_2finternal_2eproto();
  friend void protobuf_AssignDesc_cockroach_2fproto_2finternal_2eproto();
  friend void protobuf_ShutdownFile_cockroach_2fproto_2finternal_2eproto();

  void InitAsDefaultInstance();
  static InternalResolveIntentResponse* default_instance_;
};
// -------------------------------------------------------------------

class InternalResolveIntentRangeRequest : public ::google::protobuf::Message {
 public:
  InternalResolveIntentRangeRequest();
  virtual ~InternalResolveIntentRangeRequest();

  InternalResolveIntentRangeRequest(const InternalResolveIntentRangeRequest& from);

  inline InternalResolveIntentRangeRequest& operator=(const InternalResolveIntentRangeRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const InternalResolveIntentRangeRequest& default_instance();

  void Swap(InternalResolveIntentRangeRequest* other);

  // implements Message ----------------------------------------------

  InternalResolveIntentRangeRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const InternalResolveIntentRangeRequest& from);
  void MergeFrom(const InternalResolveIntentRangeRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .cockroach.proto.RequestHeader header = 1;
  inline bool has_header() const;
  inline void clear_header();
  static const int kHeaderFieldNumber = 1;
  inline const ::cockroach::proto::RequestHeader& header() const;
  inline ::cockroach::proto::RequestHeader* mutable_header();
  inline ::cockroach::proto::RequestHeader* release_header();
  inline void set_allocated_header(::cockroach::proto::RequestHeader* header);

  // @@protoc_insertion_point(class_scope:cockroach.proto.InternalResolveIntentRangeRequest)
 private:
  inline void set_has_header();
  inline void clear_has_header();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::cockroach::proto::RequestHeader* header_;
  friend void  protobuf_AddDesc_cockroach_2fproto_2finternal_2eproto();
  friend void protobuf_AssignDesc_cockroach_2fproto_2finternal_2eproto();
  friend void protobuf_ShutdownFile_cockroach_2fproto_2finternal_2eproto();

  void InitAsDefaultInstance();
  static InternalResolveIntentRangeRequest* default_instance_;
};
// -------------------------------------------------------------------

class InternalResolveIntentRangeResponse : public ::google::protobuf::Message {
 public:
  InternalResolveIntentRangeResponse();
  virtual ~InternalResolveIntentRangeResponse();

  InternalResolveIntentRangeResponse(const InternalResolveIntentRangeResponse& from);

  inline InternalResolveIntentRangeResponse& operator=(const InternalResolveIntentRangeResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const InternalResolveIntentRangeResponse& default_instance();

  void Swap(InternalResolveIntentRangeResponse* other);

  // implements Message ----------------------------------------------

  InternalResolveIntentRangeResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const InternalResolveIntentRangeResponse& from);
  void MergeFrom(const InternalResolveIntentRangeResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .cockroach.proto.ResponseHeader header = 1;
  inline bool has_header() const;
  inline void clear_header();
  static const int kHeaderFieldNumber = 1;
  inline const ::cockroach::proto::ResponseHeader& header() const;
  inline ::cockroach::proto::ResponseHeader* mutable_header();
  inline ::cockroach::proto::ResponseHeader* release_header();
  inline void set_allocated_header(::cockroach::proto::ResponseHeader* header);

  // @@protoc_insertion_point(class_scope:cockroach.proto.InternalResolveIntentRangeResponse)
 private:
  inline void set_has_header();
  inline void clear_has_header();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::cockroach::proto::ResponseHeader* header_;
  friend void  protobuf_AddDesc_cockroach_2fproto_2finternal_2eproto();
  friend void protobuf_AssignDesc_cockroach_2fproto_2finternal_2eproto();
  friend void protobuf_ShutdownFile_cockroach_2fproto_2finternal_2eproto();

  void InitAsDefaultInstance();
  static InternalResolveIntentRangeResponse* default_instance_;
};
// -------------------------------------------------------------------

class InternalMergeRequest : public ::google::protobuf::Message {
 public:
  InternalMergeRequest();
  virtual ~InternalMergeRequest();

  InternalMergeRequest(const InternalMergeRequest& from);

  inline InternalMergeRequest& operator=(const InternalMergeRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const InternalMergeRequest& default_instance();

  void Swap(InternalMergeRequest* other);

  // implements Message ----------------------------------------------

  InternalMergeRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const InternalMergeRequest& from);
  void MergeFrom(const InternalMergeRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .cockroach.proto.RequestHeader header = 1;
  inline bool has_header() const;
  inline void clear_header();
  static const int kHeaderFieldNumber = 1;
  inline const ::cockroach::proto::RequestHeader& header() const;
  inline ::cockroach::proto::RequestHeader* mutable_header();
  inline ::cockroach::proto::RequestHeader* release_header();
  inline void set_allocated_header(::cockroach::proto::RequestHeader* header);

  // optional .cockroach.proto.Value value = 2;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 2;
  inline const ::cockroach::proto::Value& value() const;
  inline ::cockroach::proto::Value* mutable_value();
  inline ::cockroach::proto::Value* release_value();
  inline void set_allocated_value(::cockroach::proto::Value* value);

  // @@protoc_insertion_point(class_scope:cockroach.proto.InternalMergeRequest)
 private:
  inline void set_has_header();
  inline void clear_has_header();
  inline void set_has_value();
  inline void clear_has_value();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::cockroach::proto::RequestHeader* header_;
  ::cockroach::proto::Value* value_;
  friend void  protobuf_AddDesc_cockroach_2fproto_2finternal_2eproto();
  friend void protobuf_AssignDesc_cockroach_2fproto_2finternal_2eproto();
  friend void protobuf_ShutdownFile_cockroach_2fproto_2finternal_2eproto();

  void InitAsDefaultInstance();
  static InternalMergeRequest* default_instance_;
};
// -------------------------------------------------------------------

class InternalMergeResponse : public ::google::protobuf::Message {
 public:
  InternalMergeResponse();
  virtual ~InternalMergeResponse();

  InternalMergeResponse(const InternalMergeResponse& from);

  inline InternalMergeResponse& operator=(const InternalMergeResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const InternalMergeResponse& default_instance();

  void Swap(InternalMergeResponse* other);

  // implements Message ----------------------------------------------

  InternalMergeResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const InternalMergeResponse& from);
  void MergeFrom(const InternalMergeResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .cockroach.proto.ResponseHeader header = 1;
  inline bool has_header() const;
  inline void clear_header();
  static const int kHeaderFieldNumber = 1;
  inline const ::cockroach::proto::ResponseHeader& header() const;
  inline ::cockroach::proto::ResponseHeader* mutable_header();
  inline ::cockroach::proto::ResponseHeader* release_header();
  inline void set_allocated_header(::cockroach::proto::ResponseHeader* header);

  // @@protoc_insertion_point(class_scope:cockroach.proto.InternalMergeResponse)
 private:
  inline void set_has_header();
  inline void clear_has_header();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::cockroach::proto::ResponseHeader* header_;
  friend void  protobuf_AddDesc_cockroach_2fproto_2finternal_2eproto();
  friend void protobuf_AssignDesc_cockroach_2fproto_2finternal_2eproto();
  friend void protobuf_ShutdownFile_cockroach_2fproto_2finternal_2eproto();

  void InitAsDefaultInstance();
  static InternalMergeResponse* default_instance_;
};
// -------------------------------------------------------------------

class InternalTruncateLogRequest : public ::google::protobuf::Message {
 public:
  InternalTruncateLogRequest();
  virtual ~InternalTruncateLogRequest();

  InternalTruncateLogRequest(const InternalTruncateLogRequest& from);

  inline InternalTruncateLogRequest& operator=(const InternalTruncateLogRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const InternalTruncateLogRequest& default_instance();

  void Swap(InternalTruncateLogRequest* other);

  // implements Message ----------------------------------------------

  InternalTruncateLogRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const InternalTruncateLogRequest& from);
  void MergeFrom(const InternalTruncateLogRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .cockroach.proto.RequestHeader header = 1;
  inline bool has_header() const;
  inline void clear_header();
  static const int kHeaderFieldNumber = 1;
  inline const ::cockroach::proto::RequestHeader& header() const;
  inline ::cockroach::proto::RequestHeader* mutable_header();
  inline ::cockroach::proto::RequestHeader* release_header();
  inline void set_allocated_header(::cockroach::proto::RequestHeader* header);

  // optional uint64 index = 2;
  inline bool has_index() const;
  inline void clear_index();
  static const int kIndexFieldNumber = 2;
  inline ::google::protobuf::uint64 index() const;
  inline void set_index(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:cockroach.proto.InternalTruncateLogRequest)
 private:
  inline void set_has_header();
  inline void clear_has_header();
  inline void set_has_index();
  inline void clear_has_index();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::cockroach::proto::RequestHeader* header_;
  ::google::protobuf::uint64 index_;
  friend void  protobuf_AddDesc_cockroach_2fproto_2finternal_2eproto();
  friend void protobuf_AssignDesc_cockroach_2fproto_2finternal_2eproto();
  friend void protobuf_ShutdownFile_cockroach_2fproto_2finternal_2eproto();

  void InitAsDefaultInstance();
  static InternalTruncateLogRequest* default_instance_;
};
// -------------------------------------------------------------------

class InternalTruncateLogResponse : public ::google::protobuf::Message {
 public:
  InternalTruncateLogResponse();
  virtual ~InternalTruncateLogResponse();

  InternalTruncateLogResponse(const InternalTruncateLogResponse& from);

  inline InternalTruncateLogResponse& operator=(const InternalTruncateLogResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const InternalTruncateLogResponse& default_instance();

  void Swap(InternalTruncateLogResponse* other);

  // implements Message ----------------------------------------------

  InternalTruncateLogResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const InternalTruncateLogResponse& from);
  void MergeFrom(const InternalTruncateLogResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .cockroach.proto.ResponseHeader header = 1;
  inline bool has_header() const;
  inline void clear_header();
  static const int kHeaderFieldNumber = 1;
  inline const ::cockroach::proto::ResponseHeader& header() const;
  inline ::cockroach::proto::ResponseHeader* mutable_header();
  inline ::cockroach::proto::ResponseHeader* release_header();
  inline void set_allocated_header(::cockroach::proto::ResponseHeader* header);

  // @@protoc_insertion_point(class_scope:cockroach.proto.InternalTruncateLogResponse)
 private:
  inline void set_has_header();
  inline void clear_has_header();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::cockroach::proto::ResponseHeader* header_;
  friend void  protobuf_AddDesc_cockroach_2fproto_2finternal_2eproto();
  friend void protobuf_AssignDesc_cockroach_2fproto_2finternal_2eproto();
  friend void protobuf_ShutdownFile_cockroach_2fproto_2finternal_2eproto();

  void InitAsDefaultInstance();
  static InternalTruncateLogResponse* default_instance_;
};
// -------------------------------------------------------------------

class InternalLeaderLeaseRequest : public ::google::protobuf::Message {
 public:
  InternalLeaderLeaseRequest();
  virtual ~InternalLeaderLeaseRequest();

  InternalLeaderLeaseRequest(const InternalLeaderLeaseRequest& from);

  inline InternalLeaderLeaseRequest& operator=(const InternalLeaderLeaseRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const InternalLeaderLeaseRequest& default_instance();

  void Swap(InternalLeaderLeaseRequest* other);

  // implements Message ----------------------------------------------

  InternalLeaderLeaseRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const InternalLeaderLeaseRequest& from);
  void MergeFrom(const InternalLeaderLeaseRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .cockroach.proto.RequestHeader header = 1;
  inline bool has_header() const;
  inline void clear_header();
  static const int kHeaderFieldNumber = 1;
  inline const ::cockroach::proto::RequestHeader& header() const;
  inline ::cockroach::proto::RequestHeader* mutable_header();
  inline ::cockroach::proto::RequestHeader* release_header();
  inline void set_allocated_header(::cockroach::proto::RequestHeader* header);

  // optional .cockroach.proto.Lease lease = 2;
  inline bool has_lease() const;
  inline void clear_lease();
  static const int kLeaseFieldNumber = 2;
  inline const ::cockroach::proto::Lease& lease() const;
  inline ::cockroach::proto::Lease* mutable_lease();
  inline ::cockroach::proto::Lease* release_lease();
  inline void set_allocated_lease(::cockroach::proto::Lease* lease);

  // @@protoc_insertion_point(class_scope:cockroach.proto.InternalLeaderLeaseRequest)
 private:
  inline void set_has_header();
  inline void clear_has_header();
  inline void set_has_lease();
  inline void clear_has_lease();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::cockroach::proto::RequestHeader* header_;
  ::cockroach::proto::Lease* lease_;
  friend void  protobuf_AddDesc_cockroach_2fproto_2finternal_2eproto();
  friend void protobuf_AssignDesc_cockroach_2fproto_2finternal_2eproto();
  friend void protobuf_ShutdownFile_cockroach_2fproto_2finternal_2eproto();

  void InitAsDefaultInstance();
  static InternalLeaderLeaseRequest* default_instance_;
};
// -------------------------------------------------------------------

class InternalLeaderLeaseResponse : public ::google::protobuf::Message {
 public:
  InternalLeaderLeaseResponse();
  virtual ~InternalLeaderLeaseResponse();

  InternalLeaderLeaseResponse(const InternalLeaderLeaseResponse& from);

  inline InternalLeaderLeaseResponse& operator=(const InternalLeaderLeaseResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const InternalLeaderLeaseResponse& default_instance();

  void Swap(InternalLeaderLeaseResponse* other);

  // implements Message ----------------------------------------------

  InternalLeaderLeaseResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const InternalLeaderLeaseResponse& from);
  void MergeFrom(const InternalLeaderLeaseResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .cockroach.proto.ResponseHeader header = 1;
  inline bool has_header() const;
  inline void clear_header();
  static const int kHeaderFieldNumber = 1;
  inline const ::cockroach::proto::ResponseHeader& header() const;
  inline ::cockroach::proto::ResponseHeader* mutable_header();
  inline ::cockroach::proto::ResponseHeader* release_header();
  inline void set_allocated_header(::cockroach::proto::ResponseHeader* header);

  // @@protoc_insertion_point(class_scope:cockroach.proto.InternalLeaderLeaseResponse)
 private:
  inline void set_has_header();
  inline void clear_has_header();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::cockroach::proto::ResponseHeader* header_;
  friend void  protobuf_AddDesc_cockroach_2fproto_2finternal_2eproto();
  friend void protobuf_AssignDesc_cockroach_2fproto_2finternal_2eproto();
  friend void protobuf_ShutdownFile_cockroach_2fproto_2finternal_2eproto();

  void InitAsDefaultInstance();
  static InternalLeaderLeaseResponse* default_instance_;
};
// -------------------------------------------------------------------

class InternalRequestUnion : public ::google::protobuf::Message {
 public:
  InternalRequestUnion();
  virtual ~InternalRequestUnion();

  InternalRequestUnion(const InternalRequestUnion& from);

  inline InternalRequestUnion& operator=(const InternalRequestUnion& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const InternalRequestUnion& default_instance();

  enum ValueCase {
    kGet = 2,
    kPut = 3,
    kConditionalPut = 4,
    kIncrement = 5,
    kDelete = 6,
    kDeleteRange = 7,
    kScan = 8,
    kEndTransaction = 9,
    kInternalPushTxn = 30,
    kInternalResolveIntent = 31,
    kInternalResolveIntentRange = 32,
    VALUE_NOT_SET = 0,
  };

  void Swap(InternalRequestUnion* other);

  // implements Message ----------------------------------------------

  InternalRequestUnion* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const InternalRequestUnion& from);
  void MergeFrom(const InternalRequestUnion& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .cockroach.proto.GetRequest get = 2;
  inline bool has_get() const;
  inline void clear_get();
  static const int kGetFieldNumber = 2;
  inline const ::cockroach::proto::GetRequest& get() const;
  inline ::cockroach::proto::GetRequest* mutable_get();
  inline ::cockroach::proto::GetRequest* release_get();
  inline void set_allocated_get(::cockroach::proto::GetRequest* get);

  // optional .cockroach.proto.PutRequest put = 3;
  inline bool has_put() const;
  inline void clear_put();
  static const int kPutFieldNumber = 3;
  inline const ::cockroach::proto::PutRequest& put() const;
  inline ::cockroach::proto::PutRequest* mutable_put();
  inline ::cockroach::proto::PutRequest* release_put();
  inline void set_allocated_put(::cockroach::proto::PutRequest* put);

  // optional .cockroach.proto.ConditionalPutRequest conditional_put = 4;
  inline bool has_conditional_put() const;
  inline void clear_conditional_put();
  static const int kConditionalPutFieldNumber = 4;
  inline const ::cockroach::proto::ConditionalPutRequest& conditional_put() const;
  inline ::cockroach::proto::ConditionalPutRequest* mutable_conditional_put();
  inline ::cockroach::proto::ConditionalPutRequest* release_conditional_put();
  inline void set_allocated_conditional_put(::cockroach::proto::ConditionalPutRequest* conditional_put);

  // optional .cockroach.proto.IncrementRequest increment = 5;
  inline bool has_increment() const;
  inline void clear_increment();
  static const int kIncrementFieldNumber = 5;
  inline const ::cockroach::proto::IncrementRequest& increment() const;
  inline ::cockroach::proto::IncrementRequest* mutable_increment();
  inline ::cockroach::proto::IncrementRequest* release_increment();
  inline void set_allocated_increment(::cockroach::proto::IncrementRequest* increment);

  // optional .cockroach.proto.DeleteRequest delete = 6;
  inline bool has_delete_() const;
  inline void clear_delete_();
  static const int kDeleteFieldNumber = 6;
  inline const ::cockroach::proto::DeleteRequest& delete_() const;
  inline ::cockroach::proto::DeleteRequest* mutable_delete_();
  inline ::cockroach::proto::DeleteRequest* release_delete_();
  inline void set_allocated_delete_(::cockroach::proto::DeleteRequest* delete_);

  // optional .cockroach.proto.DeleteRangeRequest delete_range = 7;
  inline bool has_delete_range() const;
  inline void clear_delete_range();
  static const int kDeleteRangeFieldNumber = 7;
  inline const ::cockroach::proto::DeleteRangeRequest& delete_range() const;
  inline ::cockroach::proto::DeleteRangeRequest* mutable_delete_range();
  inline ::cockroach::proto::DeleteRangeRequest* release_delete_range();
  inline void set_allocated_delete_range(::cockroach::proto::DeleteRangeRequest* delete_range);

  // optional .cockroach.proto.ScanRequest scan = 8;
  inline bool has_scan() const;
  inline void clear_scan();
  static const int kScanFieldNumber = 8;
  inline const ::cockroach::proto::ScanRequest& scan() const;
  inline ::cockroach::proto::ScanRequest* mutable_scan();
  inline ::cockroach::proto::ScanRequest* release_scan();
  inline void set_allocated_scan(::cockroach::proto::ScanRequest* scan);

  // optional .cockroach.proto.EndTransactionRequest end_transaction = 9;
  inline bool has_end_transaction() const;
  inline void clear_end_transaction();
  static const int kEndTransactionFieldNumber = 9;
  inline const ::cockroach::proto::EndTransactionRequest& end_transaction() const;
  inline ::cockroach::proto::EndTransactionRequest* mutable_end_transaction();
  inline ::cockroach::proto::EndTransactionRequest* release_end_transaction();
  inline void set_allocated_end_transaction(::cockroach::proto::EndTransactionRequest* end_transaction);

  // optional .cockroach.proto.InternalPushTxnRequest internal_push_txn = 30;
  inline bool has_internal_push_txn() const;
  inline void clear_internal_push_txn();
  static const int kInternalPushTxnFieldNumber = 30;
  inline const ::cockroach::proto::InternalPushTxnRequest& internal_push_txn() const;
  inline ::cockroach::proto::InternalPushTxnRequest* mutable_internal_push_txn();
  inline ::cockroach::proto::InternalPushTxnRequest* release_internal_push_txn();
  inline void set_allocated_internal_push_txn(::cockroach::proto::InternalPushTxnRequest* internal_push_txn);

  // optional .cockroach.proto.InternalResolveIntentRequest internal_resolve_intent = 31;
  inline bool has_internal_resolve_intent() const;
  inline void clear_internal_resolve_intent();
  static const int kInternalResolveIntentFieldNumber = 31;
  inline const ::cockroach::proto::InternalResolveIntentRequest& internal_resolve_intent() const;
  inline ::cockroach::proto::InternalResolveIntentRequest* mutable_internal_resolve_intent();
  inline ::cockroach::proto::InternalResolveIntentRequest* release_internal_resolve_intent();
  inline void set_allocated_internal_resolve_intent(::cockroach::proto::InternalResolveIntentRequest* internal_resolve_intent);

  // optional .cockroach.proto.InternalResolveIntentRangeRequest internal_resolve_intent_range = 32;
  inline bool has_internal_resolve_intent_range() const;
  inline void clear_internal_resolve_intent_range();
  static const int kInternalResolveIntentRangeFieldNumber = 32;
  inline const ::cockroach::proto::InternalResolveIntentRangeRequest& internal_resolve_intent_range() const;
  inline ::cockroach::proto::InternalResolveIntentRangeRequest* mutable_internal_resolve_intent_range();
  inline ::cockroach::proto::InternalResolveIntentRangeRequest* release_internal_resolve_intent_range();
  inline void set_allocated_internal_resolve_intent_range(::cockroach::proto::InternalResolveIntentRangeRequest* internal_resolve_intent_range);

  inline ValueCase value_case() const;
  // @@protoc_insertion_point(class_scope:cockroach.proto.InternalRequestUnion)
 private:
  inline void set_has_get();
  inline void set_has_put();
  inline void set_has_conditional_put();
  inline void set_has_increment();
  inline void set_has_delete_();
  inline void set_has_delete_range();
  inline void set_has_scan();
  inline void set_has_end_transaction();
  inline void set_has_internal_push_txn();
  inline void set_has_internal_resolve_intent();
  inline void set_has_internal_resolve_intent_range();

  inline bool has_value();
  void clear_value();
  inline void clear_has_value();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  union ValueUnion {
    ::cockroach::proto::GetRequest* get_;
    ::cockroach::proto::PutRequest* put_;
    ::cockroach::proto::ConditionalPutRequest* conditional_put_;
    ::cockroach::proto::IncrementRequest* increment_;
    ::cockroach::proto::DeleteRequest* delete__;
    ::cockroach::proto::DeleteRangeRequest* delete_range_;
    ::cockroach::proto::ScanRequest* scan_;
    ::cockroach::proto::EndTransactionRequest* end_transaction_;
    ::cockroach::proto::InternalPushTxnRequest* internal_push_txn_;
    ::cockroach::proto::InternalResolveIntentRequest* internal_resolve_intent_;
    ::cockroach::proto::InternalResolveIntentRangeRequest* internal_resolve_intent_range_;
  } value_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend void  protobuf_AddDesc_cockroach_2fproto_2finternal_2eproto();
  friend void protobuf_AssignDesc_cockroach_2fproto_2finternal_2eproto();
  friend void protobuf_ShutdownFile_cockroach_2fproto_2finternal_2eproto();

  void InitAsDefaultInstance();
  static InternalRequestUnion* default_instance_;
};
// -------------------------------------------------------------------

class InternalResponseUnion : public ::google::protobuf::Message {
 public:
  InternalResponseUnion();
  virtual ~InternalResponseUnion();

  InternalResponseUnion(const InternalResponseUnion& from);

  inline InternalResponseUnion& operator=(const InternalResponseUnion& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const InternalResponseUnion& default_instance();

  enum ValueCase {
    kGet = 2,
    kPut = 3,
    kConditionalPut = 4,
    kIncrement = 5,
    kDelete = 6,
    kDeleteRange = 7,
    kScan = 8,
    kEndTransaction = 9,
    kInternalPushTxn = 30,
    kInternalResolveIntent = 31,
    kInternalResolveIntentRange = 32,
    VALUE_NOT_SET = 0,
  };

  void Swap(InternalResponseUnion* other);

  // implements Message ----------------------------------------------

  InternalResponseUnion* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const InternalResponseUnion& from);
  void MergeFrom(const InternalResponseUnion& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .cockroach.proto.GetResponse get = 2;
  inline bool has_get() const;
  inline void clear_get();
  static const int kGetFieldNumber = 2;
  inline const ::cockroach::proto::GetResponse& get() const;
  inline ::cockroach::proto::GetResponse* mutable_get();
  inline ::cockroach::proto::GetResponse* release_get();
  inline void set_allocated_get(::cockroach::proto::GetResponse* get);

  // optional .cockroach.proto.PutResponse put = 3;
  inline bool has_put() const;
  inline void clear_put();
  static const int kPutFieldNumber = 3;
  inline const ::cockroach::proto::PutResponse& put() const;
  inline ::cockroach::proto::PutResponse* mutable_put();
  inline ::cockroach::proto::PutResponse* release_put();
  inline void set_allocated_put(::cockroach::proto::PutResponse* put);

  // optional .cockroach.proto.ConditionalPutResponse conditional_put = 4;
  inline bool has_conditional_put() const;
  inline void clear_conditional_put();
  static const int kConditionalPutFieldNumber = 4;
  inline const ::cockroach::proto::ConditionalPutResponse& conditional_put() const;
  inline ::cockroach::proto::ConditionalPutResponse* mutable_conditional_put();
  inline ::cockroach::proto::ConditionalPutResponse* release_conditional_put();
  inline void set_allocated_conditional_put(::cockroach::proto::ConditionalPutResponse* conditional_put);

  // optional .cockroach.proto.IncrementResponse increment = 5;
  inline bool has_increment() const;
  inline void clear_increment();
  static const int kIncrementFieldNumber = 5;
  inline const ::cockroach::proto::IncrementResponse& increment() const;
  inline ::cockroach::proto::IncrementResponse* mutable_increment();
  inline ::cockroach::proto::IncrementResponse* release_increment();
  inline void set_allocated_increment(::cockroach::proto::IncrementResponse* increment);

  // optional .cockroach.proto.DeleteResponse delete = 6;
  inline bool has_delete_() const;
  inline void clear_delete_();
  static const int kDeleteFieldNumber = 6;
  inline const ::cockroach::proto::DeleteResponse& delete_() const;
  inline ::cockroach::proto::DeleteResponse* mutable_delete_();
  inline ::cockroach::proto::DeleteResponse* release_delete_();
  inline void set_allocated_delete_(::cockroach::proto::DeleteResponse* delete_);

  // optional .cockroach.proto.DeleteRangeResponse delete_range = 7;
  inline bool has_delete_range() const;
  inline void clear_delete_range();
  static const int kDeleteRangeFieldNumber = 7;
  inline const ::cockroach::proto::DeleteRangeResponse& delete_range() const;
  inline ::cockroach::proto::DeleteRangeResponse* mutable_delete_range();
  inline ::cockroach::proto::DeleteRangeResponse* release_delete_range();
  inline void set_allocated_delete_range(::cockroach::proto::DeleteRangeResponse* delete_range);

  // optional .cockroach.proto.ScanResponse scan = 8;
  inline bool has_scan() const;
  inline void clear_scan();
  static const int kScanFieldNumber = 8;
  inline const ::cockroach::proto::ScanResponse& scan() const;
  inline ::cockroach::proto::ScanResponse* mutable_scan();
  inline ::cockroach::proto::ScanResponse* release_scan();
  inline void set_allocated_scan(::cockroach::proto::ScanResponse* scan);

  // optional .cockroach.proto.EndTransactionResponse end_transaction = 9;
  inline bool has_end_transaction() const;
  inline void clear_end_transaction();
  static const int kEndTransactionFieldNumber = 9;
  inline const ::cockroach::proto::EndTransactionResponse& end_transaction() const;
  inline ::cockroach::proto::EndTransactionResponse* mutable_end_transaction();
  inline ::cockroach::proto::EndTransactionResponse* release_end_transaction();
  inline void set_allocated_end_transaction(::cockroach::proto::EndTransactionResponse* end_transaction);

  // optional .cockroach.proto.InternalPushTxnResponse internal_push_txn = 30;
  inline bool has_internal_push_txn() const;
  inline void clear_internal_push_txn();
  static const int kInternalPushTxnFieldNumber = 30;
  inline const ::cockroach::proto::InternalPushTxnResponse& internal_push_txn() const;
  inline ::cockroach::proto::InternalPushTxnResponse* mutable_internal_push_txn();
  inline ::cockroach::proto::InternalPushTxnResponse* release_internal_push_txn();
  inline void set_allocated_internal_push_txn(::cockroach::proto::InternalPushTxnResponse* internal_push_txn);

  // optional .cockroach.proto.InternalResolveIntentResponse internal_resolve_intent = 31;
  inline bool has_internal_resolve_intent() const;
  inline void clear_internal_resolve_intent();
  static const int kInternalResolveIntentFieldNumber = 31;
  inline const ::cockroach::proto::InternalResolveIntentResponse& internal_resolve_intent() const;
  inline ::cockroach::proto::InternalResolveIntentResponse* mutable_internal_resolve_intent();
  inline ::cockroach::proto::InternalResolveIntentResponse* release_internal_resolve_intent();
  inline void set_allocated_internal_resolve_intent(::cockroach::proto::InternalResolveIntentResponse* internal_resolve_intent);

  // optional .cockroach.proto.InternalResolveIntentRangeResponse internal_resolve_intent_range = 32;
  inline bool has_internal_resolve_intent_range() const;
  inline void clear_internal_resolve_intent_range();
  static const int kInternalResolveIntentRangeFieldNumber = 32;
  inline const ::cockroach::proto::InternalResolveIntentRangeResponse& internal_resolve_intent_range() const;
  inline ::cockroach::proto::InternalResolveIntentRangeResponse* mutable_internal_resolve_intent_range();
  inline ::cockroach::proto::InternalResolveIntentRangeResponse* release_internal_resolve_intent_range();
  inline void set_allocated_internal_resolve_intent_range(::cockroach::proto::InternalResolveIntentRangeResponse* internal_resolve_intent_range);

  inline ValueCase value_case() const;
  // @@protoc_insertion_point(class_scope:cockroach.proto.InternalResponseUnion)
 private:
  inline void set_has_get();
  inline void set_has_put();
  inline void set_has_conditional_put();
  inline void set_has_increment();
  inline void set_has_delete_();
  inline void set_has_delete_range();
  inline void set_has_scan();
  inline void set_has_end_transaction();
  inline void set_has_internal_push_txn();
  inline void set_has_internal_resolve_intent();
  inline void set_has_internal_resolve_intent_range();

  inline bool has_value();
  void clear_value();
  inline void clear_has_value();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  union ValueUnion {
    ::cockroach::proto::GetResponse* get_;
    ::cockroach::proto::PutResponse* put_;
    ::cockroach::proto::ConditionalPutResponse* conditional_put_;
    ::cockroach::proto::IncrementResponse* increment_;
    ::cockroach::proto::DeleteResponse* delete__;
    ::cockroach::proto::DeleteRangeResponse* delete_range_;
    ::cockroach::proto::ScanResponse* scan_;
    ::cockroach::proto::EndTransactionResponse* end_transaction_;
    ::cockroach::proto::InternalPushTxnResponse* internal_push_txn_;
    ::cockroach::proto::InternalResolveIntentResponse* internal_resolve_intent_;
    ::cockroach::proto::InternalResolveIntentRangeResponse* internal_resolve_intent_range_;
  } value_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend void  protobuf_AddDesc_cockroach_2fproto_2finternal_2eproto();
  friend void protobuf_AssignDesc_cockroach_2fproto_2finternal_2eproto();
  friend void protobuf_ShutdownFile_cockroach_2fproto_2finternal_2eproto();

  void InitAsDefaultInstance();
  static InternalResponseUnion* default_instance_;
};
// -------------------------------------------------------------------

class InternalBatchRequest : public ::google::protobuf::Message {
 public:
  InternalBatchRequest();
  virtual ~InternalBatchRequest();

  InternalBatchRequest(const InternalBatchRequest& from);

  inline InternalBatchRequest& operator=(const InternalBatchRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const InternalBatchRequest& default_instance();

  void Swap(InternalBatchRequest* other);

  // implements Message ----------------------------------------------

  InternalBatchRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const InternalBatchRequest& from);
  void MergeFrom(const InternalBatchRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .cockroach.proto.RequestHeader header = 1;
  inline bool has_header() const;
  inline void clear_header();
  static const int kHeaderFieldNumber = 1;
  inline const ::cockroach::proto::RequestHeader& header() const;
  inline ::cockroach::proto::RequestHeader* mutable_header();
  inline ::cockroach::proto::RequestHeader* release_header();
  inline void set_allocated_header(::cockroach::proto::RequestHeader* header);

  // repeated .cockroach.proto.InternalRequestUnion requests = 2;
  inline int requests_size() const;
  inline void clear_requests();
  static const int kRequestsFieldNumber = 2;
  inline const ::cockroach::proto::InternalRequestUnion& requests(int index) const;
  inline ::cockroach::proto::InternalRequestUnion* mutable_requests(int index);
  inline ::cockroach::proto::InternalRequestUnion* add_requests();
  inline const ::google::protobuf::RepeatedPtrField< ::cockroach::proto::InternalRequestUnion >&
      requests() const;
  inline ::google::protobuf::RepeatedPtrField< ::cockroach::proto::InternalRequestUnion >*
      mutable_requests();

  // @@protoc_insertion_point(class_scope:cockroach.proto.InternalBatchRequest)
 private:
  inline void set_has_header();
  inline void clear_has_header();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::cockroach::proto::RequestHeader* header_;
  ::google::protobuf::RepeatedPtrField< ::cockroach::proto::InternalRequestUnion > requests_;
  friend void  protobuf_AddDesc_cockroach_2fproto_2finternal_2eproto();
  friend void protobuf_AssignDesc_cockroach_2fproto_2finternal_2eproto();
  friend void protobuf_ShutdownFile_cockroach_2fproto_2finternal_2eproto();

  void InitAsDefaultInstance();
  static InternalBatchRequest* default_instance_;
};
// -------------------------------------------------------------------

class InternalBatchResponse : public ::google::protobuf::Message {
 public:
  InternalBatchResponse();
  virtual ~InternalBatchResponse();

  InternalBatchResponse(const InternalBatchResponse& from);

  inline InternalBatchResponse& operator=(const InternalBatchResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const InternalBatchResponse& default_instance();

  void Swap(InternalBatchResponse* other);

  // implements Message ----------------------------------------------

  InternalBatchResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const InternalBatchResponse& from);
  void MergeFrom(const InternalBatchResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .cockroach.proto.ResponseHeader header = 1;
  inline bool has_header() const;
  inline void clear_header();
  static const int kHeaderFieldNumber = 1;
  inline const ::cockroach::proto::ResponseHeader& header() const;
  inline ::cockroach::proto::ResponseHeader* mutable_header();
  inline ::cockroach::proto::ResponseHeader* release_header();
  inline void set_allocated_header(::cockroach::proto::ResponseHeader* header);

  // repeated .cockroach.proto.InternalResponseUnion responses = 2;
  inline int responses_size() const;
  inline void clear_responses();
  static const int kResponsesFieldNumber = 2;
  inline const ::cockroach::proto::InternalResponseUnion& responses(int index) const;
  inline ::cockroach::proto::InternalResponseUnion* mutable_responses(int index);
  inline ::cockroach::proto::InternalResponseUnion* add_responses();
  inline const ::google::protobuf::RepeatedPtrField< ::cockroach::proto::InternalResponseUnion >&
      responses() const;
  inline ::google::protobuf::RepeatedPtrField< ::cockroach::proto::InternalResponseUnion >*
      mutable_responses();

  // @@protoc_insertion_point(class_scope:cockroach.proto.InternalBatchResponse)
 private:
  inline void set_has_header();
  inline void clear_has_header();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::cockroach::proto::ResponseHeader* header_;
  ::google::protobuf::RepeatedPtrField< ::cockroach::proto::InternalResponseUnion > responses_;
  friend void  protobuf_AddDesc_cockroach_2fproto_2finternal_2eproto();
  friend void protobuf_AssignDesc_cockroach_2fproto_2finternal_2eproto();
  friend void protobuf_ShutdownFile_cockroach_2fproto_2finternal_2eproto();

  void InitAsDefaultInstance();
  static InternalBatchResponse* default_instance_;
};
// -------------------------------------------------------------------

class ReadWriteCmdResponse : public ::google::protobuf::Message {
 public:
  ReadWriteCmdResponse();
  virtual ~ReadWriteCmdResponse();

  ReadWriteCmdResponse(const ReadWriteCmdResponse& from);

  inline ReadWriteCmdResponse& operator=(const ReadWriteCmdResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ReadWriteCmdResponse& default_instance();

  enum ValueCase {
    kPut = 1,
    kConditionalPut = 2,
    kIncrement = 3,
    kDelete = 4,
    kDeleteRange = 5,
    kEndTransaction = 6,
    kInternalHeartbeatTxn = 10,
    kInternalPushTxn = 11,
    kInternalResolveIntent = 12,
    kInternalResolveIntentRange = 13,
    kInternalMerge = 14,
    kInternalTruncateLog = 15,
    kInternalGc = 16,
    kInternalLeaderLease = 17,
    VALUE_NOT_SET = 0,
  };

  void Swap(ReadWriteCmdResponse* other);

  // implements Message ----------------------------------------------

  ReadWriteCmdResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReadWriteCmdResponse& from);
  void MergeFrom(const ReadWriteCmdResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .cockroach.proto.PutResponse put = 1;
  inline bool has_put() const;
  inline void clear_put();
  static const int kPutFieldNumber = 1;
  inline const ::cockroach::proto::PutResponse& put() const;
  inline ::cockroach::proto::PutResponse* mutable_put();
  inline ::cockroach::proto::PutResponse* release_put();
  inline void set_allocated_put(::cockroach::proto::PutResponse* put);

  // optional .cockroach.proto.ConditionalPutResponse conditional_put = 2;
  inline bool has_conditional_put() const;
  inline void clear_conditional_put();
  static const int kConditionalPutFieldNumber = 2;
  inline const ::cockroach::proto::ConditionalPutResponse& conditional_put() const;
  inline ::cockroach::proto::ConditionalPutResponse* mutable_conditional_put();
  inline ::cockroach::proto::ConditionalPutResponse* release_conditional_put();
  inline void set_allocated_conditional_put(::cockroach::proto::ConditionalPutResponse* conditional_put);

  // optional .cockroach.proto.IncrementResponse increment = 3;
  inline bool has_increment() const;
  inline void clear_increment();
  static const int kIncrementFieldNumber = 3;
  inline const ::cockroach::proto::IncrementResponse& increment() const;
  inline ::cockroach::proto::IncrementResponse* mutable_increment();
  inline ::cockroach::proto::IncrementResponse* release_increment();
  inline void set_allocated_increment(::cockroach::proto::IncrementResponse* increment);

  // optional .cockroach.proto.DeleteResponse delete = 4;
  inline bool has_delete_() const;
  inline void clear_delete_();
  static const int kDeleteFieldNumber = 4;
  inline const ::cockroach::proto::DeleteResponse& delete_() const;
  inline ::cockroach::proto::DeleteResponse* mutable_delete_();
  inline ::cockroach::proto::DeleteResponse* release_delete_();
  inline void set_allocated_delete_(::cockroach::proto::DeleteResponse* delete_);

  // optional .cockroach.proto.DeleteRangeResponse delete_range = 5;
  inline bool has_delete_range() const;
  inline void clear_delete_range();
  static const int kDeleteRangeFieldNumber = 5;
  inline const ::cockroach::proto::DeleteRangeResponse& delete_range() const;
  inline ::cockroach::proto::DeleteRangeResponse* mutable_delete_range();
  inline ::cockroach::proto::DeleteRangeResponse* release_delete_range();
  inline void set_allocated_delete_range(::cockroach::proto::DeleteRangeResponse* delete_range);

  // optional .cockroach.proto.EndTransactionResponse end_transaction = 6;
  inline bool has_end_transaction() const;
  inline void clear_end_transaction();
  static const int kEndTransactionFieldNumber = 6;
  inline const ::cockroach::proto::EndTransactionResponse& end_transaction() const;
  inline ::cockroach::proto::EndTransactionResponse* mutable_end_transaction();
  inline ::cockroach::proto::EndTransactionResponse* release_end_transaction();
  inline void set_allocated_end_transaction(::cockroach::proto::EndTransactionResponse* end_transaction);

  // optional .cockroach.proto.InternalHeartbeatTxnResponse internal_heartbeat_txn = 10;
  inline bool has_internal_heartbeat_txn() const;
  inline void clear_internal_heartbeat_txn();
  static const int kInternalHeartbeatTxnFieldNumber = 10;
  inline const ::cockroach::proto::InternalHeartbeatTxnResponse& internal_heartbeat_txn() const;
  inline ::cockroach::proto::InternalHeartbeatTxnResponse* mutable_internal_heartbeat_txn();
  inline ::cockroach::proto::InternalHeartbeatTxnResponse* release_internal_heartbeat_txn();
  inline void set_allocated_internal_heartbeat_txn(::cockroach::proto::InternalHeartbeatTxnResponse* internal_heartbeat_txn);

  // optional .cockroach.proto.InternalPushTxnResponse internal_push_txn = 11;
  inline bool has_internal_push_txn() const;
  inline void clear_internal_push_txn();
  static const int kInternalPushTxnFieldNumber = 11;
  inline const ::cockroach::proto::InternalPushTxnResponse& internal_push_txn() const;
  inline ::cockroach::proto::InternalPushTxnResponse* mutable_internal_push_txn();
  inline ::cockroach::proto::InternalPushTxnResponse* release_internal_push_txn();
  inline void set_allocated_internal_push_txn(::cockroach::proto::InternalPushTxnResponse* internal_push_txn);

  // optional .cockroach.proto.InternalResolveIntentResponse internal_resolve_intent = 12;
  inline bool has_internal_resolve_intent() const;
  inline void clear_internal_resolve_intent();
  static const int kInternalResolveIntentFieldNumber = 12;
  inline const ::cockroach::proto::InternalResolveIntentResponse& internal_resolve_intent() const;
  inline ::cockroach::proto::InternalResolveIntentResponse* mutable_internal_resolve_intent();
  inline ::cockroach::proto::InternalResolveIntentResponse* release_internal_resolve_intent();
  inline void set_allocated_internal_resolve_intent(::cockroach::proto::InternalResolveIntentResponse* internal_resolve_intent);

  // optional .cockroach.proto.InternalResolveIntentRangeResponse internal_resolve_intent_range = 13;
  inline bool has_internal_resolve_intent_range() const;
  inline void clear_internal_resolve_intent_range();
  static const int kInternalResolveIntentRangeFieldNumber = 13;
  inline const ::cockroach::proto::InternalResolveIntentRangeResponse& internal_resolve_intent_range() const;
  inline ::cockroach::proto::InternalResolveIntentRangeResponse* mutable_internal_resolve_intent_range();
  inline ::cockroach::proto::InternalResolveIntentRangeResponse* release_internal_resolve_intent_range();
  inline void set_allocated_internal_resolve_intent_range(::cockroach::proto::InternalResolveIntentRangeResponse* internal_resolve_intent_range);

  // optional .cockroach.proto.InternalMergeResponse internal_merge = 14;
  inline bool has_internal_merge() const;
  inline void clear_internal_merge();
  static const int kInternalMergeFieldNumber = 14;
  inline const ::cockroach::proto::InternalMergeResponse& internal_merge() const;
  inline ::cockroach::proto::InternalMergeResponse* mutable_internal_merge();
  inline ::cockroach::proto::InternalMergeResponse* release_internal_merge();
  inline void set_allocated_internal_merge(::cockroach::proto::InternalMergeResponse* internal_merge);

  // optional .cockroach.proto.InternalTruncateLogResponse internal_truncate_log = 15;
  inline bool has_internal_truncate_log() const;
  inline void clear_internal_truncate_log();
  static const int kInternalTruncateLogFieldNumber = 15;
  inline const ::cockroach::proto::InternalTruncateLogResponse& internal_truncate_log() const;
  inline ::cockroach::proto::InternalTruncateLogResponse* mutable_internal_truncate_log();
  inline ::cockroach::proto::InternalTruncateLogResponse* release_internal_truncate_log();
  inline void set_allocated_internal_truncate_log(::cockroach::proto::InternalTruncateLogResponse* internal_truncate_log);

  // optional .cockroach.proto.InternalGCResponse internal_gc = 16;
  inline bool has_internal_gc() const;
  inline void clear_internal_gc();
  static const int kInternalGcFieldNumber = 16;
  inline const ::cockroach::proto::InternalGCResponse& internal_gc() const;
  inline ::cockroach::proto::InternalGCResponse* mutable_internal_gc();
  inline ::cockroach::proto::InternalGCResponse* release_internal_gc();
  inline void set_allocated_internal_gc(::cockroach::proto::InternalGCResponse* internal_gc);

  // optional .cockroach.proto.InternalLeaderLeaseResponse internal_leader_lease = 17;
  inline bool has_internal_leader_lease() const;
  inline void clear_internal_leader_lease();
  static const int kInternalLeaderLeaseFieldNumber = 17;
  inline const ::cockroach::proto::InternalLeaderLeaseResponse& internal_leader_lease() const;
  inline ::cockroach::proto::InternalLeaderLeaseResponse* mutable_internal_leader_lease();
  inline ::cockroach::proto::InternalLeaderLeaseResponse* release_internal_leader_lease();
  inline void set_allocated_internal_leader_lease(::cockroach::proto::InternalLeaderLeaseResponse* internal_leader_lease);

  inline ValueCase value_case() const;
  // @@protoc_insertion_point(class_scope:cockroach.proto.ReadWriteCmdResponse)
 private:
  inline void set_has_put();
  inline void set_has_conditional_put();
  inline void set_has_increment();
  inline void set_has_delete_();
  inline void set_has_delete_range();
  inline void set_has_end_transaction();
  inline void set_has_internal_heartbeat_txn();
  inline void set_has_internal_push_txn();
  inline void set_has_internal_resolve_intent();
  inline void set_has_internal_resolve_intent_range();
  inline void set_has_internal_merge();
  inline void set_has_internal_truncate_log();
  inline void set_has_internal_gc();
  inline void set_has_internal_leader_lease();

  inline bool has_value();
  void clear_value();
  inline void clear_has_value();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  union ValueUnion {
    ::cockroach::proto::PutResponse* put_;
    ::cockroach::proto::ConditionalPutResponse* conditional_put_;
    ::cockroach::proto::IncrementResponse* increment_;
    ::cockroach::proto::DeleteResponse* delete__;
    ::cockroach::proto::DeleteRangeResponse* delete_range_;
    ::cockroach::proto::EndTransactionResponse* end_transaction_;
    ::cockroach::proto::InternalHeartbeatTxnResponse* internal_heartbeat_txn_;
    ::cockroach::proto::InternalPushTxnResponse* internal_push_txn_;
    ::cockroach::proto::InternalResolveIntentResponse* internal_resolve_intent_;
    ::cockroach::proto::InternalResolveIntentRangeResponse* internal_resolve_intent_range_;
    ::cockroach::proto::InternalMergeResponse* internal_merge_;
    ::cockroach::proto::InternalTruncateLogResponse* internal_truncate_log_;
    ::cockroach::proto::InternalGCResponse* internal_gc_;
    ::cockroach::proto::InternalLeaderLeaseResponse* internal_leader_lease_;
  } value_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend void  protobuf_AddDesc_cockroach_2fproto_2finternal_2eproto();
  friend void protobuf_AssignDesc_cockroach_2fproto_2finternal_2eproto();
  friend void protobuf_ShutdownFile_cockroach_2fproto_2finternal_2eproto();

  void InitAsDefaultInstance();
  static ReadWriteCmdResponse* default_instance_;
};
// -------------------------------------------------------------------

class InternalRaftCommandUnion : public ::google::protobuf::Message {
 public:
  InternalRaftCommandUnion();
  virtual ~InternalRaftCommandUnion();

  InternalRaftCommandUnion(const InternalRaftCommandUnion& from);

  inline InternalRaftCommandUnion& operator=(const InternalRaftCommandUnion& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const InternalRaftCommandUnion& default_instance();

  enum ValueCase {
    kGet = 2,
    kPut = 3,
    kConditionalPut = 4,
    kIncrement = 5,
    kDelete = 6,
    kDeleteRange = 7,
    kScan = 8,
    kEndTransaction = 9,
    kBatch = 30,
    kInternalRangeLookup = 31,
    kInternalHeartbeatTxn = 32,
    kInternalPushTxn = 33,
    kInternalResolveIntent = 34,
    kInternalResolveIntentRange = 35,
    kInternalMergeResponse = 36,
    kInternalTruncateLog = 37,
    kInternalGc = 38,
    kInternalLease = 39,
    kInternalBatch = 40,
    VALUE_NOT_SET = 0,
  };

  void Swap(InternalRaftCommandUnion* other);

  // implements Message ----------------------------------------------

  InternalRaftCommandUnion* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const InternalRaftCommandUnion& from);
  void MergeFrom(const InternalRaftCommandUnion& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .cockroach.proto.GetRequest get = 2;
  inline bool has_get() const;
  inline void clear_get();
  static const int kGetFieldNumber = 2;
  inline const ::cockroach::proto::GetRequest& get() const;
  inline ::cockroach::proto::GetRequest* mutable_get();
  inline ::cockroach::proto::GetRequest* release_get();
  inline void set_allocated_get(::cockroach::proto::GetRequest* get);

  // optional .cockroach.proto.PutRequest put = 3;
  inline bool has_put() const;
  inline void clear_put();
  static const int kPutFieldNumber = 3;
  inline const ::cockroach::proto::PutRequest& put() const;
  inline ::cockroach::proto::PutRequest* mutable_put();
  inline ::cockroach::proto::PutRequest* release_put();
  inline void set_allocated_put(::cockroach::proto::PutRequest* put);

  // optional .cockroach.proto.ConditionalPutRequest conditional_put = 4;
  inline bool has_conditional_put() const;
  inline void clear_conditional_put();
  static const int kConditionalPutFieldNumber = 4;
  inline const ::cockroach::proto::ConditionalPutRequest& conditional_put() const;
  inline ::cockroach::proto::ConditionalPutRequest* mutable_conditional_put();
  inline ::cockroach::proto::ConditionalPutRequest* release_conditional_put();
  inline void set_allocated_conditional_put(::cockroach::proto::ConditionalPutRequest* conditional_put);

  // optional .cockroach.proto.IncrementRequest increment = 5;
  inline bool has_increment() const;
  inline void clear_increment();
  static const int kIncrementFieldNumber = 5;
  inline const ::cockroach::proto::IncrementRequest& increment() const;
  inline ::cockroach::proto::IncrementRequest* mutable_increment();
  inline ::cockroach::proto::IncrementRequest* release_increment();
  inline void set_allocated_increment(::cockroach::proto::IncrementRequest* increment);

  // optional .cockroach.proto.DeleteRequest delete = 6;
  inline bool has_delete_() const;
  inline void clear_delete_();
  static const int kDeleteFieldNumber = 6;
  inline const ::cockroach::proto::DeleteRequest& delete_() const;
  inline ::cockroach::proto::DeleteRequest* mutable_delete_();
  inline ::cockroach::proto::DeleteRequest* release_delete_();
  inline void set_allocated_delete_(::cockroach::proto::DeleteRequest* delete_);

  // optional .cockroach.proto.DeleteRangeRequest delete_range = 7;
  inline bool has_delete_range() const;
  inline void clear_delete_range();
  static const int kDeleteRangeFieldNumber = 7;
  inline const ::cockroach::proto::DeleteRangeRequest& delete_range() const;
  inline ::cockroach::proto::DeleteRangeRequest* mutable_delete_range();
  inline ::cockroach::proto::DeleteRangeRequest* release_delete_range();
  inline void set_allocated_delete_range(::cockroach::proto::DeleteRangeRequest* delete_range);

  // optional .cockroach.proto.ScanRequest scan = 8;
  inline bool has_scan() const;
  inline void clear_scan();
  static const int kScanFieldNumber = 8;
  inline const ::cockroach::proto::ScanRequest& scan() const;
  inline ::cockroach::proto::ScanRequest* mutable_scan();
  inline ::cockroach::proto::ScanRequest* release_scan();
  inline void set_allocated_scan(::cockroach::proto::ScanRequest* scan);

  // optional .cockroach.proto.EndTransactionRequest end_transaction = 9;
  inline bool has_end_transaction() const;
  inline void clear_end_transaction();
  static const int kEndTransactionFieldNumber = 9;
  inline const ::cockroach::proto::EndTransactionRequest& end_transaction() const;
  inline ::cockroach::proto::EndTransactionRequest* mutable_end_transaction();
  inline ::cockroach::proto::EndTransactionRequest* release_end_transaction();
  inline void set_allocated_end_transaction(::cockroach::proto::EndTransactionRequest* end_transaction);

  // optional .cockroach.proto.BatchRequest batch = 30;
  inline bool has_batch() const;
  inline void clear_batch();
  static const int kBatchFieldNumber = 30;
  inline const ::cockroach::proto::BatchRequest& batch() const;
  inline ::cockroach::proto::BatchRequest* mutable_batch();
  inline ::cockroach::proto::BatchRequest* release_batch();
  inline void set_allocated_batch(::cockroach::proto::BatchRequest* batch);

  // optional .cockroach.proto.InternalRangeLookupRequest internal_range_lookup = 31;
  inline bool has_internal_range_lookup() const;
  inline void clear_internal_range_lookup();
  static const int kInternalRangeLookupFieldNumber = 31;
  inline const ::cockroach::proto::InternalRangeLookupRequest& internal_range_lookup() const;
  inline ::cockroach::proto::InternalRangeLookupRequest* mutable_internal_range_lookup();
  inline ::cockroach::proto::InternalRangeLookupRequest* release_internal_range_lookup();
  inline void set_allocated_internal_range_lookup(::cockroach::proto::InternalRangeLookupRequest* internal_range_lookup);

  // optional .cockroach.proto.InternalHeartbeatTxnRequest internal_heartbeat_txn = 32;
  inline bool has_internal_heartbeat_txn() const;
  inline void clear_internal_heartbeat_txn();
  static const int kInternalHeartbeatTxnFieldNumber = 32;
  inline const ::cockroach::proto::InternalHeartbeatTxnRequest& internal_heartbeat_txn() const;
  inline ::cockroach::proto::InternalHeartbeatTxnRequest* mutable_internal_heartbeat_txn();
  inline ::cockroach::proto::InternalHeartbeatTxnRequest* release_internal_heartbeat_txn();
  inline void set_allocated_internal_heartbeat_txn(::cockroach::proto::InternalHeartbeatTxnRequest* internal_heartbeat_txn);

  // optional .cockroach.proto.InternalPushTxnRequest internal_push_txn = 33;
  inline bool has_internal_push_txn() const;
  inline void clear_internal_push_txn();
  static const int kInternalPushTxnFieldNumber = 33;
  inline const ::cockroach::proto::InternalPushTxnRequest& internal_push_txn() const;
  inline ::cockroach::proto::InternalPushTxnRequest* mutable_internal_push_txn();
  inline ::cockroach::proto::InternalPushTxnRequest* release_internal_push_txn();
  inline void set_allocated_internal_push_txn(::cockroach::proto::InternalPushTxnRequest* internal_push_txn);

  // optional .cockroach.proto.InternalResolveIntentRequest internal_resolve_intent = 34;
  inline bool has_internal_resolve_intent() const;
  inline void clear_internal_resolve_intent();
  static const int kInternalResolveIntentFieldNumber = 34;
  inline const ::cockroach::proto::InternalResolveIntentRequest& internal_resolve_intent() const;
  inline ::cockroach::proto::InternalResolveIntentRequest* mutable_internal_resolve_intent();
  inline ::cockroach::proto::InternalResolveIntentRequest* release_internal_resolve_intent();
  inline void set_allocated_internal_resolve_intent(::cockroach::proto::InternalResolveIntentRequest* internal_resolve_intent);

  // optional .cockroach.proto.InternalResolveIntentRangeRequest internal_resolve_intent_range = 35;
  inline bool has_internal_resolve_intent_range() const;
  inline void clear_internal_resolve_intent_range();
  static const int kInternalResolveIntentRangeFieldNumber = 35;
  inline const ::cockroach::proto::InternalResolveIntentRangeRequest& internal_resolve_intent_range() const;
  inline ::cockroach::proto::InternalResolveIntentRangeRequest* mutable_internal_resolve_intent_range();
  inline ::cockroach::proto::InternalResolveIntentRangeRequest* release_internal_resolve_intent_range();
  inline void set_allocated_internal_resolve_intent_range(::cockroach::proto::InternalResolveIntentRangeRequest* internal_resolve_intent_range);

  // optional .cockroach.proto.InternalMergeRequest internal_merge_response = 36;
  inline bool has_internal_merge_response() const;
  inline void clear_internal_merge_response();
  static const int kInternalMergeResponseFieldNumber = 36;
  inline const ::cockroach::proto::InternalMergeRequest& internal_merge_response() const;
  inline ::cockroach::proto::InternalMergeRequest* mutable_internal_merge_response();
  inline ::cockroach::proto::InternalMergeRequest* release_internal_merge_response();
  inline void set_allocated_internal_merge_response(::cockroach::proto::InternalMergeRequest* internal_merge_response);

  // optional .cockroach.proto.InternalTruncateLogRequest internal_truncate_log = 37;
  inline bool has_internal_truncate_log() const;
  inline void clear_internal_truncate_log();
  static const int kInternalTruncateLogFieldNumber = 37;
  inline const ::cockroach::proto::InternalTruncateLogRequest& internal_truncate_log() const;
  inline ::cockroach::proto::InternalTruncateLogRequest* mutable_internal_truncate_log();
  inline ::cockroach::proto::InternalTruncateLogRequest* release_internal_truncate_log();
  inline void set_allocated_internal_truncate_log(::cockroach::proto::InternalTruncateLogRequest* internal_truncate_log);

  // optional .cockroach.proto.InternalGCRequest internal_gc = 38;
  inline bool has_internal_gc() const;
  inline void clear_internal_gc();
  static const int kInternalGcFieldNumber = 38;
  inline const ::cockroach::proto::InternalGCRequest& internal_gc() const;
  inline ::cockroach::proto::InternalGCRequest* mutable_internal_gc();
  inline ::cockroach::proto::InternalGCRequest* release_internal_gc();
  inline void set_allocated_internal_gc(::cockroach::proto::InternalGCRequest* internal_gc);

  // optional .cockroach.proto.InternalLeaderLeaseRequest internal_lease = 39;
  inline bool has_internal_lease() const;
  inline void clear_internal_lease();
  static const int kInternalLeaseFieldNumber = 39;
  inline const ::cockroach::proto::InternalLeaderLeaseRequest& internal_lease() const;
  inline ::cockroach::proto::InternalLeaderLeaseRequest* mutable_internal_lease();
  inline ::cockroach::proto::InternalLeaderLeaseRequest* release_internal_lease();
  inline void set_allocated_internal_lease(::cockroach::proto::InternalLeaderLeaseRequest* internal_lease);

  // optional .cockroach.proto.InternalBatchRequest internal_batch = 40;
  inline bool has_internal_batch() const;
  inline void clear_internal_batch();
  static const int kInternalBatchFieldNumber = 40;
  inline const ::cockroach::proto::InternalBatchRequest& internal_batch() const;
  inline ::cockroach::proto::InternalBatchRequest* mutable_internal_batch();
  inline ::cockroach::proto::InternalBatchRequest* release_internal_batch();
  inline void set_allocated_internal_batch(::cockroach::proto::InternalBatchRequest* internal_batch);

  inline ValueCase value_case() const;
  // @@protoc_insertion_point(class_scope:cockroach.proto.InternalRaftCommandUnion)
 private:
  inline void set_has_get();
  inline void set_has_put();
  inline void set_has_conditional_put();
  inline void set_has_increment();
  inline void set_has_delete_();
  inline void set_has_delete_range();
  inline void set_has_scan();
  inline void set_has_end_transaction();
  inline void set_has_batch();
  inline void set_has_internal_range_lookup();
  inline void set_has_internal_heartbeat_txn();
  inline void set_has_internal_push_txn();
  inline void set_has_internal_resolve_intent();
  inline void set_has_internal_resolve_intent_range();
  inline void set_has_internal_merge_response();
  inline void set_has_internal_truncate_log();
  inline void set_has_internal_gc();
  inline void set_has_internal_lease();
  inline void set_has_internal_batch();

  inline bool has_value();
  void clear_value();
  inline void clear_has_value();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  union ValueUnion {
    ::cockroach::proto::GetRequest* get_;
    ::cockroach::proto::PutRequest* put_;
    ::cockroach::proto::ConditionalPutRequest* conditional_put_;
    ::cockroach::proto::IncrementRequest* increment_;
    ::cockroach::proto::DeleteRequest* delete__;
    ::cockroach::proto::DeleteRangeRequest* delete_range_;
    ::cockroach::proto::ScanRequest* scan_;
    ::cockroach::proto::EndTransactionRequest* end_transaction_;
    ::cockroach::proto::BatchRequest* batch_;
    ::cockroach::proto::InternalRangeLookupRequest* internal_range_lookup_;
    ::cockroach::proto::InternalHeartbeatTxnRequest* internal_heartbeat_txn_;
    ::cockroach::proto::InternalPushTxnRequest* internal_push_txn_;
    ::cockroach::proto::InternalResolveIntentRequest* internal_resolve_intent_;
    ::cockroach::proto::InternalResolveIntentRangeRequest* internal_resolve_intent_range_;
    ::cockroach::proto::InternalMergeRequest* internal_merge_response_;
    ::cockroach::proto::InternalTruncateLogRequest* internal_truncate_log_;
    ::cockroach::proto::InternalGCRequest* internal_gc_;
    ::cockroach::proto::InternalLeaderLeaseRequest* internal_lease_;
    ::cockroach::proto::InternalBatchRequest* internal_batch_;
  } value_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend void  protobuf_AddDesc_cockroach_2fproto_2finternal_2eproto();
  friend void protobuf_AssignDesc_cockroach_2fproto_2finternal_2eproto();
  friend void protobuf_ShutdownFile_cockroach_2fproto_2finternal_2eproto();

  void InitAsDefaultInstance();
  static InternalRaftCommandUnion* default_instance_;
};
// -------------------------------------------------------------------

class InternalRaftCommand : public ::google::protobuf::Message {
 public:
  InternalRaftCommand();
  virtual ~InternalRaftCommand();

  InternalRaftCommand(const InternalRaftCommand& from);

  inline InternalRaftCommand& operator=(const InternalRaftCommand& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const InternalRaftCommand& default_instance();

  void Swap(InternalRaftCommand* other);

  // implements Message ----------------------------------------------

  InternalRaftCommand* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const InternalRaftCommand& from);
  void MergeFrom(const InternalRaftCommand& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int64 raft_id = 1;
  inline bool has_raft_id() const;
  inline void clear_raft_id();
  static const int kRaftIdFieldNumber = 1;
  inline ::google::protobuf::int64 raft_id() const;
  inline void set_raft_id(::google::protobuf::int64 value);

  // optional uint64 origin_node_id = 2;
  inline bool has_origin_node_id() const;
  inline void clear_origin_node_id();
  static const int kOriginNodeIdFieldNumber = 2;
  inline ::google::protobuf::uint64 origin_node_id() const;
  inline void set_origin_node_id(::google::protobuf::uint64 value);

  // optional .cockroach.proto.InternalRaftCommandUnion cmd = 3;
  inline bool has_cmd() const;
  inline void clear_cmd();
  static const int kCmdFieldNumber = 3;
  inline const ::cockroach::proto::InternalRaftCommandUnion& cmd() const;
  inline ::cockroach::proto::InternalRaftCommandUnion* mutable_cmd();
  inline ::cockroach::proto::InternalRaftCommandUnion* release_cmd();
  inline void set_allocated_cmd(::cockroach::proto::InternalRaftCommandUnion* cmd);

  // @@protoc_insertion_point(class_scope:cockroach.proto.InternalRaftCommand)
 private:
  inline void set_has_raft_id();
  inline void clear_has_raft_id();
  inline void set_has_origin_node_id();
  inline void clear_has_origin_node_id();
  inline void set_has_cmd();
  inline void clear_has_cmd();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int64 raft_id_;
  ::google::protobuf::uint64 origin_node_id_;
  ::cockroach::proto::InternalRaftCommandUnion* cmd_;
  friend void  protobuf_AddDesc_cockroach_2fproto_2finternal_2eproto();
  friend void protobuf_AssignDesc_cockroach_2fproto_2finternal_2eproto();
  friend void protobuf_ShutdownFile_cockroach_2fproto_2finternal_2eproto();

  void InitAsDefaultInstance();
  static InternalRaftCommand* default_instance_;
};
// -------------------------------------------------------------------

class RaftMessageRequest : public ::google::protobuf::Message {
 public:
  RaftMessageRequest();
  virtual ~RaftMessageRequest();

  RaftMessageRequest(const RaftMessageRequest& from);

  inline RaftMessageRequest& operator=(const RaftMessageRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RaftMessageRequest& default_instance();

  void Swap(RaftMessageRequest* other);

  // implements Message ----------------------------------------------

  RaftMessageRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RaftMessageRequest& from);
  void MergeFrom(const RaftMessageRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 group_id = 1;
  inline bool has_group_id() const;
  inline void clear_group_id();
  static const int kGroupIdFieldNumber = 1;
  inline ::google::protobuf::uint64 group_id() const;
  inline void set_group_id(::google::protobuf::uint64 value);

  // optional bytes msg = 2;
  inline bool has_msg() const;
  inline void clear_msg();
  static const int kMsgFieldNumber = 2;
  inline const ::std::string& msg() const;
  inline void set_msg(const ::std::string& value);
  inline void set_msg(const char* value);
  inline void set_msg(const void* value, size_t size);
  inline ::std::string* mutable_msg();
  inline ::std::string* release_msg();
  inline void set_allocated_msg(::std::string* msg);

  // @@protoc_insertion_point(class_scope:cockroach.proto.RaftMessageRequest)
 private:
  inline void set_has_group_id();
  inline void clear_has_group_id();
  inline void set_has_msg();
  inline void clear_has_msg();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint64 group_id_;
  ::std::string* msg_;
  friend void  protobuf_AddDesc_cockroach_2fproto_2finternal_2eproto();
  friend void protobuf_AssignDesc_cockroach_2fproto_2finternal_2eproto();
  friend void protobuf_ShutdownFile_cockroach_2fproto_2finternal_2eproto();

  void InitAsDefaultInstance();
  static RaftMessageRequest* default_instance_;
};
// -------------------------------------------------------------------

class RaftMessageResponse : public ::google::protobuf::Message {
 public:
  RaftMessageResponse();
  virtual ~RaftMessageResponse();

  RaftMessageResponse(const RaftMessageResponse& from);

  inline RaftMessageResponse& operator=(const RaftMessageResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RaftMessageResponse& default_instance();

  void Swap(RaftMessageResponse* other);

  // implements Message ----------------------------------------------

  RaftMessageResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RaftMessageResponse& from);
  void MergeFrom(const RaftMessageResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:cockroach.proto.RaftMessageResponse)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_cockroach_2fproto_2finternal_2eproto();
  friend void protobuf_AssignDesc_cockroach_2fproto_2finternal_2eproto();
  friend void protobuf_ShutdownFile_cockroach_2fproto_2finternal_2eproto();

  void InitAsDefaultInstance();
  static RaftMessageResponse* default_instance_;
};
// -------------------------------------------------------------------

class InternalTimeSeriesData : public ::google::protobuf::Message {
 public:
  InternalTimeSeriesData();
  virtual ~InternalTimeSeriesData();

  InternalTimeSeriesData(const InternalTimeSeriesData& from);

  inline InternalTimeSeriesData& operator=(const InternalTimeSeriesData& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const InternalTimeSeriesData& default_instance();

  void Swap(InternalTimeSeriesData* other);

  // implements Message ----------------------------------------------

  InternalTimeSeriesData* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const InternalTimeSeriesData& from);
  void MergeFrom(const InternalTimeSeriesData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int64 start_timestamp_nanos = 1;
  inline bool has_start_timestamp_nanos() const;
  inline void clear_start_timestamp_nanos();
  static const int kStartTimestampNanosFieldNumber = 1;
  inline ::google::protobuf::int64 start_timestamp_nanos() const;
  inline void set_start_timestamp_nanos(::google::protobuf::int64 value);

  // optional int64 sample_duration_nanos = 2;
  inline bool has_sample_duration_nanos() const;
  inline void clear_sample_duration_nanos();
  static const int kSampleDurationNanosFieldNumber = 2;
  inline ::google::protobuf::int64 sample_duration_nanos() const;
  inline void set_sample_duration_nanos(::google::protobuf::int64 value);

  // repeated .cockroach.proto.InternalTimeSeriesSample samples = 3;
  inline int samples_size() const;
  inline void clear_samples();
  static const int kSamplesFieldNumber = 3;
  inline const ::cockroach::proto::InternalTimeSeriesSample& samples(int index) const;
  inline ::cockroach::proto::InternalTimeSeriesSample* mutable_samples(int index);
  inline ::cockroach::proto::InternalTimeSeriesSample* add_samples();
  inline const ::google::protobuf::RepeatedPtrField< ::cockroach::proto::InternalTimeSeriesSample >&
      samples() const;
  inline ::google::protobuf::RepeatedPtrField< ::cockroach::proto::InternalTimeSeriesSample >*
      mutable_samples();

  // @@protoc_insertion_point(class_scope:cockroach.proto.InternalTimeSeriesData)
 private:
  inline void set_has_start_timestamp_nanos();
  inline void clear_has_start_timestamp_nanos();
  inline void set_has_sample_duration_nanos();
  inline void clear_has_sample_duration_nanos();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int64 start_timestamp_nanos_;
  ::google::protobuf::int64 sample_duration_nanos_;
  ::google::protobuf::RepeatedPtrField< ::cockroach::proto::InternalTimeSeriesSample > samples_;
  friend void  protobuf_AddDesc_cockroach_2fproto_2finternal_2eproto();
  friend void protobuf_AssignDesc_cockroach_2fproto_2finternal_2eproto();
  friend void protobuf_ShutdownFile_cockroach_2fproto_2finternal_2eproto();

  void InitAsDefaultInstance();
  static InternalTimeSeriesData* default_instance_;
};
// -------------------------------------------------------------------

class InternalTimeSeriesSample : public ::google::protobuf::Message {
 public:
  InternalTimeSeriesSample();
  virtual ~InternalTimeSeriesSample();

  InternalTimeSeriesSample(const InternalTimeSeriesSample& from);

  inline InternalTimeSeriesSample& operator=(const InternalTimeSeriesSample& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const InternalTimeSeriesSample& default_instance();

  void Swap(InternalTimeSeriesSample* other);

  // implements Message ----------------------------------------------

  InternalTimeSeriesSample* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const InternalTimeSeriesSample& from);
  void MergeFrom(const InternalTimeSeriesSample& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 offset = 1;
  inline bool has_offset() const;
  inline void clear_offset();
  static const int kOffsetFieldNumber = 1;
  inline ::google::protobuf::int32 offset() const;
  inline void set_offset(::google::protobuf::int32 value);

  // optional uint32 count = 6;
  inline bool has_count() const;
  inline void clear_count();
  static const int kCountFieldNumber = 6;
  inline ::google::protobuf::uint32 count() const;
  inline void set_count(::google::protobuf::uint32 value);

  // optional double sum = 7;
  inline bool has_sum() const;
  inline void clear_sum();
  static const int kSumFieldNumber = 7;
  inline double sum() const;
  inline void set_sum(double value);

  // optional double max = 8;
  inline bool has_max() const;
  inline void clear_max();
  static const int kMaxFieldNumber = 8;
  inline double max() const;
  inline void set_max(double value);

  // optional double min = 9;
  inline bool has_min() const;
  inline void clear_min();
  static const int kMinFieldNumber = 9;
  inline double min() const;
  inline void set_min(double value);

  // @@protoc_insertion_point(class_scope:cockroach.proto.InternalTimeSeriesSample)
 private:
  inline void set_has_offset();
  inline void clear_has_offset();
  inline void set_has_count();
  inline void clear_has_count();
  inline void set_has_sum();
  inline void clear_has_sum();
  inline void set_has_max();
  inline void clear_has_max();
  inline void set_has_min();
  inline void clear_has_min();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 offset_;
  ::google::protobuf::uint32 count_;
  double sum_;
  double max_;
  double min_;
  friend void  protobuf_AddDesc_cockroach_2fproto_2finternal_2eproto();
  friend void protobuf_AssignDesc_cockroach_2fproto_2finternal_2eproto();
  friend void protobuf_ShutdownFile_cockroach_2fproto_2finternal_2eproto();

  void InitAsDefaultInstance();
  static InternalTimeSeriesSample* default_instance_;
};
// -------------------------------------------------------------------

class RaftTruncatedState : public ::google::protobuf::Message {
 public:
  RaftTruncatedState();
  virtual ~RaftTruncatedState();

  RaftTruncatedState(const RaftTruncatedState& from);

  inline RaftTruncatedState& operator=(const RaftTruncatedState& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RaftTruncatedState& default_instance();

  void Swap(RaftTruncatedState* other);

  // implements Message ----------------------------------------------

  RaftTruncatedState* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RaftTruncatedState& from);
  void MergeFrom(const RaftTruncatedState& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 index = 1;
  inline bool has_index() const;
  inline void clear_index();
  static const int kIndexFieldNumber = 1;
  inline ::google::protobuf::uint64 index() const;
  inline void set_index(::google::protobuf::uint64 value);

  // optional uint64 term = 2;
  inline bool has_term() const;
  inline void clear_term();
  static const int kTermFieldNumber = 2;
  inline ::google::protobuf::uint64 term() const;
  inline void set_term(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:cockroach.proto.RaftTruncatedState)
 private:
  inline void set_has_index();
  inline void clear_has_index();
  inline void set_has_term();
  inline void clear_has_term();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint64 index_;
  ::google::protobuf::uint64 term_;
  friend void  protobuf_AddDesc_cockroach_2fproto_2finternal_2eproto();
  friend void protobuf_AssignDesc_cockroach_2fproto_2finternal_2eproto();
  friend void protobuf_ShutdownFile_cockroach_2fproto_2finternal_2eproto();

  void InitAsDefaultInstance();
  static RaftTruncatedState* default_instance_;
};
// -------------------------------------------------------------------

class RaftSnapshotData_KeyValue : public ::google::protobuf::Message {
 public:
  RaftSnapshotData_KeyValue();
  virtual ~RaftSnapshotData_KeyValue();

  RaftSnapshotData_KeyValue(const RaftSnapshotData_KeyValue& from);

  inline RaftSnapshotData_KeyValue& operator=(const RaftSnapshotData_KeyValue& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RaftSnapshotData_KeyValue& default_instance();

  void Swap(RaftSnapshotData_KeyValue* other);

  // implements Message ----------------------------------------------

  RaftSnapshotData_KeyValue* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RaftSnapshotData_KeyValue& from);
  void MergeFrom(const RaftSnapshotData_KeyValue& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes key = 1;
  inline bool has_key() const;
  inline void clear_key();
  static const int kKeyFieldNumber = 1;
  inline const ::std::string& key() const;
  inline void set_key(const ::std::string& value);
  inline void set_key(const char* value);
  inline void set_key(const void* value, size_t size);
  inline ::std::string* mutable_key();
  inline ::std::string* release_key();
  inline void set_allocated_key(::std::string* key);

  // optional bytes value = 2;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 2;
  inline const ::std::string& value() const;
  inline void set_value(const ::std::string& value);
  inline void set_value(const char* value);
  inline void set_value(const void* value, size_t size);
  inline ::std::string* mutable_value();
  inline ::std::string* release_value();
  inline void set_allocated_value(::std::string* value);

  // @@protoc_insertion_point(class_scope:cockroach.proto.RaftSnapshotData.KeyValue)
 private:
  inline void set_has_key();
  inline void clear_has_key();
  inline void set_has_value();
  inline void clear_has_value();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* key_;
  ::std::string* value_;
  friend void  protobuf_AddDesc_cockroach_2fproto_2finternal_2eproto();
  friend void protobuf_AssignDesc_cockroach_2fproto_2finternal_2eproto();
  friend void protobuf_ShutdownFile_cockroach_2fproto_2finternal_2eproto();

  void InitAsDefaultInstance();
  static RaftSnapshotData_KeyValue* default_instance_;
};
// -------------------------------------------------------------------

class RaftSnapshotData : public ::google::protobuf::Message {
 public:
  RaftSnapshotData();
  virtual ~RaftSnapshotData();

  RaftSnapshotData(const RaftSnapshotData& from);

  inline RaftSnapshotData& operator=(const RaftSnapshotData& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RaftSnapshotData& default_instance();

  void Swap(RaftSnapshotData* other);

  // implements Message ----------------------------------------------

  RaftSnapshotData* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RaftSnapshotData& from);
  void MergeFrom(const RaftSnapshotData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef RaftSnapshotData_KeyValue KeyValue;

  // accessors -------------------------------------------------------

  // repeated .cockroach.proto.RaftSnapshotData.KeyValue KV = 1;
  inline int kv_size() const;
  inline void clear_kv();
  static const int kKVFieldNumber = 1;
  inline const ::cockroach::proto::RaftSnapshotData_KeyValue& kv(int index) const;
  inline ::cockroach::proto::RaftSnapshotData_KeyValue* mutable_kv(int index);
  inline ::cockroach::proto::RaftSnapshotData_KeyValue* add_kv();
  inline const ::google::protobuf::RepeatedPtrField< ::cockroach::proto::RaftSnapshotData_KeyValue >&
      kv() const;
  inline ::google::protobuf::RepeatedPtrField< ::cockroach::proto::RaftSnapshotData_KeyValue >*
      mutable_kv();

  // @@protoc_insertion_point(class_scope:cockroach.proto.RaftSnapshotData)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::cockroach::proto::RaftSnapshotData_KeyValue > kv_;
  friend void  protobuf_AddDesc_cockroach_2fproto_2finternal_2eproto();
  friend void protobuf_AssignDesc_cockroach_2fproto_2finternal_2eproto();
  friend void protobuf_ShutdownFile_cockroach_2fproto_2finternal_2eproto();

  void InitAsDefaultInstance();
  static RaftSnapshotData* default_instance_;
};
// ===================================================================


// ===================================================================

// InternalRangeLookupRequest

// optional .cockroach.proto.RequestHeader header = 1;
inline bool InternalRangeLookupRequest::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InternalRangeLookupRequest::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void InternalRangeLookupRequest::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void InternalRangeLookupRequest::clear_header() {
  if (header_ != NULL) header_->::cockroach::proto::RequestHeader::Clear();
  clear_has_header();
}
inline const ::cockroach::proto::RequestHeader& InternalRangeLookupRequest::header() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.InternalRangeLookupRequest.header)
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
inline ::cockroach::proto::RequestHeader* InternalRangeLookupRequest::mutable_header() {
  set_has_header();
  if (header_ == NULL) header_ = new ::cockroach::proto::RequestHeader;
  // @@protoc_insertion_point(field_mutable:cockroach.proto.InternalRangeLookupRequest.header)
  return header_;
}
inline ::cockroach::proto::RequestHeader* InternalRangeLookupRequest::release_header() {
  clear_has_header();
  ::cockroach::proto::RequestHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void InternalRangeLookupRequest::set_allocated_header(::cockroach::proto::RequestHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.InternalRangeLookupRequest.header)
}

// optional int32 max_ranges = 2;
inline bool InternalRangeLookupRequest::has_max_ranges() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void InternalRangeLookupRequest::set_has_max_ranges() {
  _has_bits_[0] |= 0x00000002u;
}
inline void InternalRangeLookupRequest::clear_has_max_ranges() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void InternalRangeLookupRequest::clear_max_ranges() {
  max_ranges_ = 0;
  clear_has_max_ranges();
}
inline ::google::protobuf::int32 InternalRangeLookupRequest::max_ranges() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.InternalRangeLookupRequest.max_ranges)
  return max_ranges_;
}
inline void InternalRangeLookupRequest::set_max_ranges(::google::protobuf::int32 value) {
  set_has_max_ranges();
  max_ranges_ = value;
  // @@protoc_insertion_point(field_set:cockroach.proto.InternalRangeLookupRequest.max_ranges)
}

// optional bool ignore_intents = 3;
inline bool InternalRangeLookupRequest::has_ignore_intents() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void InternalRangeLookupRequest::set_has_ignore_intents() {
  _has_bits_[0] |= 0x00000004u;
}
inline void InternalRangeLookupRequest::clear_has_ignore_intents() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void InternalRangeLookupRequest::clear_ignore_intents() {
  ignore_intents_ = false;
  clear_has_ignore_intents();
}
inline bool InternalRangeLookupRequest::ignore_intents() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.InternalRangeLookupRequest.ignore_intents)
  return ignore_intents_;
}
inline void InternalRangeLookupRequest::set_ignore_intents(bool value) {
  set_has_ignore_intents();
  ignore_intents_ = value;
  // @@protoc_insertion_point(field_set:cockroach.proto.InternalRangeLookupRequest.ignore_intents)
}

// -------------------------------------------------------------------

// InternalRangeLookupResponse

// optional .cockroach.proto.ResponseHeader header = 1;
inline bool InternalRangeLookupResponse::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InternalRangeLookupResponse::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void InternalRangeLookupResponse::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void InternalRangeLookupResponse::clear_header() {
  if (header_ != NULL) header_->::cockroach::proto::ResponseHeader::Clear();
  clear_has_header();
}
inline const ::cockroach::proto::ResponseHeader& InternalRangeLookupResponse::header() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.InternalRangeLookupResponse.header)
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
inline ::cockroach::proto::ResponseHeader* InternalRangeLookupResponse::mutable_header() {
  set_has_header();
  if (header_ == NULL) header_ = new ::cockroach::proto::ResponseHeader;
  // @@protoc_insertion_point(field_mutable:cockroach.proto.InternalRangeLookupResponse.header)
  return header_;
}
inline ::cockroach::proto::ResponseHeader* InternalRangeLookupResponse::release_header() {
  clear_has_header();
  ::cockroach::proto::ResponseHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void InternalRangeLookupResponse::set_allocated_header(::cockroach::proto::ResponseHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.InternalRangeLookupResponse.header)
}

// repeated .cockroach.proto.RangeDescriptor ranges = 2;
inline int InternalRangeLookupResponse::ranges_size() const {
  return ranges_.size();
}
inline void InternalRangeLookupResponse::clear_ranges() {
  ranges_.Clear();
}
inline const ::cockroach::proto::RangeDescriptor& InternalRangeLookupResponse::ranges(int index) const {
  // @@protoc_insertion_point(field_get:cockroach.proto.InternalRangeLookupResponse.ranges)
  return ranges_.Get(index);
}
inline ::cockroach::proto::RangeDescriptor* InternalRangeLookupResponse::mutable_ranges(int index) {
  // @@protoc_insertion_point(field_mutable:cockroach.proto.InternalRangeLookupResponse.ranges)
  return ranges_.Mutable(index);
}
inline ::cockroach::proto::RangeDescriptor* InternalRangeLookupResponse::add_ranges() {
  // @@protoc_insertion_point(field_add:cockroach.proto.InternalRangeLookupResponse.ranges)
  return ranges_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::cockroach::proto::RangeDescriptor >&
InternalRangeLookupResponse::ranges() const {
  // @@protoc_insertion_point(field_list:cockroach.proto.InternalRangeLookupResponse.ranges)
  return ranges_;
}
inline ::google::protobuf::RepeatedPtrField< ::cockroach::proto::RangeDescriptor >*
InternalRangeLookupResponse::mutable_ranges() {
  // @@protoc_insertion_point(field_mutable_list:cockroach.proto.InternalRangeLookupResponse.ranges)
  return &ranges_;
}

// -------------------------------------------------------------------

// InternalHeartbeatTxnRequest

// optional .cockroach.proto.RequestHeader header = 1;
inline bool InternalHeartbeatTxnRequest::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InternalHeartbeatTxnRequest::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void InternalHeartbeatTxnRequest::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void InternalHeartbeatTxnRequest::clear_header() {
  if (header_ != NULL) header_->::cockroach::proto::RequestHeader::Clear();
  clear_has_header();
}
inline const ::cockroach::proto::RequestHeader& InternalHeartbeatTxnRequest::header() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.InternalHeartbeatTxnRequest.header)
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
inline ::cockroach::proto::RequestHeader* InternalHeartbeatTxnRequest::mutable_header() {
  set_has_header();
  if (header_ == NULL) header_ = new ::cockroach::proto::RequestHeader;
  // @@protoc_insertion_point(field_mutable:cockroach.proto.InternalHeartbeatTxnRequest.header)
  return header_;
}
inline ::cockroach::proto::RequestHeader* InternalHeartbeatTxnRequest::release_header() {
  clear_has_header();
  ::cockroach::proto::RequestHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void InternalHeartbeatTxnRequest::set_allocated_header(::cockroach::proto::RequestHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.InternalHeartbeatTxnRequest.header)
}

// -------------------------------------------------------------------

// InternalHeartbeatTxnResponse

// optional .cockroach.proto.ResponseHeader header = 1;
inline bool InternalHeartbeatTxnResponse::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InternalHeartbeatTxnResponse::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void InternalHeartbeatTxnResponse::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void InternalHeartbeatTxnResponse::clear_header() {
  if (header_ != NULL) header_->::cockroach::proto::ResponseHeader::Clear();
  clear_has_header();
}
inline const ::cockroach::proto::ResponseHeader& InternalHeartbeatTxnResponse::header() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.InternalHeartbeatTxnResponse.header)
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
inline ::cockroach::proto::ResponseHeader* InternalHeartbeatTxnResponse::mutable_header() {
  set_has_header();
  if (header_ == NULL) header_ = new ::cockroach::proto::ResponseHeader;
  // @@protoc_insertion_point(field_mutable:cockroach.proto.InternalHeartbeatTxnResponse.header)
  return header_;
}
inline ::cockroach::proto::ResponseHeader* InternalHeartbeatTxnResponse::release_header() {
  clear_has_header();
  ::cockroach::proto::ResponseHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void InternalHeartbeatTxnResponse::set_allocated_header(::cockroach::proto::ResponseHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.InternalHeartbeatTxnResponse.header)
}

// -------------------------------------------------------------------

// InternalGCRequest_GCKey

// optional bytes key = 1;
inline bool InternalGCRequest_GCKey::has_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InternalGCRequest_GCKey::set_has_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void InternalGCRequest_GCKey::clear_has_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void InternalGCRequest_GCKey::clear_key() {
  if (key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_->clear();
  }
  clear_has_key();
}
inline const ::std::string& InternalGCRequest_GCKey::key() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.InternalGCRequest.GCKey.key)
  return *key_;
}
inline void InternalGCRequest_GCKey::set_key(const ::std::string& value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  key_->assign(value);
  // @@protoc_insertion_point(field_set:cockroach.proto.InternalGCRequest.GCKey.key)
}
inline void InternalGCRequest_GCKey::set_key(const char* value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  key_->assign(value);
  // @@protoc_insertion_point(field_set_char:cockroach.proto.InternalGCRequest.GCKey.key)
}
inline void InternalGCRequest_GCKey::set_key(const void* value, size_t size) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  key_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:cockroach.proto.InternalGCRequest.GCKey.key)
}
inline ::std::string* InternalGCRequest_GCKey::mutable_key() {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.proto.InternalGCRequest.GCKey.key)
  return key_;
}
inline ::std::string* InternalGCRequest_GCKey::release_key() {
  clear_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = key_;
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void InternalGCRequest_GCKey::set_allocated_key(::std::string* key) {
  if (key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete key_;
  }
  if (key) {
    set_has_key();
    key_ = key;
  } else {
    clear_has_key();
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.InternalGCRequest.GCKey.key)
}

// optional .cockroach.proto.Timestamp timestamp = 2;
inline bool InternalGCRequest_GCKey::has_timestamp() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void InternalGCRequest_GCKey::set_has_timestamp() {
  _has_bits_[0] |= 0x00000002u;
}
inline void InternalGCRequest_GCKey::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void InternalGCRequest_GCKey::clear_timestamp() {
  if (timestamp_ != NULL) timestamp_->::cockroach::proto::Timestamp::Clear();
  clear_has_timestamp();
}
inline const ::cockroach::proto::Timestamp& InternalGCRequest_GCKey::timestamp() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.InternalGCRequest.GCKey.timestamp)
  return timestamp_ != NULL ? *timestamp_ : *default_instance_->timestamp_;
}
inline ::cockroach::proto::Timestamp* InternalGCRequest_GCKey::mutable_timestamp() {
  set_has_timestamp();
  if (timestamp_ == NULL) timestamp_ = new ::cockroach::proto::Timestamp;
  // @@protoc_insertion_point(field_mutable:cockroach.proto.InternalGCRequest.GCKey.timestamp)
  return timestamp_;
}
inline ::cockroach::proto::Timestamp* InternalGCRequest_GCKey::release_timestamp() {
  clear_has_timestamp();
  ::cockroach::proto::Timestamp* temp = timestamp_;
  timestamp_ = NULL;
  return temp;
}
inline void InternalGCRequest_GCKey::set_allocated_timestamp(::cockroach::proto::Timestamp* timestamp) {
  delete timestamp_;
  timestamp_ = timestamp;
  if (timestamp) {
    set_has_timestamp();
  } else {
    clear_has_timestamp();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.InternalGCRequest.GCKey.timestamp)
}

// -------------------------------------------------------------------

// InternalGCRequest

// optional .cockroach.proto.RequestHeader header = 1;
inline bool InternalGCRequest::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InternalGCRequest::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void InternalGCRequest::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void InternalGCRequest::clear_header() {
  if (header_ != NULL) header_->::cockroach::proto::RequestHeader::Clear();
  clear_has_header();
}
inline const ::cockroach::proto::RequestHeader& InternalGCRequest::header() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.InternalGCRequest.header)
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
inline ::cockroach::proto::RequestHeader* InternalGCRequest::mutable_header() {
  set_has_header();
  if (header_ == NULL) header_ = new ::cockroach::proto::RequestHeader;
  // @@protoc_insertion_point(field_mutable:cockroach.proto.InternalGCRequest.header)
  return header_;
}
inline ::cockroach::proto::RequestHeader* InternalGCRequest::release_header() {
  clear_has_header();
  ::cockroach::proto::RequestHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void InternalGCRequest::set_allocated_header(::cockroach::proto::RequestHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.InternalGCRequest.header)
}

// optional .cockroach.proto.GCMetadata gc_meta = 2;
inline bool InternalGCRequest::has_gc_meta() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void InternalGCRequest::set_has_gc_meta() {
  _has_bits_[0] |= 0x00000002u;
}
inline void InternalGCRequest::clear_has_gc_meta() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void InternalGCRequest::clear_gc_meta() {
  if (gc_meta_ != NULL) gc_meta_->::cockroach::proto::GCMetadata::Clear();
  clear_has_gc_meta();
}
inline const ::cockroach::proto::GCMetadata& InternalGCRequest::gc_meta() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.InternalGCRequest.gc_meta)
  return gc_meta_ != NULL ? *gc_meta_ : *default_instance_->gc_meta_;
}
inline ::cockroach::proto::GCMetadata* InternalGCRequest::mutable_gc_meta() {
  set_has_gc_meta();
  if (gc_meta_ == NULL) gc_meta_ = new ::cockroach::proto::GCMetadata;
  // @@protoc_insertion_point(field_mutable:cockroach.proto.InternalGCRequest.gc_meta)
  return gc_meta_;
}
inline ::cockroach::proto::GCMetadata* InternalGCRequest::release_gc_meta() {
  clear_has_gc_meta();
  ::cockroach::proto::GCMetadata* temp = gc_meta_;
  gc_meta_ = NULL;
  return temp;
}
inline void InternalGCRequest::set_allocated_gc_meta(::cockroach::proto::GCMetadata* gc_meta) {
  delete gc_meta_;
  gc_meta_ = gc_meta;
  if (gc_meta) {
    set_has_gc_meta();
  } else {
    clear_has_gc_meta();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.InternalGCRequest.gc_meta)
}

// repeated .cockroach.proto.InternalGCRequest.GCKey keys = 3;
inline int InternalGCRequest::keys_size() const {
  return keys_.size();
}
inline void InternalGCRequest::clear_keys() {
  keys_.Clear();
}
inline const ::cockroach::proto::InternalGCRequest_GCKey& InternalGCRequest::keys(int index) const {
  // @@protoc_insertion_point(field_get:cockroach.proto.InternalGCRequest.keys)
  return keys_.Get(index);
}
inline ::cockroach::proto::InternalGCRequest_GCKey* InternalGCRequest::mutable_keys(int index) {
  // @@protoc_insertion_point(field_mutable:cockroach.proto.InternalGCRequest.keys)
  return keys_.Mutable(index);
}
inline ::cockroach::proto::InternalGCRequest_GCKey* InternalGCRequest::add_keys() {
  // @@protoc_insertion_point(field_add:cockroach.proto.InternalGCRequest.keys)
  return keys_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::cockroach::proto::InternalGCRequest_GCKey >&
InternalGCRequest::keys() const {
  // @@protoc_insertion_point(field_list:cockroach.proto.InternalGCRequest.keys)
  return keys_;
}
inline ::google::protobuf::RepeatedPtrField< ::cockroach::proto::InternalGCRequest_GCKey >*
InternalGCRequest::mutable_keys() {
  // @@protoc_insertion_point(field_mutable_list:cockroach.proto.InternalGCRequest.keys)
  return &keys_;
}

// -------------------------------------------------------------------

// InternalGCResponse

// optional .cockroach.proto.ResponseHeader header = 1;
inline bool InternalGCResponse::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InternalGCResponse::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void InternalGCResponse::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void InternalGCResponse::clear_header() {
  if (header_ != NULL) header_->::cockroach::proto::ResponseHeader::Clear();
  clear_has_header();
}
inline const ::cockroach::proto::ResponseHeader& InternalGCResponse::header() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.InternalGCResponse.header)
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
inline ::cockroach::proto::ResponseHeader* InternalGCResponse::mutable_header() {
  set_has_header();
  if (header_ == NULL) header_ = new ::cockroach::proto::ResponseHeader;
  // @@protoc_insertion_point(field_mutable:cockroach.proto.InternalGCResponse.header)
  return header_;
}
inline ::cockroach::proto::ResponseHeader* InternalGCResponse::release_header() {
  clear_has_header();
  ::cockroach::proto::ResponseHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void InternalGCResponse::set_allocated_header(::cockroach::proto::ResponseHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.InternalGCResponse.header)
}

// -------------------------------------------------------------------

// InternalPushTxnRequest

// optional .cockroach.proto.RequestHeader header = 1;
inline bool InternalPushTxnRequest::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InternalPushTxnRequest::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void InternalPushTxnRequest::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void InternalPushTxnRequest::clear_header() {
  if (header_ != NULL) header_->::cockroach::proto::RequestHeader::Clear();
  clear_has_header();
}
inline const ::cockroach::proto::RequestHeader& InternalPushTxnRequest::header() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.InternalPushTxnRequest.header)
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
inline ::cockroach::proto::RequestHeader* InternalPushTxnRequest::mutable_header() {
  set_has_header();
  if (header_ == NULL) header_ = new ::cockroach::proto::RequestHeader;
  // @@protoc_insertion_point(field_mutable:cockroach.proto.InternalPushTxnRequest.header)
  return header_;
}
inline ::cockroach::proto::RequestHeader* InternalPushTxnRequest::release_header() {
  clear_has_header();
  ::cockroach::proto::RequestHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void InternalPushTxnRequest::set_allocated_header(::cockroach::proto::RequestHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.InternalPushTxnRequest.header)
}

// optional .cockroach.proto.Transaction pushee_txn = 2;
inline bool InternalPushTxnRequest::has_pushee_txn() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void InternalPushTxnRequest::set_has_pushee_txn() {
  _has_bits_[0] |= 0x00000002u;
}
inline void InternalPushTxnRequest::clear_has_pushee_txn() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void InternalPushTxnRequest::clear_pushee_txn() {
  if (pushee_txn_ != NULL) pushee_txn_->::cockroach::proto::Transaction::Clear();
  clear_has_pushee_txn();
}
inline const ::cockroach::proto::Transaction& InternalPushTxnRequest::pushee_txn() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.InternalPushTxnRequest.pushee_txn)
  return pushee_txn_ != NULL ? *pushee_txn_ : *default_instance_->pushee_txn_;
}
inline ::cockroach::proto::Transaction* InternalPushTxnRequest::mutable_pushee_txn() {
  set_has_pushee_txn();
  if (pushee_txn_ == NULL) pushee_txn_ = new ::cockroach::proto::Transaction;
  // @@protoc_insertion_point(field_mutable:cockroach.proto.InternalPushTxnRequest.pushee_txn)
  return pushee_txn_;
}
inline ::cockroach::proto::Transaction* InternalPushTxnRequest::release_pushee_txn() {
  clear_has_pushee_txn();
  ::cockroach::proto::Transaction* temp = pushee_txn_;
  pushee_txn_ = NULL;
  return temp;
}
inline void InternalPushTxnRequest::set_allocated_pushee_txn(::cockroach::proto::Transaction* pushee_txn) {
  delete pushee_txn_;
  pushee_txn_ = pushee_txn;
  if (pushee_txn) {
    set_has_pushee_txn();
  } else {
    clear_has_pushee_txn();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.InternalPushTxnRequest.pushee_txn)
}

// optional .cockroach.proto.Timestamp now = 3;
inline bool InternalPushTxnRequest::has_now() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void InternalPushTxnRequest::set_has_now() {
  _has_bits_[0] |= 0x00000004u;
}
inline void InternalPushTxnRequest::clear_has_now() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void InternalPushTxnRequest::clear_now() {
  if (now_ != NULL) now_->::cockroach::proto::Timestamp::Clear();
  clear_has_now();
}
inline const ::cockroach::proto::Timestamp& InternalPushTxnRequest::now() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.InternalPushTxnRequest.now)
  return now_ != NULL ? *now_ : *default_instance_->now_;
}
inline ::cockroach::proto::Timestamp* InternalPushTxnRequest::mutable_now() {
  set_has_now();
  if (now_ == NULL) now_ = new ::cockroach::proto::Timestamp;
  // @@protoc_insertion_point(field_mutable:cockroach.proto.InternalPushTxnRequest.now)
  return now_;
}
inline ::cockroach::proto::Timestamp* InternalPushTxnRequest::release_now() {
  clear_has_now();
  ::cockroach::proto::Timestamp* temp = now_;
  now_ = NULL;
  return temp;
}
inline void InternalPushTxnRequest::set_allocated_now(::cockroach::proto::Timestamp* now) {
  delete now_;
  now_ = now;
  if (now) {
    set_has_now();
  } else {
    clear_has_now();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.InternalPushTxnRequest.now)
}

// optional .cockroach.proto.PushTxnType push_type = 4;
inline bool InternalPushTxnRequest::has_push_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void InternalPushTxnRequest::set_has_push_type() {
  _has_bits_[0] |= 0x00000008u;
}
inline void InternalPushTxnRequest::clear_has_push_type() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void InternalPushTxnRequest::clear_push_type() {
  push_type_ = 0;
  clear_has_push_type();
}
inline ::cockroach::proto::PushTxnType InternalPushTxnRequest::push_type() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.InternalPushTxnRequest.push_type)
  return static_cast< ::cockroach::proto::PushTxnType >(push_type_);
}
inline void InternalPushTxnRequest::set_push_type(::cockroach::proto::PushTxnType value) {
  assert(::cockroach::proto::PushTxnType_IsValid(value));
  set_has_push_type();
  push_type_ = value;
  // @@protoc_insertion_point(field_set:cockroach.proto.InternalPushTxnRequest.push_type)
}

// optional bool range_lookup = 5;
inline bool InternalPushTxnRequest::has_range_lookup() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void InternalPushTxnRequest::set_has_range_lookup() {
  _has_bits_[0] |= 0x00000010u;
}
inline void InternalPushTxnRequest::clear_has_range_lookup() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void InternalPushTxnRequest::clear_range_lookup() {
  range_lookup_ = false;
  clear_has_range_lookup();
}
inline bool InternalPushTxnRequest::range_lookup() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.InternalPushTxnRequest.range_lookup)
  return range_lookup_;
}
inline void InternalPushTxnRequest::set_range_lookup(bool value) {
  set_has_range_lookup();
  range_lookup_ = value;
  // @@protoc_insertion_point(field_set:cockroach.proto.InternalPushTxnRequest.range_lookup)
}

// -------------------------------------------------------------------

// InternalPushTxnResponse

// optional .cockroach.proto.ResponseHeader header = 1;
inline bool InternalPushTxnResponse::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InternalPushTxnResponse::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void InternalPushTxnResponse::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void InternalPushTxnResponse::clear_header() {
  if (header_ != NULL) header_->::cockroach::proto::ResponseHeader::Clear();
  clear_has_header();
}
inline const ::cockroach::proto::ResponseHeader& InternalPushTxnResponse::header() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.InternalPushTxnResponse.header)
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
inline ::cockroach::proto::ResponseHeader* InternalPushTxnResponse::mutable_header() {
  set_has_header();
  if (header_ == NULL) header_ = new ::cockroach::proto::ResponseHeader;
  // @@protoc_insertion_point(field_mutable:cockroach.proto.InternalPushTxnResponse.header)
  return header_;
}
inline ::cockroach::proto::ResponseHeader* InternalPushTxnResponse::release_header() {
  clear_has_header();
  ::cockroach::proto::ResponseHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void InternalPushTxnResponse::set_allocated_header(::cockroach::proto::ResponseHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.InternalPushTxnResponse.header)
}

// optional .cockroach.proto.Transaction pushee_txn = 2;
inline bool InternalPushTxnResponse::has_pushee_txn() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void InternalPushTxnResponse::set_has_pushee_txn() {
  _has_bits_[0] |= 0x00000002u;
}
inline void InternalPushTxnResponse::clear_has_pushee_txn() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void InternalPushTxnResponse::clear_pushee_txn() {
  if (pushee_txn_ != NULL) pushee_txn_->::cockroach::proto::Transaction::Clear();
  clear_has_pushee_txn();
}
inline const ::cockroach::proto::Transaction& InternalPushTxnResponse::pushee_txn() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.InternalPushTxnResponse.pushee_txn)
  return pushee_txn_ != NULL ? *pushee_txn_ : *default_instance_->pushee_txn_;
}
inline ::cockroach::proto::Transaction* InternalPushTxnResponse::mutable_pushee_txn() {
  set_has_pushee_txn();
  if (pushee_txn_ == NULL) pushee_txn_ = new ::cockroach::proto::Transaction;
  // @@protoc_insertion_point(field_mutable:cockroach.proto.InternalPushTxnResponse.pushee_txn)
  return pushee_txn_;
}
inline ::cockroach::proto::Transaction* InternalPushTxnResponse::release_pushee_txn() {
  clear_has_pushee_txn();
  ::cockroach::proto::Transaction* temp = pushee_txn_;
  pushee_txn_ = NULL;
  return temp;
}
inline void InternalPushTxnResponse::set_allocated_pushee_txn(::cockroach::proto::Transaction* pushee_txn) {
  delete pushee_txn_;
  pushee_txn_ = pushee_txn;
  if (pushee_txn) {
    set_has_pushee_txn();
  } else {
    clear_has_pushee_txn();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.InternalPushTxnResponse.pushee_txn)
}

// -------------------------------------------------------------------

// InternalResolveIntentRequest

// optional .cockroach.proto.RequestHeader header = 1;
inline bool InternalResolveIntentRequest::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InternalResolveIntentRequest::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void InternalResolveIntentRequest::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void InternalResolveIntentRequest::clear_header() {
  if (header_ != NULL) header_->::cockroach::proto::RequestHeader::Clear();
  clear_has_header();
}
inline const ::cockroach::proto::RequestHeader& InternalResolveIntentRequest::header() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.InternalResolveIntentRequest.header)
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
inline ::cockroach::proto::RequestHeader* InternalResolveIntentRequest::mutable_header() {
  set_has_header();
  if (header_ == NULL) header_ = new ::cockroach::proto::RequestHeader;
  // @@protoc_insertion_point(field_mutable:cockroach.proto.InternalResolveIntentRequest.header)
  return header_;
}
inline ::cockroach::proto::RequestHeader* InternalResolveIntentRequest::release_header() {
  clear_has_header();
  ::cockroach::proto::RequestHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void InternalResolveIntentRequest::set_allocated_header(::cockroach::proto::RequestHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.InternalResolveIntentRequest.header)
}

// -------------------------------------------------------------------

// InternalResolveIntentResponse

// optional .cockroach.proto.ResponseHeader header = 1;
inline bool InternalResolveIntentResponse::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InternalResolveIntentResponse::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void InternalResolveIntentResponse::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void InternalResolveIntentResponse::clear_header() {
  if (header_ != NULL) header_->::cockroach::proto::ResponseHeader::Clear();
  clear_has_header();
}
inline const ::cockroach::proto::ResponseHeader& InternalResolveIntentResponse::header() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.InternalResolveIntentResponse.header)
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
inline ::cockroach::proto::ResponseHeader* InternalResolveIntentResponse::mutable_header() {
  set_has_header();
  if (header_ == NULL) header_ = new ::cockroach::proto::ResponseHeader;
  // @@protoc_insertion_point(field_mutable:cockroach.proto.InternalResolveIntentResponse.header)
  return header_;
}
inline ::cockroach::proto::ResponseHeader* InternalResolveIntentResponse::release_header() {
  clear_has_header();
  ::cockroach::proto::ResponseHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void InternalResolveIntentResponse::set_allocated_header(::cockroach::proto::ResponseHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.InternalResolveIntentResponse.header)
}

// -------------------------------------------------------------------

// InternalResolveIntentRangeRequest

// optional .cockroach.proto.RequestHeader header = 1;
inline bool InternalResolveIntentRangeRequest::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InternalResolveIntentRangeRequest::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void InternalResolveIntentRangeRequest::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void InternalResolveIntentRangeRequest::clear_header() {
  if (header_ != NULL) header_->::cockroach::proto::RequestHeader::Clear();
  clear_has_header();
}
inline const ::cockroach::proto::RequestHeader& InternalResolveIntentRangeRequest::header() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.InternalResolveIntentRangeRequest.header)
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
inline ::cockroach::proto::RequestHeader* InternalResolveIntentRangeRequest::mutable_header() {
  set_has_header();
  if (header_ == NULL) header_ = new ::cockroach::proto::RequestHeader;
  // @@protoc_insertion_point(field_mutable:cockroach.proto.InternalResolveIntentRangeRequest.header)
  return header_;
}
inline ::cockroach::proto::RequestHeader* InternalResolveIntentRangeRequest::release_header() {
  clear_has_header();
  ::cockroach::proto::RequestHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void InternalResolveIntentRangeRequest::set_allocated_header(::cockroach::proto::RequestHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.InternalResolveIntentRangeRequest.header)
}

// -------------------------------------------------------------------

// InternalResolveIntentRangeResponse

// optional .cockroach.proto.ResponseHeader header = 1;
inline bool InternalResolveIntentRangeResponse::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InternalResolveIntentRangeResponse::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void InternalResolveIntentRangeResponse::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void InternalResolveIntentRangeResponse::clear_header() {
  if (header_ != NULL) header_->::cockroach::proto::ResponseHeader::Clear();
  clear_has_header();
}
inline const ::cockroach::proto::ResponseHeader& InternalResolveIntentRangeResponse::header() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.InternalResolveIntentRangeResponse.header)
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
inline ::cockroach::proto::ResponseHeader* InternalResolveIntentRangeResponse::mutable_header() {
  set_has_header();
  if (header_ == NULL) header_ = new ::cockroach::proto::ResponseHeader;
  // @@protoc_insertion_point(field_mutable:cockroach.proto.InternalResolveIntentRangeResponse.header)
  return header_;
}
inline ::cockroach::proto::ResponseHeader* InternalResolveIntentRangeResponse::release_header() {
  clear_has_header();
  ::cockroach::proto::ResponseHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void InternalResolveIntentRangeResponse::set_allocated_header(::cockroach::proto::ResponseHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.InternalResolveIntentRangeResponse.header)
}

// -------------------------------------------------------------------

// InternalMergeRequest

// optional .cockroach.proto.RequestHeader header = 1;
inline bool InternalMergeRequest::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InternalMergeRequest::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void InternalMergeRequest::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void InternalMergeRequest::clear_header() {
  if (header_ != NULL) header_->::cockroach::proto::RequestHeader::Clear();
  clear_has_header();
}
inline const ::cockroach::proto::RequestHeader& InternalMergeRequest::header() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.InternalMergeRequest.header)
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
inline ::cockroach::proto::RequestHeader* InternalMergeRequest::mutable_header() {
  set_has_header();
  if (header_ == NULL) header_ = new ::cockroach::proto::RequestHeader;
  // @@protoc_insertion_point(field_mutable:cockroach.proto.InternalMergeRequest.header)
  return header_;
}
inline ::cockroach::proto::RequestHeader* InternalMergeRequest::release_header() {
  clear_has_header();
  ::cockroach::proto::RequestHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void InternalMergeRequest::set_allocated_header(::cockroach::proto::RequestHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.InternalMergeRequest.header)
}

// optional .cockroach.proto.Value value = 2;
inline bool InternalMergeRequest::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void InternalMergeRequest::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void InternalMergeRequest::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void InternalMergeRequest::clear_value() {
  if (value_ != NULL) value_->::cockroach::proto::Value::Clear();
  clear_has_value();
}
inline const ::cockroach::proto::Value& InternalMergeRequest::value() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.InternalMergeRequest.value)
  return value_ != NULL ? *value_ : *default_instance_->value_;
}
inline ::cockroach::proto::Value* InternalMergeRequest::mutable_value() {
  set_has_value();
  if (value_ == NULL) value_ = new ::cockroach::proto::Value;
  // @@protoc_insertion_point(field_mutable:cockroach.proto.InternalMergeRequest.value)
  return value_;
}
inline ::cockroach::proto::Value* InternalMergeRequest::release_value() {
  clear_has_value();
  ::cockroach::proto::Value* temp = value_;
  value_ = NULL;
  return temp;
}
inline void InternalMergeRequest::set_allocated_value(::cockroach::proto::Value* value) {
  delete value_;
  value_ = value;
  if (value) {
    set_has_value();
  } else {
    clear_has_value();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.InternalMergeRequest.value)
}

// -------------------------------------------------------------------

// InternalMergeResponse

// optional .cockroach.proto.ResponseHeader header = 1;
inline bool InternalMergeResponse::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InternalMergeResponse::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void InternalMergeResponse::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void InternalMergeResponse::clear_header() {
  if (header_ != NULL) header_->::cockroach::proto::ResponseHeader::Clear();
  clear_has_header();
}
inline const ::cockroach::proto::ResponseHeader& InternalMergeResponse::header() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.InternalMergeResponse.header)
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
inline ::cockroach::proto::ResponseHeader* InternalMergeResponse::mutable_header() {
  set_has_header();
  if (header_ == NULL) header_ = new ::cockroach::proto::ResponseHeader;
  // @@protoc_insertion_point(field_mutable:cockroach.proto.InternalMergeResponse.header)
  return header_;
}
inline ::cockroach::proto::ResponseHeader* InternalMergeResponse::release_header() {
  clear_has_header();
  ::cockroach::proto::ResponseHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void InternalMergeResponse::set_allocated_header(::cockroach::proto::ResponseHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.InternalMergeResponse.header)
}

// -------------------------------------------------------------------

// InternalTruncateLogRequest

// optional .cockroach.proto.RequestHeader header = 1;
inline bool InternalTruncateLogRequest::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InternalTruncateLogRequest::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void InternalTruncateLogRequest::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void InternalTruncateLogRequest::clear_header() {
  if (header_ != NULL) header_->::cockroach::proto::RequestHeader::Clear();
  clear_has_header();
}
inline const ::cockroach::proto::RequestHeader& InternalTruncateLogRequest::header() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.InternalTruncateLogRequest.header)
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
inline ::cockroach::proto::RequestHeader* InternalTruncateLogRequest::mutable_header() {
  set_has_header();
  if (header_ == NULL) header_ = new ::cockroach::proto::RequestHeader;
  // @@protoc_insertion_point(field_mutable:cockroach.proto.InternalTruncateLogRequest.header)
  return header_;
}
inline ::cockroach::proto::RequestHeader* InternalTruncateLogRequest::release_header() {
  clear_has_header();
  ::cockroach::proto::RequestHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void InternalTruncateLogRequest::set_allocated_header(::cockroach::proto::RequestHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.InternalTruncateLogRequest.header)
}

// optional uint64 index = 2;
inline bool InternalTruncateLogRequest::has_index() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void InternalTruncateLogRequest::set_has_index() {
  _has_bits_[0] |= 0x00000002u;
}
inline void InternalTruncateLogRequest::clear_has_index() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void InternalTruncateLogRequest::clear_index() {
  index_ = GOOGLE_ULONGLONG(0);
  clear_has_index();
}
inline ::google::protobuf::uint64 InternalTruncateLogRequest::index() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.InternalTruncateLogRequest.index)
  return index_;
}
inline void InternalTruncateLogRequest::set_index(::google::protobuf::uint64 value) {
  set_has_index();
  index_ = value;
  // @@protoc_insertion_point(field_set:cockroach.proto.InternalTruncateLogRequest.index)
}

// -------------------------------------------------------------------

// InternalTruncateLogResponse

// optional .cockroach.proto.ResponseHeader header = 1;
inline bool InternalTruncateLogResponse::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InternalTruncateLogResponse::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void InternalTruncateLogResponse::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void InternalTruncateLogResponse::clear_header() {
  if (header_ != NULL) header_->::cockroach::proto::ResponseHeader::Clear();
  clear_has_header();
}
inline const ::cockroach::proto::ResponseHeader& InternalTruncateLogResponse::header() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.InternalTruncateLogResponse.header)
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
inline ::cockroach::proto::ResponseHeader* InternalTruncateLogResponse::mutable_header() {
  set_has_header();
  if (header_ == NULL) header_ = new ::cockroach::proto::ResponseHeader;
  // @@protoc_insertion_point(field_mutable:cockroach.proto.InternalTruncateLogResponse.header)
  return header_;
}
inline ::cockroach::proto::ResponseHeader* InternalTruncateLogResponse::release_header() {
  clear_has_header();
  ::cockroach::proto::ResponseHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void InternalTruncateLogResponse::set_allocated_header(::cockroach::proto::ResponseHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.InternalTruncateLogResponse.header)
}

// -------------------------------------------------------------------

// InternalLeaderLeaseRequest

// optional .cockroach.proto.RequestHeader header = 1;
inline bool InternalLeaderLeaseRequest::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InternalLeaderLeaseRequest::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void InternalLeaderLeaseRequest::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void InternalLeaderLeaseRequest::clear_header() {
  if (header_ != NULL) header_->::cockroach::proto::RequestHeader::Clear();
  clear_has_header();
}
inline const ::cockroach::proto::RequestHeader& InternalLeaderLeaseRequest::header() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.InternalLeaderLeaseRequest.header)
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
inline ::cockroach::proto::RequestHeader* InternalLeaderLeaseRequest::mutable_header() {
  set_has_header();
  if (header_ == NULL) header_ = new ::cockroach::proto::RequestHeader;
  // @@protoc_insertion_point(field_mutable:cockroach.proto.InternalLeaderLeaseRequest.header)
  return header_;
}
inline ::cockroach::proto::RequestHeader* InternalLeaderLeaseRequest::release_header() {
  clear_has_header();
  ::cockroach::proto::RequestHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void InternalLeaderLeaseRequest::set_allocated_header(::cockroach::proto::RequestHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.InternalLeaderLeaseRequest.header)
}

// optional .cockroach.proto.Lease lease = 2;
inline bool InternalLeaderLeaseRequest::has_lease() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void InternalLeaderLeaseRequest::set_has_lease() {
  _has_bits_[0] |= 0x00000002u;
}
inline void InternalLeaderLeaseRequest::clear_has_lease() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void InternalLeaderLeaseRequest::clear_lease() {
  if (lease_ != NULL) lease_->::cockroach::proto::Lease::Clear();
  clear_has_lease();
}
inline const ::cockroach::proto::Lease& InternalLeaderLeaseRequest::lease() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.InternalLeaderLeaseRequest.lease)
  return lease_ != NULL ? *lease_ : *default_instance_->lease_;
}
inline ::cockroach::proto::Lease* InternalLeaderLeaseRequest::mutable_lease() {
  set_has_lease();
  if (lease_ == NULL) lease_ = new ::cockroach::proto::Lease;
  // @@protoc_insertion_point(field_mutable:cockroach.proto.InternalLeaderLeaseRequest.lease)
  return lease_;
}
inline ::cockroach::proto::Lease* InternalLeaderLeaseRequest::release_lease() {
  clear_has_lease();
  ::cockroach::proto::Lease* temp = lease_;
  lease_ = NULL;
  return temp;
}
inline void InternalLeaderLeaseRequest::set_allocated_lease(::cockroach::proto::Lease* lease) {
  delete lease_;
  lease_ = lease;
  if (lease) {
    set_has_lease();
  } else {
    clear_has_lease();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.InternalLeaderLeaseRequest.lease)
}

// -------------------------------------------------------------------

// InternalLeaderLeaseResponse

// optional .cockroach.proto.ResponseHeader header = 1;
inline bool InternalLeaderLeaseResponse::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InternalLeaderLeaseResponse::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void InternalLeaderLeaseResponse::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void InternalLeaderLeaseResponse::clear_header() {
  if (header_ != NULL) header_->::cockroach::proto::ResponseHeader::Clear();
  clear_has_header();
}
inline const ::cockroach::proto::ResponseHeader& InternalLeaderLeaseResponse::header() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.InternalLeaderLeaseResponse.header)
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
inline ::cockroach::proto::ResponseHeader* InternalLeaderLeaseResponse::mutable_header() {
  set_has_header();
  if (header_ == NULL) header_ = new ::cockroach::proto::ResponseHeader;
  // @@protoc_insertion_point(field_mutable:cockroach.proto.InternalLeaderLeaseResponse.header)
  return header_;
}
inline ::cockroach::proto::ResponseHeader* InternalLeaderLeaseResponse::release_header() {
  clear_has_header();
  ::cockroach::proto::ResponseHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void InternalLeaderLeaseResponse::set_allocated_header(::cockroach::proto::ResponseHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.InternalLeaderLeaseResponse.header)
}

// -------------------------------------------------------------------

// InternalRequestUnion

// optional .cockroach.proto.GetRequest get = 2;
inline bool InternalRequestUnion::has_get() const {
  return value_case() == kGet;
}
inline void InternalRequestUnion::set_has_get() {
  _oneof_case_[0] = kGet;
}
inline void InternalRequestUnion::clear_get() {
  if (has_get()) {
    delete value_.get_;
    clear_has_value();
  }
}
inline const ::cockroach::proto::GetRequest& InternalRequestUnion::get() const {
  return has_get() ? *value_.get_
                      : ::cockroach::proto::GetRequest::default_instance();
}
inline ::cockroach::proto::GetRequest* InternalRequestUnion::mutable_get() {
  if (!has_get()) {
    clear_value();
    set_has_get();
    value_.get_ = new ::cockroach::proto::GetRequest;
  }
  return value_.get_;
}
inline ::cockroach::proto::GetRequest* InternalRequestUnion::release_get() {
  if (has_get()) {
    clear_has_value();
    ::cockroach::proto::GetRequest* temp = value_.get_;
    value_.get_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void InternalRequestUnion::set_allocated_get(::cockroach::proto::GetRequest* get) {
  clear_value();
  if (get) {
    set_has_get();
    value_.get_ = get;
  }
}

// optional .cockroach.proto.PutRequest put = 3;
inline bool InternalRequestUnion::has_put() const {
  return value_case() == kPut;
}
inline void InternalRequestUnion::set_has_put() {
  _oneof_case_[0] = kPut;
}
inline void InternalRequestUnion::clear_put() {
  if (has_put()) {
    delete value_.put_;
    clear_has_value();
  }
}
inline const ::cockroach::proto::PutRequest& InternalRequestUnion::put() const {
  return has_put() ? *value_.put_
                      : ::cockroach::proto::PutRequest::default_instance();
}
inline ::cockroach::proto::PutRequest* InternalRequestUnion::mutable_put() {
  if (!has_put()) {
    clear_value();
    set_has_put();
    value_.put_ = new ::cockroach::proto::PutRequest;
  }
  return value_.put_;
}
inline ::cockroach::proto::PutRequest* InternalRequestUnion::release_put() {
  if (has_put()) {
    clear_has_value();
    ::cockroach::proto::PutRequest* temp = value_.put_;
    value_.put_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void InternalRequestUnion::set_allocated_put(::cockroach::proto::PutRequest* put) {
  clear_value();
  if (put) {
    set_has_put();
    value_.put_ = put;
  }
}

// optional .cockroach.proto.ConditionalPutRequest conditional_put = 4;
inline bool InternalRequestUnion::has_conditional_put() const {
  return value_case() == kConditionalPut;
}
inline void InternalRequestUnion::set_has_conditional_put() {
  _oneof_case_[0] = kConditionalPut;
}
inline void InternalRequestUnion::clear_conditional_put() {
  if (has_conditional_put()) {
    delete value_.conditional_put_;
    clear_has_value();
  }
}
inline const ::cockroach::proto::ConditionalPutRequest& InternalRequestUnion::conditional_put() const {
  return has_conditional_put() ? *value_.conditional_put_
                      : ::cockroach::proto::ConditionalPutRequest::default_instance();
}
inline ::cockroach::proto::ConditionalPutRequest* InternalRequestUnion::mutable_conditional_put() {
  if (!has_conditional_put()) {
    clear_value();
    set_has_conditional_put();
    value_.conditional_put_ = new ::cockroach::proto::ConditionalPutRequest;
  }
  return value_.conditional_put_;
}
inline ::cockroach::proto::ConditionalPutRequest* InternalRequestUnion::release_conditional_put() {
  if (has_conditional_put()) {
    clear_has_value();
    ::cockroach::proto::ConditionalPutRequest* temp = value_.conditional_put_;
    value_.conditional_put_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void InternalRequestUnion::set_allocated_conditional_put(::cockroach::proto::ConditionalPutRequest* conditional_put) {
  clear_value();
  if (conditional_put) {
    set_has_conditional_put();
    value_.conditional_put_ = conditional_put;
  }
}

// optional .cockroach.proto.IncrementRequest increment = 5;
inline bool InternalRequestUnion::has_increment() const {
  return value_case() == kIncrement;
}
inline void InternalRequestUnion::set_has_increment() {
  _oneof_case_[0] = kIncrement;
}
inline void InternalRequestUnion::clear_increment() {
  if (has_increment()) {
    delete value_.increment_;
    clear_has_value();
  }
}
inline const ::cockroach::proto::IncrementRequest& InternalRequestUnion::increment() const {
  return has_increment() ? *value_.increment_
                      : ::cockroach::proto::IncrementRequest::default_instance();
}
inline ::cockroach::proto::IncrementRequest* InternalRequestUnion::mutable_increment() {
  if (!has_increment()) {
    clear_value();
    set_has_increment();
    value_.increment_ = new ::cockroach::proto::IncrementRequest;
  }
  return value_.increment_;
}
inline ::cockroach::proto::IncrementRequest* InternalRequestUnion::release_increment() {
  if (has_increment()) {
    clear_has_value();
    ::cockroach::proto::IncrementRequest* temp = value_.increment_;
    value_.increment_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void InternalRequestUnion::set_allocated_increment(::cockroach::proto::IncrementRequest* increment) {
  clear_value();
  if (increment) {
    set_has_increment();
    value_.increment_ = increment;
  }
}

// optional .cockroach.proto.DeleteRequest delete = 6;
inline bool InternalRequestUnion::has_delete_() const {
  return value_case() == kDelete;
}
inline void InternalRequestUnion::set_has_delete_() {
  _oneof_case_[0] = kDelete;
}
inline void InternalRequestUnion::clear_delete_() {
  if (has_delete_()) {
    delete value_.delete__;
    clear_has_value();
  }
}
inline const ::cockroach::proto::DeleteRequest& InternalRequestUnion::delete_() const {
  return has_delete_() ? *value_.delete__
                      : ::cockroach::proto::DeleteRequest::default_instance();
}
inline ::cockroach::proto::DeleteRequest* InternalRequestUnion::mutable_delete_() {
  if (!has_delete_()) {
    clear_value();
    set_has_delete_();
    value_.delete__ = new ::cockroach::proto::DeleteRequest;
  }
  return value_.delete__;
}
inline ::cockroach::proto::DeleteRequest* InternalRequestUnion::release_delete_() {
  if (has_delete_()) {
    clear_has_value();
    ::cockroach::proto::DeleteRequest* temp = value_.delete__;
    value_.delete__ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void InternalRequestUnion::set_allocated_delete_(::cockroach::proto::DeleteRequest* delete_) {
  clear_value();
  if (delete_) {
    set_has_delete_();
    value_.delete__ = delete_;
  }
}

// optional .cockroach.proto.DeleteRangeRequest delete_range = 7;
inline bool InternalRequestUnion::has_delete_range() const {
  return value_case() == kDeleteRange;
}
inline void InternalRequestUnion::set_has_delete_range() {
  _oneof_case_[0] = kDeleteRange;
}
inline void InternalRequestUnion::clear_delete_range() {
  if (has_delete_range()) {
    delete value_.delete_range_;
    clear_has_value();
  }
}
inline const ::cockroach::proto::DeleteRangeRequest& InternalRequestUnion::delete_range() const {
  return has_delete_range() ? *value_.delete_range_
                      : ::cockroach::proto::DeleteRangeRequest::default_instance();
}
inline ::cockroach::proto::DeleteRangeRequest* InternalRequestUnion::mutable_delete_range() {
  if (!has_delete_range()) {
    clear_value();
    set_has_delete_range();
    value_.delete_range_ = new ::cockroach::proto::DeleteRangeRequest;
  }
  return value_.delete_range_;
}
inline ::cockroach::proto::DeleteRangeRequest* InternalRequestUnion::release_delete_range() {
  if (has_delete_range()) {
    clear_has_value();
    ::cockroach::proto::DeleteRangeRequest* temp = value_.delete_range_;
    value_.delete_range_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void InternalRequestUnion::set_allocated_delete_range(::cockroach::proto::DeleteRangeRequest* delete_range) {
  clear_value();
  if (delete_range) {
    set_has_delete_range();
    value_.delete_range_ = delete_range;
  }
}

// optional .cockroach.proto.ScanRequest scan = 8;
inline bool InternalRequestUnion::has_scan() const {
  return value_case() == kScan;
}
inline void InternalRequestUnion::set_has_scan() {
  _oneof_case_[0] = kScan;
}
inline void InternalRequestUnion::clear_scan() {
  if (has_scan()) {
    delete value_.scan_;
    clear_has_value();
  }
}
inline const ::cockroach::proto::ScanRequest& InternalRequestUnion::scan() const {
  return has_scan() ? *value_.scan_
                      : ::cockroach::proto::ScanRequest::default_instance();
}
inline ::cockroach::proto::ScanRequest* InternalRequestUnion::mutable_scan() {
  if (!has_scan()) {
    clear_value();
    set_has_scan();
    value_.scan_ = new ::cockroach::proto::ScanRequest;
  }
  return value_.scan_;
}
inline ::cockroach::proto::ScanRequest* InternalRequestUnion::release_scan() {
  if (has_scan()) {
    clear_has_value();
    ::cockroach::proto::ScanRequest* temp = value_.scan_;
    value_.scan_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void InternalRequestUnion::set_allocated_scan(::cockroach::proto::ScanRequest* scan) {
  clear_value();
  if (scan) {
    set_has_scan();
    value_.scan_ = scan;
  }
}

// optional .cockroach.proto.EndTransactionRequest end_transaction = 9;
inline bool InternalRequestUnion::has_end_transaction() const {
  return value_case() == kEndTransaction;
}
inline void InternalRequestUnion::set_has_end_transaction() {
  _oneof_case_[0] = kEndTransaction;
}
inline void InternalRequestUnion::clear_end_transaction() {
  if (has_end_transaction()) {
    delete value_.end_transaction_;
    clear_has_value();
  }
}
inline const ::cockroach::proto::EndTransactionRequest& InternalRequestUnion::end_transaction() const {
  return has_end_transaction() ? *value_.end_transaction_
                      : ::cockroach::proto::EndTransactionRequest::default_instance();
}
inline ::cockroach::proto::EndTransactionRequest* InternalRequestUnion::mutable_end_transaction() {
  if (!has_end_transaction()) {
    clear_value();
    set_has_end_transaction();
    value_.end_transaction_ = new ::cockroach::proto::EndTransactionRequest;
  }
  return value_.end_transaction_;
}
inline ::cockroach::proto::EndTransactionRequest* InternalRequestUnion::release_end_transaction() {
  if (has_end_transaction()) {
    clear_has_value();
    ::cockroach::proto::EndTransactionRequest* temp = value_.end_transaction_;
    value_.end_transaction_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void InternalRequestUnion::set_allocated_end_transaction(::cockroach::proto::EndTransactionRequest* end_transaction) {
  clear_value();
  if (end_transaction) {
    set_has_end_transaction();
    value_.end_transaction_ = end_transaction;
  }
}

// optional .cockroach.proto.InternalPushTxnRequest internal_push_txn = 30;
inline bool InternalRequestUnion::has_internal_push_txn() const {
  return value_case() == kInternalPushTxn;
}
inline void InternalRequestUnion::set_has_internal_push_txn() {
  _oneof_case_[0] = kInternalPushTxn;
}
inline void InternalRequestUnion::clear_internal_push_txn() {
  if (has_internal_push_txn()) {
    delete value_.internal_push_txn_;
    clear_has_value();
  }
}
inline const ::cockroach::proto::InternalPushTxnRequest& InternalRequestUnion::internal_push_txn() const {
  return has_internal_push_txn() ? *value_.internal_push_txn_
                      : ::cockroach::proto::InternalPushTxnRequest::default_instance();
}
inline ::cockroach::proto::InternalPushTxnRequest* InternalRequestUnion::mutable_internal_push_txn() {
  if (!has_internal_push_txn()) {
    clear_value();
    set_has_internal_push_txn();
    value_.internal_push_txn_ = new ::cockroach::proto::InternalPushTxnRequest;
  }
  return value_.internal_push_txn_;
}
inline ::cockroach::proto::InternalPushTxnRequest* InternalRequestUnion::release_internal_push_txn() {
  if (has_internal_push_txn()) {
    clear_has_value();
    ::cockroach::proto::InternalPushTxnRequest* temp = value_.internal_push_txn_;
    value_.internal_push_txn_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void InternalRequestUnion::set_allocated_internal_push_txn(::cockroach::proto::InternalPushTxnRequest* internal_push_txn) {
  clear_value();
  if (internal_push_txn) {
    set_has_internal_push_txn();
    value_.internal_push_txn_ = internal_push_txn;
  }
}

// optional .cockroach.proto.InternalResolveIntentRequest internal_resolve_intent = 31;
inline bool InternalRequestUnion::has_internal_resolve_intent() const {
  return value_case() == kInternalResolveIntent;
}
inline void InternalRequestUnion::set_has_internal_resolve_intent() {
  _oneof_case_[0] = kInternalResolveIntent;
}
inline void InternalRequestUnion::clear_internal_resolve_intent() {
  if (has_internal_resolve_intent()) {
    delete value_.internal_resolve_intent_;
    clear_has_value();
  }
}
inline const ::cockroach::proto::InternalResolveIntentRequest& InternalRequestUnion::internal_resolve_intent() const {
  return has_internal_resolve_intent() ? *value_.internal_resolve_intent_
                      : ::cockroach::proto::InternalResolveIntentRequest::default_instance();
}
inline ::cockroach::proto::InternalResolveIntentRequest* InternalRequestUnion::mutable_internal_resolve_intent() {
  if (!has_internal_resolve_intent()) {
    clear_value();
    set_has_internal_resolve_intent();
    value_.internal_resolve_intent_ = new ::cockroach::proto::InternalResolveIntentRequest;
  }
  return value_.internal_resolve_intent_;
}
inline ::cockroach::proto::InternalResolveIntentRequest* InternalRequestUnion::release_internal_resolve_intent() {
  if (has_internal_resolve_intent()) {
    clear_has_value();
    ::cockroach::proto::InternalResolveIntentRequest* temp = value_.internal_resolve_intent_;
    value_.internal_resolve_intent_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void InternalRequestUnion::set_allocated_internal_resolve_intent(::cockroach::proto::InternalResolveIntentRequest* internal_resolve_intent) {
  clear_value();
  if (internal_resolve_intent) {
    set_has_internal_resolve_intent();
    value_.internal_resolve_intent_ = internal_resolve_intent;
  }
}

// optional .cockroach.proto.InternalResolveIntentRangeRequest internal_resolve_intent_range = 32;
inline bool InternalRequestUnion::has_internal_resolve_intent_range() const {
  return value_case() == kInternalResolveIntentRange;
}
inline void InternalRequestUnion::set_has_internal_resolve_intent_range() {
  _oneof_case_[0] = kInternalResolveIntentRange;
}
inline void InternalRequestUnion::clear_internal_resolve_intent_range() {
  if (has_internal_resolve_intent_range()) {
    delete value_.internal_resolve_intent_range_;
    clear_has_value();
  }
}
inline const ::cockroach::proto::InternalResolveIntentRangeRequest& InternalRequestUnion::internal_resolve_intent_range() const {
  return has_internal_resolve_intent_range() ? *value_.internal_resolve_intent_range_
                      : ::cockroach::proto::InternalResolveIntentRangeRequest::default_instance();
}
inline ::cockroach::proto::InternalResolveIntentRangeRequest* InternalRequestUnion::mutable_internal_resolve_intent_range() {
  if (!has_internal_resolve_intent_range()) {
    clear_value();
    set_has_internal_resolve_intent_range();
    value_.internal_resolve_intent_range_ = new ::cockroach::proto::InternalResolveIntentRangeRequest;
  }
  return value_.internal_resolve_intent_range_;
}
inline ::cockroach::proto::InternalResolveIntentRangeRequest* InternalRequestUnion::release_internal_resolve_intent_range() {
  if (has_internal_resolve_intent_range()) {
    clear_has_value();
    ::cockroach::proto::InternalResolveIntentRangeRequest* temp = value_.internal_resolve_intent_range_;
    value_.internal_resolve_intent_range_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void InternalRequestUnion::set_allocated_internal_resolve_intent_range(::cockroach::proto::InternalResolveIntentRangeRequest* internal_resolve_intent_range) {
  clear_value();
  if (internal_resolve_intent_range) {
    set_has_internal_resolve_intent_range();
    value_.internal_resolve_intent_range_ = internal_resolve_intent_range;
  }
}

inline bool InternalRequestUnion::has_value() {
  return value_case() != VALUE_NOT_SET;
}
inline void InternalRequestUnion::clear_has_value() {
  _oneof_case_[0] = VALUE_NOT_SET;
}
inline InternalRequestUnion::ValueCase InternalRequestUnion::value_case() const {
  return InternalRequestUnion::ValueCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// InternalResponseUnion

// optional .cockroach.proto.GetResponse get = 2;
inline bool InternalResponseUnion::has_get() const {
  return value_case() == kGet;
}
inline void InternalResponseUnion::set_has_get() {
  _oneof_case_[0] = kGet;
}
inline void InternalResponseUnion::clear_get() {
  if (has_get()) {
    delete value_.get_;
    clear_has_value();
  }
}
inline const ::cockroach::proto::GetResponse& InternalResponseUnion::get() const {
  return has_get() ? *value_.get_
                      : ::cockroach::proto::GetResponse::default_instance();
}
inline ::cockroach::proto::GetResponse* InternalResponseUnion::mutable_get() {
  if (!has_get()) {
    clear_value();
    set_has_get();
    value_.get_ = new ::cockroach::proto::GetResponse;
  }
  return value_.get_;
}
inline ::cockroach::proto::GetResponse* InternalResponseUnion::release_get() {
  if (has_get()) {
    clear_has_value();
    ::cockroach::proto::GetResponse* temp = value_.get_;
    value_.get_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void InternalResponseUnion::set_allocated_get(::cockroach::proto::GetResponse* get) {
  clear_value();
  if (get) {
    set_has_get();
    value_.get_ = get;
  }
}

// optional .cockroach.proto.PutResponse put = 3;
inline bool InternalResponseUnion::has_put() const {
  return value_case() == kPut;
}
inline void InternalResponseUnion::set_has_put() {
  _oneof_case_[0] = kPut;
}
inline void InternalResponseUnion::clear_put() {
  if (has_put()) {
    delete value_.put_;
    clear_has_value();
  }
}
inline const ::cockroach::proto::PutResponse& InternalResponseUnion::put() const {
  return has_put() ? *value_.put_
                      : ::cockroach::proto::PutResponse::default_instance();
}
inline ::cockroach::proto::PutResponse* InternalResponseUnion::mutable_put() {
  if (!has_put()) {
    clear_value();
    set_has_put();
    value_.put_ = new ::cockroach::proto::PutResponse;
  }
  return value_.put_;
}
inline ::cockroach::proto::PutResponse* InternalResponseUnion::release_put() {
  if (has_put()) {
    clear_has_value();
    ::cockroach::proto::PutResponse* temp = value_.put_;
    value_.put_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void InternalResponseUnion::set_allocated_put(::cockroach::proto::PutResponse* put) {
  clear_value();
  if (put) {
    set_has_put();
    value_.put_ = put;
  }
}

// optional .cockroach.proto.ConditionalPutResponse conditional_put = 4;
inline bool InternalResponseUnion::has_conditional_put() const {
  return value_case() == kConditionalPut;
}
inline void InternalResponseUnion::set_has_conditional_put() {
  _oneof_case_[0] = kConditionalPut;
}
inline void InternalResponseUnion::clear_conditional_put() {
  if (has_conditional_put()) {
    delete value_.conditional_put_;
    clear_has_value();
  }
}
inline const ::cockroach::proto::ConditionalPutResponse& InternalResponseUnion::conditional_put() const {
  return has_conditional_put() ? *value_.conditional_put_
                      : ::cockroach::proto::ConditionalPutResponse::default_instance();
}
inline ::cockroach::proto::ConditionalPutResponse* InternalResponseUnion::mutable_conditional_put() {
  if (!has_conditional_put()) {
    clear_value();
    set_has_conditional_put();
    value_.conditional_put_ = new ::cockroach::proto::ConditionalPutResponse;
  }
  return value_.conditional_put_;
}
inline ::cockroach::proto::ConditionalPutResponse* InternalResponseUnion::release_conditional_put() {
  if (has_conditional_put()) {
    clear_has_value();
    ::cockroach::proto::ConditionalPutResponse* temp = value_.conditional_put_;
    value_.conditional_put_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void InternalResponseUnion::set_allocated_conditional_put(::cockroach::proto::ConditionalPutResponse* conditional_put) {
  clear_value();
  if (conditional_put) {
    set_has_conditional_put();
    value_.conditional_put_ = conditional_put;
  }
}

// optional .cockroach.proto.IncrementResponse increment = 5;
inline bool InternalResponseUnion::has_increment() const {
  return value_case() == kIncrement;
}
inline void InternalResponseUnion::set_has_increment() {
  _oneof_case_[0] = kIncrement;
}
inline void InternalResponseUnion::clear_increment() {
  if (has_increment()) {
    delete value_.increment_;
    clear_has_value();
  }
}
inline const ::cockroach::proto::IncrementResponse& InternalResponseUnion::increment() const {
  return has_increment() ? *value_.increment_
                      : ::cockroach::proto::IncrementResponse::default_instance();
}
inline ::cockroach::proto::IncrementResponse* InternalResponseUnion::mutable_increment() {
  if (!has_increment()) {
    clear_value();
    set_has_increment();
    value_.increment_ = new ::cockroach::proto::IncrementResponse;
  }
  return value_.increment_;
}
inline ::cockroach::proto::IncrementResponse* InternalResponseUnion::release_increment() {
  if (has_increment()) {
    clear_has_value();
    ::cockroach::proto::IncrementResponse* temp = value_.increment_;
    value_.increment_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void InternalResponseUnion::set_allocated_increment(::cockroach::proto::IncrementResponse* increment) {
  clear_value();
  if (increment) {
    set_has_increment();
    value_.increment_ = increment;
  }
}

// optional .cockroach.proto.DeleteResponse delete = 6;
inline bool InternalResponseUnion::has_delete_() const {
  return value_case() == kDelete;
}
inline void InternalResponseUnion::set_has_delete_() {
  _oneof_case_[0] = kDelete;
}
inline void InternalResponseUnion::clear_delete_() {
  if (has_delete_()) {
    delete value_.delete__;
    clear_has_value();
  }
}
inline const ::cockroach::proto::DeleteResponse& InternalResponseUnion::delete_() const {
  return has_delete_() ? *value_.delete__
                      : ::cockroach::proto::DeleteResponse::default_instance();
}
inline ::cockroach::proto::DeleteResponse* InternalResponseUnion::mutable_delete_() {
  if (!has_delete_()) {
    clear_value();
    set_has_delete_();
    value_.delete__ = new ::cockroach::proto::DeleteResponse;
  }
  return value_.delete__;
}
inline ::cockroach::proto::DeleteResponse* InternalResponseUnion::release_delete_() {
  if (has_delete_()) {
    clear_has_value();
    ::cockroach::proto::DeleteResponse* temp = value_.delete__;
    value_.delete__ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void InternalResponseUnion::set_allocated_delete_(::cockroach::proto::DeleteResponse* delete_) {
  clear_value();
  if (delete_) {
    set_has_delete_();
    value_.delete__ = delete_;
  }
}

// optional .cockroach.proto.DeleteRangeResponse delete_range = 7;
inline bool InternalResponseUnion::has_delete_range() const {
  return value_case() == kDeleteRange;
}
inline void InternalResponseUnion::set_has_delete_range() {
  _oneof_case_[0] = kDeleteRange;
}
inline void InternalResponseUnion::clear_delete_range() {
  if (has_delete_range()) {
    delete value_.delete_range_;
    clear_has_value();
  }
}
inline const ::cockroach::proto::DeleteRangeResponse& InternalResponseUnion::delete_range() const {
  return has_delete_range() ? *value_.delete_range_
                      : ::cockroach::proto::DeleteRangeResponse::default_instance();
}
inline ::cockroach::proto::DeleteRangeResponse* InternalResponseUnion::mutable_delete_range() {
  if (!has_delete_range()) {
    clear_value();
    set_has_delete_range();
    value_.delete_range_ = new ::cockroach::proto::DeleteRangeResponse;
  }
  return value_.delete_range_;
}
inline ::cockroach::proto::DeleteRangeResponse* InternalResponseUnion::release_delete_range() {
  if (has_delete_range()) {
    clear_has_value();
    ::cockroach::proto::DeleteRangeResponse* temp = value_.delete_range_;
    value_.delete_range_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void InternalResponseUnion::set_allocated_delete_range(::cockroach::proto::DeleteRangeResponse* delete_range) {
  clear_value();
  if (delete_range) {
    set_has_delete_range();
    value_.delete_range_ = delete_range;
  }
}

// optional .cockroach.proto.ScanResponse scan = 8;
inline bool InternalResponseUnion::has_scan() const {
  return value_case() == kScan;
}
inline void InternalResponseUnion::set_has_scan() {
  _oneof_case_[0] = kScan;
}
inline void InternalResponseUnion::clear_scan() {
  if (has_scan()) {
    delete value_.scan_;
    clear_has_value();
  }
}
inline const ::cockroach::proto::ScanResponse& InternalResponseUnion::scan() const {
  return has_scan() ? *value_.scan_
                      : ::cockroach::proto::ScanResponse::default_instance();
}
inline ::cockroach::proto::ScanResponse* InternalResponseUnion::mutable_scan() {
  if (!has_scan()) {
    clear_value();
    set_has_scan();
    value_.scan_ = new ::cockroach::proto::ScanResponse;
  }
  return value_.scan_;
}
inline ::cockroach::proto::ScanResponse* InternalResponseUnion::release_scan() {
  if (has_scan()) {
    clear_has_value();
    ::cockroach::proto::ScanResponse* temp = value_.scan_;
    value_.scan_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void InternalResponseUnion::set_allocated_scan(::cockroach::proto::ScanResponse* scan) {
  clear_value();
  if (scan) {
    set_has_scan();
    value_.scan_ = scan;
  }
}

// optional .cockroach.proto.EndTransactionResponse end_transaction = 9;
inline bool InternalResponseUnion::has_end_transaction() const {
  return value_case() == kEndTransaction;
}
inline void InternalResponseUnion::set_has_end_transaction() {
  _oneof_case_[0] = kEndTransaction;
}
inline void InternalResponseUnion::clear_end_transaction() {
  if (has_end_transaction()) {
    delete value_.end_transaction_;
    clear_has_value();
  }
}
inline const ::cockroach::proto::EndTransactionResponse& InternalResponseUnion::end_transaction() const {
  return has_end_transaction() ? *value_.end_transaction_
                      : ::cockroach::proto::EndTransactionResponse::default_instance();
}
inline ::cockroach::proto::EndTransactionResponse* InternalResponseUnion::mutable_end_transaction() {
  if (!has_end_transaction()) {
    clear_value();
    set_has_end_transaction();
    value_.end_transaction_ = new ::cockroach::proto::EndTransactionResponse;
  }
  return value_.end_transaction_;
}
inline ::cockroach::proto::EndTransactionResponse* InternalResponseUnion::release_end_transaction() {
  if (has_end_transaction()) {
    clear_has_value();
    ::cockroach::proto::EndTransactionResponse* temp = value_.end_transaction_;
    value_.end_transaction_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void InternalResponseUnion::set_allocated_end_transaction(::cockroach::proto::EndTransactionResponse* end_transaction) {
  clear_value();
  if (end_transaction) {
    set_has_end_transaction();
    value_.end_transaction_ = end_transaction;
  }
}

// optional .cockroach.proto.InternalPushTxnResponse internal_push_txn = 30;
inline bool InternalResponseUnion::has_internal_push_txn() const {
  return value_case() == kInternalPushTxn;
}
inline void InternalResponseUnion::set_has_internal_push_txn() {
  _oneof_case_[0] = kInternalPushTxn;
}
inline void InternalResponseUnion::clear_internal_push_txn() {
  if (has_internal_push_txn()) {
    delete value_.internal_push_txn_;
    clear_has_value();
  }
}
inline const ::cockroach::proto::InternalPushTxnResponse& InternalResponseUnion::internal_push_txn() const {
  return has_internal_push_txn() ? *value_.internal_push_txn_
                      : ::cockroach::proto::InternalPushTxnResponse::default_instance();
}
inline ::cockroach::proto::InternalPushTxnResponse* InternalResponseUnion::mutable_internal_push_txn() {
  if (!has_internal_push_txn()) {
    clear_value();
    set_has_internal_push_txn();
    value_.internal_push_txn_ = new ::cockroach::proto::InternalPushTxnResponse;
  }
  return value_.internal_push_txn_;
}
inline ::cockroach::proto::InternalPushTxnResponse* InternalResponseUnion::release_internal_push_txn() {
  if (has_internal_push_txn()) {
    clear_has_value();
    ::cockroach::proto::InternalPushTxnResponse* temp = value_.internal_push_txn_;
    value_.internal_push_txn_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void InternalResponseUnion::set_allocated_internal_push_txn(::cockroach::proto::InternalPushTxnResponse* internal_push_txn) {
  clear_value();
  if (internal_push_txn) {
    set_has_internal_push_txn();
    value_.internal_push_txn_ = internal_push_txn;
  }
}

// optional .cockroach.proto.InternalResolveIntentResponse internal_resolve_intent = 31;
inline bool InternalResponseUnion::has_internal_resolve_intent() const {
  return value_case() == kInternalResolveIntent;
}
inline void InternalResponseUnion::set_has_internal_resolve_intent() {
  _oneof_case_[0] = kInternalResolveIntent;
}
inline void InternalResponseUnion::clear_internal_resolve_intent() {
  if (has_internal_resolve_intent()) {
    delete value_.internal_resolve_intent_;
    clear_has_value();
  }
}
inline const ::cockroach::proto::InternalResolveIntentResponse& InternalResponseUnion::internal_resolve_intent() const {
  return has_internal_resolve_intent() ? *value_.internal_resolve_intent_
                      : ::cockroach::proto::InternalResolveIntentResponse::default_instance();
}
inline ::cockroach::proto::InternalResolveIntentResponse* InternalResponseUnion::mutable_internal_resolve_intent() {
  if (!has_internal_resolve_intent()) {
    clear_value();
    set_has_internal_resolve_intent();
    value_.internal_resolve_intent_ = new ::cockroach::proto::InternalResolveIntentResponse;
  }
  return value_.internal_resolve_intent_;
}
inline ::cockroach::proto::InternalResolveIntentResponse* InternalResponseUnion::release_internal_resolve_intent() {
  if (has_internal_resolve_intent()) {
    clear_has_value();
    ::cockroach::proto::InternalResolveIntentResponse* temp = value_.internal_resolve_intent_;
    value_.internal_resolve_intent_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void InternalResponseUnion::set_allocated_internal_resolve_intent(::cockroach::proto::InternalResolveIntentResponse* internal_resolve_intent) {
  clear_value();
  if (internal_resolve_intent) {
    set_has_internal_resolve_intent();
    value_.internal_resolve_intent_ = internal_resolve_intent;
  }
}

// optional .cockroach.proto.InternalResolveIntentRangeResponse internal_resolve_intent_range = 32;
inline bool InternalResponseUnion::has_internal_resolve_intent_range() const {
  return value_case() == kInternalResolveIntentRange;
}
inline void InternalResponseUnion::set_has_internal_resolve_intent_range() {
  _oneof_case_[0] = kInternalResolveIntentRange;
}
inline void InternalResponseUnion::clear_internal_resolve_intent_range() {
  if (has_internal_resolve_intent_range()) {
    delete value_.internal_resolve_intent_range_;
    clear_has_value();
  }
}
inline const ::cockroach::proto::InternalResolveIntentRangeResponse& InternalResponseUnion::internal_resolve_intent_range() const {
  return has_internal_resolve_intent_range() ? *value_.internal_resolve_intent_range_
                      : ::cockroach::proto::InternalResolveIntentRangeResponse::default_instance();
}
inline ::cockroach::proto::InternalResolveIntentRangeResponse* InternalResponseUnion::mutable_internal_resolve_intent_range() {
  if (!has_internal_resolve_intent_range()) {
    clear_value();
    set_has_internal_resolve_intent_range();
    value_.internal_resolve_intent_range_ = new ::cockroach::proto::InternalResolveIntentRangeResponse;
  }
  return value_.internal_resolve_intent_range_;
}
inline ::cockroach::proto::InternalResolveIntentRangeResponse* InternalResponseUnion::release_internal_resolve_intent_range() {
  if (has_internal_resolve_intent_range()) {
    clear_has_value();
    ::cockroach::proto::InternalResolveIntentRangeResponse* temp = value_.internal_resolve_intent_range_;
    value_.internal_resolve_intent_range_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void InternalResponseUnion::set_allocated_internal_resolve_intent_range(::cockroach::proto::InternalResolveIntentRangeResponse* internal_resolve_intent_range) {
  clear_value();
  if (internal_resolve_intent_range) {
    set_has_internal_resolve_intent_range();
    value_.internal_resolve_intent_range_ = internal_resolve_intent_range;
  }
}

inline bool InternalResponseUnion::has_value() {
  return value_case() != VALUE_NOT_SET;
}
inline void InternalResponseUnion::clear_has_value() {
  _oneof_case_[0] = VALUE_NOT_SET;
}
inline InternalResponseUnion::ValueCase InternalResponseUnion::value_case() const {
  return InternalResponseUnion::ValueCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// InternalBatchRequest

// optional .cockroach.proto.RequestHeader header = 1;
inline bool InternalBatchRequest::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InternalBatchRequest::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void InternalBatchRequest::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void InternalBatchRequest::clear_header() {
  if (header_ != NULL) header_->::cockroach::proto::RequestHeader::Clear();
  clear_has_header();
}
inline const ::cockroach::proto::RequestHeader& InternalBatchRequest::header() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.InternalBatchRequest.header)
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
inline ::cockroach::proto::RequestHeader* InternalBatchRequest::mutable_header() {
  set_has_header();
  if (header_ == NULL) header_ = new ::cockroach::proto::RequestHeader;
  // @@protoc_insertion_point(field_mutable:cockroach.proto.InternalBatchRequest.header)
  return header_;
}
inline ::cockroach::proto::RequestHeader* InternalBatchRequest::release_header() {
  clear_has_header();
  ::cockroach::proto::RequestHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void InternalBatchRequest::set_allocated_header(::cockroach::proto::RequestHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.InternalBatchRequest.header)
}

// repeated .cockroach.proto.InternalRequestUnion requests = 2;
inline int InternalBatchRequest::requests_size() const {
  return requests_.size();
}
inline void InternalBatchRequest::clear_requests() {
  requests_.Clear();
}
inline const ::cockroach::proto::InternalRequestUnion& InternalBatchRequest::requests(int index) const {
  // @@protoc_insertion_point(field_get:cockroach.proto.InternalBatchRequest.requests)
  return requests_.Get(index);
}
inline ::cockroach::proto::InternalRequestUnion* InternalBatchRequest::mutable_requests(int index) {
  // @@protoc_insertion_point(field_mutable:cockroach.proto.InternalBatchRequest.requests)
  return requests_.Mutable(index);
}
inline ::cockroach::proto::InternalRequestUnion* InternalBatchRequest::add_requests() {
  // @@protoc_insertion_point(field_add:cockroach.proto.InternalBatchRequest.requests)
  return requests_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::cockroach::proto::InternalRequestUnion >&
InternalBatchRequest::requests() const {
  // @@protoc_insertion_point(field_list:cockroach.proto.InternalBatchRequest.requests)
  return requests_;
}
inline ::google::protobuf::RepeatedPtrField< ::cockroach::proto::InternalRequestUnion >*
InternalBatchRequest::mutable_requests() {
  // @@protoc_insertion_point(field_mutable_list:cockroach.proto.InternalBatchRequest.requests)
  return &requests_;
}

// -------------------------------------------------------------------

// InternalBatchResponse

// optional .cockroach.proto.ResponseHeader header = 1;
inline bool InternalBatchResponse::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InternalBatchResponse::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void InternalBatchResponse::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void InternalBatchResponse::clear_header() {
  if (header_ != NULL) header_->::cockroach::proto::ResponseHeader::Clear();
  clear_has_header();
}
inline const ::cockroach::proto::ResponseHeader& InternalBatchResponse::header() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.InternalBatchResponse.header)
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
inline ::cockroach::proto::ResponseHeader* InternalBatchResponse::mutable_header() {
  set_has_header();
  if (header_ == NULL) header_ = new ::cockroach::proto::ResponseHeader;
  // @@protoc_insertion_point(field_mutable:cockroach.proto.InternalBatchResponse.header)
  return header_;
}
inline ::cockroach::proto::ResponseHeader* InternalBatchResponse::release_header() {
  clear_has_header();
  ::cockroach::proto::ResponseHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void InternalBatchResponse::set_allocated_header(::cockroach::proto::ResponseHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.InternalBatchResponse.header)
}

// repeated .cockroach.proto.InternalResponseUnion responses = 2;
inline int InternalBatchResponse::responses_size() const {
  return responses_.size();
}
inline void InternalBatchResponse::clear_responses() {
  responses_.Clear();
}
inline const ::cockroach::proto::InternalResponseUnion& InternalBatchResponse::responses(int index) const {
  // @@protoc_insertion_point(field_get:cockroach.proto.InternalBatchResponse.responses)
  return responses_.Get(index);
}
inline ::cockroach::proto::InternalResponseUnion* InternalBatchResponse::mutable_responses(int index) {
  // @@protoc_insertion_point(field_mutable:cockroach.proto.InternalBatchResponse.responses)
  return responses_.Mutable(index);
}
inline ::cockroach::proto::InternalResponseUnion* InternalBatchResponse::add_responses() {
  // @@protoc_insertion_point(field_add:cockroach.proto.InternalBatchResponse.responses)
  return responses_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::cockroach::proto::InternalResponseUnion >&
InternalBatchResponse::responses() const {
  // @@protoc_insertion_point(field_list:cockroach.proto.InternalBatchResponse.responses)
  return responses_;
}
inline ::google::protobuf::RepeatedPtrField< ::cockroach::proto::InternalResponseUnion >*
InternalBatchResponse::mutable_responses() {
  // @@protoc_insertion_point(field_mutable_list:cockroach.proto.InternalBatchResponse.responses)
  return &responses_;
}

// -------------------------------------------------------------------

// ReadWriteCmdResponse

// optional .cockroach.proto.PutResponse put = 1;
inline bool ReadWriteCmdResponse::has_put() const {
  return value_case() == kPut;
}
inline void ReadWriteCmdResponse::set_has_put() {
  _oneof_case_[0] = kPut;
}
inline void ReadWriteCmdResponse::clear_put() {
  if (has_put()) {
    delete value_.put_;
    clear_has_value();
  }
}
inline const ::cockroach::proto::PutResponse& ReadWriteCmdResponse::put() const {
  return has_put() ? *value_.put_
                      : ::cockroach::proto::PutResponse::default_instance();
}
inline ::cockroach::proto::PutResponse* ReadWriteCmdResponse::mutable_put() {
  if (!has_put()) {
    clear_value();
    set_has_put();
    value_.put_ = new ::cockroach::proto::PutResponse;
  }
  return value_.put_;
}
inline ::cockroach::proto::PutResponse* ReadWriteCmdResponse::release_put() {
  if (has_put()) {
    clear_has_value();
    ::cockroach::proto::PutResponse* temp = value_.put_;
    value_.put_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void ReadWriteCmdResponse::set_allocated_put(::cockroach::proto::PutResponse* put) {
  clear_value();
  if (put) {
    set_has_put();
    value_.put_ = put;
  }
}

// optional .cockroach.proto.ConditionalPutResponse conditional_put = 2;
inline bool ReadWriteCmdResponse::has_conditional_put() const {
  return value_case() == kConditionalPut;
}
inline void ReadWriteCmdResponse::set_has_conditional_put() {
  _oneof_case_[0] = kConditionalPut;
}
inline void ReadWriteCmdResponse::clear_conditional_put() {
  if (has_conditional_put()) {
    delete value_.conditional_put_;
    clear_has_value();
  }
}
inline const ::cockroach::proto::ConditionalPutResponse& ReadWriteCmdResponse::conditional_put() const {
  return has_conditional_put() ? *value_.conditional_put_
                      : ::cockroach::proto::ConditionalPutResponse::default_instance();
}
inline ::cockroach::proto::ConditionalPutResponse* ReadWriteCmdResponse::mutable_conditional_put() {
  if (!has_conditional_put()) {
    clear_value();
    set_has_conditional_put();
    value_.conditional_put_ = new ::cockroach::proto::ConditionalPutResponse;
  }
  return value_.conditional_put_;
}
inline ::cockroach::proto::ConditionalPutResponse* ReadWriteCmdResponse::release_conditional_put() {
  if (has_conditional_put()) {
    clear_has_value();
    ::cockroach::proto::ConditionalPutResponse* temp = value_.conditional_put_;
    value_.conditional_put_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void ReadWriteCmdResponse::set_allocated_conditional_put(::cockroach::proto::ConditionalPutResponse* conditional_put) {
  clear_value();
  if (conditional_put) {
    set_has_conditional_put();
    value_.conditional_put_ = conditional_put;
  }
}

// optional .cockroach.proto.IncrementResponse increment = 3;
inline bool ReadWriteCmdResponse::has_increment() const {
  return value_case() == kIncrement;
}
inline void ReadWriteCmdResponse::set_has_increment() {
  _oneof_case_[0] = kIncrement;
}
inline void ReadWriteCmdResponse::clear_increment() {
  if (has_increment()) {
    delete value_.increment_;
    clear_has_value();
  }
}
inline const ::cockroach::proto::IncrementResponse& ReadWriteCmdResponse::increment() const {
  return has_increment() ? *value_.increment_
                      : ::cockroach::proto::IncrementResponse::default_instance();
}
inline ::cockroach::proto::IncrementResponse* ReadWriteCmdResponse::mutable_increment() {
  if (!has_increment()) {
    clear_value();
    set_has_increment();
    value_.increment_ = new ::cockroach::proto::IncrementResponse;
  }
  return value_.increment_;
}
inline ::cockroach::proto::IncrementResponse* ReadWriteCmdResponse::release_increment() {
  if (has_increment()) {
    clear_has_value();
    ::cockroach::proto::IncrementResponse* temp = value_.increment_;
    value_.increment_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void ReadWriteCmdResponse::set_allocated_increment(::cockroach::proto::IncrementResponse* increment) {
  clear_value();
  if (increment) {
    set_has_increment();
    value_.increment_ = increment;
  }
}

// optional .cockroach.proto.DeleteResponse delete = 4;
inline bool ReadWriteCmdResponse::has_delete_() const {
  return value_case() == kDelete;
}
inline void ReadWriteCmdResponse::set_has_delete_() {
  _oneof_case_[0] = kDelete;
}
inline void ReadWriteCmdResponse::clear_delete_() {
  if (has_delete_()) {
    delete value_.delete__;
    clear_has_value();
  }
}
inline const ::cockroach::proto::DeleteResponse& ReadWriteCmdResponse::delete_() const {
  return has_delete_() ? *value_.delete__
                      : ::cockroach::proto::DeleteResponse::default_instance();
}
inline ::cockroach::proto::DeleteResponse* ReadWriteCmdResponse::mutable_delete_() {
  if (!has_delete_()) {
    clear_value();
    set_has_delete_();
    value_.delete__ = new ::cockroach::proto::DeleteResponse;
  }
  return value_.delete__;
}
inline ::cockroach::proto::DeleteResponse* ReadWriteCmdResponse::release_delete_() {
  if (has_delete_()) {
    clear_has_value();
    ::cockroach::proto::DeleteResponse* temp = value_.delete__;
    value_.delete__ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void ReadWriteCmdResponse::set_allocated_delete_(::cockroach::proto::DeleteResponse* delete_) {
  clear_value();
  if (delete_) {
    set_has_delete_();
    value_.delete__ = delete_;
  }
}

// optional .cockroach.proto.DeleteRangeResponse delete_range = 5;
inline bool ReadWriteCmdResponse::has_delete_range() const {
  return value_case() == kDeleteRange;
}
inline void ReadWriteCmdResponse::set_has_delete_range() {
  _oneof_case_[0] = kDeleteRange;
}
inline void ReadWriteCmdResponse::clear_delete_range() {
  if (has_delete_range()) {
    delete value_.delete_range_;
    clear_has_value();
  }
}
inline const ::cockroach::proto::DeleteRangeResponse& ReadWriteCmdResponse::delete_range() const {
  return has_delete_range() ? *value_.delete_range_
                      : ::cockroach::proto::DeleteRangeResponse::default_instance();
}
inline ::cockroach::proto::DeleteRangeResponse* ReadWriteCmdResponse::mutable_delete_range() {
  if (!has_delete_range()) {
    clear_value();
    set_has_delete_range();
    value_.delete_range_ = new ::cockroach::proto::DeleteRangeResponse;
  }
  return value_.delete_range_;
}
inline ::cockroach::proto::DeleteRangeResponse* ReadWriteCmdResponse::release_delete_range() {
  if (has_delete_range()) {
    clear_has_value();
    ::cockroach::proto::DeleteRangeResponse* temp = value_.delete_range_;
    value_.delete_range_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void ReadWriteCmdResponse::set_allocated_delete_range(::cockroach::proto::DeleteRangeResponse* delete_range) {
  clear_value();
  if (delete_range) {
    set_has_delete_range();
    value_.delete_range_ = delete_range;
  }
}

// optional .cockroach.proto.EndTransactionResponse end_transaction = 6;
inline bool ReadWriteCmdResponse::has_end_transaction() const {
  return value_case() == kEndTransaction;
}
inline void ReadWriteCmdResponse::set_has_end_transaction() {
  _oneof_case_[0] = kEndTransaction;
}
inline void ReadWriteCmdResponse::clear_end_transaction() {
  if (has_end_transaction()) {
    delete value_.end_transaction_;
    clear_has_value();
  }
}
inline const ::cockroach::proto::EndTransactionResponse& ReadWriteCmdResponse::end_transaction() const {
  return has_end_transaction() ? *value_.end_transaction_
                      : ::cockroach::proto::EndTransactionResponse::default_instance();
}
inline ::cockroach::proto::EndTransactionResponse* ReadWriteCmdResponse::mutable_end_transaction() {
  if (!has_end_transaction()) {
    clear_value();
    set_has_end_transaction();
    value_.end_transaction_ = new ::cockroach::proto::EndTransactionResponse;
  }
  return value_.end_transaction_;
}
inline ::cockroach::proto::EndTransactionResponse* ReadWriteCmdResponse::release_end_transaction() {
  if (has_end_transaction()) {
    clear_has_value();
    ::cockroach::proto::EndTransactionResponse* temp = value_.end_transaction_;
    value_.end_transaction_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void ReadWriteCmdResponse::set_allocated_end_transaction(::cockroach::proto::EndTransactionResponse* end_transaction) {
  clear_value();
  if (end_transaction) {
    set_has_end_transaction();
    value_.end_transaction_ = end_transaction;
  }
}

// optional .cockroach.proto.InternalHeartbeatTxnResponse internal_heartbeat_txn = 10;
inline bool ReadWriteCmdResponse::has_internal_heartbeat_txn() const {
  return value_case() == kInternalHeartbeatTxn;
}
inline void ReadWriteCmdResponse::set_has_internal_heartbeat_txn() {
  _oneof_case_[0] = kInternalHeartbeatTxn;
}
inline void ReadWriteCmdResponse::clear_internal_heartbeat_txn() {
  if (has_internal_heartbeat_txn()) {
    delete value_.internal_heartbeat_txn_;
    clear_has_value();
  }
}
inline const ::cockroach::proto::InternalHeartbeatTxnResponse& ReadWriteCmdResponse::internal_heartbeat_txn() const {
  return has_internal_heartbeat_txn() ? *value_.internal_heartbeat_txn_
                      : ::cockroach::proto::InternalHeartbeatTxnResponse::default_instance();
}
inline ::cockroach::proto::InternalHeartbeatTxnResponse* ReadWriteCmdResponse::mutable_internal_heartbeat_txn() {
  if (!has_internal_heartbeat_txn()) {
    clear_value();
    set_has_internal_heartbeat_txn();
    value_.internal_heartbeat_txn_ = new ::cockroach::proto::InternalHeartbeatTxnResponse;
  }
  return value_.internal_heartbeat_txn_;
}
inline ::cockroach::proto::InternalHeartbeatTxnResponse* ReadWriteCmdResponse::release_internal_heartbeat_txn() {
  if (has_internal_heartbeat_txn()) {
    clear_has_value();
    ::cockroach::proto::InternalHeartbeatTxnResponse* temp = value_.internal_heartbeat_txn_;
    value_.internal_heartbeat_txn_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void ReadWriteCmdResponse::set_allocated_internal_heartbeat_txn(::cockroach::proto::InternalHeartbeatTxnResponse* internal_heartbeat_txn) {
  clear_value();
  if (internal_heartbeat_txn) {
    set_has_internal_heartbeat_txn();
    value_.internal_heartbeat_txn_ = internal_heartbeat_txn;
  }
}

// optional .cockroach.proto.InternalPushTxnResponse internal_push_txn = 11;
inline bool ReadWriteCmdResponse::has_internal_push_txn() const {
  return value_case() == kInternalPushTxn;
}
inline void ReadWriteCmdResponse::set_has_internal_push_txn() {
  _oneof_case_[0] = kInternalPushTxn;
}
inline void ReadWriteCmdResponse::clear_internal_push_txn() {
  if (has_internal_push_txn()) {
    delete value_.internal_push_txn_;
    clear_has_value();
  }
}
inline const ::cockroach::proto::InternalPushTxnResponse& ReadWriteCmdResponse::internal_push_txn() const {
  return has_internal_push_txn() ? *value_.internal_push_txn_
                      : ::cockroach::proto::InternalPushTxnResponse::default_instance();
}
inline ::cockroach::proto::InternalPushTxnResponse* ReadWriteCmdResponse::mutable_internal_push_txn() {
  if (!has_internal_push_txn()) {
    clear_value();
    set_has_internal_push_txn();
    value_.internal_push_txn_ = new ::cockroach::proto::InternalPushTxnResponse;
  }
  return value_.internal_push_txn_;
}
inline ::cockroach::proto::InternalPushTxnResponse* ReadWriteCmdResponse::release_internal_push_txn() {
  if (has_internal_push_txn()) {
    clear_has_value();
    ::cockroach::proto::InternalPushTxnResponse* temp = value_.internal_push_txn_;
    value_.internal_push_txn_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void ReadWriteCmdResponse::set_allocated_internal_push_txn(::cockroach::proto::InternalPushTxnResponse* internal_push_txn) {
  clear_value();
  if (internal_push_txn) {
    set_has_internal_push_txn();
    value_.internal_push_txn_ = internal_push_txn;
  }
}

// optional .cockroach.proto.InternalResolveIntentResponse internal_resolve_intent = 12;
inline bool ReadWriteCmdResponse::has_internal_resolve_intent() const {
  return value_case() == kInternalResolveIntent;
}
inline void ReadWriteCmdResponse::set_has_internal_resolve_intent() {
  _oneof_case_[0] = kInternalResolveIntent;
}
inline void ReadWriteCmdResponse::clear_internal_resolve_intent() {
  if (has_internal_resolve_intent()) {
    delete value_.internal_resolve_intent_;
    clear_has_value();
  }
}
inline const ::cockroach::proto::InternalResolveIntentResponse& ReadWriteCmdResponse::internal_resolve_intent() const {
  return has_internal_resolve_intent() ? *value_.internal_resolve_intent_
                      : ::cockroach::proto::InternalResolveIntentResponse::default_instance();
}
inline ::cockroach::proto::InternalResolveIntentResponse* ReadWriteCmdResponse::mutable_internal_resolve_intent() {
  if (!has_internal_resolve_intent()) {
    clear_value();
    set_has_internal_resolve_intent();
    value_.internal_resolve_intent_ = new ::cockroach::proto::InternalResolveIntentResponse;
  }
  return value_.internal_resolve_intent_;
}
inline ::cockroach::proto::InternalResolveIntentResponse* ReadWriteCmdResponse::release_internal_resolve_intent() {
  if (has_internal_resolve_intent()) {
    clear_has_value();
    ::cockroach::proto::InternalResolveIntentResponse* temp = value_.internal_resolve_intent_;
    value_.internal_resolve_intent_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void ReadWriteCmdResponse::set_allocated_internal_resolve_intent(::cockroach::proto::InternalResolveIntentResponse* internal_resolve_intent) {
  clear_value();
  if (internal_resolve_intent) {
    set_has_internal_resolve_intent();
    value_.internal_resolve_intent_ = internal_resolve_intent;
  }
}

// optional .cockroach.proto.InternalResolveIntentRangeResponse internal_resolve_intent_range = 13;
inline bool ReadWriteCmdResponse::has_internal_resolve_intent_range() const {
  return value_case() == kInternalResolveIntentRange;
}
inline void ReadWriteCmdResponse::set_has_internal_resolve_intent_range() {
  _oneof_case_[0] = kInternalResolveIntentRange;
}
inline void ReadWriteCmdResponse::clear_internal_resolve_intent_range() {
  if (has_internal_resolve_intent_range()) {
    delete value_.internal_resolve_intent_range_;
    clear_has_value();
  }
}
inline const ::cockroach::proto::InternalResolveIntentRangeResponse& ReadWriteCmdResponse::internal_resolve_intent_range() const {
  return has_internal_resolve_intent_range() ? *value_.internal_resolve_intent_range_
                      : ::cockroach::proto::InternalResolveIntentRangeResponse::default_instance();
}
inline ::cockroach::proto::InternalResolveIntentRangeResponse* ReadWriteCmdResponse::mutable_internal_resolve_intent_range() {
  if (!has_internal_resolve_intent_range()) {
    clear_value();
    set_has_internal_resolve_intent_range();
    value_.internal_resolve_intent_range_ = new ::cockroach::proto::InternalResolveIntentRangeResponse;
  }
  return value_.internal_resolve_intent_range_;
}
inline ::cockroach::proto::InternalResolveIntentRangeResponse* ReadWriteCmdResponse::release_internal_resolve_intent_range() {
  if (has_internal_resolve_intent_range()) {
    clear_has_value();
    ::cockroach::proto::InternalResolveIntentRangeResponse* temp = value_.internal_resolve_intent_range_;
    value_.internal_resolve_intent_range_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void ReadWriteCmdResponse::set_allocated_internal_resolve_intent_range(::cockroach::proto::InternalResolveIntentRangeResponse* internal_resolve_intent_range) {
  clear_value();
  if (internal_resolve_intent_range) {
    set_has_internal_resolve_intent_range();
    value_.internal_resolve_intent_range_ = internal_resolve_intent_range;
  }
}

// optional .cockroach.proto.InternalMergeResponse internal_merge = 14;
inline bool ReadWriteCmdResponse::has_internal_merge() const {
  return value_case() == kInternalMerge;
}
inline void ReadWriteCmdResponse::set_has_internal_merge() {
  _oneof_case_[0] = kInternalMerge;
}
inline void ReadWriteCmdResponse::clear_internal_merge() {
  if (has_internal_merge()) {
    delete value_.internal_merge_;
    clear_has_value();
  }
}
inline const ::cockroach::proto::InternalMergeResponse& ReadWriteCmdResponse::internal_merge() const {
  return has_internal_merge() ? *value_.internal_merge_
                      : ::cockroach::proto::InternalMergeResponse::default_instance();
}
inline ::cockroach::proto::InternalMergeResponse* ReadWriteCmdResponse::mutable_internal_merge() {
  if (!has_internal_merge()) {
    clear_value();
    set_has_internal_merge();
    value_.internal_merge_ = new ::cockroach::proto::InternalMergeResponse;
  }
  return value_.internal_merge_;
}
inline ::cockroach::proto::InternalMergeResponse* ReadWriteCmdResponse::release_internal_merge() {
  if (has_internal_merge()) {
    clear_has_value();
    ::cockroach::proto::InternalMergeResponse* temp = value_.internal_merge_;
    value_.internal_merge_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void ReadWriteCmdResponse::set_allocated_internal_merge(::cockroach::proto::InternalMergeResponse* internal_merge) {
  clear_value();
  if (internal_merge) {
    set_has_internal_merge();
    value_.internal_merge_ = internal_merge;
  }
}

// optional .cockroach.proto.InternalTruncateLogResponse internal_truncate_log = 15;
inline bool ReadWriteCmdResponse::has_internal_truncate_log() const {
  return value_case() == kInternalTruncateLog;
}
inline void ReadWriteCmdResponse::set_has_internal_truncate_log() {
  _oneof_case_[0] = kInternalTruncateLog;
}
inline void ReadWriteCmdResponse::clear_internal_truncate_log() {
  if (has_internal_truncate_log()) {
    delete value_.internal_truncate_log_;
    clear_has_value();
  }
}
inline const ::cockroach::proto::InternalTruncateLogResponse& ReadWriteCmdResponse::internal_truncate_log() const {
  return has_internal_truncate_log() ? *value_.internal_truncate_log_
                      : ::cockroach::proto::InternalTruncateLogResponse::default_instance();
}
inline ::cockroach::proto::InternalTruncateLogResponse* ReadWriteCmdResponse::mutable_internal_truncate_log() {
  if (!has_internal_truncate_log()) {
    clear_value();
    set_has_internal_truncate_log();
    value_.internal_truncate_log_ = new ::cockroach::proto::InternalTruncateLogResponse;
  }
  return value_.internal_truncate_log_;
}
inline ::cockroach::proto::InternalTruncateLogResponse* ReadWriteCmdResponse::release_internal_truncate_log() {
  if (has_internal_truncate_log()) {
    clear_has_value();
    ::cockroach::proto::InternalTruncateLogResponse* temp = value_.internal_truncate_log_;
    value_.internal_truncate_log_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void ReadWriteCmdResponse::set_allocated_internal_truncate_log(::cockroach::proto::InternalTruncateLogResponse* internal_truncate_log) {
  clear_value();
  if (internal_truncate_log) {
    set_has_internal_truncate_log();
    value_.internal_truncate_log_ = internal_truncate_log;
  }
}

// optional .cockroach.proto.InternalGCResponse internal_gc = 16;
inline bool ReadWriteCmdResponse::has_internal_gc() const {
  return value_case() == kInternalGc;
}
inline void ReadWriteCmdResponse::set_has_internal_gc() {
  _oneof_case_[0] = kInternalGc;
}
inline void ReadWriteCmdResponse::clear_internal_gc() {
  if (has_internal_gc()) {
    delete value_.internal_gc_;
    clear_has_value();
  }
}
inline const ::cockroach::proto::InternalGCResponse& ReadWriteCmdResponse::internal_gc() const {
  return has_internal_gc() ? *value_.internal_gc_
                      : ::cockroach::proto::InternalGCResponse::default_instance();
}
inline ::cockroach::proto::InternalGCResponse* ReadWriteCmdResponse::mutable_internal_gc() {
  if (!has_internal_gc()) {
    clear_value();
    set_has_internal_gc();
    value_.internal_gc_ = new ::cockroach::proto::InternalGCResponse;
  }
  return value_.internal_gc_;
}
inline ::cockroach::proto::InternalGCResponse* ReadWriteCmdResponse::release_internal_gc() {
  if (has_internal_gc()) {
    clear_has_value();
    ::cockroach::proto::InternalGCResponse* temp = value_.internal_gc_;
    value_.internal_gc_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void ReadWriteCmdResponse::set_allocated_internal_gc(::cockroach::proto::InternalGCResponse* internal_gc) {
  clear_value();
  if (internal_gc) {
    set_has_internal_gc();
    value_.internal_gc_ = internal_gc;
  }
}

// optional .cockroach.proto.InternalLeaderLeaseResponse internal_leader_lease = 17;
inline bool ReadWriteCmdResponse::has_internal_leader_lease() const {
  return value_case() == kInternalLeaderLease;
}
inline void ReadWriteCmdResponse::set_has_internal_leader_lease() {
  _oneof_case_[0] = kInternalLeaderLease;
}
inline void ReadWriteCmdResponse::clear_internal_leader_lease() {
  if (has_internal_leader_lease()) {
    delete value_.internal_leader_lease_;
    clear_has_value();
  }
}
inline const ::cockroach::proto::InternalLeaderLeaseResponse& ReadWriteCmdResponse::internal_leader_lease() const {
  return has_internal_leader_lease() ? *value_.internal_leader_lease_
                      : ::cockroach::proto::InternalLeaderLeaseResponse::default_instance();
}
inline ::cockroach::proto::InternalLeaderLeaseResponse* ReadWriteCmdResponse::mutable_internal_leader_lease() {
  if (!has_internal_leader_lease()) {
    clear_value();
    set_has_internal_leader_lease();
    value_.internal_leader_lease_ = new ::cockroach::proto::InternalLeaderLeaseResponse;
  }
  return value_.internal_leader_lease_;
}
inline ::cockroach::proto::InternalLeaderLeaseResponse* ReadWriteCmdResponse::release_internal_leader_lease() {
  if (has_internal_leader_lease()) {
    clear_has_value();
    ::cockroach::proto::InternalLeaderLeaseResponse* temp = value_.internal_leader_lease_;
    value_.internal_leader_lease_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void ReadWriteCmdResponse::set_allocated_internal_leader_lease(::cockroach::proto::InternalLeaderLeaseResponse* internal_leader_lease) {
  clear_value();
  if (internal_leader_lease) {
    set_has_internal_leader_lease();
    value_.internal_leader_lease_ = internal_leader_lease;
  }
}

inline bool ReadWriteCmdResponse::has_value() {
  return value_case() != VALUE_NOT_SET;
}
inline void ReadWriteCmdResponse::clear_has_value() {
  _oneof_case_[0] = VALUE_NOT_SET;
}
inline ReadWriteCmdResponse::ValueCase ReadWriteCmdResponse::value_case() const {
  return ReadWriteCmdResponse::ValueCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// InternalRaftCommandUnion

// optional .cockroach.proto.GetRequest get = 2;
inline bool InternalRaftCommandUnion::has_get() const {
  return value_case() == kGet;
}
inline void InternalRaftCommandUnion::set_has_get() {
  _oneof_case_[0] = kGet;
}
inline void InternalRaftCommandUnion::clear_get() {
  if (has_get()) {
    delete value_.get_;
    clear_has_value();
  }
}
inline const ::cockroach::proto::GetRequest& InternalRaftCommandUnion::get() const {
  return has_get() ? *value_.get_
                      : ::cockroach::proto::GetRequest::default_instance();
}
inline ::cockroach::proto::GetRequest* InternalRaftCommandUnion::mutable_get() {
  if (!has_get()) {
    clear_value();
    set_has_get();
    value_.get_ = new ::cockroach::proto::GetRequest;
  }
  return value_.get_;
}
inline ::cockroach::proto::GetRequest* InternalRaftCommandUnion::release_get() {
  if (has_get()) {
    clear_has_value();
    ::cockroach::proto::GetRequest* temp = value_.get_;
    value_.get_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void InternalRaftCommandUnion::set_allocated_get(::cockroach::proto::GetRequest* get) {
  clear_value();
  if (get) {
    set_has_get();
    value_.get_ = get;
  }
}

// optional .cockroach.proto.PutRequest put = 3;
inline bool InternalRaftCommandUnion::has_put() const {
  return value_case() == kPut;
}
inline void InternalRaftCommandUnion::set_has_put() {
  _oneof_case_[0] = kPut;
}
inline void InternalRaftCommandUnion::clear_put() {
  if (has_put()) {
    delete value_.put_;
    clear_has_value();
  }
}
inline const ::cockroach::proto::PutRequest& InternalRaftCommandUnion::put() const {
  return has_put() ? *value_.put_
                      : ::cockroach::proto::PutRequest::default_instance();
}
inline ::cockroach::proto::PutRequest* InternalRaftCommandUnion::mutable_put() {
  if (!has_put()) {
    clear_value();
    set_has_put();
    value_.put_ = new ::cockroach::proto::PutRequest;
  }
  return value_.put_;
}
inline ::cockroach::proto::PutRequest* InternalRaftCommandUnion::release_put() {
  if (has_put()) {
    clear_has_value();
    ::cockroach::proto::PutRequest* temp = value_.put_;
    value_.put_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void InternalRaftCommandUnion::set_allocated_put(::cockroach::proto::PutRequest* put) {
  clear_value();
  if (put) {
    set_has_put();
    value_.put_ = put;
  }
}

// optional .cockroach.proto.ConditionalPutRequest conditional_put = 4;
inline bool InternalRaftCommandUnion::has_conditional_put() const {
  return value_case() == kConditionalPut;
}
inline void InternalRaftCommandUnion::set_has_conditional_put() {
  _oneof_case_[0] = kConditionalPut;
}
inline void InternalRaftCommandUnion::clear_conditional_put() {
  if (has_conditional_put()) {
    delete value_.conditional_put_;
    clear_has_value();
  }
}
inline const ::cockroach::proto::ConditionalPutRequest& InternalRaftCommandUnion::conditional_put() const {
  return has_conditional_put() ? *value_.conditional_put_
                      : ::cockroach::proto::ConditionalPutRequest::default_instance();
}
inline ::cockroach::proto::ConditionalPutRequest* InternalRaftCommandUnion::mutable_conditional_put() {
  if (!has_conditional_put()) {
    clear_value();
    set_has_conditional_put();
    value_.conditional_put_ = new ::cockroach::proto::ConditionalPutRequest;
  }
  return value_.conditional_put_;
}
inline ::cockroach::proto::ConditionalPutRequest* InternalRaftCommandUnion::release_conditional_put() {
  if (has_conditional_put()) {
    clear_has_value();
    ::cockroach::proto::ConditionalPutRequest* temp = value_.conditional_put_;
    value_.conditional_put_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void InternalRaftCommandUnion::set_allocated_conditional_put(::cockroach::proto::ConditionalPutRequest* conditional_put) {
  clear_value();
  if (conditional_put) {
    set_has_conditional_put();
    value_.conditional_put_ = conditional_put;
  }
}

// optional .cockroach.proto.IncrementRequest increment = 5;
inline bool InternalRaftCommandUnion::has_increment() const {
  return value_case() == kIncrement;
}
inline void InternalRaftCommandUnion::set_has_increment() {
  _oneof_case_[0] = kIncrement;
}
inline void InternalRaftCommandUnion::clear_increment() {
  if (has_increment()) {
    delete value_.increment_;
    clear_has_value();
  }
}
inline const ::cockroach::proto::IncrementRequest& InternalRaftCommandUnion::increment() const {
  return has_increment() ? *value_.increment_
                      : ::cockroach::proto::IncrementRequest::default_instance();
}
inline ::cockroach::proto::IncrementRequest* InternalRaftCommandUnion::mutable_increment() {
  if (!has_increment()) {
    clear_value();
    set_has_increment();
    value_.increment_ = new ::cockroach::proto::IncrementRequest;
  }
  return value_.increment_;
}
inline ::cockroach::proto::IncrementRequest* InternalRaftCommandUnion::release_increment() {
  if (has_increment()) {
    clear_has_value();
    ::cockroach::proto::IncrementRequest* temp = value_.increment_;
    value_.increment_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void InternalRaftCommandUnion::set_allocated_increment(::cockroach::proto::IncrementRequest* increment) {
  clear_value();
  if (increment) {
    set_has_increment();
    value_.increment_ = increment;
  }
}

// optional .cockroach.proto.DeleteRequest delete = 6;
inline bool InternalRaftCommandUnion::has_delete_() const {
  return value_case() == kDelete;
}
inline void InternalRaftCommandUnion::set_has_delete_() {
  _oneof_case_[0] = kDelete;
}
inline void InternalRaftCommandUnion::clear_delete_() {
  if (has_delete_()) {
    delete value_.delete__;
    clear_has_value();
  }
}
inline const ::cockroach::proto::DeleteRequest& InternalRaftCommandUnion::delete_() const {
  return has_delete_() ? *value_.delete__
                      : ::cockroach::proto::DeleteRequest::default_instance();
}
inline ::cockroach::proto::DeleteRequest* InternalRaftCommandUnion::mutable_delete_() {
  if (!has_delete_()) {
    clear_value();
    set_has_delete_();
    value_.delete__ = new ::cockroach::proto::DeleteRequest;
  }
  return value_.delete__;
}
inline ::cockroach::proto::DeleteRequest* InternalRaftCommandUnion::release_delete_() {
  if (has_delete_()) {
    clear_has_value();
    ::cockroach::proto::DeleteRequest* temp = value_.delete__;
    value_.delete__ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void InternalRaftCommandUnion::set_allocated_delete_(::cockroach::proto::DeleteRequest* delete_) {
  clear_value();
  if (delete_) {
    set_has_delete_();
    value_.delete__ = delete_;
  }
}

// optional .cockroach.proto.DeleteRangeRequest delete_range = 7;
inline bool InternalRaftCommandUnion::has_delete_range() const {
  return value_case() == kDeleteRange;
}
inline void InternalRaftCommandUnion::set_has_delete_range() {
  _oneof_case_[0] = kDeleteRange;
}
inline void InternalRaftCommandUnion::clear_delete_range() {
  if (has_delete_range()) {
    delete value_.delete_range_;
    clear_has_value();
  }
}
inline const ::cockroach::proto::DeleteRangeRequest& InternalRaftCommandUnion::delete_range() const {
  return has_delete_range() ? *value_.delete_range_
                      : ::cockroach::proto::DeleteRangeRequest::default_instance();
}
inline ::cockroach::proto::DeleteRangeRequest* InternalRaftCommandUnion::mutable_delete_range() {
  if (!has_delete_range()) {
    clear_value();
    set_has_delete_range();
    value_.delete_range_ = new ::cockroach::proto::DeleteRangeRequest;
  }
  return value_.delete_range_;
}
inline ::cockroach::proto::DeleteRangeRequest* InternalRaftCommandUnion::release_delete_range() {
  if (has_delete_range()) {
    clear_has_value();
    ::cockroach::proto::DeleteRangeRequest* temp = value_.delete_range_;
    value_.delete_range_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void InternalRaftCommandUnion::set_allocated_delete_range(::cockroach::proto::DeleteRangeRequest* delete_range) {
  clear_value();
  if (delete_range) {
    set_has_delete_range();
    value_.delete_range_ = delete_range;
  }
}

// optional .cockroach.proto.ScanRequest scan = 8;
inline bool InternalRaftCommandUnion::has_scan() const {
  return value_case() == kScan;
}
inline void InternalRaftCommandUnion::set_has_scan() {
  _oneof_case_[0] = kScan;
}
inline void InternalRaftCommandUnion::clear_scan() {
  if (has_scan()) {
    delete value_.scan_;
    clear_has_value();
  }
}
inline const ::cockroach::proto::ScanRequest& InternalRaftCommandUnion::scan() const {
  return has_scan() ? *value_.scan_
                      : ::cockroach::proto::ScanRequest::default_instance();
}
inline ::cockroach::proto::ScanRequest* InternalRaftCommandUnion::mutable_scan() {
  if (!has_scan()) {
    clear_value();
    set_has_scan();
    value_.scan_ = new ::cockroach::proto::ScanRequest;
  }
  return value_.scan_;
}
inline ::cockroach::proto::ScanRequest* InternalRaftCommandUnion::release_scan() {
  if (has_scan()) {
    clear_has_value();
    ::cockroach::proto::ScanRequest* temp = value_.scan_;
    value_.scan_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void InternalRaftCommandUnion::set_allocated_scan(::cockroach::proto::ScanRequest* scan) {
  clear_value();
  if (scan) {
    set_has_scan();
    value_.scan_ = scan;
  }
}

// optional .cockroach.proto.EndTransactionRequest end_transaction = 9;
inline bool InternalRaftCommandUnion::has_end_transaction() const {
  return value_case() == kEndTransaction;
}
inline void InternalRaftCommandUnion::set_has_end_transaction() {
  _oneof_case_[0] = kEndTransaction;
}
inline void InternalRaftCommandUnion::clear_end_transaction() {
  if (has_end_transaction()) {
    delete value_.end_transaction_;
    clear_has_value();
  }
}
inline const ::cockroach::proto::EndTransactionRequest& InternalRaftCommandUnion::end_transaction() const {
  return has_end_transaction() ? *value_.end_transaction_
                      : ::cockroach::proto::EndTransactionRequest::default_instance();
}
inline ::cockroach::proto::EndTransactionRequest* InternalRaftCommandUnion::mutable_end_transaction() {
  if (!has_end_transaction()) {
    clear_value();
    set_has_end_transaction();
    value_.end_transaction_ = new ::cockroach::proto::EndTransactionRequest;
  }
  return value_.end_transaction_;
}
inline ::cockroach::proto::EndTransactionRequest* InternalRaftCommandUnion::release_end_transaction() {
  if (has_end_transaction()) {
    clear_has_value();
    ::cockroach::proto::EndTransactionRequest* temp = value_.end_transaction_;
    value_.end_transaction_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void InternalRaftCommandUnion::set_allocated_end_transaction(::cockroach::proto::EndTransactionRequest* end_transaction) {
  clear_value();
  if (end_transaction) {
    set_has_end_transaction();
    value_.end_transaction_ = end_transaction;
  }
}

// optional .cockroach.proto.BatchRequest batch = 30;
inline bool InternalRaftCommandUnion::has_batch() const {
  return value_case() == kBatch;
}
inline void InternalRaftCommandUnion::set_has_batch() {
  _oneof_case_[0] = kBatch;
}
inline void InternalRaftCommandUnion::clear_batch() {
  if (has_batch()) {
    delete value_.batch_;
    clear_has_value();
  }
}
inline const ::cockroach::proto::BatchRequest& InternalRaftCommandUnion::batch() const {
  return has_batch() ? *value_.batch_
                      : ::cockroach::proto::BatchRequest::default_instance();
}
inline ::cockroach::proto::BatchRequest* InternalRaftCommandUnion::mutable_batch() {
  if (!has_batch()) {
    clear_value();
    set_has_batch();
    value_.batch_ = new ::cockroach::proto::BatchRequest;
  }
  return value_.batch_;
}
inline ::cockroach::proto::BatchRequest* InternalRaftCommandUnion::release_batch() {
  if (has_batch()) {
    clear_has_value();
    ::cockroach::proto::BatchRequest* temp = value_.batch_;
    value_.batch_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void InternalRaftCommandUnion::set_allocated_batch(::cockroach::proto::BatchRequest* batch) {
  clear_value();
  if (batch) {
    set_has_batch();
    value_.batch_ = batch;
  }
}

// optional .cockroach.proto.InternalRangeLookupRequest internal_range_lookup = 31;
inline bool InternalRaftCommandUnion::has_internal_range_lookup() const {
  return value_case() == kInternalRangeLookup;
}
inline void InternalRaftCommandUnion::set_has_internal_range_lookup() {
  _oneof_case_[0] = kInternalRangeLookup;
}
inline void InternalRaftCommandUnion::clear_internal_range_lookup() {
  if (has_internal_range_lookup()) {
    delete value_.internal_range_lookup_;
    clear_has_value();
  }
}
inline const ::cockroach::proto::InternalRangeLookupRequest& InternalRaftCommandUnion::internal_range_lookup() const {
  return has_internal_range_lookup() ? *value_.internal_range_lookup_
                      : ::cockroach::proto::InternalRangeLookupRequest::default_instance();
}
inline ::cockroach::proto::InternalRangeLookupRequest* InternalRaftCommandUnion::mutable_internal_range_lookup() {
  if (!has_internal_range_lookup()) {
    clear_value();
    set_has_internal_range_lookup();
    value_.internal_range_lookup_ = new ::cockroach::proto::InternalRangeLookupRequest;
  }
  return value_.internal_range_lookup_;
}
inline ::cockroach::proto::InternalRangeLookupRequest* InternalRaftCommandUnion::release_internal_range_lookup() {
  if (has_internal_range_lookup()) {
    clear_has_value();
    ::cockroach::proto::InternalRangeLookupRequest* temp = value_.internal_range_lookup_;
    value_.internal_range_lookup_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void InternalRaftCommandUnion::set_allocated_internal_range_lookup(::cockroach::proto::InternalRangeLookupRequest* internal_range_lookup) {
  clear_value();
  if (internal_range_lookup) {
    set_has_internal_range_lookup();
    value_.internal_range_lookup_ = internal_range_lookup;
  }
}

// optional .cockroach.proto.InternalHeartbeatTxnRequest internal_heartbeat_txn = 32;
inline bool InternalRaftCommandUnion::has_internal_heartbeat_txn() const {
  return value_case() == kInternalHeartbeatTxn;
}
inline void InternalRaftCommandUnion::set_has_internal_heartbeat_txn() {
  _oneof_case_[0] = kInternalHeartbeatTxn;
}
inline void InternalRaftCommandUnion::clear_internal_heartbeat_txn() {
  if (has_internal_heartbeat_txn()) {
    delete value_.internal_heartbeat_txn_;
    clear_has_value();
  }
}
inline const ::cockroach::proto::InternalHeartbeatTxnRequest& InternalRaftCommandUnion::internal_heartbeat_txn() const {
  return has_internal_heartbeat_txn() ? *value_.internal_heartbeat_txn_
                      : ::cockroach::proto::InternalHeartbeatTxnRequest::default_instance();
}
inline ::cockroach::proto::InternalHeartbeatTxnRequest* InternalRaftCommandUnion::mutable_internal_heartbeat_txn() {
  if (!has_internal_heartbeat_txn()) {
    clear_value();
    set_has_internal_heartbeat_txn();
    value_.internal_heartbeat_txn_ = new ::cockroach::proto::InternalHeartbeatTxnRequest;
  }
  return value_.internal_heartbeat_txn_;
}
inline ::cockroach::proto::InternalHeartbeatTxnRequest* InternalRaftCommandUnion::release_internal_heartbeat_txn() {
  if (has_internal_heartbeat_txn()) {
    clear_has_value();
    ::cockroach::proto::InternalHeartbeatTxnRequest* temp = value_.internal_heartbeat_txn_;
    value_.internal_heartbeat_txn_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void InternalRaftCommandUnion::set_allocated_internal_heartbeat_txn(::cockroach::proto::InternalHeartbeatTxnRequest* internal_heartbeat_txn) {
  clear_value();
  if (internal_heartbeat_txn) {
    set_has_internal_heartbeat_txn();
    value_.internal_heartbeat_txn_ = internal_heartbeat_txn;
  }
}

// optional .cockroach.proto.InternalPushTxnRequest internal_push_txn = 33;
inline bool InternalRaftCommandUnion::has_internal_push_txn() const {
  return value_case() == kInternalPushTxn;
}
inline void InternalRaftCommandUnion::set_has_internal_push_txn() {
  _oneof_case_[0] = kInternalPushTxn;
}
inline void InternalRaftCommandUnion::clear_internal_push_txn() {
  if (has_internal_push_txn()) {
    delete value_.internal_push_txn_;
    clear_has_value();
  }
}
inline const ::cockroach::proto::InternalPushTxnRequest& InternalRaftCommandUnion::internal_push_txn() const {
  return has_internal_push_txn() ? *value_.internal_push_txn_
                      : ::cockroach::proto::InternalPushTxnRequest::default_instance();
}
inline ::cockroach::proto::InternalPushTxnRequest* InternalRaftCommandUnion::mutable_internal_push_txn() {
  if (!has_internal_push_txn()) {
    clear_value();
    set_has_internal_push_txn();
    value_.internal_push_txn_ = new ::cockroach::proto::InternalPushTxnRequest;
  }
  return value_.internal_push_txn_;
}
inline ::cockroach::proto::InternalPushTxnRequest* InternalRaftCommandUnion::release_internal_push_txn() {
  if (has_internal_push_txn()) {
    clear_has_value();
    ::cockroach::proto::InternalPushTxnRequest* temp = value_.internal_push_txn_;
    value_.internal_push_txn_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void InternalRaftCommandUnion::set_allocated_internal_push_txn(::cockroach::proto::InternalPushTxnRequest* internal_push_txn) {
  clear_value();
  if (internal_push_txn) {
    set_has_internal_push_txn();
    value_.internal_push_txn_ = internal_push_txn;
  }
}

// optional .cockroach.proto.InternalResolveIntentRequest internal_resolve_intent = 34;
inline bool InternalRaftCommandUnion::has_internal_resolve_intent() const {
  return value_case() == kInternalResolveIntent;
}
inline void InternalRaftCommandUnion::set_has_internal_resolve_intent() {
  _oneof_case_[0] = kInternalResolveIntent;
}
inline void InternalRaftCommandUnion::clear_internal_resolve_intent() {
  if (has_internal_resolve_intent()) {
    delete value_.internal_resolve_intent_;
    clear_has_value();
  }
}
inline const ::cockroach::proto::InternalResolveIntentRequest& InternalRaftCommandUnion::internal_resolve_intent() const {
  return has_internal_resolve_intent() ? *value_.internal_resolve_intent_
                      : ::cockroach::proto::InternalResolveIntentRequest::default_instance();
}
inline ::cockroach::proto::InternalResolveIntentRequest* InternalRaftCommandUnion::mutable_internal_resolve_intent() {
  if (!has_internal_resolve_intent()) {
    clear_value();
    set_has_internal_resolve_intent();
    value_.internal_resolve_intent_ = new ::cockroach::proto::InternalResolveIntentRequest;
  }
  return value_.internal_resolve_intent_;
}
inline ::cockroach::proto::InternalResolveIntentRequest* InternalRaftCommandUnion::release_internal_resolve_intent() {
  if (has_internal_resolve_intent()) {
    clear_has_value();
    ::cockroach::proto::InternalResolveIntentRequest* temp = value_.internal_resolve_intent_;
    value_.internal_resolve_intent_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void InternalRaftCommandUnion::set_allocated_internal_resolve_intent(::cockroach::proto::InternalResolveIntentRequest* internal_resolve_intent) {
  clear_value();
  if (internal_resolve_intent) {
    set_has_internal_resolve_intent();
    value_.internal_resolve_intent_ = internal_resolve_intent;
  }
}

// optional .cockroach.proto.InternalResolveIntentRangeRequest internal_resolve_intent_range = 35;
inline bool InternalRaftCommandUnion::has_internal_resolve_intent_range() const {
  return value_case() == kInternalResolveIntentRange;
}
inline void InternalRaftCommandUnion::set_has_internal_resolve_intent_range() {
  _oneof_case_[0] = kInternalResolveIntentRange;
}
inline void InternalRaftCommandUnion::clear_internal_resolve_intent_range() {
  if (has_internal_resolve_intent_range()) {
    delete value_.internal_resolve_intent_range_;
    clear_has_value();
  }
}
inline const ::cockroach::proto::InternalResolveIntentRangeRequest& InternalRaftCommandUnion::internal_resolve_intent_range() const {
  return has_internal_resolve_intent_range() ? *value_.internal_resolve_intent_range_
                      : ::cockroach::proto::InternalResolveIntentRangeRequest::default_instance();
}
inline ::cockroach::proto::InternalResolveIntentRangeRequest* InternalRaftCommandUnion::mutable_internal_resolve_intent_range() {
  if (!has_internal_resolve_intent_range()) {
    clear_value();
    set_has_internal_resolve_intent_range();
    value_.internal_resolve_intent_range_ = new ::cockroach::proto::InternalResolveIntentRangeRequest;
  }
  return value_.internal_resolve_intent_range_;
}
inline ::cockroach::proto::InternalResolveIntentRangeRequest* InternalRaftCommandUnion::release_internal_resolve_intent_range() {
  if (has_internal_resolve_intent_range()) {
    clear_has_value();
    ::cockroach::proto::InternalResolveIntentRangeRequest* temp = value_.internal_resolve_intent_range_;
    value_.internal_resolve_intent_range_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void InternalRaftCommandUnion::set_allocated_internal_resolve_intent_range(::cockroach::proto::InternalResolveIntentRangeRequest* internal_resolve_intent_range) {
  clear_value();
  if (internal_resolve_intent_range) {
    set_has_internal_resolve_intent_range();
    value_.internal_resolve_intent_range_ = internal_resolve_intent_range;
  }
}

// optional .cockroach.proto.InternalMergeRequest internal_merge_response = 36;
inline bool InternalRaftCommandUnion::has_internal_merge_response() const {
  return value_case() == kInternalMergeResponse;
}
inline void InternalRaftCommandUnion::set_has_internal_merge_response() {
  _oneof_case_[0] = kInternalMergeResponse;
}
inline void InternalRaftCommandUnion::clear_internal_merge_response() {
  if (has_internal_merge_response()) {
    delete value_.internal_merge_response_;
    clear_has_value();
  }
}
inline const ::cockroach::proto::InternalMergeRequest& InternalRaftCommandUnion::internal_merge_response() const {
  return has_internal_merge_response() ? *value_.internal_merge_response_
                      : ::cockroach::proto::InternalMergeRequest::default_instance();
}
inline ::cockroach::proto::InternalMergeRequest* InternalRaftCommandUnion::mutable_internal_merge_response() {
  if (!has_internal_merge_response()) {
    clear_value();
    set_has_internal_merge_response();
    value_.internal_merge_response_ = new ::cockroach::proto::InternalMergeRequest;
  }
  return value_.internal_merge_response_;
}
inline ::cockroach::proto::InternalMergeRequest* InternalRaftCommandUnion::release_internal_merge_response() {
  if (has_internal_merge_response()) {
    clear_has_value();
    ::cockroach::proto::InternalMergeRequest* temp = value_.internal_merge_response_;
    value_.internal_merge_response_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void InternalRaftCommandUnion::set_allocated_internal_merge_response(::cockroach::proto::InternalMergeRequest* internal_merge_response) {
  clear_value();
  if (internal_merge_response) {
    set_has_internal_merge_response();
    value_.internal_merge_response_ = internal_merge_response;
  }
}

// optional .cockroach.proto.InternalTruncateLogRequest internal_truncate_log = 37;
inline bool InternalRaftCommandUnion::has_internal_truncate_log() const {
  return value_case() == kInternalTruncateLog;
}
inline void InternalRaftCommandUnion::set_has_internal_truncate_log() {
  _oneof_case_[0] = kInternalTruncateLog;
}
inline void InternalRaftCommandUnion::clear_internal_truncate_log() {
  if (has_internal_truncate_log()) {
    delete value_.internal_truncate_log_;
    clear_has_value();
  }
}
inline const ::cockroach::proto::InternalTruncateLogRequest& InternalRaftCommandUnion::internal_truncate_log() const {
  return has_internal_truncate_log() ? *value_.internal_truncate_log_
                      : ::cockroach::proto::InternalTruncateLogRequest::default_instance();
}
inline ::cockroach::proto::InternalTruncateLogRequest* InternalRaftCommandUnion::mutable_internal_truncate_log() {
  if (!has_internal_truncate_log()) {
    clear_value();
    set_has_internal_truncate_log();
    value_.internal_truncate_log_ = new ::cockroach::proto::InternalTruncateLogRequest;
  }
  return value_.internal_truncate_log_;
}
inline ::cockroach::proto::InternalTruncateLogRequest* InternalRaftCommandUnion::release_internal_truncate_log() {
  if (has_internal_truncate_log()) {
    clear_has_value();
    ::cockroach::proto::InternalTruncateLogRequest* temp = value_.internal_truncate_log_;
    value_.internal_truncate_log_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void InternalRaftCommandUnion::set_allocated_internal_truncate_log(::cockroach::proto::InternalTruncateLogRequest* internal_truncate_log) {
  clear_value();
  if (internal_truncate_log) {
    set_has_internal_truncate_log();
    value_.internal_truncate_log_ = internal_truncate_log;
  }
}

// optional .cockroach.proto.InternalGCRequest internal_gc = 38;
inline bool InternalRaftCommandUnion::has_internal_gc() const {
  return value_case() == kInternalGc;
}
inline void InternalRaftCommandUnion::set_has_internal_gc() {
  _oneof_case_[0] = kInternalGc;
}
inline void InternalRaftCommandUnion::clear_internal_gc() {
  if (has_internal_gc()) {
    delete value_.internal_gc_;
    clear_has_value();
  }
}
inline const ::cockroach::proto::InternalGCRequest& InternalRaftCommandUnion::internal_gc() const {
  return has_internal_gc() ? *value_.internal_gc_
                      : ::cockroach::proto::InternalGCRequest::default_instance();
}
inline ::cockroach::proto::InternalGCRequest* InternalRaftCommandUnion::mutable_internal_gc() {
  if (!has_internal_gc()) {
    clear_value();
    set_has_internal_gc();
    value_.internal_gc_ = new ::cockroach::proto::InternalGCRequest;
  }
  return value_.internal_gc_;
}
inline ::cockroach::proto::InternalGCRequest* InternalRaftCommandUnion::release_internal_gc() {
  if (has_internal_gc()) {
    clear_has_value();
    ::cockroach::proto::InternalGCRequest* temp = value_.internal_gc_;
    value_.internal_gc_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void InternalRaftCommandUnion::set_allocated_internal_gc(::cockroach::proto::InternalGCRequest* internal_gc) {
  clear_value();
  if (internal_gc) {
    set_has_internal_gc();
    value_.internal_gc_ = internal_gc;
  }
}

// optional .cockroach.proto.InternalLeaderLeaseRequest internal_lease = 39;
inline bool InternalRaftCommandUnion::has_internal_lease() const {
  return value_case() == kInternalLease;
}
inline void InternalRaftCommandUnion::set_has_internal_lease() {
  _oneof_case_[0] = kInternalLease;
}
inline void InternalRaftCommandUnion::clear_internal_lease() {
  if (has_internal_lease()) {
    delete value_.internal_lease_;
    clear_has_value();
  }
}
inline const ::cockroach::proto::InternalLeaderLeaseRequest& InternalRaftCommandUnion::internal_lease() const {
  return has_internal_lease() ? *value_.internal_lease_
                      : ::cockroach::proto::InternalLeaderLeaseRequest::default_instance();
}
inline ::cockroach::proto::InternalLeaderLeaseRequest* InternalRaftCommandUnion::mutable_internal_lease() {
  if (!has_internal_lease()) {
    clear_value();
    set_has_internal_lease();
    value_.internal_lease_ = new ::cockroach::proto::InternalLeaderLeaseRequest;
  }
  return value_.internal_lease_;
}
inline ::cockroach::proto::InternalLeaderLeaseRequest* InternalRaftCommandUnion::release_internal_lease() {
  if (has_internal_lease()) {
    clear_has_value();
    ::cockroach::proto::InternalLeaderLeaseRequest* temp = value_.internal_lease_;
    value_.internal_lease_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void InternalRaftCommandUnion::set_allocated_internal_lease(::cockroach::proto::InternalLeaderLeaseRequest* internal_lease) {
  clear_value();
  if (internal_lease) {
    set_has_internal_lease();
    value_.internal_lease_ = internal_lease;
  }
}

// optional .cockroach.proto.InternalBatchRequest internal_batch = 40;
inline bool InternalRaftCommandUnion::has_internal_batch() const {
  return value_case() == kInternalBatch;
}
inline void InternalRaftCommandUnion::set_has_internal_batch() {
  _oneof_case_[0] = kInternalBatch;
}
inline void InternalRaftCommandUnion::clear_internal_batch() {
  if (has_internal_batch()) {
    delete value_.internal_batch_;
    clear_has_value();
  }
}
inline const ::cockroach::proto::InternalBatchRequest& InternalRaftCommandUnion::internal_batch() const {
  return has_internal_batch() ? *value_.internal_batch_
                      : ::cockroach::proto::InternalBatchRequest::default_instance();
}
inline ::cockroach::proto::InternalBatchRequest* InternalRaftCommandUnion::mutable_internal_batch() {
  if (!has_internal_batch()) {
    clear_value();
    set_has_internal_batch();
    value_.internal_batch_ = new ::cockroach::proto::InternalBatchRequest;
  }
  return value_.internal_batch_;
}
inline ::cockroach::proto::InternalBatchRequest* InternalRaftCommandUnion::release_internal_batch() {
  if (has_internal_batch()) {
    clear_has_value();
    ::cockroach::proto::InternalBatchRequest* temp = value_.internal_batch_;
    value_.internal_batch_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void InternalRaftCommandUnion::set_allocated_internal_batch(::cockroach::proto::InternalBatchRequest* internal_batch) {
  clear_value();
  if (internal_batch) {
    set_has_internal_batch();
    value_.internal_batch_ = internal_batch;
  }
}

inline bool InternalRaftCommandUnion::has_value() {
  return value_case() != VALUE_NOT_SET;
}
inline void InternalRaftCommandUnion::clear_has_value() {
  _oneof_case_[0] = VALUE_NOT_SET;
}
inline InternalRaftCommandUnion::ValueCase InternalRaftCommandUnion::value_case() const {
  return InternalRaftCommandUnion::ValueCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// InternalRaftCommand

// optional int64 raft_id = 1;
inline bool InternalRaftCommand::has_raft_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InternalRaftCommand::set_has_raft_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void InternalRaftCommand::clear_has_raft_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void InternalRaftCommand::clear_raft_id() {
  raft_id_ = GOOGLE_LONGLONG(0);
  clear_has_raft_id();
}
inline ::google::protobuf::int64 InternalRaftCommand::raft_id() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.InternalRaftCommand.raft_id)
  return raft_id_;
}
inline void InternalRaftCommand::set_raft_id(::google::protobuf::int64 value) {
  set_has_raft_id();
  raft_id_ = value;
  // @@protoc_insertion_point(field_set:cockroach.proto.InternalRaftCommand.raft_id)
}

// optional uint64 origin_node_id = 2;
inline bool InternalRaftCommand::has_origin_node_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void InternalRaftCommand::set_has_origin_node_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void InternalRaftCommand::clear_has_origin_node_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void InternalRaftCommand::clear_origin_node_id() {
  origin_node_id_ = GOOGLE_ULONGLONG(0);
  clear_has_origin_node_id();
}
inline ::google::protobuf::uint64 InternalRaftCommand::origin_node_id() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.InternalRaftCommand.origin_node_id)
  return origin_node_id_;
}
inline void InternalRaftCommand::set_origin_node_id(::google::protobuf::uint64 value) {
  set_has_origin_node_id();
  origin_node_id_ = value;
  // @@protoc_insertion_point(field_set:cockroach.proto.InternalRaftCommand.origin_node_id)
}

// optional .cockroach.proto.InternalRaftCommandUnion cmd = 3;
inline bool InternalRaftCommand::has_cmd() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void InternalRaftCommand::set_has_cmd() {
  _has_bits_[0] |= 0x00000004u;
}
inline void InternalRaftCommand::clear_has_cmd() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void InternalRaftCommand::clear_cmd() {
  if (cmd_ != NULL) cmd_->::cockroach::proto::InternalRaftCommandUnion::Clear();
  clear_has_cmd();
}
inline const ::cockroach::proto::InternalRaftCommandUnion& InternalRaftCommand::cmd() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.InternalRaftCommand.cmd)
  return cmd_ != NULL ? *cmd_ : *default_instance_->cmd_;
}
inline ::cockroach::proto::InternalRaftCommandUnion* InternalRaftCommand::mutable_cmd() {
  set_has_cmd();
  if (cmd_ == NULL) cmd_ = new ::cockroach::proto::InternalRaftCommandUnion;
  // @@protoc_insertion_point(field_mutable:cockroach.proto.InternalRaftCommand.cmd)
  return cmd_;
}
inline ::cockroach::proto::InternalRaftCommandUnion* InternalRaftCommand::release_cmd() {
  clear_has_cmd();
  ::cockroach::proto::InternalRaftCommandUnion* temp = cmd_;
  cmd_ = NULL;
  return temp;
}
inline void InternalRaftCommand::set_allocated_cmd(::cockroach::proto::InternalRaftCommandUnion* cmd) {
  delete cmd_;
  cmd_ = cmd;
  if (cmd) {
    set_has_cmd();
  } else {
    clear_has_cmd();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.InternalRaftCommand.cmd)
}

// -------------------------------------------------------------------

// RaftMessageRequest

// optional uint64 group_id = 1;
inline bool RaftMessageRequest::has_group_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RaftMessageRequest::set_has_group_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RaftMessageRequest::clear_has_group_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RaftMessageRequest::clear_group_id() {
  group_id_ = GOOGLE_ULONGLONG(0);
  clear_has_group_id();
}
inline ::google::protobuf::uint64 RaftMessageRequest::group_id() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.RaftMessageRequest.group_id)
  return group_id_;
}
inline void RaftMessageRequest::set_group_id(::google::protobuf::uint64 value) {
  set_has_group_id();
  group_id_ = value;
  // @@protoc_insertion_point(field_set:cockroach.proto.RaftMessageRequest.group_id)
}

// optional bytes msg = 2;
inline bool RaftMessageRequest::has_msg() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RaftMessageRequest::set_has_msg() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RaftMessageRequest::clear_has_msg() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RaftMessageRequest::clear_msg() {
  if (msg_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    msg_->clear();
  }
  clear_has_msg();
}
inline const ::std::string& RaftMessageRequest::msg() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.RaftMessageRequest.msg)
  return *msg_;
}
inline void RaftMessageRequest::set_msg(const ::std::string& value) {
  set_has_msg();
  if (msg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    msg_ = new ::std::string;
  }
  msg_->assign(value);
  // @@protoc_insertion_point(field_set:cockroach.proto.RaftMessageRequest.msg)
}
inline void RaftMessageRequest::set_msg(const char* value) {
  set_has_msg();
  if (msg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    msg_ = new ::std::string;
  }
  msg_->assign(value);
  // @@protoc_insertion_point(field_set_char:cockroach.proto.RaftMessageRequest.msg)
}
inline void RaftMessageRequest::set_msg(const void* value, size_t size) {
  set_has_msg();
  if (msg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    msg_ = new ::std::string;
  }
  msg_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:cockroach.proto.RaftMessageRequest.msg)
}
inline ::std::string* RaftMessageRequest::mutable_msg() {
  set_has_msg();
  if (msg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    msg_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.proto.RaftMessageRequest.msg)
  return msg_;
}
inline ::std::string* RaftMessageRequest::release_msg() {
  clear_has_msg();
  if (msg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = msg_;
    msg_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RaftMessageRequest::set_allocated_msg(::std::string* msg) {
  if (msg_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete msg_;
  }
  if (msg) {
    set_has_msg();
    msg_ = msg;
  } else {
    clear_has_msg();
    msg_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.RaftMessageRequest.msg)
}

// -------------------------------------------------------------------

// RaftMessageResponse

// -------------------------------------------------------------------

// InternalTimeSeriesData

// optional int64 start_timestamp_nanos = 1;
inline bool InternalTimeSeriesData::has_start_timestamp_nanos() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InternalTimeSeriesData::set_has_start_timestamp_nanos() {
  _has_bits_[0] |= 0x00000001u;
}
inline void InternalTimeSeriesData::clear_has_start_timestamp_nanos() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void InternalTimeSeriesData::clear_start_timestamp_nanos() {
  start_timestamp_nanos_ = GOOGLE_LONGLONG(0);
  clear_has_start_timestamp_nanos();
}
inline ::google::protobuf::int64 InternalTimeSeriesData::start_timestamp_nanos() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.InternalTimeSeriesData.start_timestamp_nanos)
  return start_timestamp_nanos_;
}
inline void InternalTimeSeriesData::set_start_timestamp_nanos(::google::protobuf::int64 value) {
  set_has_start_timestamp_nanos();
  start_timestamp_nanos_ = value;
  // @@protoc_insertion_point(field_set:cockroach.proto.InternalTimeSeriesData.start_timestamp_nanos)
}

// optional int64 sample_duration_nanos = 2;
inline bool InternalTimeSeriesData::has_sample_duration_nanos() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void InternalTimeSeriesData::set_has_sample_duration_nanos() {
  _has_bits_[0] |= 0x00000002u;
}
inline void InternalTimeSeriesData::clear_has_sample_duration_nanos() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void InternalTimeSeriesData::clear_sample_duration_nanos() {
  sample_duration_nanos_ = GOOGLE_LONGLONG(0);
  clear_has_sample_duration_nanos();
}
inline ::google::protobuf::int64 InternalTimeSeriesData::sample_duration_nanos() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.InternalTimeSeriesData.sample_duration_nanos)
  return sample_duration_nanos_;
}
inline void InternalTimeSeriesData::set_sample_duration_nanos(::google::protobuf::int64 value) {
  set_has_sample_duration_nanos();
  sample_duration_nanos_ = value;
  // @@protoc_insertion_point(field_set:cockroach.proto.InternalTimeSeriesData.sample_duration_nanos)
}

// repeated .cockroach.proto.InternalTimeSeriesSample samples = 3;
inline int InternalTimeSeriesData::samples_size() const {
  return samples_.size();
}
inline void InternalTimeSeriesData::clear_samples() {
  samples_.Clear();
}
inline const ::cockroach::proto::InternalTimeSeriesSample& InternalTimeSeriesData::samples(int index) const {
  // @@protoc_insertion_point(field_get:cockroach.proto.InternalTimeSeriesData.samples)
  return samples_.Get(index);
}
inline ::cockroach::proto::InternalTimeSeriesSample* InternalTimeSeriesData::mutable_samples(int index) {
  // @@protoc_insertion_point(field_mutable:cockroach.proto.InternalTimeSeriesData.samples)
  return samples_.Mutable(index);
}
inline ::cockroach::proto::InternalTimeSeriesSample* InternalTimeSeriesData::add_samples() {
  // @@protoc_insertion_point(field_add:cockroach.proto.InternalTimeSeriesData.samples)
  return samples_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::cockroach::proto::InternalTimeSeriesSample >&
InternalTimeSeriesData::samples() const {
  // @@protoc_insertion_point(field_list:cockroach.proto.InternalTimeSeriesData.samples)
  return samples_;
}
inline ::google::protobuf::RepeatedPtrField< ::cockroach::proto::InternalTimeSeriesSample >*
InternalTimeSeriesData::mutable_samples() {
  // @@protoc_insertion_point(field_mutable_list:cockroach.proto.InternalTimeSeriesData.samples)
  return &samples_;
}

// -------------------------------------------------------------------

// InternalTimeSeriesSample

// optional int32 offset = 1;
inline bool InternalTimeSeriesSample::has_offset() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InternalTimeSeriesSample::set_has_offset() {
  _has_bits_[0] |= 0x00000001u;
}
inline void InternalTimeSeriesSample::clear_has_offset() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void InternalTimeSeriesSample::clear_offset() {
  offset_ = 0;
  clear_has_offset();
}
inline ::google::protobuf::int32 InternalTimeSeriesSample::offset() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.InternalTimeSeriesSample.offset)
  return offset_;
}
inline void InternalTimeSeriesSample::set_offset(::google::protobuf::int32 value) {
  set_has_offset();
  offset_ = value;
  // @@protoc_insertion_point(field_set:cockroach.proto.InternalTimeSeriesSample.offset)
}

// optional uint32 count = 6;
inline bool InternalTimeSeriesSample::has_count() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void InternalTimeSeriesSample::set_has_count() {
  _has_bits_[0] |= 0x00000002u;
}
inline void InternalTimeSeriesSample::clear_has_count() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void InternalTimeSeriesSample::clear_count() {
  count_ = 0u;
  clear_has_count();
}
inline ::google::protobuf::uint32 InternalTimeSeriesSample::count() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.InternalTimeSeriesSample.count)
  return count_;
}
inline void InternalTimeSeriesSample::set_count(::google::protobuf::uint32 value) {
  set_has_count();
  count_ = value;
  // @@protoc_insertion_point(field_set:cockroach.proto.InternalTimeSeriesSample.count)
}

// optional double sum = 7;
inline bool InternalTimeSeriesSample::has_sum() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void InternalTimeSeriesSample::set_has_sum() {
  _has_bits_[0] |= 0x00000004u;
}
inline void InternalTimeSeriesSample::clear_has_sum() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void InternalTimeSeriesSample::clear_sum() {
  sum_ = 0;
  clear_has_sum();
}
inline double InternalTimeSeriesSample::sum() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.InternalTimeSeriesSample.sum)
  return sum_;
}
inline void InternalTimeSeriesSample::set_sum(double value) {
  set_has_sum();
  sum_ = value;
  // @@protoc_insertion_point(field_set:cockroach.proto.InternalTimeSeriesSample.sum)
}

// optional double max = 8;
inline bool InternalTimeSeriesSample::has_max() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void InternalTimeSeriesSample::set_has_max() {
  _has_bits_[0] |= 0x00000008u;
}
inline void InternalTimeSeriesSample::clear_has_max() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void InternalTimeSeriesSample::clear_max() {
  max_ = 0;
  clear_has_max();
}
inline double InternalTimeSeriesSample::max() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.InternalTimeSeriesSample.max)
  return max_;
}
inline void InternalTimeSeriesSample::set_max(double value) {
  set_has_max();
  max_ = value;
  // @@protoc_insertion_point(field_set:cockroach.proto.InternalTimeSeriesSample.max)
}

// optional double min = 9;
inline bool InternalTimeSeriesSample::has_min() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void InternalTimeSeriesSample::set_has_min() {
  _has_bits_[0] |= 0x00000010u;
}
inline void InternalTimeSeriesSample::clear_has_min() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void InternalTimeSeriesSample::clear_min() {
  min_ = 0;
  clear_has_min();
}
inline double InternalTimeSeriesSample::min() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.InternalTimeSeriesSample.min)
  return min_;
}
inline void InternalTimeSeriesSample::set_min(double value) {
  set_has_min();
  min_ = value;
  // @@protoc_insertion_point(field_set:cockroach.proto.InternalTimeSeriesSample.min)
}

// -------------------------------------------------------------------

// RaftTruncatedState

// optional uint64 index = 1;
inline bool RaftTruncatedState::has_index() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RaftTruncatedState::set_has_index() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RaftTruncatedState::clear_has_index() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RaftTruncatedState::clear_index() {
  index_ = GOOGLE_ULONGLONG(0);
  clear_has_index();
}
inline ::google::protobuf::uint64 RaftTruncatedState::index() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.RaftTruncatedState.index)
  return index_;
}
inline void RaftTruncatedState::set_index(::google::protobuf::uint64 value) {
  set_has_index();
  index_ = value;
  // @@protoc_insertion_point(field_set:cockroach.proto.RaftTruncatedState.index)
}

// optional uint64 term = 2;
inline bool RaftTruncatedState::has_term() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RaftTruncatedState::set_has_term() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RaftTruncatedState::clear_has_term() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RaftTruncatedState::clear_term() {
  term_ = GOOGLE_ULONGLONG(0);
  clear_has_term();
}
inline ::google::protobuf::uint64 RaftTruncatedState::term() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.RaftTruncatedState.term)
  return term_;
}
inline void RaftTruncatedState::set_term(::google::protobuf::uint64 value) {
  set_has_term();
  term_ = value;
  // @@protoc_insertion_point(field_set:cockroach.proto.RaftTruncatedState.term)
}

// -------------------------------------------------------------------

// RaftSnapshotData_KeyValue

// optional bytes key = 1;
inline bool RaftSnapshotData_KeyValue::has_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RaftSnapshotData_KeyValue::set_has_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RaftSnapshotData_KeyValue::clear_has_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RaftSnapshotData_KeyValue::clear_key() {
  if (key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_->clear();
  }
  clear_has_key();
}
inline const ::std::string& RaftSnapshotData_KeyValue::key() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.RaftSnapshotData.KeyValue.key)
  return *key_;
}
inline void RaftSnapshotData_KeyValue::set_key(const ::std::string& value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  key_->assign(value);
  // @@protoc_insertion_point(field_set:cockroach.proto.RaftSnapshotData.KeyValue.key)
}
inline void RaftSnapshotData_KeyValue::set_key(const char* value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  key_->assign(value);
  // @@protoc_insertion_point(field_set_char:cockroach.proto.RaftSnapshotData.KeyValue.key)
}
inline void RaftSnapshotData_KeyValue::set_key(const void* value, size_t size) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  key_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:cockroach.proto.RaftSnapshotData.KeyValue.key)
}
inline ::std::string* RaftSnapshotData_KeyValue::mutable_key() {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.proto.RaftSnapshotData.KeyValue.key)
  return key_;
}
inline ::std::string* RaftSnapshotData_KeyValue::release_key() {
  clear_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = key_;
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RaftSnapshotData_KeyValue::set_allocated_key(::std::string* key) {
  if (key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete key_;
  }
  if (key) {
    set_has_key();
    key_ = key;
  } else {
    clear_has_key();
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.RaftSnapshotData.KeyValue.key)
}

// optional bytes value = 2;
inline bool RaftSnapshotData_KeyValue::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RaftSnapshotData_KeyValue::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RaftSnapshotData_KeyValue::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RaftSnapshotData_KeyValue::clear_value() {
  if (value_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_->clear();
  }
  clear_has_value();
}
inline const ::std::string& RaftSnapshotData_KeyValue::value() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.RaftSnapshotData.KeyValue.value)
  return *value_;
}
inline void RaftSnapshotData_KeyValue::set_value(const ::std::string& value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_ = new ::std::string;
  }
  value_->assign(value);
  // @@protoc_insertion_point(field_set:cockroach.proto.RaftSnapshotData.KeyValue.value)
}
inline void RaftSnapshotData_KeyValue::set_value(const char* value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_ = new ::std::string;
  }
  value_->assign(value);
  // @@protoc_insertion_point(field_set_char:cockroach.proto.RaftSnapshotData.KeyValue.value)
}
inline void RaftSnapshotData_KeyValue::set_value(const void* value, size_t size) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_ = new ::std::string;
  }
  value_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:cockroach.proto.RaftSnapshotData.KeyValue.value)
}
inline ::std::string* RaftSnapshotData_KeyValue::mutable_value() {
  set_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.proto.RaftSnapshotData.KeyValue.value)
  return value_;
}
inline ::std::string* RaftSnapshotData_KeyValue::release_value() {
  clear_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = value_;
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RaftSnapshotData_KeyValue::set_allocated_value(::std::string* value) {
  if (value_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete value_;
  }
  if (value) {
    set_has_value();
    value_ = value;
  } else {
    clear_has_value();
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.RaftSnapshotData.KeyValue.value)
}

// -------------------------------------------------------------------

// RaftSnapshotData

// repeated .cockroach.proto.RaftSnapshotData.KeyValue KV = 1;
inline int RaftSnapshotData::kv_size() const {
  return kv_.size();
}
inline void RaftSnapshotData::clear_kv() {
  kv_.Clear();
}
inline const ::cockroach::proto::RaftSnapshotData_KeyValue& RaftSnapshotData::kv(int index) const {
  // @@protoc_insertion_point(field_get:cockroach.proto.RaftSnapshotData.KV)
  return kv_.Get(index);
}
inline ::cockroach::proto::RaftSnapshotData_KeyValue* RaftSnapshotData::mutable_kv(int index) {
  // @@protoc_insertion_point(field_mutable:cockroach.proto.RaftSnapshotData.KV)
  return kv_.Mutable(index);
}
inline ::cockroach::proto::RaftSnapshotData_KeyValue* RaftSnapshotData::add_kv() {
  // @@protoc_insertion_point(field_add:cockroach.proto.RaftSnapshotData.KV)
  return kv_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::cockroach::proto::RaftSnapshotData_KeyValue >&
RaftSnapshotData::kv() const {
  // @@protoc_insertion_point(field_list:cockroach.proto.RaftSnapshotData.KV)
  return kv_;
}
inline ::google::protobuf::RepeatedPtrField< ::cockroach::proto::RaftSnapshotData_KeyValue >*
RaftSnapshotData::mutable_kv() {
  // @@protoc_insertion_point(field_mutable_list:cockroach.proto.RaftSnapshotData.KV)
  return &kv_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace proto
}  // namespace cockroach

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::cockroach::proto::PushTxnType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::cockroach::proto::PushTxnType>() {
  return ::cockroach::proto::PushTxnType_descriptor();
}
template <> struct is_proto_enum< ::cockroach::proto::InternalValueType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::cockroach::proto::InternalValueType>() {
  return ::cockroach::proto::InternalValueType_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_cockroach_2fproto_2finternal_2eproto__INCLUDED
