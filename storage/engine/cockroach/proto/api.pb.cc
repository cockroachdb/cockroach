// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: cockroach/proto/api.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "cockroach/proto/api.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)

namespace cockroach {
namespace proto {

namespace {

const ::google::protobuf::Descriptor* ClientCmdID_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ClientCmdID_reflection_ = NULL;
const ::google::protobuf::Descriptor* RequestHeader_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  RequestHeader_reflection_ = NULL;
const ::google::protobuf::Descriptor* ResponseHeader_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ResponseHeader_reflection_ = NULL;
const ::google::protobuf::Descriptor* KVRequestHeader_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  KVRequestHeader_reflection_ = NULL;
const ::google::protobuf::Descriptor* KVResponseHeader_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  KVResponseHeader_reflection_ = NULL;
const ::google::protobuf::Descriptor* GetRequest_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  GetRequest_reflection_ = NULL;
const ::google::protobuf::Descriptor* GetResponse_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  GetResponse_reflection_ = NULL;
const ::google::protobuf::Descriptor* PutRequest_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  PutRequest_reflection_ = NULL;
const ::google::protobuf::Descriptor* PutResponse_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  PutResponse_reflection_ = NULL;
const ::google::protobuf::Descriptor* ConditionalPutRequest_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ConditionalPutRequest_reflection_ = NULL;
const ::google::protobuf::Descriptor* ConditionalPutResponse_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ConditionalPutResponse_reflection_ = NULL;
const ::google::protobuf::Descriptor* IncrementRequest_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  IncrementRequest_reflection_ = NULL;
const ::google::protobuf::Descriptor* IncrementResponse_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  IncrementResponse_reflection_ = NULL;
const ::google::protobuf::Descriptor* DeleteRequest_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  DeleteRequest_reflection_ = NULL;
const ::google::protobuf::Descriptor* DeleteResponse_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  DeleteResponse_reflection_ = NULL;
const ::google::protobuf::Descriptor* DeleteRangeRequest_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  DeleteRangeRequest_reflection_ = NULL;
const ::google::protobuf::Descriptor* DeleteRangeResponse_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  DeleteRangeResponse_reflection_ = NULL;
const ::google::protobuf::Descriptor* ScanRequest_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ScanRequest_reflection_ = NULL;
const ::google::protobuf::Descriptor* ScanResponse_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ScanResponse_reflection_ = NULL;
const ::google::protobuf::Descriptor* EndTransactionRequest_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  EndTransactionRequest_reflection_ = NULL;
const ::google::protobuf::Descriptor* EndTransactionResponse_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  EndTransactionResponse_reflection_ = NULL;
const ::google::protobuf::Descriptor* RequestUnion_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  RequestUnion_reflection_ = NULL;
struct RequestUnionOneofInstance {
  const ::cockroach::proto::GetRequest* get_;
  const ::cockroach::proto::PutRequest* put_;
  const ::cockroach::proto::ConditionalPutRequest* conditional_put_;
  const ::cockroach::proto::IncrementRequest* increment_;
  const ::cockroach::proto::DeleteRequest* delete__;
  const ::cockroach::proto::DeleteRangeRequest* delete_range_;
  const ::cockroach::proto::ScanRequest* scan_;
  const ::cockroach::proto::EndTransactionRequest* end_transaction_;
}* RequestUnion_default_oneof_instance_ = NULL;
const ::google::protobuf::Descriptor* ResponseUnion_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ResponseUnion_reflection_ = NULL;
struct ResponseUnionOneofInstance {
  const ::cockroach::proto::GetResponse* get_;
  const ::cockroach::proto::PutResponse* put_;
  const ::cockroach::proto::ConditionalPutResponse* conditional_put_;
  const ::cockroach::proto::IncrementResponse* increment_;
  const ::cockroach::proto::DeleteResponse* delete__;
  const ::cockroach::proto::DeleteRangeResponse* delete_range_;
  const ::cockroach::proto::ScanResponse* scan_;
  const ::cockroach::proto::EndTransactionResponse* end_transaction_;
}* ResponseUnion_default_oneof_instance_ = NULL;
const ::google::protobuf::Descriptor* BatchRequest_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  BatchRequest_reflection_ = NULL;
const ::google::protobuf::Descriptor* BatchResponse_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  BatchResponse_reflection_ = NULL;
const ::google::protobuf::Descriptor* AdminSplitRequest_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  AdminSplitRequest_reflection_ = NULL;
const ::google::protobuf::Descriptor* AdminSplitResponse_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  AdminSplitResponse_reflection_ = NULL;
const ::google::protobuf::Descriptor* AdminMergeRequest_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  AdminMergeRequest_reflection_ = NULL;
const ::google::protobuf::Descriptor* AdminMergeResponse_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  AdminMergeResponse_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* ReadConsistencyType_descriptor_ = NULL;

}  // namespace


void protobuf_AssignDesc_cockroach_2fproto_2fapi_2eproto() {
  protobuf_AddDesc_cockroach_2fproto_2fapi_2eproto();
  const ::google::protobuf::FileDescriptor* file =
    ::google::protobuf::DescriptorPool::generated_pool()->FindFileByName(
      "cockroach/proto/api.proto");
  GOOGLE_CHECK(file != NULL);
  ClientCmdID_descriptor_ = file->message_type(0);
  static const int ClientCmdID_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ClientCmdID, wall_time_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ClientCmdID, random_),
  };
  ClientCmdID_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      ClientCmdID_descriptor_,
      ClientCmdID::default_instance_,
      ClientCmdID_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ClientCmdID, _has_bits_[0]),
      -1,
      -1,
      sizeof(ClientCmdID),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ClientCmdID, _internal_metadata_),
      -1);
  RequestHeader_descriptor_ = file->message_type(1);
  static const int RequestHeader_offsets_[6] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RequestHeader, timestamp_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RequestHeader, cmd_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RequestHeader, user_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RequestHeader, user_priority_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RequestHeader, txn_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RequestHeader, read_consistency_),
  };
  RequestHeader_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      RequestHeader_descriptor_,
      RequestHeader::default_instance_,
      RequestHeader_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RequestHeader, _has_bits_[0]),
      -1,
      -1,
      sizeof(RequestHeader),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RequestHeader, _internal_metadata_),
      -1);
  ResponseHeader_descriptor_ = file->message_type(2);
  static const int ResponseHeader_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResponseHeader, error_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResponseHeader, timestamp_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResponseHeader, txn_),
  };
  ResponseHeader_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      ResponseHeader_descriptor_,
      ResponseHeader::default_instance_,
      ResponseHeader_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResponseHeader, _has_bits_[0]),
      -1,
      -1,
      sizeof(ResponseHeader),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResponseHeader, _internal_metadata_),
      -1);
  KVRequestHeader_descriptor_ = file->message_type(3);
  static const int KVRequestHeader_offsets_[5] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(KVRequestHeader, header_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(KVRequestHeader, key_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(KVRequestHeader, end_key_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(KVRequestHeader, replica_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(KVRequestHeader, raft_id_),
  };
  KVRequestHeader_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      KVRequestHeader_descriptor_,
      KVRequestHeader::default_instance_,
      KVRequestHeader_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(KVRequestHeader, _has_bits_[0]),
      -1,
      -1,
      sizeof(KVRequestHeader),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(KVRequestHeader, _internal_metadata_),
      -1);
  KVResponseHeader_descriptor_ = file->message_type(4);
  static const int KVResponseHeader_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(KVResponseHeader, header_),
  };
  KVResponseHeader_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      KVResponseHeader_descriptor_,
      KVResponseHeader::default_instance_,
      KVResponseHeader_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(KVResponseHeader, _has_bits_[0]),
      -1,
      -1,
      sizeof(KVResponseHeader),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(KVResponseHeader, _internal_metadata_),
      -1);
  GetRequest_descriptor_ = file->message_type(5);
  static const int GetRequest_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GetRequest, kvheader_),
  };
  GetRequest_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      GetRequest_descriptor_,
      GetRequest::default_instance_,
      GetRequest_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GetRequest, _has_bits_[0]),
      -1,
      -1,
      sizeof(GetRequest),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GetRequest, _internal_metadata_),
      -1);
  GetResponse_descriptor_ = file->message_type(6);
  static const int GetResponse_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GetResponse, kvheader_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GetResponse, value_),
  };
  GetResponse_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      GetResponse_descriptor_,
      GetResponse::default_instance_,
      GetResponse_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GetResponse, _has_bits_[0]),
      -1,
      -1,
      sizeof(GetResponse),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GetResponse, _internal_metadata_),
      -1);
  PutRequest_descriptor_ = file->message_type(7);
  static const int PutRequest_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PutRequest, kvheader_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PutRequest, value_),
  };
  PutRequest_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      PutRequest_descriptor_,
      PutRequest::default_instance_,
      PutRequest_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PutRequest, _has_bits_[0]),
      -1,
      -1,
      sizeof(PutRequest),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PutRequest, _internal_metadata_),
      -1);
  PutResponse_descriptor_ = file->message_type(8);
  static const int PutResponse_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PutResponse, kvheader_),
  };
  PutResponse_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      PutResponse_descriptor_,
      PutResponse::default_instance_,
      PutResponse_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PutResponse, _has_bits_[0]),
      -1,
      -1,
      sizeof(PutResponse),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PutResponse, _internal_metadata_),
      -1);
  ConditionalPutRequest_descriptor_ = file->message_type(9);
  static const int ConditionalPutRequest_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ConditionalPutRequest, kvheader_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ConditionalPutRequest, value_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ConditionalPutRequest, exp_value_),
  };
  ConditionalPutRequest_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      ConditionalPutRequest_descriptor_,
      ConditionalPutRequest::default_instance_,
      ConditionalPutRequest_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ConditionalPutRequest, _has_bits_[0]),
      -1,
      -1,
      sizeof(ConditionalPutRequest),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ConditionalPutRequest, _internal_metadata_),
      -1);
  ConditionalPutResponse_descriptor_ = file->message_type(10);
  static const int ConditionalPutResponse_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ConditionalPutResponse, kvheader_),
  };
  ConditionalPutResponse_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      ConditionalPutResponse_descriptor_,
      ConditionalPutResponse::default_instance_,
      ConditionalPutResponse_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ConditionalPutResponse, _has_bits_[0]),
      -1,
      -1,
      sizeof(ConditionalPutResponse),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ConditionalPutResponse, _internal_metadata_),
      -1);
  IncrementRequest_descriptor_ = file->message_type(11);
  static const int IncrementRequest_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(IncrementRequest, kvheader_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(IncrementRequest, increment_),
  };
  IncrementRequest_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      IncrementRequest_descriptor_,
      IncrementRequest::default_instance_,
      IncrementRequest_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(IncrementRequest, _has_bits_[0]),
      -1,
      -1,
      sizeof(IncrementRequest),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(IncrementRequest, _internal_metadata_),
      -1);
  IncrementResponse_descriptor_ = file->message_type(12);
  static const int IncrementResponse_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(IncrementResponse, kvheader_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(IncrementResponse, new_value_),
  };
  IncrementResponse_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      IncrementResponse_descriptor_,
      IncrementResponse::default_instance_,
      IncrementResponse_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(IncrementResponse, _has_bits_[0]),
      -1,
      -1,
      sizeof(IncrementResponse),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(IncrementResponse, _internal_metadata_),
      -1);
  DeleteRequest_descriptor_ = file->message_type(13);
  static const int DeleteRequest_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DeleteRequest, kvheader_),
  };
  DeleteRequest_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      DeleteRequest_descriptor_,
      DeleteRequest::default_instance_,
      DeleteRequest_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DeleteRequest, _has_bits_[0]),
      -1,
      -1,
      sizeof(DeleteRequest),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DeleteRequest, _internal_metadata_),
      -1);
  DeleteResponse_descriptor_ = file->message_type(14);
  static const int DeleteResponse_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DeleteResponse, kvheader_),
  };
  DeleteResponse_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      DeleteResponse_descriptor_,
      DeleteResponse::default_instance_,
      DeleteResponse_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DeleteResponse, _has_bits_[0]),
      -1,
      -1,
      sizeof(DeleteResponse),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DeleteResponse, _internal_metadata_),
      -1);
  DeleteRangeRequest_descriptor_ = file->message_type(15);
  static const int DeleteRangeRequest_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DeleteRangeRequest, kvheader_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DeleteRangeRequest, max_entries_to_delete_),
  };
  DeleteRangeRequest_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      DeleteRangeRequest_descriptor_,
      DeleteRangeRequest::default_instance_,
      DeleteRangeRequest_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DeleteRangeRequest, _has_bits_[0]),
      -1,
      -1,
      sizeof(DeleteRangeRequest),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DeleteRangeRequest, _internal_metadata_),
      -1);
  DeleteRangeResponse_descriptor_ = file->message_type(16);
  static const int DeleteRangeResponse_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DeleteRangeResponse, kvheader_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DeleteRangeResponse, num_deleted_),
  };
  DeleteRangeResponse_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      DeleteRangeResponse_descriptor_,
      DeleteRangeResponse::default_instance_,
      DeleteRangeResponse_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DeleteRangeResponse, _has_bits_[0]),
      -1,
      -1,
      sizeof(DeleteRangeResponse),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DeleteRangeResponse, _internal_metadata_),
      -1);
  ScanRequest_descriptor_ = file->message_type(17);
  static const int ScanRequest_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ScanRequest, kvheader_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ScanRequest, max_results_),
  };
  ScanRequest_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      ScanRequest_descriptor_,
      ScanRequest::default_instance_,
      ScanRequest_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ScanRequest, _has_bits_[0]),
      -1,
      -1,
      sizeof(ScanRequest),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ScanRequest, _internal_metadata_),
      -1);
  ScanResponse_descriptor_ = file->message_type(18);
  static const int ScanResponse_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ScanResponse, kvheader_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ScanResponse, rows_),
  };
  ScanResponse_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      ScanResponse_descriptor_,
      ScanResponse::default_instance_,
      ScanResponse_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ScanResponse, _has_bits_[0]),
      -1,
      -1,
      sizeof(ScanResponse),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ScanResponse, _internal_metadata_),
      -1);
  EndTransactionRequest_descriptor_ = file->message_type(19);
  static const int EndTransactionRequest_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EndTransactionRequest, kvheader_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EndTransactionRequest, commit_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EndTransactionRequest, internal_commit_trigger_),
  };
  EndTransactionRequest_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      EndTransactionRequest_descriptor_,
      EndTransactionRequest::default_instance_,
      EndTransactionRequest_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EndTransactionRequest, _has_bits_[0]),
      -1,
      -1,
      sizeof(EndTransactionRequest),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EndTransactionRequest, _internal_metadata_),
      -1);
  EndTransactionResponse_descriptor_ = file->message_type(20);
  static const int EndTransactionResponse_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EndTransactionResponse, kvheader_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EndTransactionResponse, commit_wait_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EndTransactionResponse, resolved_),
  };
  EndTransactionResponse_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      EndTransactionResponse_descriptor_,
      EndTransactionResponse::default_instance_,
      EndTransactionResponse_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EndTransactionResponse, _has_bits_[0]),
      -1,
      -1,
      sizeof(EndTransactionResponse),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EndTransactionResponse, _internal_metadata_),
      -1);
  RequestUnion_descriptor_ = file->message_type(21);
  static const int RequestUnion_offsets_[9] = {
    PROTO2_GENERATED_DEFAULT_ONEOF_FIELD_OFFSET(RequestUnion_default_oneof_instance_, get_),
    PROTO2_GENERATED_DEFAULT_ONEOF_FIELD_OFFSET(RequestUnion_default_oneof_instance_, put_),
    PROTO2_GENERATED_DEFAULT_ONEOF_FIELD_OFFSET(RequestUnion_default_oneof_instance_, conditional_put_),
    PROTO2_GENERATED_DEFAULT_ONEOF_FIELD_OFFSET(RequestUnion_default_oneof_instance_, increment_),
    PROTO2_GENERATED_DEFAULT_ONEOF_FIELD_OFFSET(RequestUnion_default_oneof_instance_, delete__),
    PROTO2_GENERATED_DEFAULT_ONEOF_FIELD_OFFSET(RequestUnion_default_oneof_instance_, delete_range_),
    PROTO2_GENERATED_DEFAULT_ONEOF_FIELD_OFFSET(RequestUnion_default_oneof_instance_, scan_),
    PROTO2_GENERATED_DEFAULT_ONEOF_FIELD_OFFSET(RequestUnion_default_oneof_instance_, end_transaction_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RequestUnion, value_),
  };
  RequestUnion_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      RequestUnion_descriptor_,
      RequestUnion::default_instance_,
      RequestUnion_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RequestUnion, _has_bits_[0]),
      -1,
      -1,
      RequestUnion_default_oneof_instance_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RequestUnion, _oneof_case_[0]),
      sizeof(RequestUnion),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RequestUnion, _internal_metadata_),
      -1);
  ResponseUnion_descriptor_ = file->message_type(22);
  static const int ResponseUnion_offsets_[9] = {
    PROTO2_GENERATED_DEFAULT_ONEOF_FIELD_OFFSET(ResponseUnion_default_oneof_instance_, get_),
    PROTO2_GENERATED_DEFAULT_ONEOF_FIELD_OFFSET(ResponseUnion_default_oneof_instance_, put_),
    PROTO2_GENERATED_DEFAULT_ONEOF_FIELD_OFFSET(ResponseUnion_default_oneof_instance_, conditional_put_),
    PROTO2_GENERATED_DEFAULT_ONEOF_FIELD_OFFSET(ResponseUnion_default_oneof_instance_, increment_),
    PROTO2_GENERATED_DEFAULT_ONEOF_FIELD_OFFSET(ResponseUnion_default_oneof_instance_, delete__),
    PROTO2_GENERATED_DEFAULT_ONEOF_FIELD_OFFSET(ResponseUnion_default_oneof_instance_, delete_range_),
    PROTO2_GENERATED_DEFAULT_ONEOF_FIELD_OFFSET(ResponseUnion_default_oneof_instance_, scan_),
    PROTO2_GENERATED_DEFAULT_ONEOF_FIELD_OFFSET(ResponseUnion_default_oneof_instance_, end_transaction_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResponseUnion, value_),
  };
  ResponseUnion_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      ResponseUnion_descriptor_,
      ResponseUnion::default_instance_,
      ResponseUnion_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResponseUnion, _has_bits_[0]),
      -1,
      -1,
      ResponseUnion_default_oneof_instance_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResponseUnion, _oneof_case_[0]),
      sizeof(ResponseUnion),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResponseUnion, _internal_metadata_),
      -1);
  BatchRequest_descriptor_ = file->message_type(23);
  static const int BatchRequest_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BatchRequest, kvheader_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BatchRequest, requests_),
  };
  BatchRequest_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      BatchRequest_descriptor_,
      BatchRequest::default_instance_,
      BatchRequest_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BatchRequest, _has_bits_[0]),
      -1,
      -1,
      sizeof(BatchRequest),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BatchRequest, _internal_metadata_),
      -1);
  BatchResponse_descriptor_ = file->message_type(24);
  static const int BatchResponse_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BatchResponse, kvheader_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BatchResponse, responses_),
  };
  BatchResponse_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      BatchResponse_descriptor_,
      BatchResponse::default_instance_,
      BatchResponse_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BatchResponse, _has_bits_[0]),
      -1,
      -1,
      sizeof(BatchResponse),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BatchResponse, _internal_metadata_),
      -1);
  AdminSplitRequest_descriptor_ = file->message_type(25);
  static const int AdminSplitRequest_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AdminSplitRequest, kvheader_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AdminSplitRequest, split_key_),
  };
  AdminSplitRequest_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      AdminSplitRequest_descriptor_,
      AdminSplitRequest::default_instance_,
      AdminSplitRequest_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AdminSplitRequest, _has_bits_[0]),
      -1,
      -1,
      sizeof(AdminSplitRequest),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AdminSplitRequest, _internal_metadata_),
      -1);
  AdminSplitResponse_descriptor_ = file->message_type(26);
  static const int AdminSplitResponse_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AdminSplitResponse, kvheader_),
  };
  AdminSplitResponse_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      AdminSplitResponse_descriptor_,
      AdminSplitResponse::default_instance_,
      AdminSplitResponse_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AdminSplitResponse, _has_bits_[0]),
      -1,
      -1,
      sizeof(AdminSplitResponse),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AdminSplitResponse, _internal_metadata_),
      -1);
  AdminMergeRequest_descriptor_ = file->message_type(27);
  static const int AdminMergeRequest_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AdminMergeRequest, kvheader_),
  };
  AdminMergeRequest_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      AdminMergeRequest_descriptor_,
      AdminMergeRequest::default_instance_,
      AdminMergeRequest_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AdminMergeRequest, _has_bits_[0]),
      -1,
      -1,
      sizeof(AdminMergeRequest),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AdminMergeRequest, _internal_metadata_),
      -1);
  AdminMergeResponse_descriptor_ = file->message_type(28);
  static const int AdminMergeResponse_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AdminMergeResponse, kvheader_),
  };
  AdminMergeResponse_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      AdminMergeResponse_descriptor_,
      AdminMergeResponse::default_instance_,
      AdminMergeResponse_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AdminMergeResponse, _has_bits_[0]),
      -1,
      -1,
      sizeof(AdminMergeResponse),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AdminMergeResponse, _internal_metadata_),
      -1);
  ReadConsistencyType_descriptor_ = file->enum_type(0);
}

namespace {

GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AssignDescriptors_once_);
inline void protobuf_AssignDescriptorsOnce() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AssignDescriptors_once_,
                 &protobuf_AssignDesc_cockroach_2fproto_2fapi_2eproto);
}

void protobuf_RegisterTypes(const ::std::string&) {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      ClientCmdID_descriptor_, &ClientCmdID::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      RequestHeader_descriptor_, &RequestHeader::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      ResponseHeader_descriptor_, &ResponseHeader::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      KVRequestHeader_descriptor_, &KVRequestHeader::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      KVResponseHeader_descriptor_, &KVResponseHeader::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      GetRequest_descriptor_, &GetRequest::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      GetResponse_descriptor_, &GetResponse::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      PutRequest_descriptor_, &PutRequest::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      PutResponse_descriptor_, &PutResponse::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      ConditionalPutRequest_descriptor_, &ConditionalPutRequest::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      ConditionalPutResponse_descriptor_, &ConditionalPutResponse::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      IncrementRequest_descriptor_, &IncrementRequest::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      IncrementResponse_descriptor_, &IncrementResponse::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      DeleteRequest_descriptor_, &DeleteRequest::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      DeleteResponse_descriptor_, &DeleteResponse::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      DeleteRangeRequest_descriptor_, &DeleteRangeRequest::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      DeleteRangeResponse_descriptor_, &DeleteRangeResponse::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      ScanRequest_descriptor_, &ScanRequest::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      ScanResponse_descriptor_, &ScanResponse::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      EndTransactionRequest_descriptor_, &EndTransactionRequest::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      EndTransactionResponse_descriptor_, &EndTransactionResponse::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      RequestUnion_descriptor_, &RequestUnion::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      ResponseUnion_descriptor_, &ResponseUnion::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      BatchRequest_descriptor_, &BatchRequest::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      BatchResponse_descriptor_, &BatchResponse::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      AdminSplitRequest_descriptor_, &AdminSplitRequest::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      AdminSplitResponse_descriptor_, &AdminSplitResponse::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      AdminMergeRequest_descriptor_, &AdminMergeRequest::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      AdminMergeResponse_descriptor_, &AdminMergeResponse::default_instance());
}

}  // namespace

void protobuf_ShutdownFile_cockroach_2fproto_2fapi_2eproto() {
  delete ClientCmdID::default_instance_;
  delete ClientCmdID_reflection_;
  delete RequestHeader::default_instance_;
  delete RequestHeader_reflection_;
  delete ResponseHeader::default_instance_;
  delete ResponseHeader_reflection_;
  delete KVRequestHeader::default_instance_;
  delete KVRequestHeader_reflection_;
  delete KVResponseHeader::default_instance_;
  delete KVResponseHeader_reflection_;
  delete GetRequest::default_instance_;
  delete GetRequest_reflection_;
  delete GetResponse::default_instance_;
  delete GetResponse_reflection_;
  delete PutRequest::default_instance_;
  delete PutRequest_reflection_;
  delete PutResponse::default_instance_;
  delete PutResponse_reflection_;
  delete ConditionalPutRequest::default_instance_;
  delete ConditionalPutRequest_reflection_;
  delete ConditionalPutResponse::default_instance_;
  delete ConditionalPutResponse_reflection_;
  delete IncrementRequest::default_instance_;
  delete IncrementRequest_reflection_;
  delete IncrementResponse::default_instance_;
  delete IncrementResponse_reflection_;
  delete DeleteRequest::default_instance_;
  delete DeleteRequest_reflection_;
  delete DeleteResponse::default_instance_;
  delete DeleteResponse_reflection_;
  delete DeleteRangeRequest::default_instance_;
  delete DeleteRangeRequest_reflection_;
  delete DeleteRangeResponse::default_instance_;
  delete DeleteRangeResponse_reflection_;
  delete ScanRequest::default_instance_;
  delete ScanRequest_reflection_;
  delete ScanResponse::default_instance_;
  delete ScanResponse_reflection_;
  delete EndTransactionRequest::default_instance_;
  delete EndTransactionRequest_reflection_;
  delete EndTransactionResponse::default_instance_;
  delete EndTransactionResponse_reflection_;
  delete RequestUnion::default_instance_;
  delete RequestUnion_default_oneof_instance_;
  delete RequestUnion_reflection_;
  delete ResponseUnion::default_instance_;
  delete ResponseUnion_default_oneof_instance_;
  delete ResponseUnion_reflection_;
  delete BatchRequest::default_instance_;
  delete BatchRequest_reflection_;
  delete BatchResponse::default_instance_;
  delete BatchResponse_reflection_;
  delete AdminSplitRequest::default_instance_;
  delete AdminSplitRequest_reflection_;
  delete AdminSplitResponse::default_instance_;
  delete AdminSplitResponse_reflection_;
  delete AdminMergeRequest::default_instance_;
  delete AdminMergeRequest_reflection_;
  delete AdminMergeResponse::default_instance_;
  delete AdminMergeResponse_reflection_;
}

void protobuf_AddDesc_cockroach_2fproto_2fapi_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  ::cockroach::proto::protobuf_AddDesc_cockroach_2fproto_2fconfig_2eproto();
  ::cockroach::proto::protobuf_AddDesc_cockroach_2fproto_2fdata_2eproto();
  ::cockroach::proto::protobuf_AddDesc_cockroach_2fproto_2ferrors_2eproto();
  ::gogoproto::protobuf_AddDesc_gogoproto_2fgogo_2eproto();
  ::google::protobuf::DescriptorPool::InternalAddGeneratedFile(
    "\n\031cockroach/proto/api.proto\022\017cockroach.p"
    "roto\032\034cockroach/proto/config.proto\032\032cock"
    "roach/proto/data.proto\032\034cockroach/proto/"
    "errors.proto\032\024gogoproto/gogo.proto\"<\n\013Cl"
    "ientCmdID\022\027\n\twall_time\030\001 \001(\003B\004\310\336\037\000\022\024\n\006ra"
    "ndom\030\002 \001(\003B\004\310\336\037\000\"\240\002\n\rRequestHeader\0223\n\tti"
    "mestamp\030\001 \001(\0132\032.cockroach.proto.Timestam"
    "pB\004\310\336\037\000\022;\n\006cmd_id\030\002 \001(\0132\034.cockroach.prot"
    "o.ClientCmdIDB\r\310\336\037\000\342\336\037\005CmdID\022\022\n\004user\030\005 \001"
    "(\tB\004\310\336\037\000\022\030\n\ruser_priority\030\010 \001(\005:\0011\022)\n\003tx"
    "n\030\t \001(\0132\034.cockroach.proto.Transaction\022D\n"
    "\020read_consistency\030\n \001(\0162$.cockroach.prot"
    "o.ReadConsistencyTypeB\004\310\336\037\000\"\227\001\n\016Response"
    "Header\022%\n\005error\030\001 \001(\0132\026.cockroach.proto."
    "Error\0223\n\ttimestamp\030\002 \001(\0132\032.cockroach.pro"
    "to.TimestampB\004\310\336\037\000\022)\n\003txn\030\003 \001(\0132\034.cockro"
    "ach.proto.Transaction\"\327\001\n\017KVRequestHeade"
    "r\0228\n\006header\030\001 \001(\0132\036.cockroach.proto.Requ"
    "estHeaderB\010\310\336\037\000\320\336\037\001\022\024\n\003key\030\003 \001(\014B\007\372\336\037\003Ke"
    "y\022\030\n\007end_key\030\004 \001(\014B\007\372\336\037\003Key\022/\n\007replica\030\006"
    " \001(\0132\030.cockroach.proto.ReplicaB\004\310\336\037\000\022)\n\007"
    "raft_id\030\007 \001(\003B\030\310\336\037\000\342\336\037\006RaftID\372\336\037\006RaftID\""
    "M\n\020KVResponseHeader\0229\n\006header\030\001 \001(\0132\037.co"
    "ckroach.proto.ResponseHeaderB\010\310\336\037\000\320\336\037\001\"J"
    "\n\nGetRequest\022<\n\010kvheader\030\001 \001(\0132 .cockroa"
    "ch.proto.KVRequestHeaderB\010\310\336\037\000\320\336\037\001\"s\n\013Ge"
    "tResponse\022=\n\010kvheader\030\001 \001(\0132!.cockroach."
    "proto.KVResponseHeaderB\010\310\336\037\000\320\336\037\001\022%\n\005valu"
    "e\030\002 \001(\0132\026.cockroach.proto.Value\"w\n\nPutRe"
    "quest\022<\n\010kvheader\030\001 \001(\0132 .cockroach.prot"
    "o.KVRequestHeaderB\010\310\336\037\000\320\336\037\001\022+\n\005value\030\002 \001"
    "(\0132\026.cockroach.proto.ValueB\004\310\336\037\000\"L\n\013PutR"
    "esponse\022=\n\010kvheader\030\001 \001(\0132!.cockroach.pr"
    "oto.KVResponseHeaderB\010\310\336\037\000\320\336\037\001\"\255\001\n\025Condi"
    "tionalPutRequest\022<\n\010kvheader\030\001 \001(\0132 .coc"
    "kroach.proto.KVRequestHeaderB\010\310\336\037\000\320\336\037\001\022+"
    "\n\005value\030\002 \001(\0132\026.cockroach.proto.ValueB\004\310"
    "\336\037\000\022)\n\texp_value\030\003 \001(\0132\026.cockroach.proto"
    ".Value\"W\n\026ConditionalPutResponse\022=\n\010kvhe"
    "ader\030\001 \001(\0132!.cockroach.proto.KVResponseH"
    "eaderB\010\310\336\037\000\320\336\037\001\"i\n\020IncrementRequest\022<\n\010k"
    "vheader\030\001 \001(\0132 .cockroach.proto.KVReques"
    "tHeaderB\010\310\336\037\000\320\336\037\001\022\027\n\tincrement\030\002 \001(\003B\004\310\336"
    "\037\000\"k\n\021IncrementResponse\022=\n\010kvheader\030\001 \001("
    "\0132!.cockroach.proto.KVResponseHeaderB\010\310\336"
    "\037\000\320\336\037\001\022\027\n\tnew_value\030\002 \001(\003B\004\310\336\037\000\"M\n\rDelet"
    "eRequest\022<\n\010kvheader\030\001 \001(\0132 .cockroach.p"
    "roto.KVRequestHeaderB\010\310\336\037\000\320\336\037\001\"O\n\016Delete"
    "Response\022=\n\010kvheader\030\001 \001(\0132!.cockroach.p"
    "roto.KVResponseHeaderB\010\310\336\037\000\320\336\037\001\"w\n\022Delet"
    "eRangeRequest\022<\n\010kvheader\030\001 \001(\0132 .cockro"
    "ach.proto.KVRequestHeaderB\010\310\336\037\000\320\336\037\001\022#\n\025m"
    "ax_entries_to_delete\030\002 \001(\003B\004\310\336\037\000\"o\n\023Dele"
    "teRangeResponse\022=\n\010kvheader\030\001 \001(\0132!.cock"
    "roach.proto.KVResponseHeaderB\010\310\336\037\000\320\336\037\001\022\031"
    "\n\013num_deleted\030\002 \001(\003B\004\310\336\037\000\"f\n\013ScanRequest"
    "\022<\n\010kvheader\030\001 \001(\0132 .cockroach.proto.KVR"
    "equestHeaderB\010\310\336\037\000\320\336\037\001\022\031\n\013max_results\030\002 "
    "\001(\003B\004\310\336\037\000\"|\n\014ScanResponse\022=\n\010kvheader\030\001 "
    "\001(\0132!.cockroach.proto.KVResponseHeaderB\010"
    "\310\336\037\000\320\336\037\001\022-\n\004rows\030\002 \003(\0132\031.cockroach.proto"
    ".KeyValueB\004\310\336\037\000\"\264\001\n\025EndTransactionReques"
    "t\022<\n\010kvheader\030\001 \001(\0132 .cockroach.proto.KV"
    "RequestHeaderB\010\310\336\037\000\320\336\037\001\022\024\n\006commit\030\002 \001(\010B"
    "\004\310\336\037\000\022G\n\027internal_commit_trigger\030\003 \001(\0132&"
    ".cockroach.proto.InternalCommitTrigger\"\215"
    "\001\n\026EndTransactionResponse\022=\n\010kvheader\030\001 "
    "\001(\0132!.cockroach.proto.KVResponseHeaderB\010"
    "\310\336\037\000\320\336\037\001\022\031\n\013commit_wait\030\002 \001(\003B\004\310\336\037\000\022\031\n\010r"
    "esolved\030\003 \003(\014B\007\372\336\037\003Key\"\320\003\n\014RequestUnion\022"
    "*\n\003get\030\002 \001(\0132\033.cockroach.proto.GetReques"
    "tH\000\022*\n\003put\030\003 \001(\0132\033.cockroach.proto.PutRe"
    "questH\000\022A\n\017conditional_put\030\004 \001(\0132&.cockr"
    "oach.proto.ConditionalPutRequestH\000\0226\n\tin"
    "crement\030\005 \001(\0132!.cockroach.proto.Incremen"
    "tRequestH\000\0220\n\006delete\030\006 \001(\0132\036.cockroach.p"
    "roto.DeleteRequestH\000\022;\n\014delete_range\030\007 \001"
    "(\0132#.cockroach.proto.DeleteRangeRequestH"
    "\000\022,\n\004scan\030\010 \001(\0132\034.cockroach.proto.ScanRe"
    "questH\000\022A\n\017end_transaction\030\t \001(\0132&.cockr"
    "oach.proto.EndTransactionRequestH\000:\004\310\240\037\001"
    "B\007\n\005value\"\331\003\n\rResponseUnion\022+\n\003get\030\002 \001(\013"
    "2\034.cockroach.proto.GetResponseH\000\022+\n\003put\030"
    "\003 \001(\0132\034.cockroach.proto.PutResponseH\000\022B\n"
    "\017conditional_put\030\004 \001(\0132\'.cockroach.proto"
    ".ConditionalPutResponseH\000\0227\n\tincrement\030\005"
    " \001(\0132\".cockroach.proto.IncrementResponse"
    "H\000\0221\n\006delete\030\006 \001(\0132\037.cockroach.proto.Del"
    "eteResponseH\000\022<\n\014delete_range\030\007 \001(\0132$.co"
    "ckroach.proto.DeleteRangeResponseH\000\022-\n\004s"
    "can\030\010 \001(\0132\035.cockroach.proto.ScanResponse"
    "H\000\022B\n\017end_transaction\030\t \001(\0132\'.cockroach."
    "proto.EndTransactionResponseH\000:\004\310\240\037\001B\007\n\005"
    "value\"\203\001\n\014BatchRequest\022<\n\010kvheader\030\001 \001(\013"
    "2 .cockroach.proto.KVRequestHeaderB\010\310\336\037\000"
    "\320\336\037\001\0225\n\010requests\030\002 \003(\0132\035.cockroach.proto"
    ".RequestUnionB\004\310\336\037\000\"\207\001\n\rBatchResponse\022=\n"
    "\010kvheader\030\001 \001(\0132!.cockroach.proto.KVResp"
    "onseHeaderB\010\310\336\037\000\320\336\037\001\0227\n\tresponses\030\002 \003(\0132"
    "\036.cockroach.proto.ResponseUnionB\004\310\336\037\000\"m\n"
    "\021AdminSplitRequest\022<\n\010kvheader\030\001 \001(\0132 .c"
    "ockroach.proto.KVRequestHeaderB\010\310\336\037\000\320\336\037\001"
    "\022\032\n\tsplit_key\030\002 \001(\014B\007\372\336\037\003Key\"S\n\022AdminSpl"
    "itResponse\022=\n\010kvheader\030\001 \001(\0132!.cockroach"
    ".proto.KVResponseHeaderB\010\310\336\037\000\320\336\037\001\"Q\n\021Adm"
    "inMergeRequest\022<\n\010kvheader\030\001 \001(\0132 .cockr"
    "oach.proto.KVRequestHeaderB\010\310\336\037\000\320\336\037\001\"S\n\022"
    "AdminMergeResponse\022=\n\010kvheader\030\001 \001(\0132!.c"
    "ockroach.proto.KVResponseHeaderB\010\310\336\037\000\320\336\037"
    "\001*L\n\023ReadConsistencyType\022\016\n\nCONSISTENT\020\000"
    "\022\r\n\tCONSENSUS\020\001\022\020\n\014INCONSISTENT\020\002\032\004\210\243\036\000B"
    "\023Z\005proto\340\342\036\001\310\342\036\001\320\342\036\001", 4460);
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedFile(
    "cockroach/proto/api.proto", &protobuf_RegisterTypes);
  ClientCmdID::default_instance_ = new ClientCmdID();
  RequestHeader::default_instance_ = new RequestHeader();
  ResponseHeader::default_instance_ = new ResponseHeader();
  KVRequestHeader::default_instance_ = new KVRequestHeader();
  KVResponseHeader::default_instance_ = new KVResponseHeader();
  GetRequest::default_instance_ = new GetRequest();
  GetResponse::default_instance_ = new GetResponse();
  PutRequest::default_instance_ = new PutRequest();
  PutResponse::default_instance_ = new PutResponse();
  ConditionalPutRequest::default_instance_ = new ConditionalPutRequest();
  ConditionalPutResponse::default_instance_ = new ConditionalPutResponse();
  IncrementRequest::default_instance_ = new IncrementRequest();
  IncrementResponse::default_instance_ = new IncrementResponse();
  DeleteRequest::default_instance_ = new DeleteRequest();
  DeleteResponse::default_instance_ = new DeleteResponse();
  DeleteRangeRequest::default_instance_ = new DeleteRangeRequest();
  DeleteRangeResponse::default_instance_ = new DeleteRangeResponse();
  ScanRequest::default_instance_ = new ScanRequest();
  ScanResponse::default_instance_ = new ScanResponse();
  EndTransactionRequest::default_instance_ = new EndTransactionRequest();
  EndTransactionResponse::default_instance_ = new EndTransactionResponse();
  RequestUnion::default_instance_ = new RequestUnion();
  RequestUnion_default_oneof_instance_ = new RequestUnionOneofInstance();
  ResponseUnion::default_instance_ = new ResponseUnion();
  ResponseUnion_default_oneof_instance_ = new ResponseUnionOneofInstance();
  BatchRequest::default_instance_ = new BatchRequest();
  BatchResponse::default_instance_ = new BatchResponse();
  AdminSplitRequest::default_instance_ = new AdminSplitRequest();
  AdminSplitResponse::default_instance_ = new AdminSplitResponse();
  AdminMergeRequest::default_instance_ = new AdminMergeRequest();
  AdminMergeResponse::default_instance_ = new AdminMergeResponse();
  ClientCmdID::default_instance_->InitAsDefaultInstance();
  RequestHeader::default_instance_->InitAsDefaultInstance();
  ResponseHeader::default_instance_->InitAsDefaultInstance();
  KVRequestHeader::default_instance_->InitAsDefaultInstance();
  KVResponseHeader::default_instance_->InitAsDefaultInstance();
  GetRequest::default_instance_->InitAsDefaultInstance();
  GetResponse::default_instance_->InitAsDefaultInstance();
  PutRequest::default_instance_->InitAsDefaultInstance();
  PutResponse::default_instance_->InitAsDefaultInstance();
  ConditionalPutRequest::default_instance_->InitAsDefaultInstance();
  ConditionalPutResponse::default_instance_->InitAsDefaultInstance();
  IncrementRequest::default_instance_->InitAsDefaultInstance();
  IncrementResponse::default_instance_->InitAsDefaultInstance();
  DeleteRequest::default_instance_->InitAsDefaultInstance();
  DeleteResponse::default_instance_->InitAsDefaultInstance();
  DeleteRangeRequest::default_instance_->InitAsDefaultInstance();
  DeleteRangeResponse::default_instance_->InitAsDefaultInstance();
  ScanRequest::default_instance_->InitAsDefaultInstance();
  ScanResponse::default_instance_->InitAsDefaultInstance();
  EndTransactionRequest::default_instance_->InitAsDefaultInstance();
  EndTransactionResponse::default_instance_->InitAsDefaultInstance();
  RequestUnion::default_instance_->InitAsDefaultInstance();
  ResponseUnion::default_instance_->InitAsDefaultInstance();
  BatchRequest::default_instance_->InitAsDefaultInstance();
  BatchResponse::default_instance_->InitAsDefaultInstance();
  AdminSplitRequest::default_instance_->InitAsDefaultInstance();
  AdminSplitResponse::default_instance_->InitAsDefaultInstance();
  AdminMergeRequest::default_instance_->InitAsDefaultInstance();
  AdminMergeResponse::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_cockroach_2fproto_2fapi_2eproto);
}

// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_cockroach_2fproto_2fapi_2eproto {
  StaticDescriptorInitializer_cockroach_2fproto_2fapi_2eproto() {
    protobuf_AddDesc_cockroach_2fproto_2fapi_2eproto();
  }
} static_descriptor_initializer_cockroach_2fproto_2fapi_2eproto_;
const ::google::protobuf::EnumDescriptor* ReadConsistencyType_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ReadConsistencyType_descriptor_;
}
bool ReadConsistencyType_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}


namespace {

static void MergeFromFail(int line) GOOGLE_ATTRIBUTE_COLD;
static void MergeFromFail(int line) {
  GOOGLE_CHECK(false) << __FILE__ << ":" << line;
}

}  // namespace


// ===================================================================

#ifndef _MSC_VER
const int ClientCmdID::kWallTimeFieldNumber;
const int ClientCmdID::kRandomFieldNumber;
#endif  // !_MSC_VER

ClientCmdID::ClientCmdID()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:cockroach.proto.ClientCmdID)
}

void ClientCmdID::InitAsDefaultInstance() {
}

ClientCmdID::ClientCmdID(const ClientCmdID& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:cockroach.proto.ClientCmdID)
}

void ClientCmdID::SharedCtor() {
  _cached_size_ = 0;
  wall_time_ = GOOGLE_LONGLONG(0);
  random_ = GOOGLE_LONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ClientCmdID::~ClientCmdID() {
  // @@protoc_insertion_point(destructor:cockroach.proto.ClientCmdID)
  SharedDtor();
}

void ClientCmdID::SharedDtor() {
  if (this != default_instance_) {
  }
}

void ClientCmdID::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ClientCmdID::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ClientCmdID_descriptor_;
}

const ClientCmdID& ClientCmdID::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_cockroach_2fproto_2fapi_2eproto();
  return *default_instance_;
}

ClientCmdID* ClientCmdID::default_instance_ = NULL;

ClientCmdID* ClientCmdID::New(::google::protobuf::Arena* arena) const {
  ClientCmdID* n = new ClientCmdID;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void ClientCmdID::Clear() {
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<ClientCmdID*>(16)->f)

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  ZR_(wall_time_, random_);

#undef ZR_HELPER_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool ClientCmdID::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:cockroach.proto.ClientCmdID)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int64 wall_time = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &wall_time_)));
          set_has_wall_time();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_random;
        break;
      }

      // optional int64 random = 2;
      case 2: {
        if (tag == 16) {
         parse_random:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &random_)));
          set_has_random();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:cockroach.proto.ClientCmdID)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:cockroach.proto.ClientCmdID)
  return false;
#undef DO_
}

void ClientCmdID::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:cockroach.proto.ClientCmdID)
  // optional int64 wall_time = 1;
  if (has_wall_time()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(1, this->wall_time(), output);
  }

  // optional int64 random = 2;
  if (has_random()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(2, this->random(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:cockroach.proto.ClientCmdID)
}

::google::protobuf::uint8* ClientCmdID::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:cockroach.proto.ClientCmdID)
  // optional int64 wall_time = 1;
  if (has_wall_time()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(1, this->wall_time(), target);
  }

  // optional int64 random = 2;
  if (has_random()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(2, this->random(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:cockroach.proto.ClientCmdID)
  return target;
}

int ClientCmdID::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & 3) {
    // optional int64 wall_time = 1;
    if (has_wall_time()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->wall_time());
    }

    // optional int64 random = 2;
    if (has_random()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->random());
    }

  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ClientCmdID::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const ClientCmdID* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const ClientCmdID>(
          &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ClientCmdID::MergeFrom(const ClientCmdID& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_wall_time()) {
      set_wall_time(from.wall_time());
    }
    if (from.has_random()) {
      set_random(from.random());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void ClientCmdID::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ClientCmdID::CopyFrom(const ClientCmdID& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ClientCmdID::IsInitialized() const {

  return true;
}

void ClientCmdID::Swap(ClientCmdID* other) {
  if (other == this) return;
  InternalSwap(other);
}
void ClientCmdID::InternalSwap(ClientCmdID* other) {
  std::swap(wall_time_, other->wall_time_);
  std::swap(random_, other->random_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata ClientCmdID::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ClientCmdID_descriptor_;
  metadata.reflection = ClientCmdID_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// ClientCmdID

// optional int64 wall_time = 1;
bool ClientCmdID::has_wall_time() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void ClientCmdID::set_has_wall_time() {
  _has_bits_[0] |= 0x00000001u;
}
void ClientCmdID::clear_has_wall_time() {
  _has_bits_[0] &= ~0x00000001u;
}
void ClientCmdID::clear_wall_time() {
  wall_time_ = GOOGLE_LONGLONG(0);
  clear_has_wall_time();
}
 ::google::protobuf::int64 ClientCmdID::wall_time() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.ClientCmdID.wall_time)
  return wall_time_;
}
 void ClientCmdID::set_wall_time(::google::protobuf::int64 value) {
  set_has_wall_time();
  wall_time_ = value;
  // @@protoc_insertion_point(field_set:cockroach.proto.ClientCmdID.wall_time)
}

// optional int64 random = 2;
bool ClientCmdID::has_random() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void ClientCmdID::set_has_random() {
  _has_bits_[0] |= 0x00000002u;
}
void ClientCmdID::clear_has_random() {
  _has_bits_[0] &= ~0x00000002u;
}
void ClientCmdID::clear_random() {
  random_ = GOOGLE_LONGLONG(0);
  clear_has_random();
}
 ::google::protobuf::int64 ClientCmdID::random() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.ClientCmdID.random)
  return random_;
}
 void ClientCmdID::set_random(::google::protobuf::int64 value) {
  set_has_random();
  random_ = value;
  // @@protoc_insertion_point(field_set:cockroach.proto.ClientCmdID.random)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#ifndef _MSC_VER
const int RequestHeader::kTimestampFieldNumber;
const int RequestHeader::kCmdIdFieldNumber;
const int RequestHeader::kUserFieldNumber;
const int RequestHeader::kUserPriorityFieldNumber;
const int RequestHeader::kTxnFieldNumber;
const int RequestHeader::kReadConsistencyFieldNumber;
#endif  // !_MSC_VER

RequestHeader::RequestHeader()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:cockroach.proto.RequestHeader)
}

void RequestHeader::InitAsDefaultInstance() {
  timestamp_ = const_cast< ::cockroach::proto::Timestamp*>(&::cockroach::proto::Timestamp::default_instance());
  cmd_id_ = const_cast< ::cockroach::proto::ClientCmdID*>(&::cockroach::proto::ClientCmdID::default_instance());
  txn_ = const_cast< ::cockroach::proto::Transaction*>(&::cockroach::proto::Transaction::default_instance());
}

RequestHeader::RequestHeader(const RequestHeader& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:cockroach.proto.RequestHeader)
}

void RequestHeader::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  timestamp_ = NULL;
  cmd_id_ = NULL;
  user_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  user_priority_ = 1;
  txn_ = NULL;
  read_consistency_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RequestHeader::~RequestHeader() {
  // @@protoc_insertion_point(destructor:cockroach.proto.RequestHeader)
  SharedDtor();
}

void RequestHeader::SharedDtor() {
  user_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != default_instance_) {
    delete timestamp_;
    delete cmd_id_;
    delete txn_;
  }
}

void RequestHeader::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* RequestHeader::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return RequestHeader_descriptor_;
}

const RequestHeader& RequestHeader::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_cockroach_2fproto_2fapi_2eproto();
  return *default_instance_;
}

RequestHeader* RequestHeader::default_instance_ = NULL;

RequestHeader* RequestHeader::New(::google::protobuf::Arena* arena) const {
  RequestHeader* n = new RequestHeader;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void RequestHeader::Clear() {
  if (_has_bits_[0 / 32] & 63u) {
    if (has_timestamp()) {
      if (timestamp_ != NULL) timestamp_->::cockroach::proto::Timestamp::Clear();
    }
    if (has_cmd_id()) {
      if (cmd_id_ != NULL) cmd_id_->::cockroach::proto::ClientCmdID::Clear();
    }
    if (has_user()) {
      user_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    user_priority_ = 1;
    if (has_txn()) {
      if (txn_ != NULL) txn_->::cockroach::proto::Transaction::Clear();
    }
    read_consistency_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool RequestHeader::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:cockroach.proto.RequestHeader)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .cockroach.proto.Timestamp timestamp = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_timestamp()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_cmd_id;
        break;
      }

      // optional .cockroach.proto.ClientCmdID cmd_id = 2;
      case 2: {
        if (tag == 18) {
         parse_cmd_id:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_cmd_id()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_user;
        break;
      }

      // optional string user = 5;
      case 5: {
        if (tag == 42) {
         parse_user:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_user()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->user().data(), this->user().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "cockroach.proto.RequestHeader.user");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(64)) goto parse_user_priority;
        break;
      }

      // optional int32 user_priority = 8 [default = 1];
      case 8: {
        if (tag == 64) {
         parse_user_priority:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &user_priority_)));
          set_has_user_priority();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(74)) goto parse_txn;
        break;
      }

      // optional .cockroach.proto.Transaction txn = 9;
      case 9: {
        if (tag == 74) {
         parse_txn:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_txn()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(80)) goto parse_read_consistency;
        break;
      }

      // optional .cockroach.proto.ReadConsistencyType read_consistency = 10;
      case 10: {
        if (tag == 80) {
         parse_read_consistency:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::cockroach::proto::ReadConsistencyType_IsValid(value)) {
            set_read_consistency(static_cast< ::cockroach::proto::ReadConsistencyType >(value));
          } else {
            mutable_unknown_fields()->AddVarint(10, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:cockroach.proto.RequestHeader)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:cockroach.proto.RequestHeader)
  return false;
#undef DO_
}

void RequestHeader::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:cockroach.proto.RequestHeader)
  // optional .cockroach.proto.Timestamp timestamp = 1;
  if (has_timestamp()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->timestamp_, output);
  }

  // optional .cockroach.proto.ClientCmdID cmd_id = 2;
  if (has_cmd_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, *this->cmd_id_, output);
  }

  // optional string user = 5;
  if (has_user()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->user().data(), this->user().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "cockroach.proto.RequestHeader.user");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      5, this->user(), output);
  }

  // optional int32 user_priority = 8 [default = 1];
  if (has_user_priority()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(8, this->user_priority(), output);
  }

  // optional .cockroach.proto.Transaction txn = 9;
  if (has_txn()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      9, *this->txn_, output);
  }

  // optional .cockroach.proto.ReadConsistencyType read_consistency = 10;
  if (has_read_consistency()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      10, this->read_consistency(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:cockroach.proto.RequestHeader)
}

::google::protobuf::uint8* RequestHeader::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:cockroach.proto.RequestHeader)
  // optional .cockroach.proto.Timestamp timestamp = 1;
  if (has_timestamp()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, *this->timestamp_, target);
  }

  // optional .cockroach.proto.ClientCmdID cmd_id = 2;
  if (has_cmd_id()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, *this->cmd_id_, target);
  }

  // optional string user = 5;
  if (has_user()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->user().data(), this->user().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "cockroach.proto.RequestHeader.user");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        5, this->user(), target);
  }

  // optional int32 user_priority = 8 [default = 1];
  if (has_user_priority()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(8, this->user_priority(), target);
  }

  // optional .cockroach.proto.Transaction txn = 9;
  if (has_txn()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        9, *this->txn_, target);
  }

  // optional .cockroach.proto.ReadConsistencyType read_consistency = 10;
  if (has_read_consistency()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      10, this->read_consistency(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:cockroach.proto.RequestHeader)
  return target;
}

int RequestHeader::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & 63) {
    // optional .cockroach.proto.Timestamp timestamp = 1;
    if (has_timestamp()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->timestamp_);
    }

    // optional .cockroach.proto.ClientCmdID cmd_id = 2;
    if (has_cmd_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->cmd_id_);
    }

    // optional string user = 5;
    if (has_user()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->user());
    }

    // optional int32 user_priority = 8 [default = 1];
    if (has_user_priority()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->user_priority());
    }

    // optional .cockroach.proto.Transaction txn = 9;
    if (has_txn()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->txn_);
    }

    // optional .cockroach.proto.ReadConsistencyType read_consistency = 10;
    if (has_read_consistency()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->read_consistency());
    }

  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RequestHeader::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const RequestHeader* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const RequestHeader>(
          &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void RequestHeader::MergeFrom(const RequestHeader& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_timestamp()) {
      mutable_timestamp()->::cockroach::proto::Timestamp::MergeFrom(from.timestamp());
    }
    if (from.has_cmd_id()) {
      mutable_cmd_id()->::cockroach::proto::ClientCmdID::MergeFrom(from.cmd_id());
    }
    if (from.has_user()) {
      set_has_user();
      user_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.user_);
    }
    if (from.has_user_priority()) {
      set_user_priority(from.user_priority());
    }
    if (from.has_txn()) {
      mutable_txn()->::cockroach::proto::Transaction::MergeFrom(from.txn());
    }
    if (from.has_read_consistency()) {
      set_read_consistency(from.read_consistency());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void RequestHeader::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void RequestHeader::CopyFrom(const RequestHeader& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RequestHeader::IsInitialized() const {

  return true;
}

void RequestHeader::Swap(RequestHeader* other) {
  if (other == this) return;
  InternalSwap(other);
}
void RequestHeader::InternalSwap(RequestHeader* other) {
  std::swap(timestamp_, other->timestamp_);
  std::swap(cmd_id_, other->cmd_id_);
  user_.Swap(&other->user_);
  std::swap(user_priority_, other->user_priority_);
  std::swap(txn_, other->txn_);
  std::swap(read_consistency_, other->read_consistency_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata RequestHeader::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = RequestHeader_descriptor_;
  metadata.reflection = RequestHeader_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// RequestHeader

// optional .cockroach.proto.Timestamp timestamp = 1;
bool RequestHeader::has_timestamp() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void RequestHeader::set_has_timestamp() {
  _has_bits_[0] |= 0x00000001u;
}
void RequestHeader::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000001u;
}
void RequestHeader::clear_timestamp() {
  if (timestamp_ != NULL) timestamp_->::cockroach::proto::Timestamp::Clear();
  clear_has_timestamp();
}
 const ::cockroach::proto::Timestamp& RequestHeader::timestamp() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.RequestHeader.timestamp)
  return timestamp_ != NULL ? *timestamp_ : *default_instance_->timestamp_;
}
 ::cockroach::proto::Timestamp* RequestHeader::mutable_timestamp() {
  set_has_timestamp();
  if (timestamp_ == NULL) {
    timestamp_ = new ::cockroach::proto::Timestamp;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.proto.RequestHeader.timestamp)
  return timestamp_;
}
 ::cockroach::proto::Timestamp* RequestHeader::release_timestamp() {
  clear_has_timestamp();
  ::cockroach::proto::Timestamp* temp = timestamp_;
  timestamp_ = NULL;
  return temp;
}
 void RequestHeader::set_allocated_timestamp(::cockroach::proto::Timestamp* timestamp) {
  delete timestamp_;
  timestamp_ = timestamp;
  if (timestamp) {
    set_has_timestamp();
  } else {
    clear_has_timestamp();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.RequestHeader.timestamp)
}

// optional .cockroach.proto.ClientCmdID cmd_id = 2;
bool RequestHeader::has_cmd_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void RequestHeader::set_has_cmd_id() {
  _has_bits_[0] |= 0x00000002u;
}
void RequestHeader::clear_has_cmd_id() {
  _has_bits_[0] &= ~0x00000002u;
}
void RequestHeader::clear_cmd_id() {
  if (cmd_id_ != NULL) cmd_id_->::cockroach::proto::ClientCmdID::Clear();
  clear_has_cmd_id();
}
 const ::cockroach::proto::ClientCmdID& RequestHeader::cmd_id() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.RequestHeader.cmd_id)
  return cmd_id_ != NULL ? *cmd_id_ : *default_instance_->cmd_id_;
}
 ::cockroach::proto::ClientCmdID* RequestHeader::mutable_cmd_id() {
  set_has_cmd_id();
  if (cmd_id_ == NULL) {
    cmd_id_ = new ::cockroach::proto::ClientCmdID;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.proto.RequestHeader.cmd_id)
  return cmd_id_;
}
 ::cockroach::proto::ClientCmdID* RequestHeader::release_cmd_id() {
  clear_has_cmd_id();
  ::cockroach::proto::ClientCmdID* temp = cmd_id_;
  cmd_id_ = NULL;
  return temp;
}
 void RequestHeader::set_allocated_cmd_id(::cockroach::proto::ClientCmdID* cmd_id) {
  delete cmd_id_;
  cmd_id_ = cmd_id;
  if (cmd_id) {
    set_has_cmd_id();
  } else {
    clear_has_cmd_id();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.RequestHeader.cmd_id)
}

// optional string user = 5;
bool RequestHeader::has_user() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void RequestHeader::set_has_user() {
  _has_bits_[0] |= 0x00000004u;
}
void RequestHeader::clear_has_user() {
  _has_bits_[0] &= ~0x00000004u;
}
void RequestHeader::clear_user() {
  user_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_user();
}
 const ::std::string& RequestHeader::user() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.RequestHeader.user)
  return user_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void RequestHeader::set_user(const ::std::string& value) {
  set_has_user();
  user_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cockroach.proto.RequestHeader.user)
}
 void RequestHeader::set_user(const char* value) {
  set_has_user();
  user_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cockroach.proto.RequestHeader.user)
}
 void RequestHeader::set_user(const char* value, size_t size) {
  set_has_user();
  user_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cockroach.proto.RequestHeader.user)
}
 ::std::string* RequestHeader::mutable_user() {
  set_has_user();
  // @@protoc_insertion_point(field_mutable:cockroach.proto.RequestHeader.user)
  return user_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* RequestHeader::release_user() {
  clear_has_user();
  return user_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void RequestHeader::set_allocated_user(::std::string* user) {
  if (user != NULL) {
    set_has_user();
  } else {
    clear_has_user();
  }
  user_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), user);
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.RequestHeader.user)
}

// optional int32 user_priority = 8 [default = 1];
bool RequestHeader::has_user_priority() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void RequestHeader::set_has_user_priority() {
  _has_bits_[0] |= 0x00000008u;
}
void RequestHeader::clear_has_user_priority() {
  _has_bits_[0] &= ~0x00000008u;
}
void RequestHeader::clear_user_priority() {
  user_priority_ = 1;
  clear_has_user_priority();
}
 ::google::protobuf::int32 RequestHeader::user_priority() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.RequestHeader.user_priority)
  return user_priority_;
}
 void RequestHeader::set_user_priority(::google::protobuf::int32 value) {
  set_has_user_priority();
  user_priority_ = value;
  // @@protoc_insertion_point(field_set:cockroach.proto.RequestHeader.user_priority)
}

// optional .cockroach.proto.Transaction txn = 9;
bool RequestHeader::has_txn() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
void RequestHeader::set_has_txn() {
  _has_bits_[0] |= 0x00000010u;
}
void RequestHeader::clear_has_txn() {
  _has_bits_[0] &= ~0x00000010u;
}
void RequestHeader::clear_txn() {
  if (txn_ != NULL) txn_->::cockroach::proto::Transaction::Clear();
  clear_has_txn();
}
 const ::cockroach::proto::Transaction& RequestHeader::txn() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.RequestHeader.txn)
  return txn_ != NULL ? *txn_ : *default_instance_->txn_;
}
 ::cockroach::proto::Transaction* RequestHeader::mutable_txn() {
  set_has_txn();
  if (txn_ == NULL) {
    txn_ = new ::cockroach::proto::Transaction;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.proto.RequestHeader.txn)
  return txn_;
}
 ::cockroach::proto::Transaction* RequestHeader::release_txn() {
  clear_has_txn();
  ::cockroach::proto::Transaction* temp = txn_;
  txn_ = NULL;
  return temp;
}
 void RequestHeader::set_allocated_txn(::cockroach::proto::Transaction* txn) {
  delete txn_;
  txn_ = txn;
  if (txn) {
    set_has_txn();
  } else {
    clear_has_txn();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.RequestHeader.txn)
}

// optional .cockroach.proto.ReadConsistencyType read_consistency = 10;
bool RequestHeader::has_read_consistency() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
void RequestHeader::set_has_read_consistency() {
  _has_bits_[0] |= 0x00000020u;
}
void RequestHeader::clear_has_read_consistency() {
  _has_bits_[0] &= ~0x00000020u;
}
void RequestHeader::clear_read_consistency() {
  read_consistency_ = 0;
  clear_has_read_consistency();
}
 ::cockroach::proto::ReadConsistencyType RequestHeader::read_consistency() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.RequestHeader.read_consistency)
  return static_cast< ::cockroach::proto::ReadConsistencyType >(read_consistency_);
}
 void RequestHeader::set_read_consistency(::cockroach::proto::ReadConsistencyType value) {
  assert(::cockroach::proto::ReadConsistencyType_IsValid(value));
  set_has_read_consistency();
  read_consistency_ = value;
  // @@protoc_insertion_point(field_set:cockroach.proto.RequestHeader.read_consistency)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#ifndef _MSC_VER
const int ResponseHeader::kErrorFieldNumber;
const int ResponseHeader::kTimestampFieldNumber;
const int ResponseHeader::kTxnFieldNumber;
#endif  // !_MSC_VER

ResponseHeader::ResponseHeader()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:cockroach.proto.ResponseHeader)
}

void ResponseHeader::InitAsDefaultInstance() {
  error_ = const_cast< ::cockroach::proto::Error*>(&::cockroach::proto::Error::default_instance());
  timestamp_ = const_cast< ::cockroach::proto::Timestamp*>(&::cockroach::proto::Timestamp::default_instance());
  txn_ = const_cast< ::cockroach::proto::Transaction*>(&::cockroach::proto::Transaction::default_instance());
}

ResponseHeader::ResponseHeader(const ResponseHeader& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:cockroach.proto.ResponseHeader)
}

void ResponseHeader::SharedCtor() {
  _cached_size_ = 0;
  error_ = NULL;
  timestamp_ = NULL;
  txn_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ResponseHeader::~ResponseHeader() {
  // @@protoc_insertion_point(destructor:cockroach.proto.ResponseHeader)
  SharedDtor();
}

void ResponseHeader::SharedDtor() {
  if (this != default_instance_) {
    delete error_;
    delete timestamp_;
    delete txn_;
  }
}

void ResponseHeader::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ResponseHeader::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ResponseHeader_descriptor_;
}

const ResponseHeader& ResponseHeader::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_cockroach_2fproto_2fapi_2eproto();
  return *default_instance_;
}

ResponseHeader* ResponseHeader::default_instance_ = NULL;

ResponseHeader* ResponseHeader::New(::google::protobuf::Arena* arena) const {
  ResponseHeader* n = new ResponseHeader;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void ResponseHeader::Clear() {
  if (_has_bits_[0 / 32] & 7u) {
    if (has_error()) {
      if (error_ != NULL) error_->::cockroach::proto::Error::Clear();
    }
    if (has_timestamp()) {
      if (timestamp_ != NULL) timestamp_->::cockroach::proto::Timestamp::Clear();
    }
    if (has_txn()) {
      if (txn_ != NULL) txn_->::cockroach::proto::Transaction::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool ResponseHeader::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:cockroach.proto.ResponseHeader)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .cockroach.proto.Error error = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_error()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_timestamp;
        break;
      }

      // optional .cockroach.proto.Timestamp timestamp = 2;
      case 2: {
        if (tag == 18) {
         parse_timestamp:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_timestamp()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_txn;
        break;
      }

      // optional .cockroach.proto.Transaction txn = 3;
      case 3: {
        if (tag == 26) {
         parse_txn:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_txn()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:cockroach.proto.ResponseHeader)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:cockroach.proto.ResponseHeader)
  return false;
#undef DO_
}

void ResponseHeader::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:cockroach.proto.ResponseHeader)
  // optional .cockroach.proto.Error error = 1;
  if (has_error()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->error_, output);
  }

  // optional .cockroach.proto.Timestamp timestamp = 2;
  if (has_timestamp()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, *this->timestamp_, output);
  }

  // optional .cockroach.proto.Transaction txn = 3;
  if (has_txn()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, *this->txn_, output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:cockroach.proto.ResponseHeader)
}

::google::protobuf::uint8* ResponseHeader::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:cockroach.proto.ResponseHeader)
  // optional .cockroach.proto.Error error = 1;
  if (has_error()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, *this->error_, target);
  }

  // optional .cockroach.proto.Timestamp timestamp = 2;
  if (has_timestamp()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, *this->timestamp_, target);
  }

  // optional .cockroach.proto.Transaction txn = 3;
  if (has_txn()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, *this->txn_, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:cockroach.proto.ResponseHeader)
  return target;
}

int ResponseHeader::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & 7) {
    // optional .cockroach.proto.Error error = 1;
    if (has_error()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->error_);
    }

    // optional .cockroach.proto.Timestamp timestamp = 2;
    if (has_timestamp()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->timestamp_);
    }

    // optional .cockroach.proto.Transaction txn = 3;
    if (has_txn()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->txn_);
    }

  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ResponseHeader::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const ResponseHeader* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const ResponseHeader>(
          &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ResponseHeader::MergeFrom(const ResponseHeader& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_error()) {
      mutable_error()->::cockroach::proto::Error::MergeFrom(from.error());
    }
    if (from.has_timestamp()) {
      mutable_timestamp()->::cockroach::proto::Timestamp::MergeFrom(from.timestamp());
    }
    if (from.has_txn()) {
      mutable_txn()->::cockroach::proto::Transaction::MergeFrom(from.txn());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void ResponseHeader::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ResponseHeader::CopyFrom(const ResponseHeader& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ResponseHeader::IsInitialized() const {

  return true;
}

void ResponseHeader::Swap(ResponseHeader* other) {
  if (other == this) return;
  InternalSwap(other);
}
void ResponseHeader::InternalSwap(ResponseHeader* other) {
  std::swap(error_, other->error_);
  std::swap(timestamp_, other->timestamp_);
  std::swap(txn_, other->txn_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata ResponseHeader::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ResponseHeader_descriptor_;
  metadata.reflection = ResponseHeader_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// ResponseHeader

// optional .cockroach.proto.Error error = 1;
bool ResponseHeader::has_error() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void ResponseHeader::set_has_error() {
  _has_bits_[0] |= 0x00000001u;
}
void ResponseHeader::clear_has_error() {
  _has_bits_[0] &= ~0x00000001u;
}
void ResponseHeader::clear_error() {
  if (error_ != NULL) error_->::cockroach::proto::Error::Clear();
  clear_has_error();
}
 const ::cockroach::proto::Error& ResponseHeader::error() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.ResponseHeader.error)
  return error_ != NULL ? *error_ : *default_instance_->error_;
}
 ::cockroach::proto::Error* ResponseHeader::mutable_error() {
  set_has_error();
  if (error_ == NULL) {
    error_ = new ::cockroach::proto::Error;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.proto.ResponseHeader.error)
  return error_;
}
 ::cockroach::proto::Error* ResponseHeader::release_error() {
  clear_has_error();
  ::cockroach::proto::Error* temp = error_;
  error_ = NULL;
  return temp;
}
 void ResponseHeader::set_allocated_error(::cockroach::proto::Error* error) {
  delete error_;
  error_ = error;
  if (error) {
    set_has_error();
  } else {
    clear_has_error();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.ResponseHeader.error)
}

// optional .cockroach.proto.Timestamp timestamp = 2;
bool ResponseHeader::has_timestamp() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void ResponseHeader::set_has_timestamp() {
  _has_bits_[0] |= 0x00000002u;
}
void ResponseHeader::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000002u;
}
void ResponseHeader::clear_timestamp() {
  if (timestamp_ != NULL) timestamp_->::cockroach::proto::Timestamp::Clear();
  clear_has_timestamp();
}
 const ::cockroach::proto::Timestamp& ResponseHeader::timestamp() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.ResponseHeader.timestamp)
  return timestamp_ != NULL ? *timestamp_ : *default_instance_->timestamp_;
}
 ::cockroach::proto::Timestamp* ResponseHeader::mutable_timestamp() {
  set_has_timestamp();
  if (timestamp_ == NULL) {
    timestamp_ = new ::cockroach::proto::Timestamp;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.proto.ResponseHeader.timestamp)
  return timestamp_;
}
 ::cockroach::proto::Timestamp* ResponseHeader::release_timestamp() {
  clear_has_timestamp();
  ::cockroach::proto::Timestamp* temp = timestamp_;
  timestamp_ = NULL;
  return temp;
}
 void ResponseHeader::set_allocated_timestamp(::cockroach::proto::Timestamp* timestamp) {
  delete timestamp_;
  timestamp_ = timestamp;
  if (timestamp) {
    set_has_timestamp();
  } else {
    clear_has_timestamp();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.ResponseHeader.timestamp)
}

// optional .cockroach.proto.Transaction txn = 3;
bool ResponseHeader::has_txn() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void ResponseHeader::set_has_txn() {
  _has_bits_[0] |= 0x00000004u;
}
void ResponseHeader::clear_has_txn() {
  _has_bits_[0] &= ~0x00000004u;
}
void ResponseHeader::clear_txn() {
  if (txn_ != NULL) txn_->::cockroach::proto::Transaction::Clear();
  clear_has_txn();
}
 const ::cockroach::proto::Transaction& ResponseHeader::txn() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.ResponseHeader.txn)
  return txn_ != NULL ? *txn_ : *default_instance_->txn_;
}
 ::cockroach::proto::Transaction* ResponseHeader::mutable_txn() {
  set_has_txn();
  if (txn_ == NULL) {
    txn_ = new ::cockroach::proto::Transaction;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.proto.ResponseHeader.txn)
  return txn_;
}
 ::cockroach::proto::Transaction* ResponseHeader::release_txn() {
  clear_has_txn();
  ::cockroach::proto::Transaction* temp = txn_;
  txn_ = NULL;
  return temp;
}
 void ResponseHeader::set_allocated_txn(::cockroach::proto::Transaction* txn) {
  delete txn_;
  txn_ = txn;
  if (txn) {
    set_has_txn();
  } else {
    clear_has_txn();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.ResponseHeader.txn)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#ifndef _MSC_VER
const int KVRequestHeader::kHeaderFieldNumber;
const int KVRequestHeader::kKeyFieldNumber;
const int KVRequestHeader::kEndKeyFieldNumber;
const int KVRequestHeader::kReplicaFieldNumber;
const int KVRequestHeader::kRaftIdFieldNumber;
#endif  // !_MSC_VER

KVRequestHeader::KVRequestHeader()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:cockroach.proto.KVRequestHeader)
}

void KVRequestHeader::InitAsDefaultInstance() {
  header_ = const_cast< ::cockroach::proto::RequestHeader*>(&::cockroach::proto::RequestHeader::default_instance());
  replica_ = const_cast< ::cockroach::proto::Replica*>(&::cockroach::proto::Replica::default_instance());
}

KVRequestHeader::KVRequestHeader(const KVRequestHeader& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:cockroach.proto.KVRequestHeader)
}

void KVRequestHeader::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  header_ = NULL;
  key_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  end_key_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  replica_ = NULL;
  raft_id_ = GOOGLE_LONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

KVRequestHeader::~KVRequestHeader() {
  // @@protoc_insertion_point(destructor:cockroach.proto.KVRequestHeader)
  SharedDtor();
}

void KVRequestHeader::SharedDtor() {
  key_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  end_key_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != default_instance_) {
    delete header_;
    delete replica_;
  }
}

void KVRequestHeader::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* KVRequestHeader::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return KVRequestHeader_descriptor_;
}

const KVRequestHeader& KVRequestHeader::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_cockroach_2fproto_2fapi_2eproto();
  return *default_instance_;
}

KVRequestHeader* KVRequestHeader::default_instance_ = NULL;

KVRequestHeader* KVRequestHeader::New(::google::protobuf::Arena* arena) const {
  KVRequestHeader* n = new KVRequestHeader;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void KVRequestHeader::Clear() {
  if (_has_bits_[0 / 32] & 31u) {
    if (has_header()) {
      if (header_ != NULL) header_->::cockroach::proto::RequestHeader::Clear();
    }
    if (has_key()) {
      key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    if (has_end_key()) {
      end_key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    if (has_replica()) {
      if (replica_ != NULL) replica_->::cockroach::proto::Replica::Clear();
    }
    raft_id_ = GOOGLE_LONGLONG(0);
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool KVRequestHeader::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:cockroach.proto.KVRequestHeader)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .cockroach.proto.RequestHeader header = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_header()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_key;
        break;
      }

      // optional bytes key = 3;
      case 3: {
        if (tag == 26) {
         parse_key:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_key()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_end_key;
        break;
      }

      // optional bytes end_key = 4;
      case 4: {
        if (tag == 34) {
         parse_end_key:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_end_key()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(50)) goto parse_replica;
        break;
      }

      // optional .cockroach.proto.Replica replica = 6;
      case 6: {
        if (tag == 50) {
         parse_replica:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_replica()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(56)) goto parse_raft_id;
        break;
      }

      // optional int64 raft_id = 7;
      case 7: {
        if (tag == 56) {
         parse_raft_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &raft_id_)));
          set_has_raft_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:cockroach.proto.KVRequestHeader)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:cockroach.proto.KVRequestHeader)
  return false;
#undef DO_
}

void KVRequestHeader::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:cockroach.proto.KVRequestHeader)
  // optional .cockroach.proto.RequestHeader header = 1;
  if (has_header()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->header_, output);
  }

  // optional bytes key = 3;
  if (has_key()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      3, this->key(), output);
  }

  // optional bytes end_key = 4;
  if (has_end_key()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      4, this->end_key(), output);
  }

  // optional .cockroach.proto.Replica replica = 6;
  if (has_replica()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      6, *this->replica_, output);
  }

  // optional int64 raft_id = 7;
  if (has_raft_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(7, this->raft_id(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:cockroach.proto.KVRequestHeader)
}

::google::protobuf::uint8* KVRequestHeader::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:cockroach.proto.KVRequestHeader)
  // optional .cockroach.proto.RequestHeader header = 1;
  if (has_header()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, *this->header_, target);
  }

  // optional bytes key = 3;
  if (has_key()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        3, this->key(), target);
  }

  // optional bytes end_key = 4;
  if (has_end_key()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        4, this->end_key(), target);
  }

  // optional .cockroach.proto.Replica replica = 6;
  if (has_replica()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        6, *this->replica_, target);
  }

  // optional int64 raft_id = 7;
  if (has_raft_id()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(7, this->raft_id(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:cockroach.proto.KVRequestHeader)
  return target;
}

int KVRequestHeader::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & 31) {
    // optional .cockroach.proto.RequestHeader header = 1;
    if (has_header()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->header_);
    }

    // optional bytes key = 3;
    if (has_key()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->key());
    }

    // optional bytes end_key = 4;
    if (has_end_key()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->end_key());
    }

    // optional .cockroach.proto.Replica replica = 6;
    if (has_replica()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->replica_);
    }

    // optional int64 raft_id = 7;
    if (has_raft_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->raft_id());
    }

  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void KVRequestHeader::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const KVRequestHeader* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const KVRequestHeader>(
          &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void KVRequestHeader::MergeFrom(const KVRequestHeader& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_header()) {
      mutable_header()->::cockroach::proto::RequestHeader::MergeFrom(from.header());
    }
    if (from.has_key()) {
      set_has_key();
      key_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.key_);
    }
    if (from.has_end_key()) {
      set_has_end_key();
      end_key_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.end_key_);
    }
    if (from.has_replica()) {
      mutable_replica()->::cockroach::proto::Replica::MergeFrom(from.replica());
    }
    if (from.has_raft_id()) {
      set_raft_id(from.raft_id());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void KVRequestHeader::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void KVRequestHeader::CopyFrom(const KVRequestHeader& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool KVRequestHeader::IsInitialized() const {

  return true;
}

void KVRequestHeader::Swap(KVRequestHeader* other) {
  if (other == this) return;
  InternalSwap(other);
}
void KVRequestHeader::InternalSwap(KVRequestHeader* other) {
  std::swap(header_, other->header_);
  key_.Swap(&other->key_);
  end_key_.Swap(&other->end_key_);
  std::swap(replica_, other->replica_);
  std::swap(raft_id_, other->raft_id_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata KVRequestHeader::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = KVRequestHeader_descriptor_;
  metadata.reflection = KVRequestHeader_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// KVRequestHeader

// optional .cockroach.proto.RequestHeader header = 1;
bool KVRequestHeader::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void KVRequestHeader::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
void KVRequestHeader::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
void KVRequestHeader::clear_header() {
  if (header_ != NULL) header_->::cockroach::proto::RequestHeader::Clear();
  clear_has_header();
}
 const ::cockroach::proto::RequestHeader& KVRequestHeader::header() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.KVRequestHeader.header)
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
 ::cockroach::proto::RequestHeader* KVRequestHeader::mutable_header() {
  set_has_header();
  if (header_ == NULL) {
    header_ = new ::cockroach::proto::RequestHeader;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.proto.KVRequestHeader.header)
  return header_;
}
 ::cockroach::proto::RequestHeader* KVRequestHeader::release_header() {
  clear_has_header();
  ::cockroach::proto::RequestHeader* temp = header_;
  header_ = NULL;
  return temp;
}
 void KVRequestHeader::set_allocated_header(::cockroach::proto::RequestHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.KVRequestHeader.header)
}

// optional bytes key = 3;
bool KVRequestHeader::has_key() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void KVRequestHeader::set_has_key() {
  _has_bits_[0] |= 0x00000002u;
}
void KVRequestHeader::clear_has_key() {
  _has_bits_[0] &= ~0x00000002u;
}
void KVRequestHeader::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_key();
}
 const ::std::string& KVRequestHeader::key() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.KVRequestHeader.key)
  return key_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void KVRequestHeader::set_key(const ::std::string& value) {
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cockroach.proto.KVRequestHeader.key)
}
 void KVRequestHeader::set_key(const char* value) {
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cockroach.proto.KVRequestHeader.key)
}
 void KVRequestHeader::set_key(const void* value, size_t size) {
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cockroach.proto.KVRequestHeader.key)
}
 ::std::string* KVRequestHeader::mutable_key() {
  set_has_key();
  // @@protoc_insertion_point(field_mutable:cockroach.proto.KVRequestHeader.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* KVRequestHeader::release_key() {
  clear_has_key();
  return key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void KVRequestHeader::set_allocated_key(::std::string* key) {
  if (key != NULL) {
    set_has_key();
  } else {
    clear_has_key();
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.KVRequestHeader.key)
}

// optional bytes end_key = 4;
bool KVRequestHeader::has_end_key() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void KVRequestHeader::set_has_end_key() {
  _has_bits_[0] |= 0x00000004u;
}
void KVRequestHeader::clear_has_end_key() {
  _has_bits_[0] &= ~0x00000004u;
}
void KVRequestHeader::clear_end_key() {
  end_key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_end_key();
}
 const ::std::string& KVRequestHeader::end_key() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.KVRequestHeader.end_key)
  return end_key_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void KVRequestHeader::set_end_key(const ::std::string& value) {
  set_has_end_key();
  end_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cockroach.proto.KVRequestHeader.end_key)
}
 void KVRequestHeader::set_end_key(const char* value) {
  set_has_end_key();
  end_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cockroach.proto.KVRequestHeader.end_key)
}
 void KVRequestHeader::set_end_key(const void* value, size_t size) {
  set_has_end_key();
  end_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cockroach.proto.KVRequestHeader.end_key)
}
 ::std::string* KVRequestHeader::mutable_end_key() {
  set_has_end_key();
  // @@protoc_insertion_point(field_mutable:cockroach.proto.KVRequestHeader.end_key)
  return end_key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* KVRequestHeader::release_end_key() {
  clear_has_end_key();
  return end_key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void KVRequestHeader::set_allocated_end_key(::std::string* end_key) {
  if (end_key != NULL) {
    set_has_end_key();
  } else {
    clear_has_end_key();
  }
  end_key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), end_key);
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.KVRequestHeader.end_key)
}

// optional .cockroach.proto.Replica replica = 6;
bool KVRequestHeader::has_replica() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void KVRequestHeader::set_has_replica() {
  _has_bits_[0] |= 0x00000008u;
}
void KVRequestHeader::clear_has_replica() {
  _has_bits_[0] &= ~0x00000008u;
}
void KVRequestHeader::clear_replica() {
  if (replica_ != NULL) replica_->::cockroach::proto::Replica::Clear();
  clear_has_replica();
}
 const ::cockroach::proto::Replica& KVRequestHeader::replica() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.KVRequestHeader.replica)
  return replica_ != NULL ? *replica_ : *default_instance_->replica_;
}
 ::cockroach::proto::Replica* KVRequestHeader::mutable_replica() {
  set_has_replica();
  if (replica_ == NULL) {
    replica_ = new ::cockroach::proto::Replica;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.proto.KVRequestHeader.replica)
  return replica_;
}
 ::cockroach::proto::Replica* KVRequestHeader::release_replica() {
  clear_has_replica();
  ::cockroach::proto::Replica* temp = replica_;
  replica_ = NULL;
  return temp;
}
 void KVRequestHeader::set_allocated_replica(::cockroach::proto::Replica* replica) {
  delete replica_;
  replica_ = replica;
  if (replica) {
    set_has_replica();
  } else {
    clear_has_replica();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.KVRequestHeader.replica)
}

// optional int64 raft_id = 7;
bool KVRequestHeader::has_raft_id() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
void KVRequestHeader::set_has_raft_id() {
  _has_bits_[0] |= 0x00000010u;
}
void KVRequestHeader::clear_has_raft_id() {
  _has_bits_[0] &= ~0x00000010u;
}
void KVRequestHeader::clear_raft_id() {
  raft_id_ = GOOGLE_LONGLONG(0);
  clear_has_raft_id();
}
 ::google::protobuf::int64 KVRequestHeader::raft_id() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.KVRequestHeader.raft_id)
  return raft_id_;
}
 void KVRequestHeader::set_raft_id(::google::protobuf::int64 value) {
  set_has_raft_id();
  raft_id_ = value;
  // @@protoc_insertion_point(field_set:cockroach.proto.KVRequestHeader.raft_id)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#ifndef _MSC_VER
const int KVResponseHeader::kHeaderFieldNumber;
#endif  // !_MSC_VER

KVResponseHeader::KVResponseHeader()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:cockroach.proto.KVResponseHeader)
}

void KVResponseHeader::InitAsDefaultInstance() {
  header_ = const_cast< ::cockroach::proto::ResponseHeader*>(&::cockroach::proto::ResponseHeader::default_instance());
}

KVResponseHeader::KVResponseHeader(const KVResponseHeader& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:cockroach.proto.KVResponseHeader)
}

void KVResponseHeader::SharedCtor() {
  _cached_size_ = 0;
  header_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

KVResponseHeader::~KVResponseHeader() {
  // @@protoc_insertion_point(destructor:cockroach.proto.KVResponseHeader)
  SharedDtor();
}

void KVResponseHeader::SharedDtor() {
  if (this != default_instance_) {
    delete header_;
  }
}

void KVResponseHeader::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* KVResponseHeader::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return KVResponseHeader_descriptor_;
}

const KVResponseHeader& KVResponseHeader::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_cockroach_2fproto_2fapi_2eproto();
  return *default_instance_;
}

KVResponseHeader* KVResponseHeader::default_instance_ = NULL;

KVResponseHeader* KVResponseHeader::New(::google::protobuf::Arena* arena) const {
  KVResponseHeader* n = new KVResponseHeader;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void KVResponseHeader::Clear() {
  if (has_header()) {
    if (header_ != NULL) header_->::cockroach::proto::ResponseHeader::Clear();
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool KVResponseHeader::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:cockroach.proto.KVResponseHeader)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .cockroach.proto.ResponseHeader header = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_header()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:cockroach.proto.KVResponseHeader)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:cockroach.proto.KVResponseHeader)
  return false;
#undef DO_
}

void KVResponseHeader::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:cockroach.proto.KVResponseHeader)
  // optional .cockroach.proto.ResponseHeader header = 1;
  if (has_header()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->header_, output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:cockroach.proto.KVResponseHeader)
}

::google::protobuf::uint8* KVResponseHeader::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:cockroach.proto.KVResponseHeader)
  // optional .cockroach.proto.ResponseHeader header = 1;
  if (has_header()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, *this->header_, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:cockroach.proto.KVResponseHeader)
  return target;
}

int KVResponseHeader::ByteSize() const {
  int total_size = 0;

  // optional .cockroach.proto.ResponseHeader header = 1;
  if (has_header()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->header_);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void KVResponseHeader::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const KVResponseHeader* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const KVResponseHeader>(
          &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void KVResponseHeader::MergeFrom(const KVResponseHeader& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_header()) {
      mutable_header()->::cockroach::proto::ResponseHeader::MergeFrom(from.header());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void KVResponseHeader::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void KVResponseHeader::CopyFrom(const KVResponseHeader& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool KVResponseHeader::IsInitialized() const {

  return true;
}

void KVResponseHeader::Swap(KVResponseHeader* other) {
  if (other == this) return;
  InternalSwap(other);
}
void KVResponseHeader::InternalSwap(KVResponseHeader* other) {
  std::swap(header_, other->header_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata KVResponseHeader::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = KVResponseHeader_descriptor_;
  metadata.reflection = KVResponseHeader_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// KVResponseHeader

// optional .cockroach.proto.ResponseHeader header = 1;
bool KVResponseHeader::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void KVResponseHeader::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
void KVResponseHeader::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
void KVResponseHeader::clear_header() {
  if (header_ != NULL) header_->::cockroach::proto::ResponseHeader::Clear();
  clear_has_header();
}
 const ::cockroach::proto::ResponseHeader& KVResponseHeader::header() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.KVResponseHeader.header)
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
 ::cockroach::proto::ResponseHeader* KVResponseHeader::mutable_header() {
  set_has_header();
  if (header_ == NULL) {
    header_ = new ::cockroach::proto::ResponseHeader;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.proto.KVResponseHeader.header)
  return header_;
}
 ::cockroach::proto::ResponseHeader* KVResponseHeader::release_header() {
  clear_has_header();
  ::cockroach::proto::ResponseHeader* temp = header_;
  header_ = NULL;
  return temp;
}
 void KVResponseHeader::set_allocated_header(::cockroach::proto::ResponseHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.KVResponseHeader.header)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#ifndef _MSC_VER
const int GetRequest::kKvheaderFieldNumber;
#endif  // !_MSC_VER

GetRequest::GetRequest()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:cockroach.proto.GetRequest)
}

void GetRequest::InitAsDefaultInstance() {
  kvheader_ = const_cast< ::cockroach::proto::KVRequestHeader*>(&::cockroach::proto::KVRequestHeader::default_instance());
}

GetRequest::GetRequest(const GetRequest& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:cockroach.proto.GetRequest)
}

void GetRequest::SharedCtor() {
  _cached_size_ = 0;
  kvheader_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GetRequest::~GetRequest() {
  // @@protoc_insertion_point(destructor:cockroach.proto.GetRequest)
  SharedDtor();
}

void GetRequest::SharedDtor() {
  if (this != default_instance_) {
    delete kvheader_;
  }
}

void GetRequest::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* GetRequest::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return GetRequest_descriptor_;
}

const GetRequest& GetRequest::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_cockroach_2fproto_2fapi_2eproto();
  return *default_instance_;
}

GetRequest* GetRequest::default_instance_ = NULL;

GetRequest* GetRequest::New(::google::protobuf::Arena* arena) const {
  GetRequest* n = new GetRequest;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void GetRequest::Clear() {
  if (has_kvheader()) {
    if (kvheader_ != NULL) kvheader_->::cockroach::proto::KVRequestHeader::Clear();
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool GetRequest::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:cockroach.proto.GetRequest)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .cockroach.proto.KVRequestHeader kvheader = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_kvheader()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:cockroach.proto.GetRequest)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:cockroach.proto.GetRequest)
  return false;
#undef DO_
}

void GetRequest::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:cockroach.proto.GetRequest)
  // optional .cockroach.proto.KVRequestHeader kvheader = 1;
  if (has_kvheader()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->kvheader_, output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:cockroach.proto.GetRequest)
}

::google::protobuf::uint8* GetRequest::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:cockroach.proto.GetRequest)
  // optional .cockroach.proto.KVRequestHeader kvheader = 1;
  if (has_kvheader()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, *this->kvheader_, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:cockroach.proto.GetRequest)
  return target;
}

int GetRequest::ByteSize() const {
  int total_size = 0;

  // optional .cockroach.proto.KVRequestHeader kvheader = 1;
  if (has_kvheader()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->kvheader_);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GetRequest::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const GetRequest* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const GetRequest>(
          &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void GetRequest::MergeFrom(const GetRequest& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_kvheader()) {
      mutable_kvheader()->::cockroach::proto::KVRequestHeader::MergeFrom(from.kvheader());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void GetRequest::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void GetRequest::CopyFrom(const GetRequest& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GetRequest::IsInitialized() const {

  return true;
}

void GetRequest::Swap(GetRequest* other) {
  if (other == this) return;
  InternalSwap(other);
}
void GetRequest::InternalSwap(GetRequest* other) {
  std::swap(kvheader_, other->kvheader_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata GetRequest::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = GetRequest_descriptor_;
  metadata.reflection = GetRequest_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// GetRequest

// optional .cockroach.proto.KVRequestHeader kvheader = 1;
bool GetRequest::has_kvheader() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void GetRequest::set_has_kvheader() {
  _has_bits_[0] |= 0x00000001u;
}
void GetRequest::clear_has_kvheader() {
  _has_bits_[0] &= ~0x00000001u;
}
void GetRequest::clear_kvheader() {
  if (kvheader_ != NULL) kvheader_->::cockroach::proto::KVRequestHeader::Clear();
  clear_has_kvheader();
}
 const ::cockroach::proto::KVRequestHeader& GetRequest::kvheader() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.GetRequest.kvheader)
  return kvheader_ != NULL ? *kvheader_ : *default_instance_->kvheader_;
}
 ::cockroach::proto::KVRequestHeader* GetRequest::mutable_kvheader() {
  set_has_kvheader();
  if (kvheader_ == NULL) {
    kvheader_ = new ::cockroach::proto::KVRequestHeader;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.proto.GetRequest.kvheader)
  return kvheader_;
}
 ::cockroach::proto::KVRequestHeader* GetRequest::release_kvheader() {
  clear_has_kvheader();
  ::cockroach::proto::KVRequestHeader* temp = kvheader_;
  kvheader_ = NULL;
  return temp;
}
 void GetRequest::set_allocated_kvheader(::cockroach::proto::KVRequestHeader* kvheader) {
  delete kvheader_;
  kvheader_ = kvheader;
  if (kvheader) {
    set_has_kvheader();
  } else {
    clear_has_kvheader();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.GetRequest.kvheader)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#ifndef _MSC_VER
const int GetResponse::kKvheaderFieldNumber;
const int GetResponse::kValueFieldNumber;
#endif  // !_MSC_VER

GetResponse::GetResponse()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:cockroach.proto.GetResponse)
}

void GetResponse::InitAsDefaultInstance() {
  kvheader_ = const_cast< ::cockroach::proto::KVResponseHeader*>(&::cockroach::proto::KVResponseHeader::default_instance());
  value_ = const_cast< ::cockroach::proto::Value*>(&::cockroach::proto::Value::default_instance());
}

GetResponse::GetResponse(const GetResponse& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:cockroach.proto.GetResponse)
}

void GetResponse::SharedCtor() {
  _cached_size_ = 0;
  kvheader_ = NULL;
  value_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GetResponse::~GetResponse() {
  // @@protoc_insertion_point(destructor:cockroach.proto.GetResponse)
  SharedDtor();
}

void GetResponse::SharedDtor() {
  if (this != default_instance_) {
    delete kvheader_;
    delete value_;
  }
}

void GetResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* GetResponse::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return GetResponse_descriptor_;
}

const GetResponse& GetResponse::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_cockroach_2fproto_2fapi_2eproto();
  return *default_instance_;
}

GetResponse* GetResponse::default_instance_ = NULL;

GetResponse* GetResponse::New(::google::protobuf::Arena* arena) const {
  GetResponse* n = new GetResponse;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void GetResponse::Clear() {
  if (_has_bits_[0 / 32] & 3u) {
    if (has_kvheader()) {
      if (kvheader_ != NULL) kvheader_->::cockroach::proto::KVResponseHeader::Clear();
    }
    if (has_value()) {
      if (value_ != NULL) value_->::cockroach::proto::Value::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool GetResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:cockroach.proto.GetResponse)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .cockroach.proto.KVResponseHeader kvheader = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_kvheader()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_value;
        break;
      }

      // optional .cockroach.proto.Value value = 2;
      case 2: {
        if (tag == 18) {
         parse_value:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_value()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:cockroach.proto.GetResponse)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:cockroach.proto.GetResponse)
  return false;
#undef DO_
}

void GetResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:cockroach.proto.GetResponse)
  // optional .cockroach.proto.KVResponseHeader kvheader = 1;
  if (has_kvheader()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->kvheader_, output);
  }

  // optional .cockroach.proto.Value value = 2;
  if (has_value()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, *this->value_, output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:cockroach.proto.GetResponse)
}

::google::protobuf::uint8* GetResponse::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:cockroach.proto.GetResponse)
  // optional .cockroach.proto.KVResponseHeader kvheader = 1;
  if (has_kvheader()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, *this->kvheader_, target);
  }

  // optional .cockroach.proto.Value value = 2;
  if (has_value()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, *this->value_, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:cockroach.proto.GetResponse)
  return target;
}

int GetResponse::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & 3) {
    // optional .cockroach.proto.KVResponseHeader kvheader = 1;
    if (has_kvheader()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->kvheader_);
    }

    // optional .cockroach.proto.Value value = 2;
    if (has_value()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->value_);
    }

  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GetResponse::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const GetResponse* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const GetResponse>(
          &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void GetResponse::MergeFrom(const GetResponse& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_kvheader()) {
      mutable_kvheader()->::cockroach::proto::KVResponseHeader::MergeFrom(from.kvheader());
    }
    if (from.has_value()) {
      mutable_value()->::cockroach::proto::Value::MergeFrom(from.value());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void GetResponse::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void GetResponse::CopyFrom(const GetResponse& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GetResponse::IsInitialized() const {

  return true;
}

void GetResponse::Swap(GetResponse* other) {
  if (other == this) return;
  InternalSwap(other);
}
void GetResponse::InternalSwap(GetResponse* other) {
  std::swap(kvheader_, other->kvheader_);
  std::swap(value_, other->value_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata GetResponse::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = GetResponse_descriptor_;
  metadata.reflection = GetResponse_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// GetResponse

// optional .cockroach.proto.KVResponseHeader kvheader = 1;
bool GetResponse::has_kvheader() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void GetResponse::set_has_kvheader() {
  _has_bits_[0] |= 0x00000001u;
}
void GetResponse::clear_has_kvheader() {
  _has_bits_[0] &= ~0x00000001u;
}
void GetResponse::clear_kvheader() {
  if (kvheader_ != NULL) kvheader_->::cockroach::proto::KVResponseHeader::Clear();
  clear_has_kvheader();
}
 const ::cockroach::proto::KVResponseHeader& GetResponse::kvheader() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.GetResponse.kvheader)
  return kvheader_ != NULL ? *kvheader_ : *default_instance_->kvheader_;
}
 ::cockroach::proto::KVResponseHeader* GetResponse::mutable_kvheader() {
  set_has_kvheader();
  if (kvheader_ == NULL) {
    kvheader_ = new ::cockroach::proto::KVResponseHeader;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.proto.GetResponse.kvheader)
  return kvheader_;
}
 ::cockroach::proto::KVResponseHeader* GetResponse::release_kvheader() {
  clear_has_kvheader();
  ::cockroach::proto::KVResponseHeader* temp = kvheader_;
  kvheader_ = NULL;
  return temp;
}
 void GetResponse::set_allocated_kvheader(::cockroach::proto::KVResponseHeader* kvheader) {
  delete kvheader_;
  kvheader_ = kvheader;
  if (kvheader) {
    set_has_kvheader();
  } else {
    clear_has_kvheader();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.GetResponse.kvheader)
}

// optional .cockroach.proto.Value value = 2;
bool GetResponse::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void GetResponse::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
void GetResponse::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
void GetResponse::clear_value() {
  if (value_ != NULL) value_->::cockroach::proto::Value::Clear();
  clear_has_value();
}
 const ::cockroach::proto::Value& GetResponse::value() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.GetResponse.value)
  return value_ != NULL ? *value_ : *default_instance_->value_;
}
 ::cockroach::proto::Value* GetResponse::mutable_value() {
  set_has_value();
  if (value_ == NULL) {
    value_ = new ::cockroach::proto::Value;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.proto.GetResponse.value)
  return value_;
}
 ::cockroach::proto::Value* GetResponse::release_value() {
  clear_has_value();
  ::cockroach::proto::Value* temp = value_;
  value_ = NULL;
  return temp;
}
 void GetResponse::set_allocated_value(::cockroach::proto::Value* value) {
  delete value_;
  value_ = value;
  if (value) {
    set_has_value();
  } else {
    clear_has_value();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.GetResponse.value)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#ifndef _MSC_VER
const int PutRequest::kKvheaderFieldNumber;
const int PutRequest::kValueFieldNumber;
#endif  // !_MSC_VER

PutRequest::PutRequest()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:cockroach.proto.PutRequest)
}

void PutRequest::InitAsDefaultInstance() {
  kvheader_ = const_cast< ::cockroach::proto::KVRequestHeader*>(&::cockroach::proto::KVRequestHeader::default_instance());
  value_ = const_cast< ::cockroach::proto::Value*>(&::cockroach::proto::Value::default_instance());
}

PutRequest::PutRequest(const PutRequest& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:cockroach.proto.PutRequest)
}

void PutRequest::SharedCtor() {
  _cached_size_ = 0;
  kvheader_ = NULL;
  value_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

PutRequest::~PutRequest() {
  // @@protoc_insertion_point(destructor:cockroach.proto.PutRequest)
  SharedDtor();
}

void PutRequest::SharedDtor() {
  if (this != default_instance_) {
    delete kvheader_;
    delete value_;
  }
}

void PutRequest::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* PutRequest::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return PutRequest_descriptor_;
}

const PutRequest& PutRequest::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_cockroach_2fproto_2fapi_2eproto();
  return *default_instance_;
}

PutRequest* PutRequest::default_instance_ = NULL;

PutRequest* PutRequest::New(::google::protobuf::Arena* arena) const {
  PutRequest* n = new PutRequest;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void PutRequest::Clear() {
  if (_has_bits_[0 / 32] & 3u) {
    if (has_kvheader()) {
      if (kvheader_ != NULL) kvheader_->::cockroach::proto::KVRequestHeader::Clear();
    }
    if (has_value()) {
      if (value_ != NULL) value_->::cockroach::proto::Value::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool PutRequest::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:cockroach.proto.PutRequest)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .cockroach.proto.KVRequestHeader kvheader = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_kvheader()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_value;
        break;
      }

      // optional .cockroach.proto.Value value = 2;
      case 2: {
        if (tag == 18) {
         parse_value:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_value()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:cockroach.proto.PutRequest)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:cockroach.proto.PutRequest)
  return false;
#undef DO_
}

void PutRequest::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:cockroach.proto.PutRequest)
  // optional .cockroach.proto.KVRequestHeader kvheader = 1;
  if (has_kvheader()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->kvheader_, output);
  }

  // optional .cockroach.proto.Value value = 2;
  if (has_value()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, *this->value_, output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:cockroach.proto.PutRequest)
}

::google::protobuf::uint8* PutRequest::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:cockroach.proto.PutRequest)
  // optional .cockroach.proto.KVRequestHeader kvheader = 1;
  if (has_kvheader()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, *this->kvheader_, target);
  }

  // optional .cockroach.proto.Value value = 2;
  if (has_value()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, *this->value_, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:cockroach.proto.PutRequest)
  return target;
}

int PutRequest::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & 3) {
    // optional .cockroach.proto.KVRequestHeader kvheader = 1;
    if (has_kvheader()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->kvheader_);
    }

    // optional .cockroach.proto.Value value = 2;
    if (has_value()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->value_);
    }

  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void PutRequest::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const PutRequest* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const PutRequest>(
          &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void PutRequest::MergeFrom(const PutRequest& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_kvheader()) {
      mutable_kvheader()->::cockroach::proto::KVRequestHeader::MergeFrom(from.kvheader());
    }
    if (from.has_value()) {
      mutable_value()->::cockroach::proto::Value::MergeFrom(from.value());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void PutRequest::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void PutRequest::CopyFrom(const PutRequest& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PutRequest::IsInitialized() const {

  return true;
}

void PutRequest::Swap(PutRequest* other) {
  if (other == this) return;
  InternalSwap(other);
}
void PutRequest::InternalSwap(PutRequest* other) {
  std::swap(kvheader_, other->kvheader_);
  std::swap(value_, other->value_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata PutRequest::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = PutRequest_descriptor_;
  metadata.reflection = PutRequest_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// PutRequest

// optional .cockroach.proto.KVRequestHeader kvheader = 1;
bool PutRequest::has_kvheader() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void PutRequest::set_has_kvheader() {
  _has_bits_[0] |= 0x00000001u;
}
void PutRequest::clear_has_kvheader() {
  _has_bits_[0] &= ~0x00000001u;
}
void PutRequest::clear_kvheader() {
  if (kvheader_ != NULL) kvheader_->::cockroach::proto::KVRequestHeader::Clear();
  clear_has_kvheader();
}
 const ::cockroach::proto::KVRequestHeader& PutRequest::kvheader() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.PutRequest.kvheader)
  return kvheader_ != NULL ? *kvheader_ : *default_instance_->kvheader_;
}
 ::cockroach::proto::KVRequestHeader* PutRequest::mutable_kvheader() {
  set_has_kvheader();
  if (kvheader_ == NULL) {
    kvheader_ = new ::cockroach::proto::KVRequestHeader;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.proto.PutRequest.kvheader)
  return kvheader_;
}
 ::cockroach::proto::KVRequestHeader* PutRequest::release_kvheader() {
  clear_has_kvheader();
  ::cockroach::proto::KVRequestHeader* temp = kvheader_;
  kvheader_ = NULL;
  return temp;
}
 void PutRequest::set_allocated_kvheader(::cockroach::proto::KVRequestHeader* kvheader) {
  delete kvheader_;
  kvheader_ = kvheader;
  if (kvheader) {
    set_has_kvheader();
  } else {
    clear_has_kvheader();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.PutRequest.kvheader)
}

// optional .cockroach.proto.Value value = 2;
bool PutRequest::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void PutRequest::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
void PutRequest::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
void PutRequest::clear_value() {
  if (value_ != NULL) value_->::cockroach::proto::Value::Clear();
  clear_has_value();
}
 const ::cockroach::proto::Value& PutRequest::value() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.PutRequest.value)
  return value_ != NULL ? *value_ : *default_instance_->value_;
}
 ::cockroach::proto::Value* PutRequest::mutable_value() {
  set_has_value();
  if (value_ == NULL) {
    value_ = new ::cockroach::proto::Value;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.proto.PutRequest.value)
  return value_;
}
 ::cockroach::proto::Value* PutRequest::release_value() {
  clear_has_value();
  ::cockroach::proto::Value* temp = value_;
  value_ = NULL;
  return temp;
}
 void PutRequest::set_allocated_value(::cockroach::proto::Value* value) {
  delete value_;
  value_ = value;
  if (value) {
    set_has_value();
  } else {
    clear_has_value();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.PutRequest.value)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#ifndef _MSC_VER
const int PutResponse::kKvheaderFieldNumber;
#endif  // !_MSC_VER

PutResponse::PutResponse()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:cockroach.proto.PutResponse)
}

void PutResponse::InitAsDefaultInstance() {
  kvheader_ = const_cast< ::cockroach::proto::KVResponseHeader*>(&::cockroach::proto::KVResponseHeader::default_instance());
}

PutResponse::PutResponse(const PutResponse& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:cockroach.proto.PutResponse)
}

void PutResponse::SharedCtor() {
  _cached_size_ = 0;
  kvheader_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

PutResponse::~PutResponse() {
  // @@protoc_insertion_point(destructor:cockroach.proto.PutResponse)
  SharedDtor();
}

void PutResponse::SharedDtor() {
  if (this != default_instance_) {
    delete kvheader_;
  }
}

void PutResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* PutResponse::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return PutResponse_descriptor_;
}

const PutResponse& PutResponse::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_cockroach_2fproto_2fapi_2eproto();
  return *default_instance_;
}

PutResponse* PutResponse::default_instance_ = NULL;

PutResponse* PutResponse::New(::google::protobuf::Arena* arena) const {
  PutResponse* n = new PutResponse;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void PutResponse::Clear() {
  if (has_kvheader()) {
    if (kvheader_ != NULL) kvheader_->::cockroach::proto::KVResponseHeader::Clear();
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool PutResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:cockroach.proto.PutResponse)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .cockroach.proto.KVResponseHeader kvheader = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_kvheader()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:cockroach.proto.PutResponse)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:cockroach.proto.PutResponse)
  return false;
#undef DO_
}

void PutResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:cockroach.proto.PutResponse)
  // optional .cockroach.proto.KVResponseHeader kvheader = 1;
  if (has_kvheader()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->kvheader_, output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:cockroach.proto.PutResponse)
}

::google::protobuf::uint8* PutResponse::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:cockroach.proto.PutResponse)
  // optional .cockroach.proto.KVResponseHeader kvheader = 1;
  if (has_kvheader()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, *this->kvheader_, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:cockroach.proto.PutResponse)
  return target;
}

int PutResponse::ByteSize() const {
  int total_size = 0;

  // optional .cockroach.proto.KVResponseHeader kvheader = 1;
  if (has_kvheader()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->kvheader_);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void PutResponse::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const PutResponse* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const PutResponse>(
          &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void PutResponse::MergeFrom(const PutResponse& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_kvheader()) {
      mutable_kvheader()->::cockroach::proto::KVResponseHeader::MergeFrom(from.kvheader());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void PutResponse::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void PutResponse::CopyFrom(const PutResponse& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PutResponse::IsInitialized() const {

  return true;
}

void PutResponse::Swap(PutResponse* other) {
  if (other == this) return;
  InternalSwap(other);
}
void PutResponse::InternalSwap(PutResponse* other) {
  std::swap(kvheader_, other->kvheader_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata PutResponse::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = PutResponse_descriptor_;
  metadata.reflection = PutResponse_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// PutResponse

// optional .cockroach.proto.KVResponseHeader kvheader = 1;
bool PutResponse::has_kvheader() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void PutResponse::set_has_kvheader() {
  _has_bits_[0] |= 0x00000001u;
}
void PutResponse::clear_has_kvheader() {
  _has_bits_[0] &= ~0x00000001u;
}
void PutResponse::clear_kvheader() {
  if (kvheader_ != NULL) kvheader_->::cockroach::proto::KVResponseHeader::Clear();
  clear_has_kvheader();
}
 const ::cockroach::proto::KVResponseHeader& PutResponse::kvheader() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.PutResponse.kvheader)
  return kvheader_ != NULL ? *kvheader_ : *default_instance_->kvheader_;
}
 ::cockroach::proto::KVResponseHeader* PutResponse::mutable_kvheader() {
  set_has_kvheader();
  if (kvheader_ == NULL) {
    kvheader_ = new ::cockroach::proto::KVResponseHeader;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.proto.PutResponse.kvheader)
  return kvheader_;
}
 ::cockroach::proto::KVResponseHeader* PutResponse::release_kvheader() {
  clear_has_kvheader();
  ::cockroach::proto::KVResponseHeader* temp = kvheader_;
  kvheader_ = NULL;
  return temp;
}
 void PutResponse::set_allocated_kvheader(::cockroach::proto::KVResponseHeader* kvheader) {
  delete kvheader_;
  kvheader_ = kvheader;
  if (kvheader) {
    set_has_kvheader();
  } else {
    clear_has_kvheader();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.PutResponse.kvheader)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#ifndef _MSC_VER
const int ConditionalPutRequest::kKvheaderFieldNumber;
const int ConditionalPutRequest::kValueFieldNumber;
const int ConditionalPutRequest::kExpValueFieldNumber;
#endif  // !_MSC_VER

ConditionalPutRequest::ConditionalPutRequest()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:cockroach.proto.ConditionalPutRequest)
}

void ConditionalPutRequest::InitAsDefaultInstance() {
  kvheader_ = const_cast< ::cockroach::proto::KVRequestHeader*>(&::cockroach::proto::KVRequestHeader::default_instance());
  value_ = const_cast< ::cockroach::proto::Value*>(&::cockroach::proto::Value::default_instance());
  exp_value_ = const_cast< ::cockroach::proto::Value*>(&::cockroach::proto::Value::default_instance());
}

ConditionalPutRequest::ConditionalPutRequest(const ConditionalPutRequest& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:cockroach.proto.ConditionalPutRequest)
}

void ConditionalPutRequest::SharedCtor() {
  _cached_size_ = 0;
  kvheader_ = NULL;
  value_ = NULL;
  exp_value_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ConditionalPutRequest::~ConditionalPutRequest() {
  // @@protoc_insertion_point(destructor:cockroach.proto.ConditionalPutRequest)
  SharedDtor();
}

void ConditionalPutRequest::SharedDtor() {
  if (this != default_instance_) {
    delete kvheader_;
    delete value_;
    delete exp_value_;
  }
}

void ConditionalPutRequest::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ConditionalPutRequest::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ConditionalPutRequest_descriptor_;
}

const ConditionalPutRequest& ConditionalPutRequest::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_cockroach_2fproto_2fapi_2eproto();
  return *default_instance_;
}

ConditionalPutRequest* ConditionalPutRequest::default_instance_ = NULL;

ConditionalPutRequest* ConditionalPutRequest::New(::google::protobuf::Arena* arena) const {
  ConditionalPutRequest* n = new ConditionalPutRequest;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void ConditionalPutRequest::Clear() {
  if (_has_bits_[0 / 32] & 7u) {
    if (has_kvheader()) {
      if (kvheader_ != NULL) kvheader_->::cockroach::proto::KVRequestHeader::Clear();
    }
    if (has_value()) {
      if (value_ != NULL) value_->::cockroach::proto::Value::Clear();
    }
    if (has_exp_value()) {
      if (exp_value_ != NULL) exp_value_->::cockroach::proto::Value::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool ConditionalPutRequest::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:cockroach.proto.ConditionalPutRequest)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .cockroach.proto.KVRequestHeader kvheader = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_kvheader()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_value;
        break;
      }

      // optional .cockroach.proto.Value value = 2;
      case 2: {
        if (tag == 18) {
         parse_value:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_value()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_exp_value;
        break;
      }

      // optional .cockroach.proto.Value exp_value = 3;
      case 3: {
        if (tag == 26) {
         parse_exp_value:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_exp_value()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:cockroach.proto.ConditionalPutRequest)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:cockroach.proto.ConditionalPutRequest)
  return false;
#undef DO_
}

void ConditionalPutRequest::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:cockroach.proto.ConditionalPutRequest)
  // optional .cockroach.proto.KVRequestHeader kvheader = 1;
  if (has_kvheader()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->kvheader_, output);
  }

  // optional .cockroach.proto.Value value = 2;
  if (has_value()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, *this->value_, output);
  }

  // optional .cockroach.proto.Value exp_value = 3;
  if (has_exp_value()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, *this->exp_value_, output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:cockroach.proto.ConditionalPutRequest)
}

::google::protobuf::uint8* ConditionalPutRequest::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:cockroach.proto.ConditionalPutRequest)
  // optional .cockroach.proto.KVRequestHeader kvheader = 1;
  if (has_kvheader()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, *this->kvheader_, target);
  }

  // optional .cockroach.proto.Value value = 2;
  if (has_value()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, *this->value_, target);
  }

  // optional .cockroach.proto.Value exp_value = 3;
  if (has_exp_value()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, *this->exp_value_, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:cockroach.proto.ConditionalPutRequest)
  return target;
}

int ConditionalPutRequest::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & 7) {
    // optional .cockroach.proto.KVRequestHeader kvheader = 1;
    if (has_kvheader()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->kvheader_);
    }

    // optional .cockroach.proto.Value value = 2;
    if (has_value()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->value_);
    }

    // optional .cockroach.proto.Value exp_value = 3;
    if (has_exp_value()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->exp_value_);
    }

  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ConditionalPutRequest::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const ConditionalPutRequest* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const ConditionalPutRequest>(
          &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ConditionalPutRequest::MergeFrom(const ConditionalPutRequest& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_kvheader()) {
      mutable_kvheader()->::cockroach::proto::KVRequestHeader::MergeFrom(from.kvheader());
    }
    if (from.has_value()) {
      mutable_value()->::cockroach::proto::Value::MergeFrom(from.value());
    }
    if (from.has_exp_value()) {
      mutable_exp_value()->::cockroach::proto::Value::MergeFrom(from.exp_value());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void ConditionalPutRequest::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ConditionalPutRequest::CopyFrom(const ConditionalPutRequest& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ConditionalPutRequest::IsInitialized() const {

  return true;
}

void ConditionalPutRequest::Swap(ConditionalPutRequest* other) {
  if (other == this) return;
  InternalSwap(other);
}
void ConditionalPutRequest::InternalSwap(ConditionalPutRequest* other) {
  std::swap(kvheader_, other->kvheader_);
  std::swap(value_, other->value_);
  std::swap(exp_value_, other->exp_value_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata ConditionalPutRequest::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ConditionalPutRequest_descriptor_;
  metadata.reflection = ConditionalPutRequest_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// ConditionalPutRequest

// optional .cockroach.proto.KVRequestHeader kvheader = 1;
bool ConditionalPutRequest::has_kvheader() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void ConditionalPutRequest::set_has_kvheader() {
  _has_bits_[0] |= 0x00000001u;
}
void ConditionalPutRequest::clear_has_kvheader() {
  _has_bits_[0] &= ~0x00000001u;
}
void ConditionalPutRequest::clear_kvheader() {
  if (kvheader_ != NULL) kvheader_->::cockroach::proto::KVRequestHeader::Clear();
  clear_has_kvheader();
}
 const ::cockroach::proto::KVRequestHeader& ConditionalPutRequest::kvheader() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.ConditionalPutRequest.kvheader)
  return kvheader_ != NULL ? *kvheader_ : *default_instance_->kvheader_;
}
 ::cockroach::proto::KVRequestHeader* ConditionalPutRequest::mutable_kvheader() {
  set_has_kvheader();
  if (kvheader_ == NULL) {
    kvheader_ = new ::cockroach::proto::KVRequestHeader;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.proto.ConditionalPutRequest.kvheader)
  return kvheader_;
}
 ::cockroach::proto::KVRequestHeader* ConditionalPutRequest::release_kvheader() {
  clear_has_kvheader();
  ::cockroach::proto::KVRequestHeader* temp = kvheader_;
  kvheader_ = NULL;
  return temp;
}
 void ConditionalPutRequest::set_allocated_kvheader(::cockroach::proto::KVRequestHeader* kvheader) {
  delete kvheader_;
  kvheader_ = kvheader;
  if (kvheader) {
    set_has_kvheader();
  } else {
    clear_has_kvheader();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.ConditionalPutRequest.kvheader)
}

// optional .cockroach.proto.Value value = 2;
bool ConditionalPutRequest::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void ConditionalPutRequest::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
void ConditionalPutRequest::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
void ConditionalPutRequest::clear_value() {
  if (value_ != NULL) value_->::cockroach::proto::Value::Clear();
  clear_has_value();
}
 const ::cockroach::proto::Value& ConditionalPutRequest::value() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.ConditionalPutRequest.value)
  return value_ != NULL ? *value_ : *default_instance_->value_;
}
 ::cockroach::proto::Value* ConditionalPutRequest::mutable_value() {
  set_has_value();
  if (value_ == NULL) {
    value_ = new ::cockroach::proto::Value;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.proto.ConditionalPutRequest.value)
  return value_;
}
 ::cockroach::proto::Value* ConditionalPutRequest::release_value() {
  clear_has_value();
  ::cockroach::proto::Value* temp = value_;
  value_ = NULL;
  return temp;
}
 void ConditionalPutRequest::set_allocated_value(::cockroach::proto::Value* value) {
  delete value_;
  value_ = value;
  if (value) {
    set_has_value();
  } else {
    clear_has_value();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.ConditionalPutRequest.value)
}

// optional .cockroach.proto.Value exp_value = 3;
bool ConditionalPutRequest::has_exp_value() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void ConditionalPutRequest::set_has_exp_value() {
  _has_bits_[0] |= 0x00000004u;
}
void ConditionalPutRequest::clear_has_exp_value() {
  _has_bits_[0] &= ~0x00000004u;
}
void ConditionalPutRequest::clear_exp_value() {
  if (exp_value_ != NULL) exp_value_->::cockroach::proto::Value::Clear();
  clear_has_exp_value();
}
 const ::cockroach::proto::Value& ConditionalPutRequest::exp_value() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.ConditionalPutRequest.exp_value)
  return exp_value_ != NULL ? *exp_value_ : *default_instance_->exp_value_;
}
 ::cockroach::proto::Value* ConditionalPutRequest::mutable_exp_value() {
  set_has_exp_value();
  if (exp_value_ == NULL) {
    exp_value_ = new ::cockroach::proto::Value;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.proto.ConditionalPutRequest.exp_value)
  return exp_value_;
}
 ::cockroach::proto::Value* ConditionalPutRequest::release_exp_value() {
  clear_has_exp_value();
  ::cockroach::proto::Value* temp = exp_value_;
  exp_value_ = NULL;
  return temp;
}
 void ConditionalPutRequest::set_allocated_exp_value(::cockroach::proto::Value* exp_value) {
  delete exp_value_;
  exp_value_ = exp_value;
  if (exp_value) {
    set_has_exp_value();
  } else {
    clear_has_exp_value();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.ConditionalPutRequest.exp_value)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#ifndef _MSC_VER
const int ConditionalPutResponse::kKvheaderFieldNumber;
#endif  // !_MSC_VER

ConditionalPutResponse::ConditionalPutResponse()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:cockroach.proto.ConditionalPutResponse)
}

void ConditionalPutResponse::InitAsDefaultInstance() {
  kvheader_ = const_cast< ::cockroach::proto::KVResponseHeader*>(&::cockroach::proto::KVResponseHeader::default_instance());
}

ConditionalPutResponse::ConditionalPutResponse(const ConditionalPutResponse& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:cockroach.proto.ConditionalPutResponse)
}

void ConditionalPutResponse::SharedCtor() {
  _cached_size_ = 0;
  kvheader_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ConditionalPutResponse::~ConditionalPutResponse() {
  // @@protoc_insertion_point(destructor:cockroach.proto.ConditionalPutResponse)
  SharedDtor();
}

void ConditionalPutResponse::SharedDtor() {
  if (this != default_instance_) {
    delete kvheader_;
  }
}

void ConditionalPutResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ConditionalPutResponse::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ConditionalPutResponse_descriptor_;
}

const ConditionalPutResponse& ConditionalPutResponse::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_cockroach_2fproto_2fapi_2eproto();
  return *default_instance_;
}

ConditionalPutResponse* ConditionalPutResponse::default_instance_ = NULL;

ConditionalPutResponse* ConditionalPutResponse::New(::google::protobuf::Arena* arena) const {
  ConditionalPutResponse* n = new ConditionalPutResponse;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void ConditionalPutResponse::Clear() {
  if (has_kvheader()) {
    if (kvheader_ != NULL) kvheader_->::cockroach::proto::KVResponseHeader::Clear();
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool ConditionalPutResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:cockroach.proto.ConditionalPutResponse)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .cockroach.proto.KVResponseHeader kvheader = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_kvheader()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:cockroach.proto.ConditionalPutResponse)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:cockroach.proto.ConditionalPutResponse)
  return false;
#undef DO_
}

void ConditionalPutResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:cockroach.proto.ConditionalPutResponse)
  // optional .cockroach.proto.KVResponseHeader kvheader = 1;
  if (has_kvheader()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->kvheader_, output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:cockroach.proto.ConditionalPutResponse)
}

::google::protobuf::uint8* ConditionalPutResponse::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:cockroach.proto.ConditionalPutResponse)
  // optional .cockroach.proto.KVResponseHeader kvheader = 1;
  if (has_kvheader()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, *this->kvheader_, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:cockroach.proto.ConditionalPutResponse)
  return target;
}

int ConditionalPutResponse::ByteSize() const {
  int total_size = 0;

  // optional .cockroach.proto.KVResponseHeader kvheader = 1;
  if (has_kvheader()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->kvheader_);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ConditionalPutResponse::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const ConditionalPutResponse* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const ConditionalPutResponse>(
          &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ConditionalPutResponse::MergeFrom(const ConditionalPutResponse& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_kvheader()) {
      mutable_kvheader()->::cockroach::proto::KVResponseHeader::MergeFrom(from.kvheader());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void ConditionalPutResponse::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ConditionalPutResponse::CopyFrom(const ConditionalPutResponse& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ConditionalPutResponse::IsInitialized() const {

  return true;
}

void ConditionalPutResponse::Swap(ConditionalPutResponse* other) {
  if (other == this) return;
  InternalSwap(other);
}
void ConditionalPutResponse::InternalSwap(ConditionalPutResponse* other) {
  std::swap(kvheader_, other->kvheader_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata ConditionalPutResponse::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ConditionalPutResponse_descriptor_;
  metadata.reflection = ConditionalPutResponse_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// ConditionalPutResponse

// optional .cockroach.proto.KVResponseHeader kvheader = 1;
bool ConditionalPutResponse::has_kvheader() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void ConditionalPutResponse::set_has_kvheader() {
  _has_bits_[0] |= 0x00000001u;
}
void ConditionalPutResponse::clear_has_kvheader() {
  _has_bits_[0] &= ~0x00000001u;
}
void ConditionalPutResponse::clear_kvheader() {
  if (kvheader_ != NULL) kvheader_->::cockroach::proto::KVResponseHeader::Clear();
  clear_has_kvheader();
}
 const ::cockroach::proto::KVResponseHeader& ConditionalPutResponse::kvheader() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.ConditionalPutResponse.kvheader)
  return kvheader_ != NULL ? *kvheader_ : *default_instance_->kvheader_;
}
 ::cockroach::proto::KVResponseHeader* ConditionalPutResponse::mutable_kvheader() {
  set_has_kvheader();
  if (kvheader_ == NULL) {
    kvheader_ = new ::cockroach::proto::KVResponseHeader;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.proto.ConditionalPutResponse.kvheader)
  return kvheader_;
}
 ::cockroach::proto::KVResponseHeader* ConditionalPutResponse::release_kvheader() {
  clear_has_kvheader();
  ::cockroach::proto::KVResponseHeader* temp = kvheader_;
  kvheader_ = NULL;
  return temp;
}
 void ConditionalPutResponse::set_allocated_kvheader(::cockroach::proto::KVResponseHeader* kvheader) {
  delete kvheader_;
  kvheader_ = kvheader;
  if (kvheader) {
    set_has_kvheader();
  } else {
    clear_has_kvheader();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.ConditionalPutResponse.kvheader)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#ifndef _MSC_VER
const int IncrementRequest::kKvheaderFieldNumber;
const int IncrementRequest::kIncrementFieldNumber;
#endif  // !_MSC_VER

IncrementRequest::IncrementRequest()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:cockroach.proto.IncrementRequest)
}

void IncrementRequest::InitAsDefaultInstance() {
  kvheader_ = const_cast< ::cockroach::proto::KVRequestHeader*>(&::cockroach::proto::KVRequestHeader::default_instance());
}

IncrementRequest::IncrementRequest(const IncrementRequest& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:cockroach.proto.IncrementRequest)
}

void IncrementRequest::SharedCtor() {
  _cached_size_ = 0;
  kvheader_ = NULL;
  increment_ = GOOGLE_LONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

IncrementRequest::~IncrementRequest() {
  // @@protoc_insertion_point(destructor:cockroach.proto.IncrementRequest)
  SharedDtor();
}

void IncrementRequest::SharedDtor() {
  if (this != default_instance_) {
    delete kvheader_;
  }
}

void IncrementRequest::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* IncrementRequest::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return IncrementRequest_descriptor_;
}

const IncrementRequest& IncrementRequest::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_cockroach_2fproto_2fapi_2eproto();
  return *default_instance_;
}

IncrementRequest* IncrementRequest::default_instance_ = NULL;

IncrementRequest* IncrementRequest::New(::google::protobuf::Arena* arena) const {
  IncrementRequest* n = new IncrementRequest;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void IncrementRequest::Clear() {
  if (_has_bits_[0 / 32] & 3u) {
    if (has_kvheader()) {
      if (kvheader_ != NULL) kvheader_->::cockroach::proto::KVRequestHeader::Clear();
    }
    increment_ = GOOGLE_LONGLONG(0);
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool IncrementRequest::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:cockroach.proto.IncrementRequest)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .cockroach.proto.KVRequestHeader kvheader = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_kvheader()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_increment;
        break;
      }

      // optional int64 increment = 2;
      case 2: {
        if (tag == 16) {
         parse_increment:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &increment_)));
          set_has_increment();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:cockroach.proto.IncrementRequest)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:cockroach.proto.IncrementRequest)
  return false;
#undef DO_
}

void IncrementRequest::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:cockroach.proto.IncrementRequest)
  // optional .cockroach.proto.KVRequestHeader kvheader = 1;
  if (has_kvheader()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->kvheader_, output);
  }

  // optional int64 increment = 2;
  if (has_increment()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(2, this->increment(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:cockroach.proto.IncrementRequest)
}

::google::protobuf::uint8* IncrementRequest::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:cockroach.proto.IncrementRequest)
  // optional .cockroach.proto.KVRequestHeader kvheader = 1;
  if (has_kvheader()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, *this->kvheader_, target);
  }

  // optional int64 increment = 2;
  if (has_increment()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(2, this->increment(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:cockroach.proto.IncrementRequest)
  return target;
}

int IncrementRequest::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & 3) {
    // optional .cockroach.proto.KVRequestHeader kvheader = 1;
    if (has_kvheader()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->kvheader_);
    }

    // optional int64 increment = 2;
    if (has_increment()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->increment());
    }

  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void IncrementRequest::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const IncrementRequest* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const IncrementRequest>(
          &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void IncrementRequest::MergeFrom(const IncrementRequest& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_kvheader()) {
      mutable_kvheader()->::cockroach::proto::KVRequestHeader::MergeFrom(from.kvheader());
    }
    if (from.has_increment()) {
      set_increment(from.increment());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void IncrementRequest::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void IncrementRequest::CopyFrom(const IncrementRequest& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IncrementRequest::IsInitialized() const {

  return true;
}

void IncrementRequest::Swap(IncrementRequest* other) {
  if (other == this) return;
  InternalSwap(other);
}
void IncrementRequest::InternalSwap(IncrementRequest* other) {
  std::swap(kvheader_, other->kvheader_);
  std::swap(increment_, other->increment_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata IncrementRequest::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = IncrementRequest_descriptor_;
  metadata.reflection = IncrementRequest_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// IncrementRequest

// optional .cockroach.proto.KVRequestHeader kvheader = 1;
bool IncrementRequest::has_kvheader() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void IncrementRequest::set_has_kvheader() {
  _has_bits_[0] |= 0x00000001u;
}
void IncrementRequest::clear_has_kvheader() {
  _has_bits_[0] &= ~0x00000001u;
}
void IncrementRequest::clear_kvheader() {
  if (kvheader_ != NULL) kvheader_->::cockroach::proto::KVRequestHeader::Clear();
  clear_has_kvheader();
}
 const ::cockroach::proto::KVRequestHeader& IncrementRequest::kvheader() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.IncrementRequest.kvheader)
  return kvheader_ != NULL ? *kvheader_ : *default_instance_->kvheader_;
}
 ::cockroach::proto::KVRequestHeader* IncrementRequest::mutable_kvheader() {
  set_has_kvheader();
  if (kvheader_ == NULL) {
    kvheader_ = new ::cockroach::proto::KVRequestHeader;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.proto.IncrementRequest.kvheader)
  return kvheader_;
}
 ::cockroach::proto::KVRequestHeader* IncrementRequest::release_kvheader() {
  clear_has_kvheader();
  ::cockroach::proto::KVRequestHeader* temp = kvheader_;
  kvheader_ = NULL;
  return temp;
}
 void IncrementRequest::set_allocated_kvheader(::cockroach::proto::KVRequestHeader* kvheader) {
  delete kvheader_;
  kvheader_ = kvheader;
  if (kvheader) {
    set_has_kvheader();
  } else {
    clear_has_kvheader();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.IncrementRequest.kvheader)
}

// optional int64 increment = 2;
bool IncrementRequest::has_increment() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void IncrementRequest::set_has_increment() {
  _has_bits_[0] |= 0x00000002u;
}
void IncrementRequest::clear_has_increment() {
  _has_bits_[0] &= ~0x00000002u;
}
void IncrementRequest::clear_increment() {
  increment_ = GOOGLE_LONGLONG(0);
  clear_has_increment();
}
 ::google::protobuf::int64 IncrementRequest::increment() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.IncrementRequest.increment)
  return increment_;
}
 void IncrementRequest::set_increment(::google::protobuf::int64 value) {
  set_has_increment();
  increment_ = value;
  // @@protoc_insertion_point(field_set:cockroach.proto.IncrementRequest.increment)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#ifndef _MSC_VER
const int IncrementResponse::kKvheaderFieldNumber;
const int IncrementResponse::kNewValueFieldNumber;
#endif  // !_MSC_VER

IncrementResponse::IncrementResponse()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:cockroach.proto.IncrementResponse)
}

void IncrementResponse::InitAsDefaultInstance() {
  kvheader_ = const_cast< ::cockroach::proto::KVResponseHeader*>(&::cockroach::proto::KVResponseHeader::default_instance());
}

IncrementResponse::IncrementResponse(const IncrementResponse& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:cockroach.proto.IncrementResponse)
}

void IncrementResponse::SharedCtor() {
  _cached_size_ = 0;
  kvheader_ = NULL;
  new_value_ = GOOGLE_LONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

IncrementResponse::~IncrementResponse() {
  // @@protoc_insertion_point(destructor:cockroach.proto.IncrementResponse)
  SharedDtor();
}

void IncrementResponse::SharedDtor() {
  if (this != default_instance_) {
    delete kvheader_;
  }
}

void IncrementResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* IncrementResponse::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return IncrementResponse_descriptor_;
}

const IncrementResponse& IncrementResponse::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_cockroach_2fproto_2fapi_2eproto();
  return *default_instance_;
}

IncrementResponse* IncrementResponse::default_instance_ = NULL;

IncrementResponse* IncrementResponse::New(::google::protobuf::Arena* arena) const {
  IncrementResponse* n = new IncrementResponse;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void IncrementResponse::Clear() {
  if (_has_bits_[0 / 32] & 3u) {
    if (has_kvheader()) {
      if (kvheader_ != NULL) kvheader_->::cockroach::proto::KVResponseHeader::Clear();
    }
    new_value_ = GOOGLE_LONGLONG(0);
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool IncrementResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:cockroach.proto.IncrementResponse)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .cockroach.proto.KVResponseHeader kvheader = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_kvheader()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_new_value;
        break;
      }

      // optional int64 new_value = 2;
      case 2: {
        if (tag == 16) {
         parse_new_value:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &new_value_)));
          set_has_new_value();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:cockroach.proto.IncrementResponse)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:cockroach.proto.IncrementResponse)
  return false;
#undef DO_
}

void IncrementResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:cockroach.proto.IncrementResponse)
  // optional .cockroach.proto.KVResponseHeader kvheader = 1;
  if (has_kvheader()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->kvheader_, output);
  }

  // optional int64 new_value = 2;
  if (has_new_value()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(2, this->new_value(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:cockroach.proto.IncrementResponse)
}

::google::protobuf::uint8* IncrementResponse::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:cockroach.proto.IncrementResponse)
  // optional .cockroach.proto.KVResponseHeader kvheader = 1;
  if (has_kvheader()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, *this->kvheader_, target);
  }

  // optional int64 new_value = 2;
  if (has_new_value()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(2, this->new_value(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:cockroach.proto.IncrementResponse)
  return target;
}

int IncrementResponse::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & 3) {
    // optional .cockroach.proto.KVResponseHeader kvheader = 1;
    if (has_kvheader()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->kvheader_);
    }

    // optional int64 new_value = 2;
    if (has_new_value()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->new_value());
    }

  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void IncrementResponse::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const IncrementResponse* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const IncrementResponse>(
          &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void IncrementResponse::MergeFrom(const IncrementResponse& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_kvheader()) {
      mutable_kvheader()->::cockroach::proto::KVResponseHeader::MergeFrom(from.kvheader());
    }
    if (from.has_new_value()) {
      set_new_value(from.new_value());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void IncrementResponse::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void IncrementResponse::CopyFrom(const IncrementResponse& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IncrementResponse::IsInitialized() const {

  return true;
}

void IncrementResponse::Swap(IncrementResponse* other) {
  if (other == this) return;
  InternalSwap(other);
}
void IncrementResponse::InternalSwap(IncrementResponse* other) {
  std::swap(kvheader_, other->kvheader_);
  std::swap(new_value_, other->new_value_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata IncrementResponse::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = IncrementResponse_descriptor_;
  metadata.reflection = IncrementResponse_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// IncrementResponse

// optional .cockroach.proto.KVResponseHeader kvheader = 1;
bool IncrementResponse::has_kvheader() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void IncrementResponse::set_has_kvheader() {
  _has_bits_[0] |= 0x00000001u;
}
void IncrementResponse::clear_has_kvheader() {
  _has_bits_[0] &= ~0x00000001u;
}
void IncrementResponse::clear_kvheader() {
  if (kvheader_ != NULL) kvheader_->::cockroach::proto::KVResponseHeader::Clear();
  clear_has_kvheader();
}
 const ::cockroach::proto::KVResponseHeader& IncrementResponse::kvheader() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.IncrementResponse.kvheader)
  return kvheader_ != NULL ? *kvheader_ : *default_instance_->kvheader_;
}
 ::cockroach::proto::KVResponseHeader* IncrementResponse::mutable_kvheader() {
  set_has_kvheader();
  if (kvheader_ == NULL) {
    kvheader_ = new ::cockroach::proto::KVResponseHeader;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.proto.IncrementResponse.kvheader)
  return kvheader_;
}
 ::cockroach::proto::KVResponseHeader* IncrementResponse::release_kvheader() {
  clear_has_kvheader();
  ::cockroach::proto::KVResponseHeader* temp = kvheader_;
  kvheader_ = NULL;
  return temp;
}
 void IncrementResponse::set_allocated_kvheader(::cockroach::proto::KVResponseHeader* kvheader) {
  delete kvheader_;
  kvheader_ = kvheader;
  if (kvheader) {
    set_has_kvheader();
  } else {
    clear_has_kvheader();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.IncrementResponse.kvheader)
}

// optional int64 new_value = 2;
bool IncrementResponse::has_new_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void IncrementResponse::set_has_new_value() {
  _has_bits_[0] |= 0x00000002u;
}
void IncrementResponse::clear_has_new_value() {
  _has_bits_[0] &= ~0x00000002u;
}
void IncrementResponse::clear_new_value() {
  new_value_ = GOOGLE_LONGLONG(0);
  clear_has_new_value();
}
 ::google::protobuf::int64 IncrementResponse::new_value() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.IncrementResponse.new_value)
  return new_value_;
}
 void IncrementResponse::set_new_value(::google::protobuf::int64 value) {
  set_has_new_value();
  new_value_ = value;
  // @@protoc_insertion_point(field_set:cockroach.proto.IncrementResponse.new_value)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#ifndef _MSC_VER
const int DeleteRequest::kKvheaderFieldNumber;
#endif  // !_MSC_VER

DeleteRequest::DeleteRequest()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:cockroach.proto.DeleteRequest)
}

void DeleteRequest::InitAsDefaultInstance() {
  kvheader_ = const_cast< ::cockroach::proto::KVRequestHeader*>(&::cockroach::proto::KVRequestHeader::default_instance());
}

DeleteRequest::DeleteRequest(const DeleteRequest& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:cockroach.proto.DeleteRequest)
}

void DeleteRequest::SharedCtor() {
  _cached_size_ = 0;
  kvheader_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

DeleteRequest::~DeleteRequest() {
  // @@protoc_insertion_point(destructor:cockroach.proto.DeleteRequest)
  SharedDtor();
}

void DeleteRequest::SharedDtor() {
  if (this != default_instance_) {
    delete kvheader_;
  }
}

void DeleteRequest::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* DeleteRequest::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return DeleteRequest_descriptor_;
}

const DeleteRequest& DeleteRequest::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_cockroach_2fproto_2fapi_2eproto();
  return *default_instance_;
}

DeleteRequest* DeleteRequest::default_instance_ = NULL;

DeleteRequest* DeleteRequest::New(::google::protobuf::Arena* arena) const {
  DeleteRequest* n = new DeleteRequest;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void DeleteRequest::Clear() {
  if (has_kvheader()) {
    if (kvheader_ != NULL) kvheader_->::cockroach::proto::KVRequestHeader::Clear();
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool DeleteRequest::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:cockroach.proto.DeleteRequest)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .cockroach.proto.KVRequestHeader kvheader = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_kvheader()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:cockroach.proto.DeleteRequest)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:cockroach.proto.DeleteRequest)
  return false;
#undef DO_
}

void DeleteRequest::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:cockroach.proto.DeleteRequest)
  // optional .cockroach.proto.KVRequestHeader kvheader = 1;
  if (has_kvheader()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->kvheader_, output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:cockroach.proto.DeleteRequest)
}

::google::protobuf::uint8* DeleteRequest::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:cockroach.proto.DeleteRequest)
  // optional .cockroach.proto.KVRequestHeader kvheader = 1;
  if (has_kvheader()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, *this->kvheader_, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:cockroach.proto.DeleteRequest)
  return target;
}

int DeleteRequest::ByteSize() const {
  int total_size = 0;

  // optional .cockroach.proto.KVRequestHeader kvheader = 1;
  if (has_kvheader()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->kvheader_);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void DeleteRequest::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const DeleteRequest* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const DeleteRequest>(
          &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void DeleteRequest::MergeFrom(const DeleteRequest& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_kvheader()) {
      mutable_kvheader()->::cockroach::proto::KVRequestHeader::MergeFrom(from.kvheader());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void DeleteRequest::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void DeleteRequest::CopyFrom(const DeleteRequest& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DeleteRequest::IsInitialized() const {

  return true;
}

void DeleteRequest::Swap(DeleteRequest* other) {
  if (other == this) return;
  InternalSwap(other);
}
void DeleteRequest::InternalSwap(DeleteRequest* other) {
  std::swap(kvheader_, other->kvheader_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata DeleteRequest::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = DeleteRequest_descriptor_;
  metadata.reflection = DeleteRequest_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// DeleteRequest

// optional .cockroach.proto.KVRequestHeader kvheader = 1;
bool DeleteRequest::has_kvheader() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void DeleteRequest::set_has_kvheader() {
  _has_bits_[0] |= 0x00000001u;
}
void DeleteRequest::clear_has_kvheader() {
  _has_bits_[0] &= ~0x00000001u;
}
void DeleteRequest::clear_kvheader() {
  if (kvheader_ != NULL) kvheader_->::cockroach::proto::KVRequestHeader::Clear();
  clear_has_kvheader();
}
 const ::cockroach::proto::KVRequestHeader& DeleteRequest::kvheader() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.DeleteRequest.kvheader)
  return kvheader_ != NULL ? *kvheader_ : *default_instance_->kvheader_;
}
 ::cockroach::proto::KVRequestHeader* DeleteRequest::mutable_kvheader() {
  set_has_kvheader();
  if (kvheader_ == NULL) {
    kvheader_ = new ::cockroach::proto::KVRequestHeader;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.proto.DeleteRequest.kvheader)
  return kvheader_;
}
 ::cockroach::proto::KVRequestHeader* DeleteRequest::release_kvheader() {
  clear_has_kvheader();
  ::cockroach::proto::KVRequestHeader* temp = kvheader_;
  kvheader_ = NULL;
  return temp;
}
 void DeleteRequest::set_allocated_kvheader(::cockroach::proto::KVRequestHeader* kvheader) {
  delete kvheader_;
  kvheader_ = kvheader;
  if (kvheader) {
    set_has_kvheader();
  } else {
    clear_has_kvheader();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.DeleteRequest.kvheader)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#ifndef _MSC_VER
const int DeleteResponse::kKvheaderFieldNumber;
#endif  // !_MSC_VER

DeleteResponse::DeleteResponse()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:cockroach.proto.DeleteResponse)
}

void DeleteResponse::InitAsDefaultInstance() {
  kvheader_ = const_cast< ::cockroach::proto::KVResponseHeader*>(&::cockroach::proto::KVResponseHeader::default_instance());
}

DeleteResponse::DeleteResponse(const DeleteResponse& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:cockroach.proto.DeleteResponse)
}

void DeleteResponse::SharedCtor() {
  _cached_size_ = 0;
  kvheader_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

DeleteResponse::~DeleteResponse() {
  // @@protoc_insertion_point(destructor:cockroach.proto.DeleteResponse)
  SharedDtor();
}

void DeleteResponse::SharedDtor() {
  if (this != default_instance_) {
    delete kvheader_;
  }
}

void DeleteResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* DeleteResponse::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return DeleteResponse_descriptor_;
}

const DeleteResponse& DeleteResponse::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_cockroach_2fproto_2fapi_2eproto();
  return *default_instance_;
}

DeleteResponse* DeleteResponse::default_instance_ = NULL;

DeleteResponse* DeleteResponse::New(::google::protobuf::Arena* arena) const {
  DeleteResponse* n = new DeleteResponse;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void DeleteResponse::Clear() {
  if (has_kvheader()) {
    if (kvheader_ != NULL) kvheader_->::cockroach::proto::KVResponseHeader::Clear();
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool DeleteResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:cockroach.proto.DeleteResponse)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .cockroach.proto.KVResponseHeader kvheader = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_kvheader()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:cockroach.proto.DeleteResponse)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:cockroach.proto.DeleteResponse)
  return false;
#undef DO_
}

void DeleteResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:cockroach.proto.DeleteResponse)
  // optional .cockroach.proto.KVResponseHeader kvheader = 1;
  if (has_kvheader()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->kvheader_, output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:cockroach.proto.DeleteResponse)
}

::google::protobuf::uint8* DeleteResponse::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:cockroach.proto.DeleteResponse)
  // optional .cockroach.proto.KVResponseHeader kvheader = 1;
  if (has_kvheader()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, *this->kvheader_, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:cockroach.proto.DeleteResponse)
  return target;
}

int DeleteResponse::ByteSize() const {
  int total_size = 0;

  // optional .cockroach.proto.KVResponseHeader kvheader = 1;
  if (has_kvheader()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->kvheader_);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void DeleteResponse::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const DeleteResponse* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const DeleteResponse>(
          &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void DeleteResponse::MergeFrom(const DeleteResponse& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_kvheader()) {
      mutable_kvheader()->::cockroach::proto::KVResponseHeader::MergeFrom(from.kvheader());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void DeleteResponse::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void DeleteResponse::CopyFrom(const DeleteResponse& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DeleteResponse::IsInitialized() const {

  return true;
}

void DeleteResponse::Swap(DeleteResponse* other) {
  if (other == this) return;
  InternalSwap(other);
}
void DeleteResponse::InternalSwap(DeleteResponse* other) {
  std::swap(kvheader_, other->kvheader_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata DeleteResponse::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = DeleteResponse_descriptor_;
  metadata.reflection = DeleteResponse_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// DeleteResponse

// optional .cockroach.proto.KVResponseHeader kvheader = 1;
bool DeleteResponse::has_kvheader() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void DeleteResponse::set_has_kvheader() {
  _has_bits_[0] |= 0x00000001u;
}
void DeleteResponse::clear_has_kvheader() {
  _has_bits_[0] &= ~0x00000001u;
}
void DeleteResponse::clear_kvheader() {
  if (kvheader_ != NULL) kvheader_->::cockroach::proto::KVResponseHeader::Clear();
  clear_has_kvheader();
}
 const ::cockroach::proto::KVResponseHeader& DeleteResponse::kvheader() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.DeleteResponse.kvheader)
  return kvheader_ != NULL ? *kvheader_ : *default_instance_->kvheader_;
}
 ::cockroach::proto::KVResponseHeader* DeleteResponse::mutable_kvheader() {
  set_has_kvheader();
  if (kvheader_ == NULL) {
    kvheader_ = new ::cockroach::proto::KVResponseHeader;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.proto.DeleteResponse.kvheader)
  return kvheader_;
}
 ::cockroach::proto::KVResponseHeader* DeleteResponse::release_kvheader() {
  clear_has_kvheader();
  ::cockroach::proto::KVResponseHeader* temp = kvheader_;
  kvheader_ = NULL;
  return temp;
}
 void DeleteResponse::set_allocated_kvheader(::cockroach::proto::KVResponseHeader* kvheader) {
  delete kvheader_;
  kvheader_ = kvheader;
  if (kvheader) {
    set_has_kvheader();
  } else {
    clear_has_kvheader();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.DeleteResponse.kvheader)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#ifndef _MSC_VER
const int DeleteRangeRequest::kKvheaderFieldNumber;
const int DeleteRangeRequest::kMaxEntriesToDeleteFieldNumber;
#endif  // !_MSC_VER

DeleteRangeRequest::DeleteRangeRequest()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:cockroach.proto.DeleteRangeRequest)
}

void DeleteRangeRequest::InitAsDefaultInstance() {
  kvheader_ = const_cast< ::cockroach::proto::KVRequestHeader*>(&::cockroach::proto::KVRequestHeader::default_instance());
}

DeleteRangeRequest::DeleteRangeRequest(const DeleteRangeRequest& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:cockroach.proto.DeleteRangeRequest)
}

void DeleteRangeRequest::SharedCtor() {
  _cached_size_ = 0;
  kvheader_ = NULL;
  max_entries_to_delete_ = GOOGLE_LONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

DeleteRangeRequest::~DeleteRangeRequest() {
  // @@protoc_insertion_point(destructor:cockroach.proto.DeleteRangeRequest)
  SharedDtor();
}

void DeleteRangeRequest::SharedDtor() {
  if (this != default_instance_) {
    delete kvheader_;
  }
}

void DeleteRangeRequest::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* DeleteRangeRequest::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return DeleteRangeRequest_descriptor_;
}

const DeleteRangeRequest& DeleteRangeRequest::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_cockroach_2fproto_2fapi_2eproto();
  return *default_instance_;
}

DeleteRangeRequest* DeleteRangeRequest::default_instance_ = NULL;

DeleteRangeRequest* DeleteRangeRequest::New(::google::protobuf::Arena* arena) const {
  DeleteRangeRequest* n = new DeleteRangeRequest;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void DeleteRangeRequest::Clear() {
  if (_has_bits_[0 / 32] & 3u) {
    if (has_kvheader()) {
      if (kvheader_ != NULL) kvheader_->::cockroach::proto::KVRequestHeader::Clear();
    }
    max_entries_to_delete_ = GOOGLE_LONGLONG(0);
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool DeleteRangeRequest::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:cockroach.proto.DeleteRangeRequest)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .cockroach.proto.KVRequestHeader kvheader = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_kvheader()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_max_entries_to_delete;
        break;
      }

      // optional int64 max_entries_to_delete = 2;
      case 2: {
        if (tag == 16) {
         parse_max_entries_to_delete:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &max_entries_to_delete_)));
          set_has_max_entries_to_delete();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:cockroach.proto.DeleteRangeRequest)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:cockroach.proto.DeleteRangeRequest)
  return false;
#undef DO_
}

void DeleteRangeRequest::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:cockroach.proto.DeleteRangeRequest)
  // optional .cockroach.proto.KVRequestHeader kvheader = 1;
  if (has_kvheader()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->kvheader_, output);
  }

  // optional int64 max_entries_to_delete = 2;
  if (has_max_entries_to_delete()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(2, this->max_entries_to_delete(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:cockroach.proto.DeleteRangeRequest)
}

::google::protobuf::uint8* DeleteRangeRequest::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:cockroach.proto.DeleteRangeRequest)
  // optional .cockroach.proto.KVRequestHeader kvheader = 1;
  if (has_kvheader()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, *this->kvheader_, target);
  }

  // optional int64 max_entries_to_delete = 2;
  if (has_max_entries_to_delete()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(2, this->max_entries_to_delete(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:cockroach.proto.DeleteRangeRequest)
  return target;
}

int DeleteRangeRequest::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & 3) {
    // optional .cockroach.proto.KVRequestHeader kvheader = 1;
    if (has_kvheader()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->kvheader_);
    }

    // optional int64 max_entries_to_delete = 2;
    if (has_max_entries_to_delete()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->max_entries_to_delete());
    }

  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void DeleteRangeRequest::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const DeleteRangeRequest* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const DeleteRangeRequest>(
          &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void DeleteRangeRequest::MergeFrom(const DeleteRangeRequest& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_kvheader()) {
      mutable_kvheader()->::cockroach::proto::KVRequestHeader::MergeFrom(from.kvheader());
    }
    if (from.has_max_entries_to_delete()) {
      set_max_entries_to_delete(from.max_entries_to_delete());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void DeleteRangeRequest::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void DeleteRangeRequest::CopyFrom(const DeleteRangeRequest& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DeleteRangeRequest::IsInitialized() const {

  return true;
}

void DeleteRangeRequest::Swap(DeleteRangeRequest* other) {
  if (other == this) return;
  InternalSwap(other);
}
void DeleteRangeRequest::InternalSwap(DeleteRangeRequest* other) {
  std::swap(kvheader_, other->kvheader_);
  std::swap(max_entries_to_delete_, other->max_entries_to_delete_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata DeleteRangeRequest::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = DeleteRangeRequest_descriptor_;
  metadata.reflection = DeleteRangeRequest_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// DeleteRangeRequest

// optional .cockroach.proto.KVRequestHeader kvheader = 1;
bool DeleteRangeRequest::has_kvheader() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void DeleteRangeRequest::set_has_kvheader() {
  _has_bits_[0] |= 0x00000001u;
}
void DeleteRangeRequest::clear_has_kvheader() {
  _has_bits_[0] &= ~0x00000001u;
}
void DeleteRangeRequest::clear_kvheader() {
  if (kvheader_ != NULL) kvheader_->::cockroach::proto::KVRequestHeader::Clear();
  clear_has_kvheader();
}
 const ::cockroach::proto::KVRequestHeader& DeleteRangeRequest::kvheader() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.DeleteRangeRequest.kvheader)
  return kvheader_ != NULL ? *kvheader_ : *default_instance_->kvheader_;
}
 ::cockroach::proto::KVRequestHeader* DeleteRangeRequest::mutable_kvheader() {
  set_has_kvheader();
  if (kvheader_ == NULL) {
    kvheader_ = new ::cockroach::proto::KVRequestHeader;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.proto.DeleteRangeRequest.kvheader)
  return kvheader_;
}
 ::cockroach::proto::KVRequestHeader* DeleteRangeRequest::release_kvheader() {
  clear_has_kvheader();
  ::cockroach::proto::KVRequestHeader* temp = kvheader_;
  kvheader_ = NULL;
  return temp;
}
 void DeleteRangeRequest::set_allocated_kvheader(::cockroach::proto::KVRequestHeader* kvheader) {
  delete kvheader_;
  kvheader_ = kvheader;
  if (kvheader) {
    set_has_kvheader();
  } else {
    clear_has_kvheader();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.DeleteRangeRequest.kvheader)
}

// optional int64 max_entries_to_delete = 2;
bool DeleteRangeRequest::has_max_entries_to_delete() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void DeleteRangeRequest::set_has_max_entries_to_delete() {
  _has_bits_[0] |= 0x00000002u;
}
void DeleteRangeRequest::clear_has_max_entries_to_delete() {
  _has_bits_[0] &= ~0x00000002u;
}
void DeleteRangeRequest::clear_max_entries_to_delete() {
  max_entries_to_delete_ = GOOGLE_LONGLONG(0);
  clear_has_max_entries_to_delete();
}
 ::google::protobuf::int64 DeleteRangeRequest::max_entries_to_delete() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.DeleteRangeRequest.max_entries_to_delete)
  return max_entries_to_delete_;
}
 void DeleteRangeRequest::set_max_entries_to_delete(::google::protobuf::int64 value) {
  set_has_max_entries_to_delete();
  max_entries_to_delete_ = value;
  // @@protoc_insertion_point(field_set:cockroach.proto.DeleteRangeRequest.max_entries_to_delete)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#ifndef _MSC_VER
const int DeleteRangeResponse::kKvheaderFieldNumber;
const int DeleteRangeResponse::kNumDeletedFieldNumber;
#endif  // !_MSC_VER

DeleteRangeResponse::DeleteRangeResponse()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:cockroach.proto.DeleteRangeResponse)
}

void DeleteRangeResponse::InitAsDefaultInstance() {
  kvheader_ = const_cast< ::cockroach::proto::KVResponseHeader*>(&::cockroach::proto::KVResponseHeader::default_instance());
}

DeleteRangeResponse::DeleteRangeResponse(const DeleteRangeResponse& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:cockroach.proto.DeleteRangeResponse)
}

void DeleteRangeResponse::SharedCtor() {
  _cached_size_ = 0;
  kvheader_ = NULL;
  num_deleted_ = GOOGLE_LONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

DeleteRangeResponse::~DeleteRangeResponse() {
  // @@protoc_insertion_point(destructor:cockroach.proto.DeleteRangeResponse)
  SharedDtor();
}

void DeleteRangeResponse::SharedDtor() {
  if (this != default_instance_) {
    delete kvheader_;
  }
}

void DeleteRangeResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* DeleteRangeResponse::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return DeleteRangeResponse_descriptor_;
}

const DeleteRangeResponse& DeleteRangeResponse::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_cockroach_2fproto_2fapi_2eproto();
  return *default_instance_;
}

DeleteRangeResponse* DeleteRangeResponse::default_instance_ = NULL;

DeleteRangeResponse* DeleteRangeResponse::New(::google::protobuf::Arena* arena) const {
  DeleteRangeResponse* n = new DeleteRangeResponse;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void DeleteRangeResponse::Clear() {
  if (_has_bits_[0 / 32] & 3u) {
    if (has_kvheader()) {
      if (kvheader_ != NULL) kvheader_->::cockroach::proto::KVResponseHeader::Clear();
    }
    num_deleted_ = GOOGLE_LONGLONG(0);
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool DeleteRangeResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:cockroach.proto.DeleteRangeResponse)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .cockroach.proto.KVResponseHeader kvheader = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_kvheader()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_num_deleted;
        break;
      }

      // optional int64 num_deleted = 2;
      case 2: {
        if (tag == 16) {
         parse_num_deleted:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &num_deleted_)));
          set_has_num_deleted();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:cockroach.proto.DeleteRangeResponse)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:cockroach.proto.DeleteRangeResponse)
  return false;
#undef DO_
}

void DeleteRangeResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:cockroach.proto.DeleteRangeResponse)
  // optional .cockroach.proto.KVResponseHeader kvheader = 1;
  if (has_kvheader()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->kvheader_, output);
  }

  // optional int64 num_deleted = 2;
  if (has_num_deleted()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(2, this->num_deleted(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:cockroach.proto.DeleteRangeResponse)
}

::google::protobuf::uint8* DeleteRangeResponse::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:cockroach.proto.DeleteRangeResponse)
  // optional .cockroach.proto.KVResponseHeader kvheader = 1;
  if (has_kvheader()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, *this->kvheader_, target);
  }

  // optional int64 num_deleted = 2;
  if (has_num_deleted()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(2, this->num_deleted(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:cockroach.proto.DeleteRangeResponse)
  return target;
}

int DeleteRangeResponse::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & 3) {
    // optional .cockroach.proto.KVResponseHeader kvheader = 1;
    if (has_kvheader()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->kvheader_);
    }

    // optional int64 num_deleted = 2;
    if (has_num_deleted()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->num_deleted());
    }

  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void DeleteRangeResponse::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const DeleteRangeResponse* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const DeleteRangeResponse>(
          &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void DeleteRangeResponse::MergeFrom(const DeleteRangeResponse& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_kvheader()) {
      mutable_kvheader()->::cockroach::proto::KVResponseHeader::MergeFrom(from.kvheader());
    }
    if (from.has_num_deleted()) {
      set_num_deleted(from.num_deleted());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void DeleteRangeResponse::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void DeleteRangeResponse::CopyFrom(const DeleteRangeResponse& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DeleteRangeResponse::IsInitialized() const {

  return true;
}

void DeleteRangeResponse::Swap(DeleteRangeResponse* other) {
  if (other == this) return;
  InternalSwap(other);
}
void DeleteRangeResponse::InternalSwap(DeleteRangeResponse* other) {
  std::swap(kvheader_, other->kvheader_);
  std::swap(num_deleted_, other->num_deleted_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata DeleteRangeResponse::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = DeleteRangeResponse_descriptor_;
  metadata.reflection = DeleteRangeResponse_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// DeleteRangeResponse

// optional .cockroach.proto.KVResponseHeader kvheader = 1;
bool DeleteRangeResponse::has_kvheader() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void DeleteRangeResponse::set_has_kvheader() {
  _has_bits_[0] |= 0x00000001u;
}
void DeleteRangeResponse::clear_has_kvheader() {
  _has_bits_[0] &= ~0x00000001u;
}
void DeleteRangeResponse::clear_kvheader() {
  if (kvheader_ != NULL) kvheader_->::cockroach::proto::KVResponseHeader::Clear();
  clear_has_kvheader();
}
 const ::cockroach::proto::KVResponseHeader& DeleteRangeResponse::kvheader() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.DeleteRangeResponse.kvheader)
  return kvheader_ != NULL ? *kvheader_ : *default_instance_->kvheader_;
}
 ::cockroach::proto::KVResponseHeader* DeleteRangeResponse::mutable_kvheader() {
  set_has_kvheader();
  if (kvheader_ == NULL) {
    kvheader_ = new ::cockroach::proto::KVResponseHeader;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.proto.DeleteRangeResponse.kvheader)
  return kvheader_;
}
 ::cockroach::proto::KVResponseHeader* DeleteRangeResponse::release_kvheader() {
  clear_has_kvheader();
  ::cockroach::proto::KVResponseHeader* temp = kvheader_;
  kvheader_ = NULL;
  return temp;
}
 void DeleteRangeResponse::set_allocated_kvheader(::cockroach::proto::KVResponseHeader* kvheader) {
  delete kvheader_;
  kvheader_ = kvheader;
  if (kvheader) {
    set_has_kvheader();
  } else {
    clear_has_kvheader();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.DeleteRangeResponse.kvheader)
}

// optional int64 num_deleted = 2;
bool DeleteRangeResponse::has_num_deleted() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void DeleteRangeResponse::set_has_num_deleted() {
  _has_bits_[0] |= 0x00000002u;
}
void DeleteRangeResponse::clear_has_num_deleted() {
  _has_bits_[0] &= ~0x00000002u;
}
void DeleteRangeResponse::clear_num_deleted() {
  num_deleted_ = GOOGLE_LONGLONG(0);
  clear_has_num_deleted();
}
 ::google::protobuf::int64 DeleteRangeResponse::num_deleted() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.DeleteRangeResponse.num_deleted)
  return num_deleted_;
}
 void DeleteRangeResponse::set_num_deleted(::google::protobuf::int64 value) {
  set_has_num_deleted();
  num_deleted_ = value;
  // @@protoc_insertion_point(field_set:cockroach.proto.DeleteRangeResponse.num_deleted)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#ifndef _MSC_VER
const int ScanRequest::kKvheaderFieldNumber;
const int ScanRequest::kMaxResultsFieldNumber;
#endif  // !_MSC_VER

ScanRequest::ScanRequest()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:cockroach.proto.ScanRequest)
}

void ScanRequest::InitAsDefaultInstance() {
  kvheader_ = const_cast< ::cockroach::proto::KVRequestHeader*>(&::cockroach::proto::KVRequestHeader::default_instance());
}

ScanRequest::ScanRequest(const ScanRequest& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:cockroach.proto.ScanRequest)
}

void ScanRequest::SharedCtor() {
  _cached_size_ = 0;
  kvheader_ = NULL;
  max_results_ = GOOGLE_LONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ScanRequest::~ScanRequest() {
  // @@protoc_insertion_point(destructor:cockroach.proto.ScanRequest)
  SharedDtor();
}

void ScanRequest::SharedDtor() {
  if (this != default_instance_) {
    delete kvheader_;
  }
}

void ScanRequest::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ScanRequest::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ScanRequest_descriptor_;
}

const ScanRequest& ScanRequest::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_cockroach_2fproto_2fapi_2eproto();
  return *default_instance_;
}

ScanRequest* ScanRequest::default_instance_ = NULL;

ScanRequest* ScanRequest::New(::google::protobuf::Arena* arena) const {
  ScanRequest* n = new ScanRequest;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void ScanRequest::Clear() {
  if (_has_bits_[0 / 32] & 3u) {
    if (has_kvheader()) {
      if (kvheader_ != NULL) kvheader_->::cockroach::proto::KVRequestHeader::Clear();
    }
    max_results_ = GOOGLE_LONGLONG(0);
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool ScanRequest::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:cockroach.proto.ScanRequest)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .cockroach.proto.KVRequestHeader kvheader = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_kvheader()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_max_results;
        break;
      }

      // optional int64 max_results = 2;
      case 2: {
        if (tag == 16) {
         parse_max_results:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &max_results_)));
          set_has_max_results();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:cockroach.proto.ScanRequest)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:cockroach.proto.ScanRequest)
  return false;
#undef DO_
}

void ScanRequest::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:cockroach.proto.ScanRequest)
  // optional .cockroach.proto.KVRequestHeader kvheader = 1;
  if (has_kvheader()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->kvheader_, output);
  }

  // optional int64 max_results = 2;
  if (has_max_results()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(2, this->max_results(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:cockroach.proto.ScanRequest)
}

::google::protobuf::uint8* ScanRequest::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:cockroach.proto.ScanRequest)
  // optional .cockroach.proto.KVRequestHeader kvheader = 1;
  if (has_kvheader()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, *this->kvheader_, target);
  }

  // optional int64 max_results = 2;
  if (has_max_results()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(2, this->max_results(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:cockroach.proto.ScanRequest)
  return target;
}

int ScanRequest::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & 3) {
    // optional .cockroach.proto.KVRequestHeader kvheader = 1;
    if (has_kvheader()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->kvheader_);
    }

    // optional int64 max_results = 2;
    if (has_max_results()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->max_results());
    }

  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ScanRequest::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const ScanRequest* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const ScanRequest>(
          &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ScanRequest::MergeFrom(const ScanRequest& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_kvheader()) {
      mutable_kvheader()->::cockroach::proto::KVRequestHeader::MergeFrom(from.kvheader());
    }
    if (from.has_max_results()) {
      set_max_results(from.max_results());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void ScanRequest::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ScanRequest::CopyFrom(const ScanRequest& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ScanRequest::IsInitialized() const {

  return true;
}

void ScanRequest::Swap(ScanRequest* other) {
  if (other == this) return;
  InternalSwap(other);
}
void ScanRequest::InternalSwap(ScanRequest* other) {
  std::swap(kvheader_, other->kvheader_);
  std::swap(max_results_, other->max_results_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata ScanRequest::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ScanRequest_descriptor_;
  metadata.reflection = ScanRequest_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// ScanRequest

// optional .cockroach.proto.KVRequestHeader kvheader = 1;
bool ScanRequest::has_kvheader() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void ScanRequest::set_has_kvheader() {
  _has_bits_[0] |= 0x00000001u;
}
void ScanRequest::clear_has_kvheader() {
  _has_bits_[0] &= ~0x00000001u;
}
void ScanRequest::clear_kvheader() {
  if (kvheader_ != NULL) kvheader_->::cockroach::proto::KVRequestHeader::Clear();
  clear_has_kvheader();
}
 const ::cockroach::proto::KVRequestHeader& ScanRequest::kvheader() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.ScanRequest.kvheader)
  return kvheader_ != NULL ? *kvheader_ : *default_instance_->kvheader_;
}
 ::cockroach::proto::KVRequestHeader* ScanRequest::mutable_kvheader() {
  set_has_kvheader();
  if (kvheader_ == NULL) {
    kvheader_ = new ::cockroach::proto::KVRequestHeader;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.proto.ScanRequest.kvheader)
  return kvheader_;
}
 ::cockroach::proto::KVRequestHeader* ScanRequest::release_kvheader() {
  clear_has_kvheader();
  ::cockroach::proto::KVRequestHeader* temp = kvheader_;
  kvheader_ = NULL;
  return temp;
}
 void ScanRequest::set_allocated_kvheader(::cockroach::proto::KVRequestHeader* kvheader) {
  delete kvheader_;
  kvheader_ = kvheader;
  if (kvheader) {
    set_has_kvheader();
  } else {
    clear_has_kvheader();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.ScanRequest.kvheader)
}

// optional int64 max_results = 2;
bool ScanRequest::has_max_results() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void ScanRequest::set_has_max_results() {
  _has_bits_[0] |= 0x00000002u;
}
void ScanRequest::clear_has_max_results() {
  _has_bits_[0] &= ~0x00000002u;
}
void ScanRequest::clear_max_results() {
  max_results_ = GOOGLE_LONGLONG(0);
  clear_has_max_results();
}
 ::google::protobuf::int64 ScanRequest::max_results() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.ScanRequest.max_results)
  return max_results_;
}
 void ScanRequest::set_max_results(::google::protobuf::int64 value) {
  set_has_max_results();
  max_results_ = value;
  // @@protoc_insertion_point(field_set:cockroach.proto.ScanRequest.max_results)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#ifndef _MSC_VER
const int ScanResponse::kKvheaderFieldNumber;
const int ScanResponse::kRowsFieldNumber;
#endif  // !_MSC_VER

ScanResponse::ScanResponse()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:cockroach.proto.ScanResponse)
}

void ScanResponse::InitAsDefaultInstance() {
  kvheader_ = const_cast< ::cockroach::proto::KVResponseHeader*>(&::cockroach::proto::KVResponseHeader::default_instance());
}

ScanResponse::ScanResponse(const ScanResponse& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:cockroach.proto.ScanResponse)
}

void ScanResponse::SharedCtor() {
  _cached_size_ = 0;
  kvheader_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ScanResponse::~ScanResponse() {
  // @@protoc_insertion_point(destructor:cockroach.proto.ScanResponse)
  SharedDtor();
}

void ScanResponse::SharedDtor() {
  if (this != default_instance_) {
    delete kvheader_;
  }
}

void ScanResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ScanResponse::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ScanResponse_descriptor_;
}

const ScanResponse& ScanResponse::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_cockroach_2fproto_2fapi_2eproto();
  return *default_instance_;
}

ScanResponse* ScanResponse::default_instance_ = NULL;

ScanResponse* ScanResponse::New(::google::protobuf::Arena* arena) const {
  ScanResponse* n = new ScanResponse;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void ScanResponse::Clear() {
  if (has_kvheader()) {
    if (kvheader_ != NULL) kvheader_->::cockroach::proto::KVResponseHeader::Clear();
  }
  rows_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool ScanResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:cockroach.proto.ScanResponse)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .cockroach.proto.KVResponseHeader kvheader = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_kvheader()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_rows;
        break;
      }

      // repeated .cockroach.proto.KeyValue rows = 2;
      case 2: {
        if (tag == 18) {
         parse_rows:
          DO_(input->IncrementRecursionDepth());
         parse_loop_rows:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                input, add_rows()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_loop_rows;
        input->UnsafeDecrementRecursionDepth();
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:cockroach.proto.ScanResponse)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:cockroach.proto.ScanResponse)
  return false;
#undef DO_
}

void ScanResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:cockroach.proto.ScanResponse)
  // optional .cockroach.proto.KVResponseHeader kvheader = 1;
  if (has_kvheader()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->kvheader_, output);
  }

  // repeated .cockroach.proto.KeyValue rows = 2;
  for (unsigned int i = 0, n = this->rows_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->rows(i), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:cockroach.proto.ScanResponse)
}

::google::protobuf::uint8* ScanResponse::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:cockroach.proto.ScanResponse)
  // optional .cockroach.proto.KVResponseHeader kvheader = 1;
  if (has_kvheader()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, *this->kvheader_, target);
  }

  // repeated .cockroach.proto.KeyValue rows = 2;
  for (unsigned int i = 0, n = this->rows_size(); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->rows(i), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:cockroach.proto.ScanResponse)
  return target;
}

int ScanResponse::ByteSize() const {
  int total_size = 0;

  // optional .cockroach.proto.KVResponseHeader kvheader = 1;
  if (has_kvheader()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->kvheader_);
  }

  // repeated .cockroach.proto.KeyValue rows = 2;
  total_size += 1 * this->rows_size();
  for (int i = 0; i < this->rows_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->rows(i));
  }

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ScanResponse::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const ScanResponse* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const ScanResponse>(
          &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ScanResponse::MergeFrom(const ScanResponse& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  rows_.MergeFrom(from.rows_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_kvheader()) {
      mutable_kvheader()->::cockroach::proto::KVResponseHeader::MergeFrom(from.kvheader());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void ScanResponse::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ScanResponse::CopyFrom(const ScanResponse& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ScanResponse::IsInitialized() const {

  return true;
}

void ScanResponse::Swap(ScanResponse* other) {
  if (other == this) return;
  InternalSwap(other);
}
void ScanResponse::InternalSwap(ScanResponse* other) {
  std::swap(kvheader_, other->kvheader_);
  rows_.UnsafeArenaSwap(&other->rows_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata ScanResponse::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ScanResponse_descriptor_;
  metadata.reflection = ScanResponse_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// ScanResponse

// optional .cockroach.proto.KVResponseHeader kvheader = 1;
bool ScanResponse::has_kvheader() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void ScanResponse::set_has_kvheader() {
  _has_bits_[0] |= 0x00000001u;
}
void ScanResponse::clear_has_kvheader() {
  _has_bits_[0] &= ~0x00000001u;
}
void ScanResponse::clear_kvheader() {
  if (kvheader_ != NULL) kvheader_->::cockroach::proto::KVResponseHeader::Clear();
  clear_has_kvheader();
}
 const ::cockroach::proto::KVResponseHeader& ScanResponse::kvheader() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.ScanResponse.kvheader)
  return kvheader_ != NULL ? *kvheader_ : *default_instance_->kvheader_;
}
 ::cockroach::proto::KVResponseHeader* ScanResponse::mutable_kvheader() {
  set_has_kvheader();
  if (kvheader_ == NULL) {
    kvheader_ = new ::cockroach::proto::KVResponseHeader;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.proto.ScanResponse.kvheader)
  return kvheader_;
}
 ::cockroach::proto::KVResponseHeader* ScanResponse::release_kvheader() {
  clear_has_kvheader();
  ::cockroach::proto::KVResponseHeader* temp = kvheader_;
  kvheader_ = NULL;
  return temp;
}
 void ScanResponse::set_allocated_kvheader(::cockroach::proto::KVResponseHeader* kvheader) {
  delete kvheader_;
  kvheader_ = kvheader;
  if (kvheader) {
    set_has_kvheader();
  } else {
    clear_has_kvheader();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.ScanResponse.kvheader)
}

// repeated .cockroach.proto.KeyValue rows = 2;
int ScanResponse::rows_size() const {
  return rows_.size();
}
void ScanResponse::clear_rows() {
  rows_.Clear();
}
 const ::cockroach::proto::KeyValue& ScanResponse::rows(int index) const {
  // @@protoc_insertion_point(field_get:cockroach.proto.ScanResponse.rows)
  return rows_.Get(index);
}
 ::cockroach::proto::KeyValue* ScanResponse::mutable_rows(int index) {
  // @@protoc_insertion_point(field_mutable:cockroach.proto.ScanResponse.rows)
  return rows_.Mutable(index);
}
 ::cockroach::proto::KeyValue* ScanResponse::add_rows() {
  // @@protoc_insertion_point(field_add:cockroach.proto.ScanResponse.rows)
  return rows_.Add();
}
 const ::google::protobuf::RepeatedPtrField< ::cockroach::proto::KeyValue >&
ScanResponse::rows() const {
  // @@protoc_insertion_point(field_list:cockroach.proto.ScanResponse.rows)
  return rows_;
}
 ::google::protobuf::RepeatedPtrField< ::cockroach::proto::KeyValue >*
ScanResponse::mutable_rows() {
  // @@protoc_insertion_point(field_mutable_list:cockroach.proto.ScanResponse.rows)
  return &rows_;
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#ifndef _MSC_VER
const int EndTransactionRequest::kKvheaderFieldNumber;
const int EndTransactionRequest::kCommitFieldNumber;
const int EndTransactionRequest::kInternalCommitTriggerFieldNumber;
#endif  // !_MSC_VER

EndTransactionRequest::EndTransactionRequest()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:cockroach.proto.EndTransactionRequest)
}

void EndTransactionRequest::InitAsDefaultInstance() {
  kvheader_ = const_cast< ::cockroach::proto::KVRequestHeader*>(&::cockroach::proto::KVRequestHeader::default_instance());
  internal_commit_trigger_ = const_cast< ::cockroach::proto::InternalCommitTrigger*>(&::cockroach::proto::InternalCommitTrigger::default_instance());
}

EndTransactionRequest::EndTransactionRequest(const EndTransactionRequest& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:cockroach.proto.EndTransactionRequest)
}

void EndTransactionRequest::SharedCtor() {
  _cached_size_ = 0;
  kvheader_ = NULL;
  commit_ = false;
  internal_commit_trigger_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

EndTransactionRequest::~EndTransactionRequest() {
  // @@protoc_insertion_point(destructor:cockroach.proto.EndTransactionRequest)
  SharedDtor();
}

void EndTransactionRequest::SharedDtor() {
  if (this != default_instance_) {
    delete kvheader_;
    delete internal_commit_trigger_;
  }
}

void EndTransactionRequest::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* EndTransactionRequest::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return EndTransactionRequest_descriptor_;
}

const EndTransactionRequest& EndTransactionRequest::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_cockroach_2fproto_2fapi_2eproto();
  return *default_instance_;
}

EndTransactionRequest* EndTransactionRequest::default_instance_ = NULL;

EndTransactionRequest* EndTransactionRequest::New(::google::protobuf::Arena* arena) const {
  EndTransactionRequest* n = new EndTransactionRequest;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void EndTransactionRequest::Clear() {
  if (_has_bits_[0 / 32] & 7u) {
    if (has_kvheader()) {
      if (kvheader_ != NULL) kvheader_->::cockroach::proto::KVRequestHeader::Clear();
    }
    commit_ = false;
    if (has_internal_commit_trigger()) {
      if (internal_commit_trigger_ != NULL) internal_commit_trigger_->::cockroach::proto::InternalCommitTrigger::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool EndTransactionRequest::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:cockroach.proto.EndTransactionRequest)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .cockroach.proto.KVRequestHeader kvheader = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_kvheader()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_commit;
        break;
      }

      // optional bool commit = 2;
      case 2: {
        if (tag == 16) {
         parse_commit:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &commit_)));
          set_has_commit();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_internal_commit_trigger;
        break;
      }

      // optional .cockroach.proto.InternalCommitTrigger internal_commit_trigger = 3;
      case 3: {
        if (tag == 26) {
         parse_internal_commit_trigger:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_internal_commit_trigger()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:cockroach.proto.EndTransactionRequest)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:cockroach.proto.EndTransactionRequest)
  return false;
#undef DO_
}

void EndTransactionRequest::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:cockroach.proto.EndTransactionRequest)
  // optional .cockroach.proto.KVRequestHeader kvheader = 1;
  if (has_kvheader()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->kvheader_, output);
  }

  // optional bool commit = 2;
  if (has_commit()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(2, this->commit(), output);
  }

  // optional .cockroach.proto.InternalCommitTrigger internal_commit_trigger = 3;
  if (has_internal_commit_trigger()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, *this->internal_commit_trigger_, output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:cockroach.proto.EndTransactionRequest)
}

::google::protobuf::uint8* EndTransactionRequest::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:cockroach.proto.EndTransactionRequest)
  // optional .cockroach.proto.KVRequestHeader kvheader = 1;
  if (has_kvheader()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, *this->kvheader_, target);
  }

  // optional bool commit = 2;
  if (has_commit()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(2, this->commit(), target);
  }

  // optional .cockroach.proto.InternalCommitTrigger internal_commit_trigger = 3;
  if (has_internal_commit_trigger()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, *this->internal_commit_trigger_, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:cockroach.proto.EndTransactionRequest)
  return target;
}

int EndTransactionRequest::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & 7) {
    // optional .cockroach.proto.KVRequestHeader kvheader = 1;
    if (has_kvheader()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->kvheader_);
    }

    // optional bool commit = 2;
    if (has_commit()) {
      total_size += 1 + 1;
    }

    // optional .cockroach.proto.InternalCommitTrigger internal_commit_trigger = 3;
    if (has_internal_commit_trigger()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->internal_commit_trigger_);
    }

  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void EndTransactionRequest::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const EndTransactionRequest* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const EndTransactionRequest>(
          &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void EndTransactionRequest::MergeFrom(const EndTransactionRequest& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_kvheader()) {
      mutable_kvheader()->::cockroach::proto::KVRequestHeader::MergeFrom(from.kvheader());
    }
    if (from.has_commit()) {
      set_commit(from.commit());
    }
    if (from.has_internal_commit_trigger()) {
      mutable_internal_commit_trigger()->::cockroach::proto::InternalCommitTrigger::MergeFrom(from.internal_commit_trigger());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void EndTransactionRequest::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void EndTransactionRequest::CopyFrom(const EndTransactionRequest& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EndTransactionRequest::IsInitialized() const {

  return true;
}

void EndTransactionRequest::Swap(EndTransactionRequest* other) {
  if (other == this) return;
  InternalSwap(other);
}
void EndTransactionRequest::InternalSwap(EndTransactionRequest* other) {
  std::swap(kvheader_, other->kvheader_);
  std::swap(commit_, other->commit_);
  std::swap(internal_commit_trigger_, other->internal_commit_trigger_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata EndTransactionRequest::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = EndTransactionRequest_descriptor_;
  metadata.reflection = EndTransactionRequest_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// EndTransactionRequest

// optional .cockroach.proto.KVRequestHeader kvheader = 1;
bool EndTransactionRequest::has_kvheader() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void EndTransactionRequest::set_has_kvheader() {
  _has_bits_[0] |= 0x00000001u;
}
void EndTransactionRequest::clear_has_kvheader() {
  _has_bits_[0] &= ~0x00000001u;
}
void EndTransactionRequest::clear_kvheader() {
  if (kvheader_ != NULL) kvheader_->::cockroach::proto::KVRequestHeader::Clear();
  clear_has_kvheader();
}
 const ::cockroach::proto::KVRequestHeader& EndTransactionRequest::kvheader() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.EndTransactionRequest.kvheader)
  return kvheader_ != NULL ? *kvheader_ : *default_instance_->kvheader_;
}
 ::cockroach::proto::KVRequestHeader* EndTransactionRequest::mutable_kvheader() {
  set_has_kvheader();
  if (kvheader_ == NULL) {
    kvheader_ = new ::cockroach::proto::KVRequestHeader;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.proto.EndTransactionRequest.kvheader)
  return kvheader_;
}
 ::cockroach::proto::KVRequestHeader* EndTransactionRequest::release_kvheader() {
  clear_has_kvheader();
  ::cockroach::proto::KVRequestHeader* temp = kvheader_;
  kvheader_ = NULL;
  return temp;
}
 void EndTransactionRequest::set_allocated_kvheader(::cockroach::proto::KVRequestHeader* kvheader) {
  delete kvheader_;
  kvheader_ = kvheader;
  if (kvheader) {
    set_has_kvheader();
  } else {
    clear_has_kvheader();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.EndTransactionRequest.kvheader)
}

// optional bool commit = 2;
bool EndTransactionRequest::has_commit() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void EndTransactionRequest::set_has_commit() {
  _has_bits_[0] |= 0x00000002u;
}
void EndTransactionRequest::clear_has_commit() {
  _has_bits_[0] &= ~0x00000002u;
}
void EndTransactionRequest::clear_commit() {
  commit_ = false;
  clear_has_commit();
}
 bool EndTransactionRequest::commit() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.EndTransactionRequest.commit)
  return commit_;
}
 void EndTransactionRequest::set_commit(bool value) {
  set_has_commit();
  commit_ = value;
  // @@protoc_insertion_point(field_set:cockroach.proto.EndTransactionRequest.commit)
}

// optional .cockroach.proto.InternalCommitTrigger internal_commit_trigger = 3;
bool EndTransactionRequest::has_internal_commit_trigger() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void EndTransactionRequest::set_has_internal_commit_trigger() {
  _has_bits_[0] |= 0x00000004u;
}
void EndTransactionRequest::clear_has_internal_commit_trigger() {
  _has_bits_[0] &= ~0x00000004u;
}
void EndTransactionRequest::clear_internal_commit_trigger() {
  if (internal_commit_trigger_ != NULL) internal_commit_trigger_->::cockroach::proto::InternalCommitTrigger::Clear();
  clear_has_internal_commit_trigger();
}
 const ::cockroach::proto::InternalCommitTrigger& EndTransactionRequest::internal_commit_trigger() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.EndTransactionRequest.internal_commit_trigger)
  return internal_commit_trigger_ != NULL ? *internal_commit_trigger_ : *default_instance_->internal_commit_trigger_;
}
 ::cockroach::proto::InternalCommitTrigger* EndTransactionRequest::mutable_internal_commit_trigger() {
  set_has_internal_commit_trigger();
  if (internal_commit_trigger_ == NULL) {
    internal_commit_trigger_ = new ::cockroach::proto::InternalCommitTrigger;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.proto.EndTransactionRequest.internal_commit_trigger)
  return internal_commit_trigger_;
}
 ::cockroach::proto::InternalCommitTrigger* EndTransactionRequest::release_internal_commit_trigger() {
  clear_has_internal_commit_trigger();
  ::cockroach::proto::InternalCommitTrigger* temp = internal_commit_trigger_;
  internal_commit_trigger_ = NULL;
  return temp;
}
 void EndTransactionRequest::set_allocated_internal_commit_trigger(::cockroach::proto::InternalCommitTrigger* internal_commit_trigger) {
  delete internal_commit_trigger_;
  internal_commit_trigger_ = internal_commit_trigger;
  if (internal_commit_trigger) {
    set_has_internal_commit_trigger();
  } else {
    clear_has_internal_commit_trigger();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.EndTransactionRequest.internal_commit_trigger)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#ifndef _MSC_VER
const int EndTransactionResponse::kKvheaderFieldNumber;
const int EndTransactionResponse::kCommitWaitFieldNumber;
const int EndTransactionResponse::kResolvedFieldNumber;
#endif  // !_MSC_VER

EndTransactionResponse::EndTransactionResponse()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:cockroach.proto.EndTransactionResponse)
}

void EndTransactionResponse::InitAsDefaultInstance() {
  kvheader_ = const_cast< ::cockroach::proto::KVResponseHeader*>(&::cockroach::proto::KVResponseHeader::default_instance());
}

EndTransactionResponse::EndTransactionResponse(const EndTransactionResponse& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:cockroach.proto.EndTransactionResponse)
}

void EndTransactionResponse::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  kvheader_ = NULL;
  commit_wait_ = GOOGLE_LONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

EndTransactionResponse::~EndTransactionResponse() {
  // @@protoc_insertion_point(destructor:cockroach.proto.EndTransactionResponse)
  SharedDtor();
}

void EndTransactionResponse::SharedDtor() {
  if (this != default_instance_) {
    delete kvheader_;
  }
}

void EndTransactionResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* EndTransactionResponse::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return EndTransactionResponse_descriptor_;
}

const EndTransactionResponse& EndTransactionResponse::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_cockroach_2fproto_2fapi_2eproto();
  return *default_instance_;
}

EndTransactionResponse* EndTransactionResponse::default_instance_ = NULL;

EndTransactionResponse* EndTransactionResponse::New(::google::protobuf::Arena* arena) const {
  EndTransactionResponse* n = new EndTransactionResponse;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void EndTransactionResponse::Clear() {
  if (_has_bits_[0 / 32] & 3u) {
    if (has_kvheader()) {
      if (kvheader_ != NULL) kvheader_->::cockroach::proto::KVResponseHeader::Clear();
    }
    commit_wait_ = GOOGLE_LONGLONG(0);
  }
  resolved_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool EndTransactionResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:cockroach.proto.EndTransactionResponse)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .cockroach.proto.KVResponseHeader kvheader = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_kvheader()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_commit_wait;
        break;
      }

      // optional int64 commit_wait = 2;
      case 2: {
        if (tag == 16) {
         parse_commit_wait:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &commit_wait_)));
          set_has_commit_wait();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_resolved;
        break;
      }

      // repeated bytes resolved = 3;
      case 3: {
        if (tag == 26) {
         parse_resolved:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->add_resolved()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_resolved;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:cockroach.proto.EndTransactionResponse)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:cockroach.proto.EndTransactionResponse)
  return false;
#undef DO_
}

void EndTransactionResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:cockroach.proto.EndTransactionResponse)
  // optional .cockroach.proto.KVResponseHeader kvheader = 1;
  if (has_kvheader()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->kvheader_, output);
  }

  // optional int64 commit_wait = 2;
  if (has_commit_wait()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(2, this->commit_wait(), output);
  }

  // repeated bytes resolved = 3;
  for (int i = 0; i < this->resolved_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      3, this->resolved(i), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:cockroach.proto.EndTransactionResponse)
}

::google::protobuf::uint8* EndTransactionResponse::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:cockroach.proto.EndTransactionResponse)
  // optional .cockroach.proto.KVResponseHeader kvheader = 1;
  if (has_kvheader()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, *this->kvheader_, target);
  }

  // optional int64 commit_wait = 2;
  if (has_commit_wait()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(2, this->commit_wait(), target);
  }

  // repeated bytes resolved = 3;
  for (int i = 0; i < this->resolved_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteBytesToArray(3, this->resolved(i), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:cockroach.proto.EndTransactionResponse)
  return target;
}

int EndTransactionResponse::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & 3) {
    // optional .cockroach.proto.KVResponseHeader kvheader = 1;
    if (has_kvheader()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->kvheader_);
    }

    // optional int64 commit_wait = 2;
    if (has_commit_wait()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->commit_wait());
    }

  }
  // repeated bytes resolved = 3;
  total_size += 1 * this->resolved_size();
  for (int i = 0; i < this->resolved_size(); i++) {
    total_size += ::google::protobuf::internal::WireFormatLite::BytesSize(
      this->resolved(i));
  }

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void EndTransactionResponse::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const EndTransactionResponse* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const EndTransactionResponse>(
          &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void EndTransactionResponse::MergeFrom(const EndTransactionResponse& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  resolved_.MergeFrom(from.resolved_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_kvheader()) {
      mutable_kvheader()->::cockroach::proto::KVResponseHeader::MergeFrom(from.kvheader());
    }
    if (from.has_commit_wait()) {
      set_commit_wait(from.commit_wait());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void EndTransactionResponse::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void EndTransactionResponse::CopyFrom(const EndTransactionResponse& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EndTransactionResponse::IsInitialized() const {

  return true;
}

void EndTransactionResponse::Swap(EndTransactionResponse* other) {
  if (other == this) return;
  InternalSwap(other);
}
void EndTransactionResponse::InternalSwap(EndTransactionResponse* other) {
  std::swap(kvheader_, other->kvheader_);
  std::swap(commit_wait_, other->commit_wait_);
  resolved_.UnsafeArenaSwap(&other->resolved_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata EndTransactionResponse::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = EndTransactionResponse_descriptor_;
  metadata.reflection = EndTransactionResponse_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// EndTransactionResponse

// optional .cockroach.proto.KVResponseHeader kvheader = 1;
bool EndTransactionResponse::has_kvheader() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void EndTransactionResponse::set_has_kvheader() {
  _has_bits_[0] |= 0x00000001u;
}
void EndTransactionResponse::clear_has_kvheader() {
  _has_bits_[0] &= ~0x00000001u;
}
void EndTransactionResponse::clear_kvheader() {
  if (kvheader_ != NULL) kvheader_->::cockroach::proto::KVResponseHeader::Clear();
  clear_has_kvheader();
}
 const ::cockroach::proto::KVResponseHeader& EndTransactionResponse::kvheader() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.EndTransactionResponse.kvheader)
  return kvheader_ != NULL ? *kvheader_ : *default_instance_->kvheader_;
}
 ::cockroach::proto::KVResponseHeader* EndTransactionResponse::mutable_kvheader() {
  set_has_kvheader();
  if (kvheader_ == NULL) {
    kvheader_ = new ::cockroach::proto::KVResponseHeader;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.proto.EndTransactionResponse.kvheader)
  return kvheader_;
}
 ::cockroach::proto::KVResponseHeader* EndTransactionResponse::release_kvheader() {
  clear_has_kvheader();
  ::cockroach::proto::KVResponseHeader* temp = kvheader_;
  kvheader_ = NULL;
  return temp;
}
 void EndTransactionResponse::set_allocated_kvheader(::cockroach::proto::KVResponseHeader* kvheader) {
  delete kvheader_;
  kvheader_ = kvheader;
  if (kvheader) {
    set_has_kvheader();
  } else {
    clear_has_kvheader();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.EndTransactionResponse.kvheader)
}

// optional int64 commit_wait = 2;
bool EndTransactionResponse::has_commit_wait() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void EndTransactionResponse::set_has_commit_wait() {
  _has_bits_[0] |= 0x00000002u;
}
void EndTransactionResponse::clear_has_commit_wait() {
  _has_bits_[0] &= ~0x00000002u;
}
void EndTransactionResponse::clear_commit_wait() {
  commit_wait_ = GOOGLE_LONGLONG(0);
  clear_has_commit_wait();
}
 ::google::protobuf::int64 EndTransactionResponse::commit_wait() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.EndTransactionResponse.commit_wait)
  return commit_wait_;
}
 void EndTransactionResponse::set_commit_wait(::google::protobuf::int64 value) {
  set_has_commit_wait();
  commit_wait_ = value;
  // @@protoc_insertion_point(field_set:cockroach.proto.EndTransactionResponse.commit_wait)
}

// repeated bytes resolved = 3;
int EndTransactionResponse::resolved_size() const {
  return resolved_.size();
}
void EndTransactionResponse::clear_resolved() {
  resolved_.Clear();
}
 const ::std::string& EndTransactionResponse::resolved(int index) const {
  // @@protoc_insertion_point(field_get:cockroach.proto.EndTransactionResponse.resolved)
  return resolved_.Get(index);
}
 ::std::string* EndTransactionResponse::mutable_resolved(int index) {
  // @@protoc_insertion_point(field_mutable:cockroach.proto.EndTransactionResponse.resolved)
  return resolved_.Mutable(index);
}
 void EndTransactionResponse::set_resolved(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:cockroach.proto.EndTransactionResponse.resolved)
  resolved_.Mutable(index)->assign(value);
}
 void EndTransactionResponse::set_resolved(int index, const char* value) {
  resolved_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:cockroach.proto.EndTransactionResponse.resolved)
}
 void EndTransactionResponse::set_resolved(int index, const void* value, size_t size) {
  resolved_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:cockroach.proto.EndTransactionResponse.resolved)
}
 ::std::string* EndTransactionResponse::add_resolved() {
  return resolved_.Add();
}
 void EndTransactionResponse::add_resolved(const ::std::string& value) {
  resolved_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:cockroach.proto.EndTransactionResponse.resolved)
}
 void EndTransactionResponse::add_resolved(const char* value) {
  resolved_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:cockroach.proto.EndTransactionResponse.resolved)
}
 void EndTransactionResponse::add_resolved(const void* value, size_t size) {
  resolved_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:cockroach.proto.EndTransactionResponse.resolved)
}
 const ::google::protobuf::RepeatedPtrField< ::std::string>&
EndTransactionResponse::resolved() const {
  // @@protoc_insertion_point(field_list:cockroach.proto.EndTransactionResponse.resolved)
  return resolved_;
}
 ::google::protobuf::RepeatedPtrField< ::std::string>*
EndTransactionResponse::mutable_resolved() {
  // @@protoc_insertion_point(field_mutable_list:cockroach.proto.EndTransactionResponse.resolved)
  return &resolved_;
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#ifndef _MSC_VER
const int RequestUnion::kGetFieldNumber;
const int RequestUnion::kPutFieldNumber;
const int RequestUnion::kConditionalPutFieldNumber;
const int RequestUnion::kIncrementFieldNumber;
const int RequestUnion::kDeleteFieldNumber;
const int RequestUnion::kDeleteRangeFieldNumber;
const int RequestUnion::kScanFieldNumber;
const int RequestUnion::kEndTransactionFieldNumber;
#endif  // !_MSC_VER

RequestUnion::RequestUnion()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:cockroach.proto.RequestUnion)
}

void RequestUnion::InitAsDefaultInstance() {
  RequestUnion_default_oneof_instance_->get_ = const_cast< ::cockroach::proto::GetRequest*>(&::cockroach::proto::GetRequest::default_instance());
  RequestUnion_default_oneof_instance_->put_ = const_cast< ::cockroach::proto::PutRequest*>(&::cockroach::proto::PutRequest::default_instance());
  RequestUnion_default_oneof_instance_->conditional_put_ = const_cast< ::cockroach::proto::ConditionalPutRequest*>(&::cockroach::proto::ConditionalPutRequest::default_instance());
  RequestUnion_default_oneof_instance_->increment_ = const_cast< ::cockroach::proto::IncrementRequest*>(&::cockroach::proto::IncrementRequest::default_instance());
  RequestUnion_default_oneof_instance_->delete__ = const_cast< ::cockroach::proto::DeleteRequest*>(&::cockroach::proto::DeleteRequest::default_instance());
  RequestUnion_default_oneof_instance_->delete_range_ = const_cast< ::cockroach::proto::DeleteRangeRequest*>(&::cockroach::proto::DeleteRangeRequest::default_instance());
  RequestUnion_default_oneof_instance_->scan_ = const_cast< ::cockroach::proto::ScanRequest*>(&::cockroach::proto::ScanRequest::default_instance());
  RequestUnion_default_oneof_instance_->end_transaction_ = const_cast< ::cockroach::proto::EndTransactionRequest*>(&::cockroach::proto::EndTransactionRequest::default_instance());
}

RequestUnion::RequestUnion(const RequestUnion& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:cockroach.proto.RequestUnion)
}

void RequestUnion::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  clear_has_value();
}

RequestUnion::~RequestUnion() {
  // @@protoc_insertion_point(destructor:cockroach.proto.RequestUnion)
  SharedDtor();
}

void RequestUnion::SharedDtor() {
  if (has_value()) {
    clear_value();
  }
  if (this != default_instance_) {
  }
}

void RequestUnion::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* RequestUnion::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return RequestUnion_descriptor_;
}

const RequestUnion& RequestUnion::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_cockroach_2fproto_2fapi_2eproto();
  return *default_instance_;
}

RequestUnion* RequestUnion::default_instance_ = NULL;

RequestUnion* RequestUnion::New(::google::protobuf::Arena* arena) const {
  RequestUnion* n = new RequestUnion;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void RequestUnion::clear_value() {
  switch(value_case()) {
    case kGet: {
      delete value_.get_;
      break;
    }
    case kPut: {
      delete value_.put_;
      break;
    }
    case kConditionalPut: {
      delete value_.conditional_put_;
      break;
    }
    case kIncrement: {
      delete value_.increment_;
      break;
    }
    case kDelete: {
      delete value_.delete__;
      break;
    }
    case kDeleteRange: {
      delete value_.delete_range_;
      break;
    }
    case kScan: {
      delete value_.scan_;
      break;
    }
    case kEndTransaction: {
      delete value_.end_transaction_;
      break;
    }
    case VALUE_NOT_SET: {
      break;
    }
  }
  _oneof_case_[0] = VALUE_NOT_SET;
}


void RequestUnion::Clear() {
  clear_value();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool RequestUnion::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:cockroach.proto.RequestUnion)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .cockroach.proto.GetRequest get = 2;
      case 2: {
        if (tag == 18) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_get()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_put;
        break;
      }

      // optional .cockroach.proto.PutRequest put = 3;
      case 3: {
        if (tag == 26) {
         parse_put:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_put()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_conditional_put;
        break;
      }

      // optional .cockroach.proto.ConditionalPutRequest conditional_put = 4;
      case 4: {
        if (tag == 34) {
         parse_conditional_put:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_conditional_put()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_increment;
        break;
      }

      // optional .cockroach.proto.IncrementRequest increment = 5;
      case 5: {
        if (tag == 42) {
         parse_increment:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_increment()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(50)) goto parse_delete;
        break;
      }

      // optional .cockroach.proto.DeleteRequest delete = 6;
      case 6: {
        if (tag == 50) {
         parse_delete:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_delete_()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(58)) goto parse_delete_range;
        break;
      }

      // optional .cockroach.proto.DeleteRangeRequest delete_range = 7;
      case 7: {
        if (tag == 58) {
         parse_delete_range:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_delete_range()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(66)) goto parse_scan;
        break;
      }

      // optional .cockroach.proto.ScanRequest scan = 8;
      case 8: {
        if (tag == 66) {
         parse_scan:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_scan()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(74)) goto parse_end_transaction;
        break;
      }

      // optional .cockroach.proto.EndTransactionRequest end_transaction = 9;
      case 9: {
        if (tag == 74) {
         parse_end_transaction:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_end_transaction()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:cockroach.proto.RequestUnion)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:cockroach.proto.RequestUnion)
  return false;
#undef DO_
}

void RequestUnion::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:cockroach.proto.RequestUnion)
  // optional .cockroach.proto.GetRequest get = 2;
  if (has_get()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, *value_.get_, output);
  }

  // optional .cockroach.proto.PutRequest put = 3;
  if (has_put()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, *value_.put_, output);
  }

  // optional .cockroach.proto.ConditionalPutRequest conditional_put = 4;
  if (has_conditional_put()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, *value_.conditional_put_, output);
  }

  // optional .cockroach.proto.IncrementRequest increment = 5;
  if (has_increment()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      5, *value_.increment_, output);
  }

  // optional .cockroach.proto.DeleteRequest delete = 6;
  if (has_delete_()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      6, *value_.delete__, output);
  }

  // optional .cockroach.proto.DeleteRangeRequest delete_range = 7;
  if (has_delete_range()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      7, *value_.delete_range_, output);
  }

  // optional .cockroach.proto.ScanRequest scan = 8;
  if (has_scan()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      8, *value_.scan_, output);
  }

  // optional .cockroach.proto.EndTransactionRequest end_transaction = 9;
  if (has_end_transaction()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      9, *value_.end_transaction_, output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:cockroach.proto.RequestUnion)
}

::google::protobuf::uint8* RequestUnion::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:cockroach.proto.RequestUnion)
  // optional .cockroach.proto.GetRequest get = 2;
  if (has_get()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, *value_.get_, target);
  }

  // optional .cockroach.proto.PutRequest put = 3;
  if (has_put()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, *value_.put_, target);
  }

  // optional .cockroach.proto.ConditionalPutRequest conditional_put = 4;
  if (has_conditional_put()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        4, *value_.conditional_put_, target);
  }

  // optional .cockroach.proto.IncrementRequest increment = 5;
  if (has_increment()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        5, *value_.increment_, target);
  }

  // optional .cockroach.proto.DeleteRequest delete = 6;
  if (has_delete_()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        6, *value_.delete__, target);
  }

  // optional .cockroach.proto.DeleteRangeRequest delete_range = 7;
  if (has_delete_range()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        7, *value_.delete_range_, target);
  }

  // optional .cockroach.proto.ScanRequest scan = 8;
  if (has_scan()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        8, *value_.scan_, target);
  }

  // optional .cockroach.proto.EndTransactionRequest end_transaction = 9;
  if (has_end_transaction()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        9, *value_.end_transaction_, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:cockroach.proto.RequestUnion)
  return target;
}

int RequestUnion::ByteSize() const {
  int total_size = 0;

  switch (value_case()) {
    // optional .cockroach.proto.GetRequest get = 2;
    case kGet: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *value_.get_);
      break;
    }
    // optional .cockroach.proto.PutRequest put = 3;
    case kPut: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *value_.put_);
      break;
    }
    // optional .cockroach.proto.ConditionalPutRequest conditional_put = 4;
    case kConditionalPut: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *value_.conditional_put_);
      break;
    }
    // optional .cockroach.proto.IncrementRequest increment = 5;
    case kIncrement: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *value_.increment_);
      break;
    }
    // optional .cockroach.proto.DeleteRequest delete = 6;
    case kDelete: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *value_.delete__);
      break;
    }
    // optional .cockroach.proto.DeleteRangeRequest delete_range = 7;
    case kDeleteRange: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *value_.delete_range_);
      break;
    }
    // optional .cockroach.proto.ScanRequest scan = 8;
    case kScan: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *value_.scan_);
      break;
    }
    // optional .cockroach.proto.EndTransactionRequest end_transaction = 9;
    case kEndTransaction: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *value_.end_transaction_);
      break;
    }
    case VALUE_NOT_SET: {
      break;
    }
  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RequestUnion::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const RequestUnion* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const RequestUnion>(
          &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void RequestUnion::MergeFrom(const RequestUnion& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  switch (from.value_case()) {
    case kGet: {
      mutable_get()->::cockroach::proto::GetRequest::MergeFrom(from.get());
      break;
    }
    case kPut: {
      mutable_put()->::cockroach::proto::PutRequest::MergeFrom(from.put());
      break;
    }
    case kConditionalPut: {
      mutable_conditional_put()->::cockroach::proto::ConditionalPutRequest::MergeFrom(from.conditional_put());
      break;
    }
    case kIncrement: {
      mutable_increment()->::cockroach::proto::IncrementRequest::MergeFrom(from.increment());
      break;
    }
    case kDelete: {
      mutable_delete_()->::cockroach::proto::DeleteRequest::MergeFrom(from.delete_());
      break;
    }
    case kDeleteRange: {
      mutable_delete_range()->::cockroach::proto::DeleteRangeRequest::MergeFrom(from.delete_range());
      break;
    }
    case kScan: {
      mutable_scan()->::cockroach::proto::ScanRequest::MergeFrom(from.scan());
      break;
    }
    case kEndTransaction: {
      mutable_end_transaction()->::cockroach::proto::EndTransactionRequest::MergeFrom(from.end_transaction());
      break;
    }
    case VALUE_NOT_SET: {
      break;
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void RequestUnion::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void RequestUnion::CopyFrom(const RequestUnion& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RequestUnion::IsInitialized() const {

  return true;
}

void RequestUnion::Swap(RequestUnion* other) {
  if (other == this) return;
  InternalSwap(other);
}
void RequestUnion::InternalSwap(RequestUnion* other) {
  std::swap(value_, other->value_);
  std::swap(_oneof_case_[0], other->_oneof_case_[0]);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata RequestUnion::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = RequestUnion_descriptor_;
  metadata.reflection = RequestUnion_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// RequestUnion

// optional .cockroach.proto.GetRequest get = 2;
bool RequestUnion::has_get() const {
  return value_case() == kGet;
}
void RequestUnion::set_has_get() {
  _oneof_case_[0] = kGet;
}
void RequestUnion::clear_get() {
  if (has_get()) {
    delete value_.get_;
    clear_has_value();
  }
}
 const ::cockroach::proto::GetRequest& RequestUnion::get() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.RequestUnion.get)
  return has_get() ? *value_.get_
                      : ::cockroach::proto::GetRequest::default_instance();
}
 ::cockroach::proto::GetRequest* RequestUnion::mutable_get() {
  if (!has_get()) {
    clear_value();
    set_has_get();
    value_.get_ = new ::cockroach::proto::GetRequest;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.proto.RequestUnion.get)
  return value_.get_;
}
 ::cockroach::proto::GetRequest* RequestUnion::release_get() {
  if (has_get()) {
    clear_has_value();
    ::cockroach::proto::GetRequest* temp = value_.get_;
    value_.get_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
 void RequestUnion::set_allocated_get(::cockroach::proto::GetRequest* get) {
  clear_value();
  if (get) {
    set_has_get();
    value_.get_ = get;
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.RequestUnion.get)
}

// optional .cockroach.proto.PutRequest put = 3;
bool RequestUnion::has_put() const {
  return value_case() == kPut;
}
void RequestUnion::set_has_put() {
  _oneof_case_[0] = kPut;
}
void RequestUnion::clear_put() {
  if (has_put()) {
    delete value_.put_;
    clear_has_value();
  }
}
 const ::cockroach::proto::PutRequest& RequestUnion::put() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.RequestUnion.put)
  return has_put() ? *value_.put_
                      : ::cockroach::proto::PutRequest::default_instance();
}
 ::cockroach::proto::PutRequest* RequestUnion::mutable_put() {
  if (!has_put()) {
    clear_value();
    set_has_put();
    value_.put_ = new ::cockroach::proto::PutRequest;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.proto.RequestUnion.put)
  return value_.put_;
}
 ::cockroach::proto::PutRequest* RequestUnion::release_put() {
  if (has_put()) {
    clear_has_value();
    ::cockroach::proto::PutRequest* temp = value_.put_;
    value_.put_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
 void RequestUnion::set_allocated_put(::cockroach::proto::PutRequest* put) {
  clear_value();
  if (put) {
    set_has_put();
    value_.put_ = put;
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.RequestUnion.put)
}

// optional .cockroach.proto.ConditionalPutRequest conditional_put = 4;
bool RequestUnion::has_conditional_put() const {
  return value_case() == kConditionalPut;
}
void RequestUnion::set_has_conditional_put() {
  _oneof_case_[0] = kConditionalPut;
}
void RequestUnion::clear_conditional_put() {
  if (has_conditional_put()) {
    delete value_.conditional_put_;
    clear_has_value();
  }
}
 const ::cockroach::proto::ConditionalPutRequest& RequestUnion::conditional_put() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.RequestUnion.conditional_put)
  return has_conditional_put() ? *value_.conditional_put_
                      : ::cockroach::proto::ConditionalPutRequest::default_instance();
}
 ::cockroach::proto::ConditionalPutRequest* RequestUnion::mutable_conditional_put() {
  if (!has_conditional_put()) {
    clear_value();
    set_has_conditional_put();
    value_.conditional_put_ = new ::cockroach::proto::ConditionalPutRequest;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.proto.RequestUnion.conditional_put)
  return value_.conditional_put_;
}
 ::cockroach::proto::ConditionalPutRequest* RequestUnion::release_conditional_put() {
  if (has_conditional_put()) {
    clear_has_value();
    ::cockroach::proto::ConditionalPutRequest* temp = value_.conditional_put_;
    value_.conditional_put_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
 void RequestUnion::set_allocated_conditional_put(::cockroach::proto::ConditionalPutRequest* conditional_put) {
  clear_value();
  if (conditional_put) {
    set_has_conditional_put();
    value_.conditional_put_ = conditional_put;
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.RequestUnion.conditional_put)
}

// optional .cockroach.proto.IncrementRequest increment = 5;
bool RequestUnion::has_increment() const {
  return value_case() == kIncrement;
}
void RequestUnion::set_has_increment() {
  _oneof_case_[0] = kIncrement;
}
void RequestUnion::clear_increment() {
  if (has_increment()) {
    delete value_.increment_;
    clear_has_value();
  }
}
 const ::cockroach::proto::IncrementRequest& RequestUnion::increment() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.RequestUnion.increment)
  return has_increment() ? *value_.increment_
                      : ::cockroach::proto::IncrementRequest::default_instance();
}
 ::cockroach::proto::IncrementRequest* RequestUnion::mutable_increment() {
  if (!has_increment()) {
    clear_value();
    set_has_increment();
    value_.increment_ = new ::cockroach::proto::IncrementRequest;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.proto.RequestUnion.increment)
  return value_.increment_;
}
 ::cockroach::proto::IncrementRequest* RequestUnion::release_increment() {
  if (has_increment()) {
    clear_has_value();
    ::cockroach::proto::IncrementRequest* temp = value_.increment_;
    value_.increment_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
 void RequestUnion::set_allocated_increment(::cockroach::proto::IncrementRequest* increment) {
  clear_value();
  if (increment) {
    set_has_increment();
    value_.increment_ = increment;
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.RequestUnion.increment)
}

// optional .cockroach.proto.DeleteRequest delete = 6;
bool RequestUnion::has_delete_() const {
  return value_case() == kDelete;
}
void RequestUnion::set_has_delete_() {
  _oneof_case_[0] = kDelete;
}
void RequestUnion::clear_delete_() {
  if (has_delete_()) {
    delete value_.delete__;
    clear_has_value();
  }
}
 const ::cockroach::proto::DeleteRequest& RequestUnion::delete_() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.RequestUnion.delete)
  return has_delete_() ? *value_.delete__
                      : ::cockroach::proto::DeleteRequest::default_instance();
}
 ::cockroach::proto::DeleteRequest* RequestUnion::mutable_delete_() {
  if (!has_delete_()) {
    clear_value();
    set_has_delete_();
    value_.delete__ = new ::cockroach::proto::DeleteRequest;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.proto.RequestUnion.delete)
  return value_.delete__;
}
 ::cockroach::proto::DeleteRequest* RequestUnion::release_delete_() {
  if (has_delete_()) {
    clear_has_value();
    ::cockroach::proto::DeleteRequest* temp = value_.delete__;
    value_.delete__ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
 void RequestUnion::set_allocated_delete_(::cockroach::proto::DeleteRequest* delete_) {
  clear_value();
  if (delete_) {
    set_has_delete_();
    value_.delete__ = delete_;
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.RequestUnion.delete)
}

// optional .cockroach.proto.DeleteRangeRequest delete_range = 7;
bool RequestUnion::has_delete_range() const {
  return value_case() == kDeleteRange;
}
void RequestUnion::set_has_delete_range() {
  _oneof_case_[0] = kDeleteRange;
}
void RequestUnion::clear_delete_range() {
  if (has_delete_range()) {
    delete value_.delete_range_;
    clear_has_value();
  }
}
 const ::cockroach::proto::DeleteRangeRequest& RequestUnion::delete_range() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.RequestUnion.delete_range)
  return has_delete_range() ? *value_.delete_range_
                      : ::cockroach::proto::DeleteRangeRequest::default_instance();
}
 ::cockroach::proto::DeleteRangeRequest* RequestUnion::mutable_delete_range() {
  if (!has_delete_range()) {
    clear_value();
    set_has_delete_range();
    value_.delete_range_ = new ::cockroach::proto::DeleteRangeRequest;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.proto.RequestUnion.delete_range)
  return value_.delete_range_;
}
 ::cockroach::proto::DeleteRangeRequest* RequestUnion::release_delete_range() {
  if (has_delete_range()) {
    clear_has_value();
    ::cockroach::proto::DeleteRangeRequest* temp = value_.delete_range_;
    value_.delete_range_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
 void RequestUnion::set_allocated_delete_range(::cockroach::proto::DeleteRangeRequest* delete_range) {
  clear_value();
  if (delete_range) {
    set_has_delete_range();
    value_.delete_range_ = delete_range;
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.RequestUnion.delete_range)
}

// optional .cockroach.proto.ScanRequest scan = 8;
bool RequestUnion::has_scan() const {
  return value_case() == kScan;
}
void RequestUnion::set_has_scan() {
  _oneof_case_[0] = kScan;
}
void RequestUnion::clear_scan() {
  if (has_scan()) {
    delete value_.scan_;
    clear_has_value();
  }
}
 const ::cockroach::proto::ScanRequest& RequestUnion::scan() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.RequestUnion.scan)
  return has_scan() ? *value_.scan_
                      : ::cockroach::proto::ScanRequest::default_instance();
}
 ::cockroach::proto::ScanRequest* RequestUnion::mutable_scan() {
  if (!has_scan()) {
    clear_value();
    set_has_scan();
    value_.scan_ = new ::cockroach::proto::ScanRequest;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.proto.RequestUnion.scan)
  return value_.scan_;
}
 ::cockroach::proto::ScanRequest* RequestUnion::release_scan() {
  if (has_scan()) {
    clear_has_value();
    ::cockroach::proto::ScanRequest* temp = value_.scan_;
    value_.scan_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
 void RequestUnion::set_allocated_scan(::cockroach::proto::ScanRequest* scan) {
  clear_value();
  if (scan) {
    set_has_scan();
    value_.scan_ = scan;
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.RequestUnion.scan)
}

// optional .cockroach.proto.EndTransactionRequest end_transaction = 9;
bool RequestUnion::has_end_transaction() const {
  return value_case() == kEndTransaction;
}
void RequestUnion::set_has_end_transaction() {
  _oneof_case_[0] = kEndTransaction;
}
void RequestUnion::clear_end_transaction() {
  if (has_end_transaction()) {
    delete value_.end_transaction_;
    clear_has_value();
  }
}
 const ::cockroach::proto::EndTransactionRequest& RequestUnion::end_transaction() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.RequestUnion.end_transaction)
  return has_end_transaction() ? *value_.end_transaction_
                      : ::cockroach::proto::EndTransactionRequest::default_instance();
}
 ::cockroach::proto::EndTransactionRequest* RequestUnion::mutable_end_transaction() {
  if (!has_end_transaction()) {
    clear_value();
    set_has_end_transaction();
    value_.end_transaction_ = new ::cockroach::proto::EndTransactionRequest;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.proto.RequestUnion.end_transaction)
  return value_.end_transaction_;
}
 ::cockroach::proto::EndTransactionRequest* RequestUnion::release_end_transaction() {
  if (has_end_transaction()) {
    clear_has_value();
    ::cockroach::proto::EndTransactionRequest* temp = value_.end_transaction_;
    value_.end_transaction_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
 void RequestUnion::set_allocated_end_transaction(::cockroach::proto::EndTransactionRequest* end_transaction) {
  clear_value();
  if (end_transaction) {
    set_has_end_transaction();
    value_.end_transaction_ = end_transaction;
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.RequestUnion.end_transaction)
}

bool RequestUnion::has_value() const {
  return value_case() != VALUE_NOT_SET;
}
void RequestUnion::clear_has_value() {
  _oneof_case_[0] = VALUE_NOT_SET;
}
RequestUnion::ValueCase RequestUnion::value_case() const {
  return RequestUnion::ValueCase(_oneof_case_[0]);
}
#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#ifndef _MSC_VER
const int ResponseUnion::kGetFieldNumber;
const int ResponseUnion::kPutFieldNumber;
const int ResponseUnion::kConditionalPutFieldNumber;
const int ResponseUnion::kIncrementFieldNumber;
const int ResponseUnion::kDeleteFieldNumber;
const int ResponseUnion::kDeleteRangeFieldNumber;
const int ResponseUnion::kScanFieldNumber;
const int ResponseUnion::kEndTransactionFieldNumber;
#endif  // !_MSC_VER

ResponseUnion::ResponseUnion()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:cockroach.proto.ResponseUnion)
}

void ResponseUnion::InitAsDefaultInstance() {
  ResponseUnion_default_oneof_instance_->get_ = const_cast< ::cockroach::proto::GetResponse*>(&::cockroach::proto::GetResponse::default_instance());
  ResponseUnion_default_oneof_instance_->put_ = const_cast< ::cockroach::proto::PutResponse*>(&::cockroach::proto::PutResponse::default_instance());
  ResponseUnion_default_oneof_instance_->conditional_put_ = const_cast< ::cockroach::proto::ConditionalPutResponse*>(&::cockroach::proto::ConditionalPutResponse::default_instance());
  ResponseUnion_default_oneof_instance_->increment_ = const_cast< ::cockroach::proto::IncrementResponse*>(&::cockroach::proto::IncrementResponse::default_instance());
  ResponseUnion_default_oneof_instance_->delete__ = const_cast< ::cockroach::proto::DeleteResponse*>(&::cockroach::proto::DeleteResponse::default_instance());
  ResponseUnion_default_oneof_instance_->delete_range_ = const_cast< ::cockroach::proto::DeleteRangeResponse*>(&::cockroach::proto::DeleteRangeResponse::default_instance());
  ResponseUnion_default_oneof_instance_->scan_ = const_cast< ::cockroach::proto::ScanResponse*>(&::cockroach::proto::ScanResponse::default_instance());
  ResponseUnion_default_oneof_instance_->end_transaction_ = const_cast< ::cockroach::proto::EndTransactionResponse*>(&::cockroach::proto::EndTransactionResponse::default_instance());
}

ResponseUnion::ResponseUnion(const ResponseUnion& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:cockroach.proto.ResponseUnion)
}

void ResponseUnion::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  clear_has_value();
}

ResponseUnion::~ResponseUnion() {
  // @@protoc_insertion_point(destructor:cockroach.proto.ResponseUnion)
  SharedDtor();
}

void ResponseUnion::SharedDtor() {
  if (has_value()) {
    clear_value();
  }
  if (this != default_instance_) {
  }
}

void ResponseUnion::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ResponseUnion::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ResponseUnion_descriptor_;
}

const ResponseUnion& ResponseUnion::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_cockroach_2fproto_2fapi_2eproto();
  return *default_instance_;
}

ResponseUnion* ResponseUnion::default_instance_ = NULL;

ResponseUnion* ResponseUnion::New(::google::protobuf::Arena* arena) const {
  ResponseUnion* n = new ResponseUnion;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void ResponseUnion::clear_value() {
  switch(value_case()) {
    case kGet: {
      delete value_.get_;
      break;
    }
    case kPut: {
      delete value_.put_;
      break;
    }
    case kConditionalPut: {
      delete value_.conditional_put_;
      break;
    }
    case kIncrement: {
      delete value_.increment_;
      break;
    }
    case kDelete: {
      delete value_.delete__;
      break;
    }
    case kDeleteRange: {
      delete value_.delete_range_;
      break;
    }
    case kScan: {
      delete value_.scan_;
      break;
    }
    case kEndTransaction: {
      delete value_.end_transaction_;
      break;
    }
    case VALUE_NOT_SET: {
      break;
    }
  }
  _oneof_case_[0] = VALUE_NOT_SET;
}


void ResponseUnion::Clear() {
  clear_value();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool ResponseUnion::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:cockroach.proto.ResponseUnion)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .cockroach.proto.GetResponse get = 2;
      case 2: {
        if (tag == 18) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_get()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_put;
        break;
      }

      // optional .cockroach.proto.PutResponse put = 3;
      case 3: {
        if (tag == 26) {
         parse_put:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_put()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_conditional_put;
        break;
      }

      // optional .cockroach.proto.ConditionalPutResponse conditional_put = 4;
      case 4: {
        if (tag == 34) {
         parse_conditional_put:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_conditional_put()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_increment;
        break;
      }

      // optional .cockroach.proto.IncrementResponse increment = 5;
      case 5: {
        if (tag == 42) {
         parse_increment:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_increment()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(50)) goto parse_delete;
        break;
      }

      // optional .cockroach.proto.DeleteResponse delete = 6;
      case 6: {
        if (tag == 50) {
         parse_delete:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_delete_()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(58)) goto parse_delete_range;
        break;
      }

      // optional .cockroach.proto.DeleteRangeResponse delete_range = 7;
      case 7: {
        if (tag == 58) {
         parse_delete_range:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_delete_range()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(66)) goto parse_scan;
        break;
      }

      // optional .cockroach.proto.ScanResponse scan = 8;
      case 8: {
        if (tag == 66) {
         parse_scan:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_scan()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(74)) goto parse_end_transaction;
        break;
      }

      // optional .cockroach.proto.EndTransactionResponse end_transaction = 9;
      case 9: {
        if (tag == 74) {
         parse_end_transaction:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_end_transaction()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:cockroach.proto.ResponseUnion)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:cockroach.proto.ResponseUnion)
  return false;
#undef DO_
}

void ResponseUnion::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:cockroach.proto.ResponseUnion)
  // optional .cockroach.proto.GetResponse get = 2;
  if (has_get()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, *value_.get_, output);
  }

  // optional .cockroach.proto.PutResponse put = 3;
  if (has_put()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, *value_.put_, output);
  }

  // optional .cockroach.proto.ConditionalPutResponse conditional_put = 4;
  if (has_conditional_put()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, *value_.conditional_put_, output);
  }

  // optional .cockroach.proto.IncrementResponse increment = 5;
  if (has_increment()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      5, *value_.increment_, output);
  }

  // optional .cockroach.proto.DeleteResponse delete = 6;
  if (has_delete_()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      6, *value_.delete__, output);
  }

  // optional .cockroach.proto.DeleteRangeResponse delete_range = 7;
  if (has_delete_range()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      7, *value_.delete_range_, output);
  }

  // optional .cockroach.proto.ScanResponse scan = 8;
  if (has_scan()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      8, *value_.scan_, output);
  }

  // optional .cockroach.proto.EndTransactionResponse end_transaction = 9;
  if (has_end_transaction()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      9, *value_.end_transaction_, output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:cockroach.proto.ResponseUnion)
}

::google::protobuf::uint8* ResponseUnion::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:cockroach.proto.ResponseUnion)
  // optional .cockroach.proto.GetResponse get = 2;
  if (has_get()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, *value_.get_, target);
  }

  // optional .cockroach.proto.PutResponse put = 3;
  if (has_put()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, *value_.put_, target);
  }

  // optional .cockroach.proto.ConditionalPutResponse conditional_put = 4;
  if (has_conditional_put()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        4, *value_.conditional_put_, target);
  }

  // optional .cockroach.proto.IncrementResponse increment = 5;
  if (has_increment()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        5, *value_.increment_, target);
  }

  // optional .cockroach.proto.DeleteResponse delete = 6;
  if (has_delete_()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        6, *value_.delete__, target);
  }

  // optional .cockroach.proto.DeleteRangeResponse delete_range = 7;
  if (has_delete_range()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        7, *value_.delete_range_, target);
  }

  // optional .cockroach.proto.ScanResponse scan = 8;
  if (has_scan()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        8, *value_.scan_, target);
  }

  // optional .cockroach.proto.EndTransactionResponse end_transaction = 9;
  if (has_end_transaction()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        9, *value_.end_transaction_, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:cockroach.proto.ResponseUnion)
  return target;
}

int ResponseUnion::ByteSize() const {
  int total_size = 0;

  switch (value_case()) {
    // optional .cockroach.proto.GetResponse get = 2;
    case kGet: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *value_.get_);
      break;
    }
    // optional .cockroach.proto.PutResponse put = 3;
    case kPut: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *value_.put_);
      break;
    }
    // optional .cockroach.proto.ConditionalPutResponse conditional_put = 4;
    case kConditionalPut: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *value_.conditional_put_);
      break;
    }
    // optional .cockroach.proto.IncrementResponse increment = 5;
    case kIncrement: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *value_.increment_);
      break;
    }
    // optional .cockroach.proto.DeleteResponse delete = 6;
    case kDelete: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *value_.delete__);
      break;
    }
    // optional .cockroach.proto.DeleteRangeResponse delete_range = 7;
    case kDeleteRange: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *value_.delete_range_);
      break;
    }
    // optional .cockroach.proto.ScanResponse scan = 8;
    case kScan: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *value_.scan_);
      break;
    }
    // optional .cockroach.proto.EndTransactionResponse end_transaction = 9;
    case kEndTransaction: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *value_.end_transaction_);
      break;
    }
    case VALUE_NOT_SET: {
      break;
    }
  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ResponseUnion::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const ResponseUnion* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const ResponseUnion>(
          &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ResponseUnion::MergeFrom(const ResponseUnion& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  switch (from.value_case()) {
    case kGet: {
      mutable_get()->::cockroach::proto::GetResponse::MergeFrom(from.get());
      break;
    }
    case kPut: {
      mutable_put()->::cockroach::proto::PutResponse::MergeFrom(from.put());
      break;
    }
    case kConditionalPut: {
      mutable_conditional_put()->::cockroach::proto::ConditionalPutResponse::MergeFrom(from.conditional_put());
      break;
    }
    case kIncrement: {
      mutable_increment()->::cockroach::proto::IncrementResponse::MergeFrom(from.increment());
      break;
    }
    case kDelete: {
      mutable_delete_()->::cockroach::proto::DeleteResponse::MergeFrom(from.delete_());
      break;
    }
    case kDeleteRange: {
      mutable_delete_range()->::cockroach::proto::DeleteRangeResponse::MergeFrom(from.delete_range());
      break;
    }
    case kScan: {
      mutable_scan()->::cockroach::proto::ScanResponse::MergeFrom(from.scan());
      break;
    }
    case kEndTransaction: {
      mutable_end_transaction()->::cockroach::proto::EndTransactionResponse::MergeFrom(from.end_transaction());
      break;
    }
    case VALUE_NOT_SET: {
      break;
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void ResponseUnion::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ResponseUnion::CopyFrom(const ResponseUnion& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ResponseUnion::IsInitialized() const {

  return true;
}

void ResponseUnion::Swap(ResponseUnion* other) {
  if (other == this) return;
  InternalSwap(other);
}
void ResponseUnion::InternalSwap(ResponseUnion* other) {
  std::swap(value_, other->value_);
  std::swap(_oneof_case_[0], other->_oneof_case_[0]);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata ResponseUnion::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ResponseUnion_descriptor_;
  metadata.reflection = ResponseUnion_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// ResponseUnion

// optional .cockroach.proto.GetResponse get = 2;
bool ResponseUnion::has_get() const {
  return value_case() == kGet;
}
void ResponseUnion::set_has_get() {
  _oneof_case_[0] = kGet;
}
void ResponseUnion::clear_get() {
  if (has_get()) {
    delete value_.get_;
    clear_has_value();
  }
}
 const ::cockroach::proto::GetResponse& ResponseUnion::get() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.ResponseUnion.get)
  return has_get() ? *value_.get_
                      : ::cockroach::proto::GetResponse::default_instance();
}
 ::cockroach::proto::GetResponse* ResponseUnion::mutable_get() {
  if (!has_get()) {
    clear_value();
    set_has_get();
    value_.get_ = new ::cockroach::proto::GetResponse;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.proto.ResponseUnion.get)
  return value_.get_;
}
 ::cockroach::proto::GetResponse* ResponseUnion::release_get() {
  if (has_get()) {
    clear_has_value();
    ::cockroach::proto::GetResponse* temp = value_.get_;
    value_.get_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
 void ResponseUnion::set_allocated_get(::cockroach::proto::GetResponse* get) {
  clear_value();
  if (get) {
    set_has_get();
    value_.get_ = get;
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.ResponseUnion.get)
}

// optional .cockroach.proto.PutResponse put = 3;
bool ResponseUnion::has_put() const {
  return value_case() == kPut;
}
void ResponseUnion::set_has_put() {
  _oneof_case_[0] = kPut;
}
void ResponseUnion::clear_put() {
  if (has_put()) {
    delete value_.put_;
    clear_has_value();
  }
}
 const ::cockroach::proto::PutResponse& ResponseUnion::put() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.ResponseUnion.put)
  return has_put() ? *value_.put_
                      : ::cockroach::proto::PutResponse::default_instance();
}
 ::cockroach::proto::PutResponse* ResponseUnion::mutable_put() {
  if (!has_put()) {
    clear_value();
    set_has_put();
    value_.put_ = new ::cockroach::proto::PutResponse;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.proto.ResponseUnion.put)
  return value_.put_;
}
 ::cockroach::proto::PutResponse* ResponseUnion::release_put() {
  if (has_put()) {
    clear_has_value();
    ::cockroach::proto::PutResponse* temp = value_.put_;
    value_.put_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
 void ResponseUnion::set_allocated_put(::cockroach::proto::PutResponse* put) {
  clear_value();
  if (put) {
    set_has_put();
    value_.put_ = put;
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.ResponseUnion.put)
}

// optional .cockroach.proto.ConditionalPutResponse conditional_put = 4;
bool ResponseUnion::has_conditional_put() const {
  return value_case() == kConditionalPut;
}
void ResponseUnion::set_has_conditional_put() {
  _oneof_case_[0] = kConditionalPut;
}
void ResponseUnion::clear_conditional_put() {
  if (has_conditional_put()) {
    delete value_.conditional_put_;
    clear_has_value();
  }
}
 const ::cockroach::proto::ConditionalPutResponse& ResponseUnion::conditional_put() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.ResponseUnion.conditional_put)
  return has_conditional_put() ? *value_.conditional_put_
                      : ::cockroach::proto::ConditionalPutResponse::default_instance();
}
 ::cockroach::proto::ConditionalPutResponse* ResponseUnion::mutable_conditional_put() {
  if (!has_conditional_put()) {
    clear_value();
    set_has_conditional_put();
    value_.conditional_put_ = new ::cockroach::proto::ConditionalPutResponse;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.proto.ResponseUnion.conditional_put)
  return value_.conditional_put_;
}
 ::cockroach::proto::ConditionalPutResponse* ResponseUnion::release_conditional_put() {
  if (has_conditional_put()) {
    clear_has_value();
    ::cockroach::proto::ConditionalPutResponse* temp = value_.conditional_put_;
    value_.conditional_put_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
 void ResponseUnion::set_allocated_conditional_put(::cockroach::proto::ConditionalPutResponse* conditional_put) {
  clear_value();
  if (conditional_put) {
    set_has_conditional_put();
    value_.conditional_put_ = conditional_put;
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.ResponseUnion.conditional_put)
}

// optional .cockroach.proto.IncrementResponse increment = 5;
bool ResponseUnion::has_increment() const {
  return value_case() == kIncrement;
}
void ResponseUnion::set_has_increment() {
  _oneof_case_[0] = kIncrement;
}
void ResponseUnion::clear_increment() {
  if (has_increment()) {
    delete value_.increment_;
    clear_has_value();
  }
}
 const ::cockroach::proto::IncrementResponse& ResponseUnion::increment() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.ResponseUnion.increment)
  return has_increment() ? *value_.increment_
                      : ::cockroach::proto::IncrementResponse::default_instance();
}
 ::cockroach::proto::IncrementResponse* ResponseUnion::mutable_increment() {
  if (!has_increment()) {
    clear_value();
    set_has_increment();
    value_.increment_ = new ::cockroach::proto::IncrementResponse;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.proto.ResponseUnion.increment)
  return value_.increment_;
}
 ::cockroach::proto::IncrementResponse* ResponseUnion::release_increment() {
  if (has_increment()) {
    clear_has_value();
    ::cockroach::proto::IncrementResponse* temp = value_.increment_;
    value_.increment_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
 void ResponseUnion::set_allocated_increment(::cockroach::proto::IncrementResponse* increment) {
  clear_value();
  if (increment) {
    set_has_increment();
    value_.increment_ = increment;
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.ResponseUnion.increment)
}

// optional .cockroach.proto.DeleteResponse delete = 6;
bool ResponseUnion::has_delete_() const {
  return value_case() == kDelete;
}
void ResponseUnion::set_has_delete_() {
  _oneof_case_[0] = kDelete;
}
void ResponseUnion::clear_delete_() {
  if (has_delete_()) {
    delete value_.delete__;
    clear_has_value();
  }
}
 const ::cockroach::proto::DeleteResponse& ResponseUnion::delete_() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.ResponseUnion.delete)
  return has_delete_() ? *value_.delete__
                      : ::cockroach::proto::DeleteResponse::default_instance();
}
 ::cockroach::proto::DeleteResponse* ResponseUnion::mutable_delete_() {
  if (!has_delete_()) {
    clear_value();
    set_has_delete_();
    value_.delete__ = new ::cockroach::proto::DeleteResponse;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.proto.ResponseUnion.delete)
  return value_.delete__;
}
 ::cockroach::proto::DeleteResponse* ResponseUnion::release_delete_() {
  if (has_delete_()) {
    clear_has_value();
    ::cockroach::proto::DeleteResponse* temp = value_.delete__;
    value_.delete__ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
 void ResponseUnion::set_allocated_delete_(::cockroach::proto::DeleteResponse* delete_) {
  clear_value();
  if (delete_) {
    set_has_delete_();
    value_.delete__ = delete_;
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.ResponseUnion.delete)
}

// optional .cockroach.proto.DeleteRangeResponse delete_range = 7;
bool ResponseUnion::has_delete_range() const {
  return value_case() == kDeleteRange;
}
void ResponseUnion::set_has_delete_range() {
  _oneof_case_[0] = kDeleteRange;
}
void ResponseUnion::clear_delete_range() {
  if (has_delete_range()) {
    delete value_.delete_range_;
    clear_has_value();
  }
}
 const ::cockroach::proto::DeleteRangeResponse& ResponseUnion::delete_range() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.ResponseUnion.delete_range)
  return has_delete_range() ? *value_.delete_range_
                      : ::cockroach::proto::DeleteRangeResponse::default_instance();
}
 ::cockroach::proto::DeleteRangeResponse* ResponseUnion::mutable_delete_range() {
  if (!has_delete_range()) {
    clear_value();
    set_has_delete_range();
    value_.delete_range_ = new ::cockroach::proto::DeleteRangeResponse;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.proto.ResponseUnion.delete_range)
  return value_.delete_range_;
}
 ::cockroach::proto::DeleteRangeResponse* ResponseUnion::release_delete_range() {
  if (has_delete_range()) {
    clear_has_value();
    ::cockroach::proto::DeleteRangeResponse* temp = value_.delete_range_;
    value_.delete_range_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
 void ResponseUnion::set_allocated_delete_range(::cockroach::proto::DeleteRangeResponse* delete_range) {
  clear_value();
  if (delete_range) {
    set_has_delete_range();
    value_.delete_range_ = delete_range;
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.ResponseUnion.delete_range)
}

// optional .cockroach.proto.ScanResponse scan = 8;
bool ResponseUnion::has_scan() const {
  return value_case() == kScan;
}
void ResponseUnion::set_has_scan() {
  _oneof_case_[0] = kScan;
}
void ResponseUnion::clear_scan() {
  if (has_scan()) {
    delete value_.scan_;
    clear_has_value();
  }
}
 const ::cockroach::proto::ScanResponse& ResponseUnion::scan() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.ResponseUnion.scan)
  return has_scan() ? *value_.scan_
                      : ::cockroach::proto::ScanResponse::default_instance();
}
 ::cockroach::proto::ScanResponse* ResponseUnion::mutable_scan() {
  if (!has_scan()) {
    clear_value();
    set_has_scan();
    value_.scan_ = new ::cockroach::proto::ScanResponse;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.proto.ResponseUnion.scan)
  return value_.scan_;
}
 ::cockroach::proto::ScanResponse* ResponseUnion::release_scan() {
  if (has_scan()) {
    clear_has_value();
    ::cockroach::proto::ScanResponse* temp = value_.scan_;
    value_.scan_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
 void ResponseUnion::set_allocated_scan(::cockroach::proto::ScanResponse* scan) {
  clear_value();
  if (scan) {
    set_has_scan();
    value_.scan_ = scan;
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.ResponseUnion.scan)
}

// optional .cockroach.proto.EndTransactionResponse end_transaction = 9;
bool ResponseUnion::has_end_transaction() const {
  return value_case() == kEndTransaction;
}
void ResponseUnion::set_has_end_transaction() {
  _oneof_case_[0] = kEndTransaction;
}
void ResponseUnion::clear_end_transaction() {
  if (has_end_transaction()) {
    delete value_.end_transaction_;
    clear_has_value();
  }
}
 const ::cockroach::proto::EndTransactionResponse& ResponseUnion::end_transaction() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.ResponseUnion.end_transaction)
  return has_end_transaction() ? *value_.end_transaction_
                      : ::cockroach::proto::EndTransactionResponse::default_instance();
}
 ::cockroach::proto::EndTransactionResponse* ResponseUnion::mutable_end_transaction() {
  if (!has_end_transaction()) {
    clear_value();
    set_has_end_transaction();
    value_.end_transaction_ = new ::cockroach::proto::EndTransactionResponse;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.proto.ResponseUnion.end_transaction)
  return value_.end_transaction_;
}
 ::cockroach::proto::EndTransactionResponse* ResponseUnion::release_end_transaction() {
  if (has_end_transaction()) {
    clear_has_value();
    ::cockroach::proto::EndTransactionResponse* temp = value_.end_transaction_;
    value_.end_transaction_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
 void ResponseUnion::set_allocated_end_transaction(::cockroach::proto::EndTransactionResponse* end_transaction) {
  clear_value();
  if (end_transaction) {
    set_has_end_transaction();
    value_.end_transaction_ = end_transaction;
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.ResponseUnion.end_transaction)
}

bool ResponseUnion::has_value() const {
  return value_case() != VALUE_NOT_SET;
}
void ResponseUnion::clear_has_value() {
  _oneof_case_[0] = VALUE_NOT_SET;
}
ResponseUnion::ValueCase ResponseUnion::value_case() const {
  return ResponseUnion::ValueCase(_oneof_case_[0]);
}
#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#ifndef _MSC_VER
const int BatchRequest::kKvheaderFieldNumber;
const int BatchRequest::kRequestsFieldNumber;
#endif  // !_MSC_VER

BatchRequest::BatchRequest()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:cockroach.proto.BatchRequest)
}

void BatchRequest::InitAsDefaultInstance() {
  kvheader_ = const_cast< ::cockroach::proto::KVRequestHeader*>(&::cockroach::proto::KVRequestHeader::default_instance());
}

BatchRequest::BatchRequest(const BatchRequest& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:cockroach.proto.BatchRequest)
}

void BatchRequest::SharedCtor() {
  _cached_size_ = 0;
  kvheader_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

BatchRequest::~BatchRequest() {
  // @@protoc_insertion_point(destructor:cockroach.proto.BatchRequest)
  SharedDtor();
}

void BatchRequest::SharedDtor() {
  if (this != default_instance_) {
    delete kvheader_;
  }
}

void BatchRequest::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* BatchRequest::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return BatchRequest_descriptor_;
}

const BatchRequest& BatchRequest::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_cockroach_2fproto_2fapi_2eproto();
  return *default_instance_;
}

BatchRequest* BatchRequest::default_instance_ = NULL;

BatchRequest* BatchRequest::New(::google::protobuf::Arena* arena) const {
  BatchRequest* n = new BatchRequest;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void BatchRequest::Clear() {
  if (has_kvheader()) {
    if (kvheader_ != NULL) kvheader_->::cockroach::proto::KVRequestHeader::Clear();
  }
  requests_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool BatchRequest::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:cockroach.proto.BatchRequest)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .cockroach.proto.KVRequestHeader kvheader = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_kvheader()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_requests;
        break;
      }

      // repeated .cockroach.proto.RequestUnion requests = 2;
      case 2: {
        if (tag == 18) {
         parse_requests:
          DO_(input->IncrementRecursionDepth());
         parse_loop_requests:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                input, add_requests()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_loop_requests;
        input->UnsafeDecrementRecursionDepth();
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:cockroach.proto.BatchRequest)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:cockroach.proto.BatchRequest)
  return false;
#undef DO_
}

void BatchRequest::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:cockroach.proto.BatchRequest)
  // optional .cockroach.proto.KVRequestHeader kvheader = 1;
  if (has_kvheader()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->kvheader_, output);
  }

  // repeated .cockroach.proto.RequestUnion requests = 2;
  for (unsigned int i = 0, n = this->requests_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->requests(i), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:cockroach.proto.BatchRequest)
}

::google::protobuf::uint8* BatchRequest::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:cockroach.proto.BatchRequest)
  // optional .cockroach.proto.KVRequestHeader kvheader = 1;
  if (has_kvheader()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, *this->kvheader_, target);
  }

  // repeated .cockroach.proto.RequestUnion requests = 2;
  for (unsigned int i = 0, n = this->requests_size(); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->requests(i), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:cockroach.proto.BatchRequest)
  return target;
}

int BatchRequest::ByteSize() const {
  int total_size = 0;

  // optional .cockroach.proto.KVRequestHeader kvheader = 1;
  if (has_kvheader()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->kvheader_);
  }

  // repeated .cockroach.proto.RequestUnion requests = 2;
  total_size += 1 * this->requests_size();
  for (int i = 0; i < this->requests_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->requests(i));
  }

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void BatchRequest::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const BatchRequest* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const BatchRequest>(
          &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void BatchRequest::MergeFrom(const BatchRequest& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  requests_.MergeFrom(from.requests_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_kvheader()) {
      mutable_kvheader()->::cockroach::proto::KVRequestHeader::MergeFrom(from.kvheader());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void BatchRequest::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void BatchRequest::CopyFrom(const BatchRequest& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BatchRequest::IsInitialized() const {

  return true;
}

void BatchRequest::Swap(BatchRequest* other) {
  if (other == this) return;
  InternalSwap(other);
}
void BatchRequest::InternalSwap(BatchRequest* other) {
  std::swap(kvheader_, other->kvheader_);
  requests_.UnsafeArenaSwap(&other->requests_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata BatchRequest::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = BatchRequest_descriptor_;
  metadata.reflection = BatchRequest_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// BatchRequest

// optional .cockroach.proto.KVRequestHeader kvheader = 1;
bool BatchRequest::has_kvheader() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void BatchRequest::set_has_kvheader() {
  _has_bits_[0] |= 0x00000001u;
}
void BatchRequest::clear_has_kvheader() {
  _has_bits_[0] &= ~0x00000001u;
}
void BatchRequest::clear_kvheader() {
  if (kvheader_ != NULL) kvheader_->::cockroach::proto::KVRequestHeader::Clear();
  clear_has_kvheader();
}
 const ::cockroach::proto::KVRequestHeader& BatchRequest::kvheader() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.BatchRequest.kvheader)
  return kvheader_ != NULL ? *kvheader_ : *default_instance_->kvheader_;
}
 ::cockroach::proto::KVRequestHeader* BatchRequest::mutable_kvheader() {
  set_has_kvheader();
  if (kvheader_ == NULL) {
    kvheader_ = new ::cockroach::proto::KVRequestHeader;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.proto.BatchRequest.kvheader)
  return kvheader_;
}
 ::cockroach::proto::KVRequestHeader* BatchRequest::release_kvheader() {
  clear_has_kvheader();
  ::cockroach::proto::KVRequestHeader* temp = kvheader_;
  kvheader_ = NULL;
  return temp;
}
 void BatchRequest::set_allocated_kvheader(::cockroach::proto::KVRequestHeader* kvheader) {
  delete kvheader_;
  kvheader_ = kvheader;
  if (kvheader) {
    set_has_kvheader();
  } else {
    clear_has_kvheader();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.BatchRequest.kvheader)
}

// repeated .cockroach.proto.RequestUnion requests = 2;
int BatchRequest::requests_size() const {
  return requests_.size();
}
void BatchRequest::clear_requests() {
  requests_.Clear();
}
 const ::cockroach::proto::RequestUnion& BatchRequest::requests(int index) const {
  // @@protoc_insertion_point(field_get:cockroach.proto.BatchRequest.requests)
  return requests_.Get(index);
}
 ::cockroach::proto::RequestUnion* BatchRequest::mutable_requests(int index) {
  // @@protoc_insertion_point(field_mutable:cockroach.proto.BatchRequest.requests)
  return requests_.Mutable(index);
}
 ::cockroach::proto::RequestUnion* BatchRequest::add_requests() {
  // @@protoc_insertion_point(field_add:cockroach.proto.BatchRequest.requests)
  return requests_.Add();
}
 const ::google::protobuf::RepeatedPtrField< ::cockroach::proto::RequestUnion >&
BatchRequest::requests() const {
  // @@protoc_insertion_point(field_list:cockroach.proto.BatchRequest.requests)
  return requests_;
}
 ::google::protobuf::RepeatedPtrField< ::cockroach::proto::RequestUnion >*
BatchRequest::mutable_requests() {
  // @@protoc_insertion_point(field_mutable_list:cockroach.proto.BatchRequest.requests)
  return &requests_;
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#ifndef _MSC_VER
const int BatchResponse::kKvheaderFieldNumber;
const int BatchResponse::kResponsesFieldNumber;
#endif  // !_MSC_VER

BatchResponse::BatchResponse()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:cockroach.proto.BatchResponse)
}

void BatchResponse::InitAsDefaultInstance() {
  kvheader_ = const_cast< ::cockroach::proto::KVResponseHeader*>(&::cockroach::proto::KVResponseHeader::default_instance());
}

BatchResponse::BatchResponse(const BatchResponse& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:cockroach.proto.BatchResponse)
}

void BatchResponse::SharedCtor() {
  _cached_size_ = 0;
  kvheader_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

BatchResponse::~BatchResponse() {
  // @@protoc_insertion_point(destructor:cockroach.proto.BatchResponse)
  SharedDtor();
}

void BatchResponse::SharedDtor() {
  if (this != default_instance_) {
    delete kvheader_;
  }
}

void BatchResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* BatchResponse::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return BatchResponse_descriptor_;
}

const BatchResponse& BatchResponse::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_cockroach_2fproto_2fapi_2eproto();
  return *default_instance_;
}

BatchResponse* BatchResponse::default_instance_ = NULL;

BatchResponse* BatchResponse::New(::google::protobuf::Arena* arena) const {
  BatchResponse* n = new BatchResponse;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void BatchResponse::Clear() {
  if (has_kvheader()) {
    if (kvheader_ != NULL) kvheader_->::cockroach::proto::KVResponseHeader::Clear();
  }
  responses_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool BatchResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:cockroach.proto.BatchResponse)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .cockroach.proto.KVResponseHeader kvheader = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_kvheader()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_responses;
        break;
      }

      // repeated .cockroach.proto.ResponseUnion responses = 2;
      case 2: {
        if (tag == 18) {
         parse_responses:
          DO_(input->IncrementRecursionDepth());
         parse_loop_responses:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                input, add_responses()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_loop_responses;
        input->UnsafeDecrementRecursionDepth();
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:cockroach.proto.BatchResponse)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:cockroach.proto.BatchResponse)
  return false;
#undef DO_
}

void BatchResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:cockroach.proto.BatchResponse)
  // optional .cockroach.proto.KVResponseHeader kvheader = 1;
  if (has_kvheader()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->kvheader_, output);
  }

  // repeated .cockroach.proto.ResponseUnion responses = 2;
  for (unsigned int i = 0, n = this->responses_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->responses(i), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:cockroach.proto.BatchResponse)
}

::google::protobuf::uint8* BatchResponse::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:cockroach.proto.BatchResponse)
  // optional .cockroach.proto.KVResponseHeader kvheader = 1;
  if (has_kvheader()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, *this->kvheader_, target);
  }

  // repeated .cockroach.proto.ResponseUnion responses = 2;
  for (unsigned int i = 0, n = this->responses_size(); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->responses(i), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:cockroach.proto.BatchResponse)
  return target;
}

int BatchResponse::ByteSize() const {
  int total_size = 0;

  // optional .cockroach.proto.KVResponseHeader kvheader = 1;
  if (has_kvheader()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->kvheader_);
  }

  // repeated .cockroach.proto.ResponseUnion responses = 2;
  total_size += 1 * this->responses_size();
  for (int i = 0; i < this->responses_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->responses(i));
  }

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void BatchResponse::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const BatchResponse* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const BatchResponse>(
          &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void BatchResponse::MergeFrom(const BatchResponse& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  responses_.MergeFrom(from.responses_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_kvheader()) {
      mutable_kvheader()->::cockroach::proto::KVResponseHeader::MergeFrom(from.kvheader());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void BatchResponse::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void BatchResponse::CopyFrom(const BatchResponse& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BatchResponse::IsInitialized() const {

  return true;
}

void BatchResponse::Swap(BatchResponse* other) {
  if (other == this) return;
  InternalSwap(other);
}
void BatchResponse::InternalSwap(BatchResponse* other) {
  std::swap(kvheader_, other->kvheader_);
  responses_.UnsafeArenaSwap(&other->responses_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata BatchResponse::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = BatchResponse_descriptor_;
  metadata.reflection = BatchResponse_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// BatchResponse

// optional .cockroach.proto.KVResponseHeader kvheader = 1;
bool BatchResponse::has_kvheader() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void BatchResponse::set_has_kvheader() {
  _has_bits_[0] |= 0x00000001u;
}
void BatchResponse::clear_has_kvheader() {
  _has_bits_[0] &= ~0x00000001u;
}
void BatchResponse::clear_kvheader() {
  if (kvheader_ != NULL) kvheader_->::cockroach::proto::KVResponseHeader::Clear();
  clear_has_kvheader();
}
 const ::cockroach::proto::KVResponseHeader& BatchResponse::kvheader() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.BatchResponse.kvheader)
  return kvheader_ != NULL ? *kvheader_ : *default_instance_->kvheader_;
}
 ::cockroach::proto::KVResponseHeader* BatchResponse::mutable_kvheader() {
  set_has_kvheader();
  if (kvheader_ == NULL) {
    kvheader_ = new ::cockroach::proto::KVResponseHeader;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.proto.BatchResponse.kvheader)
  return kvheader_;
}
 ::cockroach::proto::KVResponseHeader* BatchResponse::release_kvheader() {
  clear_has_kvheader();
  ::cockroach::proto::KVResponseHeader* temp = kvheader_;
  kvheader_ = NULL;
  return temp;
}
 void BatchResponse::set_allocated_kvheader(::cockroach::proto::KVResponseHeader* kvheader) {
  delete kvheader_;
  kvheader_ = kvheader;
  if (kvheader) {
    set_has_kvheader();
  } else {
    clear_has_kvheader();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.BatchResponse.kvheader)
}

// repeated .cockroach.proto.ResponseUnion responses = 2;
int BatchResponse::responses_size() const {
  return responses_.size();
}
void BatchResponse::clear_responses() {
  responses_.Clear();
}
 const ::cockroach::proto::ResponseUnion& BatchResponse::responses(int index) const {
  // @@protoc_insertion_point(field_get:cockroach.proto.BatchResponse.responses)
  return responses_.Get(index);
}
 ::cockroach::proto::ResponseUnion* BatchResponse::mutable_responses(int index) {
  // @@protoc_insertion_point(field_mutable:cockroach.proto.BatchResponse.responses)
  return responses_.Mutable(index);
}
 ::cockroach::proto::ResponseUnion* BatchResponse::add_responses() {
  // @@protoc_insertion_point(field_add:cockroach.proto.BatchResponse.responses)
  return responses_.Add();
}
 const ::google::protobuf::RepeatedPtrField< ::cockroach::proto::ResponseUnion >&
BatchResponse::responses() const {
  // @@protoc_insertion_point(field_list:cockroach.proto.BatchResponse.responses)
  return responses_;
}
 ::google::protobuf::RepeatedPtrField< ::cockroach::proto::ResponseUnion >*
BatchResponse::mutable_responses() {
  // @@protoc_insertion_point(field_mutable_list:cockroach.proto.BatchResponse.responses)
  return &responses_;
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#ifndef _MSC_VER
const int AdminSplitRequest::kKvheaderFieldNumber;
const int AdminSplitRequest::kSplitKeyFieldNumber;
#endif  // !_MSC_VER

AdminSplitRequest::AdminSplitRequest()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:cockroach.proto.AdminSplitRequest)
}

void AdminSplitRequest::InitAsDefaultInstance() {
  kvheader_ = const_cast< ::cockroach::proto::KVRequestHeader*>(&::cockroach::proto::KVRequestHeader::default_instance());
}

AdminSplitRequest::AdminSplitRequest(const AdminSplitRequest& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:cockroach.proto.AdminSplitRequest)
}

void AdminSplitRequest::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  kvheader_ = NULL;
  split_key_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

AdminSplitRequest::~AdminSplitRequest() {
  // @@protoc_insertion_point(destructor:cockroach.proto.AdminSplitRequest)
  SharedDtor();
}

void AdminSplitRequest::SharedDtor() {
  split_key_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != default_instance_) {
    delete kvheader_;
  }
}

void AdminSplitRequest::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* AdminSplitRequest::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return AdminSplitRequest_descriptor_;
}

const AdminSplitRequest& AdminSplitRequest::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_cockroach_2fproto_2fapi_2eproto();
  return *default_instance_;
}

AdminSplitRequest* AdminSplitRequest::default_instance_ = NULL;

AdminSplitRequest* AdminSplitRequest::New(::google::protobuf::Arena* arena) const {
  AdminSplitRequest* n = new AdminSplitRequest;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void AdminSplitRequest::Clear() {
  if (_has_bits_[0 / 32] & 3u) {
    if (has_kvheader()) {
      if (kvheader_ != NULL) kvheader_->::cockroach::proto::KVRequestHeader::Clear();
    }
    if (has_split_key()) {
      split_key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool AdminSplitRequest::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:cockroach.proto.AdminSplitRequest)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .cockroach.proto.KVRequestHeader kvheader = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_kvheader()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_split_key;
        break;
      }

      // optional bytes split_key = 2;
      case 2: {
        if (tag == 18) {
         parse_split_key:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_split_key()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:cockroach.proto.AdminSplitRequest)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:cockroach.proto.AdminSplitRequest)
  return false;
#undef DO_
}

void AdminSplitRequest::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:cockroach.proto.AdminSplitRequest)
  // optional .cockroach.proto.KVRequestHeader kvheader = 1;
  if (has_kvheader()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->kvheader_, output);
  }

  // optional bytes split_key = 2;
  if (has_split_key()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      2, this->split_key(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:cockroach.proto.AdminSplitRequest)
}

::google::protobuf::uint8* AdminSplitRequest::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:cockroach.proto.AdminSplitRequest)
  // optional .cockroach.proto.KVRequestHeader kvheader = 1;
  if (has_kvheader()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, *this->kvheader_, target);
  }

  // optional bytes split_key = 2;
  if (has_split_key()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        2, this->split_key(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:cockroach.proto.AdminSplitRequest)
  return target;
}

int AdminSplitRequest::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & 3) {
    // optional .cockroach.proto.KVRequestHeader kvheader = 1;
    if (has_kvheader()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->kvheader_);
    }

    // optional bytes split_key = 2;
    if (has_split_key()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->split_key());
    }

  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void AdminSplitRequest::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const AdminSplitRequest* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const AdminSplitRequest>(
          &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void AdminSplitRequest::MergeFrom(const AdminSplitRequest& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_kvheader()) {
      mutable_kvheader()->::cockroach::proto::KVRequestHeader::MergeFrom(from.kvheader());
    }
    if (from.has_split_key()) {
      set_has_split_key();
      split_key_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.split_key_);
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void AdminSplitRequest::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void AdminSplitRequest::CopyFrom(const AdminSplitRequest& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AdminSplitRequest::IsInitialized() const {

  return true;
}

void AdminSplitRequest::Swap(AdminSplitRequest* other) {
  if (other == this) return;
  InternalSwap(other);
}
void AdminSplitRequest::InternalSwap(AdminSplitRequest* other) {
  std::swap(kvheader_, other->kvheader_);
  split_key_.Swap(&other->split_key_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata AdminSplitRequest::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = AdminSplitRequest_descriptor_;
  metadata.reflection = AdminSplitRequest_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// AdminSplitRequest

// optional .cockroach.proto.KVRequestHeader kvheader = 1;
bool AdminSplitRequest::has_kvheader() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void AdminSplitRequest::set_has_kvheader() {
  _has_bits_[0] |= 0x00000001u;
}
void AdminSplitRequest::clear_has_kvheader() {
  _has_bits_[0] &= ~0x00000001u;
}
void AdminSplitRequest::clear_kvheader() {
  if (kvheader_ != NULL) kvheader_->::cockroach::proto::KVRequestHeader::Clear();
  clear_has_kvheader();
}
 const ::cockroach::proto::KVRequestHeader& AdminSplitRequest::kvheader() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.AdminSplitRequest.kvheader)
  return kvheader_ != NULL ? *kvheader_ : *default_instance_->kvheader_;
}
 ::cockroach::proto::KVRequestHeader* AdminSplitRequest::mutable_kvheader() {
  set_has_kvheader();
  if (kvheader_ == NULL) {
    kvheader_ = new ::cockroach::proto::KVRequestHeader;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.proto.AdminSplitRequest.kvheader)
  return kvheader_;
}
 ::cockroach::proto::KVRequestHeader* AdminSplitRequest::release_kvheader() {
  clear_has_kvheader();
  ::cockroach::proto::KVRequestHeader* temp = kvheader_;
  kvheader_ = NULL;
  return temp;
}
 void AdminSplitRequest::set_allocated_kvheader(::cockroach::proto::KVRequestHeader* kvheader) {
  delete kvheader_;
  kvheader_ = kvheader;
  if (kvheader) {
    set_has_kvheader();
  } else {
    clear_has_kvheader();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.AdminSplitRequest.kvheader)
}

// optional bytes split_key = 2;
bool AdminSplitRequest::has_split_key() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void AdminSplitRequest::set_has_split_key() {
  _has_bits_[0] |= 0x00000002u;
}
void AdminSplitRequest::clear_has_split_key() {
  _has_bits_[0] &= ~0x00000002u;
}
void AdminSplitRequest::clear_split_key() {
  split_key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_split_key();
}
 const ::std::string& AdminSplitRequest::split_key() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.AdminSplitRequest.split_key)
  return split_key_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void AdminSplitRequest::set_split_key(const ::std::string& value) {
  set_has_split_key();
  split_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cockroach.proto.AdminSplitRequest.split_key)
}
 void AdminSplitRequest::set_split_key(const char* value) {
  set_has_split_key();
  split_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cockroach.proto.AdminSplitRequest.split_key)
}
 void AdminSplitRequest::set_split_key(const void* value, size_t size) {
  set_has_split_key();
  split_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cockroach.proto.AdminSplitRequest.split_key)
}
 ::std::string* AdminSplitRequest::mutable_split_key() {
  set_has_split_key();
  // @@protoc_insertion_point(field_mutable:cockroach.proto.AdminSplitRequest.split_key)
  return split_key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* AdminSplitRequest::release_split_key() {
  clear_has_split_key();
  return split_key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void AdminSplitRequest::set_allocated_split_key(::std::string* split_key) {
  if (split_key != NULL) {
    set_has_split_key();
  } else {
    clear_has_split_key();
  }
  split_key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), split_key);
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.AdminSplitRequest.split_key)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#ifndef _MSC_VER
const int AdminSplitResponse::kKvheaderFieldNumber;
#endif  // !_MSC_VER

AdminSplitResponse::AdminSplitResponse()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:cockroach.proto.AdminSplitResponse)
}

void AdminSplitResponse::InitAsDefaultInstance() {
  kvheader_ = const_cast< ::cockroach::proto::KVResponseHeader*>(&::cockroach::proto::KVResponseHeader::default_instance());
}

AdminSplitResponse::AdminSplitResponse(const AdminSplitResponse& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:cockroach.proto.AdminSplitResponse)
}

void AdminSplitResponse::SharedCtor() {
  _cached_size_ = 0;
  kvheader_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

AdminSplitResponse::~AdminSplitResponse() {
  // @@protoc_insertion_point(destructor:cockroach.proto.AdminSplitResponse)
  SharedDtor();
}

void AdminSplitResponse::SharedDtor() {
  if (this != default_instance_) {
    delete kvheader_;
  }
}

void AdminSplitResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* AdminSplitResponse::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return AdminSplitResponse_descriptor_;
}

const AdminSplitResponse& AdminSplitResponse::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_cockroach_2fproto_2fapi_2eproto();
  return *default_instance_;
}

AdminSplitResponse* AdminSplitResponse::default_instance_ = NULL;

AdminSplitResponse* AdminSplitResponse::New(::google::protobuf::Arena* arena) const {
  AdminSplitResponse* n = new AdminSplitResponse;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void AdminSplitResponse::Clear() {
  if (has_kvheader()) {
    if (kvheader_ != NULL) kvheader_->::cockroach::proto::KVResponseHeader::Clear();
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool AdminSplitResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:cockroach.proto.AdminSplitResponse)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .cockroach.proto.KVResponseHeader kvheader = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_kvheader()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:cockroach.proto.AdminSplitResponse)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:cockroach.proto.AdminSplitResponse)
  return false;
#undef DO_
}

void AdminSplitResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:cockroach.proto.AdminSplitResponse)
  // optional .cockroach.proto.KVResponseHeader kvheader = 1;
  if (has_kvheader()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->kvheader_, output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:cockroach.proto.AdminSplitResponse)
}

::google::protobuf::uint8* AdminSplitResponse::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:cockroach.proto.AdminSplitResponse)
  // optional .cockroach.proto.KVResponseHeader kvheader = 1;
  if (has_kvheader()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, *this->kvheader_, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:cockroach.proto.AdminSplitResponse)
  return target;
}

int AdminSplitResponse::ByteSize() const {
  int total_size = 0;

  // optional .cockroach.proto.KVResponseHeader kvheader = 1;
  if (has_kvheader()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->kvheader_);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void AdminSplitResponse::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const AdminSplitResponse* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const AdminSplitResponse>(
          &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void AdminSplitResponse::MergeFrom(const AdminSplitResponse& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_kvheader()) {
      mutable_kvheader()->::cockroach::proto::KVResponseHeader::MergeFrom(from.kvheader());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void AdminSplitResponse::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void AdminSplitResponse::CopyFrom(const AdminSplitResponse& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AdminSplitResponse::IsInitialized() const {

  return true;
}

void AdminSplitResponse::Swap(AdminSplitResponse* other) {
  if (other == this) return;
  InternalSwap(other);
}
void AdminSplitResponse::InternalSwap(AdminSplitResponse* other) {
  std::swap(kvheader_, other->kvheader_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata AdminSplitResponse::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = AdminSplitResponse_descriptor_;
  metadata.reflection = AdminSplitResponse_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// AdminSplitResponse

// optional .cockroach.proto.KVResponseHeader kvheader = 1;
bool AdminSplitResponse::has_kvheader() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void AdminSplitResponse::set_has_kvheader() {
  _has_bits_[0] |= 0x00000001u;
}
void AdminSplitResponse::clear_has_kvheader() {
  _has_bits_[0] &= ~0x00000001u;
}
void AdminSplitResponse::clear_kvheader() {
  if (kvheader_ != NULL) kvheader_->::cockroach::proto::KVResponseHeader::Clear();
  clear_has_kvheader();
}
 const ::cockroach::proto::KVResponseHeader& AdminSplitResponse::kvheader() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.AdminSplitResponse.kvheader)
  return kvheader_ != NULL ? *kvheader_ : *default_instance_->kvheader_;
}
 ::cockroach::proto::KVResponseHeader* AdminSplitResponse::mutable_kvheader() {
  set_has_kvheader();
  if (kvheader_ == NULL) {
    kvheader_ = new ::cockroach::proto::KVResponseHeader;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.proto.AdminSplitResponse.kvheader)
  return kvheader_;
}
 ::cockroach::proto::KVResponseHeader* AdminSplitResponse::release_kvheader() {
  clear_has_kvheader();
  ::cockroach::proto::KVResponseHeader* temp = kvheader_;
  kvheader_ = NULL;
  return temp;
}
 void AdminSplitResponse::set_allocated_kvheader(::cockroach::proto::KVResponseHeader* kvheader) {
  delete kvheader_;
  kvheader_ = kvheader;
  if (kvheader) {
    set_has_kvheader();
  } else {
    clear_has_kvheader();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.AdminSplitResponse.kvheader)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#ifndef _MSC_VER
const int AdminMergeRequest::kKvheaderFieldNumber;
#endif  // !_MSC_VER

AdminMergeRequest::AdminMergeRequest()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:cockroach.proto.AdminMergeRequest)
}

void AdminMergeRequest::InitAsDefaultInstance() {
  kvheader_ = const_cast< ::cockroach::proto::KVRequestHeader*>(&::cockroach::proto::KVRequestHeader::default_instance());
}

AdminMergeRequest::AdminMergeRequest(const AdminMergeRequest& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:cockroach.proto.AdminMergeRequest)
}

void AdminMergeRequest::SharedCtor() {
  _cached_size_ = 0;
  kvheader_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

AdminMergeRequest::~AdminMergeRequest() {
  // @@protoc_insertion_point(destructor:cockroach.proto.AdminMergeRequest)
  SharedDtor();
}

void AdminMergeRequest::SharedDtor() {
  if (this != default_instance_) {
    delete kvheader_;
  }
}

void AdminMergeRequest::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* AdminMergeRequest::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return AdminMergeRequest_descriptor_;
}

const AdminMergeRequest& AdminMergeRequest::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_cockroach_2fproto_2fapi_2eproto();
  return *default_instance_;
}

AdminMergeRequest* AdminMergeRequest::default_instance_ = NULL;

AdminMergeRequest* AdminMergeRequest::New(::google::protobuf::Arena* arena) const {
  AdminMergeRequest* n = new AdminMergeRequest;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void AdminMergeRequest::Clear() {
  if (has_kvheader()) {
    if (kvheader_ != NULL) kvheader_->::cockroach::proto::KVRequestHeader::Clear();
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool AdminMergeRequest::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:cockroach.proto.AdminMergeRequest)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .cockroach.proto.KVRequestHeader kvheader = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_kvheader()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:cockroach.proto.AdminMergeRequest)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:cockroach.proto.AdminMergeRequest)
  return false;
#undef DO_
}

void AdminMergeRequest::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:cockroach.proto.AdminMergeRequest)
  // optional .cockroach.proto.KVRequestHeader kvheader = 1;
  if (has_kvheader()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->kvheader_, output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:cockroach.proto.AdminMergeRequest)
}

::google::protobuf::uint8* AdminMergeRequest::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:cockroach.proto.AdminMergeRequest)
  // optional .cockroach.proto.KVRequestHeader kvheader = 1;
  if (has_kvheader()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, *this->kvheader_, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:cockroach.proto.AdminMergeRequest)
  return target;
}

int AdminMergeRequest::ByteSize() const {
  int total_size = 0;

  // optional .cockroach.proto.KVRequestHeader kvheader = 1;
  if (has_kvheader()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->kvheader_);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void AdminMergeRequest::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const AdminMergeRequest* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const AdminMergeRequest>(
          &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void AdminMergeRequest::MergeFrom(const AdminMergeRequest& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_kvheader()) {
      mutable_kvheader()->::cockroach::proto::KVRequestHeader::MergeFrom(from.kvheader());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void AdminMergeRequest::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void AdminMergeRequest::CopyFrom(const AdminMergeRequest& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AdminMergeRequest::IsInitialized() const {

  return true;
}

void AdminMergeRequest::Swap(AdminMergeRequest* other) {
  if (other == this) return;
  InternalSwap(other);
}
void AdminMergeRequest::InternalSwap(AdminMergeRequest* other) {
  std::swap(kvheader_, other->kvheader_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata AdminMergeRequest::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = AdminMergeRequest_descriptor_;
  metadata.reflection = AdminMergeRequest_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// AdminMergeRequest

// optional .cockroach.proto.KVRequestHeader kvheader = 1;
bool AdminMergeRequest::has_kvheader() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void AdminMergeRequest::set_has_kvheader() {
  _has_bits_[0] |= 0x00000001u;
}
void AdminMergeRequest::clear_has_kvheader() {
  _has_bits_[0] &= ~0x00000001u;
}
void AdminMergeRequest::clear_kvheader() {
  if (kvheader_ != NULL) kvheader_->::cockroach::proto::KVRequestHeader::Clear();
  clear_has_kvheader();
}
 const ::cockroach::proto::KVRequestHeader& AdminMergeRequest::kvheader() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.AdminMergeRequest.kvheader)
  return kvheader_ != NULL ? *kvheader_ : *default_instance_->kvheader_;
}
 ::cockroach::proto::KVRequestHeader* AdminMergeRequest::mutable_kvheader() {
  set_has_kvheader();
  if (kvheader_ == NULL) {
    kvheader_ = new ::cockroach::proto::KVRequestHeader;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.proto.AdminMergeRequest.kvheader)
  return kvheader_;
}
 ::cockroach::proto::KVRequestHeader* AdminMergeRequest::release_kvheader() {
  clear_has_kvheader();
  ::cockroach::proto::KVRequestHeader* temp = kvheader_;
  kvheader_ = NULL;
  return temp;
}
 void AdminMergeRequest::set_allocated_kvheader(::cockroach::proto::KVRequestHeader* kvheader) {
  delete kvheader_;
  kvheader_ = kvheader;
  if (kvheader) {
    set_has_kvheader();
  } else {
    clear_has_kvheader();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.AdminMergeRequest.kvheader)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#ifndef _MSC_VER
const int AdminMergeResponse::kKvheaderFieldNumber;
#endif  // !_MSC_VER

AdminMergeResponse::AdminMergeResponse()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:cockroach.proto.AdminMergeResponse)
}

void AdminMergeResponse::InitAsDefaultInstance() {
  kvheader_ = const_cast< ::cockroach::proto::KVResponseHeader*>(&::cockroach::proto::KVResponseHeader::default_instance());
}

AdminMergeResponse::AdminMergeResponse(const AdminMergeResponse& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:cockroach.proto.AdminMergeResponse)
}

void AdminMergeResponse::SharedCtor() {
  _cached_size_ = 0;
  kvheader_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

AdminMergeResponse::~AdminMergeResponse() {
  // @@protoc_insertion_point(destructor:cockroach.proto.AdminMergeResponse)
  SharedDtor();
}

void AdminMergeResponse::SharedDtor() {
  if (this != default_instance_) {
    delete kvheader_;
  }
}

void AdminMergeResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* AdminMergeResponse::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return AdminMergeResponse_descriptor_;
}

const AdminMergeResponse& AdminMergeResponse::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_cockroach_2fproto_2fapi_2eproto();
  return *default_instance_;
}

AdminMergeResponse* AdminMergeResponse::default_instance_ = NULL;

AdminMergeResponse* AdminMergeResponse::New(::google::protobuf::Arena* arena) const {
  AdminMergeResponse* n = new AdminMergeResponse;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void AdminMergeResponse::Clear() {
  if (has_kvheader()) {
    if (kvheader_ != NULL) kvheader_->::cockroach::proto::KVResponseHeader::Clear();
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool AdminMergeResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:cockroach.proto.AdminMergeResponse)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .cockroach.proto.KVResponseHeader kvheader = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_kvheader()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:cockroach.proto.AdminMergeResponse)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:cockroach.proto.AdminMergeResponse)
  return false;
#undef DO_
}

void AdminMergeResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:cockroach.proto.AdminMergeResponse)
  // optional .cockroach.proto.KVResponseHeader kvheader = 1;
  if (has_kvheader()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->kvheader_, output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:cockroach.proto.AdminMergeResponse)
}

::google::protobuf::uint8* AdminMergeResponse::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:cockroach.proto.AdminMergeResponse)
  // optional .cockroach.proto.KVResponseHeader kvheader = 1;
  if (has_kvheader()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, *this->kvheader_, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:cockroach.proto.AdminMergeResponse)
  return target;
}

int AdminMergeResponse::ByteSize() const {
  int total_size = 0;

  // optional .cockroach.proto.KVResponseHeader kvheader = 1;
  if (has_kvheader()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->kvheader_);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void AdminMergeResponse::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const AdminMergeResponse* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const AdminMergeResponse>(
          &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void AdminMergeResponse::MergeFrom(const AdminMergeResponse& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_kvheader()) {
      mutable_kvheader()->::cockroach::proto::KVResponseHeader::MergeFrom(from.kvheader());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void AdminMergeResponse::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void AdminMergeResponse::CopyFrom(const AdminMergeResponse& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AdminMergeResponse::IsInitialized() const {

  return true;
}

void AdminMergeResponse::Swap(AdminMergeResponse* other) {
  if (other == this) return;
  InternalSwap(other);
}
void AdminMergeResponse::InternalSwap(AdminMergeResponse* other) {
  std::swap(kvheader_, other->kvheader_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata AdminMergeResponse::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = AdminMergeResponse_descriptor_;
  metadata.reflection = AdminMergeResponse_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// AdminMergeResponse

// optional .cockroach.proto.KVResponseHeader kvheader = 1;
bool AdminMergeResponse::has_kvheader() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void AdminMergeResponse::set_has_kvheader() {
  _has_bits_[0] |= 0x00000001u;
}
void AdminMergeResponse::clear_has_kvheader() {
  _has_bits_[0] &= ~0x00000001u;
}
void AdminMergeResponse::clear_kvheader() {
  if (kvheader_ != NULL) kvheader_->::cockroach::proto::KVResponseHeader::Clear();
  clear_has_kvheader();
}
 const ::cockroach::proto::KVResponseHeader& AdminMergeResponse::kvheader() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.AdminMergeResponse.kvheader)
  return kvheader_ != NULL ? *kvheader_ : *default_instance_->kvheader_;
}
 ::cockroach::proto::KVResponseHeader* AdminMergeResponse::mutable_kvheader() {
  set_has_kvheader();
  if (kvheader_ == NULL) {
    kvheader_ = new ::cockroach::proto::KVResponseHeader;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.proto.AdminMergeResponse.kvheader)
  return kvheader_;
}
 ::cockroach::proto::KVResponseHeader* AdminMergeResponse::release_kvheader() {
  clear_has_kvheader();
  ::cockroach::proto::KVResponseHeader* temp = kvheader_;
  kvheader_ = NULL;
  return temp;
}
 void AdminMergeResponse::set_allocated_kvheader(::cockroach::proto::KVResponseHeader* kvheader) {
  delete kvheader_;
  kvheader_ = kvheader;
  if (kvheader) {
    set_has_kvheader();
  } else {
    clear_has_kvheader();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.AdminMergeResponse.kvheader)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// @@protoc_insertion_point(namespace_scope)

}  // namespace proto
}  // namespace cockroach

// @@protoc_insertion_point(global_scope)
