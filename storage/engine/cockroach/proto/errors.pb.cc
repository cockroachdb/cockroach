// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: cockroach/proto/errors.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "cockroach/proto/errors.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)

namespace cockroach {
namespace proto {

namespace {

const ::google::protobuf::Descriptor* NotLeaderError_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  NotLeaderError_reflection_ = NULL;
const ::google::protobuf::Descriptor* RangeNotFoundError_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  RangeNotFoundError_reflection_ = NULL;
const ::google::protobuf::Descriptor* RangeKeyMismatchError_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  RangeKeyMismatchError_reflection_ = NULL;
const ::google::protobuf::Descriptor* ReadWithinUncertaintyIntervalError_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ReadWithinUncertaintyIntervalError_reflection_ = NULL;
const ::google::protobuf::Descriptor* TransactionAbortedError_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  TransactionAbortedError_reflection_ = NULL;
const ::google::protobuf::Descriptor* TransactionPushError_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  TransactionPushError_reflection_ = NULL;
const ::google::protobuf::Descriptor* TransactionRetryError_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  TransactionRetryError_reflection_ = NULL;
const ::google::protobuf::Descriptor* TransactionStatusError_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  TransactionStatusError_reflection_ = NULL;
const ::google::protobuf::Descriptor* WriteIntentError_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  WriteIntentError_reflection_ = NULL;
const ::google::protobuf::Descriptor* WriteTooOldError_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  WriteTooOldError_reflection_ = NULL;
const ::google::protobuf::Descriptor* OpRequiresTxnError_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  OpRequiresTxnError_reflection_ = NULL;
const ::google::protobuf::Descriptor* ConditionFailedError_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ConditionFailedError_reflection_ = NULL;
const ::google::protobuf::Descriptor* LeaseRejectedError_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  LeaseRejectedError_reflection_ = NULL;
const ::google::protobuf::Descriptor* ErrorDetail_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ErrorDetail_reflection_ = NULL;
struct ErrorDetailOneofInstance {
  const ::cockroach::proto::NotLeaderError* not_leader_;
  const ::cockroach::proto::RangeNotFoundError* range_not_found_;
  const ::cockroach::proto::RangeKeyMismatchError* range_key_mismatch_;
  const ::cockroach::proto::ReadWithinUncertaintyIntervalError* read_within_uncertainty_interval_;
  const ::cockroach::proto::TransactionAbortedError* transaction_aborted_;
  const ::cockroach::proto::TransactionPushError* transaction_push_;
  const ::cockroach::proto::TransactionRetryError* transaction_retry_;
  const ::cockroach::proto::TransactionStatusError* transaction_status_;
  const ::cockroach::proto::WriteIntentError* write_intent_;
  const ::cockroach::proto::WriteTooOldError* write_too_old_;
  const ::cockroach::proto::OpRequiresTxnError* op_requires_txn_;
  const ::cockroach::proto::ConditionFailedError* condition_failed_;
  const ::cockroach::proto::LeaseRejectedError* lease_rejected_;
}* ErrorDetail_default_oneof_instance_ = NULL;
const ::google::protobuf::Descriptor* Error_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Error_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* TransactionRestart_descriptor_ = NULL;

}  // namespace


void protobuf_AssignDesc_cockroach_2fproto_2ferrors_2eproto() {
  protobuf_AddDesc_cockroach_2fproto_2ferrors_2eproto();
  const ::google::protobuf::FileDescriptor* file =
    ::google::protobuf::DescriptorPool::generated_pool()->FindFileByName(
      "cockroach/proto/errors.proto");
  GOOGLE_CHECK(file != NULL);
  NotLeaderError_descriptor_ = file->message_type(0);
  static const int NotLeaderError_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NotLeaderError, replica_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NotLeaderError, leader_),
  };
  NotLeaderError_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      NotLeaderError_descriptor_,
      NotLeaderError::default_instance_,
      NotLeaderError_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NotLeaderError, _has_bits_[0]),
      -1,
      -1,
      sizeof(NotLeaderError),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NotLeaderError, _internal_metadata_),
      -1);
  RangeNotFoundError_descriptor_ = file->message_type(1);
  static const int RangeNotFoundError_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RangeNotFoundError, raft_id_),
  };
  RangeNotFoundError_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      RangeNotFoundError_descriptor_,
      RangeNotFoundError::default_instance_,
      RangeNotFoundError_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RangeNotFoundError, _has_bits_[0]),
      -1,
      -1,
      sizeof(RangeNotFoundError),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RangeNotFoundError, _internal_metadata_),
      -1);
  RangeKeyMismatchError_descriptor_ = file->message_type(2);
  static const int RangeKeyMismatchError_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RangeKeyMismatchError, request_start_key_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RangeKeyMismatchError, request_end_key_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RangeKeyMismatchError, range_),
  };
  RangeKeyMismatchError_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      RangeKeyMismatchError_descriptor_,
      RangeKeyMismatchError::default_instance_,
      RangeKeyMismatchError_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RangeKeyMismatchError, _has_bits_[0]),
      -1,
      -1,
      sizeof(RangeKeyMismatchError),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RangeKeyMismatchError, _internal_metadata_),
      -1);
  ReadWithinUncertaintyIntervalError_descriptor_ = file->message_type(3);
  static const int ReadWithinUncertaintyIntervalError_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReadWithinUncertaintyIntervalError, timestamp_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReadWithinUncertaintyIntervalError, existing_timestamp_),
  };
  ReadWithinUncertaintyIntervalError_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      ReadWithinUncertaintyIntervalError_descriptor_,
      ReadWithinUncertaintyIntervalError::default_instance_,
      ReadWithinUncertaintyIntervalError_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReadWithinUncertaintyIntervalError, _has_bits_[0]),
      -1,
      -1,
      sizeof(ReadWithinUncertaintyIntervalError),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReadWithinUncertaintyIntervalError, _internal_metadata_),
      -1);
  TransactionAbortedError_descriptor_ = file->message_type(4);
  static const int TransactionAbortedError_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TransactionAbortedError, txn_),
  };
  TransactionAbortedError_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      TransactionAbortedError_descriptor_,
      TransactionAbortedError::default_instance_,
      TransactionAbortedError_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TransactionAbortedError, _has_bits_[0]),
      -1,
      -1,
      sizeof(TransactionAbortedError),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TransactionAbortedError, _internal_metadata_),
      -1);
  TransactionPushError_descriptor_ = file->message_type(5);
  static const int TransactionPushError_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TransactionPushError, txn_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TransactionPushError, pushee_txn_),
  };
  TransactionPushError_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      TransactionPushError_descriptor_,
      TransactionPushError::default_instance_,
      TransactionPushError_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TransactionPushError, _has_bits_[0]),
      -1,
      -1,
      sizeof(TransactionPushError),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TransactionPushError, _internal_metadata_),
      -1);
  TransactionRetryError_descriptor_ = file->message_type(6);
  static const int TransactionRetryError_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TransactionRetryError, txn_),
  };
  TransactionRetryError_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      TransactionRetryError_descriptor_,
      TransactionRetryError::default_instance_,
      TransactionRetryError_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TransactionRetryError, _has_bits_[0]),
      -1,
      -1,
      sizeof(TransactionRetryError),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TransactionRetryError, _internal_metadata_),
      -1);
  TransactionStatusError_descriptor_ = file->message_type(7);
  static const int TransactionStatusError_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TransactionStatusError, txn_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TransactionStatusError, msg_),
  };
  TransactionStatusError_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      TransactionStatusError_descriptor_,
      TransactionStatusError::default_instance_,
      TransactionStatusError_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TransactionStatusError, _has_bits_[0]),
      -1,
      -1,
      sizeof(TransactionStatusError),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TransactionStatusError, _internal_metadata_),
      -1);
  WriteIntentError_descriptor_ = file->message_type(8);
  static const int WriteIntentError_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(WriteIntentError, intents_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(WriteIntentError, resolved_),
  };
  WriteIntentError_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      WriteIntentError_descriptor_,
      WriteIntentError::default_instance_,
      WriteIntentError_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(WriteIntentError, _has_bits_[0]),
      -1,
      -1,
      sizeof(WriteIntentError),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(WriteIntentError, _internal_metadata_),
      -1);
  WriteTooOldError_descriptor_ = file->message_type(9);
  static const int WriteTooOldError_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(WriteTooOldError, timestamp_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(WriteTooOldError, existing_timestamp_),
  };
  WriteTooOldError_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      WriteTooOldError_descriptor_,
      WriteTooOldError::default_instance_,
      WriteTooOldError_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(WriteTooOldError, _has_bits_[0]),
      -1,
      -1,
      sizeof(WriteTooOldError),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(WriteTooOldError, _internal_metadata_),
      -1);
  OpRequiresTxnError_descriptor_ = file->message_type(10);
  static const int OpRequiresTxnError_offsets_[1] = {
  };
  OpRequiresTxnError_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      OpRequiresTxnError_descriptor_,
      OpRequiresTxnError::default_instance_,
      OpRequiresTxnError_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(OpRequiresTxnError, _has_bits_[0]),
      -1,
      -1,
      sizeof(OpRequiresTxnError),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(OpRequiresTxnError, _internal_metadata_),
      -1);
  ConditionFailedError_descriptor_ = file->message_type(11);
  static const int ConditionFailedError_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ConditionFailedError, actual_value_),
  };
  ConditionFailedError_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      ConditionFailedError_descriptor_,
      ConditionFailedError::default_instance_,
      ConditionFailedError_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ConditionFailedError, _has_bits_[0]),
      -1,
      -1,
      sizeof(ConditionFailedError),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ConditionFailedError, _internal_metadata_),
      -1);
  LeaseRejectedError_descriptor_ = file->message_type(12);
  static const int LeaseRejectedError_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LeaseRejectedError, requested_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LeaseRejectedError, existing_),
  };
  LeaseRejectedError_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      LeaseRejectedError_descriptor_,
      LeaseRejectedError::default_instance_,
      LeaseRejectedError_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LeaseRejectedError, _has_bits_[0]),
      -1,
      -1,
      sizeof(LeaseRejectedError),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LeaseRejectedError, _internal_metadata_),
      -1);
  ErrorDetail_descriptor_ = file->message_type(13);
  static const int ErrorDetail_offsets_[14] = {
    PROTO2_GENERATED_DEFAULT_ONEOF_FIELD_OFFSET(ErrorDetail_default_oneof_instance_, not_leader_),
    PROTO2_GENERATED_DEFAULT_ONEOF_FIELD_OFFSET(ErrorDetail_default_oneof_instance_, range_not_found_),
    PROTO2_GENERATED_DEFAULT_ONEOF_FIELD_OFFSET(ErrorDetail_default_oneof_instance_, range_key_mismatch_),
    PROTO2_GENERATED_DEFAULT_ONEOF_FIELD_OFFSET(ErrorDetail_default_oneof_instance_, read_within_uncertainty_interval_),
    PROTO2_GENERATED_DEFAULT_ONEOF_FIELD_OFFSET(ErrorDetail_default_oneof_instance_, transaction_aborted_),
    PROTO2_GENERATED_DEFAULT_ONEOF_FIELD_OFFSET(ErrorDetail_default_oneof_instance_, transaction_push_),
    PROTO2_GENERATED_DEFAULT_ONEOF_FIELD_OFFSET(ErrorDetail_default_oneof_instance_, transaction_retry_),
    PROTO2_GENERATED_DEFAULT_ONEOF_FIELD_OFFSET(ErrorDetail_default_oneof_instance_, transaction_status_),
    PROTO2_GENERATED_DEFAULT_ONEOF_FIELD_OFFSET(ErrorDetail_default_oneof_instance_, write_intent_),
    PROTO2_GENERATED_DEFAULT_ONEOF_FIELD_OFFSET(ErrorDetail_default_oneof_instance_, write_too_old_),
    PROTO2_GENERATED_DEFAULT_ONEOF_FIELD_OFFSET(ErrorDetail_default_oneof_instance_, op_requires_txn_),
    PROTO2_GENERATED_DEFAULT_ONEOF_FIELD_OFFSET(ErrorDetail_default_oneof_instance_, condition_failed_),
    PROTO2_GENERATED_DEFAULT_ONEOF_FIELD_OFFSET(ErrorDetail_default_oneof_instance_, lease_rejected_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ErrorDetail, value_),
  };
  ErrorDetail_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      ErrorDetail_descriptor_,
      ErrorDetail::default_instance_,
      ErrorDetail_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ErrorDetail, _has_bits_[0]),
      -1,
      -1,
      ErrorDetail_default_oneof_instance_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ErrorDetail, _oneof_case_[0]),
      sizeof(ErrorDetail),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ErrorDetail, _internal_metadata_),
      -1);
  Error_descriptor_ = file->message_type(14);
  static const int Error_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Error, message_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Error, retryable_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Error, transaction_restart_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Error, detail_),
  };
  Error_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      Error_descriptor_,
      Error::default_instance_,
      Error_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Error, _has_bits_[0]),
      -1,
      -1,
      sizeof(Error),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Error, _internal_metadata_),
      -1);
  TransactionRestart_descriptor_ = file->enum_type(0);
}

namespace {

GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AssignDescriptors_once_);
inline void protobuf_AssignDescriptorsOnce() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AssignDescriptors_once_,
                 &protobuf_AssignDesc_cockroach_2fproto_2ferrors_2eproto);
}

void protobuf_RegisterTypes(const ::std::string&) {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      NotLeaderError_descriptor_, &NotLeaderError::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      RangeNotFoundError_descriptor_, &RangeNotFoundError::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      RangeKeyMismatchError_descriptor_, &RangeKeyMismatchError::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      ReadWithinUncertaintyIntervalError_descriptor_, &ReadWithinUncertaintyIntervalError::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      TransactionAbortedError_descriptor_, &TransactionAbortedError::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      TransactionPushError_descriptor_, &TransactionPushError::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      TransactionRetryError_descriptor_, &TransactionRetryError::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      TransactionStatusError_descriptor_, &TransactionStatusError::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      WriteIntentError_descriptor_, &WriteIntentError::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      WriteTooOldError_descriptor_, &WriteTooOldError::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      OpRequiresTxnError_descriptor_, &OpRequiresTxnError::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      ConditionFailedError_descriptor_, &ConditionFailedError::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      LeaseRejectedError_descriptor_, &LeaseRejectedError::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      ErrorDetail_descriptor_, &ErrorDetail::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      Error_descriptor_, &Error::default_instance());
}

}  // namespace

void protobuf_ShutdownFile_cockroach_2fproto_2ferrors_2eproto() {
  delete NotLeaderError::default_instance_;
  delete NotLeaderError_reflection_;
  delete RangeNotFoundError::default_instance_;
  delete RangeNotFoundError_reflection_;
  delete RangeKeyMismatchError::default_instance_;
  delete RangeKeyMismatchError_reflection_;
  delete ReadWithinUncertaintyIntervalError::default_instance_;
  delete ReadWithinUncertaintyIntervalError_reflection_;
  delete TransactionAbortedError::default_instance_;
  delete TransactionAbortedError_reflection_;
  delete TransactionPushError::default_instance_;
  delete TransactionPushError_reflection_;
  delete TransactionRetryError::default_instance_;
  delete TransactionRetryError_reflection_;
  delete TransactionStatusError::default_instance_;
  delete TransactionStatusError_reflection_;
  delete WriteIntentError::default_instance_;
  delete WriteIntentError_reflection_;
  delete WriteTooOldError::default_instance_;
  delete WriteTooOldError_reflection_;
  delete OpRequiresTxnError::default_instance_;
  delete OpRequiresTxnError_reflection_;
  delete ConditionFailedError::default_instance_;
  delete ConditionFailedError_reflection_;
  delete LeaseRejectedError::default_instance_;
  delete LeaseRejectedError_reflection_;
  delete ErrorDetail::default_instance_;
  delete ErrorDetail_default_oneof_instance_;
  delete ErrorDetail_reflection_;
  delete Error::default_instance_;
  delete Error_reflection_;
}

void protobuf_AddDesc_cockroach_2fproto_2ferrors_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  ::cockroach::proto::protobuf_AddDesc_cockroach_2fproto_2fconfig_2eproto();
  ::cockroach::proto::protobuf_AddDesc_cockroach_2fproto_2fdata_2eproto();
  ::gogoproto::protobuf_AddDesc_gogoproto_2fgogo_2eproto();
  ::google::protobuf::DescriptorPool::InternalAddGeneratedFile(
    "\n\034cockroach/proto/errors.proto\022\017cockroac"
    "h.proto\032\034cockroach/proto/config.proto\032\032c"
    "ockroach/proto/data.proto\032\024gogoproto/gog"
    "o.proto\"e\n\016NotLeaderError\022)\n\007replica\030\001 \001"
    "(\0132\030.cockroach.proto.Replica\022(\n\006leader\030\002"
    " \001(\0132\030.cockroach.proto.Replica\"\?\n\022RangeN"
    "otFoundError\022)\n\007raft_id\030\001 \001(\003B\030\310\336\037\000\342\336\037\006R"
    "aftID\372\336\037\006RaftID\"\216\001\n\025RangeKeyMismatchErro"
    "r\022\"\n\021request_start_key\030\001 \001(\014B\007\372\336\037\003Key\022 \n"
    "\017request_end_key\030\002 \001(\014B\007\372\336\037\003Key\022/\n\005range"
    "\030\003 \001(\0132 .cockroach.proto.RangeDescriptor"
    "\"\227\001\n\"ReadWithinUncertaintyIntervalError\022"
    "3\n\ttimestamp\030\001 \001(\0132\032.cockroach.proto.Tim"
    "estampB\004\310\336\037\000\022<\n\022existing_timestamp\030\002 \001(\013"
    "2\032.cockroach.proto.TimestampB\004\310\336\037\000\"J\n\027Tr"
    "ansactionAbortedError\022/\n\003txn\030\001 \001(\0132\034.coc"
    "kroach.proto.TransactionB\004\310\336\037\000\"y\n\024Transa"
    "ctionPushError\022)\n\003txn\030\001 \001(\0132\034.cockroach."
    "proto.Transaction\0226\n\npushee_txn\030\002 \001(\0132\034."
    "cockroach.proto.TransactionB\004\310\336\037\000\"H\n\025Tra"
    "nsactionRetryError\022/\n\003txn\030\001 \001(\0132\034.cockro"
    "ach.proto.TransactionB\004\310\336\037\000\"\\\n\026Transacti"
    "onStatusError\022/\n\003txn\030\001 \001(\0132\034.cockroach.p"
    "roto.TransactionB\004\310\336\037\000\022\021\n\003msg\030\002 \001(\tB\004\310\336\037"
    "\000\"Z\n\020WriteIntentError\022.\n\007intents\030\001 \003(\0132\027"
    ".cockroach.proto.IntentB\004\310\336\037\000\022\026\n\010resolve"
    "d\030\002 \001(\010B\004\310\336\037\000\"\205\001\n\020WriteTooOldError\0223\n\tti"
    "mestamp\030\001 \001(\0132\032.cockroach.proto.Timestam"
    "pB\004\310\336\037\000\022<\n\022existing_timestamp\030\002 \001(\0132\032.co"
    "ckroach.proto.TimestampB\004\310\336\037\000\"\024\n\022OpRequi"
    "resTxnError\"D\n\024ConditionFailedError\022,\n\014a"
    "ctual_value\030\001 \001(\0132\026.cockroach.proto.Valu"
    "e\"u\n\022LeaseRejectedError\022/\n\tRequested\030\001 \001"
    "(\0132\026.cockroach.proto.LeaseB\004\310\336\037\000\022.\n\010Exis"
    "ting\030\002 \001(\0132\026.cockroach.proto.LeaseB\004\310\336\037\000"
    "\"\213\007\n\013ErrorDetail\0225\n\nnot_leader\030\001 \001(\0132\037.c"
    "ockroach.proto.NotLeaderErrorH\000\022>\n\017range"
    "_not_found\030\002 \001(\0132#.cockroach.proto.Range"
    "NotFoundErrorH\000\022D\n\022range_key_mismatch\030\003 "
    "\001(\0132&.cockroach.proto.RangeKeyMismatchEr"
    "rorH\000\022_\n read_within_uncertainty_interva"
    "l\030\004 \001(\01323.cockroach.proto.ReadWithinUnce"
    "rtaintyIntervalErrorH\000\022G\n\023transaction_ab"
    "orted\030\005 \001(\0132(.cockroach.proto.Transactio"
    "nAbortedErrorH\000\022A\n\020transaction_push\030\006 \001("
    "\0132%.cockroach.proto.TransactionPushError"
    "H\000\022C\n\021transaction_retry\030\007 \001(\0132&.cockroac"
    "h.proto.TransactionRetryErrorH\000\022E\n\022trans"
    "action_status\030\010 \001(\0132\'.cockroach.proto.Tr"
    "ansactionStatusErrorH\000\0229\n\014write_intent\030\t"
    " \001(\0132!.cockroach.proto.WriteIntentErrorH"
    "\000\022:\n\rwrite_too_old\030\n \001(\0132!.cockroach.pro"
    "to.WriteTooOldErrorH\000\022>\n\017op_requires_txn"
    "\030\013 \001(\0132#.cockroach.proto.OpRequiresTxnEr"
    "rorH\000\022A\n\020condition_failed\030\014 \001(\0132%.cockro"
    "ach.proto.ConditionFailedErrorH\000\022=\n\016leas"
    "e_rejected\030\r \001(\0132#.cockroach.proto.Lease"
    "RejectedErrorH\000:\004\310\240\037\001B\007\n\005value\"\255\001\n\005Error"
    "\022\025\n\007message\030\001 \001(\tB\004\310\336\037\000\022\027\n\tretryable\030\002 \001"
    "(\010B\004\310\336\037\000\022F\n\023transaction_restart\030\004 \001(\0162#."
    "cockroach.proto.TransactionRestartB\004\310\336\037\000"
    "\022,\n\006detail\030\003 \001(\0132\034.cockroach.proto.Error"
    "Detail*;\n\022TransactionRestart\022\t\n\005ABORT\020\000\022"
    "\013\n\007BACKOFF\020\001\022\r\n\tIMMEDIATE\020\002B\013Z\005proto\330\341\036\000", 2560);
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedFile(
    "cockroach/proto/errors.proto", &protobuf_RegisterTypes);
  NotLeaderError::default_instance_ = new NotLeaderError();
  RangeNotFoundError::default_instance_ = new RangeNotFoundError();
  RangeKeyMismatchError::default_instance_ = new RangeKeyMismatchError();
  ReadWithinUncertaintyIntervalError::default_instance_ = new ReadWithinUncertaintyIntervalError();
  TransactionAbortedError::default_instance_ = new TransactionAbortedError();
  TransactionPushError::default_instance_ = new TransactionPushError();
  TransactionRetryError::default_instance_ = new TransactionRetryError();
  TransactionStatusError::default_instance_ = new TransactionStatusError();
  WriteIntentError::default_instance_ = new WriteIntentError();
  WriteTooOldError::default_instance_ = new WriteTooOldError();
  OpRequiresTxnError::default_instance_ = new OpRequiresTxnError();
  ConditionFailedError::default_instance_ = new ConditionFailedError();
  LeaseRejectedError::default_instance_ = new LeaseRejectedError();
  ErrorDetail::default_instance_ = new ErrorDetail();
  ErrorDetail_default_oneof_instance_ = new ErrorDetailOneofInstance();
  Error::default_instance_ = new Error();
  NotLeaderError::default_instance_->InitAsDefaultInstance();
  RangeNotFoundError::default_instance_->InitAsDefaultInstance();
  RangeKeyMismatchError::default_instance_->InitAsDefaultInstance();
  ReadWithinUncertaintyIntervalError::default_instance_->InitAsDefaultInstance();
  TransactionAbortedError::default_instance_->InitAsDefaultInstance();
  TransactionPushError::default_instance_->InitAsDefaultInstance();
  TransactionRetryError::default_instance_->InitAsDefaultInstance();
  TransactionStatusError::default_instance_->InitAsDefaultInstance();
  WriteIntentError::default_instance_->InitAsDefaultInstance();
  WriteTooOldError::default_instance_->InitAsDefaultInstance();
  OpRequiresTxnError::default_instance_->InitAsDefaultInstance();
  ConditionFailedError::default_instance_->InitAsDefaultInstance();
  LeaseRejectedError::default_instance_->InitAsDefaultInstance();
  ErrorDetail::default_instance_->InitAsDefaultInstance();
  Error::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_cockroach_2fproto_2ferrors_2eproto);
}

// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_cockroach_2fproto_2ferrors_2eproto {
  StaticDescriptorInitializer_cockroach_2fproto_2ferrors_2eproto() {
    protobuf_AddDesc_cockroach_2fproto_2ferrors_2eproto();
  }
} static_descriptor_initializer_cockroach_2fproto_2ferrors_2eproto_;
const ::google::protobuf::EnumDescriptor* TransactionRestart_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return TransactionRestart_descriptor_;
}
bool TransactionRestart_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}


namespace {

static void MergeFromFail(int line) GOOGLE_ATTRIBUTE_COLD;
static void MergeFromFail(int line) {
  GOOGLE_CHECK(false) << __FILE__ << ":" << line;
}

}  // namespace


// ===================================================================

#ifndef _MSC_VER
const int NotLeaderError::kReplicaFieldNumber;
const int NotLeaderError::kLeaderFieldNumber;
#endif  // !_MSC_VER

NotLeaderError::NotLeaderError()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:cockroach.proto.NotLeaderError)
}

void NotLeaderError::InitAsDefaultInstance() {
  replica_ = const_cast< ::cockroach::proto::Replica*>(&::cockroach::proto::Replica::default_instance());
  leader_ = const_cast< ::cockroach::proto::Replica*>(&::cockroach::proto::Replica::default_instance());
}

NotLeaderError::NotLeaderError(const NotLeaderError& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:cockroach.proto.NotLeaderError)
}

void NotLeaderError::SharedCtor() {
  _cached_size_ = 0;
  replica_ = NULL;
  leader_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

NotLeaderError::~NotLeaderError() {
  // @@protoc_insertion_point(destructor:cockroach.proto.NotLeaderError)
  SharedDtor();
}

void NotLeaderError::SharedDtor() {
  if (this != default_instance_) {
    delete replica_;
    delete leader_;
  }
}

void NotLeaderError::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* NotLeaderError::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return NotLeaderError_descriptor_;
}

const NotLeaderError& NotLeaderError::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_cockroach_2fproto_2ferrors_2eproto();
  return *default_instance_;
}

NotLeaderError* NotLeaderError::default_instance_ = NULL;

NotLeaderError* NotLeaderError::New(::google::protobuf::Arena* arena) const {
  NotLeaderError* n = new NotLeaderError;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void NotLeaderError::Clear() {
  if (_has_bits_[0 / 32] & 3u) {
    if (has_replica()) {
      if (replica_ != NULL) replica_->::cockroach::proto::Replica::Clear();
    }
    if (has_leader()) {
      if (leader_ != NULL) leader_->::cockroach::proto::Replica::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool NotLeaderError::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:cockroach.proto.NotLeaderError)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .cockroach.proto.Replica replica = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_replica()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_leader;
        break;
      }

      // optional .cockroach.proto.Replica leader = 2;
      case 2: {
        if (tag == 18) {
         parse_leader:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_leader()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:cockroach.proto.NotLeaderError)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:cockroach.proto.NotLeaderError)
  return false;
#undef DO_
}

void NotLeaderError::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:cockroach.proto.NotLeaderError)
  // optional .cockroach.proto.Replica replica = 1;
  if (has_replica()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->replica_, output);
  }

  // optional .cockroach.proto.Replica leader = 2;
  if (has_leader()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, *this->leader_, output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:cockroach.proto.NotLeaderError)
}

::google::protobuf::uint8* NotLeaderError::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:cockroach.proto.NotLeaderError)
  // optional .cockroach.proto.Replica replica = 1;
  if (has_replica()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, *this->replica_, target);
  }

  // optional .cockroach.proto.Replica leader = 2;
  if (has_leader()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, *this->leader_, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:cockroach.proto.NotLeaderError)
  return target;
}

int NotLeaderError::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & 3) {
    // optional .cockroach.proto.Replica replica = 1;
    if (has_replica()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->replica_);
    }

    // optional .cockroach.proto.Replica leader = 2;
    if (has_leader()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->leader_);
    }

  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void NotLeaderError::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const NotLeaderError* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const NotLeaderError>(
          &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void NotLeaderError::MergeFrom(const NotLeaderError& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_replica()) {
      mutable_replica()->::cockroach::proto::Replica::MergeFrom(from.replica());
    }
    if (from.has_leader()) {
      mutable_leader()->::cockroach::proto::Replica::MergeFrom(from.leader());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void NotLeaderError::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void NotLeaderError::CopyFrom(const NotLeaderError& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NotLeaderError::IsInitialized() const {

  return true;
}

void NotLeaderError::Swap(NotLeaderError* other) {
  if (other == this) return;
  InternalSwap(other);
}
void NotLeaderError::InternalSwap(NotLeaderError* other) {
  std::swap(replica_, other->replica_);
  std::swap(leader_, other->leader_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata NotLeaderError::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = NotLeaderError_descriptor_;
  metadata.reflection = NotLeaderError_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// NotLeaderError

// optional .cockroach.proto.Replica replica = 1;
bool NotLeaderError::has_replica() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void NotLeaderError::set_has_replica() {
  _has_bits_[0] |= 0x00000001u;
}
void NotLeaderError::clear_has_replica() {
  _has_bits_[0] &= ~0x00000001u;
}
void NotLeaderError::clear_replica() {
  if (replica_ != NULL) replica_->::cockroach::proto::Replica::Clear();
  clear_has_replica();
}
 const ::cockroach::proto::Replica& NotLeaderError::replica() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.NotLeaderError.replica)
  return replica_ != NULL ? *replica_ : *default_instance_->replica_;
}
 ::cockroach::proto::Replica* NotLeaderError::mutable_replica() {
  set_has_replica();
  if (replica_ == NULL) {
    replica_ = new ::cockroach::proto::Replica;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.proto.NotLeaderError.replica)
  return replica_;
}
 ::cockroach::proto::Replica* NotLeaderError::release_replica() {
  clear_has_replica();
  ::cockroach::proto::Replica* temp = replica_;
  replica_ = NULL;
  return temp;
}
 void NotLeaderError::set_allocated_replica(::cockroach::proto::Replica* replica) {
  delete replica_;
  replica_ = replica;
  if (replica) {
    set_has_replica();
  } else {
    clear_has_replica();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.NotLeaderError.replica)
}

// optional .cockroach.proto.Replica leader = 2;
bool NotLeaderError::has_leader() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void NotLeaderError::set_has_leader() {
  _has_bits_[0] |= 0x00000002u;
}
void NotLeaderError::clear_has_leader() {
  _has_bits_[0] &= ~0x00000002u;
}
void NotLeaderError::clear_leader() {
  if (leader_ != NULL) leader_->::cockroach::proto::Replica::Clear();
  clear_has_leader();
}
 const ::cockroach::proto::Replica& NotLeaderError::leader() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.NotLeaderError.leader)
  return leader_ != NULL ? *leader_ : *default_instance_->leader_;
}
 ::cockroach::proto::Replica* NotLeaderError::mutable_leader() {
  set_has_leader();
  if (leader_ == NULL) {
    leader_ = new ::cockroach::proto::Replica;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.proto.NotLeaderError.leader)
  return leader_;
}
 ::cockroach::proto::Replica* NotLeaderError::release_leader() {
  clear_has_leader();
  ::cockroach::proto::Replica* temp = leader_;
  leader_ = NULL;
  return temp;
}
 void NotLeaderError::set_allocated_leader(::cockroach::proto::Replica* leader) {
  delete leader_;
  leader_ = leader;
  if (leader) {
    set_has_leader();
  } else {
    clear_has_leader();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.NotLeaderError.leader)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#ifndef _MSC_VER
const int RangeNotFoundError::kRaftIdFieldNumber;
#endif  // !_MSC_VER

RangeNotFoundError::RangeNotFoundError()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:cockroach.proto.RangeNotFoundError)
}

void RangeNotFoundError::InitAsDefaultInstance() {
}

RangeNotFoundError::RangeNotFoundError(const RangeNotFoundError& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:cockroach.proto.RangeNotFoundError)
}

void RangeNotFoundError::SharedCtor() {
  _cached_size_ = 0;
  raft_id_ = GOOGLE_LONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RangeNotFoundError::~RangeNotFoundError() {
  // @@protoc_insertion_point(destructor:cockroach.proto.RangeNotFoundError)
  SharedDtor();
}

void RangeNotFoundError::SharedDtor() {
  if (this != default_instance_) {
  }
}

void RangeNotFoundError::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* RangeNotFoundError::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return RangeNotFoundError_descriptor_;
}

const RangeNotFoundError& RangeNotFoundError::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_cockroach_2fproto_2ferrors_2eproto();
  return *default_instance_;
}

RangeNotFoundError* RangeNotFoundError::default_instance_ = NULL;

RangeNotFoundError* RangeNotFoundError::New(::google::protobuf::Arena* arena) const {
  RangeNotFoundError* n = new RangeNotFoundError;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void RangeNotFoundError::Clear() {
  raft_id_ = GOOGLE_LONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool RangeNotFoundError::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:cockroach.proto.RangeNotFoundError)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int64 raft_id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &raft_id_)));
          set_has_raft_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:cockroach.proto.RangeNotFoundError)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:cockroach.proto.RangeNotFoundError)
  return false;
#undef DO_
}

void RangeNotFoundError::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:cockroach.proto.RangeNotFoundError)
  // optional int64 raft_id = 1;
  if (has_raft_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(1, this->raft_id(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:cockroach.proto.RangeNotFoundError)
}

::google::protobuf::uint8* RangeNotFoundError::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:cockroach.proto.RangeNotFoundError)
  // optional int64 raft_id = 1;
  if (has_raft_id()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(1, this->raft_id(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:cockroach.proto.RangeNotFoundError)
  return target;
}

int RangeNotFoundError::ByteSize() const {
  int total_size = 0;

  // optional int64 raft_id = 1;
  if (has_raft_id()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int64Size(
        this->raft_id());
  }

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RangeNotFoundError::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const RangeNotFoundError* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const RangeNotFoundError>(
          &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void RangeNotFoundError::MergeFrom(const RangeNotFoundError& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_raft_id()) {
      set_raft_id(from.raft_id());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void RangeNotFoundError::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void RangeNotFoundError::CopyFrom(const RangeNotFoundError& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RangeNotFoundError::IsInitialized() const {

  return true;
}

void RangeNotFoundError::Swap(RangeNotFoundError* other) {
  if (other == this) return;
  InternalSwap(other);
}
void RangeNotFoundError::InternalSwap(RangeNotFoundError* other) {
  std::swap(raft_id_, other->raft_id_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata RangeNotFoundError::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = RangeNotFoundError_descriptor_;
  metadata.reflection = RangeNotFoundError_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// RangeNotFoundError

// optional int64 raft_id = 1;
bool RangeNotFoundError::has_raft_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void RangeNotFoundError::set_has_raft_id() {
  _has_bits_[0] |= 0x00000001u;
}
void RangeNotFoundError::clear_has_raft_id() {
  _has_bits_[0] &= ~0x00000001u;
}
void RangeNotFoundError::clear_raft_id() {
  raft_id_ = GOOGLE_LONGLONG(0);
  clear_has_raft_id();
}
 ::google::protobuf::int64 RangeNotFoundError::raft_id() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.RangeNotFoundError.raft_id)
  return raft_id_;
}
 void RangeNotFoundError::set_raft_id(::google::protobuf::int64 value) {
  set_has_raft_id();
  raft_id_ = value;
  // @@protoc_insertion_point(field_set:cockroach.proto.RangeNotFoundError.raft_id)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#ifndef _MSC_VER
const int RangeKeyMismatchError::kRequestStartKeyFieldNumber;
const int RangeKeyMismatchError::kRequestEndKeyFieldNumber;
const int RangeKeyMismatchError::kRangeFieldNumber;
#endif  // !_MSC_VER

RangeKeyMismatchError::RangeKeyMismatchError()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:cockroach.proto.RangeKeyMismatchError)
}

void RangeKeyMismatchError::InitAsDefaultInstance() {
  range_ = const_cast< ::cockroach::proto::RangeDescriptor*>(&::cockroach::proto::RangeDescriptor::default_instance());
}

RangeKeyMismatchError::RangeKeyMismatchError(const RangeKeyMismatchError& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:cockroach.proto.RangeKeyMismatchError)
}

void RangeKeyMismatchError::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  request_start_key_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  request_end_key_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  range_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RangeKeyMismatchError::~RangeKeyMismatchError() {
  // @@protoc_insertion_point(destructor:cockroach.proto.RangeKeyMismatchError)
  SharedDtor();
}

void RangeKeyMismatchError::SharedDtor() {
  request_start_key_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  request_end_key_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != default_instance_) {
    delete range_;
  }
}

void RangeKeyMismatchError::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* RangeKeyMismatchError::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return RangeKeyMismatchError_descriptor_;
}

const RangeKeyMismatchError& RangeKeyMismatchError::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_cockroach_2fproto_2ferrors_2eproto();
  return *default_instance_;
}

RangeKeyMismatchError* RangeKeyMismatchError::default_instance_ = NULL;

RangeKeyMismatchError* RangeKeyMismatchError::New(::google::protobuf::Arena* arena) const {
  RangeKeyMismatchError* n = new RangeKeyMismatchError;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void RangeKeyMismatchError::Clear() {
  if (_has_bits_[0 / 32] & 7u) {
    if (has_request_start_key()) {
      request_start_key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    if (has_request_end_key()) {
      request_end_key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    if (has_range()) {
      if (range_ != NULL) range_->::cockroach::proto::RangeDescriptor::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool RangeKeyMismatchError::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:cockroach.proto.RangeKeyMismatchError)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional bytes request_start_key = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_request_start_key()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_request_end_key;
        break;
      }

      // optional bytes request_end_key = 2;
      case 2: {
        if (tag == 18) {
         parse_request_end_key:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_request_end_key()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_range;
        break;
      }

      // optional .cockroach.proto.RangeDescriptor range = 3;
      case 3: {
        if (tag == 26) {
         parse_range:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_range()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:cockroach.proto.RangeKeyMismatchError)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:cockroach.proto.RangeKeyMismatchError)
  return false;
#undef DO_
}

void RangeKeyMismatchError::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:cockroach.proto.RangeKeyMismatchError)
  // optional bytes request_start_key = 1;
  if (has_request_start_key()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      1, this->request_start_key(), output);
  }

  // optional bytes request_end_key = 2;
  if (has_request_end_key()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      2, this->request_end_key(), output);
  }

  // optional .cockroach.proto.RangeDescriptor range = 3;
  if (has_range()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, *this->range_, output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:cockroach.proto.RangeKeyMismatchError)
}

::google::protobuf::uint8* RangeKeyMismatchError::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:cockroach.proto.RangeKeyMismatchError)
  // optional bytes request_start_key = 1;
  if (has_request_start_key()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        1, this->request_start_key(), target);
  }

  // optional bytes request_end_key = 2;
  if (has_request_end_key()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        2, this->request_end_key(), target);
  }

  // optional .cockroach.proto.RangeDescriptor range = 3;
  if (has_range()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, *this->range_, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:cockroach.proto.RangeKeyMismatchError)
  return target;
}

int RangeKeyMismatchError::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & 7) {
    // optional bytes request_start_key = 1;
    if (has_request_start_key()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->request_start_key());
    }

    // optional bytes request_end_key = 2;
    if (has_request_end_key()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->request_end_key());
    }

    // optional .cockroach.proto.RangeDescriptor range = 3;
    if (has_range()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->range_);
    }

  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RangeKeyMismatchError::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const RangeKeyMismatchError* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const RangeKeyMismatchError>(
          &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void RangeKeyMismatchError::MergeFrom(const RangeKeyMismatchError& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_request_start_key()) {
      set_has_request_start_key();
      request_start_key_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.request_start_key_);
    }
    if (from.has_request_end_key()) {
      set_has_request_end_key();
      request_end_key_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.request_end_key_);
    }
    if (from.has_range()) {
      mutable_range()->::cockroach::proto::RangeDescriptor::MergeFrom(from.range());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void RangeKeyMismatchError::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void RangeKeyMismatchError::CopyFrom(const RangeKeyMismatchError& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RangeKeyMismatchError::IsInitialized() const {

  return true;
}

void RangeKeyMismatchError::Swap(RangeKeyMismatchError* other) {
  if (other == this) return;
  InternalSwap(other);
}
void RangeKeyMismatchError::InternalSwap(RangeKeyMismatchError* other) {
  request_start_key_.Swap(&other->request_start_key_);
  request_end_key_.Swap(&other->request_end_key_);
  std::swap(range_, other->range_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata RangeKeyMismatchError::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = RangeKeyMismatchError_descriptor_;
  metadata.reflection = RangeKeyMismatchError_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// RangeKeyMismatchError

// optional bytes request_start_key = 1;
bool RangeKeyMismatchError::has_request_start_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void RangeKeyMismatchError::set_has_request_start_key() {
  _has_bits_[0] |= 0x00000001u;
}
void RangeKeyMismatchError::clear_has_request_start_key() {
  _has_bits_[0] &= ~0x00000001u;
}
void RangeKeyMismatchError::clear_request_start_key() {
  request_start_key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_request_start_key();
}
 const ::std::string& RangeKeyMismatchError::request_start_key() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.RangeKeyMismatchError.request_start_key)
  return request_start_key_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void RangeKeyMismatchError::set_request_start_key(const ::std::string& value) {
  set_has_request_start_key();
  request_start_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cockroach.proto.RangeKeyMismatchError.request_start_key)
}
 void RangeKeyMismatchError::set_request_start_key(const char* value) {
  set_has_request_start_key();
  request_start_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cockroach.proto.RangeKeyMismatchError.request_start_key)
}
 void RangeKeyMismatchError::set_request_start_key(const void* value, size_t size) {
  set_has_request_start_key();
  request_start_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cockroach.proto.RangeKeyMismatchError.request_start_key)
}
 ::std::string* RangeKeyMismatchError::mutable_request_start_key() {
  set_has_request_start_key();
  // @@protoc_insertion_point(field_mutable:cockroach.proto.RangeKeyMismatchError.request_start_key)
  return request_start_key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* RangeKeyMismatchError::release_request_start_key() {
  clear_has_request_start_key();
  return request_start_key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void RangeKeyMismatchError::set_allocated_request_start_key(::std::string* request_start_key) {
  if (request_start_key != NULL) {
    set_has_request_start_key();
  } else {
    clear_has_request_start_key();
  }
  request_start_key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), request_start_key);
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.RangeKeyMismatchError.request_start_key)
}

// optional bytes request_end_key = 2;
bool RangeKeyMismatchError::has_request_end_key() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void RangeKeyMismatchError::set_has_request_end_key() {
  _has_bits_[0] |= 0x00000002u;
}
void RangeKeyMismatchError::clear_has_request_end_key() {
  _has_bits_[0] &= ~0x00000002u;
}
void RangeKeyMismatchError::clear_request_end_key() {
  request_end_key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_request_end_key();
}
 const ::std::string& RangeKeyMismatchError::request_end_key() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.RangeKeyMismatchError.request_end_key)
  return request_end_key_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void RangeKeyMismatchError::set_request_end_key(const ::std::string& value) {
  set_has_request_end_key();
  request_end_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cockroach.proto.RangeKeyMismatchError.request_end_key)
}
 void RangeKeyMismatchError::set_request_end_key(const char* value) {
  set_has_request_end_key();
  request_end_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cockroach.proto.RangeKeyMismatchError.request_end_key)
}
 void RangeKeyMismatchError::set_request_end_key(const void* value, size_t size) {
  set_has_request_end_key();
  request_end_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cockroach.proto.RangeKeyMismatchError.request_end_key)
}
 ::std::string* RangeKeyMismatchError::mutable_request_end_key() {
  set_has_request_end_key();
  // @@protoc_insertion_point(field_mutable:cockroach.proto.RangeKeyMismatchError.request_end_key)
  return request_end_key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* RangeKeyMismatchError::release_request_end_key() {
  clear_has_request_end_key();
  return request_end_key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void RangeKeyMismatchError::set_allocated_request_end_key(::std::string* request_end_key) {
  if (request_end_key != NULL) {
    set_has_request_end_key();
  } else {
    clear_has_request_end_key();
  }
  request_end_key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), request_end_key);
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.RangeKeyMismatchError.request_end_key)
}

// optional .cockroach.proto.RangeDescriptor range = 3;
bool RangeKeyMismatchError::has_range() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void RangeKeyMismatchError::set_has_range() {
  _has_bits_[0] |= 0x00000004u;
}
void RangeKeyMismatchError::clear_has_range() {
  _has_bits_[0] &= ~0x00000004u;
}
void RangeKeyMismatchError::clear_range() {
  if (range_ != NULL) range_->::cockroach::proto::RangeDescriptor::Clear();
  clear_has_range();
}
 const ::cockroach::proto::RangeDescriptor& RangeKeyMismatchError::range() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.RangeKeyMismatchError.range)
  return range_ != NULL ? *range_ : *default_instance_->range_;
}
 ::cockroach::proto::RangeDescriptor* RangeKeyMismatchError::mutable_range() {
  set_has_range();
  if (range_ == NULL) {
    range_ = new ::cockroach::proto::RangeDescriptor;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.proto.RangeKeyMismatchError.range)
  return range_;
}
 ::cockroach::proto::RangeDescriptor* RangeKeyMismatchError::release_range() {
  clear_has_range();
  ::cockroach::proto::RangeDescriptor* temp = range_;
  range_ = NULL;
  return temp;
}
 void RangeKeyMismatchError::set_allocated_range(::cockroach::proto::RangeDescriptor* range) {
  delete range_;
  range_ = range;
  if (range) {
    set_has_range();
  } else {
    clear_has_range();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.RangeKeyMismatchError.range)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#ifndef _MSC_VER
const int ReadWithinUncertaintyIntervalError::kTimestampFieldNumber;
const int ReadWithinUncertaintyIntervalError::kExistingTimestampFieldNumber;
#endif  // !_MSC_VER

ReadWithinUncertaintyIntervalError::ReadWithinUncertaintyIntervalError()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:cockroach.proto.ReadWithinUncertaintyIntervalError)
}

void ReadWithinUncertaintyIntervalError::InitAsDefaultInstance() {
  timestamp_ = const_cast< ::cockroach::proto::Timestamp*>(&::cockroach::proto::Timestamp::default_instance());
  existing_timestamp_ = const_cast< ::cockroach::proto::Timestamp*>(&::cockroach::proto::Timestamp::default_instance());
}

ReadWithinUncertaintyIntervalError::ReadWithinUncertaintyIntervalError(const ReadWithinUncertaintyIntervalError& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:cockroach.proto.ReadWithinUncertaintyIntervalError)
}

void ReadWithinUncertaintyIntervalError::SharedCtor() {
  _cached_size_ = 0;
  timestamp_ = NULL;
  existing_timestamp_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ReadWithinUncertaintyIntervalError::~ReadWithinUncertaintyIntervalError() {
  // @@protoc_insertion_point(destructor:cockroach.proto.ReadWithinUncertaintyIntervalError)
  SharedDtor();
}

void ReadWithinUncertaintyIntervalError::SharedDtor() {
  if (this != default_instance_) {
    delete timestamp_;
    delete existing_timestamp_;
  }
}

void ReadWithinUncertaintyIntervalError::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ReadWithinUncertaintyIntervalError::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ReadWithinUncertaintyIntervalError_descriptor_;
}

const ReadWithinUncertaintyIntervalError& ReadWithinUncertaintyIntervalError::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_cockroach_2fproto_2ferrors_2eproto();
  return *default_instance_;
}

ReadWithinUncertaintyIntervalError* ReadWithinUncertaintyIntervalError::default_instance_ = NULL;

ReadWithinUncertaintyIntervalError* ReadWithinUncertaintyIntervalError::New(::google::protobuf::Arena* arena) const {
  ReadWithinUncertaintyIntervalError* n = new ReadWithinUncertaintyIntervalError;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void ReadWithinUncertaintyIntervalError::Clear() {
  if (_has_bits_[0 / 32] & 3u) {
    if (has_timestamp()) {
      if (timestamp_ != NULL) timestamp_->::cockroach::proto::Timestamp::Clear();
    }
    if (has_existing_timestamp()) {
      if (existing_timestamp_ != NULL) existing_timestamp_->::cockroach::proto::Timestamp::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool ReadWithinUncertaintyIntervalError::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:cockroach.proto.ReadWithinUncertaintyIntervalError)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .cockroach.proto.Timestamp timestamp = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_timestamp()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_existing_timestamp;
        break;
      }

      // optional .cockroach.proto.Timestamp existing_timestamp = 2;
      case 2: {
        if (tag == 18) {
         parse_existing_timestamp:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_existing_timestamp()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:cockroach.proto.ReadWithinUncertaintyIntervalError)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:cockroach.proto.ReadWithinUncertaintyIntervalError)
  return false;
#undef DO_
}

void ReadWithinUncertaintyIntervalError::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:cockroach.proto.ReadWithinUncertaintyIntervalError)
  // optional .cockroach.proto.Timestamp timestamp = 1;
  if (has_timestamp()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->timestamp_, output);
  }

  // optional .cockroach.proto.Timestamp existing_timestamp = 2;
  if (has_existing_timestamp()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, *this->existing_timestamp_, output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:cockroach.proto.ReadWithinUncertaintyIntervalError)
}

::google::protobuf::uint8* ReadWithinUncertaintyIntervalError::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:cockroach.proto.ReadWithinUncertaintyIntervalError)
  // optional .cockroach.proto.Timestamp timestamp = 1;
  if (has_timestamp()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, *this->timestamp_, target);
  }

  // optional .cockroach.proto.Timestamp existing_timestamp = 2;
  if (has_existing_timestamp()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, *this->existing_timestamp_, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:cockroach.proto.ReadWithinUncertaintyIntervalError)
  return target;
}

int ReadWithinUncertaintyIntervalError::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & 3) {
    // optional .cockroach.proto.Timestamp timestamp = 1;
    if (has_timestamp()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->timestamp_);
    }

    // optional .cockroach.proto.Timestamp existing_timestamp = 2;
    if (has_existing_timestamp()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->existing_timestamp_);
    }

  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ReadWithinUncertaintyIntervalError::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const ReadWithinUncertaintyIntervalError* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const ReadWithinUncertaintyIntervalError>(
          &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ReadWithinUncertaintyIntervalError::MergeFrom(const ReadWithinUncertaintyIntervalError& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_timestamp()) {
      mutable_timestamp()->::cockroach::proto::Timestamp::MergeFrom(from.timestamp());
    }
    if (from.has_existing_timestamp()) {
      mutable_existing_timestamp()->::cockroach::proto::Timestamp::MergeFrom(from.existing_timestamp());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void ReadWithinUncertaintyIntervalError::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ReadWithinUncertaintyIntervalError::CopyFrom(const ReadWithinUncertaintyIntervalError& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ReadWithinUncertaintyIntervalError::IsInitialized() const {

  return true;
}

void ReadWithinUncertaintyIntervalError::Swap(ReadWithinUncertaintyIntervalError* other) {
  if (other == this) return;
  InternalSwap(other);
}
void ReadWithinUncertaintyIntervalError::InternalSwap(ReadWithinUncertaintyIntervalError* other) {
  std::swap(timestamp_, other->timestamp_);
  std::swap(existing_timestamp_, other->existing_timestamp_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata ReadWithinUncertaintyIntervalError::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ReadWithinUncertaintyIntervalError_descriptor_;
  metadata.reflection = ReadWithinUncertaintyIntervalError_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// ReadWithinUncertaintyIntervalError

// optional .cockroach.proto.Timestamp timestamp = 1;
bool ReadWithinUncertaintyIntervalError::has_timestamp() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void ReadWithinUncertaintyIntervalError::set_has_timestamp() {
  _has_bits_[0] |= 0x00000001u;
}
void ReadWithinUncertaintyIntervalError::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000001u;
}
void ReadWithinUncertaintyIntervalError::clear_timestamp() {
  if (timestamp_ != NULL) timestamp_->::cockroach::proto::Timestamp::Clear();
  clear_has_timestamp();
}
 const ::cockroach::proto::Timestamp& ReadWithinUncertaintyIntervalError::timestamp() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.ReadWithinUncertaintyIntervalError.timestamp)
  return timestamp_ != NULL ? *timestamp_ : *default_instance_->timestamp_;
}
 ::cockroach::proto::Timestamp* ReadWithinUncertaintyIntervalError::mutable_timestamp() {
  set_has_timestamp();
  if (timestamp_ == NULL) {
    timestamp_ = new ::cockroach::proto::Timestamp;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.proto.ReadWithinUncertaintyIntervalError.timestamp)
  return timestamp_;
}
 ::cockroach::proto::Timestamp* ReadWithinUncertaintyIntervalError::release_timestamp() {
  clear_has_timestamp();
  ::cockroach::proto::Timestamp* temp = timestamp_;
  timestamp_ = NULL;
  return temp;
}
 void ReadWithinUncertaintyIntervalError::set_allocated_timestamp(::cockroach::proto::Timestamp* timestamp) {
  delete timestamp_;
  timestamp_ = timestamp;
  if (timestamp) {
    set_has_timestamp();
  } else {
    clear_has_timestamp();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.ReadWithinUncertaintyIntervalError.timestamp)
}

// optional .cockroach.proto.Timestamp existing_timestamp = 2;
bool ReadWithinUncertaintyIntervalError::has_existing_timestamp() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void ReadWithinUncertaintyIntervalError::set_has_existing_timestamp() {
  _has_bits_[0] |= 0x00000002u;
}
void ReadWithinUncertaintyIntervalError::clear_has_existing_timestamp() {
  _has_bits_[0] &= ~0x00000002u;
}
void ReadWithinUncertaintyIntervalError::clear_existing_timestamp() {
  if (existing_timestamp_ != NULL) existing_timestamp_->::cockroach::proto::Timestamp::Clear();
  clear_has_existing_timestamp();
}
 const ::cockroach::proto::Timestamp& ReadWithinUncertaintyIntervalError::existing_timestamp() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.ReadWithinUncertaintyIntervalError.existing_timestamp)
  return existing_timestamp_ != NULL ? *existing_timestamp_ : *default_instance_->existing_timestamp_;
}
 ::cockroach::proto::Timestamp* ReadWithinUncertaintyIntervalError::mutable_existing_timestamp() {
  set_has_existing_timestamp();
  if (existing_timestamp_ == NULL) {
    existing_timestamp_ = new ::cockroach::proto::Timestamp;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.proto.ReadWithinUncertaintyIntervalError.existing_timestamp)
  return existing_timestamp_;
}
 ::cockroach::proto::Timestamp* ReadWithinUncertaintyIntervalError::release_existing_timestamp() {
  clear_has_existing_timestamp();
  ::cockroach::proto::Timestamp* temp = existing_timestamp_;
  existing_timestamp_ = NULL;
  return temp;
}
 void ReadWithinUncertaintyIntervalError::set_allocated_existing_timestamp(::cockroach::proto::Timestamp* existing_timestamp) {
  delete existing_timestamp_;
  existing_timestamp_ = existing_timestamp;
  if (existing_timestamp) {
    set_has_existing_timestamp();
  } else {
    clear_has_existing_timestamp();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.ReadWithinUncertaintyIntervalError.existing_timestamp)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#ifndef _MSC_VER
const int TransactionAbortedError::kTxnFieldNumber;
#endif  // !_MSC_VER

TransactionAbortedError::TransactionAbortedError()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:cockroach.proto.TransactionAbortedError)
}

void TransactionAbortedError::InitAsDefaultInstance() {
  txn_ = const_cast< ::cockroach::proto::Transaction*>(&::cockroach::proto::Transaction::default_instance());
}

TransactionAbortedError::TransactionAbortedError(const TransactionAbortedError& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:cockroach.proto.TransactionAbortedError)
}

void TransactionAbortedError::SharedCtor() {
  _cached_size_ = 0;
  txn_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

TransactionAbortedError::~TransactionAbortedError() {
  // @@protoc_insertion_point(destructor:cockroach.proto.TransactionAbortedError)
  SharedDtor();
}

void TransactionAbortedError::SharedDtor() {
  if (this != default_instance_) {
    delete txn_;
  }
}

void TransactionAbortedError::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* TransactionAbortedError::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return TransactionAbortedError_descriptor_;
}

const TransactionAbortedError& TransactionAbortedError::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_cockroach_2fproto_2ferrors_2eproto();
  return *default_instance_;
}

TransactionAbortedError* TransactionAbortedError::default_instance_ = NULL;

TransactionAbortedError* TransactionAbortedError::New(::google::protobuf::Arena* arena) const {
  TransactionAbortedError* n = new TransactionAbortedError;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void TransactionAbortedError::Clear() {
  if (has_txn()) {
    if (txn_ != NULL) txn_->::cockroach::proto::Transaction::Clear();
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool TransactionAbortedError::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:cockroach.proto.TransactionAbortedError)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .cockroach.proto.Transaction txn = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_txn()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:cockroach.proto.TransactionAbortedError)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:cockroach.proto.TransactionAbortedError)
  return false;
#undef DO_
}

void TransactionAbortedError::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:cockroach.proto.TransactionAbortedError)
  // optional .cockroach.proto.Transaction txn = 1;
  if (has_txn()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->txn_, output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:cockroach.proto.TransactionAbortedError)
}

::google::protobuf::uint8* TransactionAbortedError::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:cockroach.proto.TransactionAbortedError)
  // optional .cockroach.proto.Transaction txn = 1;
  if (has_txn()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, *this->txn_, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:cockroach.proto.TransactionAbortedError)
  return target;
}

int TransactionAbortedError::ByteSize() const {
  int total_size = 0;

  // optional .cockroach.proto.Transaction txn = 1;
  if (has_txn()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->txn_);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TransactionAbortedError::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const TransactionAbortedError* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const TransactionAbortedError>(
          &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void TransactionAbortedError::MergeFrom(const TransactionAbortedError& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_txn()) {
      mutable_txn()->::cockroach::proto::Transaction::MergeFrom(from.txn());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void TransactionAbortedError::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TransactionAbortedError::CopyFrom(const TransactionAbortedError& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TransactionAbortedError::IsInitialized() const {

  return true;
}

void TransactionAbortedError::Swap(TransactionAbortedError* other) {
  if (other == this) return;
  InternalSwap(other);
}
void TransactionAbortedError::InternalSwap(TransactionAbortedError* other) {
  std::swap(txn_, other->txn_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata TransactionAbortedError::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = TransactionAbortedError_descriptor_;
  metadata.reflection = TransactionAbortedError_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// TransactionAbortedError

// optional .cockroach.proto.Transaction txn = 1;
bool TransactionAbortedError::has_txn() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void TransactionAbortedError::set_has_txn() {
  _has_bits_[0] |= 0x00000001u;
}
void TransactionAbortedError::clear_has_txn() {
  _has_bits_[0] &= ~0x00000001u;
}
void TransactionAbortedError::clear_txn() {
  if (txn_ != NULL) txn_->::cockroach::proto::Transaction::Clear();
  clear_has_txn();
}
 const ::cockroach::proto::Transaction& TransactionAbortedError::txn() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.TransactionAbortedError.txn)
  return txn_ != NULL ? *txn_ : *default_instance_->txn_;
}
 ::cockroach::proto::Transaction* TransactionAbortedError::mutable_txn() {
  set_has_txn();
  if (txn_ == NULL) {
    txn_ = new ::cockroach::proto::Transaction;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.proto.TransactionAbortedError.txn)
  return txn_;
}
 ::cockroach::proto::Transaction* TransactionAbortedError::release_txn() {
  clear_has_txn();
  ::cockroach::proto::Transaction* temp = txn_;
  txn_ = NULL;
  return temp;
}
 void TransactionAbortedError::set_allocated_txn(::cockroach::proto::Transaction* txn) {
  delete txn_;
  txn_ = txn;
  if (txn) {
    set_has_txn();
  } else {
    clear_has_txn();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.TransactionAbortedError.txn)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#ifndef _MSC_VER
const int TransactionPushError::kTxnFieldNumber;
const int TransactionPushError::kPusheeTxnFieldNumber;
#endif  // !_MSC_VER

TransactionPushError::TransactionPushError()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:cockroach.proto.TransactionPushError)
}

void TransactionPushError::InitAsDefaultInstance() {
  txn_ = const_cast< ::cockroach::proto::Transaction*>(&::cockroach::proto::Transaction::default_instance());
  pushee_txn_ = const_cast< ::cockroach::proto::Transaction*>(&::cockroach::proto::Transaction::default_instance());
}

TransactionPushError::TransactionPushError(const TransactionPushError& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:cockroach.proto.TransactionPushError)
}

void TransactionPushError::SharedCtor() {
  _cached_size_ = 0;
  txn_ = NULL;
  pushee_txn_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

TransactionPushError::~TransactionPushError() {
  // @@protoc_insertion_point(destructor:cockroach.proto.TransactionPushError)
  SharedDtor();
}

void TransactionPushError::SharedDtor() {
  if (this != default_instance_) {
    delete txn_;
    delete pushee_txn_;
  }
}

void TransactionPushError::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* TransactionPushError::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return TransactionPushError_descriptor_;
}

const TransactionPushError& TransactionPushError::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_cockroach_2fproto_2ferrors_2eproto();
  return *default_instance_;
}

TransactionPushError* TransactionPushError::default_instance_ = NULL;

TransactionPushError* TransactionPushError::New(::google::protobuf::Arena* arena) const {
  TransactionPushError* n = new TransactionPushError;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void TransactionPushError::Clear() {
  if (_has_bits_[0 / 32] & 3u) {
    if (has_txn()) {
      if (txn_ != NULL) txn_->::cockroach::proto::Transaction::Clear();
    }
    if (has_pushee_txn()) {
      if (pushee_txn_ != NULL) pushee_txn_->::cockroach::proto::Transaction::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool TransactionPushError::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:cockroach.proto.TransactionPushError)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .cockroach.proto.Transaction txn = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_txn()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_pushee_txn;
        break;
      }

      // optional .cockroach.proto.Transaction pushee_txn = 2;
      case 2: {
        if (tag == 18) {
         parse_pushee_txn:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_pushee_txn()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:cockroach.proto.TransactionPushError)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:cockroach.proto.TransactionPushError)
  return false;
#undef DO_
}

void TransactionPushError::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:cockroach.proto.TransactionPushError)
  // optional .cockroach.proto.Transaction txn = 1;
  if (has_txn()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->txn_, output);
  }

  // optional .cockroach.proto.Transaction pushee_txn = 2;
  if (has_pushee_txn()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, *this->pushee_txn_, output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:cockroach.proto.TransactionPushError)
}

::google::protobuf::uint8* TransactionPushError::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:cockroach.proto.TransactionPushError)
  // optional .cockroach.proto.Transaction txn = 1;
  if (has_txn()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, *this->txn_, target);
  }

  // optional .cockroach.proto.Transaction pushee_txn = 2;
  if (has_pushee_txn()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, *this->pushee_txn_, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:cockroach.proto.TransactionPushError)
  return target;
}

int TransactionPushError::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & 3) {
    // optional .cockroach.proto.Transaction txn = 1;
    if (has_txn()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->txn_);
    }

    // optional .cockroach.proto.Transaction pushee_txn = 2;
    if (has_pushee_txn()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->pushee_txn_);
    }

  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TransactionPushError::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const TransactionPushError* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const TransactionPushError>(
          &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void TransactionPushError::MergeFrom(const TransactionPushError& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_txn()) {
      mutable_txn()->::cockroach::proto::Transaction::MergeFrom(from.txn());
    }
    if (from.has_pushee_txn()) {
      mutable_pushee_txn()->::cockroach::proto::Transaction::MergeFrom(from.pushee_txn());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void TransactionPushError::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TransactionPushError::CopyFrom(const TransactionPushError& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TransactionPushError::IsInitialized() const {

  return true;
}

void TransactionPushError::Swap(TransactionPushError* other) {
  if (other == this) return;
  InternalSwap(other);
}
void TransactionPushError::InternalSwap(TransactionPushError* other) {
  std::swap(txn_, other->txn_);
  std::swap(pushee_txn_, other->pushee_txn_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata TransactionPushError::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = TransactionPushError_descriptor_;
  metadata.reflection = TransactionPushError_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// TransactionPushError

// optional .cockroach.proto.Transaction txn = 1;
bool TransactionPushError::has_txn() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void TransactionPushError::set_has_txn() {
  _has_bits_[0] |= 0x00000001u;
}
void TransactionPushError::clear_has_txn() {
  _has_bits_[0] &= ~0x00000001u;
}
void TransactionPushError::clear_txn() {
  if (txn_ != NULL) txn_->::cockroach::proto::Transaction::Clear();
  clear_has_txn();
}
 const ::cockroach::proto::Transaction& TransactionPushError::txn() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.TransactionPushError.txn)
  return txn_ != NULL ? *txn_ : *default_instance_->txn_;
}
 ::cockroach::proto::Transaction* TransactionPushError::mutable_txn() {
  set_has_txn();
  if (txn_ == NULL) {
    txn_ = new ::cockroach::proto::Transaction;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.proto.TransactionPushError.txn)
  return txn_;
}
 ::cockroach::proto::Transaction* TransactionPushError::release_txn() {
  clear_has_txn();
  ::cockroach::proto::Transaction* temp = txn_;
  txn_ = NULL;
  return temp;
}
 void TransactionPushError::set_allocated_txn(::cockroach::proto::Transaction* txn) {
  delete txn_;
  txn_ = txn;
  if (txn) {
    set_has_txn();
  } else {
    clear_has_txn();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.TransactionPushError.txn)
}

// optional .cockroach.proto.Transaction pushee_txn = 2;
bool TransactionPushError::has_pushee_txn() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void TransactionPushError::set_has_pushee_txn() {
  _has_bits_[0] |= 0x00000002u;
}
void TransactionPushError::clear_has_pushee_txn() {
  _has_bits_[0] &= ~0x00000002u;
}
void TransactionPushError::clear_pushee_txn() {
  if (pushee_txn_ != NULL) pushee_txn_->::cockroach::proto::Transaction::Clear();
  clear_has_pushee_txn();
}
 const ::cockroach::proto::Transaction& TransactionPushError::pushee_txn() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.TransactionPushError.pushee_txn)
  return pushee_txn_ != NULL ? *pushee_txn_ : *default_instance_->pushee_txn_;
}
 ::cockroach::proto::Transaction* TransactionPushError::mutable_pushee_txn() {
  set_has_pushee_txn();
  if (pushee_txn_ == NULL) {
    pushee_txn_ = new ::cockroach::proto::Transaction;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.proto.TransactionPushError.pushee_txn)
  return pushee_txn_;
}
 ::cockroach::proto::Transaction* TransactionPushError::release_pushee_txn() {
  clear_has_pushee_txn();
  ::cockroach::proto::Transaction* temp = pushee_txn_;
  pushee_txn_ = NULL;
  return temp;
}
 void TransactionPushError::set_allocated_pushee_txn(::cockroach::proto::Transaction* pushee_txn) {
  delete pushee_txn_;
  pushee_txn_ = pushee_txn;
  if (pushee_txn) {
    set_has_pushee_txn();
  } else {
    clear_has_pushee_txn();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.TransactionPushError.pushee_txn)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#ifndef _MSC_VER
const int TransactionRetryError::kTxnFieldNumber;
#endif  // !_MSC_VER

TransactionRetryError::TransactionRetryError()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:cockroach.proto.TransactionRetryError)
}

void TransactionRetryError::InitAsDefaultInstance() {
  txn_ = const_cast< ::cockroach::proto::Transaction*>(&::cockroach::proto::Transaction::default_instance());
}

TransactionRetryError::TransactionRetryError(const TransactionRetryError& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:cockroach.proto.TransactionRetryError)
}

void TransactionRetryError::SharedCtor() {
  _cached_size_ = 0;
  txn_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

TransactionRetryError::~TransactionRetryError() {
  // @@protoc_insertion_point(destructor:cockroach.proto.TransactionRetryError)
  SharedDtor();
}

void TransactionRetryError::SharedDtor() {
  if (this != default_instance_) {
    delete txn_;
  }
}

void TransactionRetryError::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* TransactionRetryError::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return TransactionRetryError_descriptor_;
}

const TransactionRetryError& TransactionRetryError::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_cockroach_2fproto_2ferrors_2eproto();
  return *default_instance_;
}

TransactionRetryError* TransactionRetryError::default_instance_ = NULL;

TransactionRetryError* TransactionRetryError::New(::google::protobuf::Arena* arena) const {
  TransactionRetryError* n = new TransactionRetryError;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void TransactionRetryError::Clear() {
  if (has_txn()) {
    if (txn_ != NULL) txn_->::cockroach::proto::Transaction::Clear();
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool TransactionRetryError::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:cockroach.proto.TransactionRetryError)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .cockroach.proto.Transaction txn = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_txn()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:cockroach.proto.TransactionRetryError)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:cockroach.proto.TransactionRetryError)
  return false;
#undef DO_
}

void TransactionRetryError::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:cockroach.proto.TransactionRetryError)
  // optional .cockroach.proto.Transaction txn = 1;
  if (has_txn()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->txn_, output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:cockroach.proto.TransactionRetryError)
}

::google::protobuf::uint8* TransactionRetryError::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:cockroach.proto.TransactionRetryError)
  // optional .cockroach.proto.Transaction txn = 1;
  if (has_txn()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, *this->txn_, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:cockroach.proto.TransactionRetryError)
  return target;
}

int TransactionRetryError::ByteSize() const {
  int total_size = 0;

  // optional .cockroach.proto.Transaction txn = 1;
  if (has_txn()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->txn_);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TransactionRetryError::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const TransactionRetryError* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const TransactionRetryError>(
          &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void TransactionRetryError::MergeFrom(const TransactionRetryError& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_txn()) {
      mutable_txn()->::cockroach::proto::Transaction::MergeFrom(from.txn());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void TransactionRetryError::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TransactionRetryError::CopyFrom(const TransactionRetryError& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TransactionRetryError::IsInitialized() const {

  return true;
}

void TransactionRetryError::Swap(TransactionRetryError* other) {
  if (other == this) return;
  InternalSwap(other);
}
void TransactionRetryError::InternalSwap(TransactionRetryError* other) {
  std::swap(txn_, other->txn_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata TransactionRetryError::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = TransactionRetryError_descriptor_;
  metadata.reflection = TransactionRetryError_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// TransactionRetryError

// optional .cockroach.proto.Transaction txn = 1;
bool TransactionRetryError::has_txn() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void TransactionRetryError::set_has_txn() {
  _has_bits_[0] |= 0x00000001u;
}
void TransactionRetryError::clear_has_txn() {
  _has_bits_[0] &= ~0x00000001u;
}
void TransactionRetryError::clear_txn() {
  if (txn_ != NULL) txn_->::cockroach::proto::Transaction::Clear();
  clear_has_txn();
}
 const ::cockroach::proto::Transaction& TransactionRetryError::txn() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.TransactionRetryError.txn)
  return txn_ != NULL ? *txn_ : *default_instance_->txn_;
}
 ::cockroach::proto::Transaction* TransactionRetryError::mutable_txn() {
  set_has_txn();
  if (txn_ == NULL) {
    txn_ = new ::cockroach::proto::Transaction;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.proto.TransactionRetryError.txn)
  return txn_;
}
 ::cockroach::proto::Transaction* TransactionRetryError::release_txn() {
  clear_has_txn();
  ::cockroach::proto::Transaction* temp = txn_;
  txn_ = NULL;
  return temp;
}
 void TransactionRetryError::set_allocated_txn(::cockroach::proto::Transaction* txn) {
  delete txn_;
  txn_ = txn;
  if (txn) {
    set_has_txn();
  } else {
    clear_has_txn();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.TransactionRetryError.txn)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#ifndef _MSC_VER
const int TransactionStatusError::kTxnFieldNumber;
const int TransactionStatusError::kMsgFieldNumber;
#endif  // !_MSC_VER

TransactionStatusError::TransactionStatusError()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:cockroach.proto.TransactionStatusError)
}

void TransactionStatusError::InitAsDefaultInstance() {
  txn_ = const_cast< ::cockroach::proto::Transaction*>(&::cockroach::proto::Transaction::default_instance());
}

TransactionStatusError::TransactionStatusError(const TransactionStatusError& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:cockroach.proto.TransactionStatusError)
}

void TransactionStatusError::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  txn_ = NULL;
  msg_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

TransactionStatusError::~TransactionStatusError() {
  // @@protoc_insertion_point(destructor:cockroach.proto.TransactionStatusError)
  SharedDtor();
}

void TransactionStatusError::SharedDtor() {
  msg_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != default_instance_) {
    delete txn_;
  }
}

void TransactionStatusError::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* TransactionStatusError::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return TransactionStatusError_descriptor_;
}

const TransactionStatusError& TransactionStatusError::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_cockroach_2fproto_2ferrors_2eproto();
  return *default_instance_;
}

TransactionStatusError* TransactionStatusError::default_instance_ = NULL;

TransactionStatusError* TransactionStatusError::New(::google::protobuf::Arena* arena) const {
  TransactionStatusError* n = new TransactionStatusError;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void TransactionStatusError::Clear() {
  if (_has_bits_[0 / 32] & 3u) {
    if (has_txn()) {
      if (txn_ != NULL) txn_->::cockroach::proto::Transaction::Clear();
    }
    if (has_msg()) {
      msg_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool TransactionStatusError::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:cockroach.proto.TransactionStatusError)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .cockroach.proto.Transaction txn = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_txn()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_msg;
        break;
      }

      // optional string msg = 2;
      case 2: {
        if (tag == 18) {
         parse_msg:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_msg()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->msg().data(), this->msg().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "cockroach.proto.TransactionStatusError.msg");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:cockroach.proto.TransactionStatusError)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:cockroach.proto.TransactionStatusError)
  return false;
#undef DO_
}

void TransactionStatusError::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:cockroach.proto.TransactionStatusError)
  // optional .cockroach.proto.Transaction txn = 1;
  if (has_txn()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->txn_, output);
  }

  // optional string msg = 2;
  if (has_msg()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->msg().data(), this->msg().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "cockroach.proto.TransactionStatusError.msg");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->msg(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:cockroach.proto.TransactionStatusError)
}

::google::protobuf::uint8* TransactionStatusError::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:cockroach.proto.TransactionStatusError)
  // optional .cockroach.proto.Transaction txn = 1;
  if (has_txn()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, *this->txn_, target);
  }

  // optional string msg = 2;
  if (has_msg()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->msg().data(), this->msg().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "cockroach.proto.TransactionStatusError.msg");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->msg(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:cockroach.proto.TransactionStatusError)
  return target;
}

int TransactionStatusError::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & 3) {
    // optional .cockroach.proto.Transaction txn = 1;
    if (has_txn()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->txn_);
    }

    // optional string msg = 2;
    if (has_msg()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->msg());
    }

  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TransactionStatusError::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const TransactionStatusError* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const TransactionStatusError>(
          &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void TransactionStatusError::MergeFrom(const TransactionStatusError& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_txn()) {
      mutable_txn()->::cockroach::proto::Transaction::MergeFrom(from.txn());
    }
    if (from.has_msg()) {
      set_has_msg();
      msg_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.msg_);
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void TransactionStatusError::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TransactionStatusError::CopyFrom(const TransactionStatusError& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TransactionStatusError::IsInitialized() const {

  return true;
}

void TransactionStatusError::Swap(TransactionStatusError* other) {
  if (other == this) return;
  InternalSwap(other);
}
void TransactionStatusError::InternalSwap(TransactionStatusError* other) {
  std::swap(txn_, other->txn_);
  msg_.Swap(&other->msg_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata TransactionStatusError::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = TransactionStatusError_descriptor_;
  metadata.reflection = TransactionStatusError_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// TransactionStatusError

// optional .cockroach.proto.Transaction txn = 1;
bool TransactionStatusError::has_txn() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void TransactionStatusError::set_has_txn() {
  _has_bits_[0] |= 0x00000001u;
}
void TransactionStatusError::clear_has_txn() {
  _has_bits_[0] &= ~0x00000001u;
}
void TransactionStatusError::clear_txn() {
  if (txn_ != NULL) txn_->::cockroach::proto::Transaction::Clear();
  clear_has_txn();
}
 const ::cockroach::proto::Transaction& TransactionStatusError::txn() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.TransactionStatusError.txn)
  return txn_ != NULL ? *txn_ : *default_instance_->txn_;
}
 ::cockroach::proto::Transaction* TransactionStatusError::mutable_txn() {
  set_has_txn();
  if (txn_ == NULL) {
    txn_ = new ::cockroach::proto::Transaction;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.proto.TransactionStatusError.txn)
  return txn_;
}
 ::cockroach::proto::Transaction* TransactionStatusError::release_txn() {
  clear_has_txn();
  ::cockroach::proto::Transaction* temp = txn_;
  txn_ = NULL;
  return temp;
}
 void TransactionStatusError::set_allocated_txn(::cockroach::proto::Transaction* txn) {
  delete txn_;
  txn_ = txn;
  if (txn) {
    set_has_txn();
  } else {
    clear_has_txn();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.TransactionStatusError.txn)
}

// optional string msg = 2;
bool TransactionStatusError::has_msg() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void TransactionStatusError::set_has_msg() {
  _has_bits_[0] |= 0x00000002u;
}
void TransactionStatusError::clear_has_msg() {
  _has_bits_[0] &= ~0x00000002u;
}
void TransactionStatusError::clear_msg() {
  msg_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_msg();
}
 const ::std::string& TransactionStatusError::msg() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.TransactionStatusError.msg)
  return msg_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void TransactionStatusError::set_msg(const ::std::string& value) {
  set_has_msg();
  msg_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cockroach.proto.TransactionStatusError.msg)
}
 void TransactionStatusError::set_msg(const char* value) {
  set_has_msg();
  msg_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cockroach.proto.TransactionStatusError.msg)
}
 void TransactionStatusError::set_msg(const char* value, size_t size) {
  set_has_msg();
  msg_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cockroach.proto.TransactionStatusError.msg)
}
 ::std::string* TransactionStatusError::mutable_msg() {
  set_has_msg();
  // @@protoc_insertion_point(field_mutable:cockroach.proto.TransactionStatusError.msg)
  return msg_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* TransactionStatusError::release_msg() {
  clear_has_msg();
  return msg_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void TransactionStatusError::set_allocated_msg(::std::string* msg) {
  if (msg != NULL) {
    set_has_msg();
  } else {
    clear_has_msg();
  }
  msg_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), msg);
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.TransactionStatusError.msg)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#ifndef _MSC_VER
const int WriteIntentError::kIntentsFieldNumber;
const int WriteIntentError::kResolvedFieldNumber;
#endif  // !_MSC_VER

WriteIntentError::WriteIntentError()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:cockroach.proto.WriteIntentError)
}

void WriteIntentError::InitAsDefaultInstance() {
}

WriteIntentError::WriteIntentError(const WriteIntentError& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:cockroach.proto.WriteIntentError)
}

void WriteIntentError::SharedCtor() {
  _cached_size_ = 0;
  resolved_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

WriteIntentError::~WriteIntentError() {
  // @@protoc_insertion_point(destructor:cockroach.proto.WriteIntentError)
  SharedDtor();
}

void WriteIntentError::SharedDtor() {
  if (this != default_instance_) {
  }
}

void WriteIntentError::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* WriteIntentError::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return WriteIntentError_descriptor_;
}

const WriteIntentError& WriteIntentError::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_cockroach_2fproto_2ferrors_2eproto();
  return *default_instance_;
}

WriteIntentError* WriteIntentError::default_instance_ = NULL;

WriteIntentError* WriteIntentError::New(::google::protobuf::Arena* arena) const {
  WriteIntentError* n = new WriteIntentError;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void WriteIntentError::Clear() {
  resolved_ = false;
  intents_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool WriteIntentError::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:cockroach.proto.WriteIntentError)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .cockroach.proto.Intent intents = 1;
      case 1: {
        if (tag == 10) {
          DO_(input->IncrementRecursionDepth());
         parse_loop_intents:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                input, add_intents()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(10)) goto parse_loop_intents;
        input->UnsafeDecrementRecursionDepth();
        if (input->ExpectTag(16)) goto parse_resolved;
        break;
      }

      // optional bool resolved = 2;
      case 2: {
        if (tag == 16) {
         parse_resolved:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &resolved_)));
          set_has_resolved();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:cockroach.proto.WriteIntentError)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:cockroach.proto.WriteIntentError)
  return false;
#undef DO_
}

void WriteIntentError::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:cockroach.proto.WriteIntentError)
  // repeated .cockroach.proto.Intent intents = 1;
  for (unsigned int i = 0, n = this->intents_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->intents(i), output);
  }

  // optional bool resolved = 2;
  if (has_resolved()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(2, this->resolved(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:cockroach.proto.WriteIntentError)
}

::google::protobuf::uint8* WriteIntentError::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:cockroach.proto.WriteIntentError)
  // repeated .cockroach.proto.Intent intents = 1;
  for (unsigned int i = 0, n = this->intents_size(); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->intents(i), target);
  }

  // optional bool resolved = 2;
  if (has_resolved()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(2, this->resolved(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:cockroach.proto.WriteIntentError)
  return target;
}

int WriteIntentError::ByteSize() const {
  int total_size = 0;

  // optional bool resolved = 2;
  if (has_resolved()) {
    total_size += 1 + 1;
  }

  // repeated .cockroach.proto.Intent intents = 1;
  total_size += 1 * this->intents_size();
  for (int i = 0; i < this->intents_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->intents(i));
  }

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void WriteIntentError::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const WriteIntentError* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const WriteIntentError>(
          &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void WriteIntentError::MergeFrom(const WriteIntentError& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  intents_.MergeFrom(from.intents_);
  if (from._has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    if (from.has_resolved()) {
      set_resolved(from.resolved());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void WriteIntentError::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void WriteIntentError::CopyFrom(const WriteIntentError& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool WriteIntentError::IsInitialized() const {

  return true;
}

void WriteIntentError::Swap(WriteIntentError* other) {
  if (other == this) return;
  InternalSwap(other);
}
void WriteIntentError::InternalSwap(WriteIntentError* other) {
  intents_.UnsafeArenaSwap(&other->intents_);
  std::swap(resolved_, other->resolved_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata WriteIntentError::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = WriteIntentError_descriptor_;
  metadata.reflection = WriteIntentError_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// WriteIntentError

// repeated .cockroach.proto.Intent intents = 1;
int WriteIntentError::intents_size() const {
  return intents_.size();
}
void WriteIntentError::clear_intents() {
  intents_.Clear();
}
 const ::cockroach::proto::Intent& WriteIntentError::intents(int index) const {
  // @@protoc_insertion_point(field_get:cockroach.proto.WriteIntentError.intents)
  return intents_.Get(index);
}
 ::cockroach::proto::Intent* WriteIntentError::mutable_intents(int index) {
  // @@protoc_insertion_point(field_mutable:cockroach.proto.WriteIntentError.intents)
  return intents_.Mutable(index);
}
 ::cockroach::proto::Intent* WriteIntentError::add_intents() {
  // @@protoc_insertion_point(field_add:cockroach.proto.WriteIntentError.intents)
  return intents_.Add();
}
 const ::google::protobuf::RepeatedPtrField< ::cockroach::proto::Intent >&
WriteIntentError::intents() const {
  // @@protoc_insertion_point(field_list:cockroach.proto.WriteIntentError.intents)
  return intents_;
}
 ::google::protobuf::RepeatedPtrField< ::cockroach::proto::Intent >*
WriteIntentError::mutable_intents() {
  // @@protoc_insertion_point(field_mutable_list:cockroach.proto.WriteIntentError.intents)
  return &intents_;
}

// optional bool resolved = 2;
bool WriteIntentError::has_resolved() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void WriteIntentError::set_has_resolved() {
  _has_bits_[0] |= 0x00000002u;
}
void WriteIntentError::clear_has_resolved() {
  _has_bits_[0] &= ~0x00000002u;
}
void WriteIntentError::clear_resolved() {
  resolved_ = false;
  clear_has_resolved();
}
 bool WriteIntentError::resolved() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.WriteIntentError.resolved)
  return resolved_;
}
 void WriteIntentError::set_resolved(bool value) {
  set_has_resolved();
  resolved_ = value;
  // @@protoc_insertion_point(field_set:cockroach.proto.WriteIntentError.resolved)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#ifndef _MSC_VER
const int WriteTooOldError::kTimestampFieldNumber;
const int WriteTooOldError::kExistingTimestampFieldNumber;
#endif  // !_MSC_VER

WriteTooOldError::WriteTooOldError()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:cockroach.proto.WriteTooOldError)
}

void WriteTooOldError::InitAsDefaultInstance() {
  timestamp_ = const_cast< ::cockroach::proto::Timestamp*>(&::cockroach::proto::Timestamp::default_instance());
  existing_timestamp_ = const_cast< ::cockroach::proto::Timestamp*>(&::cockroach::proto::Timestamp::default_instance());
}

WriteTooOldError::WriteTooOldError(const WriteTooOldError& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:cockroach.proto.WriteTooOldError)
}

void WriteTooOldError::SharedCtor() {
  _cached_size_ = 0;
  timestamp_ = NULL;
  existing_timestamp_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

WriteTooOldError::~WriteTooOldError() {
  // @@protoc_insertion_point(destructor:cockroach.proto.WriteTooOldError)
  SharedDtor();
}

void WriteTooOldError::SharedDtor() {
  if (this != default_instance_) {
    delete timestamp_;
    delete existing_timestamp_;
  }
}

void WriteTooOldError::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* WriteTooOldError::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return WriteTooOldError_descriptor_;
}

const WriteTooOldError& WriteTooOldError::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_cockroach_2fproto_2ferrors_2eproto();
  return *default_instance_;
}

WriteTooOldError* WriteTooOldError::default_instance_ = NULL;

WriteTooOldError* WriteTooOldError::New(::google::protobuf::Arena* arena) const {
  WriteTooOldError* n = new WriteTooOldError;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void WriteTooOldError::Clear() {
  if (_has_bits_[0 / 32] & 3u) {
    if (has_timestamp()) {
      if (timestamp_ != NULL) timestamp_->::cockroach::proto::Timestamp::Clear();
    }
    if (has_existing_timestamp()) {
      if (existing_timestamp_ != NULL) existing_timestamp_->::cockroach::proto::Timestamp::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool WriteTooOldError::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:cockroach.proto.WriteTooOldError)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .cockroach.proto.Timestamp timestamp = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_timestamp()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_existing_timestamp;
        break;
      }

      // optional .cockroach.proto.Timestamp existing_timestamp = 2;
      case 2: {
        if (tag == 18) {
         parse_existing_timestamp:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_existing_timestamp()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:cockroach.proto.WriteTooOldError)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:cockroach.proto.WriteTooOldError)
  return false;
#undef DO_
}

void WriteTooOldError::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:cockroach.proto.WriteTooOldError)
  // optional .cockroach.proto.Timestamp timestamp = 1;
  if (has_timestamp()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->timestamp_, output);
  }

  // optional .cockroach.proto.Timestamp existing_timestamp = 2;
  if (has_existing_timestamp()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, *this->existing_timestamp_, output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:cockroach.proto.WriteTooOldError)
}

::google::protobuf::uint8* WriteTooOldError::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:cockroach.proto.WriteTooOldError)
  // optional .cockroach.proto.Timestamp timestamp = 1;
  if (has_timestamp()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, *this->timestamp_, target);
  }

  // optional .cockroach.proto.Timestamp existing_timestamp = 2;
  if (has_existing_timestamp()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, *this->existing_timestamp_, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:cockroach.proto.WriteTooOldError)
  return target;
}

int WriteTooOldError::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & 3) {
    // optional .cockroach.proto.Timestamp timestamp = 1;
    if (has_timestamp()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->timestamp_);
    }

    // optional .cockroach.proto.Timestamp existing_timestamp = 2;
    if (has_existing_timestamp()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->existing_timestamp_);
    }

  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void WriteTooOldError::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const WriteTooOldError* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const WriteTooOldError>(
          &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void WriteTooOldError::MergeFrom(const WriteTooOldError& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_timestamp()) {
      mutable_timestamp()->::cockroach::proto::Timestamp::MergeFrom(from.timestamp());
    }
    if (from.has_existing_timestamp()) {
      mutable_existing_timestamp()->::cockroach::proto::Timestamp::MergeFrom(from.existing_timestamp());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void WriteTooOldError::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void WriteTooOldError::CopyFrom(const WriteTooOldError& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool WriteTooOldError::IsInitialized() const {

  return true;
}

void WriteTooOldError::Swap(WriteTooOldError* other) {
  if (other == this) return;
  InternalSwap(other);
}
void WriteTooOldError::InternalSwap(WriteTooOldError* other) {
  std::swap(timestamp_, other->timestamp_);
  std::swap(existing_timestamp_, other->existing_timestamp_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata WriteTooOldError::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = WriteTooOldError_descriptor_;
  metadata.reflection = WriteTooOldError_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// WriteTooOldError

// optional .cockroach.proto.Timestamp timestamp = 1;
bool WriteTooOldError::has_timestamp() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void WriteTooOldError::set_has_timestamp() {
  _has_bits_[0] |= 0x00000001u;
}
void WriteTooOldError::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000001u;
}
void WriteTooOldError::clear_timestamp() {
  if (timestamp_ != NULL) timestamp_->::cockroach::proto::Timestamp::Clear();
  clear_has_timestamp();
}
 const ::cockroach::proto::Timestamp& WriteTooOldError::timestamp() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.WriteTooOldError.timestamp)
  return timestamp_ != NULL ? *timestamp_ : *default_instance_->timestamp_;
}
 ::cockroach::proto::Timestamp* WriteTooOldError::mutable_timestamp() {
  set_has_timestamp();
  if (timestamp_ == NULL) {
    timestamp_ = new ::cockroach::proto::Timestamp;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.proto.WriteTooOldError.timestamp)
  return timestamp_;
}
 ::cockroach::proto::Timestamp* WriteTooOldError::release_timestamp() {
  clear_has_timestamp();
  ::cockroach::proto::Timestamp* temp = timestamp_;
  timestamp_ = NULL;
  return temp;
}
 void WriteTooOldError::set_allocated_timestamp(::cockroach::proto::Timestamp* timestamp) {
  delete timestamp_;
  timestamp_ = timestamp;
  if (timestamp) {
    set_has_timestamp();
  } else {
    clear_has_timestamp();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.WriteTooOldError.timestamp)
}

// optional .cockroach.proto.Timestamp existing_timestamp = 2;
bool WriteTooOldError::has_existing_timestamp() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void WriteTooOldError::set_has_existing_timestamp() {
  _has_bits_[0] |= 0x00000002u;
}
void WriteTooOldError::clear_has_existing_timestamp() {
  _has_bits_[0] &= ~0x00000002u;
}
void WriteTooOldError::clear_existing_timestamp() {
  if (existing_timestamp_ != NULL) existing_timestamp_->::cockroach::proto::Timestamp::Clear();
  clear_has_existing_timestamp();
}
 const ::cockroach::proto::Timestamp& WriteTooOldError::existing_timestamp() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.WriteTooOldError.existing_timestamp)
  return existing_timestamp_ != NULL ? *existing_timestamp_ : *default_instance_->existing_timestamp_;
}
 ::cockroach::proto::Timestamp* WriteTooOldError::mutable_existing_timestamp() {
  set_has_existing_timestamp();
  if (existing_timestamp_ == NULL) {
    existing_timestamp_ = new ::cockroach::proto::Timestamp;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.proto.WriteTooOldError.existing_timestamp)
  return existing_timestamp_;
}
 ::cockroach::proto::Timestamp* WriteTooOldError::release_existing_timestamp() {
  clear_has_existing_timestamp();
  ::cockroach::proto::Timestamp* temp = existing_timestamp_;
  existing_timestamp_ = NULL;
  return temp;
}
 void WriteTooOldError::set_allocated_existing_timestamp(::cockroach::proto::Timestamp* existing_timestamp) {
  delete existing_timestamp_;
  existing_timestamp_ = existing_timestamp;
  if (existing_timestamp) {
    set_has_existing_timestamp();
  } else {
    clear_has_existing_timestamp();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.WriteTooOldError.existing_timestamp)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

OpRequiresTxnError::OpRequiresTxnError()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:cockroach.proto.OpRequiresTxnError)
}

void OpRequiresTxnError::InitAsDefaultInstance() {
}

OpRequiresTxnError::OpRequiresTxnError(const OpRequiresTxnError& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:cockroach.proto.OpRequiresTxnError)
}

void OpRequiresTxnError::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

OpRequiresTxnError::~OpRequiresTxnError() {
  // @@protoc_insertion_point(destructor:cockroach.proto.OpRequiresTxnError)
  SharedDtor();
}

void OpRequiresTxnError::SharedDtor() {
  if (this != default_instance_) {
  }
}

void OpRequiresTxnError::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* OpRequiresTxnError::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return OpRequiresTxnError_descriptor_;
}

const OpRequiresTxnError& OpRequiresTxnError::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_cockroach_2fproto_2ferrors_2eproto();
  return *default_instance_;
}

OpRequiresTxnError* OpRequiresTxnError::default_instance_ = NULL;

OpRequiresTxnError* OpRequiresTxnError::New(::google::protobuf::Arena* arena) const {
  OpRequiresTxnError* n = new OpRequiresTxnError;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void OpRequiresTxnError::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool OpRequiresTxnError::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:cockroach.proto.OpRequiresTxnError)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormat::SkipField(
          input, tag, mutable_unknown_fields()));
  }
success:
  // @@protoc_insertion_point(parse_success:cockroach.proto.OpRequiresTxnError)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:cockroach.proto.OpRequiresTxnError)
  return false;
#undef DO_
}

void OpRequiresTxnError::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:cockroach.proto.OpRequiresTxnError)
  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:cockroach.proto.OpRequiresTxnError)
}

::google::protobuf::uint8* OpRequiresTxnError::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:cockroach.proto.OpRequiresTxnError)
  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:cockroach.proto.OpRequiresTxnError)
  return target;
}

int OpRequiresTxnError::ByteSize() const {
  int total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void OpRequiresTxnError::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const OpRequiresTxnError* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const OpRequiresTxnError>(
          &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void OpRequiresTxnError::MergeFrom(const OpRequiresTxnError& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void OpRequiresTxnError::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void OpRequiresTxnError::CopyFrom(const OpRequiresTxnError& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool OpRequiresTxnError::IsInitialized() const {

  return true;
}

void OpRequiresTxnError::Swap(OpRequiresTxnError* other) {
  if (other == this) return;
  InternalSwap(other);
}
void OpRequiresTxnError::InternalSwap(OpRequiresTxnError* other) {
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata OpRequiresTxnError::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = OpRequiresTxnError_descriptor_;
  metadata.reflection = OpRequiresTxnError_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// OpRequiresTxnError

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#ifndef _MSC_VER
const int ConditionFailedError::kActualValueFieldNumber;
#endif  // !_MSC_VER

ConditionFailedError::ConditionFailedError()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:cockroach.proto.ConditionFailedError)
}

void ConditionFailedError::InitAsDefaultInstance() {
  actual_value_ = const_cast< ::cockroach::proto::Value*>(&::cockroach::proto::Value::default_instance());
}

ConditionFailedError::ConditionFailedError(const ConditionFailedError& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:cockroach.proto.ConditionFailedError)
}

void ConditionFailedError::SharedCtor() {
  _cached_size_ = 0;
  actual_value_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ConditionFailedError::~ConditionFailedError() {
  // @@protoc_insertion_point(destructor:cockroach.proto.ConditionFailedError)
  SharedDtor();
}

void ConditionFailedError::SharedDtor() {
  if (this != default_instance_) {
    delete actual_value_;
  }
}

void ConditionFailedError::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ConditionFailedError::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ConditionFailedError_descriptor_;
}

const ConditionFailedError& ConditionFailedError::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_cockroach_2fproto_2ferrors_2eproto();
  return *default_instance_;
}

ConditionFailedError* ConditionFailedError::default_instance_ = NULL;

ConditionFailedError* ConditionFailedError::New(::google::protobuf::Arena* arena) const {
  ConditionFailedError* n = new ConditionFailedError;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void ConditionFailedError::Clear() {
  if (has_actual_value()) {
    if (actual_value_ != NULL) actual_value_->::cockroach::proto::Value::Clear();
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool ConditionFailedError::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:cockroach.proto.ConditionFailedError)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .cockroach.proto.Value actual_value = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_actual_value()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:cockroach.proto.ConditionFailedError)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:cockroach.proto.ConditionFailedError)
  return false;
#undef DO_
}

void ConditionFailedError::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:cockroach.proto.ConditionFailedError)
  // optional .cockroach.proto.Value actual_value = 1;
  if (has_actual_value()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->actual_value_, output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:cockroach.proto.ConditionFailedError)
}

::google::protobuf::uint8* ConditionFailedError::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:cockroach.proto.ConditionFailedError)
  // optional .cockroach.proto.Value actual_value = 1;
  if (has_actual_value()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, *this->actual_value_, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:cockroach.proto.ConditionFailedError)
  return target;
}

int ConditionFailedError::ByteSize() const {
  int total_size = 0;

  // optional .cockroach.proto.Value actual_value = 1;
  if (has_actual_value()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->actual_value_);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ConditionFailedError::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const ConditionFailedError* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const ConditionFailedError>(
          &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ConditionFailedError::MergeFrom(const ConditionFailedError& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_actual_value()) {
      mutable_actual_value()->::cockroach::proto::Value::MergeFrom(from.actual_value());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void ConditionFailedError::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ConditionFailedError::CopyFrom(const ConditionFailedError& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ConditionFailedError::IsInitialized() const {

  return true;
}

void ConditionFailedError::Swap(ConditionFailedError* other) {
  if (other == this) return;
  InternalSwap(other);
}
void ConditionFailedError::InternalSwap(ConditionFailedError* other) {
  std::swap(actual_value_, other->actual_value_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata ConditionFailedError::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ConditionFailedError_descriptor_;
  metadata.reflection = ConditionFailedError_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// ConditionFailedError

// optional .cockroach.proto.Value actual_value = 1;
bool ConditionFailedError::has_actual_value() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void ConditionFailedError::set_has_actual_value() {
  _has_bits_[0] |= 0x00000001u;
}
void ConditionFailedError::clear_has_actual_value() {
  _has_bits_[0] &= ~0x00000001u;
}
void ConditionFailedError::clear_actual_value() {
  if (actual_value_ != NULL) actual_value_->::cockroach::proto::Value::Clear();
  clear_has_actual_value();
}
 const ::cockroach::proto::Value& ConditionFailedError::actual_value() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.ConditionFailedError.actual_value)
  return actual_value_ != NULL ? *actual_value_ : *default_instance_->actual_value_;
}
 ::cockroach::proto::Value* ConditionFailedError::mutable_actual_value() {
  set_has_actual_value();
  if (actual_value_ == NULL) {
    actual_value_ = new ::cockroach::proto::Value;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.proto.ConditionFailedError.actual_value)
  return actual_value_;
}
 ::cockroach::proto::Value* ConditionFailedError::release_actual_value() {
  clear_has_actual_value();
  ::cockroach::proto::Value* temp = actual_value_;
  actual_value_ = NULL;
  return temp;
}
 void ConditionFailedError::set_allocated_actual_value(::cockroach::proto::Value* actual_value) {
  delete actual_value_;
  actual_value_ = actual_value;
  if (actual_value) {
    set_has_actual_value();
  } else {
    clear_has_actual_value();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.ConditionFailedError.actual_value)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#ifndef _MSC_VER
const int LeaseRejectedError::kRequestedFieldNumber;
const int LeaseRejectedError::kExistingFieldNumber;
#endif  // !_MSC_VER

LeaseRejectedError::LeaseRejectedError()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:cockroach.proto.LeaseRejectedError)
}

void LeaseRejectedError::InitAsDefaultInstance() {
  requested_ = const_cast< ::cockroach::proto::Lease*>(&::cockroach::proto::Lease::default_instance());
  existing_ = const_cast< ::cockroach::proto::Lease*>(&::cockroach::proto::Lease::default_instance());
}

LeaseRejectedError::LeaseRejectedError(const LeaseRejectedError& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:cockroach.proto.LeaseRejectedError)
}

void LeaseRejectedError::SharedCtor() {
  _cached_size_ = 0;
  requested_ = NULL;
  existing_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

LeaseRejectedError::~LeaseRejectedError() {
  // @@protoc_insertion_point(destructor:cockroach.proto.LeaseRejectedError)
  SharedDtor();
}

void LeaseRejectedError::SharedDtor() {
  if (this != default_instance_) {
    delete requested_;
    delete existing_;
  }
}

void LeaseRejectedError::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* LeaseRejectedError::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return LeaseRejectedError_descriptor_;
}

const LeaseRejectedError& LeaseRejectedError::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_cockroach_2fproto_2ferrors_2eproto();
  return *default_instance_;
}

LeaseRejectedError* LeaseRejectedError::default_instance_ = NULL;

LeaseRejectedError* LeaseRejectedError::New(::google::protobuf::Arena* arena) const {
  LeaseRejectedError* n = new LeaseRejectedError;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void LeaseRejectedError::Clear() {
  if (_has_bits_[0 / 32] & 3u) {
    if (has_requested()) {
      if (requested_ != NULL) requested_->::cockroach::proto::Lease::Clear();
    }
    if (has_existing()) {
      if (existing_ != NULL) existing_->::cockroach::proto::Lease::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool LeaseRejectedError::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:cockroach.proto.LeaseRejectedError)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .cockroach.proto.Lease Requested = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_requested()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_Existing;
        break;
      }

      // optional .cockroach.proto.Lease Existing = 2;
      case 2: {
        if (tag == 18) {
         parse_Existing:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_existing()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:cockroach.proto.LeaseRejectedError)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:cockroach.proto.LeaseRejectedError)
  return false;
#undef DO_
}

void LeaseRejectedError::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:cockroach.proto.LeaseRejectedError)
  // optional .cockroach.proto.Lease Requested = 1;
  if (has_requested()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->requested_, output);
  }

  // optional .cockroach.proto.Lease Existing = 2;
  if (has_existing()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, *this->existing_, output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:cockroach.proto.LeaseRejectedError)
}

::google::protobuf::uint8* LeaseRejectedError::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:cockroach.proto.LeaseRejectedError)
  // optional .cockroach.proto.Lease Requested = 1;
  if (has_requested()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, *this->requested_, target);
  }

  // optional .cockroach.proto.Lease Existing = 2;
  if (has_existing()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, *this->existing_, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:cockroach.proto.LeaseRejectedError)
  return target;
}

int LeaseRejectedError::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & 3) {
    // optional .cockroach.proto.Lease Requested = 1;
    if (has_requested()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->requested_);
    }

    // optional .cockroach.proto.Lease Existing = 2;
    if (has_existing()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->existing_);
    }

  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void LeaseRejectedError::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const LeaseRejectedError* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const LeaseRejectedError>(
          &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void LeaseRejectedError::MergeFrom(const LeaseRejectedError& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_requested()) {
      mutable_requested()->::cockroach::proto::Lease::MergeFrom(from.requested());
    }
    if (from.has_existing()) {
      mutable_existing()->::cockroach::proto::Lease::MergeFrom(from.existing());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void LeaseRejectedError::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void LeaseRejectedError::CopyFrom(const LeaseRejectedError& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LeaseRejectedError::IsInitialized() const {

  return true;
}

void LeaseRejectedError::Swap(LeaseRejectedError* other) {
  if (other == this) return;
  InternalSwap(other);
}
void LeaseRejectedError::InternalSwap(LeaseRejectedError* other) {
  std::swap(requested_, other->requested_);
  std::swap(existing_, other->existing_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata LeaseRejectedError::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = LeaseRejectedError_descriptor_;
  metadata.reflection = LeaseRejectedError_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// LeaseRejectedError

// optional .cockroach.proto.Lease Requested = 1;
bool LeaseRejectedError::has_requested() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void LeaseRejectedError::set_has_requested() {
  _has_bits_[0] |= 0x00000001u;
}
void LeaseRejectedError::clear_has_requested() {
  _has_bits_[0] &= ~0x00000001u;
}
void LeaseRejectedError::clear_requested() {
  if (requested_ != NULL) requested_->::cockroach::proto::Lease::Clear();
  clear_has_requested();
}
 const ::cockroach::proto::Lease& LeaseRejectedError::requested() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.LeaseRejectedError.Requested)
  return requested_ != NULL ? *requested_ : *default_instance_->requested_;
}
 ::cockroach::proto::Lease* LeaseRejectedError::mutable_requested() {
  set_has_requested();
  if (requested_ == NULL) {
    requested_ = new ::cockroach::proto::Lease;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.proto.LeaseRejectedError.Requested)
  return requested_;
}
 ::cockroach::proto::Lease* LeaseRejectedError::release_requested() {
  clear_has_requested();
  ::cockroach::proto::Lease* temp = requested_;
  requested_ = NULL;
  return temp;
}
 void LeaseRejectedError::set_allocated_requested(::cockroach::proto::Lease* requested) {
  delete requested_;
  requested_ = requested;
  if (requested) {
    set_has_requested();
  } else {
    clear_has_requested();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.LeaseRejectedError.Requested)
}

// optional .cockroach.proto.Lease Existing = 2;
bool LeaseRejectedError::has_existing() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void LeaseRejectedError::set_has_existing() {
  _has_bits_[0] |= 0x00000002u;
}
void LeaseRejectedError::clear_has_existing() {
  _has_bits_[0] &= ~0x00000002u;
}
void LeaseRejectedError::clear_existing() {
  if (existing_ != NULL) existing_->::cockroach::proto::Lease::Clear();
  clear_has_existing();
}
 const ::cockroach::proto::Lease& LeaseRejectedError::existing() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.LeaseRejectedError.Existing)
  return existing_ != NULL ? *existing_ : *default_instance_->existing_;
}
 ::cockroach::proto::Lease* LeaseRejectedError::mutable_existing() {
  set_has_existing();
  if (existing_ == NULL) {
    existing_ = new ::cockroach::proto::Lease;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.proto.LeaseRejectedError.Existing)
  return existing_;
}
 ::cockroach::proto::Lease* LeaseRejectedError::release_existing() {
  clear_has_existing();
  ::cockroach::proto::Lease* temp = existing_;
  existing_ = NULL;
  return temp;
}
 void LeaseRejectedError::set_allocated_existing(::cockroach::proto::Lease* existing) {
  delete existing_;
  existing_ = existing;
  if (existing) {
    set_has_existing();
  } else {
    clear_has_existing();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.LeaseRejectedError.Existing)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#ifndef _MSC_VER
const int ErrorDetail::kNotLeaderFieldNumber;
const int ErrorDetail::kRangeNotFoundFieldNumber;
const int ErrorDetail::kRangeKeyMismatchFieldNumber;
const int ErrorDetail::kReadWithinUncertaintyIntervalFieldNumber;
const int ErrorDetail::kTransactionAbortedFieldNumber;
const int ErrorDetail::kTransactionPushFieldNumber;
const int ErrorDetail::kTransactionRetryFieldNumber;
const int ErrorDetail::kTransactionStatusFieldNumber;
const int ErrorDetail::kWriteIntentFieldNumber;
const int ErrorDetail::kWriteTooOldFieldNumber;
const int ErrorDetail::kOpRequiresTxnFieldNumber;
const int ErrorDetail::kConditionFailedFieldNumber;
const int ErrorDetail::kLeaseRejectedFieldNumber;
#endif  // !_MSC_VER

ErrorDetail::ErrorDetail()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:cockroach.proto.ErrorDetail)
}

void ErrorDetail::InitAsDefaultInstance() {
  ErrorDetail_default_oneof_instance_->not_leader_ = const_cast< ::cockroach::proto::NotLeaderError*>(&::cockroach::proto::NotLeaderError::default_instance());
  ErrorDetail_default_oneof_instance_->range_not_found_ = const_cast< ::cockroach::proto::RangeNotFoundError*>(&::cockroach::proto::RangeNotFoundError::default_instance());
  ErrorDetail_default_oneof_instance_->range_key_mismatch_ = const_cast< ::cockroach::proto::RangeKeyMismatchError*>(&::cockroach::proto::RangeKeyMismatchError::default_instance());
  ErrorDetail_default_oneof_instance_->read_within_uncertainty_interval_ = const_cast< ::cockroach::proto::ReadWithinUncertaintyIntervalError*>(&::cockroach::proto::ReadWithinUncertaintyIntervalError::default_instance());
  ErrorDetail_default_oneof_instance_->transaction_aborted_ = const_cast< ::cockroach::proto::TransactionAbortedError*>(&::cockroach::proto::TransactionAbortedError::default_instance());
  ErrorDetail_default_oneof_instance_->transaction_push_ = const_cast< ::cockroach::proto::TransactionPushError*>(&::cockroach::proto::TransactionPushError::default_instance());
  ErrorDetail_default_oneof_instance_->transaction_retry_ = const_cast< ::cockroach::proto::TransactionRetryError*>(&::cockroach::proto::TransactionRetryError::default_instance());
  ErrorDetail_default_oneof_instance_->transaction_status_ = const_cast< ::cockroach::proto::TransactionStatusError*>(&::cockroach::proto::TransactionStatusError::default_instance());
  ErrorDetail_default_oneof_instance_->write_intent_ = const_cast< ::cockroach::proto::WriteIntentError*>(&::cockroach::proto::WriteIntentError::default_instance());
  ErrorDetail_default_oneof_instance_->write_too_old_ = const_cast< ::cockroach::proto::WriteTooOldError*>(&::cockroach::proto::WriteTooOldError::default_instance());
  ErrorDetail_default_oneof_instance_->op_requires_txn_ = const_cast< ::cockroach::proto::OpRequiresTxnError*>(&::cockroach::proto::OpRequiresTxnError::default_instance());
  ErrorDetail_default_oneof_instance_->condition_failed_ = const_cast< ::cockroach::proto::ConditionFailedError*>(&::cockroach::proto::ConditionFailedError::default_instance());
  ErrorDetail_default_oneof_instance_->lease_rejected_ = const_cast< ::cockroach::proto::LeaseRejectedError*>(&::cockroach::proto::LeaseRejectedError::default_instance());
}

ErrorDetail::ErrorDetail(const ErrorDetail& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:cockroach.proto.ErrorDetail)
}

void ErrorDetail::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  clear_has_value();
}

ErrorDetail::~ErrorDetail() {
  // @@protoc_insertion_point(destructor:cockroach.proto.ErrorDetail)
  SharedDtor();
}

void ErrorDetail::SharedDtor() {
  if (has_value()) {
    clear_value();
  }
  if (this != default_instance_) {
  }
}

void ErrorDetail::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ErrorDetail::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ErrorDetail_descriptor_;
}

const ErrorDetail& ErrorDetail::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_cockroach_2fproto_2ferrors_2eproto();
  return *default_instance_;
}

ErrorDetail* ErrorDetail::default_instance_ = NULL;

ErrorDetail* ErrorDetail::New(::google::protobuf::Arena* arena) const {
  ErrorDetail* n = new ErrorDetail;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void ErrorDetail::clear_value() {
  switch(value_case()) {
    case kNotLeader: {
      delete value_.not_leader_;
      break;
    }
    case kRangeNotFound: {
      delete value_.range_not_found_;
      break;
    }
    case kRangeKeyMismatch: {
      delete value_.range_key_mismatch_;
      break;
    }
    case kReadWithinUncertaintyInterval: {
      delete value_.read_within_uncertainty_interval_;
      break;
    }
    case kTransactionAborted: {
      delete value_.transaction_aborted_;
      break;
    }
    case kTransactionPush: {
      delete value_.transaction_push_;
      break;
    }
    case kTransactionRetry: {
      delete value_.transaction_retry_;
      break;
    }
    case kTransactionStatus: {
      delete value_.transaction_status_;
      break;
    }
    case kWriteIntent: {
      delete value_.write_intent_;
      break;
    }
    case kWriteTooOld: {
      delete value_.write_too_old_;
      break;
    }
    case kOpRequiresTxn: {
      delete value_.op_requires_txn_;
      break;
    }
    case kConditionFailed: {
      delete value_.condition_failed_;
      break;
    }
    case kLeaseRejected: {
      delete value_.lease_rejected_;
      break;
    }
    case VALUE_NOT_SET: {
      break;
    }
  }
  _oneof_case_[0] = VALUE_NOT_SET;
}


void ErrorDetail::Clear() {
  clear_value();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool ErrorDetail::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:cockroach.proto.ErrorDetail)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .cockroach.proto.NotLeaderError not_leader = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_not_leader()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_range_not_found;
        break;
      }

      // optional .cockroach.proto.RangeNotFoundError range_not_found = 2;
      case 2: {
        if (tag == 18) {
         parse_range_not_found:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_range_not_found()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_range_key_mismatch;
        break;
      }

      // optional .cockroach.proto.RangeKeyMismatchError range_key_mismatch = 3;
      case 3: {
        if (tag == 26) {
         parse_range_key_mismatch:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_range_key_mismatch()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_read_within_uncertainty_interval;
        break;
      }

      // optional .cockroach.proto.ReadWithinUncertaintyIntervalError read_within_uncertainty_interval = 4;
      case 4: {
        if (tag == 34) {
         parse_read_within_uncertainty_interval:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_read_within_uncertainty_interval()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_transaction_aborted;
        break;
      }

      // optional .cockroach.proto.TransactionAbortedError transaction_aborted = 5;
      case 5: {
        if (tag == 42) {
         parse_transaction_aborted:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_transaction_aborted()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(50)) goto parse_transaction_push;
        break;
      }

      // optional .cockroach.proto.TransactionPushError transaction_push = 6;
      case 6: {
        if (tag == 50) {
         parse_transaction_push:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_transaction_push()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(58)) goto parse_transaction_retry;
        break;
      }

      // optional .cockroach.proto.TransactionRetryError transaction_retry = 7;
      case 7: {
        if (tag == 58) {
         parse_transaction_retry:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_transaction_retry()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(66)) goto parse_transaction_status;
        break;
      }

      // optional .cockroach.proto.TransactionStatusError transaction_status = 8;
      case 8: {
        if (tag == 66) {
         parse_transaction_status:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_transaction_status()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(74)) goto parse_write_intent;
        break;
      }

      // optional .cockroach.proto.WriteIntentError write_intent = 9;
      case 9: {
        if (tag == 74) {
         parse_write_intent:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_write_intent()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(82)) goto parse_write_too_old;
        break;
      }

      // optional .cockroach.proto.WriteTooOldError write_too_old = 10;
      case 10: {
        if (tag == 82) {
         parse_write_too_old:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_write_too_old()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(90)) goto parse_op_requires_txn;
        break;
      }

      // optional .cockroach.proto.OpRequiresTxnError op_requires_txn = 11;
      case 11: {
        if (tag == 90) {
         parse_op_requires_txn:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_op_requires_txn()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(98)) goto parse_condition_failed;
        break;
      }

      // optional .cockroach.proto.ConditionFailedError condition_failed = 12;
      case 12: {
        if (tag == 98) {
         parse_condition_failed:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_condition_failed()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(106)) goto parse_lease_rejected;
        break;
      }

      // optional .cockroach.proto.LeaseRejectedError lease_rejected = 13;
      case 13: {
        if (tag == 106) {
         parse_lease_rejected:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_lease_rejected()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:cockroach.proto.ErrorDetail)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:cockroach.proto.ErrorDetail)
  return false;
#undef DO_
}

void ErrorDetail::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:cockroach.proto.ErrorDetail)
  // optional .cockroach.proto.NotLeaderError not_leader = 1;
  if (has_not_leader()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *value_.not_leader_, output);
  }

  // optional .cockroach.proto.RangeNotFoundError range_not_found = 2;
  if (has_range_not_found()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, *value_.range_not_found_, output);
  }

  // optional .cockroach.proto.RangeKeyMismatchError range_key_mismatch = 3;
  if (has_range_key_mismatch()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, *value_.range_key_mismatch_, output);
  }

  // optional .cockroach.proto.ReadWithinUncertaintyIntervalError read_within_uncertainty_interval = 4;
  if (has_read_within_uncertainty_interval()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, *value_.read_within_uncertainty_interval_, output);
  }

  // optional .cockroach.proto.TransactionAbortedError transaction_aborted = 5;
  if (has_transaction_aborted()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      5, *value_.transaction_aborted_, output);
  }

  // optional .cockroach.proto.TransactionPushError transaction_push = 6;
  if (has_transaction_push()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      6, *value_.transaction_push_, output);
  }

  // optional .cockroach.proto.TransactionRetryError transaction_retry = 7;
  if (has_transaction_retry()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      7, *value_.transaction_retry_, output);
  }

  // optional .cockroach.proto.TransactionStatusError transaction_status = 8;
  if (has_transaction_status()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      8, *value_.transaction_status_, output);
  }

  // optional .cockroach.proto.WriteIntentError write_intent = 9;
  if (has_write_intent()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      9, *value_.write_intent_, output);
  }

  // optional .cockroach.proto.WriteTooOldError write_too_old = 10;
  if (has_write_too_old()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      10, *value_.write_too_old_, output);
  }

  // optional .cockroach.proto.OpRequiresTxnError op_requires_txn = 11;
  if (has_op_requires_txn()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      11, *value_.op_requires_txn_, output);
  }

  // optional .cockroach.proto.ConditionFailedError condition_failed = 12;
  if (has_condition_failed()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      12, *value_.condition_failed_, output);
  }

  // optional .cockroach.proto.LeaseRejectedError lease_rejected = 13;
  if (has_lease_rejected()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      13, *value_.lease_rejected_, output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:cockroach.proto.ErrorDetail)
}

::google::protobuf::uint8* ErrorDetail::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:cockroach.proto.ErrorDetail)
  // optional .cockroach.proto.NotLeaderError not_leader = 1;
  if (has_not_leader()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, *value_.not_leader_, target);
  }

  // optional .cockroach.proto.RangeNotFoundError range_not_found = 2;
  if (has_range_not_found()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, *value_.range_not_found_, target);
  }

  // optional .cockroach.proto.RangeKeyMismatchError range_key_mismatch = 3;
  if (has_range_key_mismatch()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, *value_.range_key_mismatch_, target);
  }

  // optional .cockroach.proto.ReadWithinUncertaintyIntervalError read_within_uncertainty_interval = 4;
  if (has_read_within_uncertainty_interval()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        4, *value_.read_within_uncertainty_interval_, target);
  }

  // optional .cockroach.proto.TransactionAbortedError transaction_aborted = 5;
  if (has_transaction_aborted()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        5, *value_.transaction_aborted_, target);
  }

  // optional .cockroach.proto.TransactionPushError transaction_push = 6;
  if (has_transaction_push()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        6, *value_.transaction_push_, target);
  }

  // optional .cockroach.proto.TransactionRetryError transaction_retry = 7;
  if (has_transaction_retry()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        7, *value_.transaction_retry_, target);
  }

  // optional .cockroach.proto.TransactionStatusError transaction_status = 8;
  if (has_transaction_status()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        8, *value_.transaction_status_, target);
  }

  // optional .cockroach.proto.WriteIntentError write_intent = 9;
  if (has_write_intent()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        9, *value_.write_intent_, target);
  }

  // optional .cockroach.proto.WriteTooOldError write_too_old = 10;
  if (has_write_too_old()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        10, *value_.write_too_old_, target);
  }

  // optional .cockroach.proto.OpRequiresTxnError op_requires_txn = 11;
  if (has_op_requires_txn()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        11, *value_.op_requires_txn_, target);
  }

  // optional .cockroach.proto.ConditionFailedError condition_failed = 12;
  if (has_condition_failed()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        12, *value_.condition_failed_, target);
  }

  // optional .cockroach.proto.LeaseRejectedError lease_rejected = 13;
  if (has_lease_rejected()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        13, *value_.lease_rejected_, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:cockroach.proto.ErrorDetail)
  return target;
}

int ErrorDetail::ByteSize() const {
  int total_size = 0;

  switch (value_case()) {
    // optional .cockroach.proto.NotLeaderError not_leader = 1;
    case kNotLeader: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *value_.not_leader_);
      break;
    }
    // optional .cockroach.proto.RangeNotFoundError range_not_found = 2;
    case kRangeNotFound: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *value_.range_not_found_);
      break;
    }
    // optional .cockroach.proto.RangeKeyMismatchError range_key_mismatch = 3;
    case kRangeKeyMismatch: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *value_.range_key_mismatch_);
      break;
    }
    // optional .cockroach.proto.ReadWithinUncertaintyIntervalError read_within_uncertainty_interval = 4;
    case kReadWithinUncertaintyInterval: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *value_.read_within_uncertainty_interval_);
      break;
    }
    // optional .cockroach.proto.TransactionAbortedError transaction_aborted = 5;
    case kTransactionAborted: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *value_.transaction_aborted_);
      break;
    }
    // optional .cockroach.proto.TransactionPushError transaction_push = 6;
    case kTransactionPush: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *value_.transaction_push_);
      break;
    }
    // optional .cockroach.proto.TransactionRetryError transaction_retry = 7;
    case kTransactionRetry: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *value_.transaction_retry_);
      break;
    }
    // optional .cockroach.proto.TransactionStatusError transaction_status = 8;
    case kTransactionStatus: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *value_.transaction_status_);
      break;
    }
    // optional .cockroach.proto.WriteIntentError write_intent = 9;
    case kWriteIntent: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *value_.write_intent_);
      break;
    }
    // optional .cockroach.proto.WriteTooOldError write_too_old = 10;
    case kWriteTooOld: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *value_.write_too_old_);
      break;
    }
    // optional .cockroach.proto.OpRequiresTxnError op_requires_txn = 11;
    case kOpRequiresTxn: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *value_.op_requires_txn_);
      break;
    }
    // optional .cockroach.proto.ConditionFailedError condition_failed = 12;
    case kConditionFailed: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *value_.condition_failed_);
      break;
    }
    // optional .cockroach.proto.LeaseRejectedError lease_rejected = 13;
    case kLeaseRejected: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *value_.lease_rejected_);
      break;
    }
    case VALUE_NOT_SET: {
      break;
    }
  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ErrorDetail::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const ErrorDetail* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const ErrorDetail>(
          &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ErrorDetail::MergeFrom(const ErrorDetail& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  switch (from.value_case()) {
    case kNotLeader: {
      mutable_not_leader()->::cockroach::proto::NotLeaderError::MergeFrom(from.not_leader());
      break;
    }
    case kRangeNotFound: {
      mutable_range_not_found()->::cockroach::proto::RangeNotFoundError::MergeFrom(from.range_not_found());
      break;
    }
    case kRangeKeyMismatch: {
      mutable_range_key_mismatch()->::cockroach::proto::RangeKeyMismatchError::MergeFrom(from.range_key_mismatch());
      break;
    }
    case kReadWithinUncertaintyInterval: {
      mutable_read_within_uncertainty_interval()->::cockroach::proto::ReadWithinUncertaintyIntervalError::MergeFrom(from.read_within_uncertainty_interval());
      break;
    }
    case kTransactionAborted: {
      mutable_transaction_aborted()->::cockroach::proto::TransactionAbortedError::MergeFrom(from.transaction_aborted());
      break;
    }
    case kTransactionPush: {
      mutable_transaction_push()->::cockroach::proto::TransactionPushError::MergeFrom(from.transaction_push());
      break;
    }
    case kTransactionRetry: {
      mutable_transaction_retry()->::cockroach::proto::TransactionRetryError::MergeFrom(from.transaction_retry());
      break;
    }
    case kTransactionStatus: {
      mutable_transaction_status()->::cockroach::proto::TransactionStatusError::MergeFrom(from.transaction_status());
      break;
    }
    case kWriteIntent: {
      mutable_write_intent()->::cockroach::proto::WriteIntentError::MergeFrom(from.write_intent());
      break;
    }
    case kWriteTooOld: {
      mutable_write_too_old()->::cockroach::proto::WriteTooOldError::MergeFrom(from.write_too_old());
      break;
    }
    case kOpRequiresTxn: {
      mutable_op_requires_txn()->::cockroach::proto::OpRequiresTxnError::MergeFrom(from.op_requires_txn());
      break;
    }
    case kConditionFailed: {
      mutable_condition_failed()->::cockroach::proto::ConditionFailedError::MergeFrom(from.condition_failed());
      break;
    }
    case kLeaseRejected: {
      mutable_lease_rejected()->::cockroach::proto::LeaseRejectedError::MergeFrom(from.lease_rejected());
      break;
    }
    case VALUE_NOT_SET: {
      break;
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void ErrorDetail::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ErrorDetail::CopyFrom(const ErrorDetail& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ErrorDetail::IsInitialized() const {

  return true;
}

void ErrorDetail::Swap(ErrorDetail* other) {
  if (other == this) return;
  InternalSwap(other);
}
void ErrorDetail::InternalSwap(ErrorDetail* other) {
  std::swap(value_, other->value_);
  std::swap(_oneof_case_[0], other->_oneof_case_[0]);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata ErrorDetail::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ErrorDetail_descriptor_;
  metadata.reflection = ErrorDetail_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// ErrorDetail

// optional .cockroach.proto.NotLeaderError not_leader = 1;
bool ErrorDetail::has_not_leader() const {
  return value_case() == kNotLeader;
}
void ErrorDetail::set_has_not_leader() {
  _oneof_case_[0] = kNotLeader;
}
void ErrorDetail::clear_not_leader() {
  if (has_not_leader()) {
    delete value_.not_leader_;
    clear_has_value();
  }
}
 const ::cockroach::proto::NotLeaderError& ErrorDetail::not_leader() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.ErrorDetail.not_leader)
  return has_not_leader() ? *value_.not_leader_
                      : ::cockroach::proto::NotLeaderError::default_instance();
}
 ::cockroach::proto::NotLeaderError* ErrorDetail::mutable_not_leader() {
  if (!has_not_leader()) {
    clear_value();
    set_has_not_leader();
    value_.not_leader_ = new ::cockroach::proto::NotLeaderError;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.proto.ErrorDetail.not_leader)
  return value_.not_leader_;
}
 ::cockroach::proto::NotLeaderError* ErrorDetail::release_not_leader() {
  if (has_not_leader()) {
    clear_has_value();
    ::cockroach::proto::NotLeaderError* temp = value_.not_leader_;
    value_.not_leader_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
 void ErrorDetail::set_allocated_not_leader(::cockroach::proto::NotLeaderError* not_leader) {
  clear_value();
  if (not_leader) {
    set_has_not_leader();
    value_.not_leader_ = not_leader;
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.ErrorDetail.not_leader)
}

// optional .cockroach.proto.RangeNotFoundError range_not_found = 2;
bool ErrorDetail::has_range_not_found() const {
  return value_case() == kRangeNotFound;
}
void ErrorDetail::set_has_range_not_found() {
  _oneof_case_[0] = kRangeNotFound;
}
void ErrorDetail::clear_range_not_found() {
  if (has_range_not_found()) {
    delete value_.range_not_found_;
    clear_has_value();
  }
}
 const ::cockroach::proto::RangeNotFoundError& ErrorDetail::range_not_found() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.ErrorDetail.range_not_found)
  return has_range_not_found() ? *value_.range_not_found_
                      : ::cockroach::proto::RangeNotFoundError::default_instance();
}
 ::cockroach::proto::RangeNotFoundError* ErrorDetail::mutable_range_not_found() {
  if (!has_range_not_found()) {
    clear_value();
    set_has_range_not_found();
    value_.range_not_found_ = new ::cockroach::proto::RangeNotFoundError;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.proto.ErrorDetail.range_not_found)
  return value_.range_not_found_;
}
 ::cockroach::proto::RangeNotFoundError* ErrorDetail::release_range_not_found() {
  if (has_range_not_found()) {
    clear_has_value();
    ::cockroach::proto::RangeNotFoundError* temp = value_.range_not_found_;
    value_.range_not_found_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
 void ErrorDetail::set_allocated_range_not_found(::cockroach::proto::RangeNotFoundError* range_not_found) {
  clear_value();
  if (range_not_found) {
    set_has_range_not_found();
    value_.range_not_found_ = range_not_found;
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.ErrorDetail.range_not_found)
}

// optional .cockroach.proto.RangeKeyMismatchError range_key_mismatch = 3;
bool ErrorDetail::has_range_key_mismatch() const {
  return value_case() == kRangeKeyMismatch;
}
void ErrorDetail::set_has_range_key_mismatch() {
  _oneof_case_[0] = kRangeKeyMismatch;
}
void ErrorDetail::clear_range_key_mismatch() {
  if (has_range_key_mismatch()) {
    delete value_.range_key_mismatch_;
    clear_has_value();
  }
}
 const ::cockroach::proto::RangeKeyMismatchError& ErrorDetail::range_key_mismatch() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.ErrorDetail.range_key_mismatch)
  return has_range_key_mismatch() ? *value_.range_key_mismatch_
                      : ::cockroach::proto::RangeKeyMismatchError::default_instance();
}
 ::cockroach::proto::RangeKeyMismatchError* ErrorDetail::mutable_range_key_mismatch() {
  if (!has_range_key_mismatch()) {
    clear_value();
    set_has_range_key_mismatch();
    value_.range_key_mismatch_ = new ::cockroach::proto::RangeKeyMismatchError;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.proto.ErrorDetail.range_key_mismatch)
  return value_.range_key_mismatch_;
}
 ::cockroach::proto::RangeKeyMismatchError* ErrorDetail::release_range_key_mismatch() {
  if (has_range_key_mismatch()) {
    clear_has_value();
    ::cockroach::proto::RangeKeyMismatchError* temp = value_.range_key_mismatch_;
    value_.range_key_mismatch_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
 void ErrorDetail::set_allocated_range_key_mismatch(::cockroach::proto::RangeKeyMismatchError* range_key_mismatch) {
  clear_value();
  if (range_key_mismatch) {
    set_has_range_key_mismatch();
    value_.range_key_mismatch_ = range_key_mismatch;
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.ErrorDetail.range_key_mismatch)
}

// optional .cockroach.proto.ReadWithinUncertaintyIntervalError read_within_uncertainty_interval = 4;
bool ErrorDetail::has_read_within_uncertainty_interval() const {
  return value_case() == kReadWithinUncertaintyInterval;
}
void ErrorDetail::set_has_read_within_uncertainty_interval() {
  _oneof_case_[0] = kReadWithinUncertaintyInterval;
}
void ErrorDetail::clear_read_within_uncertainty_interval() {
  if (has_read_within_uncertainty_interval()) {
    delete value_.read_within_uncertainty_interval_;
    clear_has_value();
  }
}
 const ::cockroach::proto::ReadWithinUncertaintyIntervalError& ErrorDetail::read_within_uncertainty_interval() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.ErrorDetail.read_within_uncertainty_interval)
  return has_read_within_uncertainty_interval() ? *value_.read_within_uncertainty_interval_
                      : ::cockroach::proto::ReadWithinUncertaintyIntervalError::default_instance();
}
 ::cockroach::proto::ReadWithinUncertaintyIntervalError* ErrorDetail::mutable_read_within_uncertainty_interval() {
  if (!has_read_within_uncertainty_interval()) {
    clear_value();
    set_has_read_within_uncertainty_interval();
    value_.read_within_uncertainty_interval_ = new ::cockroach::proto::ReadWithinUncertaintyIntervalError;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.proto.ErrorDetail.read_within_uncertainty_interval)
  return value_.read_within_uncertainty_interval_;
}
 ::cockroach::proto::ReadWithinUncertaintyIntervalError* ErrorDetail::release_read_within_uncertainty_interval() {
  if (has_read_within_uncertainty_interval()) {
    clear_has_value();
    ::cockroach::proto::ReadWithinUncertaintyIntervalError* temp = value_.read_within_uncertainty_interval_;
    value_.read_within_uncertainty_interval_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
 void ErrorDetail::set_allocated_read_within_uncertainty_interval(::cockroach::proto::ReadWithinUncertaintyIntervalError* read_within_uncertainty_interval) {
  clear_value();
  if (read_within_uncertainty_interval) {
    set_has_read_within_uncertainty_interval();
    value_.read_within_uncertainty_interval_ = read_within_uncertainty_interval;
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.ErrorDetail.read_within_uncertainty_interval)
}

// optional .cockroach.proto.TransactionAbortedError transaction_aborted = 5;
bool ErrorDetail::has_transaction_aborted() const {
  return value_case() == kTransactionAborted;
}
void ErrorDetail::set_has_transaction_aborted() {
  _oneof_case_[0] = kTransactionAborted;
}
void ErrorDetail::clear_transaction_aborted() {
  if (has_transaction_aborted()) {
    delete value_.transaction_aborted_;
    clear_has_value();
  }
}
 const ::cockroach::proto::TransactionAbortedError& ErrorDetail::transaction_aborted() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.ErrorDetail.transaction_aborted)
  return has_transaction_aborted() ? *value_.transaction_aborted_
                      : ::cockroach::proto::TransactionAbortedError::default_instance();
}
 ::cockroach::proto::TransactionAbortedError* ErrorDetail::mutable_transaction_aborted() {
  if (!has_transaction_aborted()) {
    clear_value();
    set_has_transaction_aborted();
    value_.transaction_aborted_ = new ::cockroach::proto::TransactionAbortedError;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.proto.ErrorDetail.transaction_aborted)
  return value_.transaction_aborted_;
}
 ::cockroach::proto::TransactionAbortedError* ErrorDetail::release_transaction_aborted() {
  if (has_transaction_aborted()) {
    clear_has_value();
    ::cockroach::proto::TransactionAbortedError* temp = value_.transaction_aborted_;
    value_.transaction_aborted_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
 void ErrorDetail::set_allocated_transaction_aborted(::cockroach::proto::TransactionAbortedError* transaction_aborted) {
  clear_value();
  if (transaction_aborted) {
    set_has_transaction_aborted();
    value_.transaction_aborted_ = transaction_aborted;
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.ErrorDetail.transaction_aborted)
}

// optional .cockroach.proto.TransactionPushError transaction_push = 6;
bool ErrorDetail::has_transaction_push() const {
  return value_case() == kTransactionPush;
}
void ErrorDetail::set_has_transaction_push() {
  _oneof_case_[0] = kTransactionPush;
}
void ErrorDetail::clear_transaction_push() {
  if (has_transaction_push()) {
    delete value_.transaction_push_;
    clear_has_value();
  }
}
 const ::cockroach::proto::TransactionPushError& ErrorDetail::transaction_push() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.ErrorDetail.transaction_push)
  return has_transaction_push() ? *value_.transaction_push_
                      : ::cockroach::proto::TransactionPushError::default_instance();
}
 ::cockroach::proto::TransactionPushError* ErrorDetail::mutable_transaction_push() {
  if (!has_transaction_push()) {
    clear_value();
    set_has_transaction_push();
    value_.transaction_push_ = new ::cockroach::proto::TransactionPushError;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.proto.ErrorDetail.transaction_push)
  return value_.transaction_push_;
}
 ::cockroach::proto::TransactionPushError* ErrorDetail::release_transaction_push() {
  if (has_transaction_push()) {
    clear_has_value();
    ::cockroach::proto::TransactionPushError* temp = value_.transaction_push_;
    value_.transaction_push_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
 void ErrorDetail::set_allocated_transaction_push(::cockroach::proto::TransactionPushError* transaction_push) {
  clear_value();
  if (transaction_push) {
    set_has_transaction_push();
    value_.transaction_push_ = transaction_push;
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.ErrorDetail.transaction_push)
}

// optional .cockroach.proto.TransactionRetryError transaction_retry = 7;
bool ErrorDetail::has_transaction_retry() const {
  return value_case() == kTransactionRetry;
}
void ErrorDetail::set_has_transaction_retry() {
  _oneof_case_[0] = kTransactionRetry;
}
void ErrorDetail::clear_transaction_retry() {
  if (has_transaction_retry()) {
    delete value_.transaction_retry_;
    clear_has_value();
  }
}
 const ::cockroach::proto::TransactionRetryError& ErrorDetail::transaction_retry() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.ErrorDetail.transaction_retry)
  return has_transaction_retry() ? *value_.transaction_retry_
                      : ::cockroach::proto::TransactionRetryError::default_instance();
}
 ::cockroach::proto::TransactionRetryError* ErrorDetail::mutable_transaction_retry() {
  if (!has_transaction_retry()) {
    clear_value();
    set_has_transaction_retry();
    value_.transaction_retry_ = new ::cockroach::proto::TransactionRetryError;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.proto.ErrorDetail.transaction_retry)
  return value_.transaction_retry_;
}
 ::cockroach::proto::TransactionRetryError* ErrorDetail::release_transaction_retry() {
  if (has_transaction_retry()) {
    clear_has_value();
    ::cockroach::proto::TransactionRetryError* temp = value_.transaction_retry_;
    value_.transaction_retry_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
 void ErrorDetail::set_allocated_transaction_retry(::cockroach::proto::TransactionRetryError* transaction_retry) {
  clear_value();
  if (transaction_retry) {
    set_has_transaction_retry();
    value_.transaction_retry_ = transaction_retry;
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.ErrorDetail.transaction_retry)
}

// optional .cockroach.proto.TransactionStatusError transaction_status = 8;
bool ErrorDetail::has_transaction_status() const {
  return value_case() == kTransactionStatus;
}
void ErrorDetail::set_has_transaction_status() {
  _oneof_case_[0] = kTransactionStatus;
}
void ErrorDetail::clear_transaction_status() {
  if (has_transaction_status()) {
    delete value_.transaction_status_;
    clear_has_value();
  }
}
 const ::cockroach::proto::TransactionStatusError& ErrorDetail::transaction_status() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.ErrorDetail.transaction_status)
  return has_transaction_status() ? *value_.transaction_status_
                      : ::cockroach::proto::TransactionStatusError::default_instance();
}
 ::cockroach::proto::TransactionStatusError* ErrorDetail::mutable_transaction_status() {
  if (!has_transaction_status()) {
    clear_value();
    set_has_transaction_status();
    value_.transaction_status_ = new ::cockroach::proto::TransactionStatusError;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.proto.ErrorDetail.transaction_status)
  return value_.transaction_status_;
}
 ::cockroach::proto::TransactionStatusError* ErrorDetail::release_transaction_status() {
  if (has_transaction_status()) {
    clear_has_value();
    ::cockroach::proto::TransactionStatusError* temp = value_.transaction_status_;
    value_.transaction_status_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
 void ErrorDetail::set_allocated_transaction_status(::cockroach::proto::TransactionStatusError* transaction_status) {
  clear_value();
  if (transaction_status) {
    set_has_transaction_status();
    value_.transaction_status_ = transaction_status;
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.ErrorDetail.transaction_status)
}

// optional .cockroach.proto.WriteIntentError write_intent = 9;
bool ErrorDetail::has_write_intent() const {
  return value_case() == kWriteIntent;
}
void ErrorDetail::set_has_write_intent() {
  _oneof_case_[0] = kWriteIntent;
}
void ErrorDetail::clear_write_intent() {
  if (has_write_intent()) {
    delete value_.write_intent_;
    clear_has_value();
  }
}
 const ::cockroach::proto::WriteIntentError& ErrorDetail::write_intent() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.ErrorDetail.write_intent)
  return has_write_intent() ? *value_.write_intent_
                      : ::cockroach::proto::WriteIntentError::default_instance();
}
 ::cockroach::proto::WriteIntentError* ErrorDetail::mutable_write_intent() {
  if (!has_write_intent()) {
    clear_value();
    set_has_write_intent();
    value_.write_intent_ = new ::cockroach::proto::WriteIntentError;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.proto.ErrorDetail.write_intent)
  return value_.write_intent_;
}
 ::cockroach::proto::WriteIntentError* ErrorDetail::release_write_intent() {
  if (has_write_intent()) {
    clear_has_value();
    ::cockroach::proto::WriteIntentError* temp = value_.write_intent_;
    value_.write_intent_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
 void ErrorDetail::set_allocated_write_intent(::cockroach::proto::WriteIntentError* write_intent) {
  clear_value();
  if (write_intent) {
    set_has_write_intent();
    value_.write_intent_ = write_intent;
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.ErrorDetail.write_intent)
}

// optional .cockroach.proto.WriteTooOldError write_too_old = 10;
bool ErrorDetail::has_write_too_old() const {
  return value_case() == kWriteTooOld;
}
void ErrorDetail::set_has_write_too_old() {
  _oneof_case_[0] = kWriteTooOld;
}
void ErrorDetail::clear_write_too_old() {
  if (has_write_too_old()) {
    delete value_.write_too_old_;
    clear_has_value();
  }
}
 const ::cockroach::proto::WriteTooOldError& ErrorDetail::write_too_old() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.ErrorDetail.write_too_old)
  return has_write_too_old() ? *value_.write_too_old_
                      : ::cockroach::proto::WriteTooOldError::default_instance();
}
 ::cockroach::proto::WriteTooOldError* ErrorDetail::mutable_write_too_old() {
  if (!has_write_too_old()) {
    clear_value();
    set_has_write_too_old();
    value_.write_too_old_ = new ::cockroach::proto::WriteTooOldError;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.proto.ErrorDetail.write_too_old)
  return value_.write_too_old_;
}
 ::cockroach::proto::WriteTooOldError* ErrorDetail::release_write_too_old() {
  if (has_write_too_old()) {
    clear_has_value();
    ::cockroach::proto::WriteTooOldError* temp = value_.write_too_old_;
    value_.write_too_old_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
 void ErrorDetail::set_allocated_write_too_old(::cockroach::proto::WriteTooOldError* write_too_old) {
  clear_value();
  if (write_too_old) {
    set_has_write_too_old();
    value_.write_too_old_ = write_too_old;
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.ErrorDetail.write_too_old)
}

// optional .cockroach.proto.OpRequiresTxnError op_requires_txn = 11;
bool ErrorDetail::has_op_requires_txn() const {
  return value_case() == kOpRequiresTxn;
}
void ErrorDetail::set_has_op_requires_txn() {
  _oneof_case_[0] = kOpRequiresTxn;
}
void ErrorDetail::clear_op_requires_txn() {
  if (has_op_requires_txn()) {
    delete value_.op_requires_txn_;
    clear_has_value();
  }
}
 const ::cockroach::proto::OpRequiresTxnError& ErrorDetail::op_requires_txn() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.ErrorDetail.op_requires_txn)
  return has_op_requires_txn() ? *value_.op_requires_txn_
                      : ::cockroach::proto::OpRequiresTxnError::default_instance();
}
 ::cockroach::proto::OpRequiresTxnError* ErrorDetail::mutable_op_requires_txn() {
  if (!has_op_requires_txn()) {
    clear_value();
    set_has_op_requires_txn();
    value_.op_requires_txn_ = new ::cockroach::proto::OpRequiresTxnError;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.proto.ErrorDetail.op_requires_txn)
  return value_.op_requires_txn_;
}
 ::cockroach::proto::OpRequiresTxnError* ErrorDetail::release_op_requires_txn() {
  if (has_op_requires_txn()) {
    clear_has_value();
    ::cockroach::proto::OpRequiresTxnError* temp = value_.op_requires_txn_;
    value_.op_requires_txn_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
 void ErrorDetail::set_allocated_op_requires_txn(::cockroach::proto::OpRequiresTxnError* op_requires_txn) {
  clear_value();
  if (op_requires_txn) {
    set_has_op_requires_txn();
    value_.op_requires_txn_ = op_requires_txn;
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.ErrorDetail.op_requires_txn)
}

// optional .cockroach.proto.ConditionFailedError condition_failed = 12;
bool ErrorDetail::has_condition_failed() const {
  return value_case() == kConditionFailed;
}
void ErrorDetail::set_has_condition_failed() {
  _oneof_case_[0] = kConditionFailed;
}
void ErrorDetail::clear_condition_failed() {
  if (has_condition_failed()) {
    delete value_.condition_failed_;
    clear_has_value();
  }
}
 const ::cockroach::proto::ConditionFailedError& ErrorDetail::condition_failed() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.ErrorDetail.condition_failed)
  return has_condition_failed() ? *value_.condition_failed_
                      : ::cockroach::proto::ConditionFailedError::default_instance();
}
 ::cockroach::proto::ConditionFailedError* ErrorDetail::mutable_condition_failed() {
  if (!has_condition_failed()) {
    clear_value();
    set_has_condition_failed();
    value_.condition_failed_ = new ::cockroach::proto::ConditionFailedError;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.proto.ErrorDetail.condition_failed)
  return value_.condition_failed_;
}
 ::cockroach::proto::ConditionFailedError* ErrorDetail::release_condition_failed() {
  if (has_condition_failed()) {
    clear_has_value();
    ::cockroach::proto::ConditionFailedError* temp = value_.condition_failed_;
    value_.condition_failed_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
 void ErrorDetail::set_allocated_condition_failed(::cockroach::proto::ConditionFailedError* condition_failed) {
  clear_value();
  if (condition_failed) {
    set_has_condition_failed();
    value_.condition_failed_ = condition_failed;
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.ErrorDetail.condition_failed)
}

// optional .cockroach.proto.LeaseRejectedError lease_rejected = 13;
bool ErrorDetail::has_lease_rejected() const {
  return value_case() == kLeaseRejected;
}
void ErrorDetail::set_has_lease_rejected() {
  _oneof_case_[0] = kLeaseRejected;
}
void ErrorDetail::clear_lease_rejected() {
  if (has_lease_rejected()) {
    delete value_.lease_rejected_;
    clear_has_value();
  }
}
 const ::cockroach::proto::LeaseRejectedError& ErrorDetail::lease_rejected() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.ErrorDetail.lease_rejected)
  return has_lease_rejected() ? *value_.lease_rejected_
                      : ::cockroach::proto::LeaseRejectedError::default_instance();
}
 ::cockroach::proto::LeaseRejectedError* ErrorDetail::mutable_lease_rejected() {
  if (!has_lease_rejected()) {
    clear_value();
    set_has_lease_rejected();
    value_.lease_rejected_ = new ::cockroach::proto::LeaseRejectedError;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.proto.ErrorDetail.lease_rejected)
  return value_.lease_rejected_;
}
 ::cockroach::proto::LeaseRejectedError* ErrorDetail::release_lease_rejected() {
  if (has_lease_rejected()) {
    clear_has_value();
    ::cockroach::proto::LeaseRejectedError* temp = value_.lease_rejected_;
    value_.lease_rejected_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
 void ErrorDetail::set_allocated_lease_rejected(::cockroach::proto::LeaseRejectedError* lease_rejected) {
  clear_value();
  if (lease_rejected) {
    set_has_lease_rejected();
    value_.lease_rejected_ = lease_rejected;
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.ErrorDetail.lease_rejected)
}

bool ErrorDetail::has_value() const {
  return value_case() != VALUE_NOT_SET;
}
void ErrorDetail::clear_has_value() {
  _oneof_case_[0] = VALUE_NOT_SET;
}
ErrorDetail::ValueCase ErrorDetail::value_case() const {
  return ErrorDetail::ValueCase(_oneof_case_[0]);
}
#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#ifndef _MSC_VER
const int Error::kMessageFieldNumber;
const int Error::kRetryableFieldNumber;
const int Error::kTransactionRestartFieldNumber;
const int Error::kDetailFieldNumber;
#endif  // !_MSC_VER

Error::Error()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:cockroach.proto.Error)
}

void Error::InitAsDefaultInstance() {
  detail_ = const_cast< ::cockroach::proto::ErrorDetail*>(&::cockroach::proto::ErrorDetail::default_instance());
}

Error::Error(const Error& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:cockroach.proto.Error)
}

void Error::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  message_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  retryable_ = false;
  transaction_restart_ = 0;
  detail_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Error::~Error() {
  // @@protoc_insertion_point(destructor:cockroach.proto.Error)
  SharedDtor();
}

void Error::SharedDtor() {
  message_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != default_instance_) {
    delete detail_;
  }
}

void Error::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Error::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Error_descriptor_;
}

const Error& Error::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_cockroach_2fproto_2ferrors_2eproto();
  return *default_instance_;
}

Error* Error::default_instance_ = NULL;

Error* Error::New(::google::protobuf::Arena* arena) const {
  Error* n = new Error;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Error::Clear() {
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<Error*>(16)->f)

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  if (_has_bits_[0 / 32] & 15u) {
    ZR_(retryable_, transaction_restart_);
    if (has_message()) {
      message_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    if (has_detail()) {
      if (detail_ != NULL) detail_->::cockroach::proto::ErrorDetail::Clear();
    }
  }

#undef ZR_HELPER_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool Error::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:cockroach.proto.Error)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string message = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_message()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->message().data(), this->message().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "cockroach.proto.Error.message");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_retryable;
        break;
      }

      // optional bool retryable = 2;
      case 2: {
        if (tag == 16) {
         parse_retryable:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &retryable_)));
          set_has_retryable();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_detail;
        break;
      }

      // optional .cockroach.proto.ErrorDetail detail = 3;
      case 3: {
        if (tag == 26) {
         parse_detail:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_detail()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_transaction_restart;
        break;
      }

      // optional .cockroach.proto.TransactionRestart transaction_restart = 4;
      case 4: {
        if (tag == 32) {
         parse_transaction_restart:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::cockroach::proto::TransactionRestart_IsValid(value)) {
            set_transaction_restart(static_cast< ::cockroach::proto::TransactionRestart >(value));
          } else {
            mutable_unknown_fields()->AddVarint(4, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:cockroach.proto.Error)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:cockroach.proto.Error)
  return false;
#undef DO_
}

void Error::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:cockroach.proto.Error)
  // optional string message = 1;
  if (has_message()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->message().data(), this->message().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "cockroach.proto.Error.message");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->message(), output);
  }

  // optional bool retryable = 2;
  if (has_retryable()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(2, this->retryable(), output);
  }

  // optional .cockroach.proto.ErrorDetail detail = 3;
  if (has_detail()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, *this->detail_, output);
  }

  // optional .cockroach.proto.TransactionRestart transaction_restart = 4;
  if (has_transaction_restart()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      4, this->transaction_restart(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:cockroach.proto.Error)
}

::google::protobuf::uint8* Error::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:cockroach.proto.Error)
  // optional string message = 1;
  if (has_message()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->message().data(), this->message().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "cockroach.proto.Error.message");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->message(), target);
  }

  // optional bool retryable = 2;
  if (has_retryable()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(2, this->retryable(), target);
  }

  // optional .cockroach.proto.ErrorDetail detail = 3;
  if (has_detail()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, *this->detail_, target);
  }

  // optional .cockroach.proto.TransactionRestart transaction_restart = 4;
  if (has_transaction_restart()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      4, this->transaction_restart(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:cockroach.proto.Error)
  return target;
}

int Error::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & 15) {
    // optional string message = 1;
    if (has_message()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->message());
    }

    // optional bool retryable = 2;
    if (has_retryable()) {
      total_size += 1 + 1;
    }

    // optional .cockroach.proto.TransactionRestart transaction_restart = 4;
    if (has_transaction_restart()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->transaction_restart());
    }

    // optional .cockroach.proto.ErrorDetail detail = 3;
    if (has_detail()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->detail_);
    }

  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Error::MergeFrom(const ::google::protobuf::Message& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const Error* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const Error>(
          &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Error::MergeFrom(const Error& from) {
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_message()) {
      set_has_message();
      message_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.message_);
    }
    if (from.has_retryable()) {
      set_retryable(from.retryable());
    }
    if (from.has_transaction_restart()) {
      set_transaction_restart(from.transaction_restart());
    }
    if (from.has_detail()) {
      mutable_detail()->::cockroach::proto::ErrorDetail::MergeFrom(from.detail());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void Error::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Error::CopyFrom(const Error& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Error::IsInitialized() const {

  return true;
}

void Error::Swap(Error* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Error::InternalSwap(Error* other) {
  message_.Swap(&other->message_);
  std::swap(retryable_, other->retryable_);
  std::swap(transaction_restart_, other->transaction_restart_);
  std::swap(detail_, other->detail_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata Error::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Error_descriptor_;
  metadata.reflection = Error_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// Error

// optional string message = 1;
bool Error::has_message() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void Error::set_has_message() {
  _has_bits_[0] |= 0x00000001u;
}
void Error::clear_has_message() {
  _has_bits_[0] &= ~0x00000001u;
}
void Error::clear_message() {
  message_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_message();
}
 const ::std::string& Error::message() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.Error.message)
  return message_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Error::set_message(const ::std::string& value) {
  set_has_message();
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cockroach.proto.Error.message)
}
 void Error::set_message(const char* value) {
  set_has_message();
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cockroach.proto.Error.message)
}
 void Error::set_message(const char* value, size_t size) {
  set_has_message();
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cockroach.proto.Error.message)
}
 ::std::string* Error::mutable_message() {
  set_has_message();
  // @@protoc_insertion_point(field_mutable:cockroach.proto.Error.message)
  return message_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* Error::release_message() {
  clear_has_message();
  return message_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Error::set_allocated_message(::std::string* message) {
  if (message != NULL) {
    set_has_message();
  } else {
    clear_has_message();
  }
  message_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), message);
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.Error.message)
}

// optional bool retryable = 2;
bool Error::has_retryable() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void Error::set_has_retryable() {
  _has_bits_[0] |= 0x00000002u;
}
void Error::clear_has_retryable() {
  _has_bits_[0] &= ~0x00000002u;
}
void Error::clear_retryable() {
  retryable_ = false;
  clear_has_retryable();
}
 bool Error::retryable() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.Error.retryable)
  return retryable_;
}
 void Error::set_retryable(bool value) {
  set_has_retryable();
  retryable_ = value;
  // @@protoc_insertion_point(field_set:cockroach.proto.Error.retryable)
}

// optional .cockroach.proto.TransactionRestart transaction_restart = 4;
bool Error::has_transaction_restart() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void Error::set_has_transaction_restart() {
  _has_bits_[0] |= 0x00000004u;
}
void Error::clear_has_transaction_restart() {
  _has_bits_[0] &= ~0x00000004u;
}
void Error::clear_transaction_restart() {
  transaction_restart_ = 0;
  clear_has_transaction_restart();
}
 ::cockroach::proto::TransactionRestart Error::transaction_restart() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.Error.transaction_restart)
  return static_cast< ::cockroach::proto::TransactionRestart >(transaction_restart_);
}
 void Error::set_transaction_restart(::cockroach::proto::TransactionRestart value) {
  assert(::cockroach::proto::TransactionRestart_IsValid(value));
  set_has_transaction_restart();
  transaction_restart_ = value;
  // @@protoc_insertion_point(field_set:cockroach.proto.Error.transaction_restart)
}

// optional .cockroach.proto.ErrorDetail detail = 3;
bool Error::has_detail() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void Error::set_has_detail() {
  _has_bits_[0] |= 0x00000008u;
}
void Error::clear_has_detail() {
  _has_bits_[0] &= ~0x00000008u;
}
void Error::clear_detail() {
  if (detail_ != NULL) detail_->::cockroach::proto::ErrorDetail::Clear();
  clear_has_detail();
}
 const ::cockroach::proto::ErrorDetail& Error::detail() const {
  // @@protoc_insertion_point(field_get:cockroach.proto.Error.detail)
  return detail_ != NULL ? *detail_ : *default_instance_->detail_;
}
 ::cockroach::proto::ErrorDetail* Error::mutable_detail() {
  set_has_detail();
  if (detail_ == NULL) {
    detail_ = new ::cockroach::proto::ErrorDetail;
  }
  // @@protoc_insertion_point(field_mutable:cockroach.proto.Error.detail)
  return detail_;
}
 ::cockroach::proto::ErrorDetail* Error::release_detail() {
  clear_has_detail();
  ::cockroach::proto::ErrorDetail* temp = detail_;
  detail_ = NULL;
  return temp;
}
 void Error::set_allocated_detail(::cockroach::proto::ErrorDetail* detail) {
  delete detail_;
  detail_ = detail;
  if (detail) {
    set_has_detail();
  } else {
    clear_has_detail();
  }
  // @@protoc_insertion_point(field_set_allocated:cockroach.proto.Error.detail)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// @@protoc_insertion_point(namespace_scope)

}  // namespace proto
}  // namespace cockroach

// @@protoc_insertion_point(global_scope)
