// Copyright 2016 The Cockroach Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
// implied. See the License for the specific language governing
// permissions and limitations under the License.
//
// Author: Radu Berinde (radu@cockroachlabs.com)

package main

import (
	"fmt"
	"os"
	"reflect"
	"strings"

	"github.com/cockroachdb/cockroach/roachpb"
)

func main() {
	f, err := os.Create("batch-summary.go")
	if err != nil {
		fmt.Fprintln(os.Stderr, "Error opening file: ", err)
		os.Exit(1)
	}
	t := reflect.TypeOf(roachpb.RequestUnion{})
	n := t.NumField()

	// A few shorthands to help make the names more terse.
	shorthands := map[string]string{
		"Delete":      "Del",
		"Range":       "Rng",
		"Transaction": "Txn",
		"Reverse":     "Rev",
		"Admin":       "Adm",
		"Increment":   "Inc",
		"Conditional": "C",
		"Checksum":    "Chk",
	}

	fmt.Fprint(f, `// Code generated by gen-batch-summary.go; DO NOT EDIT

package roachpb

import (
	"bytes"
	"fmt"
)

var requestNames = []string{`)
	for i := 0; i < n; i++ {
		name := t.Field(i).Name
		for str, short := range shorthands {
			name = strings.Replace(name, str, short, -1)
		}
		fmt.Fprintf(f, `
	"%s",`, name)
	}
	fmt.Fprint(f, `
}
`)

	fmt.Fprintf(f, `
// Summary prints a short summary of the requests in a batch.
func (br *BatchRequest) Summary() string {
	if len(br.Requests) == 0 {
		return "empty batch"
	}
	var num [%d]int
	for _, r := range br.Requests {
		switch {
`, n)

	for i := 0; i < n; i++ {
		fmt.Fprintf(f, `		case r.%s != nil:
			num[%d]++
`, t.Field(i).Name, i)
	}

	// We don't use Fprint to avoid go vet warnings about
	// formatting directives in string.
	fmt.Fprintf(f, "%s", `		}
	}
	var buf bytes.Buffer
	for i, v := range num {
		if v == 0 {
			continue
		}
		if buf.Len() > 0 {
			buf.WriteString(", ")
		}
		fmt.Fprintf(&buf, "%d %s", v, requestNames[i])
	}
	return buf.String()
}
`)

	if err := f.Close(); err != nil {
		fmt.Fprintln(os.Stderr, "Error closing file: ", err)
		os.Exit(1)
	}
}
