// Code generated by protoc-gen-gogo.
// source: cockroach/roachpb/data.proto
// DO NOT EDIT!

package roachpb

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"

// skipping weak import gogoproto "github.com/cockroachdb/gogoproto"

import github_com_cockroachdb_cockroach_util_uuid "github.com/cockroachdb/cockroach/util/uuid"

import github_com_gogo_protobuf_sortkeys "github.com/gogo/protobuf/sortkeys"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// ValueType defines a set of type constants placed in the "tag" field of Value
// messages. These are defined as a protocol buffer enumeration so that they
// can be used portably between our Go and C code. The tags are used by the
// RocksDB Merge Operator to perform specialized merges.
type ValueType int32

const (
	// This is a subset of the SQL column type values, representing the underlying
	// storage for various types. The DELIMITED_foo entries each represent a foo
	// variant that self-delimits length.
	ValueType_UNKNOWN           ValueType = 0
	ValueType_NULL              ValueType = 7
	ValueType_INT               ValueType = 1
	ValueType_FLOAT             ValueType = 2
	ValueType_BYTES             ValueType = 3
	ValueType_DELIMITED_BYTES   ValueType = 8
	ValueType_TIME              ValueType = 4
	ValueType_DECIMAL           ValueType = 5
	ValueType_DELIMITED_DECIMAL ValueType = 9
	ValueType_DURATION          ValueType = 6
	// TUPLE represents a DTuple, encoded as repeated pairs of varint field number
	// followed by a value encoded Datum.
	ValueType_TUPLE ValueType = 10
	// TIMESERIES is applied to values which contain InternalTimeSeriesData.
	ValueType_TIMESERIES ValueType = 100
)

var ValueType_name = map[int32]string{
	0:   "UNKNOWN",
	7:   "NULL",
	1:   "INT",
	2:   "FLOAT",
	3:   "BYTES",
	8:   "DELIMITED_BYTES",
	4:   "TIME",
	5:   "DECIMAL",
	9:   "DELIMITED_DECIMAL",
	6:   "DURATION",
	10:  "TUPLE",
	100: "TIMESERIES",
}
var ValueType_value = map[string]int32{
	"UNKNOWN":           0,
	"NULL":              7,
	"INT":               1,
	"FLOAT":             2,
	"BYTES":             3,
	"DELIMITED_BYTES":   8,
	"TIME":              4,
	"DECIMAL":           5,
	"DELIMITED_DECIMAL": 9,
	"DURATION":          6,
	"TUPLE":             10,
	"TIMESERIES":        100,
}

func (x ValueType) Enum() *ValueType {
	p := new(ValueType)
	*p = x
	return p
}
func (x ValueType) String() string {
	return proto.EnumName(ValueType_name, int32(x))
}
func (x *ValueType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(ValueType_value, data, "ValueType")
	if err != nil {
		return err
	}
	*x = ValueType(value)
	return nil
}
func (ValueType) EnumDescriptor() ([]byte, []int) { return fileDescriptorData, []int{0} }

// ReplicaChangeType is a parameter of ChangeReplicasTrigger.
type ReplicaChangeType int32

const (
	ADD_REPLICA    ReplicaChangeType = 0
	REMOVE_REPLICA ReplicaChangeType = 1
)

var ReplicaChangeType_name = map[int32]string{
	0: "ADD_REPLICA",
	1: "REMOVE_REPLICA",
}
var ReplicaChangeType_value = map[string]int32{
	"ADD_REPLICA":    0,
	"REMOVE_REPLICA": 1,
}

func (x ReplicaChangeType) Enum() *ReplicaChangeType {
	p := new(ReplicaChangeType)
	*p = x
	return p
}
func (x ReplicaChangeType) String() string {
	return proto.EnumName(ReplicaChangeType_name, int32(x))
}
func (x *ReplicaChangeType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(ReplicaChangeType_value, data, "ReplicaChangeType")
	if err != nil {
		return err
	}
	*x = ReplicaChangeType(value)
	return nil
}
func (ReplicaChangeType) EnumDescriptor() ([]byte, []int) { return fileDescriptorData, []int{1} }

// IsolationType TODO(jiajia) Needs documentation.
type IsolationType int32

const (
	// SERIALIZABLE TODO(jiajia) Needs documentation.
	SERIALIZABLE IsolationType = 0
	// SNAPSHOT TODO(jiajia) Needs documentation.
	SNAPSHOT IsolationType = 1
)

var IsolationType_name = map[int32]string{
	0: "SERIALIZABLE",
	1: "SNAPSHOT",
}
var IsolationType_value = map[string]int32{
	"SERIALIZABLE": 0,
	"SNAPSHOT":     1,
}

func (x IsolationType) Enum() *IsolationType {
	p := new(IsolationType)
	*p = x
	return p
}
func (x IsolationType) String() string {
	return proto.EnumName(IsolationType_name, int32(x))
}
func (x *IsolationType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(IsolationType_value, data, "IsolationType")
	if err != nil {
		return err
	}
	*x = IsolationType(value)
	return nil
}
func (IsolationType) EnumDescriptor() ([]byte, []int) { return fileDescriptorData, []int{2} }

// TransactionStatus specifies possible states for a transaction.
type TransactionStatus int32

const (
	// PENDING is the default state for a new transaction. Transactions
	// move from PENDING to one of COMMITTED or ABORTED. Mutations made
	// as part of a PENDING transactions are recorded as "intents" in
	// the underlying MVCC model.
	PENDING TransactionStatus = 0
	// COMMITTED is the state for a transaction which has been
	// committed. Mutations made as part of a transaction which is moved
	// into COMMITTED state become durable and visible to other
	// transactions, moving from "intents" to permanent versioned
	// values.
	COMMITTED TransactionStatus = 1
	// ABORTED is the state for a transaction which has been aborted.
	// Mutations made as part of a transaction which is moved into
	// ABORTED state are deleted and are never made visible to other
	// transactions.
	ABORTED TransactionStatus = 2
)

var TransactionStatus_name = map[int32]string{
	0: "PENDING",
	1: "COMMITTED",
	2: "ABORTED",
}
var TransactionStatus_value = map[string]int32{
	"PENDING":   0,
	"COMMITTED": 1,
	"ABORTED":   2,
}

func (x TransactionStatus) Enum() *TransactionStatus {
	p := new(TransactionStatus)
	*p = x
	return p
}
func (x TransactionStatus) String() string {
	return proto.EnumName(TransactionStatus_name, int32(x))
}
func (x *TransactionStatus) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(TransactionStatus_value, data, "TransactionStatus")
	if err != nil {
		return err
	}
	*x = TransactionStatus(value)
	return nil
}
func (TransactionStatus) EnumDescriptor() ([]byte, []int) { return fileDescriptorData, []int{3} }

// Span is supplied with every storage node request.
type Span struct {
	// The key for request. If the request operates on a range, this
	// represents the starting key for the range.
	Key Key `protobuf:"bytes,3,opt,name=key,casttype=Key" json:"key,omitempty"`
	// The end key is empty if the request spans only a single key. Otherwise,
	// it must order strictly after Key. In such a case, the header indicates
	// that the operation takes place on the key range from Key to EndKey,
	// including Key and excluding EndKey.
	EndKey Key `protobuf:"bytes,4,opt,name=end_key,json=endKey,casttype=Key" json:"end_key,omitempty"`
}

func (m *Span) Reset()                    { *m = Span{} }
func (m *Span) String() string            { return proto.CompactTextString(m) }
func (*Span) ProtoMessage()               {}
func (*Span) Descriptor() ([]byte, []int) { return fileDescriptorData, []int{0} }

// Timestamp represents a state of the hybrid logical clock.
type Timestamp struct {
	// Holds a wall time, typically a unix epoch time
	// expressed in nanoseconds.
	WallTime int64 `protobuf:"varint,1,opt,name=wall_time,json=wallTime" json:"wall_time"`
	// The logical component captures causality for events whose wall
	// times are equal. It is effectively bounded by (maximum clock
	// skew)/(minimal ns between events) and nearly impossible to
	// overflow.
	Logical int32 `protobuf:"varint,2,opt,name=logical" json:"logical"`
}

func (m *Timestamp) Reset()                    { *m = Timestamp{} }
func (*Timestamp) ProtoMessage()               {}
func (*Timestamp) Descriptor() ([]byte, []int) { return fileDescriptorData, []int{1} }

// Value specifies the value at a key. Multiple values at the same key are
// supported based on timestamp. The data stored within a value is typed
// (ValueType) and custom encoded into the raw_bytes field. A custom encoding
// is used instead of separate proto fields to avoid proto overhead and to
// avoid unnecessary encoding and decoding as the value gets read from disk and
// passed through the network. The format is:
//
//   <4-byte-checksum><1-byte-tag><encoded-data>
//
// A CRC-32-IEEE checksum is computed from the associated key, tag and encoded
// data, in that order.
//
// TODO(peter): Is a 4-byte checksum overkill when most (all?) values
// will be less than 64KB?
type Value struct {
	// raw_bytes contains the encoded value and checksum.
	RawBytes []byte `protobuf:"bytes,1,opt,name=raw_bytes,json=rawBytes" json:"raw_bytes,omitempty"`
	// Timestamp of value.
	Timestamp Timestamp `protobuf:"bytes,2,opt,name=timestamp" json:"timestamp"`
}

func (m *Value) Reset()                    { *m = Value{} }
func (m *Value) String() string            { return proto.CompactTextString(m) }
func (*Value) ProtoMessage()               {}
func (*Value) Descriptor() ([]byte, []int) { return fileDescriptorData, []int{2} }

// KeyValue is a pair of Key and Value for returned Key/Value pairs
// from ScanRequest/ScanResponse. It embeds a Key and a Value.
type KeyValue struct {
	Key   Key   `protobuf:"bytes,1,opt,name=key,casttype=Key" json:"key,omitempty"`
	Value Value `protobuf:"bytes,2,opt,name=value" json:"value"`
}

func (m *KeyValue) Reset()                    { *m = KeyValue{} }
func (m *KeyValue) String() string            { return proto.CompactTextString(m) }
func (*KeyValue) ProtoMessage()               {}
func (*KeyValue) Descriptor() ([]byte, []int) { return fileDescriptorData, []int{3} }

// A StoreIdent uniquely identifies a store in the cluster. The
// StoreIdent is written to the underlying storage engine at a
// store-reserved system key (KeyLocalIdent).
type StoreIdent struct {
	ClusterID github_com_cockroachdb_cockroach_util_uuid.UUID `protobuf:"bytes,1,opt,name=cluster_id,json=clusterId,customtype=github.com/cockroachdb/cockroach/util/uuid.UUID" json:"cluster_id"`
	NodeID    NodeID                                          `protobuf:"varint,2,opt,name=node_id,json=nodeId,casttype=NodeID" json:"node_id"`
	StoreID   StoreID                                         `protobuf:"varint,3,opt,name=store_id,json=storeId,casttype=StoreID" json:"store_id"`
}

func (m *StoreIdent) Reset()                    { *m = StoreIdent{} }
func (m *StoreIdent) String() string            { return proto.CompactTextString(m) }
func (*StoreIdent) ProtoMessage()               {}
func (*StoreIdent) Descriptor() ([]byte, []int) { return fileDescriptorData, []int{4} }

// A SplitTrigger is run after a successful commit of an AdminSplit
// command. It provides the updated range descriptor covering the
// first half of the split and the new range descriptor covering the
// second half. This information allows the final bookkeeping for
// the split to be completed and the new range put into operation.
type SplitTrigger struct {
	UpdatedDesc RangeDescriptor `protobuf:"bytes,1,opt,name=updated_desc,json=updatedDesc" json:"updated_desc"`
	NewDesc     RangeDescriptor `protobuf:"bytes,2,opt,name=new_desc,json=newDesc" json:"new_desc"`
	// initial_leader_store_id designates the replica which should start
	// a raft election upon processing this split.
	InitialLeaderStoreID StoreID `protobuf:"varint,3,opt,name=initial_leader_store_id,json=initialLeaderStoreId,casttype=StoreID" json:"initial_leader_store_id"`
}

func (m *SplitTrigger) Reset()                    { *m = SplitTrigger{} }
func (m *SplitTrigger) String() string            { return proto.CompactTextString(m) }
func (*SplitTrigger) ProtoMessage()               {}
func (*SplitTrigger) Descriptor() ([]byte, []int) { return fileDescriptorData, []int{5} }

// A MergeTrigger is run after a successful commit of an AdminMerge
// command. It provides the updated range descriptor that now encompasses
// what was originally both ranges and the soon to be invalid range
// descriptor that used to cover the subsumed half of the merge. This
// information allows the final bookkeeping for the merge to be completed
// and put into operation.
type MergeTrigger struct {
	// The updated range descriptor that now encompasses what was originally
	// both ranges.
	UpdatedDesc RangeDescriptor `protobuf:"bytes,1,opt,name=updated_desc,json=updatedDesc" json:"updated_desc"`
	// The soon to be invalid range descriptor that used to cover the subsumed
	// half of the merge.
	SubsumedDesc RangeDescriptor `protobuf:"bytes,2,opt,name=subsumed_desc,json=subsumedDesc" json:"subsumed_desc"`
}

func (m *MergeTrigger) Reset()                    { *m = MergeTrigger{} }
func (m *MergeTrigger) String() string            { return proto.CompactTextString(m) }
func (*MergeTrigger) ProtoMessage()               {}
func (*MergeTrigger) Descriptor() ([]byte, []int) { return fileDescriptorData, []int{6} }

type ChangeReplicasTrigger struct {
	ChangeType ReplicaChangeType `protobuf:"varint,1,opt,name=change_type,json=changeType,enum=cockroach.roachpb.ReplicaChangeType" json:"change_type"`
	// The replica being modified.
	Replica ReplicaDescriptor `protobuf:"bytes,2,opt,name=replica" json:"replica"`
	// The new replica list with this change applied.
	UpdatedReplicas []ReplicaDescriptor `protobuf:"bytes,3,rep,name=updated_replicas,json=updatedReplicas" json:"updated_replicas"`
	NextReplicaID   ReplicaID           `protobuf:"varint,4,opt,name=next_replica_id,json=nextReplicaId,casttype=ReplicaID" json:"next_replica_id"`
}

func (m *ChangeReplicasTrigger) Reset()                    { *m = ChangeReplicasTrigger{} }
func (m *ChangeReplicasTrigger) String() string            { return proto.CompactTextString(m) }
func (*ChangeReplicasTrigger) ProtoMessage()               {}
func (*ChangeReplicasTrigger) Descriptor() ([]byte, []int) { return fileDescriptorData, []int{7} }

// ModifiedSpanTrigger indicates that a specific span has been modified.
// This can be used to trigger scan-and-gossip for the given span.
type ModifiedSpanTrigger struct {
	SystemConfigSpan bool `protobuf:"varint,1,opt,name=system_config_span,json=systemConfigSpan" json:"system_config_span"`
}

func (m *ModifiedSpanTrigger) Reset()                    { *m = ModifiedSpanTrigger{} }
func (m *ModifiedSpanTrigger) String() string            { return proto.CompactTextString(m) }
func (*ModifiedSpanTrigger) ProtoMessage()               {}
func (*ModifiedSpanTrigger) Descriptor() ([]byte, []int) { return fileDescriptorData, []int{8} }

// InternalCommitTrigger encapsulates all of the internal-only commit triggers.
// Only one may be set.
type InternalCommitTrigger struct {
	SplitTrigger          *SplitTrigger          `protobuf:"bytes,1,opt,name=split_trigger,json=splitTrigger" json:"split_trigger,omitempty"`
	MergeTrigger          *MergeTrigger          `protobuf:"bytes,2,opt,name=merge_trigger,json=mergeTrigger" json:"merge_trigger,omitempty"`
	ChangeReplicasTrigger *ChangeReplicasTrigger `protobuf:"bytes,3,opt,name=change_replicas_trigger,json=changeReplicasTrigger" json:"change_replicas_trigger,omitempty"`
	ModifiedSpanTrigger   *ModifiedSpanTrigger   `protobuf:"bytes,4,opt,name=modified_span_trigger,json=modifiedSpanTrigger" json:"modified_span_trigger,omitempty"`
}

func (m *InternalCommitTrigger) Reset()                    { *m = InternalCommitTrigger{} }
func (m *InternalCommitTrigger) String() string            { return proto.CompactTextString(m) }
func (*InternalCommitTrigger) ProtoMessage()               {}
func (*InternalCommitTrigger) Descriptor() ([]byte, []int) { return fileDescriptorData, []int{9} }

func (m *InternalCommitTrigger) GetSplitTrigger() *SplitTrigger {
	if m != nil {
		return m.SplitTrigger
	}
	return nil
}

func (m *InternalCommitTrigger) GetMergeTrigger() *MergeTrigger {
	if m != nil {
		return m.MergeTrigger
	}
	return nil
}

func (m *InternalCommitTrigger) GetChangeReplicasTrigger() *ChangeReplicasTrigger {
	if m != nil {
		return m.ChangeReplicasTrigger
	}
	return nil
}

func (m *InternalCommitTrigger) GetModifiedSpanTrigger() *ModifiedSpanTrigger {
	if m != nil {
		return m.ModifiedSpanTrigger
	}
	return nil
}

// TxnMeta is the metadata of a Transaction record.
type TxnMeta struct {
	// id is a unique UUID value which identifies the transaction.
	ID        *github_com_cockroachdb_cockroach_util_uuid.UUID `protobuf:"bytes,1,opt,name=id,customtype=github.com/cockroachdb/cockroach/util/uuid.UUID" json:"id,omitempty"`
	Isolation IsolationType                                    `protobuf:"varint,2,opt,name=isolation,enum=cockroach.roachpb.IsolationType" json:"isolation"`
	// key is the key which anchors the transaction. This is typically
	// the first key read or written during the transaction and determines which
	// range in the cluster will hold the transaction record.
	Key Key `protobuf:"bytes,3,opt,name=key,casttype=Key" json:"key,omitempty"`
	// Incremented on txn retry.
	Epoch uint32 `protobuf:"varint,4,opt,name=epoch" json:"epoch"`
	// The proposed timestamp for the transaction. This starts as
	// the current wall time on the txn coordinator.
	Timestamp Timestamp `protobuf:"bytes,5,opt,name=timestamp" json:"timestamp"`
	Priority  int32     `protobuf:"varint,6,opt,name=priority" json:"priority"`
	// A one-indexed sequence number which is increased on each batch
	// sent as part of the transaction. Used to prevent replay and
	// out-of-order application protection (by means of a transaction
	// retry).
	Sequence int32 `protobuf:"varint,7,opt,name=sequence" json:"sequence"`
	// A zero-indexed sequence number indicating the index of a
	// command within a batch. This disambiguate Raft replays of a batch
	// from multiple commands in a batch which modify the same key.
	BatchIndex int32 `protobuf:"varint,8,opt,name=batch_index,json=batchIndex" json:"batch_index"`
}

func (m *TxnMeta) Reset()                    { *m = TxnMeta{} }
func (m *TxnMeta) String() string            { return proto.CompactTextString(m) }
func (*TxnMeta) ProtoMessage()               {}
func (*TxnMeta) Descriptor() ([]byte, []int) { return fileDescriptorData, []int{10} }

// A Transaction is a unit of work performed on the database.
// Cockroach transactions support two isolation levels: snapshot
// isolation and serializable snapshot isolation. Each Cockroach
// transaction is assigned a random priority. This priority will be
// used to decide whether a transaction will be aborted during
// contention.
//
// If you add fields to Transaction you'll need to update
// Transaction.Clone. Failure to do so will result in test failures.
type Transaction struct {
	// The transaction metadata. These are persisted with every intent.
	TxnMeta `protobuf:"bytes,1,opt,name=meta,embedded=meta" json:"meta"`
	// A free-text identifier for debug purposes.
	Name   string            `protobuf:"bytes,2,opt,name=name" json:"name"`
	Status TransactionStatus `protobuf:"varint,4,opt,name=status,enum=cockroach.roachpb.TransactionStatus" json:"status"`
	// The last heartbeat timestamp.
	LastHeartbeat *Timestamp `protobuf:"bytes,5,opt,name=last_heartbeat,json=lastHeartbeat" json:"last_heartbeat,omitempty"`
	// The original timestamp at which the transaction started. For serializable
	// transactions, if the timestamp drifts from the original timestamp, the
	// transaction will retry.
	OrigTimestamp Timestamp `protobuf:"bytes,6,opt,name=orig_timestamp,json=origTimestamp" json:"orig_timestamp"`
	// Initial Timestamp + clock skew. Reads which encounter values with
	// timestamps between timestamp and max_timestamp trigger a txn
	// retry error, unless the node being read is listed in observed_timestamps
	// (in which case no more read uncertainty can occur).
	// The case max_timestamp < timestamp is possible for transactions which have
	// been pushed; in this case, max_timestamp should be ignored.
	MaxTimestamp Timestamp `protobuf:"bytes,7,opt,name=max_timestamp,json=maxTimestamp" json:"max_timestamp"`
	// A map of NodeID to timestamps as observed from their local clock during
	// this transaction. The purpose of this map is to avoid uncertainty related
	// restarts which normally occur when reading a value in the near future as
	// per the max_timestamp field.
	// When this map holds a corresponding entry for the node the current request
	// is executing on, we can run the command with the map's timestamp as the
	// top boundary of our uncertainty interval, limiting (and often avoiding)
	// uncertainty restarts.
	ObservedTimestamps map[NodeID]Timestamp `protobuf:"bytes,8,rep,name=observed_timestamps,json=observedTimestamps,castkey=NodeID" json:"observed_timestamps" protobuf_key:"varint,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// Writing is true if the transaction has previously executed a successful
	// write request, i.e. a request that may have left intents (across retries).
	Writing bool `protobuf:"varint,9,opt,name=writing" json:"writing"`
	// If this is true, the transaction must retry. Relevant only for
	// SNAPSHOT transactions: a SERIALIZABLE transaction would have to
	// retry anyway due to its commit timestamp having moved forward.
	// This bool is set instead of immediately returning a txn retry
	// error so that intents can continue to be laid down, minimizing
	// work required on txn restart.
	WriteTooOld bool `protobuf:"varint,12,opt,name=write_too_old,json=writeTooOld" json:"write_too_old"`
	// If retry_on_push is true, the transaction must retry in the event
	// that the commit timestamp is pushed forward. This flag is set if
	// the transaction contains any calls to DeleteRange, in order to
	// prevent the LostDeleteRange anomaly. This flag is relevant only
	// for SNAPSHOT transactions.
	RetryOnPush bool   `protobuf:"varint,13,opt,name=retry_on_push,json=retryOnPush" json:"retry_on_push"`
	Intents     []Span `protobuf:"bytes,11,rep,name=intents" json:"intents"`
}

func (m *Transaction) Reset()                    { *m = Transaction{} }
func (*Transaction) ProtoMessage()               {}
func (*Transaction) Descriptor() ([]byte, []int) { return fileDescriptorData, []int{11} }

// A Intent is a Span together with a Transaction metadata and its status.
type Intent struct {
	Span   `protobuf:"bytes,1,opt,name=span,embedded=span" json:"span"`
	Txn    TxnMeta           `protobuf:"bytes,2,opt,name=txn" json:"txn"`
	Status TransactionStatus `protobuf:"varint,3,opt,name=status,enum=cockroach.roachpb.TransactionStatus" json:"status"`
}

func (m *Intent) Reset()                    { *m = Intent{} }
func (m *Intent) String() string            { return proto.CompactTextString(m) }
func (*Intent) ProtoMessage()               {}
func (*Intent) Descriptor() ([]byte, []int) { return fileDescriptorData, []int{12} }

// Lease contains information about leader leases including the
// expiration and lease holder. It defines the two intervals
// [start, start_stasis) and [start_stasis, expiration). The
// former encompasses those timestamps for which the lease is
// active, while the latter is a cooldown period which avoids
// inconsistencies during leadership changes as explained below.
type Lease struct {
	// The start is a timestamp at which the lease begins. This value
	// must be greater than the last lease expiration or the lease request
	// is considered invalid.
	Start Timestamp `protobuf:"bytes,1,opt,name=start" json:"start"`
	// Before the lease expires, it enters a "stasis period" the length of which
	// is usually determined by the lease holder's maximum allowed clock offset.
	// During this stasis period, the lease must not be used (but can be extended
	// by the owner instead). This prevents a failure of linearizability on a
	// single register during lease changes. Without that stasis period, the
	// following could occur:
	// * a leader lease gets committed on the new leader (but not the old).
	// * client proposes and commits a write on new leader (with a timestamp
	//   just greater than the expiration of the old lease).
	// * client tries to read what it wrote, but hits a slow coordinator
	//   (which assigns a timestamp covered by the old lease).
	// * the read is served by the old leader (which has not processed the
	//   change in leadership).
	// * the client fails to read their own write.
	//
	// Instead, the old leader must refuse to serve the client's command on the
	// basis that its timestamp falls within the stasis period.
	StartStasis Timestamp `protobuf:"bytes,4,opt,name=start_stasis,json=startStasis" json:"start_stasis"`
	// The expiration is a timestamp at which the lease expires. This means that
	// a new lease can be granted for a later timestamp.
	Expiration Timestamp `protobuf:"bytes,2,opt,name=expiration" json:"expiration"`
	// The address of the would-be lease holder.
	Replica ReplicaDescriptor `protobuf:"bytes,3,opt,name=replica" json:"replica"`
}

func (m *Lease) Reset()                    { *m = Lease{} }
func (*Lease) ProtoMessage()               {}
func (*Lease) Descriptor() ([]byte, []int) { return fileDescriptorData, []int{13} }

// AbortCacheEntry contains information about a transaction which has
// been aborted. It's written to a range's abort cache if the range
// may have contained intents of the aborted txn. In the event that
// the same transaction attempts to read keys it may have written
// previously, this entry informs the transaction that it has aborted
// and must start fresh with an updated priority.
type AbortCacheEntry struct {
	// The key of the associated transaction.
	Key Key `protobuf:"bytes,1,opt,name=key,casttype=Key" json:"key,omitempty"`
	// The candidate commit timestamp the transaction record held at the time
	// it was aborted.
	Timestamp Timestamp `protobuf:"bytes,2,opt,name=timestamp" json:"timestamp"`
	// The priority of the transaction.
	Priority int32 `protobuf:"varint,3,opt,name=priority" json:"priority"`
}

func (m *AbortCacheEntry) Reset()                    { *m = AbortCacheEntry{} }
func (m *AbortCacheEntry) String() string            { return proto.CompactTextString(m) }
func (*AbortCacheEntry) ProtoMessage()               {}
func (*AbortCacheEntry) Descriptor() ([]byte, []int) { return fileDescriptorData, []int{14} }

func init() {
	proto.RegisterType((*Span)(nil), "cockroach.roachpb.Span")
	proto.RegisterType((*Timestamp)(nil), "cockroach.roachpb.Timestamp")
	proto.RegisterType((*Value)(nil), "cockroach.roachpb.Value")
	proto.RegisterType((*KeyValue)(nil), "cockroach.roachpb.KeyValue")
	proto.RegisterType((*StoreIdent)(nil), "cockroach.roachpb.StoreIdent")
	proto.RegisterType((*SplitTrigger)(nil), "cockroach.roachpb.SplitTrigger")
	proto.RegisterType((*MergeTrigger)(nil), "cockroach.roachpb.MergeTrigger")
	proto.RegisterType((*ChangeReplicasTrigger)(nil), "cockroach.roachpb.ChangeReplicasTrigger")
	proto.RegisterType((*ModifiedSpanTrigger)(nil), "cockroach.roachpb.ModifiedSpanTrigger")
	proto.RegisterType((*InternalCommitTrigger)(nil), "cockroach.roachpb.InternalCommitTrigger")
	proto.RegisterType((*TxnMeta)(nil), "cockroach.roachpb.TxnMeta")
	proto.RegisterType((*Transaction)(nil), "cockroach.roachpb.Transaction")
	proto.RegisterType((*Intent)(nil), "cockroach.roachpb.Intent")
	proto.RegisterType((*Lease)(nil), "cockroach.roachpb.Lease")
	proto.RegisterType((*AbortCacheEntry)(nil), "cockroach.roachpb.AbortCacheEntry")
	proto.RegisterEnum("cockroach.roachpb.ValueType", ValueType_name, ValueType_value)
	proto.RegisterEnum("cockroach.roachpb.ReplicaChangeType", ReplicaChangeType_name, ReplicaChangeType_value)
	proto.RegisterEnum("cockroach.roachpb.IsolationType", IsolationType_name, IsolationType_value)
	proto.RegisterEnum("cockroach.roachpb.TransactionStatus", TransactionStatus_name, TransactionStatus_value)
}
func (m *Span) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Span) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Key != nil {
		data[i] = 0x1a
		i++
		i = encodeVarintData(data, i, uint64(len(m.Key)))
		i += copy(data[i:], m.Key)
	}
	if m.EndKey != nil {
		data[i] = 0x22
		i++
		i = encodeVarintData(data, i, uint64(len(m.EndKey)))
		i += copy(data[i:], m.EndKey)
	}
	return i, nil
}

func (m *Timestamp) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Timestamp) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	data[i] = 0x8
	i++
	i = encodeVarintData(data, i, uint64(m.WallTime))
	data[i] = 0x10
	i++
	i = encodeVarintData(data, i, uint64(m.Logical))
	return i, nil
}

func (m *Value) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Value) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.RawBytes != nil {
		data[i] = 0xa
		i++
		i = encodeVarintData(data, i, uint64(len(m.RawBytes)))
		i += copy(data[i:], m.RawBytes)
	}
	data[i] = 0x12
	i++
	i = encodeVarintData(data, i, uint64(m.Timestamp.Size()))
	n1, err := m.Timestamp.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n1
	return i, nil
}

func (m *KeyValue) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *KeyValue) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Key != nil {
		data[i] = 0xa
		i++
		i = encodeVarintData(data, i, uint64(len(m.Key)))
		i += copy(data[i:], m.Key)
	}
	data[i] = 0x12
	i++
	i = encodeVarintData(data, i, uint64(m.Value.Size()))
	n2, err := m.Value.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n2
	return i, nil
}

func (m *StoreIdent) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *StoreIdent) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	data[i] = 0xa
	i++
	i = encodeVarintData(data, i, uint64(m.ClusterID.Size()))
	n3, err := m.ClusterID.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n3
	data[i] = 0x10
	i++
	i = encodeVarintData(data, i, uint64(m.NodeID))
	data[i] = 0x18
	i++
	i = encodeVarintData(data, i, uint64(m.StoreID))
	return i, nil
}

func (m *SplitTrigger) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *SplitTrigger) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	data[i] = 0xa
	i++
	i = encodeVarintData(data, i, uint64(m.UpdatedDesc.Size()))
	n4, err := m.UpdatedDesc.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n4
	data[i] = 0x12
	i++
	i = encodeVarintData(data, i, uint64(m.NewDesc.Size()))
	n5, err := m.NewDesc.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n5
	data[i] = 0x18
	i++
	i = encodeVarintData(data, i, uint64(m.InitialLeaderStoreID))
	return i, nil
}

func (m *MergeTrigger) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *MergeTrigger) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	data[i] = 0xa
	i++
	i = encodeVarintData(data, i, uint64(m.UpdatedDesc.Size()))
	n6, err := m.UpdatedDesc.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n6
	data[i] = 0x12
	i++
	i = encodeVarintData(data, i, uint64(m.SubsumedDesc.Size()))
	n7, err := m.SubsumedDesc.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n7
	return i, nil
}

func (m *ChangeReplicasTrigger) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *ChangeReplicasTrigger) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	data[i] = 0x8
	i++
	i = encodeVarintData(data, i, uint64(m.ChangeType))
	data[i] = 0x12
	i++
	i = encodeVarintData(data, i, uint64(m.Replica.Size()))
	n8, err := m.Replica.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n8
	if len(m.UpdatedReplicas) > 0 {
		for _, msg := range m.UpdatedReplicas {
			data[i] = 0x1a
			i++
			i = encodeVarintData(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	data[i] = 0x20
	i++
	i = encodeVarintData(data, i, uint64(m.NextReplicaID))
	return i, nil
}

func (m *ModifiedSpanTrigger) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *ModifiedSpanTrigger) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	data[i] = 0x8
	i++
	if m.SystemConfigSpan {
		data[i] = 1
	} else {
		data[i] = 0
	}
	i++
	return i, nil
}

func (m *InternalCommitTrigger) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *InternalCommitTrigger) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.SplitTrigger != nil {
		data[i] = 0xa
		i++
		i = encodeVarintData(data, i, uint64(m.SplitTrigger.Size()))
		n9, err := m.SplitTrigger.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	if m.MergeTrigger != nil {
		data[i] = 0x12
		i++
		i = encodeVarintData(data, i, uint64(m.MergeTrigger.Size()))
		n10, err := m.MergeTrigger.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n10
	}
	if m.ChangeReplicasTrigger != nil {
		data[i] = 0x1a
		i++
		i = encodeVarintData(data, i, uint64(m.ChangeReplicasTrigger.Size()))
		n11, err := m.ChangeReplicasTrigger.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n11
	}
	if m.ModifiedSpanTrigger != nil {
		data[i] = 0x22
		i++
		i = encodeVarintData(data, i, uint64(m.ModifiedSpanTrigger.Size()))
		n12, err := m.ModifiedSpanTrigger.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n12
	}
	return i, nil
}

func (m *TxnMeta) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *TxnMeta) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ID != nil {
		data[i] = 0xa
		i++
		i = encodeVarintData(data, i, uint64(m.ID.Size()))
		n13, err := m.ID.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n13
	}
	data[i] = 0x10
	i++
	i = encodeVarintData(data, i, uint64(m.Isolation))
	if m.Key != nil {
		data[i] = 0x1a
		i++
		i = encodeVarintData(data, i, uint64(len(m.Key)))
		i += copy(data[i:], m.Key)
	}
	data[i] = 0x20
	i++
	i = encodeVarintData(data, i, uint64(m.Epoch))
	data[i] = 0x2a
	i++
	i = encodeVarintData(data, i, uint64(m.Timestamp.Size()))
	n14, err := m.Timestamp.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n14
	data[i] = 0x30
	i++
	i = encodeVarintData(data, i, uint64(m.Priority))
	data[i] = 0x38
	i++
	i = encodeVarintData(data, i, uint64(m.Sequence))
	data[i] = 0x40
	i++
	i = encodeVarintData(data, i, uint64(m.BatchIndex))
	return i, nil
}

func (m *Transaction) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Transaction) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	data[i] = 0xa
	i++
	i = encodeVarintData(data, i, uint64(m.TxnMeta.Size()))
	n15, err := m.TxnMeta.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n15
	data[i] = 0x12
	i++
	i = encodeVarintData(data, i, uint64(len(m.Name)))
	i += copy(data[i:], m.Name)
	data[i] = 0x20
	i++
	i = encodeVarintData(data, i, uint64(m.Status))
	if m.LastHeartbeat != nil {
		data[i] = 0x2a
		i++
		i = encodeVarintData(data, i, uint64(m.LastHeartbeat.Size()))
		n16, err := m.LastHeartbeat.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n16
	}
	data[i] = 0x32
	i++
	i = encodeVarintData(data, i, uint64(m.OrigTimestamp.Size()))
	n17, err := m.OrigTimestamp.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n17
	data[i] = 0x3a
	i++
	i = encodeVarintData(data, i, uint64(m.MaxTimestamp.Size()))
	n18, err := m.MaxTimestamp.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n18
	if len(m.ObservedTimestamps) > 0 {
		keysForObservedTimestamps := make([]int32, 0, len(m.ObservedTimestamps))
		for k := range m.ObservedTimestamps {
			keysForObservedTimestamps = append(keysForObservedTimestamps, int32(k))
		}
		github_com_gogo_protobuf_sortkeys.Int32s(keysForObservedTimestamps)
		for _, k := range keysForObservedTimestamps {
			data[i] = 0x42
			i++
			v := m.ObservedTimestamps[NodeID(k)]
			msgSize := (&v).Size()
			mapSize := 1 + sovData(uint64(k)) + 1 + msgSize + sovData(uint64(msgSize))
			i = encodeVarintData(data, i, uint64(mapSize))
			data[i] = 0x8
			i++
			i = encodeVarintData(data, i, uint64(k))
			data[i] = 0x12
			i++
			i = encodeVarintData(data, i, uint64((&v).Size()))
			n19, err := (&v).MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n19
		}
	}
	data[i] = 0x48
	i++
	if m.Writing {
		data[i] = 1
	} else {
		data[i] = 0
	}
	i++
	if len(m.Intents) > 0 {
		for _, msg := range m.Intents {
			data[i] = 0x5a
			i++
			i = encodeVarintData(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	data[i] = 0x60
	i++
	if m.WriteTooOld {
		data[i] = 1
	} else {
		data[i] = 0
	}
	i++
	data[i] = 0x68
	i++
	if m.RetryOnPush {
		data[i] = 1
	} else {
		data[i] = 0
	}
	i++
	return i, nil
}

func (m *Intent) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Intent) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	data[i] = 0xa
	i++
	i = encodeVarintData(data, i, uint64(m.Span.Size()))
	n20, err := m.Span.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n20
	data[i] = 0x12
	i++
	i = encodeVarintData(data, i, uint64(m.Txn.Size()))
	n21, err := m.Txn.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n21
	data[i] = 0x18
	i++
	i = encodeVarintData(data, i, uint64(m.Status))
	return i, nil
}

func (m *Lease) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Lease) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	data[i] = 0xa
	i++
	i = encodeVarintData(data, i, uint64(m.Start.Size()))
	n22, err := m.Start.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n22
	data[i] = 0x12
	i++
	i = encodeVarintData(data, i, uint64(m.Expiration.Size()))
	n23, err := m.Expiration.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n23
	data[i] = 0x1a
	i++
	i = encodeVarintData(data, i, uint64(m.Replica.Size()))
	n24, err := m.Replica.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n24
	data[i] = 0x22
	i++
	i = encodeVarintData(data, i, uint64(m.StartStasis.Size()))
	n25, err := m.StartStasis.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n25
	return i, nil
}

func (m *AbortCacheEntry) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *AbortCacheEntry) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Key != nil {
		data[i] = 0xa
		i++
		i = encodeVarintData(data, i, uint64(len(m.Key)))
		i += copy(data[i:], m.Key)
	}
	data[i] = 0x12
	i++
	i = encodeVarintData(data, i, uint64(m.Timestamp.Size()))
	n26, err := m.Timestamp.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n26
	data[i] = 0x18
	i++
	i = encodeVarintData(data, i, uint64(m.Priority))
	return i, nil
}

func encodeFixed64Data(data []byte, offset int, v uint64) int {
	data[offset] = uint8(v)
	data[offset+1] = uint8(v >> 8)
	data[offset+2] = uint8(v >> 16)
	data[offset+3] = uint8(v >> 24)
	data[offset+4] = uint8(v >> 32)
	data[offset+5] = uint8(v >> 40)
	data[offset+6] = uint8(v >> 48)
	data[offset+7] = uint8(v >> 56)
	return offset + 8
}
func encodeFixed32Data(data []byte, offset int, v uint32) int {
	data[offset] = uint8(v)
	data[offset+1] = uint8(v >> 8)
	data[offset+2] = uint8(v >> 16)
	data[offset+3] = uint8(v >> 24)
	return offset + 4
}
func encodeVarintData(data []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		data[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	data[offset] = uint8(v)
	return offset + 1
}
func NewPopulatedSpan(r randyData, easy bool) *Span {
	this := &Span{}
	if r.Intn(10) != 0 {
		v1 := r.Intn(100)
		this.Key = make(Key, v1)
		for i := 0; i < v1; i++ {
			this.Key[i] = byte(r.Intn(256))
		}
	}
	if r.Intn(10) != 0 {
		v2 := r.Intn(100)
		this.EndKey = make(Key, v2)
		for i := 0; i < v2; i++ {
			this.EndKey[i] = byte(r.Intn(256))
		}
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedTimestamp(r randyData, easy bool) *Timestamp {
	this := &Timestamp{}
	this.WallTime = int64(r.Int63())
	if r.Intn(2) == 0 {
		this.WallTime *= -1
	}
	this.Logical = int32(r.Int31())
	if r.Intn(2) == 0 {
		this.Logical *= -1
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedTxnMeta(r randyData, easy bool) *TxnMeta {
	this := &TxnMeta{}
	if r.Intn(10) != 0 {
		this.ID = github_com_cockroachdb_cockroach_util_uuid.NewPopulatedUUID(r)
	}
	this.Isolation = IsolationType([]int32{0, 1}[r.Intn(2)])
	if r.Intn(10) != 0 {
		v3 := r.Intn(100)
		this.Key = make(Key, v3)
		for i := 0; i < v3; i++ {
			this.Key[i] = byte(r.Intn(256))
		}
	}
	this.Epoch = uint32(r.Uint32())
	v4 := NewPopulatedTimestamp(r, easy)
	this.Timestamp = *v4
	this.Priority = int32(r.Int31())
	if r.Intn(2) == 0 {
		this.Priority *= -1
	}
	this.Sequence = int32(r.Int31())
	if r.Intn(2) == 0 {
		this.Sequence *= -1
	}
	this.BatchIndex = int32(r.Int31())
	if r.Intn(2) == 0 {
		this.BatchIndex *= -1
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedTransaction(r randyData, easy bool) *Transaction {
	this := &Transaction{}
	v5 := NewPopulatedTxnMeta(r, easy)
	this.TxnMeta = *v5
	this.Name = randStringData(r)
	this.Status = TransactionStatus([]int32{0, 1, 2}[r.Intn(3)])
	if r.Intn(10) != 0 {
		this.LastHeartbeat = NewPopulatedTimestamp(r, easy)
	}
	v6 := NewPopulatedTimestamp(r, easy)
	this.OrigTimestamp = *v6
	v7 := NewPopulatedTimestamp(r, easy)
	this.MaxTimestamp = *v7
	if r.Intn(10) != 0 {
		v8 := r.Intn(10)
		this.ObservedTimestamps = make(map[NodeID]Timestamp)
		for i := 0; i < v8; i++ {
			this.ObservedTimestamps[NodeID(int32(r.Int31()))] = *NewPopulatedTimestamp(r, easy)
		}
	}
	this.Writing = bool(bool(r.Intn(2) == 0))
	if r.Intn(10) != 0 {
		v9 := r.Intn(5)
		this.Intents = make([]Span, v9)
		for i := 0; i < v9; i++ {
			v10 := NewPopulatedSpan(r, easy)
			this.Intents[i] = *v10
		}
	}
	this.WriteTooOld = bool(bool(r.Intn(2) == 0))
	this.RetryOnPush = bool(bool(r.Intn(2) == 0))
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedLease(r randyData, easy bool) *Lease {
	this := &Lease{}
	v11 := NewPopulatedTimestamp(r, easy)
	this.Start = *v11
	v12 := NewPopulatedTimestamp(r, easy)
	this.Expiration = *v12
	v13 := NewPopulatedReplicaDescriptor(r, easy)
	this.Replica = *v13
	v14 := NewPopulatedTimestamp(r, easy)
	this.StartStasis = *v14
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedAbortCacheEntry(r randyData, easy bool) *AbortCacheEntry {
	this := &AbortCacheEntry{}
	if r.Intn(10) != 0 {
		v15 := r.Intn(100)
		this.Key = make(Key, v15)
		for i := 0; i < v15; i++ {
			this.Key[i] = byte(r.Intn(256))
		}
	}
	v16 := NewPopulatedTimestamp(r, easy)
	this.Timestamp = *v16
	this.Priority = int32(r.Int31())
	if r.Intn(2) == 0 {
		this.Priority *= -1
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

type randyData interface {
	Float32() float32
	Float64() float64
	Int63() int64
	Int31() int32
	Uint32() uint32
	Intn(n int) int
}

func randUTF8RuneData(r randyData) rune {
	ru := r.Intn(62)
	if ru < 10 {
		return rune(ru + 48)
	} else if ru < 36 {
		return rune(ru + 55)
	}
	return rune(ru + 61)
}
func randStringData(r randyData) string {
	v17 := r.Intn(100)
	tmps := make([]rune, v17)
	for i := 0; i < v17; i++ {
		tmps[i] = randUTF8RuneData(r)
	}
	return string(tmps)
}
func randUnrecognizedData(r randyData, maxFieldNumber int) (data []byte) {
	l := r.Intn(5)
	for i := 0; i < l; i++ {
		wire := r.Intn(4)
		if wire == 3 {
			wire = 5
		}
		fieldNumber := maxFieldNumber + r.Intn(100)
		data = randFieldData(data, r, fieldNumber, wire)
	}
	return data
}
func randFieldData(data []byte, r randyData, fieldNumber int, wire int) []byte {
	key := uint32(fieldNumber)<<3 | uint32(wire)
	switch wire {
	case 0:
		data = encodeVarintPopulateData(data, uint64(key))
		v18 := r.Int63()
		if r.Intn(2) == 0 {
			v18 *= -1
		}
		data = encodeVarintPopulateData(data, uint64(v18))
	case 1:
		data = encodeVarintPopulateData(data, uint64(key))
		data = append(data, byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)))
	case 2:
		data = encodeVarintPopulateData(data, uint64(key))
		ll := r.Intn(100)
		data = encodeVarintPopulateData(data, uint64(ll))
		for j := 0; j < ll; j++ {
			data = append(data, byte(r.Intn(256)))
		}
	default:
		data = encodeVarintPopulateData(data, uint64(key))
		data = append(data, byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)))
	}
	return data
}
func encodeVarintPopulateData(data []byte, v uint64) []byte {
	for v >= 1<<7 {
		data = append(data, uint8(uint64(v)&0x7f|0x80))
		v >>= 7
	}
	data = append(data, uint8(v))
	return data
}
func (m *Span) Size() (n int) {
	var l int
	_ = l
	if m.Key != nil {
		l = len(m.Key)
		n += 1 + l + sovData(uint64(l))
	}
	if m.EndKey != nil {
		l = len(m.EndKey)
		n += 1 + l + sovData(uint64(l))
	}
	return n
}

func (m *Timestamp) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovData(uint64(m.WallTime))
	n += 1 + sovData(uint64(m.Logical))
	return n
}

func (m *Value) Size() (n int) {
	var l int
	_ = l
	if m.RawBytes != nil {
		l = len(m.RawBytes)
		n += 1 + l + sovData(uint64(l))
	}
	l = m.Timestamp.Size()
	n += 1 + l + sovData(uint64(l))
	return n
}

func (m *KeyValue) Size() (n int) {
	var l int
	_ = l
	if m.Key != nil {
		l = len(m.Key)
		n += 1 + l + sovData(uint64(l))
	}
	l = m.Value.Size()
	n += 1 + l + sovData(uint64(l))
	return n
}

func (m *StoreIdent) Size() (n int) {
	var l int
	_ = l
	l = m.ClusterID.Size()
	n += 1 + l + sovData(uint64(l))
	n += 1 + sovData(uint64(m.NodeID))
	n += 1 + sovData(uint64(m.StoreID))
	return n
}

func (m *SplitTrigger) Size() (n int) {
	var l int
	_ = l
	l = m.UpdatedDesc.Size()
	n += 1 + l + sovData(uint64(l))
	l = m.NewDesc.Size()
	n += 1 + l + sovData(uint64(l))
	n += 1 + sovData(uint64(m.InitialLeaderStoreID))
	return n
}

func (m *MergeTrigger) Size() (n int) {
	var l int
	_ = l
	l = m.UpdatedDesc.Size()
	n += 1 + l + sovData(uint64(l))
	l = m.SubsumedDesc.Size()
	n += 1 + l + sovData(uint64(l))
	return n
}

func (m *ChangeReplicasTrigger) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovData(uint64(m.ChangeType))
	l = m.Replica.Size()
	n += 1 + l + sovData(uint64(l))
	if len(m.UpdatedReplicas) > 0 {
		for _, e := range m.UpdatedReplicas {
			l = e.Size()
			n += 1 + l + sovData(uint64(l))
		}
	}
	n += 1 + sovData(uint64(m.NextReplicaID))
	return n
}

func (m *ModifiedSpanTrigger) Size() (n int) {
	var l int
	_ = l
	n += 2
	return n
}

func (m *InternalCommitTrigger) Size() (n int) {
	var l int
	_ = l
	if m.SplitTrigger != nil {
		l = m.SplitTrigger.Size()
		n += 1 + l + sovData(uint64(l))
	}
	if m.MergeTrigger != nil {
		l = m.MergeTrigger.Size()
		n += 1 + l + sovData(uint64(l))
	}
	if m.ChangeReplicasTrigger != nil {
		l = m.ChangeReplicasTrigger.Size()
		n += 1 + l + sovData(uint64(l))
	}
	if m.ModifiedSpanTrigger != nil {
		l = m.ModifiedSpanTrigger.Size()
		n += 1 + l + sovData(uint64(l))
	}
	return n
}

func (m *TxnMeta) Size() (n int) {
	var l int
	_ = l
	if m.ID != nil {
		l = m.ID.Size()
		n += 1 + l + sovData(uint64(l))
	}
	n += 1 + sovData(uint64(m.Isolation))
	if m.Key != nil {
		l = len(m.Key)
		n += 1 + l + sovData(uint64(l))
	}
	n += 1 + sovData(uint64(m.Epoch))
	l = m.Timestamp.Size()
	n += 1 + l + sovData(uint64(l))
	n += 1 + sovData(uint64(m.Priority))
	n += 1 + sovData(uint64(m.Sequence))
	n += 1 + sovData(uint64(m.BatchIndex))
	return n
}

func (m *Transaction) Size() (n int) {
	var l int
	_ = l
	l = m.TxnMeta.Size()
	n += 1 + l + sovData(uint64(l))
	l = len(m.Name)
	n += 1 + l + sovData(uint64(l))
	n += 1 + sovData(uint64(m.Status))
	if m.LastHeartbeat != nil {
		l = m.LastHeartbeat.Size()
		n += 1 + l + sovData(uint64(l))
	}
	l = m.OrigTimestamp.Size()
	n += 1 + l + sovData(uint64(l))
	l = m.MaxTimestamp.Size()
	n += 1 + l + sovData(uint64(l))
	if len(m.ObservedTimestamps) > 0 {
		for k, v := range m.ObservedTimestamps {
			_ = k
			_ = v
			l = v.Size()
			mapEntrySize := 1 + sovData(uint64(k)) + 1 + l + sovData(uint64(l))
			n += mapEntrySize + 1 + sovData(uint64(mapEntrySize))
		}
	}
	n += 2
	if len(m.Intents) > 0 {
		for _, e := range m.Intents {
			l = e.Size()
			n += 1 + l + sovData(uint64(l))
		}
	}
	n += 2
	n += 2
	return n
}

func (m *Intent) Size() (n int) {
	var l int
	_ = l
	l = m.Span.Size()
	n += 1 + l + sovData(uint64(l))
	l = m.Txn.Size()
	n += 1 + l + sovData(uint64(l))
	n += 1 + sovData(uint64(m.Status))
	return n
}

func (m *Lease) Size() (n int) {
	var l int
	_ = l
	l = m.Start.Size()
	n += 1 + l + sovData(uint64(l))
	l = m.Expiration.Size()
	n += 1 + l + sovData(uint64(l))
	l = m.Replica.Size()
	n += 1 + l + sovData(uint64(l))
	l = m.StartStasis.Size()
	n += 1 + l + sovData(uint64(l))
	return n
}

func (m *AbortCacheEntry) Size() (n int) {
	var l int
	_ = l
	if m.Key != nil {
		l = len(m.Key)
		n += 1 + l + sovData(uint64(l))
	}
	l = m.Timestamp.Size()
	n += 1 + l + sovData(uint64(l))
	n += 1 + sovData(uint64(m.Priority))
	return n
}

func sovData(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozData(x uint64) (n int) {
	return sovData(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Span) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Span: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Span: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = append(m.Key[:0], data[iNdEx:postIndex]...)
			if m.Key == nil {
				m.Key = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EndKey = append(m.EndKey[:0], data[iNdEx:postIndex]...)
			if m.EndKey == nil {
				m.EndKey = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipData(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Timestamp) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Timestamp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Timestamp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WallTime", wireType)
			}
			m.WallTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.WallTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Logical", wireType)
			}
			m.Logical = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Logical |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipData(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Value) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Value: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Value: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RawBytes", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RawBytes = append(m.RawBytes[:0], data[iNdEx:postIndex]...)
			if m.RawBytes == nil {
				m.RawBytes = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Timestamp.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipData(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *KeyValue) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: KeyValue: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: KeyValue: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = append(m.Key[:0], data[iNdEx:postIndex]...)
			if m.Key == nil {
				m.Key = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Value.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipData(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StoreIdent) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StoreIdent: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StoreIdent: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterID", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ClusterID.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeID", wireType)
			}
			m.NodeID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.NodeID |= (NodeID(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StoreID", wireType)
			}
			m.StoreID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.StoreID |= (StoreID(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipData(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SplitTrigger) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SplitTrigger: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SplitTrigger: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdatedDesc", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.UpdatedDesc.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewDesc", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.NewDesc.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InitialLeaderStoreID", wireType)
			}
			m.InitialLeaderStoreID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.InitialLeaderStoreID |= (StoreID(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipData(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MergeTrigger) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MergeTrigger: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MergeTrigger: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdatedDesc", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.UpdatedDesc.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubsumedDesc", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.SubsumedDesc.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipData(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ChangeReplicasTrigger) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ChangeReplicasTrigger: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ChangeReplicasTrigger: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChangeType", wireType)
			}
			m.ChangeType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.ChangeType |= (ReplicaChangeType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Replica", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Replica.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdatedReplicas", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UpdatedReplicas = append(m.UpdatedReplicas, ReplicaDescriptor{})
			if err := m.UpdatedReplicas[len(m.UpdatedReplicas)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextReplicaID", wireType)
			}
			m.NextReplicaID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.NextReplicaID |= (ReplicaID(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipData(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ModifiedSpanTrigger) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ModifiedSpanTrigger: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ModifiedSpanTrigger: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SystemConfigSpan", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SystemConfigSpan = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipData(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InternalCommitTrigger) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InternalCommitTrigger: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InternalCommitTrigger: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SplitTrigger", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SplitTrigger == nil {
				m.SplitTrigger = &SplitTrigger{}
			}
			if err := m.SplitTrigger.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MergeTrigger", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MergeTrigger == nil {
				m.MergeTrigger = &MergeTrigger{}
			}
			if err := m.MergeTrigger.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChangeReplicasTrigger", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ChangeReplicasTrigger == nil {
				m.ChangeReplicasTrigger = &ChangeReplicasTrigger{}
			}
			if err := m.ChangeReplicasTrigger.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ModifiedSpanTrigger", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ModifiedSpanTrigger == nil {
				m.ModifiedSpanTrigger = &ModifiedSpanTrigger{}
			}
			if err := m.ModifiedSpanTrigger.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipData(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TxnMeta) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TxnMeta: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TxnMeta: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var v github_com_cockroachdb_cockroach_util_uuid.UUID
			m.ID = &v
			if err := m.ID.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Isolation", wireType)
			}
			m.Isolation = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Isolation |= (IsolationType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = append(m.Key[:0], data[iNdEx:postIndex]...)
			if m.Key == nil {
				m.Key = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Epoch", wireType)
			}
			m.Epoch = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Epoch |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Timestamp.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Priority", wireType)
			}
			m.Priority = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Priority |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sequence", wireType)
			}
			m.Sequence = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Sequence |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BatchIndex", wireType)
			}
			m.BatchIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.BatchIndex |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipData(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Transaction) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Transaction: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Transaction: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxnMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TxnMeta.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Status |= (TransactionStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastHeartbeat", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LastHeartbeat == nil {
				m.LastHeartbeat = &Timestamp{}
			}
			if err := m.LastHeartbeat.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrigTimestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.OrigTimestamp.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxTimestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MaxTimestamp.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObservedTimestamps", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var mapkey int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				mapkey |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var valuekey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				valuekey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var mapmsglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				mapmsglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if mapmsglen < 0 {
				return ErrInvalidLengthData
			}
			postmsgIndex := iNdEx + mapmsglen
			if mapmsglen < 0 {
				return ErrInvalidLengthData
			}
			if postmsgIndex > l {
				return io.ErrUnexpectedEOF
			}
			mapvalue := &Timestamp{}
			if err := mapvalue.Unmarshal(data[iNdEx:postmsgIndex]); err != nil {
				return err
			}
			iNdEx = postmsgIndex
			if m.ObservedTimestamps == nil {
				m.ObservedTimestamps = make(map[NodeID]Timestamp)
			}
			m.ObservedTimestamps[NodeID(mapkey)] = *mapvalue
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Writing", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Writing = bool(v != 0)
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Intents", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Intents = append(m.Intents, Span{})
			if err := m.Intents[len(m.Intents)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WriteTooOld", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.WriteTooOld = bool(v != 0)
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RetryOnPush", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RetryOnPush = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipData(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Intent) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Intent: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Intent: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Span", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Span.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Txn", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Txn.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Status |= (TransactionStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipData(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Lease) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Lease: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Lease: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Start", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Start.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Expiration", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Expiration.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Replica", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Replica.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartStasis", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.StartStasis.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipData(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AbortCacheEntry) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AbortCacheEntry: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AbortCacheEntry: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = append(m.Key[:0], data[iNdEx:postIndex]...)
			if m.Key == nil {
				m.Key = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Timestamp.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Priority", wireType)
			}
			m.Priority = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Priority |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipData(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipData(data []byte) (n int, err error) {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowData
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowData
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if data[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowData
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthData
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowData
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipData(data[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthData = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowData   = fmt.Errorf("proto: integer overflow")
)

var fileDescriptorData = []byte{
	// 1611 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0xb4, 0x57, 0xcd, 0x6f, 0x1b, 0xd7,
	0x11, 0x17, 0x3f, 0x97, 0x1c, 0x92, 0x12, 0xf5, 0x64, 0x41, 0xac, 0x6a, 0x88, 0x32, 0xd1, 0x0f,
	0xc3, 0x07, 0x09, 0x15, 0xea, 0xd6, 0xd5, 0xa1, 0x28, 0xbf, 0x6a, 0x6f, 0xcd, 0x0f, 0x61, 0x49,
	0xb9, 0xae, 0x0b, 0x74, 0xbb, 0xdc, 0x7d, 0xa6, 0x16, 0x26, 0x77, 0xd9, 0xdd, 0xa5, 0x25, 0xdd,
	0x8a, 0x20, 0x07, 0x1f, 0x03, 0x04, 0x08, 0x72, 0xc8, 0xc1, 0x40, 0x6e, 0x01, 0x72, 0x4e, 0xfe,
	0x04, 0x5f, 0x02, 0xf8, 0x18, 0x24, 0x80, 0x92, 0x38, 0x87, 0xfc, 0x0f, 0x3e, 0x65, 0xde, 0xdb,
	0xb7, 0xcb, 0x55, 0x48, 0x0b, 0xb2, 0x82, 0x1c, 0x28, 0x3d, 0xce, 0xcc, 0xef, 0xf7, 0x66, 0xe6,
	0xcd, 0xbc, 0x37, 0x84, 0xeb, 0xba, 0xad, 0x3f, 0x71, 0x6c, 0x4d, 0x3f, 0xda, 0xe5, 0x7f, 0x27,
	0x83, 0x5d, 0x43, 0xf3, 0xb4, 0x9d, 0x89, 0x63, 0x7b, 0x36, 0x59, 0x0d, 0xb5, 0x3b, 0x42, 0xbb,
	0xb9, 0x3d, 0x0f, 0x18, 0x53, 0x4f, 0x9b, 0x81, 0x36, 0xaf, 0x0d, 0xed, 0xa1, 0xcd, 0x97, 0xbb,
	0x6c, 0xe5, 0x4b, 0x2b, 0x32, 0x24, 0x7b, 0x13, 0xcd, 0x22, 0xbf, 0x82, 0xc4, 0x13, 0x7a, 0x5a,
	0x4a, 0x6c, 0xc7, 0x6e, 0xe6, 0x6b, 0xd2, 0xeb, 0xb3, 0x72, 0xe2, 0x3e, 0x3d, 0x55, 0x98, 0x8c,
	0x6c, 0x83, 0x44, 0x2d, 0x43, 0x65, 0xea, 0xe4, 0x79, 0x75, 0x1a, 0xe5, 0xf8, 0x7f, 0x3f, 0xf9,
	0xf9, 0xf3, 0x72, 0xac, 0xf2, 0x10, 0xb2, 0x7d, 0x73, 0x4c, 0x5d, 0x4f, 0x1b, 0x4f, 0xc8, 0x0d,
	0xc8, 0x1e, 0x6b, 0xa3, 0x91, 0xea, 0xa1, 0xa4, 0x14, 0x43, 0x58, 0xa2, 0x96, 0x7c, 0x71, 0x56,
	0x5e, 0x52, 0x32, 0x4c, 0xcc, 0xec, 0xc8, 0x16, 0x48, 0x23, 0x7b, 0x68, 0xea, 0xda, 0xa8, 0x14,
	0x47, 0x83, 0x94, 0x30, 0x08, 0x84, 0xfb, 0x99, 0x0f, 0x9f, 0x97, 0x97, 0x38, 0xf3, 0x63, 0x48,
	0x3d, 0xd0, 0x46, 0x53, 0x4a, 0x7e, 0x0d, 0x59, 0x47, 0x3b, 0x56, 0x07, 0xa7, 0x1e, 0x75, 0x39,
	0x6b, 0x5e, 0xc9, 0xa0, 0xa0, 0xc6, 0xbe, 0x93, 0xbf, 0x41, 0xd6, 0x0b, 0xf6, 0xe7, 0x8c, 0xb9,
	0xbd, 0xeb, 0x3b, 0x73, 0x99, 0xda, 0x09, 0x7d, 0x14, 0xfb, 0xcd, 0x40, 0x95, 0x7f, 0x43, 0x06,
	0xc3, 0xf1, 0xb7, 0x12, 0x09, 0x89, 0x2d, 0x48, 0xc8, 0x1f, 0x21, 0xf5, 0x94, 0xd9, 0x88, 0x4d,
	0x4a, 0x0b, 0x36, 0xe1, 0x1c, 0x62, 0x03, 0xdf, 0xb8, 0xf2, 0x75, 0x0c, 0xa0, 0xe7, 0xd9, 0x0e,
	0x95, 0x0d, 0x6a, 0x79, 0x44, 0x07, 0xd0, 0x47, 0x53, 0xd7, 0xa3, 0x8e, 0x6a, 0x1a, 0x62, 0x9b,
	0x06, 0xb3, 0xff, 0xea, 0xac, 0xbc, 0x3b, 0x34, 0xbd, 0xa3, 0xe9, 0x00, 0x79, 0xc7, 0xbb, 0x21,
	0xb7, 0x31, 0x98, 0xad, 0x77, 0xa7, 0x9e, 0x39, 0xda, 0x9d, 0x4e, 0x4d, 0x63, 0xe7, 0xf0, 0x50,
	0x6e, 0xbc, 0x3a, 0x2b, 0x67, 0xeb, 0x3e, 0x99, 0xdc, 0x50, 0xb2, 0x82, 0x57, 0x36, 0xc8, 0x1f,
	0x40, 0xb2, 0x6c, 0x83, 0xb2, 0x1d, 0xfc, 0x14, 0x97, 0xd8, 0x0e, 0x68, 0x9e, 0xee, 0xa0, 0x58,
	0x6e, 0xbc, 0x0e, 0x57, 0x4a, 0x9a, 0x19, 0x22, 0xe4, 0x36, 0x64, 0x5c, 0xe6, 0x25, 0xc3, 0x24,
	0x38, 0x66, 0x53, 0x60, 0x24, 0xdf, 0x7b, 0x06, 0x0a, 0x96, 0x8a, 0xe4, 0xfa, 0x11, 0x55, 0xfe,
	0x1f, 0x87, 0x7c, 0x6f, 0x32, 0x32, 0xbd, 0xbe, 0x63, 0x0e, 0x87, 0xd4, 0x21, 0xf7, 0x21, 0x3f,
	0x9d, 0x60, 0xf9, 0x51, 0x43, 0x35, 0xa8, 0xab, 0xf3, 0x08, 0x73, 0x7b, 0x95, 0x05, 0xb9, 0x52,
	0x34, 0x6b, 0x48, 0x1b, 0x68, 0xe3, 0x98, 0x13, 0x64, 0x13, 0x59, 0xcb, 0x09, 0x34, 0x53, 0x90,
	0x3a, 0x64, 0x2c, 0x7a, 0xec, 0x13, 0xc5, 0xdf, 0x92, 0x48, 0x42, 0x24, 0x27, 0xf9, 0x0f, 0x6c,
	0x98, 0x96, 0xe9, 0x99, 0xda, 0x48, 0x1d, 0x51, 0xcd, 0xc0, 0xc4, 0xff, 0x24, 0xd0, 0xdf, 0x8b,
	0x40, 0xaf, 0xc9, 0xbe, 0x59, 0x8b, 0x5b, 0x2d, 0x88, 0xfa, 0x9a, 0x39, 0x6f, 0x60, 0x54, 0x3e,
	0x89, 0x41, 0xbe, 0x4d, 0x9d, 0x21, 0xfd, 0x45, 0x52, 0xd0, 0x86, 0x82, 0x3b, 0x1d, 0xb8, 0xd3,
	0x71, 0xc0, 0xf6, 0xb6, 0x79, 0xc8, 0x07, 0x70, 0xa6, 0xa9, 0x7c, 0x11, 0x87, 0xf5, 0xfa, 0x11,
	0x33, 0x54, 0x28, 0x1e, 0x9b, 0xae, 0xb9, 0x33, 0xaf, 0x73, 0x3a, 0x57, 0xa8, 0xde, 0xe9, 0xc4,
	0xef, 0xdd, 0xe5, 0xbd, 0xdf, 0x2c, 0xda, 0xc6, 0x07, 0xfa, 0x2c, 0x7d, 0xb4, 0x15, 0x1b, 0x81,
	0x1e, 0x4a, 0x48, 0x03, 0x24, 0xc7, 0x37, 0x13, 0xfe, 0x5e, 0x40, 0x34, 0x7f, 0x72, 0x02, 0x4a,
	0x0e, 0xa1, 0x18, 0x24, 0x52, 0x88, 0x5c, 0x3c, 0xb2, 0xc4, 0x5b, 0xd2, 0xad, 0x08, 0x8e, 0x20,
	0x60, 0xf2, 0x0f, 0x58, 0xb1, 0xe8, 0x89, 0x17, 0x70, 0xb2, 0x42, 0x48, 0xf2, 0x42, 0xa8, 0x88,
	0x42, 0x28, 0x74, 0x50, 0x2d, 0xcc, 0x79, 0x05, 0x64, 0xc3, 0x2f, 0x4a, 0xc1, 0x8a, 0xe8, 0x0c,
	0xbc, 0x47, 0xd7, 0xda, 0xb6, 0x61, 0x3e, 0x36, 0xa9, 0xc1, 0xee, 0xd3, 0x20, 0x99, 0x7b, 0x40,
	0xdc, 0x53, 0x6c, 0xc6, 0xb1, 0xaa, 0xdb, 0xd6, 0x63, 0x73, 0xa8, 0xba, 0xa8, 0xe4, 0x39, 0xcd,
	0x08, 0xaf, 0x8a, 0xbe, 0xbe, 0xce, 0xd5, 0x0c, 0x5a, 0xf9, 0x01, 0x8f, 0x46, 0xb6, 0xb0, 0x81,
	0x2d, 0x6d, 0x54, 0xb7, 0xc7, 0xe3, 0x59, 0x4f, 0x35, 0xb0, 0x06, 0x58, 0x8f, 0xa9, 0x9e, 0x2f,
	0x10, 0x15, 0x55, 0x5e, 0x90, 0x84, 0x68, 0x2f, 0xe2, 0xd1, 0x47, 0x3b, 0x13, 0x59, 0xc6, 0xac,
	0x4c, 0x43, 0x96, 0xf8, 0x1b, 0x59, 0xa2, 0xe5, 0xac, 0xe4, 0xc7, 0xd1, 0xe2, 0xfe, 0x2f, 0x6c,
	0x88, 0x32, 0x09, 0x8e, 0x24, 0xe4, 0x4b, 0x70, 0xbe, 0x9b, 0x0b, 0xf8, 0x16, 0x56, 0x9c, 0xb2,
	0xae, 0x2f, 0x2c, 0xc4, 0x47, 0xb0, 0x3e, 0x16, 0x29, 0xe5, 0x69, 0x0b, 0xf9, 0x93, 0x9c, 0xff,
	0x77, 0x8b, 0xfc, 0x9d, 0x3f, 0x02, 0x65, 0x6d, 0x3c, 0x2f, 0xdc, 0x4f, 0x3e, 0x63, 0xef, 0xca,
	0xbb, 0x09, 0x90, 0xfa, 0x27, 0x56, 0x1b, 0x1f, 0x4a, 0x22, 0x43, 0x3c, 0xbc, 0x87, 0xff, 0x72,
	0xb5, 0x3b, 0x38, 0x8e, 0x65, 0x81, 0x24, 0x98, 0xe0, 0xac, 0xe9, 0xda, 0x23, 0xcd, 0x33, 0x6d,
	0x8b, 0x27, 0x77, 0x79, 0x6f, 0x7b, 0x81, 0xb3, 0x72, 0x60, 0x13, 0xe9, 0x9d, 0x19, 0xf0, 0xa2,
	0x17, 0x79, 0x13, 0x52, 0x74, 0x62, 0xeb, 0x47, 0x3c, 0x13, 0x85, 0xe0, 0x99, 0xe1, 0xa2, 0xf3,
	0xaf, 0x60, 0xea, 0x0a, 0xaf, 0x20, 0xbe, 0xf7, 0x99, 0x89, 0x63, 0xda, 0x8e, 0xe9, 0x9d, 0x96,
	0xd2, 0x91, 0x87, 0x39, 0x94, 0x32, 0x0b, 0x97, 0xfe, 0x6f, 0x4a, 0x2d, 0x9d, 0x96, 0xa4, 0xa8,
	0x45, 0x20, 0x25, 0xbf, 0x85, 0xdc, 0x40, 0xf3, 0xf4, 0x23, 0xd5, 0xb4, 0x0c, 0x7a, 0x52, 0xca,
	0x44, 0x8c, 0x80, 0x2b, 0x64, 0x26, 0x17, 0x83, 0xc3, 0xfb, 0x69, 0xc8, 0xf5, 0x1d, 0xcd, 0x72,
	0x35, 0x9d, 0x47, 0x7e, 0x07, 0x92, 0x6c, 0x76, 0x11, 0xd5, 0xbd, 0xb9, 0xc8, 0x7b, 0xff, 0xd0,
	0x6a, 0x19, 0xc6, 0xf8, 0xf2, 0xac, 0x1c, 0x53, 0x38, 0x82, 0x94, 0x20, 0x69, 0x69, 0x63, 0xff,
	0x61, 0xce, 0x8a, 0xfd, 0xb8, 0x84, 0xd4, 0x20, 0x8d, 0xd1, 0x79, 0x53, 0x97, 0xe7, 0x6c, 0xf1,
	0x85, 0x16, 0xf1, 0xa1, 0xc7, 0x6d, 0x05, 0x83, 0x40, 0xe2, 0x2b, 0xb4, 0x3c, 0xd2, 0x5c, 0x4f,
	0x3d, 0xa2, 0x9a, 0xe3, 0x0d, 0xa8, 0xe6, 0x5d, 0x26, 0xbf, 0x4a, 0x81, 0x61, 0xee, 0x05, 0x10,
	0xac, 0xb3, 0x65, 0x4c, 0xe2, 0x50, 0x9d, 0x1d, 0x52, 0xfa, 0xd2, 0x87, 0x54, 0x60, 0xc8, 0xd9,
	0x8c, 0x75, 0x17, 0x1b, 0x59, 0x3b, 0x89, 0x30, 0x49, 0x97, 0x66, 0xca, 0x23, 0x70, 0x46, 0x74,
	0x0c, 0x6b, 0xf6, 0xc0, 0xa5, 0xce, 0x53, 0xec, 0xb4, 0x90, 0xcd, 0xc5, 0x53, 0x63, 0x57, 0xec,
	0x9f, 0x2e, 0xce, 0xd4, 0x4e, 0x57, 0x20, 0x43, 0x3a, 0xb7, 0x69, 0x79, 0xce, 0x69, 0x6d, 0x99,
	0x6d, 0xf4, 0xce, 0x37, 0xe1, 0x80, 0x41, 0xec, 0x39, 0x43, 0x36, 0x02, 0x1e, 0x63, 0x45, 0x99,
	0xd6, 0xb0, 0x94, 0x8d, 0xdc, 0x89, 0x81, 0x90, 0xfc, 0x19, 0x24, 0x13, 0x6f, 0x42, 0xcb, 0x73,
	0x4b, 0x39, 0xee, 0xcc, 0xc6, 0xc2, 0xab, 0x4e, 0xb3, 0x02, 0xa0, 0xb0, 0x26, 0x37, 0xa1, 0xc0,
	0x38, 0xf0, 0x8e, 0xb3, 0x6d, 0xd5, 0x1e, 0x19, 0xa5, 0x7c, 0x84, 0x3e, 0xc7, 0x55, 0x7d, 0xdb,
	0xee, 0x8e, 0x0c, 0x66, 0xe9, 0x50, 0xf4, 0x57, 0xb5, 0x2d, 0x75, 0x32, 0x75, 0x8f, 0x4a, 0x85,
	0xa8, 0x25, 0x57, 0x75, 0xad, 0x03, 0x54, 0x6c, 0xea, 0xb0, 0xf1, 0x86, 0x58, 0x49, 0x71, 0x36,
	0x2c, 0xa6, 0xfc, 0x16, 0xdd, 0x3b, 0x3f, 0x23, 0x5e, 0x5c, 0x22, 0xbe, 0xe9, 0x7e, 0xfc, 0x4e,
	0x2c, 0x32, 0xf4, 0x7e, 0x16, 0x83, 0xb4, 0xcc, 0xc3, 0xc1, 0x99, 0x2c, 0x19, 0xbe, 0x1b, 0x17,
	0xe4, 0x20, 0xd2, 0x0d, 0xcc, 0x1c, 0x7d, 0x48, 0x78, 0x27, 0x96, 0xf0, 0xe0, 0xa2, 0x36, 0xf2,
	0x83, 0x65, 0xc6, 0x91, 0x3e, 0x49, 0x5c, 0xb5, 0x4f, 0x2a, 0x1f, 0xc5, 0x21, 0x85, 0xa3, 0x91,
	0x4b, 0xb1, 0x93, 0x53, 0x28, 0x73, 0x3c, 0xe1, 0xf9, 0x65, 0x2a, 0xd3, 0x07, 0xa0, 0x1f, 0x40,
	0x4f, 0x26, 0xa6, 0x33, 0xbb, 0x44, 0x2f, 0x07, 0x8f, 0xa0, 0xa2, 0xc3, 0x47, 0xe2, 0xea, 0xc3,
	0x47, 0x13, 0xf2, 0xdc, 0x25, 0x9c, 0x16, 0x35, 0xd7, 0x74, 0xc5, 0xeb, 0x73, 0x19, 0x5f, 0x72,
	0x1c, 0xd7, 0xe3, 0xb0, 0xc8, 0xc1, 0x7e, 0x10, 0x83, 0x95, 0xea, 0xc0, 0x76, 0xbc, 0x3a, 0xc2,
	0xa8, 0x5f, 0x40, 0x17, 0xfc, 0xda, 0xf8, 0xd9, 0x3f, 0x6b, 0xce, 0x5d, 0xe8, 0x89, 0x45, 0x17,
	0xba, 0x7f, 0x0f, 0xdf, 0xfa, 0x34, 0x06, 0x59, 0xfe, 0xc3, 0x85, 0x8f, 0x6e, 0x39, 0x90, 0x0e,
	0x3b, 0xf7, 0x3b, 0xdd, 0x7f, 0x76, 0x8a, 0x4b, 0x24, 0x03, 0xc9, 0xce, 0x61, 0xab, 0x55, 0x94,
	0x88, 0x04, 0x09, 0xb9, 0xd3, 0x2f, 0xc6, 0x48, 0x16, 0x52, 0x7f, 0x6f, 0x75, 0xab, 0xfd, 0x62,
	0x9c, 0x2d, 0x6b, 0xff, 0xea, 0x37, 0x7b, 0xc5, 0x04, 0x59, 0x83, 0x95, 0x46, 0xb3, 0x25, 0xb7,
	0xe5, 0x7e, 0xb3, 0xa1, 0xfa, 0xc2, 0x0c, 0x43, 0xf7, 0xe5, 0x76, 0xb3, 0x98, 0x64, 0xa4, 0x8d,
	0x66, 0x5d, 0x6e, 0x57, 0x5b, 0xc5, 0x14, 0x59, 0x87, 0xd5, 0x99, 0x6d, 0x20, 0xce, 0x92, 0x3c,
	0x64, 0x1a, 0x87, 0x4a, 0xb5, 0x2f, 0x77, 0x3b, 0xc5, 0x34, 0xe3, 0xee, 0x1f, 0x1e, 0xb4, 0x9a,
	0x45, 0x20, 0xcb, 0x00, 0x8c, 0xa6, 0xd7, 0x54, 0x64, 0xa4, 0x35, 0x6e, 0xfd, 0x15, 0x56, 0xe7,
	0x66, 0x50, 0xb2, 0x02, 0xb9, 0x6a, 0xa3, 0xa1, 0x2a, 0xcd, 0x83, 0x96, 0x5c, 0xaf, 0xa2, 0xeb,
	0x04, 0x96, 0x95, 0x66, 0xbb, 0xfb, 0xa0, 0x19, 0xca, 0x62, 0x9b, 0xc9, 0x67, 0x1f, 0x6f, 0x2d,
	0xdd, 0xba, 0x0d, 0x85, 0x73, 0x6f, 0x30, 0xb6, 0x71, 0x9e, 0x91, 0x57, 0x5b, 0xf2, 0xa3, 0x6a,
	0x0d, 0xb7, 0x5c, 0x62, 0xbe, 0xf4, 0x3a, 0xd5, 0x83, 0xde, 0xbd, 0x6e, 0x3f, 0x84, 0xd5, 0x60,
	0x75, 0xae, 0x03, 0x58, 0x60, 0x07, 0xcd, 0x4e, 0x43, 0xee, 0xdc, 0x45, 0x54, 0x01, 0xb2, 0xf5,
	0x6e, 0x1b, 0xe3, 0xc2, 0xc0, 0x30, 0x53, 0xa8, 0xab, 0xd6, 0xba, 0x0a, 0xfb, 0x12, 0xf7, 0x39,
	0x6a, 0x37, 0x5e, 0x7c, 0xb7, 0xb5, 0xf4, 0xe2, 0xd5, 0x56, 0xec, 0x25, 0x7e, 0xbe, 0xc4, 0xcf,
	0xb7, 0xf8, 0x79, 0xef, 0xfb, 0xad, 0xa5, 0x47, 0x92, 0x38, 0xd0, 0x87, 0xb1, 0x1f, 0x03, 0x00,
	0x00, 0xff, 0xff, 0x89, 0x64, 0xd4, 0x30, 0x05, 0x10, 0x00, 0x00,
}
