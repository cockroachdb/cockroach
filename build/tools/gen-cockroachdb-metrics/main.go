// Copyright 2025 The Cockroach Authors.
//
// Use of this software is governed by the CockroachDB Software License
// included in the /LICENSE file.

// gen-cockroachdb-metrics generates the cockroachdb_metrics.go file for roachprod's OpenTelemetry
// integration, enabling proper metric forwarding to Datadog from CockroachDB clusters.
//
// This generator creates a comprehensive mapping of CockroachDB metric names to Datadog-compatible
// metric names by merging metrics from three distinct sources:
//
// 1. docs/generated/metrics/metrics.yaml
//   - The primary source containing all currently documented CockroachDB metrics
//   - These metrics are auto-generated from the metric definitions in the CRDB codebase
//   - Represents the complete set of metrics emitted by the latest version of CockroachDB
//
// 2. cockroachdb_metrics_base.yaml - runtime_conditional_metrics section
//   - Contains metrics that are only emitted when specific runtime conditions are met
//   - These metrics are processed through the same mapping logic as metrics.yaml metrics
//
// 3. cockroachdb_metrics_base.yaml - legacy_metrics section
//   - Contains legacy/stale metrics no longer emitted by the latest CRDB version
//   - Preserved for backward compatibility with older roachprod clusters running older CRDB versions
//   - These mappings are used as-is and take priority over auto-generated mappings
//   - Ensures consistent metric names across different CRDB versions
//
// The generator performs the following steps:
//
//	a) Loads Datadog metric mapping rules from a local file (downloaded via Bazel)
//	b) Reads and parses all three metric sources (metrics.yaml + base YAML with runtime_conditional + legacy)
//	c) Processes metrics.yaml and runtime_conditional_metrics, converting them to Prometheus format and applying
//	   Datadog naming conventions (including histogram variants like _bucket, _count, _sum)
//	d) Merges the processed mappings with legacy_metrics, where legacy_metrics take priority
//	e) Generates cockroachdb_metrics.go containing the final consolidated mapping

package main

import (
	"fmt"
	"io"
	"os"
	"regexp"
	"sort"
	"strings"
	"text/template"

	"gopkg.in/yaml.v2"
)

// MetricInfo represents a metric from the metrics.yaml file
type MetricInfo struct {
	Name         string `yaml:"name"`
	ExportedName string `yaml:"exported_name"`
	LabeledName  string `yaml:"labeled_name,omitempty"`
	Description  string `yaml:"description"`
	YAxisLabel   string `yaml:"y_axis_label"`
	Type         string `yaml:"type"`
	Unit         string `yaml:"unit"`
	Aggregation  string `yaml:"aggregation"`
	Derivative   string `yaml:"derivative"`
	HowToUse     string `yaml:"how_to_use,omitempty"`
	Essential    bool   `yaml:"essential,omitempty"`
}

// Category represents a category of metrics
type Category struct {
	Name    string       `yaml:"name"`
	Metrics []MetricInfo `yaml:"metrics"`
}

// Layer represents a layer containing categories
type Layer struct {
	Name       string     `yaml:"name"`
	Categories []Category `yaml:"categories"`
}

// YAMLOutput represents the structure of metrics.yaml
type YAMLOutput struct {
	Layers []Layer `yaml:"layers"`
}

// BaseMappingsYAML represents the structure of cockroachdb_metrics_base.yaml
// This file contains two types of metrics not in the standard metrics.yaml:
//   - RuntimeConditionalMetrics: Metrics emitted only under specific runtime conditions
//     (e.g., cert auth, license installed). Processed through Datadog mapping rules.
//   - LegacyMetrics: Deprecated metrics from older CRDB versions, preserved for backward
//     compatibility.
type BaseMappingsYAML struct {
	RuntimeConditionalMetrics []MetricInfo      `yaml:"runtime_conditional_metrics"`
	LegacyMetrics             map[string]string `yaml:"legacy_metrics"`
}

var (
	// Skip patterns - metrics that we haven't included for historical reasons
	skipPatterns = []*regexp.Regexp{
		regexp.MustCompile(`^auth_`),
		regexp.MustCompile(`^distsender_rpc_err_errordetailtype_`),
		regexp.MustCompile(`^gossip_callbacks_`),
		regexp.MustCompile(`^jobs_auto_config_env_runner_`),
		regexp.MustCompile(`^jobs_update_table_`),
		regexp.MustCompile(`^logical_replication_`),
		regexp.MustCompile(`^sql_crud_`),
		regexp.MustCompile(`^storage_l\d_`),
		regexp.MustCompile(`^storage_sstable_compression_`),
	}

	// Regex to convert CRDB metric names to Prometheus format
	prometheusNameRegex = regexp.MustCompile(`[^a-zA-Z0-9]`)
)

// Go code template for generating the cockroachdb_metrics.go file
const goTemplate = `// Copyright 2024 The Cockroach Authors.
//
// Use of this software is governed by the CockroachDB Software License
// included in the /LICENSE file.
//
// DO NOT EDIT THIS FILE MANUALLY
//
// This file is auto-generated when running "./dev generate".
// Manual edits will be overwritten.
//
// Generator: build/tools/gen-cockroachdb-metrics
//
// This file is generated by merging metrics from three sources:
//   1. runtime_conditional_metrics from cockroachdb_metrics_base.yaml
//      - Conditionally emitted metrics not documented in metrics.yaml
//      - Processed through Datadog mapping rules
//   2. legacy_metrics from cockroachdb_metrics_base.yaml
//      - Legacy metrics from older CRDB versions for backward compatibility
//      - Used as-is with priority over auto-generated mappings
//   3. docs/generated/metrics/metrics.yaml
//      - All current metrics documented in the latest CRDB version
//      - Processed through Datadog mapping rules

package opentelemetry

// cockroachdbMetrics is a mapping of CockroachDB metric names to cockroachdb
// Datadog integration metric names. This allows CockroachDB metrics to comply
// with the naming requirements for the cockroachdb Datadog integration listed
// in its metadata.csv.
// - https://github.com/DataDog/integrations-core/blob/master/cockroachdb/metadata.csv

var cockroachdbMetrics = map[string]string{
{{- range $key, $value := .Metrics }}
    "{{ $key }}": "{{ $value }}",
{{- end }}
}
`

// loadDatadogMappings loads the Datadog metrics mapping from a local file
func loadDatadogMappings(path string) (map[string]string, error) {
	file, err := os.Open(path)
	if err != nil {
		return nil, fmt.Errorf("opening file: %w", err)
	}
	defer file.Close()

	return parseDatadogMappings(file)
}

// parseDatadogMappings parses the Python file to extract both METRIC_MAP and OMV2_METRIC_MAP dictionaries
func parseDatadogMappings(r io.Reader) (map[string]string, error) {
	content, err := io.ReadAll(r)
	if err != nil {
		return nil, fmt.Errorf("reading content: %w", err)
	}

	lines := strings.Split(string(content), "\n")
	metrics := make(map[string]string)

	// Parse both METRIC_MAP and OMV2_METRIC_MAP
	for _, mapName := range []string{"METRIC_MAP", "OMV2_METRIC_MAP"} {
		mapMetrics, err := parsePythonDict(lines, mapName)
		if err != nil {
			return nil, fmt.Errorf("parsing %s: %w", mapName, err)
		}
		for k, v := range mapMetrics {
			metrics[k] = v
		}
	}

	return metrics, nil
}

// parsePythonDict parses a specific Python dictionary (METRIC_MAP or OMV2_METRIC_MAP)
func parsePythonDict(lines []string, dictName string) (map[string]string, error) {
	metrics := make(map[string]string)
	inDict := false
	braceDepth := 0

	for _, line := range lines {
		trimmed := strings.TrimSpace(line)

		if strings.Contains(trimmed, dictName+" = {") {
			inDict = true
			braceDepth = 1
			continue
		}

		if !inDict {
			continue
		}

		braceDepth += strings.Count(trimmed, "{") - strings.Count(trimmed, "}")
		if braceDepth <= 0 {
			break
		}

		// Parse metric mapping line: 'key': 'value',
		if strings.Contains(trimmed, ":") && strings.Contains(trimmed, "'") {
			parts := strings.SplitN(trimmed, ":", 2)
			if len(parts) == 2 {
				key := strings.Trim(strings.TrimSpace(parts[0]), "'\"")
				value := strings.Trim(strings.TrimSpace(parts[1]), "',\"")
				if key != "" && value != "" {
					metrics[strings.ToLower(key)] = value
				}
			}
		}
	}

	return metrics, nil
}

// loadMetricsYAML reads and parses the metrics.yaml file
func loadMetricsYAML(path string) (*YAMLOutput, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return nil, fmt.Errorf("reading file: %w", err)
	}

	var output YAMLOutput
	if err := yaml.Unmarshal(data, &output); err != nil {
		return nil, fmt.Errorf("parsing YAML: %w", err)
	}

	return &output, nil
}

// loadBaseMappings reads the base mappings from a YAML file
func loadBaseMappings(path string) (*BaseMappingsYAML, error) {
	if path == "" {
		return &BaseMappingsYAML{
			RuntimeConditionalMetrics: []MetricInfo{},
			LegacyMetrics:             make(map[string]string),
		}, nil
	}

	content, err := os.ReadFile(path)
	if err != nil {
		if os.IsNotExist(err) {
			return &BaseMappingsYAML{
				RuntimeConditionalMetrics: []MetricInfo{},
				LegacyMetrics:             make(map[string]string),
			}, nil
		}
		return nil, fmt.Errorf("reading file: %w", err)
	}

	var mappings BaseMappingsYAML
	if err := yaml.Unmarshal(content, &mappings); err != nil {
		return nil, fmt.Errorf("parsing YAML: %w", err)
	}

	return &mappings, nil
}

// collectAllCRDBMetrics collects all CRDB metrics from the YAML output and combines them
// with any runtime conditional metrics that aren't documented in metrics.yaml
func collectAllCRDBMetrics(yamlOutput *YAMLOutput, runtimeConditionalMetrics []MetricInfo) []MetricInfo {
	allMetrics := make([]MetricInfo, 0)

	for _, layer := range yamlOutput.Layers {
		for _, category := range layer.Categories {
			allMetrics = append(allMetrics, category.Metrics...)
		}
	}

	allMetrics = append(allMetrics, runtimeConditionalMetrics...)
	return allMetrics
}

// shouldSkipMetric checks if a metric name matches any skip patterns
func shouldSkipMetric(promName string) bool {
	for _, pattern := range skipPatterns {
		if pattern.MatchString(promName) {
			return true
		}
	}
	return false
}

// mapMetricsToDatadog processes the CRDB metrics and maps them to Datadog names
func mapMetricsToDatadog(metrics []MetricInfo, datadogMappings map[string]string) map[string]string {
	result := make(map[string]string)

	for _, metric := range metrics {
		// Convert to prometheus format (replace non-alphanumeric with underscore)
		promName := prometheusNameRegex.ReplaceAllString(metric.Name, "_")

		if shouldSkipMetric(promName) {
			continue
		}

		// Get Datadog name from mapping, default to normalized CRDB name
		datadogName := metric.Name
		if ddName, exists := datadogMappings[strings.ToLower(promName)]; exists {
			datadogName = ddName
		} else {
			// Normalize metric name for Datadog by replacing hyphens with underscores
			// Datadog metric names should not contain hyphens
			datadogName = strings.ReplaceAll(metric.Name, "-", "_")
		}

		result[promName] = datadogName

		// Add histogram variants if applicable
		if metric.Type == "HISTOGRAM" {
			result[promName+"_bucket"] = datadogName + ".bucket"
			result[promName+"_count"] = datadogName + ".count"
			result[promName+"_sum"] = datadogName + ".sum"
		}
	}

	return result
}

// mergeLegacyMappings combines legacy mappings with new mappings, giving priority to new mappings
func mergeLegacyMappings(legacyMappings, newMappings map[string]string) map[string]string {
	result := make(map[string]string)

	for k, v := range legacyMappings {
		result[k] = v
	}

	for k, v := range newMappings {
		result[k] = v
	}

	return result
}

// writeGoFile generates the cockroachdb_metrics.go file
func writeGoFile(outputPath string, metrics map[string]string) error {
	tmpl, err := template.New("cockroachdb_metrics").Parse(goTemplate)
	if err != nil {
		return fmt.Errorf("parsing template: %w", err)
	}

	// Sort keys for consistent output
	keys := make([]string, 0, len(metrics))
	for k := range metrics {
		keys = append(keys, k)
	}
	sort.Strings(keys)

	sortedMetrics := make(map[string]string)
	for _, k := range keys {
		sortedMetrics[k] = metrics[k]
	}

	file, err := os.Create(outputPath)
	if err != nil {
		return fmt.Errorf("creating file: %w", err)
	}
	defer file.Close()

	data := struct {
		Metrics map[string]string
	}{
		Metrics: sortedMetrics,
	}

	if err := tmpl.Execute(file, data); err != nil {
		return fmt.Errorf("executing template: %w", err)
	}

	return nil
}

func main() {
	if len(os.Args) < 4 {
		fmt.Fprintf(os.Stderr, "Usage: %s <metrics.yaml> <output.go> <datadog-mappings.py> [base.yaml]\n", os.Args[0])
		os.Exit(1)
	}

	metricsYamlPath := os.Args[1]
	outputPath := os.Args[2]
	datadogMappingsPath := os.Args[3]

	// Optional fourth argument: base YAML file with extra and legacy metrics
	basePath := ""
	if len(os.Args) >= 5 {
		basePath = os.Args[4]
	}

	datadogMappings, err := loadDatadogMappings(datadogMappingsPath)
	if err != nil {
		fmt.Fprintln(os.Stderr, "ERROR:", err)
		os.Exit(1)
	}

	yamlOutput, err := loadMetricsYAML(metricsYamlPath)
	if err != nil {
		fmt.Fprintln(os.Stderr, "ERROR:", err)
		os.Exit(1)
	}

	baseMetrics, err := loadBaseMappings(basePath)
	if err != nil {
		fmt.Fprintln(os.Stderr, "ERROR:", err)
		os.Exit(1)
	}

	allMetrics := collectAllCRDBMetrics(yamlOutput, baseMetrics.RuntimeConditionalMetrics)
	newMappings := mapMetricsToDatadog(allMetrics, datadogMappings)
	finalMappings := mergeLegacyMappings(baseMetrics.LegacyMetrics, newMappings)

	if err := writeGoFile(outputPath, finalMappings); err != nil {
		fmt.Fprintln(os.Stderr, "ERROR:", err)
		os.Exit(1)
	}

	// Only print summary if not in exec/tool configuration to avoid duplicate logs.
	// Bazel builds the tool in both target and exec configurations, causing duplicate output.
	if !strings.Contains(outputPath, "-exec-") && !strings.Contains(outputPath, "for tool") {
		fmt.Printf("Generated %d metric mappings:\n", len(finalMappings))
		fmt.Printf("  - %d from metrics.yaml\n", len(allMetrics)-len(baseMetrics.RuntimeConditionalMetrics))
		fmt.Printf("  - %d runtime conditional metrics\n", len(baseMetrics.RuntimeConditionalMetrics))
		fmt.Printf("  - %d legacy mappings\n", len(baseMetrics.LegacyMetrics))
		fmt.Printf("Output written to: %s\n", outputPath)
	}
}
