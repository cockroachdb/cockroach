// Code generated by protoc-gen-gogo.
// source: cockroach/proto/errors.proto
// DO NOT EDIT!

package proto

import proto1 "github.com/gogo/protobuf/proto"
import math "math"

// discarding unused import gogoproto "gogoproto"

import io "io"
import fmt "fmt"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto1.Marshal
var _ = math.Inf

// TransactionRestart indicates how an error should be handled in a
// transactional context.
type TransactionRestart int32

const (
	// ABORT (the default) is for errors that are considered permanent
	// and should abort the transaction.
	TransactionRestart_ABORT TransactionRestart = 0
	// BACKOFF is for errors that can retried by restarting the transaction
	// after an exponential backoff.
	TransactionRestart_BACKOFF TransactionRestart = 1
	// IMMEDIATE is for errors that can be retried by restarting the
	// transaction immediately.
	TransactionRestart_IMMEDIATE TransactionRestart = 2
)

var TransactionRestart_name = map[int32]string{
	0: "ABORT",
	1: "BACKOFF",
	2: "IMMEDIATE",
}
var TransactionRestart_value = map[string]int32{
	"ABORT":     0,
	"BACKOFF":   1,
	"IMMEDIATE": 2,
}

func (x TransactionRestart) Enum() *TransactionRestart {
	p := new(TransactionRestart)
	*p = x
	return p
}
func (x TransactionRestart) String() string {
	return proto1.EnumName(TransactionRestart_name, int32(x))
}
func (x *TransactionRestart) UnmarshalJSON(data []byte) error {
	value, err := proto1.UnmarshalJSONEnum(TransactionRestart_value, data, "TransactionRestart")
	if err != nil {
		return err
	}
	*x = TransactionRestart(value)
	return nil
}

// A NotLeaderError indicates that the current range is not the
// leader. If the leader is known, its Replica is set in the error.
type NotLeaderError struct {
	Replica          *Replica `protobuf:"bytes,1,opt,name=replica" json:"replica,omitempty"`
	Leader           *Replica `protobuf:"bytes,2,opt,name=leader" json:"leader,omitempty"`
	XXX_unrecognized []byte   `json:"-"`
}

func (m *NotLeaderError) Reset()      { *m = NotLeaderError{} }
func (*NotLeaderError) ProtoMessage() {}

func (m *NotLeaderError) GetReplica() *Replica {
	if m != nil {
		return m.Replica
	}
	return nil
}

func (m *NotLeaderError) GetLeader() *Replica {
	if m != nil {
		return m.Leader
	}
	return nil
}

// A NodeUnavailableError indicates that the sending gateway can
// not process requests at the time, and that the client should
// retry the request with another peer.
type NodeUnavailableError struct {
	XXX_unrecognized []byte `json:"-"`
}

func (m *NodeUnavailableError) Reset()      { *m = NodeUnavailableError{} }
func (*NodeUnavailableError) ProtoMessage() {}

// A RangeNotFoundError indicates that a command was sent to a range
// which is not hosted on this store.
type RangeNotFoundError struct {
	RangeID          RangeID `protobuf:"varint,1,opt,name=range_id,casttype=RangeID" json:"range_id"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *RangeNotFoundError) Reset()      { *m = RangeNotFoundError{} }
func (*RangeNotFoundError) ProtoMessage() {}

func (m *RangeNotFoundError) GetRangeID() RangeID {
	if m != nil {
		return m.RangeID
	}
	return 0
}

// A RangeKeyMismatchError indicates that a command was sent to a
// range which did not contain the key(s) specified by the command.
type RangeKeyMismatchError struct {
	RequestStartKey  Key              `protobuf:"bytes,1,opt,name=request_start_key,casttype=Key" json:"request_start_key,omitempty"`
	RequestEndKey    Key              `protobuf:"bytes,2,opt,name=request_end_key,casttype=Key" json:"request_end_key,omitempty"`
	Range            *RangeDescriptor `protobuf:"bytes,3,opt,name=range" json:"range,omitempty"`
	XXX_unrecognized []byte           `json:"-"`
}

func (m *RangeKeyMismatchError) Reset()      { *m = RangeKeyMismatchError{} }
func (*RangeKeyMismatchError) ProtoMessage() {}

func (m *RangeKeyMismatchError) GetRequestStartKey() Key {
	if m != nil {
		return m.RequestStartKey
	}
	return nil
}

func (m *RangeKeyMismatchError) GetRequestEndKey() Key {
	if m != nil {
		return m.RequestEndKey
	}
	return nil
}

func (m *RangeKeyMismatchError) GetRange() *RangeDescriptor {
	if m != nil {
		return m.Range
	}
	return nil
}

// A ReadWithinUncertaintyIntervalError indicates that a read at timestamp
// encountered a versioned value at existing_timestamp within the uncertainty
// interval of the reader.
// The read should be retried at existing_timestamp+1.
type ReadWithinUncertaintyIntervalError struct {
	Timestamp         Timestamp `protobuf:"bytes,1,opt,name=timestamp" json:"timestamp"`
	ExistingTimestamp Timestamp `protobuf:"bytes,2,opt,name=existing_timestamp" json:"existing_timestamp"`
	XXX_unrecognized  []byte    `json:"-"`
}

func (m *ReadWithinUncertaintyIntervalError) Reset()      { *m = ReadWithinUncertaintyIntervalError{} }
func (*ReadWithinUncertaintyIntervalError) ProtoMessage() {}

func (m *ReadWithinUncertaintyIntervalError) GetTimestamp() Timestamp {
	if m != nil {
		return m.Timestamp
	}
	return Timestamp{}
}

func (m *ReadWithinUncertaintyIntervalError) GetExistingTimestamp() Timestamp {
	if m != nil {
		return m.ExistingTimestamp
	}
	return Timestamp{}
}

// A TransactionAbortedError indicates that the transaction was
// aborted by another concurrent transaction.
type TransactionAbortedError struct {
	Txn              Transaction `protobuf:"bytes,1,opt,name=txn" json:"txn"`
	XXX_unrecognized []byte      `json:"-"`
}

func (m *TransactionAbortedError) Reset()      { *m = TransactionAbortedError{} }
func (*TransactionAbortedError) ProtoMessage() {}

func (m *TransactionAbortedError) GetTxn() Transaction {
	if m != nil {
		return m.Txn
	}
	return Transaction{}
}

// A TransactionPushError indicates that the transaction could not
// continue because it encountered a write intent from another
// transaction which it was unable to push.
type TransactionPushError struct {
	// txn can be null in the event the push error happened to a
	// non-transactional method.
	Txn              *Transaction `protobuf:"bytes,1,opt,name=txn" json:"txn,omitempty"`
	PusheeTxn        Transaction  `protobuf:"bytes,2,opt,name=pushee_txn" json:"pushee_txn"`
	XXX_unrecognized []byte       `json:"-"`
}

func (m *TransactionPushError) Reset()      { *m = TransactionPushError{} }
func (*TransactionPushError) ProtoMessage() {}

func (m *TransactionPushError) GetTxn() *Transaction {
	if m != nil {
		return m.Txn
	}
	return nil
}

func (m *TransactionPushError) GetPusheeTxn() Transaction {
	if m != nil {
		return m.PusheeTxn
	}
	return Transaction{}
}

// A TransactionRetryError indicates that the transaction must be
// retried, usually with an increased transaction timestamp. The
// transaction struct to use is returned with the error.
type TransactionRetryError struct {
	Txn              Transaction `protobuf:"bytes,1,opt,name=txn" json:"txn"`
	XXX_unrecognized []byte      `json:"-"`
}

func (m *TransactionRetryError) Reset()      { *m = TransactionRetryError{} }
func (*TransactionRetryError) ProtoMessage() {}

func (m *TransactionRetryError) GetTxn() Transaction {
	if m != nil {
		return m.Txn
	}
	return Transaction{}
}

// A TransactionStatusError indicates that the transaction status is
// incompatible with the requested operation. This might mean the
// transaction has already been committed. It might also be the case
// that the request to modify the transaction failed due to a
// regression in transaction epoch or timestamp, both of which may
// only monotonically increase.
type TransactionStatusError struct {
	Txn              Transaction `protobuf:"bytes,1,opt,name=txn" json:"txn"`
	Msg              string      `protobuf:"bytes,2,opt,name=msg" json:"msg"`
	XXX_unrecognized []byte      `json:"-"`
}

func (m *TransactionStatusError) Reset()      { *m = TransactionStatusError{} }
func (*TransactionStatusError) ProtoMessage() {}

func (m *TransactionStatusError) GetTxn() Transaction {
	if m != nil {
		return m.Txn
	}
	return Transaction{}
}

func (m *TransactionStatusError) GetMsg() string {
	if m != nil {
		return m.Msg
	}
	return ""
}

// A WriteIntentError indicates that one or more write intent
// belonging to another transaction were encountered leading to a
// read/write or write/write conflict. The keys at which the intent
// was encountered are set, as are the txn records for the intents'
// transactions. Resolved is set if the intent was successfully
// resolved, meaning the client may retry the operation
// immediately. If Resolved is false, the client should back off and
// retry.
type WriteIntentError struct {
	Intents          []Intent `protobuf:"bytes,1,rep,name=intents" json:"intents"`
	Resolved         bool     `protobuf:"varint,2,opt,name=resolved" json:"resolved"`
	XXX_unrecognized []byte   `json:"-"`
}

func (m *WriteIntentError) Reset()      { *m = WriteIntentError{} }
func (*WriteIntentError) ProtoMessage() {}

func (m *WriteIntentError) GetIntents() []Intent {
	if m != nil {
		return m.Intents
	}
	return nil
}

func (m *WriteIntentError) GetResolved() bool {
	if m != nil {
		return m.Resolved
	}
	return false
}

// A WriteTooOldError indicates that a write encountered a versioned
// value newer than its timestamp, making it impossible to rewrite
// history. The write should be retried at existing_timestamp+1.
type WriteTooOldError struct {
	Timestamp         Timestamp `protobuf:"bytes,1,opt,name=timestamp" json:"timestamp"`
	ExistingTimestamp Timestamp `protobuf:"bytes,2,opt,name=existing_timestamp" json:"existing_timestamp"`
	XXX_unrecognized  []byte    `json:"-"`
}

func (m *WriteTooOldError) Reset()      { *m = WriteTooOldError{} }
func (*WriteTooOldError) ProtoMessage() {}

func (m *WriteTooOldError) GetTimestamp() Timestamp {
	if m != nil {
		return m.Timestamp
	}
	return Timestamp{}
}

func (m *WriteTooOldError) GetExistingTimestamp() Timestamp {
	if m != nil {
		return m.ExistingTimestamp
	}
	return Timestamp{}
}

// An OpRequiresTxnError indicates that a command required to be
// carried out in a transactional context but was not.
// For example, a Scan which spans ranges requires a transaction.
// The operation should be retried inside of a transaction.
type OpRequiresTxnError struct {
	XXX_unrecognized []byte `json:"-"`
}

func (m *OpRequiresTxnError) Reset()      { *m = OpRequiresTxnError{} }
func (*OpRequiresTxnError) ProtoMessage() {}

// A ConditionFailedError indicates that the expected value
// of a ConditionalPutRequest was not found, either
// because it was missing or was not equal. The error will
// contain the actual value found.
type ConditionFailedError struct {
	ActualValue      *Value `protobuf:"bytes,1,opt,name=actual_value" json:"actual_value,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *ConditionFailedError) Reset()      { *m = ConditionFailedError{} }
func (*ConditionFailedError) ProtoMessage() {}

func (m *ConditionFailedError) GetActualValue() *Value {
	if m != nil {
		return m.ActualValue
	}
	return nil
}

// A LeaseRejectedError indicates that the requested replica could
// not acquire the desired lease because of an existing leader lease.
type LeaseRejectedError struct {
	Requested        Lease  `protobuf:"bytes,1,opt" json:"Requested"`
	Existing         Lease  `protobuf:"bytes,2,opt" json:"Existing"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *LeaseRejectedError) Reset()      { *m = LeaseRejectedError{} }
func (*LeaseRejectedError) ProtoMessage() {}

func (m *LeaseRejectedError) GetRequested() Lease {
	if m != nil {
		return m.Requested
	}
	return Lease{}
}

func (m *LeaseRejectedError) GetExisting() Lease {
	if m != nil {
		return m.Existing
	}
	return Lease{}
}

// ErrorDetail is a union type containing all available errors.
type ErrorDetail struct {
	NotLeader                     *NotLeaderError                     `protobuf:"bytes,1,opt,name=not_leader" json:"not_leader,omitempty"`
	RangeNotFound                 *RangeNotFoundError                 `protobuf:"bytes,2,opt,name=range_not_found" json:"range_not_found,omitempty"`
	RangeKeyMismatch              *RangeKeyMismatchError              `protobuf:"bytes,3,opt,name=range_key_mismatch" json:"range_key_mismatch,omitempty"`
	ReadWithinUncertaintyInterval *ReadWithinUncertaintyIntervalError `protobuf:"bytes,4,opt,name=read_within_uncertainty_interval" json:"read_within_uncertainty_interval,omitempty"`
	TransactionAborted            *TransactionAbortedError            `protobuf:"bytes,5,opt,name=transaction_aborted" json:"transaction_aborted,omitempty"`
	TransactionPush               *TransactionPushError               `protobuf:"bytes,6,opt,name=transaction_push" json:"transaction_push,omitempty"`
	TransactionRetry              *TransactionRetryError              `protobuf:"bytes,7,opt,name=transaction_retry" json:"transaction_retry,omitempty"`
	TransactionStatus             *TransactionStatusError             `protobuf:"bytes,8,opt,name=transaction_status" json:"transaction_status,omitempty"`
	WriteIntent                   *WriteIntentError                   `protobuf:"bytes,9,opt,name=write_intent" json:"write_intent,omitempty"`
	WriteTooOld                   *WriteTooOldError                   `protobuf:"bytes,10,opt,name=write_too_old" json:"write_too_old,omitempty"`
	OpRequiresTxn                 *OpRequiresTxnError                 `protobuf:"bytes,11,opt,name=op_requires_txn" json:"op_requires_txn,omitempty"`
	ConditionFailed               *ConditionFailedError               `protobuf:"bytes,12,opt,name=condition_failed" json:"condition_failed,omitempty"`
	LeaseRejected                 *LeaseRejectedError                 `protobuf:"bytes,13,opt,name=lease_rejected" json:"lease_rejected,omitempty"`
	NodeUnavailable               *NodeUnavailableError               `protobuf:"bytes,14,opt,name=node_unavailable" json:"node_unavailable,omitempty"`
	XXX_unrecognized              []byte                              `json:"-"`
}

func (m *ErrorDetail) Reset()      { *m = ErrorDetail{} }
func (*ErrorDetail) ProtoMessage() {}

func (m *ErrorDetail) GetNotLeader() *NotLeaderError {
	if m != nil {
		return m.NotLeader
	}
	return nil
}

func (m *ErrorDetail) GetRangeNotFound() *RangeNotFoundError {
	if m != nil {
		return m.RangeNotFound
	}
	return nil
}

func (m *ErrorDetail) GetRangeKeyMismatch() *RangeKeyMismatchError {
	if m != nil {
		return m.RangeKeyMismatch
	}
	return nil
}

func (m *ErrorDetail) GetReadWithinUncertaintyInterval() *ReadWithinUncertaintyIntervalError {
	if m != nil {
		return m.ReadWithinUncertaintyInterval
	}
	return nil
}

func (m *ErrorDetail) GetTransactionAborted() *TransactionAbortedError {
	if m != nil {
		return m.TransactionAborted
	}
	return nil
}

func (m *ErrorDetail) GetTransactionPush() *TransactionPushError {
	if m != nil {
		return m.TransactionPush
	}
	return nil
}

func (m *ErrorDetail) GetTransactionRetry() *TransactionRetryError {
	if m != nil {
		return m.TransactionRetry
	}
	return nil
}

func (m *ErrorDetail) GetTransactionStatus() *TransactionStatusError {
	if m != nil {
		return m.TransactionStatus
	}
	return nil
}

func (m *ErrorDetail) GetWriteIntent() *WriteIntentError {
	if m != nil {
		return m.WriteIntent
	}
	return nil
}

func (m *ErrorDetail) GetWriteTooOld() *WriteTooOldError {
	if m != nil {
		return m.WriteTooOld
	}
	return nil
}

func (m *ErrorDetail) GetOpRequiresTxn() *OpRequiresTxnError {
	if m != nil {
		return m.OpRequiresTxn
	}
	return nil
}

func (m *ErrorDetail) GetConditionFailed() *ConditionFailedError {
	if m != nil {
		return m.ConditionFailed
	}
	return nil
}

func (m *ErrorDetail) GetLeaseRejected() *LeaseRejectedError {
	if m != nil {
		return m.LeaseRejected
	}
	return nil
}

func (m *ErrorDetail) GetNodeUnavailable() *NodeUnavailableError {
	if m != nil {
		return m.NodeUnavailable
	}
	return nil
}

// Error is a generic representation including a string message
// and information about retryability.
type Error struct {
	// Message is a human-readable error message.
	Message string `protobuf:"bytes,1,opt,name=message" json:"message"`
	// If retryable is true, the error condition may be transient and the failed
	// operation may be retried (within the same transaction).
	Retryable bool `protobuf:"varint,2,opt,name=retryable" json:"retryable"`
	// If transaction_restart is not ABORT, the error condition may be handled by
	// restarting the transaction (with or without a backoff).
	TransactionRestart TransactionRestart `protobuf:"varint,4,opt,name=transaction_restart,enum=cockroach.proto.TransactionRestart" json:"transaction_restart"`
	// If an ErrorDetail is present, it may contain additional structured data
	// about the error.
	Detail           *ErrorDetail `protobuf:"bytes,3,opt,name=detail" json:"detail,omitempty"`
	XXX_unrecognized []byte       `json:"-"`
}

func (m *Error) Reset()      { *m = Error{} }
func (*Error) ProtoMessage() {}

func (m *Error) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

func (m *Error) GetRetryable() bool {
	if m != nil {
		return m.Retryable
	}
	return false
}

func (m *Error) GetTransactionRestart() TransactionRestart {
	if m != nil {
		return m.TransactionRestart
	}
	return TransactionRestart_ABORT
}

func (m *Error) GetDetail() *ErrorDetail {
	if m != nil {
		return m.Detail
	}
	return nil
}

func init() {
	proto1.RegisterEnum("cockroach.proto.TransactionRestart", TransactionRestart_name, TransactionRestart_value)
}
func (m *NotLeaderError) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Replica", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + msglen
			if msglen < 0 {
				return ErrInvalidLengthErrors
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Replica == nil {
				m.Replica = &Replica{}
			}
			if err := m.Replica.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Leader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + msglen
			if msglen < 0 {
				return ErrInvalidLengthErrors
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Leader == nil {
				m.Leader = &Replica{}
			}
			if err := m.Leader.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			var sizeOfWire int
			for {
				sizeOfWire++
				wire >>= 7
				if wire == 0 {
					break
				}
			}
			iNdEx -= sizeOfWire
			skippy, err := skipErrors(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthErrors
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, data[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	return nil
}
func (m *NodeUnavailableError) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		switch fieldNum {
		default:
			var sizeOfWire int
			for {
				sizeOfWire++
				wire >>= 7
				if wire == 0 {
					break
				}
			}
			iNdEx -= sizeOfWire
			skippy, err := skipErrors(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthErrors
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, data[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	return nil
}
func (m *RangeNotFoundError) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RangeID", wireType)
			}
			m.RangeID = 0
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.RangeID |= (RangeID(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			var sizeOfWire int
			for {
				sizeOfWire++
				wire >>= 7
				if wire == 0 {
					break
				}
			}
			iNdEx -= sizeOfWire
			skippy, err := skipErrors(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthErrors
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, data[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	return nil
}
func (m *RangeKeyMismatchError) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestStartKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthErrors
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RequestStartKey = append([]byte{}, data[iNdEx:postIndex]...)
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestEndKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthErrors
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RequestEndKey = append([]byte{}, data[iNdEx:postIndex]...)
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Range", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + msglen
			if msglen < 0 {
				return ErrInvalidLengthErrors
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Range == nil {
				m.Range = &RangeDescriptor{}
			}
			if err := m.Range.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			var sizeOfWire int
			for {
				sizeOfWire++
				wire >>= 7
				if wire == 0 {
					break
				}
			}
			iNdEx -= sizeOfWire
			skippy, err := skipErrors(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthErrors
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, data[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	return nil
}
func (m *ReadWithinUncertaintyIntervalError) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + msglen
			if msglen < 0 {
				return ErrInvalidLengthErrors
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Timestamp.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExistingTimestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + msglen
			if msglen < 0 {
				return ErrInvalidLengthErrors
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ExistingTimestamp.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			var sizeOfWire int
			for {
				sizeOfWire++
				wire >>= 7
				if wire == 0 {
					break
				}
			}
			iNdEx -= sizeOfWire
			skippy, err := skipErrors(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthErrors
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, data[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	return nil
}
func (m *TransactionAbortedError) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Txn", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + msglen
			if msglen < 0 {
				return ErrInvalidLengthErrors
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Txn.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			var sizeOfWire int
			for {
				sizeOfWire++
				wire >>= 7
				if wire == 0 {
					break
				}
			}
			iNdEx -= sizeOfWire
			skippy, err := skipErrors(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthErrors
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, data[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	return nil
}
func (m *TransactionPushError) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Txn", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + msglen
			if msglen < 0 {
				return ErrInvalidLengthErrors
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Txn == nil {
				m.Txn = &Transaction{}
			}
			if err := m.Txn.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PusheeTxn", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + msglen
			if msglen < 0 {
				return ErrInvalidLengthErrors
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.PusheeTxn.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			var sizeOfWire int
			for {
				sizeOfWire++
				wire >>= 7
				if wire == 0 {
					break
				}
			}
			iNdEx -= sizeOfWire
			skippy, err := skipErrors(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthErrors
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, data[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	return nil
}
func (m *TransactionRetryError) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Txn", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + msglen
			if msglen < 0 {
				return ErrInvalidLengthErrors
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Txn.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			var sizeOfWire int
			for {
				sizeOfWire++
				wire >>= 7
				if wire == 0 {
					break
				}
			}
			iNdEx -= sizeOfWire
			skippy, err := skipErrors(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthErrors
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, data[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	return nil
}
func (m *TransactionStatusError) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Txn", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + msglen
			if msglen < 0 {
				return ErrInvalidLengthErrors
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Txn.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + int(stringLen)
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Msg = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			var sizeOfWire int
			for {
				sizeOfWire++
				wire >>= 7
				if wire == 0 {
					break
				}
			}
			iNdEx -= sizeOfWire
			skippy, err := skipErrors(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthErrors
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, data[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	return nil
}
func (m *WriteIntentError) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Intents", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + msglen
			if msglen < 0 {
				return ErrInvalidLengthErrors
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Intents = append(m.Intents, Intent{})
			if err := m.Intents[len(m.Intents)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Resolved", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Resolved = bool(v != 0)
		default:
			var sizeOfWire int
			for {
				sizeOfWire++
				wire >>= 7
				if wire == 0 {
					break
				}
			}
			iNdEx -= sizeOfWire
			skippy, err := skipErrors(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthErrors
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, data[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	return nil
}
func (m *WriteTooOldError) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + msglen
			if msglen < 0 {
				return ErrInvalidLengthErrors
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Timestamp.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExistingTimestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + msglen
			if msglen < 0 {
				return ErrInvalidLengthErrors
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ExistingTimestamp.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			var sizeOfWire int
			for {
				sizeOfWire++
				wire >>= 7
				if wire == 0 {
					break
				}
			}
			iNdEx -= sizeOfWire
			skippy, err := skipErrors(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthErrors
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, data[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	return nil
}
func (m *OpRequiresTxnError) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		switch fieldNum {
		default:
			var sizeOfWire int
			for {
				sizeOfWire++
				wire >>= 7
				if wire == 0 {
					break
				}
			}
			iNdEx -= sizeOfWire
			skippy, err := skipErrors(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthErrors
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, data[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	return nil
}
func (m *ConditionFailedError) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActualValue", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + msglen
			if msglen < 0 {
				return ErrInvalidLengthErrors
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ActualValue == nil {
				m.ActualValue = &Value{}
			}
			if err := m.ActualValue.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			var sizeOfWire int
			for {
				sizeOfWire++
				wire >>= 7
				if wire == 0 {
					break
				}
			}
			iNdEx -= sizeOfWire
			skippy, err := skipErrors(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthErrors
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, data[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	return nil
}
func (m *LeaseRejectedError) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Requested", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + msglen
			if msglen < 0 {
				return ErrInvalidLengthErrors
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Requested.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Existing", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + msglen
			if msglen < 0 {
				return ErrInvalidLengthErrors
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Existing.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			var sizeOfWire int
			for {
				sizeOfWire++
				wire >>= 7
				if wire == 0 {
					break
				}
			}
			iNdEx -= sizeOfWire
			skippy, err := skipErrors(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthErrors
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, data[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	return nil
}
func (m *ErrorDetail) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NotLeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + msglen
			if msglen < 0 {
				return ErrInvalidLengthErrors
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NotLeader == nil {
				m.NotLeader = &NotLeaderError{}
			}
			if err := m.NotLeader.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RangeNotFound", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + msglen
			if msglen < 0 {
				return ErrInvalidLengthErrors
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RangeNotFound == nil {
				m.RangeNotFound = &RangeNotFoundError{}
			}
			if err := m.RangeNotFound.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RangeKeyMismatch", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + msglen
			if msglen < 0 {
				return ErrInvalidLengthErrors
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RangeKeyMismatch == nil {
				m.RangeKeyMismatch = &RangeKeyMismatchError{}
			}
			if err := m.RangeKeyMismatch.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadWithinUncertaintyInterval", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + msglen
			if msglen < 0 {
				return ErrInvalidLengthErrors
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ReadWithinUncertaintyInterval == nil {
				m.ReadWithinUncertaintyInterval = &ReadWithinUncertaintyIntervalError{}
			}
			if err := m.ReadWithinUncertaintyInterval.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TransactionAborted", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + msglen
			if msglen < 0 {
				return ErrInvalidLengthErrors
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TransactionAborted == nil {
				m.TransactionAborted = &TransactionAbortedError{}
			}
			if err := m.TransactionAborted.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TransactionPush", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + msglen
			if msglen < 0 {
				return ErrInvalidLengthErrors
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TransactionPush == nil {
				m.TransactionPush = &TransactionPushError{}
			}
			if err := m.TransactionPush.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TransactionRetry", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + msglen
			if msglen < 0 {
				return ErrInvalidLengthErrors
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TransactionRetry == nil {
				m.TransactionRetry = &TransactionRetryError{}
			}
			if err := m.TransactionRetry.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TransactionStatus", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + msglen
			if msglen < 0 {
				return ErrInvalidLengthErrors
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TransactionStatus == nil {
				m.TransactionStatus = &TransactionStatusError{}
			}
			if err := m.TransactionStatus.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WriteIntent", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + msglen
			if msglen < 0 {
				return ErrInvalidLengthErrors
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.WriteIntent == nil {
				m.WriteIntent = &WriteIntentError{}
			}
			if err := m.WriteIntent.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WriteTooOld", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + msglen
			if msglen < 0 {
				return ErrInvalidLengthErrors
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.WriteTooOld == nil {
				m.WriteTooOld = &WriteTooOldError{}
			}
			if err := m.WriteTooOld.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OpRequiresTxn", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + msglen
			if msglen < 0 {
				return ErrInvalidLengthErrors
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OpRequiresTxn == nil {
				m.OpRequiresTxn = &OpRequiresTxnError{}
			}
			if err := m.OpRequiresTxn.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConditionFailed", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + msglen
			if msglen < 0 {
				return ErrInvalidLengthErrors
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ConditionFailed == nil {
				m.ConditionFailed = &ConditionFailedError{}
			}
			if err := m.ConditionFailed.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LeaseRejected", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + msglen
			if msglen < 0 {
				return ErrInvalidLengthErrors
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LeaseRejected == nil {
				m.LeaseRejected = &LeaseRejectedError{}
			}
			if err := m.LeaseRejected.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeUnavailable", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + msglen
			if msglen < 0 {
				return ErrInvalidLengthErrors
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NodeUnavailable == nil {
				m.NodeUnavailable = &NodeUnavailableError{}
			}
			if err := m.NodeUnavailable.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			var sizeOfWire int
			for {
				sizeOfWire++
				wire >>= 7
				if wire == 0 {
					break
				}
			}
			iNdEx -= sizeOfWire
			skippy, err := skipErrors(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthErrors
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, data[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	return nil
}
func (m *Error) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + int(stringLen)
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Retryable", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Retryable = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TransactionRestart", wireType)
			}
			m.TransactionRestart = 0
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.TransactionRestart |= (TransactionRestart(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Detail", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + msglen
			if msglen < 0 {
				return ErrInvalidLengthErrors
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Detail == nil {
				m.Detail = &ErrorDetail{}
			}
			if err := m.Detail.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			var sizeOfWire int
			for {
				sizeOfWire++
				wire >>= 7
				if wire == 0 {
					break
				}
			}
			iNdEx -= sizeOfWire
			skippy, err := skipErrors(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthErrors
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, data[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	return nil
}
func skipErrors(data []byte) (n int, err error) {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for {
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if data[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthErrors
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipErrors(data[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthErrors = fmt.Errorf("proto: negative length found during unmarshaling")
)

func (this *ErrorDetail) GetValue() interface{} {
	if this.NotLeader != nil {
		return this.NotLeader
	}
	if this.RangeNotFound != nil {
		return this.RangeNotFound
	}
	if this.RangeKeyMismatch != nil {
		return this.RangeKeyMismatch
	}
	if this.ReadWithinUncertaintyInterval != nil {
		return this.ReadWithinUncertaintyInterval
	}
	if this.TransactionAborted != nil {
		return this.TransactionAborted
	}
	if this.TransactionPush != nil {
		return this.TransactionPush
	}
	if this.TransactionRetry != nil {
		return this.TransactionRetry
	}
	if this.TransactionStatus != nil {
		return this.TransactionStatus
	}
	if this.WriteIntent != nil {
		return this.WriteIntent
	}
	if this.WriteTooOld != nil {
		return this.WriteTooOld
	}
	if this.OpRequiresTxn != nil {
		return this.OpRequiresTxn
	}
	if this.ConditionFailed != nil {
		return this.ConditionFailed
	}
	if this.LeaseRejected != nil {
		return this.LeaseRejected
	}
	if this.NodeUnavailable != nil {
		return this.NodeUnavailable
	}
	return nil
}

func (this *ErrorDetail) SetValue(value interface{}) bool {
	switch vt := value.(type) {
	case *NotLeaderError:
		this.NotLeader = vt
	case *RangeNotFoundError:
		this.RangeNotFound = vt
	case *RangeKeyMismatchError:
		this.RangeKeyMismatch = vt
	case *ReadWithinUncertaintyIntervalError:
		this.ReadWithinUncertaintyInterval = vt
	case *TransactionAbortedError:
		this.TransactionAborted = vt
	case *TransactionPushError:
		this.TransactionPush = vt
	case *TransactionRetryError:
		this.TransactionRetry = vt
	case *TransactionStatusError:
		this.TransactionStatus = vt
	case *WriteIntentError:
		this.WriteIntent = vt
	case *WriteTooOldError:
		this.WriteTooOld = vt
	case *OpRequiresTxnError:
		this.OpRequiresTxn = vt
	case *ConditionFailedError:
		this.ConditionFailed = vt
	case *LeaseRejectedError:
		this.LeaseRejected = vt
	case *NodeUnavailableError:
		this.NodeUnavailable = vt
	default:
		return false
	}
	return true
}
func (m *NotLeaderError) Size() (n int) {
	var l int
	_ = l
	if m.Replica != nil {
		l = m.Replica.Size()
		n += 1 + l + sovErrors(uint64(l))
	}
	if m.Leader != nil {
		l = m.Leader.Size()
		n += 1 + l + sovErrors(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *NodeUnavailableError) Size() (n int) {
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RangeNotFoundError) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovErrors(uint64(m.RangeID))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RangeKeyMismatchError) Size() (n int) {
	var l int
	_ = l
	if m.RequestStartKey != nil {
		l = len(m.RequestStartKey)
		n += 1 + l + sovErrors(uint64(l))
	}
	if m.RequestEndKey != nil {
		l = len(m.RequestEndKey)
		n += 1 + l + sovErrors(uint64(l))
	}
	if m.Range != nil {
		l = m.Range.Size()
		n += 1 + l + sovErrors(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ReadWithinUncertaintyIntervalError) Size() (n int) {
	var l int
	_ = l
	l = m.Timestamp.Size()
	n += 1 + l + sovErrors(uint64(l))
	l = m.ExistingTimestamp.Size()
	n += 1 + l + sovErrors(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TransactionAbortedError) Size() (n int) {
	var l int
	_ = l
	l = m.Txn.Size()
	n += 1 + l + sovErrors(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TransactionPushError) Size() (n int) {
	var l int
	_ = l
	if m.Txn != nil {
		l = m.Txn.Size()
		n += 1 + l + sovErrors(uint64(l))
	}
	l = m.PusheeTxn.Size()
	n += 1 + l + sovErrors(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TransactionRetryError) Size() (n int) {
	var l int
	_ = l
	l = m.Txn.Size()
	n += 1 + l + sovErrors(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TransactionStatusError) Size() (n int) {
	var l int
	_ = l
	l = m.Txn.Size()
	n += 1 + l + sovErrors(uint64(l))
	l = len(m.Msg)
	n += 1 + l + sovErrors(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *WriteIntentError) Size() (n int) {
	var l int
	_ = l
	if len(m.Intents) > 0 {
		for _, e := range m.Intents {
			l = e.Size()
			n += 1 + l + sovErrors(uint64(l))
		}
	}
	n += 2
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *WriteTooOldError) Size() (n int) {
	var l int
	_ = l
	l = m.Timestamp.Size()
	n += 1 + l + sovErrors(uint64(l))
	l = m.ExistingTimestamp.Size()
	n += 1 + l + sovErrors(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *OpRequiresTxnError) Size() (n int) {
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ConditionFailedError) Size() (n int) {
	var l int
	_ = l
	if m.ActualValue != nil {
		l = m.ActualValue.Size()
		n += 1 + l + sovErrors(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LeaseRejectedError) Size() (n int) {
	var l int
	_ = l
	l = m.Requested.Size()
	n += 1 + l + sovErrors(uint64(l))
	l = m.Existing.Size()
	n += 1 + l + sovErrors(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ErrorDetail) Size() (n int) {
	var l int
	_ = l
	if m.NotLeader != nil {
		l = m.NotLeader.Size()
		n += 1 + l + sovErrors(uint64(l))
	}
	if m.RangeNotFound != nil {
		l = m.RangeNotFound.Size()
		n += 1 + l + sovErrors(uint64(l))
	}
	if m.RangeKeyMismatch != nil {
		l = m.RangeKeyMismatch.Size()
		n += 1 + l + sovErrors(uint64(l))
	}
	if m.ReadWithinUncertaintyInterval != nil {
		l = m.ReadWithinUncertaintyInterval.Size()
		n += 1 + l + sovErrors(uint64(l))
	}
	if m.TransactionAborted != nil {
		l = m.TransactionAborted.Size()
		n += 1 + l + sovErrors(uint64(l))
	}
	if m.TransactionPush != nil {
		l = m.TransactionPush.Size()
		n += 1 + l + sovErrors(uint64(l))
	}
	if m.TransactionRetry != nil {
		l = m.TransactionRetry.Size()
		n += 1 + l + sovErrors(uint64(l))
	}
	if m.TransactionStatus != nil {
		l = m.TransactionStatus.Size()
		n += 1 + l + sovErrors(uint64(l))
	}
	if m.WriteIntent != nil {
		l = m.WriteIntent.Size()
		n += 1 + l + sovErrors(uint64(l))
	}
	if m.WriteTooOld != nil {
		l = m.WriteTooOld.Size()
		n += 1 + l + sovErrors(uint64(l))
	}
	if m.OpRequiresTxn != nil {
		l = m.OpRequiresTxn.Size()
		n += 1 + l + sovErrors(uint64(l))
	}
	if m.ConditionFailed != nil {
		l = m.ConditionFailed.Size()
		n += 1 + l + sovErrors(uint64(l))
	}
	if m.LeaseRejected != nil {
		l = m.LeaseRejected.Size()
		n += 1 + l + sovErrors(uint64(l))
	}
	if m.NodeUnavailable != nil {
		l = m.NodeUnavailable.Size()
		n += 1 + l + sovErrors(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Error) Size() (n int) {
	var l int
	_ = l
	l = len(m.Message)
	n += 1 + l + sovErrors(uint64(l))
	n += 2
	n += 1 + sovErrors(uint64(m.TransactionRestart))
	if m.Detail != nil {
		l = m.Detail.Size()
		n += 1 + l + sovErrors(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovErrors(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozErrors(x uint64) (n int) {
	return sovErrors(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *NotLeaderError) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *NotLeaderError) MarshalTo(data []byte) (n int, err error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Replica != nil {
		data[i] = 0xa
		i++
		i = encodeVarintErrors(data, i, uint64(m.Replica.Size()))
		n1, err := m.Replica.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if m.Leader != nil {
		data[i] = 0x12
		i++
		i = encodeVarintErrors(data, i, uint64(m.Leader.Size()))
		n2, err := m.Leader.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	if m.XXX_unrecognized != nil {
		i += copy(data[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *NodeUnavailableError) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *NodeUnavailableError) MarshalTo(data []byte) (n int, err error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i += copy(data[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *RangeNotFoundError) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *RangeNotFoundError) MarshalTo(data []byte) (n int, err error) {
	var i int
	_ = i
	var l int
	_ = l
	data[i] = 0x8
	i++
	i = encodeVarintErrors(data, i, uint64(m.RangeID))
	if m.XXX_unrecognized != nil {
		i += copy(data[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *RangeKeyMismatchError) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *RangeKeyMismatchError) MarshalTo(data []byte) (n int, err error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.RequestStartKey != nil {
		data[i] = 0xa
		i++
		i = encodeVarintErrors(data, i, uint64(len(m.RequestStartKey)))
		i += copy(data[i:], m.RequestStartKey)
	}
	if m.RequestEndKey != nil {
		data[i] = 0x12
		i++
		i = encodeVarintErrors(data, i, uint64(len(m.RequestEndKey)))
		i += copy(data[i:], m.RequestEndKey)
	}
	if m.Range != nil {
		data[i] = 0x1a
		i++
		i = encodeVarintErrors(data, i, uint64(m.Range.Size()))
		n3, err := m.Range.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	if m.XXX_unrecognized != nil {
		i += copy(data[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ReadWithinUncertaintyIntervalError) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *ReadWithinUncertaintyIntervalError) MarshalTo(data []byte) (n int, err error) {
	var i int
	_ = i
	var l int
	_ = l
	data[i] = 0xa
	i++
	i = encodeVarintErrors(data, i, uint64(m.Timestamp.Size()))
	n4, err := m.Timestamp.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n4
	data[i] = 0x12
	i++
	i = encodeVarintErrors(data, i, uint64(m.ExistingTimestamp.Size()))
	n5, err := m.ExistingTimestamp.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n5
	if m.XXX_unrecognized != nil {
		i += copy(data[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *TransactionAbortedError) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *TransactionAbortedError) MarshalTo(data []byte) (n int, err error) {
	var i int
	_ = i
	var l int
	_ = l
	data[i] = 0xa
	i++
	i = encodeVarintErrors(data, i, uint64(m.Txn.Size()))
	n6, err := m.Txn.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n6
	if m.XXX_unrecognized != nil {
		i += copy(data[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *TransactionPushError) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *TransactionPushError) MarshalTo(data []byte) (n int, err error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Txn != nil {
		data[i] = 0xa
		i++
		i = encodeVarintErrors(data, i, uint64(m.Txn.Size()))
		n7, err := m.Txn.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	data[i] = 0x12
	i++
	i = encodeVarintErrors(data, i, uint64(m.PusheeTxn.Size()))
	n8, err := m.PusheeTxn.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n8
	if m.XXX_unrecognized != nil {
		i += copy(data[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *TransactionRetryError) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *TransactionRetryError) MarshalTo(data []byte) (n int, err error) {
	var i int
	_ = i
	var l int
	_ = l
	data[i] = 0xa
	i++
	i = encodeVarintErrors(data, i, uint64(m.Txn.Size()))
	n9, err := m.Txn.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n9
	if m.XXX_unrecognized != nil {
		i += copy(data[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *TransactionStatusError) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *TransactionStatusError) MarshalTo(data []byte) (n int, err error) {
	var i int
	_ = i
	var l int
	_ = l
	data[i] = 0xa
	i++
	i = encodeVarintErrors(data, i, uint64(m.Txn.Size()))
	n10, err := m.Txn.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n10
	data[i] = 0x12
	i++
	i = encodeVarintErrors(data, i, uint64(len(m.Msg)))
	i += copy(data[i:], m.Msg)
	if m.XXX_unrecognized != nil {
		i += copy(data[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *WriteIntentError) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *WriteIntentError) MarshalTo(data []byte) (n int, err error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Intents) > 0 {
		for _, msg := range m.Intents {
			data[i] = 0xa
			i++
			i = encodeVarintErrors(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	data[i] = 0x10
	i++
	if m.Resolved {
		data[i] = 1
	} else {
		data[i] = 0
	}
	i++
	if m.XXX_unrecognized != nil {
		i += copy(data[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *WriteTooOldError) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *WriteTooOldError) MarshalTo(data []byte) (n int, err error) {
	var i int
	_ = i
	var l int
	_ = l
	data[i] = 0xa
	i++
	i = encodeVarintErrors(data, i, uint64(m.Timestamp.Size()))
	n11, err := m.Timestamp.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n11
	data[i] = 0x12
	i++
	i = encodeVarintErrors(data, i, uint64(m.ExistingTimestamp.Size()))
	n12, err := m.ExistingTimestamp.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n12
	if m.XXX_unrecognized != nil {
		i += copy(data[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *OpRequiresTxnError) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *OpRequiresTxnError) MarshalTo(data []byte) (n int, err error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i += copy(data[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ConditionFailedError) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *ConditionFailedError) MarshalTo(data []byte) (n int, err error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ActualValue != nil {
		data[i] = 0xa
		i++
		i = encodeVarintErrors(data, i, uint64(m.ActualValue.Size()))
		n13, err := m.ActualValue.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n13
	}
	if m.XXX_unrecognized != nil {
		i += copy(data[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *LeaseRejectedError) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *LeaseRejectedError) MarshalTo(data []byte) (n int, err error) {
	var i int
	_ = i
	var l int
	_ = l
	data[i] = 0xa
	i++
	i = encodeVarintErrors(data, i, uint64(m.Requested.Size()))
	n14, err := m.Requested.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n14
	data[i] = 0x12
	i++
	i = encodeVarintErrors(data, i, uint64(m.Existing.Size()))
	n15, err := m.Existing.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n15
	if m.XXX_unrecognized != nil {
		i += copy(data[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ErrorDetail) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *ErrorDetail) MarshalTo(data []byte) (n int, err error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.NotLeader != nil {
		data[i] = 0xa
		i++
		i = encodeVarintErrors(data, i, uint64(m.NotLeader.Size()))
		n16, err := m.NotLeader.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n16
	}
	if m.RangeNotFound != nil {
		data[i] = 0x12
		i++
		i = encodeVarintErrors(data, i, uint64(m.RangeNotFound.Size()))
		n17, err := m.RangeNotFound.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n17
	}
	if m.RangeKeyMismatch != nil {
		data[i] = 0x1a
		i++
		i = encodeVarintErrors(data, i, uint64(m.RangeKeyMismatch.Size()))
		n18, err := m.RangeKeyMismatch.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n18
	}
	if m.ReadWithinUncertaintyInterval != nil {
		data[i] = 0x22
		i++
		i = encodeVarintErrors(data, i, uint64(m.ReadWithinUncertaintyInterval.Size()))
		n19, err := m.ReadWithinUncertaintyInterval.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n19
	}
	if m.TransactionAborted != nil {
		data[i] = 0x2a
		i++
		i = encodeVarintErrors(data, i, uint64(m.TransactionAborted.Size()))
		n20, err := m.TransactionAborted.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n20
	}
	if m.TransactionPush != nil {
		data[i] = 0x32
		i++
		i = encodeVarintErrors(data, i, uint64(m.TransactionPush.Size()))
		n21, err := m.TransactionPush.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n21
	}
	if m.TransactionRetry != nil {
		data[i] = 0x3a
		i++
		i = encodeVarintErrors(data, i, uint64(m.TransactionRetry.Size()))
		n22, err := m.TransactionRetry.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n22
	}
	if m.TransactionStatus != nil {
		data[i] = 0x42
		i++
		i = encodeVarintErrors(data, i, uint64(m.TransactionStatus.Size()))
		n23, err := m.TransactionStatus.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n23
	}
	if m.WriteIntent != nil {
		data[i] = 0x4a
		i++
		i = encodeVarintErrors(data, i, uint64(m.WriteIntent.Size()))
		n24, err := m.WriteIntent.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n24
	}
	if m.WriteTooOld != nil {
		data[i] = 0x52
		i++
		i = encodeVarintErrors(data, i, uint64(m.WriteTooOld.Size()))
		n25, err := m.WriteTooOld.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n25
	}
	if m.OpRequiresTxn != nil {
		data[i] = 0x5a
		i++
		i = encodeVarintErrors(data, i, uint64(m.OpRequiresTxn.Size()))
		n26, err := m.OpRequiresTxn.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n26
	}
	if m.ConditionFailed != nil {
		data[i] = 0x62
		i++
		i = encodeVarintErrors(data, i, uint64(m.ConditionFailed.Size()))
		n27, err := m.ConditionFailed.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n27
	}
	if m.LeaseRejected != nil {
		data[i] = 0x6a
		i++
		i = encodeVarintErrors(data, i, uint64(m.LeaseRejected.Size()))
		n28, err := m.LeaseRejected.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n28
	}
	if m.NodeUnavailable != nil {
		data[i] = 0x72
		i++
		i = encodeVarintErrors(data, i, uint64(m.NodeUnavailable.Size()))
		n29, err := m.NodeUnavailable.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n29
	}
	if m.XXX_unrecognized != nil {
		i += copy(data[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Error) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Error) MarshalTo(data []byte) (n int, err error) {
	var i int
	_ = i
	var l int
	_ = l
	data[i] = 0xa
	i++
	i = encodeVarintErrors(data, i, uint64(len(m.Message)))
	i += copy(data[i:], m.Message)
	data[i] = 0x10
	i++
	if m.Retryable {
		data[i] = 1
	} else {
		data[i] = 0
	}
	i++
	if m.Detail != nil {
		data[i] = 0x1a
		i++
		i = encodeVarintErrors(data, i, uint64(m.Detail.Size()))
		n30, err := m.Detail.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n30
	}
	data[i] = 0x20
	i++
	i = encodeVarintErrors(data, i, uint64(m.TransactionRestart))
	if m.XXX_unrecognized != nil {
		i += copy(data[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func encodeFixed64Errors(data []byte, offset int, v uint64) int {
	data[offset] = uint8(v)
	data[offset+1] = uint8(v >> 8)
	data[offset+2] = uint8(v >> 16)
	data[offset+3] = uint8(v >> 24)
	data[offset+4] = uint8(v >> 32)
	data[offset+5] = uint8(v >> 40)
	data[offset+6] = uint8(v >> 48)
	data[offset+7] = uint8(v >> 56)
	return offset + 8
}
func encodeFixed32Errors(data []byte, offset int, v uint32) int {
	data[offset] = uint8(v)
	data[offset+1] = uint8(v >> 8)
	data[offset+2] = uint8(v >> 16)
	data[offset+3] = uint8(v >> 24)
	return offset + 4
}
func encodeVarintErrors(data []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		data[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	data[offset] = uint8(v)
	return offset + 1
}
