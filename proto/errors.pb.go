// Code generated by protoc-gen-gogo.
// source: errors.proto
// DO NOT EDIT!

package proto

import proto1 "github.com/gogo/protobuf/proto"
import math "math"

// discarding unused import gogoproto "github.com/gogo/protobuf/gogoproto/gogo.pb"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto1.Marshal
var _ = math.Inf

// A GenericError is a generic representation of a go error including
// the string message and whether or not the error is retryable.
type GenericError struct {
	Message          string `protobuf:"bytes,1,opt,name=message" json:"message"`
	Retryable        bool   `protobuf:"varint,2,opt,name=retryable" json:"retryable"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *GenericError) Reset()         { *m = GenericError{} }
func (m *GenericError) String() string { return proto1.CompactTextString(m) }
func (*GenericError) ProtoMessage()    {}

func (m *GenericError) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

func (m *GenericError) GetRetryable() bool {
	if m != nil {
		return m.Retryable
	}
	return false
}

// A NotLeaderError indicates that the current range is not the
// leader. If the leader is known, its Replica is set in the error.
type NotLeaderError struct {
	Leader           Replica `protobuf:"bytes,1,opt,name=leader" json:"leader"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *NotLeaderError) Reset()         { *m = NotLeaderError{} }
func (m *NotLeaderError) String() string { return proto1.CompactTextString(m) }
func (*NotLeaderError) ProtoMessage()    {}

func (m *NotLeaderError) GetLeader() Replica {
	if m != nil {
		return m.Leader
	}
	return Replica{}
}

// A RangeNotFoundError indicates that a command was sent to a range
// which is not hosted on this store.
type RangeNotFoundError struct {
	RaftID           int64  `protobuf:"varint,1,opt,name=raft_id" json:"raft_id"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *RangeNotFoundError) Reset()         { *m = RangeNotFoundError{} }
func (m *RangeNotFoundError) String() string { return proto1.CompactTextString(m) }
func (*RangeNotFoundError) ProtoMessage()    {}

func (m *RangeNotFoundError) GetRaftID() int64 {
	if m != nil {
		return m.RaftID
	}
	return 0
}

// A RangeKeyMismatchError indicates that a command was sent to a
// range which did not contain the key(s) specified by the command.
type RangeKeyMismatchError struct {
	RequestStartKey  Key              `protobuf:"bytes,1,opt,name=request_start_key,customtype=Key" json:"request_start_key"`
	RequestEndKey    Key              `protobuf:"bytes,2,opt,name=request_end_key,customtype=Key" json:"request_end_key"`
	Range            *RangeDescriptor `protobuf:"bytes,3,opt,name=range" json:"range,omitempty"`
	XXX_unrecognized []byte           `json:"-"`
}

func (m *RangeKeyMismatchError) Reset()         { *m = RangeKeyMismatchError{} }
func (m *RangeKeyMismatchError) String() string { return proto1.CompactTextString(m) }
func (*RangeKeyMismatchError) ProtoMessage()    {}

func (m *RangeKeyMismatchError) GetRange() *RangeDescriptor {
	if m != nil {
		return m.Range
	}
	return nil
}

// A ReadWithinUncertaintyIntervalError indicates that a read at timestamp
// encountered a versioned value at existing_timestamp within the uncertainty
// interval of the reader.
// The read should be retried at existing_timestamp+1.
type ReadWithinUncertaintyIntervalError struct {
	Timestamp         Timestamp `protobuf:"bytes,1,opt,name=timestamp" json:"timestamp"`
	ExistingTimestamp Timestamp `protobuf:"bytes,2,opt,name=existing_timestamp" json:"existing_timestamp"`
	XXX_unrecognized  []byte    `json:"-"`
}

func (m *ReadWithinUncertaintyIntervalError) Reset()         { *m = ReadWithinUncertaintyIntervalError{} }
func (m *ReadWithinUncertaintyIntervalError) String() string { return proto1.CompactTextString(m) }
func (*ReadWithinUncertaintyIntervalError) ProtoMessage()    {}

func (m *ReadWithinUncertaintyIntervalError) GetTimestamp() Timestamp {
	if m != nil {
		return m.Timestamp
	}
	return Timestamp{}
}

func (m *ReadWithinUncertaintyIntervalError) GetExistingTimestamp() Timestamp {
	if m != nil {
		return m.ExistingTimestamp
	}
	return Timestamp{}
}

// A TransactionAbortedError indicates that the transaction was
// aborted by another concurrent transaction.
type TransactionAbortedError struct {
	Txn              Transaction `protobuf:"bytes,1,opt,name=txn" json:"txn"`
	XXX_unrecognized []byte      `json:"-"`
}

func (m *TransactionAbortedError) Reset()         { *m = TransactionAbortedError{} }
func (m *TransactionAbortedError) String() string { return proto1.CompactTextString(m) }
func (*TransactionAbortedError) ProtoMessage()    {}

func (m *TransactionAbortedError) GetTxn() Transaction {
	if m != nil {
		return m.Txn
	}
	return Transaction{}
}

// A TransactionPushError indicates that the transaction could not
// continu because it encountered a write intent from another
// transaction which it was unable to push.
type TransactionPushError struct {
	// txn can be null in the event the push error happened to a
	// non-transactional method.
	Txn              *Transaction `protobuf:"bytes,1,opt,name=txn" json:"txn,omitempty"`
	PusheeTxn        Transaction  `protobuf:"bytes,2,opt,name=pushee_txn" json:"pushee_txn"`
	XXX_unrecognized []byte       `json:"-"`
}

func (m *TransactionPushError) Reset()         { *m = TransactionPushError{} }
func (m *TransactionPushError) String() string { return proto1.CompactTextString(m) }
func (*TransactionPushError) ProtoMessage()    {}

func (m *TransactionPushError) GetTxn() *Transaction {
	if m != nil {
		return m.Txn
	}
	return nil
}

func (m *TransactionPushError) GetPusheeTxn() Transaction {
	if m != nil {
		return m.PusheeTxn
	}
	return Transaction{}
}

// A TransactionRetryError indicates that the transaction must be
// retried, usually with an increased transaction timestamp. The
// transaction struct to use is returned with the error.
type TransactionRetryError struct {
	Txn              Transaction `protobuf:"bytes,1,opt,name=txn" json:"txn"`
	XXX_unrecognized []byte      `json:"-"`
}

func (m *TransactionRetryError) Reset()         { *m = TransactionRetryError{} }
func (m *TransactionRetryError) String() string { return proto1.CompactTextString(m) }
func (*TransactionRetryError) ProtoMessage()    {}

func (m *TransactionRetryError) GetTxn() Transaction {
	if m != nil {
		return m.Txn
	}
	return Transaction{}
}

// A TransactionStatusError indicates that the transaction status is
// incompatible with the requested operation. This might mean the
// transaction has already been committed. It might also be the case
// that the request to modify the transaction failed due to a
// regression in transaction epoch or timestamp, both of which may
// only monotonically increase.
type TransactionStatusError struct {
	Txn              Transaction `protobuf:"bytes,1,opt,name=txn" json:"txn"`
	Msg              string      `protobuf:"bytes,2,opt,name=msg" json:"msg"`
	XXX_unrecognized []byte      `json:"-"`
}

func (m *TransactionStatusError) Reset()         { *m = TransactionStatusError{} }
func (m *TransactionStatusError) String() string { return proto1.CompactTextString(m) }
func (*TransactionStatusError) ProtoMessage()    {}

func (m *TransactionStatusError) GetTxn() Transaction {
	if m != nil {
		return m.Txn
	}
	return Transaction{}
}

func (m *TransactionStatusError) GetMsg() string {
	if m != nil {
		return m.Msg
	}
	return ""
}

// A WriteIntentError indicates that a write intent belonging to
// another transaction was encountered leading to a read/write or
// write/write conflict. The Key at which the intent was encountered
// is set, as is the Txn record for the intent's transaction.
// Resolved is set if the intent was successfully resolved, meaning
// the client may retry the operation immediately. If Resolved is
// false, the client should back off and retry.
type WriteIntentError struct {
	Key              Key         `protobuf:"bytes,1,opt,name=key,customtype=Key" json:"key"`
	Txn              Transaction `protobuf:"bytes,2,opt,name=txn" json:"txn"`
	Resolved         bool        `protobuf:"varint,3,opt,name=resolved" json:"resolved"`
	XXX_unrecognized []byte      `json:"-"`
}

func (m *WriteIntentError) Reset()         { *m = WriteIntentError{} }
func (m *WriteIntentError) String() string { return proto1.CompactTextString(m) }
func (*WriteIntentError) ProtoMessage()    {}

func (m *WriteIntentError) GetTxn() Transaction {
	if m != nil {
		return m.Txn
	}
	return Transaction{}
}

func (m *WriteIntentError) GetResolved() bool {
	if m != nil {
		return m.Resolved
	}
	return false
}

// A WriteTooOldError indicates that a write encountered a versioned
// value newer than its timestamp, making it impossible to rewrite
// history. The write should be retried at existing_timestamp+1.
type WriteTooOldError struct {
	Timestamp         Timestamp `protobuf:"bytes,1,opt,name=timestamp" json:"timestamp"`
	ExistingTimestamp Timestamp `protobuf:"bytes,2,opt,name=existing_timestamp" json:"existing_timestamp"`
	XXX_unrecognized  []byte    `json:"-"`
}

func (m *WriteTooOldError) Reset()         { *m = WriteTooOldError{} }
func (m *WriteTooOldError) String() string { return proto1.CompactTextString(m) }
func (*WriteTooOldError) ProtoMessage()    {}

func (m *WriteTooOldError) GetTimestamp() Timestamp {
	if m != nil {
		return m.Timestamp
	}
	return Timestamp{}
}

func (m *WriteTooOldError) GetExistingTimestamp() Timestamp {
	if m != nil {
		return m.ExistingTimestamp
	}
	return Timestamp{}
}

// An OpRequiresTxnError indicates that a command required to be
// carried out in a transactional context but was not.
// For example, a Scan which spans ranges requires a transaction.
// The operation should be retried inside of a transaction.
type OpRequiresTxnError struct {
	XXX_unrecognized []byte `json:"-"`
}

func (m *OpRequiresTxnError) Reset()         { *m = OpRequiresTxnError{} }
func (m *OpRequiresTxnError) String() string { return proto1.CompactTextString(m) }
func (*OpRequiresTxnError) ProtoMessage()    {}

// A ConditionFailedError indicates that the expected value
// of a ConditionalPutRequest was not found, either
// because it was missing or was not equal. The error will
// contain the actual value found.
type ConditionFailedError struct {
	ActualValue      *Value `protobuf:"bytes,1,opt,name=actual_value" json:"actual_value,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *ConditionFailedError) Reset()         { *m = ConditionFailedError{} }
func (m *ConditionFailedError) String() string { return proto1.CompactTextString(m) }
func (*ConditionFailedError) ProtoMessage()    {}

func (m *ConditionFailedError) GetActualValue() *Value {
	if m != nil {
		return m.ActualValue
	}
	return nil
}

// Error is a union type containing all available errors.
type Error struct {
	Generic                       *GenericError                       `protobuf:"bytes,1,opt,name=generic" json:"generic,omitempty"`
	NotLeader                     *NotLeaderError                     `protobuf:"bytes,2,opt,name=not_leader" json:"not_leader,omitempty"`
	RangeNotFound                 *RangeNotFoundError                 `protobuf:"bytes,3,opt,name=range_not_found" json:"range_not_found,omitempty"`
	RangeKeyMismatch              *RangeKeyMismatchError              `protobuf:"bytes,4,opt,name=range_key_mismatch" json:"range_key_mismatch,omitempty"`
	ReadWithinUncertaintyInterval *ReadWithinUncertaintyIntervalError `protobuf:"bytes,5,opt,name=read_within_uncertainty_interval" json:"read_within_uncertainty_interval,omitempty"`
	TransactionAborted            *TransactionAbortedError            `protobuf:"bytes,6,opt,name=transaction_aborted" json:"transaction_aborted,omitempty"`
	TransactionPush               *TransactionPushError               `protobuf:"bytes,7,opt,name=transaction_push" json:"transaction_push,omitempty"`
	TransactionRetry              *TransactionRetryError              `protobuf:"bytes,8,opt,name=transaction_retry" json:"transaction_retry,omitempty"`
	TransactionStatus             *TransactionStatusError             `protobuf:"bytes,9,opt,name=transaction_status" json:"transaction_status,omitempty"`
	WriteIntent                   *WriteIntentError                   `protobuf:"bytes,10,opt,name=write_intent" json:"write_intent,omitempty"`
	WriteTooOld                   *WriteTooOldError                   `protobuf:"bytes,11,opt,name=write_too_old" json:"write_too_old,omitempty"`
	OpRequiresTxn                 *OpRequiresTxnError                 `protobuf:"bytes,12,opt,name=op_requires_txn" json:"op_requires_txn,omitempty"`
	ConditionFailed               *ConditionFailedError               `protobuf:"bytes,13,opt,name=condition_failed" json:"condition_failed,omitempty"`
	XXX_unrecognized              []byte                              `json:"-"`
}

func (m *Error) Reset()         { *m = Error{} }
func (m *Error) String() string { return proto1.CompactTextString(m) }
func (*Error) ProtoMessage()    {}

func (m *Error) GetGeneric() *GenericError {
	if m != nil {
		return m.Generic
	}
	return nil
}

func (m *Error) GetNotLeader() *NotLeaderError {
	if m != nil {
		return m.NotLeader
	}
	return nil
}

func (m *Error) GetRangeNotFound() *RangeNotFoundError {
	if m != nil {
		return m.RangeNotFound
	}
	return nil
}

func (m *Error) GetRangeKeyMismatch() *RangeKeyMismatchError {
	if m != nil {
		return m.RangeKeyMismatch
	}
	return nil
}

func (m *Error) GetReadWithinUncertaintyInterval() *ReadWithinUncertaintyIntervalError {
	if m != nil {
		return m.ReadWithinUncertaintyInterval
	}
	return nil
}

func (m *Error) GetTransactionAborted() *TransactionAbortedError {
	if m != nil {
		return m.TransactionAborted
	}
	return nil
}

func (m *Error) GetTransactionPush() *TransactionPushError {
	if m != nil {
		return m.TransactionPush
	}
	return nil
}

func (m *Error) GetTransactionRetry() *TransactionRetryError {
	if m != nil {
		return m.TransactionRetry
	}
	return nil
}

func (m *Error) GetTransactionStatus() *TransactionStatusError {
	if m != nil {
		return m.TransactionStatus
	}
	return nil
}

func (m *Error) GetWriteIntent() *WriteIntentError {
	if m != nil {
		return m.WriteIntent
	}
	return nil
}

func (m *Error) GetWriteTooOld() *WriteTooOldError {
	if m != nil {
		return m.WriteTooOld
	}
	return nil
}

func (m *Error) GetOpRequiresTxn() *OpRequiresTxnError {
	if m != nil {
		return m.OpRequiresTxn
	}
	return nil
}

func (m *Error) GetConditionFailed() *ConditionFailedError {
	if m != nil {
		return m.ConditionFailed
	}
	return nil
}

func init() {
}
func (this *Error) GetValue() interface{} {
	if this.Generic != nil {
		return this.Generic
	}
	if this.NotLeader != nil {
		return this.NotLeader
	}
	if this.RangeNotFound != nil {
		return this.RangeNotFound
	}
	if this.RangeKeyMismatch != nil {
		return this.RangeKeyMismatch
	}
	if this.ReadWithinUncertaintyInterval != nil {
		return this.ReadWithinUncertaintyInterval
	}
	if this.TransactionAborted != nil {
		return this.TransactionAborted
	}
	if this.TransactionPush != nil {
		return this.TransactionPush
	}
	if this.TransactionRetry != nil {
		return this.TransactionRetry
	}
	if this.TransactionStatus != nil {
		return this.TransactionStatus
	}
	if this.WriteIntent != nil {
		return this.WriteIntent
	}
	if this.WriteTooOld != nil {
		return this.WriteTooOld
	}
	if this.OpRequiresTxn != nil {
		return this.OpRequiresTxn
	}
	if this.ConditionFailed != nil {
		return this.ConditionFailed
	}
	return nil
}

func (this *Error) SetValue(value interface{}) bool {
	switch vt := value.(type) {
	case *GenericError:
		this.Generic = vt
	case *NotLeaderError:
		this.NotLeader = vt
	case *RangeNotFoundError:
		this.RangeNotFound = vt
	case *RangeKeyMismatchError:
		this.RangeKeyMismatch = vt
	case *ReadWithinUncertaintyIntervalError:
		this.ReadWithinUncertaintyInterval = vt
	case *TransactionAbortedError:
		this.TransactionAborted = vt
	case *TransactionPushError:
		this.TransactionPush = vt
	case *TransactionRetryError:
		this.TransactionRetry = vt
	case *TransactionStatusError:
		this.TransactionStatus = vt
	case *WriteIntentError:
		this.WriteIntent = vt
	case *WriteTooOldError:
		this.WriteTooOld = vt
	case *OpRequiresTxnError:
		this.OpRequiresTxn = vt
	case *ConditionFailedError:
		this.ConditionFailed = vt
	default:
		return false
	}
	return true
}
