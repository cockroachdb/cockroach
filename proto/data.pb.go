// Code generated by protoc-gen-gogo.
// source: cockroach/proto/data.proto
// DO NOT EDIT!

package proto

import proto1 "github.com/gogo/protobuf/proto"
import math "math"

// discarding unused import gogoproto "gogoproto/gogo.pb"

import io "io"
import fmt "fmt"
import github_com_gogo_protobuf_proto "github.com/gogo/protobuf/proto"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto1.Marshal
var _ = math.Inf

// ReplicaChangeType is a parameter of ChangeReplicasTrigger.
type ReplicaChangeType int32

const (
	ADD_REPLICA    ReplicaChangeType = 0
	REMOVE_REPLICA ReplicaChangeType = 1
)

var ReplicaChangeType_name = map[int32]string{
	0: "ADD_REPLICA",
	1: "REMOVE_REPLICA",
}
var ReplicaChangeType_value = map[string]int32{
	"ADD_REPLICA":    0,
	"REMOVE_REPLICA": 1,
}

func (x ReplicaChangeType) Enum() *ReplicaChangeType {
	p := new(ReplicaChangeType)
	*p = x
	return p
}
func (x ReplicaChangeType) String() string {
	return proto1.EnumName(ReplicaChangeType_name, int32(x))
}
func (x *ReplicaChangeType) UnmarshalJSON(data []byte) error {
	value, err := proto1.UnmarshalJSONEnum(ReplicaChangeType_value, data, "ReplicaChangeType")
	if err != nil {
		return err
	}
	*x = ReplicaChangeType(value)
	return nil
}

// IsolationType TODO(jiajia) Needs documentation.
type IsolationType int32

const (
	// SERIALIZABLE TODO(jiajia) Needs documentation.
	SERIALIZABLE IsolationType = 0
	// SNAPSHOT TODO(jiajia) Needs documentation.
	SNAPSHOT IsolationType = 1
)

var IsolationType_name = map[int32]string{
	0: "SERIALIZABLE",
	1: "SNAPSHOT",
}
var IsolationType_value = map[string]int32{
	"SERIALIZABLE": 0,
	"SNAPSHOT":     1,
}

func (x IsolationType) Enum() *IsolationType {
	p := new(IsolationType)
	*p = x
	return p
}
func (x IsolationType) String() string {
	return proto1.EnumName(IsolationType_name, int32(x))
}
func (x *IsolationType) UnmarshalJSON(data []byte) error {
	value, err := proto1.UnmarshalJSONEnum(IsolationType_value, data, "IsolationType")
	if err != nil {
		return err
	}
	*x = IsolationType(value)
	return nil
}

// TransactionStatus specifies possible states for a transaction.
type TransactionStatus int32

const (
	// PENDING is the default state for a new transaction. Transactions
	// move from PENDING to one of COMMITTED or ABORTED. Mutations made
	// as part of a PENDING transactions are recorded as "intents" in
	// the underlying MVCC model.
	PENDING TransactionStatus = 0
	// COMMITTED is the state for a transaction which has been
	// committed. Mutations made as part of a transaction which is moved
	// into COMMITTED state become durable and visible to other
	// transactions, moving from "intents" to permanent versioned
	// values.
	COMMITTED TransactionStatus = 1
	// ABORTED is the state for a transaction which has been aborted.
	// Mutations made as part of a transaction which is moved into
	// ABORTED state are deleted and are never made visible to other
	// transactions.
	ABORTED TransactionStatus = 2
)

var TransactionStatus_name = map[int32]string{
	0: "PENDING",
	1: "COMMITTED",
	2: "ABORTED",
}
var TransactionStatus_value = map[string]int32{
	"PENDING":   0,
	"COMMITTED": 1,
	"ABORTED":   2,
}

func (x TransactionStatus) Enum() *TransactionStatus {
	p := new(TransactionStatus)
	*p = x
	return p
}
func (x TransactionStatus) String() string {
	return proto1.EnumName(TransactionStatus_name, int32(x))
}
func (x *TransactionStatus) UnmarshalJSON(data []byte) error {
	value, err := proto1.UnmarshalJSONEnum(TransactionStatus_value, data, "TransactionStatus")
	if err != nil {
		return err
	}
	*x = TransactionStatus(value)
	return nil
}

// Timestamp represents a state of the hybrid logical clock.
type Timestamp struct {
	// Holds a wall time, typically a unix epoch time
	// expressed in nanoseconds.
	WallTime int64 `protobuf:"varint,1,opt,name=wall_time" json:"wall_time"`
	// The logical component captures causality for events whose wall
	// times are equal. It is effectively bounded by (maximum clock
	// skew)/(minimal ns between events) and nearly impossible to
	// overflow.
	Logical          int32  `protobuf:"varint,2,opt,name=logical" json:"logical"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *Timestamp) Reset()      { *m = Timestamp{} }
func (*Timestamp) ProtoMessage() {}

func (m *Timestamp) GetWallTime() int64 {
	if m != nil {
		return m.WallTime
	}
	return 0
}

func (m *Timestamp) GetLogical() int32 {
	if m != nil {
		return m.Logical
	}
	return 0
}

// Value specifies the value at a key. Multiple values at the same key
// are supported based on timestamp. Values support the union of two
// basic types: a "bag o' bytes" generic byte slice and an incrementable
// int64, for use with the Increment API call.
type Value struct {
	// Bytes is the byte slice value. If this field is set, the integer field
	// should not be.
	Bytes []byte `protobuf:"bytes,1,opt,name=bytes" json:"bytes,omitempty"`
	// Integer is an integer value type. If this field is set, the bytes field
	// should not be. Only Integer values may exist at a key when making the
	// Increment API call.
	Integer *int64 `protobuf:"varint,2,opt,name=integer" json:"integer,omitempty"`
	// Checksum is a CRC-32-IEEE checksum of the key + value, in that order.
	// If this is an integer value, then the value is interpreted as an 8
	// byte, big-endian encoded value. This value is set by the client on
	// writes to do end-to-end integrity verification. If the checksum is
	// incorrect, the write operation will fail. If the client does not
	// wish to use end-to-end checksumming, this value should be nil.
	Checksum *uint32 `protobuf:"fixed32,3,opt,name=checksum" json:"checksum,omitempty"`
	// Timestamp of value.
	Timestamp *Timestamp `protobuf:"bytes,4,opt,name=timestamp" json:"timestamp,omitempty"`
	// Tag is an optional string value which can be used to add additional
	// metadata to this value. For example, Tag might provide information on how
	// the bytes in the "bytes" field should be interpreted.
	Tag              *string `protobuf:"bytes,5,opt,name=tag" json:"tag,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *Value) Reset()         { *m = Value{} }
func (m *Value) String() string { return proto1.CompactTextString(m) }
func (*Value) ProtoMessage()    {}

func (m *Value) GetBytes() []byte {
	if m != nil {
		return m.Bytes
	}
	return nil
}

func (m *Value) GetInteger() int64 {
	if m != nil && m.Integer != nil {
		return *m.Integer
	}
	return 0
}

func (m *Value) GetChecksum() uint32 {
	if m != nil && m.Checksum != nil {
		return *m.Checksum
	}
	return 0
}

func (m *Value) GetTimestamp() *Timestamp {
	if m != nil {
		return m.Timestamp
	}
	return nil
}

func (m *Value) GetTag() string {
	if m != nil && m.Tag != nil {
		return *m.Tag
	}
	return ""
}

// MVCCValue differentiates between normal versioned values and
// deletion tombstones.
type MVCCValue struct {
	// True to indicate a deletion tombstone. If false, value should not
	// be nil.
	Deleted bool `protobuf:"varint,1,opt,name=deleted" json:"deleted"`
	// The value. Nil if deleted is true; not nil otherwise.
	Value            *Value `protobuf:"bytes,2,opt,name=value" json:"value,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *MVCCValue) Reset()         { *m = MVCCValue{} }
func (m *MVCCValue) String() string { return proto1.CompactTextString(m) }
func (*MVCCValue) ProtoMessage()    {}

func (m *MVCCValue) GetDeleted() bool {
	if m != nil {
		return m.Deleted
	}
	return false
}

func (m *MVCCValue) GetValue() *Value {
	if m != nil {
		return m.Value
	}
	return nil
}

// KeyValue is a pair of Key and Value for returned Key/Value pairs
// from ScanRequest/ScanResponse. It embeds a Key and a Value.
type KeyValue struct {
	Key              Key    `protobuf:"bytes,1,opt,name=key,customtype=Key" json:"key"`
	Value            Value  `protobuf:"bytes,2,opt,name=value" json:"value"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *KeyValue) Reset()         { *m = KeyValue{} }
func (m *KeyValue) String() string { return proto1.CompactTextString(m) }
func (*KeyValue) ProtoMessage()    {}

func (m *KeyValue) GetValue() Value {
	if m != nil {
		return m.Value
	}
	return Value{}
}

// RawKeyValue contains the raw bytes of the value for a key.
type RawKeyValue struct {
	Key              EncodedKey `protobuf:"bytes,1,opt,name=key,customtype=EncodedKey" json:"key"`
	Value            []byte     `protobuf:"bytes,2,opt,name=value" json:"value"`
	XXX_unrecognized []byte     `json:"-"`
}

func (m *RawKeyValue) Reset()         { *m = RawKeyValue{} }
func (m *RawKeyValue) String() string { return proto1.CompactTextString(m) }
func (*RawKeyValue) ProtoMessage()    {}

func (m *RawKeyValue) GetValue() []byte {
	if m != nil {
		return m.Value
	}
	return nil
}

// A StoreIdent uniquely identifies a store in the cluster. The
// StoreIdent is written to the underlying storage engine at a
// store-reserved system key (KeyLocalIdent).
type StoreIdent struct {
	ClusterID        string  `protobuf:"bytes,1,opt,name=cluster_id" json:"cluster_id"`
	NodeID           NodeID  `protobuf:"varint,2,opt,name=node_id,customtype=NodeID" json:"node_id"`
	StoreID          StoreID `protobuf:"varint,3,opt,name=store_id,customtype=StoreID" json:"store_id"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *StoreIdent) Reset()         { *m = StoreIdent{} }
func (m *StoreIdent) String() string { return proto1.CompactTextString(m) }
func (*StoreIdent) ProtoMessage()    {}

func (m *StoreIdent) GetClusterID() string {
	if m != nil {
		return m.ClusterID
	}
	return ""
}

// A SplitTrigger is run after a successful commit of an AdminSplit
// command. It provides the updated range descriptor covering the
// first half of the split and the new range descriptor covering the
// second half. This information allows the final bookkeeping for
// the split to be completed and the new range put into operation.
type SplitTrigger struct {
	UpdatedDesc      RangeDescriptor `protobuf:"bytes,1,opt,name=updated_desc" json:"updated_desc"`
	NewDesc          RangeDescriptor `protobuf:"bytes,2,opt,name=new_desc" json:"new_desc"`
	XXX_unrecognized []byte          `json:"-"`
}

func (m *SplitTrigger) Reset()         { *m = SplitTrigger{} }
func (m *SplitTrigger) String() string { return proto1.CompactTextString(m) }
func (*SplitTrigger) ProtoMessage()    {}

func (m *SplitTrigger) GetUpdatedDesc() RangeDescriptor {
	if m != nil {
		return m.UpdatedDesc
	}
	return RangeDescriptor{}
}

func (m *SplitTrigger) GetNewDesc() RangeDescriptor {
	if m != nil {
		return m.NewDesc
	}
	return RangeDescriptor{}
}

// A MergeTrigger is run after a successful commit of an AdminMerge
// command. It provides the updated range descriptor that now encompasses
// what was originally both ranges. This information allows the final bookkeeping
// for the merge to be completed and put into operation.
type MergeTrigger struct {
	UpdatedDesc      RangeDescriptor `protobuf:"bytes,1,opt,name=updated_desc" json:"updated_desc"`
	SubsumedRaftID   int64           `protobuf:"varint,2,opt,name=subsumed_raft_id" json:"subsumed_raft_id"`
	XXX_unrecognized []byte          `json:"-"`
}

func (m *MergeTrigger) Reset()         { *m = MergeTrigger{} }
func (m *MergeTrigger) String() string { return proto1.CompactTextString(m) }
func (*MergeTrigger) ProtoMessage()    {}

func (m *MergeTrigger) GetUpdatedDesc() RangeDescriptor {
	if m != nil {
		return m.UpdatedDesc
	}
	return RangeDescriptor{}
}

func (m *MergeTrigger) GetSubsumedRaftID() int64 {
	if m != nil {
		return m.SubsumedRaftID
	}
	return 0
}

type ChangeReplicasTrigger struct {
	NodeID     NodeID            `protobuf:"varint,1,opt,name=node_id,customtype=NodeID" json:"node_id"`
	StoreID    StoreID           `protobuf:"varint,2,opt,name=store_id,customtype=StoreID" json:"store_id"`
	ChangeType ReplicaChangeType `protobuf:"varint,3,opt,name=change_type,enum=cockroach.proto.ReplicaChangeType" json:"change_type"`
	// The new replica list with this change applied.
	UpdatedReplicas  []Replica `protobuf:"bytes,4,rep,name=updated_replicas" json:"updated_replicas"`
	XXX_unrecognized []byte    `json:"-"`
}

func (m *ChangeReplicasTrigger) Reset()         { *m = ChangeReplicasTrigger{} }
func (m *ChangeReplicasTrigger) String() string { return proto1.CompactTextString(m) }
func (*ChangeReplicasTrigger) ProtoMessage()    {}

func (m *ChangeReplicasTrigger) GetChangeType() ReplicaChangeType {
	if m != nil {
		return m.ChangeType
	}
	return ADD_REPLICA
}

func (m *ChangeReplicasTrigger) GetUpdatedReplicas() []Replica {
	if m != nil {
		return m.UpdatedReplicas
	}
	return nil
}

// CommitTrigger encapsulates all of the internal-only commit triggers.
type InternalCommitTrigger struct {
	SplitTrigger          *SplitTrigger          `protobuf:"bytes,1,opt,name=split_trigger" json:"split_trigger,omitempty"`
	MergeTrigger          *MergeTrigger          `protobuf:"bytes,2,opt,name=merge_trigger" json:"merge_trigger,omitempty"`
	ChangeReplicasTrigger *ChangeReplicasTrigger `protobuf:"bytes,3,opt,name=change_replicas_trigger" json:"change_replicas_trigger,omitempty"`
	// List of intents to resolve on commit or abort. Note that keys
	// listed here will only be resolved if they fall on the same range
	// that the transaction was started on.
	Intents          []Key  `protobuf:"bytes,4,rep,name=intents,customtype=Key" json:"intents,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *InternalCommitTrigger) Reset()         { *m = InternalCommitTrigger{} }
func (m *InternalCommitTrigger) String() string { return proto1.CompactTextString(m) }
func (*InternalCommitTrigger) ProtoMessage()    {}

func (m *InternalCommitTrigger) GetSplitTrigger() *SplitTrigger {
	if m != nil {
		return m.SplitTrigger
	}
	return nil
}

func (m *InternalCommitTrigger) GetMergeTrigger() *MergeTrigger {
	if m != nil {
		return m.MergeTrigger
	}
	return nil
}

func (m *InternalCommitTrigger) GetChangeReplicasTrigger() *ChangeReplicasTrigger {
	if m != nil {
		return m.ChangeReplicasTrigger
	}
	return nil
}

// NodeList keeps a growing set of NodeIDs as a sorted slice, with Add()
// adding to the set and Contains() verifying membership.
type NodeList struct {
	// Note that this does not use the NodeID custom type because that appears
	// to interact badly with the repeated and/or packed options.
	Nodes            []int32 `protobuf:"varint,1,rep,packed,name=nodes" json:"nodes,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *NodeList) Reset()         { *m = NodeList{} }
func (m *NodeList) String() string { return proto1.CompactTextString(m) }
func (*NodeList) ProtoMessage()    {}

func (m *NodeList) GetNodes() []int32 {
	if m != nil {
		return m.Nodes
	}
	return nil
}

// A Transaction is a unit of work performed on the database.
// Cockroach transactions support two isolation levels: snapshot
// isolation and serializable snapshot isolation. Each Cockroach
// transaction is assigned a random priority. This priority will be
// used to decide whether a transaction will be aborted during
// contention.
type Transaction struct {
	Name string `protobuf:"bytes,1,opt,name=name" json:"name"`
	// Key is the key which anchors the transaction. This is typically
	// the first key read or written during the transaction and
	// determines which range in the cluster will hold the transaction
	// record.
	Key Key `protobuf:"bytes,2,opt,name=key,customtype=Key" json:"key"`
	// ID is a unique UUID value which identifies the transaction.
	ID        []byte            `protobuf:"bytes,3,opt,name=id" json:"id"`
	Priority  int32             `protobuf:"varint,4,opt,name=priority" json:"priority"`
	Isolation IsolationType     `protobuf:"varint,5,opt,name=isolation,enum=cockroach.proto.IsolationType" json:"isolation"`
	Status    TransactionStatus `protobuf:"varint,6,opt,name=status,enum=cockroach.proto.TransactionStatus" json:"status"`
	// Incremented on txn retry.
	Epoch int32 `protobuf:"varint,7,opt,name=epoch" json:"epoch"`
	// The last heartbeat timestamp.
	LastHeartbeat *Timestamp `protobuf:"bytes,8,opt,name=last_heartbeat" json:"last_heartbeat,omitempty"`
	// The proposed timestamp for the transaction. This starts as
	// the current wall time on the txn coordinator.
	Timestamp Timestamp `protobuf:"bytes,9,opt,name=timestamp" json:"timestamp"`
	// The original timestamp at which the transaction started. For serializable
	// transactions, if the timestamp drifts from the original timestamp, the
	// transaction will retry.
	OrigTimestamp Timestamp `protobuf:"bytes,10,opt,name=orig_timestamp" json:"orig_timestamp"`
	// Initial Timestamp + clock skew. Reads which encounter values with
	// timestamps between Timestamp and MaxTimestamp trigger a txn
	// retry error, unless the node being read is listed in certain_nodes
	// (in which case no more read uncertainty can occur).
	// The case MaxTimestamp < Timestamp is possible for transactions which have
	// been pushed; in this case, MaxTimestamp should be ignored.
	MaxTimestamp Timestamp `protobuf:"bytes,11,opt,name=max_timestamp" json:"max_timestamp"`
	// A sorted list of ids of nodes for which a ReadWithinUncertaintyIntervalError
	// occurred during a prior read. The purpose of keeping this information is
	// that as a reaction to this error, the transaction's timestamp is forwarded
	// appropriately to reflect that node's clock uncertainty. Future reads to
	// the same node are therefore freed from uncertainty restarts.
	//
	// The exact mechanism is that upon encountering the above error, the trans-
	// action will have to retry with a higher timestamp. This higher timestamp
	// is either the one of the encountered future write returned in the error
	// or (if higher, which is in the majority of cases), the time of the node
	// serving the key at the time of the failed read.
	// Additionally storing the node, we make sure to set MaxTimestamp=Timestamp
	// at the time of the read for nodes whose clock we've taken into acount,
	// which amounts to reading without any uncertainty.
	//
	// Bits of this mechanism are found in the local sender, the range and the
	// txn_coord_sender, with brief comments referring here.
	// See https://github.com/cockroachdb/cockroach/pull/221.
	CertainNodes     NodeList `protobuf:"bytes,12,opt,name=certain_nodes" json:"certain_nodes"`
	XXX_unrecognized []byte   `json:"-"`
}

func (m *Transaction) Reset()      { *m = Transaction{} }
func (*Transaction) ProtoMessage() {}

func (m *Transaction) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Transaction) GetID() []byte {
	if m != nil {
		return m.ID
	}
	return nil
}

func (m *Transaction) GetPriority() int32 {
	if m != nil {
		return m.Priority
	}
	return 0
}

func (m *Transaction) GetIsolation() IsolationType {
	if m != nil {
		return m.Isolation
	}
	return SERIALIZABLE
}

func (m *Transaction) GetStatus() TransactionStatus {
	if m != nil {
		return m.Status
	}
	return PENDING
}

func (m *Transaction) GetEpoch() int32 {
	if m != nil {
		return m.Epoch
	}
	return 0
}

func (m *Transaction) GetLastHeartbeat() *Timestamp {
	if m != nil {
		return m.LastHeartbeat
	}
	return nil
}

func (m *Transaction) GetTimestamp() Timestamp {
	if m != nil {
		return m.Timestamp
	}
	return Timestamp{}
}

func (m *Transaction) GetOrigTimestamp() Timestamp {
	if m != nil {
		return m.OrigTimestamp
	}
	return Timestamp{}
}

func (m *Transaction) GetMaxTimestamp() Timestamp {
	if m != nil {
		return m.MaxTimestamp
	}
	return Timestamp{}
}

func (m *Transaction) GetCertainNodes() NodeList {
	if m != nil {
		return m.CertainNodes
	}
	return NodeList{}
}

// Lease contains information about leader leases including the
// expiration and lease holder.
type Lease struct {
	// The expiration is a unix nanos timestamp and is set when requesting the
	// lease according to the wall clock plus the Duration below at the lease
	// requestor / grantee, which is also the only node that uses it directly.
	// Granters must always substitute their local walltime plus the Duration
	// below instead.
	Expiration int64 `protobuf:"varint,1,opt,name=expiration" json:"expiration"`
	// The duration, specified in nanoseconds, is the duration for which lease
	// granters guarantee not to participate in elections, beginning right after
	// the command has been accepted.
	Duration int64 `protobuf:"varint,2,opt,name=duration" json:"duration"`
	// The leadership term for this lease.
	Term uint64 `protobuf:"varint,3,opt,name=term" json:"term"`
	// The Raft NodeID on which the would-be lease holder lives.
	RaftNodeID       uint64 `protobuf:"varint,4,opt,name=raft_node_id" json:"raft_node_id"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *Lease) Reset()         { *m = Lease{} }
func (m *Lease) String() string { return proto1.CompactTextString(m) }
func (*Lease) ProtoMessage()    {}

func (m *Lease) GetExpiration() int64 {
	if m != nil {
		return m.Expiration
	}
	return 0
}

func (m *Lease) GetDuration() int64 {
	if m != nil {
		return m.Duration
	}
	return 0
}

func (m *Lease) GetTerm() uint64 {
	if m != nil {
		return m.Term
	}
	return 0
}

func (m *Lease) GetRaftNodeID() uint64 {
	if m != nil {
		return m.RaftNodeID
	}
	return 0
}

// MVCCMetadata holds MVCC metadata for a key. Used by storage/engine/mvcc.go.
type MVCCMetadata struct {
	Txn *Transaction `protobuf:"bytes,1,opt,name=txn" json:"txn,omitempty"`
	// The timestamp of the most recent versioned value.
	Timestamp Timestamp `protobuf:"bytes,2,opt,name=timestamp" json:"timestamp"`
	// Is the most recent value a deletion tombstone?
	Deleted bool `protobuf:"varint,3,opt,name=deleted" json:"deleted"`
	// The size in bytes of the most recent encoded key.
	KeyBytes int64 `protobuf:"varint,4,opt,name=key_bytes" json:"key_bytes"`
	// The size in bytes of the most recent versioned value.
	ValBytes int64 `protobuf:"varint,5,opt,name=val_bytes" json:"val_bytes"`
	// Inline value, used for values with zero timestamp. This provides
	// an efficient short circuit of the normal MVCC metadata sentinel
	// and subsequent version rows. If timestamp == (0, 0), then there
	// is only a single MVCC metadata row with value inlined, and with
	// empty timestamp, key_bytes, and val_bytes.
	Value *Value `protobuf:"bytes,6,opt,name=value" json:"value,omitempty"`
	// The timestamp of the most recent evicted version of the key.
	LastEvicted      Timestamp `protobuf:"bytes,7,opt,name=last_evicted" json:"last_evicted"`
	XXX_unrecognized []byte    `json:"-"`
}

func (m *MVCCMetadata) Reset()         { *m = MVCCMetadata{} }
func (m *MVCCMetadata) String() string { return proto1.CompactTextString(m) }
func (*MVCCMetadata) ProtoMessage()    {}

func (m *MVCCMetadata) GetTxn() *Transaction {
	if m != nil {
		return m.Txn
	}
	return nil
}

func (m *MVCCMetadata) GetTimestamp() Timestamp {
	if m != nil {
		return m.Timestamp
	}
	return Timestamp{}
}

func (m *MVCCMetadata) GetDeleted() bool {
	if m != nil {
		return m.Deleted
	}
	return false
}

func (m *MVCCMetadata) GetKeyBytes() int64 {
	if m != nil {
		return m.KeyBytes
	}
	return 0
}

func (m *MVCCMetadata) GetValBytes() int64 {
	if m != nil {
		return m.ValBytes
	}
	return 0
}

func (m *MVCCMetadata) GetValue() *Value {
	if m != nil {
		return m.Value
	}
	return nil
}

func (m *MVCCMetadata) GetLastEvicted() Timestamp {
	if m != nil {
		return m.LastEvicted
	}
	return Timestamp{}
}

// GCMetadata holds information about the last complete key/value
// garbage collection scan of a range.
type GCMetadata struct {
	// The last GC scan timestamp in nanoseconds since the Unix epoch.
	LastScanNanos int64 `protobuf:"varint,1,opt,name=last_scan_nanos" json:"last_scan_nanos"`
	// The oldest unresolved write intent in nanoseconds since epoch.
	// Null if there are no unresolved write intents.
	OldestIntentNanos *int64 `protobuf:"varint,2,opt,name=oldest_intent_nanos" json:"oldest_intent_nanos,omitempty"`
	XXX_unrecognized  []byte `json:"-"`
}

func (m *GCMetadata) Reset()         { *m = GCMetadata{} }
func (m *GCMetadata) String() string { return proto1.CompactTextString(m) }
func (*GCMetadata) ProtoMessage()    {}

func (m *GCMetadata) GetLastScanNanos() int64 {
	if m != nil {
		return m.LastScanNanos
	}
	return 0
}

func (m *GCMetadata) GetOldestIntentNanos() int64 {
	if m != nil && m.OldestIntentNanos != nil {
		return *m.OldestIntentNanos
	}
	return 0
}

// TimeSeriesDatapoint is a single point of time series data; a value associated
// with a timestamp.
type TimeSeriesDatapoint struct {
	// The timestamp when this datapoint is located, expressed in nanoseconds
	// since the unix epoch.
	TimestampNanos int64 `protobuf:"varint,1,opt,name=timestamp_nanos" json:"timestamp_nanos"`
	// An integer representation of the value of this datapoint. If this field
	// is set, then 'float_value' must not be set.
	IntValue *int64 `protobuf:"varint,2,opt,name=int_value" json:"int_value,omitempty"`
	// A floating point representation of the value of this datapoint. If this
	// field is set, then 'int_value' must not be set.
	FloatValue       *float32 `protobuf:"fixed32,3,opt,name=float_value" json:"float_value,omitempty"`
	XXX_unrecognized []byte   `json:"-"`
}

func (m *TimeSeriesDatapoint) Reset()         { *m = TimeSeriesDatapoint{} }
func (m *TimeSeriesDatapoint) String() string { return proto1.CompactTextString(m) }
func (*TimeSeriesDatapoint) ProtoMessage()    {}

func (m *TimeSeriesDatapoint) GetTimestampNanos() int64 {
	if m != nil {
		return m.TimestampNanos
	}
	return 0
}

func (m *TimeSeriesDatapoint) GetIntValue() int64 {
	if m != nil && m.IntValue != nil {
		return *m.IntValue
	}
	return 0
}

func (m *TimeSeriesDatapoint) GetFloatValue() float32 {
	if m != nil && m.FloatValue != nil {
		return *m.FloatValue
	}
	return 0
}

// TimeSeriesData is a set of observations of a single variable value at
// multiple points in time. This message contains a name and a source which, in
// combination, uniquely identify the series being measured. The message also
// contains a repeated set of TimeSeriesDatapoint messages representing distinct
// measurements of the variable.
type TimeSeriesData struct {
	// A string which uniquely identifies the variable from which this data was
	// measured.
	Name string `protobuf:"bytes,1,opt,name=name" json:"name"`
	// A string which identifies the unique source from which the variable was measured.
	Source string `protobuf:"bytes,2,opt,name=source" json:"source"`
	// Datapoints representing one or more measurements taken from the variable.
	Datapoints       []*TimeSeriesDatapoint `protobuf:"bytes,3,rep,name=datapoints" json:"datapoints,omitempty"`
	XXX_unrecognized []byte                 `json:"-"`
}

func (m *TimeSeriesData) Reset()         { *m = TimeSeriesData{} }
func (m *TimeSeriesData) String() string { return proto1.CompactTextString(m) }
func (*TimeSeriesData) ProtoMessage()    {}

func (m *TimeSeriesData) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *TimeSeriesData) GetSource() string {
	if m != nil {
		return m.Source
	}
	return ""
}

func (m *TimeSeriesData) GetDatapoints() []*TimeSeriesDatapoint {
	if m != nil {
		return m.Datapoints
	}
	return nil
}

// MVCCStats tracks byte and instance counts for:
//  - Live key/values (i.e. what a scan at current time will reveal;
//    note that this includes intent keys and values, but not keys and
//    values with most recent value deleted)
//  - Key bytes (includes all keys, even those with most recent value deleted)
//  - Value bytes (includes all versions)
//  - Key count (count of all keys, including keys with deleted tombstones)
//  - Value count (all versions, including deleted tombstones)
//  - Intents (provisional values written during txns)
type MVCCStats struct {
	LiveBytes        int64  `protobuf:"varint,1,opt,name=live_bytes" json:"live_bytes"`
	KeyBytes         int64  `protobuf:"varint,2,opt,name=key_bytes" json:"key_bytes"`
	ValBytes         int64  `protobuf:"varint,3,opt,name=val_bytes" json:"val_bytes"`
	IntentBytes      int64  `protobuf:"varint,4,opt,name=intent_bytes" json:"intent_bytes"`
	LiveCount        int64  `protobuf:"varint,5,opt,name=live_count" json:"live_count"`
	KeyCount         int64  `protobuf:"varint,6,opt,name=key_count" json:"key_count"`
	ValCount         int64  `protobuf:"varint,7,opt,name=val_count" json:"val_count"`
	IntentCount      int64  `protobuf:"varint,8,opt,name=intent_count" json:"intent_count"`
	IntentAge        int64  `protobuf:"varint,9,opt,name=intent_age" json:"intent_age"`
	GCBytesAge       int64  `protobuf:"varint,10,opt,name=gc_bytes_age" json:"gc_bytes_age"`
	LastUpdateNanos  int64  `protobuf:"varint,11,opt,name=last_update_nanos" json:"last_update_nanos"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *MVCCStats) Reset()         { *m = MVCCStats{} }
func (m *MVCCStats) String() string { return proto1.CompactTextString(m) }
func (*MVCCStats) ProtoMessage()    {}

func (m *MVCCStats) GetLiveBytes() int64 {
	if m != nil {
		return m.LiveBytes
	}
	return 0
}

func (m *MVCCStats) GetKeyBytes() int64 {
	if m != nil {
		return m.KeyBytes
	}
	return 0
}

func (m *MVCCStats) GetValBytes() int64 {
	if m != nil {
		return m.ValBytes
	}
	return 0
}

func (m *MVCCStats) GetIntentBytes() int64 {
	if m != nil {
		return m.IntentBytes
	}
	return 0
}

func (m *MVCCStats) GetLiveCount() int64 {
	if m != nil {
		return m.LiveCount
	}
	return 0
}

func (m *MVCCStats) GetKeyCount() int64 {
	if m != nil {
		return m.KeyCount
	}
	return 0
}

func (m *MVCCStats) GetValCount() int64 {
	if m != nil {
		return m.ValCount
	}
	return 0
}

func (m *MVCCStats) GetIntentCount() int64 {
	if m != nil {
		return m.IntentCount
	}
	return 0
}

func (m *MVCCStats) GetIntentAge() int64 {
	if m != nil {
		return m.IntentAge
	}
	return 0
}

func (m *MVCCStats) GetGCBytesAge() int64 {
	if m != nil {
		return m.GCBytesAge
	}
	return 0
}

func (m *MVCCStats) GetLastUpdateNanos() int64 {
	if m != nil {
		return m.LastUpdateNanos
	}
	return 0
}

func init() {
	proto1.RegisterEnum("cockroach.proto.ReplicaChangeType", ReplicaChangeType_name, ReplicaChangeType_value)
	proto1.RegisterEnum("cockroach.proto.IsolationType", IsolationType_name, IsolationType_value)
	proto1.RegisterEnum("cockroach.proto.TransactionStatus", TransactionStatus_name, TransactionStatus_value)
}
func (m *Timestamp) Unmarshal(data []byte) error {
	l := len(data)
	index := 0
	for index < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if index >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[index]
			index++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WallTime", wireType)
			}
			for shift := uint(0); ; shift += 7 {
				if index >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[index]
				index++
				m.WallTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Logical", wireType)
			}
			for shift := uint(0); ; shift += 7 {
				if index >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[index]
				index++
				m.Logical |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			var sizeOfWire int
			for {
				sizeOfWire++
				wire >>= 7
				if wire == 0 {
					break
				}
			}
			index -= sizeOfWire
			skippy, err := github_com_gogo_protobuf_proto.Skip(data[index:])
			if err != nil {
				return err
			}
			if (index + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, data[index:index+skippy]...)
			index += skippy
		}
	}
	return nil
}
func (m *Value) Unmarshal(data []byte) error {
	l := len(data)
	index := 0
	for index < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if index >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[index]
			index++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bytes", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if index >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[index]
				index++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := index + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Bytes = append([]byte{}, data[index:postIndex]...)
			index = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Integer", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if index >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[index]
				index++
				v |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Integer = &v
		case 3:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Checksum", wireType)
			}
			var v uint32
			i := index + 4
			if i > l {
				return io.ErrUnexpectedEOF
			}
			index = i
			v = uint32(data[i-4])
			v |= uint32(data[i-3]) << 8
			v |= uint32(data[i-2]) << 16
			v |= uint32(data[i-1]) << 24
			m.Checksum = &v
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if index >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[index]
				index++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := index + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Timestamp == nil {
				m.Timestamp = &Timestamp{}
			}
			if err := m.Timestamp.Unmarshal(data[index:postIndex]); err != nil {
				return err
			}
			index = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tag", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if index >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[index]
				index++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := index + int(stringLen)
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(data[index:postIndex])
			m.Tag = &s
			index = postIndex
		default:
			var sizeOfWire int
			for {
				sizeOfWire++
				wire >>= 7
				if wire == 0 {
					break
				}
			}
			index -= sizeOfWire
			skippy, err := github_com_gogo_protobuf_proto.Skip(data[index:])
			if err != nil {
				return err
			}
			if (index + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, data[index:index+skippy]...)
			index += skippy
		}
	}
	return nil
}
func (m *MVCCValue) Unmarshal(data []byte) error {
	l := len(data)
	index := 0
	for index < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if index >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[index]
			index++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Deleted", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if index >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[index]
				index++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Deleted = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if index >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[index]
				index++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := index + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Value == nil {
				m.Value = &Value{}
			}
			if err := m.Value.Unmarshal(data[index:postIndex]); err != nil {
				return err
			}
			index = postIndex
		default:
			var sizeOfWire int
			for {
				sizeOfWire++
				wire >>= 7
				if wire == 0 {
					break
				}
			}
			index -= sizeOfWire
			skippy, err := github_com_gogo_protobuf_proto.Skip(data[index:])
			if err != nil {
				return err
			}
			if (index + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, data[index:index+skippy]...)
			index += skippy
		}
	}
	return nil
}
func (m *KeyValue) Unmarshal(data []byte) error {
	l := len(data)
	index := 0
	for index < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if index >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[index]
			index++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if index >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[index]
				index++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := index + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Key.Unmarshal(data[index:postIndex]); err != nil {
				return err
			}
			index = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if index >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[index]
				index++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := index + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Value.Unmarshal(data[index:postIndex]); err != nil {
				return err
			}
			index = postIndex
		default:
			var sizeOfWire int
			for {
				sizeOfWire++
				wire >>= 7
				if wire == 0 {
					break
				}
			}
			index -= sizeOfWire
			skippy, err := github_com_gogo_protobuf_proto.Skip(data[index:])
			if err != nil {
				return err
			}
			if (index + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, data[index:index+skippy]...)
			index += skippy
		}
	}
	return nil
}
func (m *RawKeyValue) Unmarshal(data []byte) error {
	l := len(data)
	index := 0
	for index < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if index >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[index]
			index++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if index >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[index]
				index++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := index + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Key.Unmarshal(data[index:postIndex]); err != nil {
				return err
			}
			index = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if index >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[index]
				index++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := index + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = append([]byte{}, data[index:postIndex]...)
			index = postIndex
		default:
			var sizeOfWire int
			for {
				sizeOfWire++
				wire >>= 7
				if wire == 0 {
					break
				}
			}
			index -= sizeOfWire
			skippy, err := github_com_gogo_protobuf_proto.Skip(data[index:])
			if err != nil {
				return err
			}
			if (index + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, data[index:index+skippy]...)
			index += skippy
		}
	}
	return nil
}
func (m *StoreIdent) Unmarshal(data []byte) error {
	l := len(data)
	index := 0
	for index < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if index >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[index]
			index++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if index >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[index]
				index++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := index + int(stringLen)
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClusterID = string(data[index:postIndex])
			index = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeID", wireType)
			}
			for shift := uint(0); ; shift += 7 {
				if index >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[index]
				index++
				m.NodeID |= (NodeID(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StoreID", wireType)
			}
			for shift := uint(0); ; shift += 7 {
				if index >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[index]
				index++
				m.StoreID |= (StoreID(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			var sizeOfWire int
			for {
				sizeOfWire++
				wire >>= 7
				if wire == 0 {
					break
				}
			}
			index -= sizeOfWire
			skippy, err := github_com_gogo_protobuf_proto.Skip(data[index:])
			if err != nil {
				return err
			}
			if (index + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, data[index:index+skippy]...)
			index += skippy
		}
	}
	return nil
}
func (m *SplitTrigger) Unmarshal(data []byte) error {
	l := len(data)
	index := 0
	for index < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if index >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[index]
			index++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdatedDesc", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if index >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[index]
				index++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := index + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.UpdatedDesc.Unmarshal(data[index:postIndex]); err != nil {
				return err
			}
			index = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewDesc", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if index >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[index]
				index++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := index + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.NewDesc.Unmarshal(data[index:postIndex]); err != nil {
				return err
			}
			index = postIndex
		default:
			var sizeOfWire int
			for {
				sizeOfWire++
				wire >>= 7
				if wire == 0 {
					break
				}
			}
			index -= sizeOfWire
			skippy, err := github_com_gogo_protobuf_proto.Skip(data[index:])
			if err != nil {
				return err
			}
			if (index + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, data[index:index+skippy]...)
			index += skippy
		}
	}
	return nil
}
func (m *MergeTrigger) Unmarshal(data []byte) error {
	l := len(data)
	index := 0
	for index < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if index >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[index]
			index++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdatedDesc", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if index >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[index]
				index++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := index + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.UpdatedDesc.Unmarshal(data[index:postIndex]); err != nil {
				return err
			}
			index = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubsumedRaftID", wireType)
			}
			for shift := uint(0); ; shift += 7 {
				if index >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[index]
				index++
				m.SubsumedRaftID |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			var sizeOfWire int
			for {
				sizeOfWire++
				wire >>= 7
				if wire == 0 {
					break
				}
			}
			index -= sizeOfWire
			skippy, err := github_com_gogo_protobuf_proto.Skip(data[index:])
			if err != nil {
				return err
			}
			if (index + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, data[index:index+skippy]...)
			index += skippy
		}
	}
	return nil
}
func (m *ChangeReplicasTrigger) Unmarshal(data []byte) error {
	l := len(data)
	index := 0
	for index < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if index >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[index]
			index++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeID", wireType)
			}
			for shift := uint(0); ; shift += 7 {
				if index >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[index]
				index++
				m.NodeID |= (NodeID(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StoreID", wireType)
			}
			for shift := uint(0); ; shift += 7 {
				if index >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[index]
				index++
				m.StoreID |= (StoreID(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChangeType", wireType)
			}
			for shift := uint(0); ; shift += 7 {
				if index >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[index]
				index++
				m.ChangeType |= (ReplicaChangeType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdatedReplicas", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if index >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[index]
				index++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := index + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UpdatedReplicas = append(m.UpdatedReplicas, Replica{})
			m.UpdatedReplicas[len(m.UpdatedReplicas)-1].Unmarshal(data[index:postIndex])
			index = postIndex
		default:
			var sizeOfWire int
			for {
				sizeOfWire++
				wire >>= 7
				if wire == 0 {
					break
				}
			}
			index -= sizeOfWire
			skippy, err := github_com_gogo_protobuf_proto.Skip(data[index:])
			if err != nil {
				return err
			}
			if (index + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, data[index:index+skippy]...)
			index += skippy
		}
	}
	return nil
}
func (m *InternalCommitTrigger) Unmarshal(data []byte) error {
	l := len(data)
	index := 0
	for index < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if index >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[index]
			index++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SplitTrigger", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if index >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[index]
				index++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := index + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SplitTrigger == nil {
				m.SplitTrigger = &SplitTrigger{}
			}
			if err := m.SplitTrigger.Unmarshal(data[index:postIndex]); err != nil {
				return err
			}
			index = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MergeTrigger", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if index >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[index]
				index++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := index + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MergeTrigger == nil {
				m.MergeTrigger = &MergeTrigger{}
			}
			if err := m.MergeTrigger.Unmarshal(data[index:postIndex]); err != nil {
				return err
			}
			index = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChangeReplicasTrigger", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if index >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[index]
				index++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := index + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ChangeReplicasTrigger == nil {
				m.ChangeReplicasTrigger = &ChangeReplicasTrigger{}
			}
			if err := m.ChangeReplicasTrigger.Unmarshal(data[index:postIndex]); err != nil {
				return err
			}
			index = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Intents", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if index >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[index]
				index++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := index + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Intents = append(m.Intents, Key{})
			m.Intents[len(m.Intents)-1].Unmarshal(data[index:postIndex])
			index = postIndex
		default:
			var sizeOfWire int
			for {
				sizeOfWire++
				wire >>= 7
				if wire == 0 {
					break
				}
			}
			index -= sizeOfWire
			skippy, err := github_com_gogo_protobuf_proto.Skip(data[index:])
			if err != nil {
				return err
			}
			if (index + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, data[index:index+skippy]...)
			index += skippy
		}
	}
	return nil
}
func (m *NodeList) Unmarshal(data []byte) error {
	l := len(data)
	index := 0
	for index < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if index >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[index]
			index++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		switch fieldNum {
		case 1:
			if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if index >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[index]
					index++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				postIndex := index + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for index < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if index >= l {
							return io.ErrUnexpectedEOF
						}
						b := data[index]
						index++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Nodes = append(m.Nodes, v)
				}
			} else if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if index >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[index]
					index++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Nodes = append(m.Nodes, v)
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Nodes", wireType)
			}
		default:
			var sizeOfWire int
			for {
				sizeOfWire++
				wire >>= 7
				if wire == 0 {
					break
				}
			}
			index -= sizeOfWire
			skippy, err := github_com_gogo_protobuf_proto.Skip(data[index:])
			if err != nil {
				return err
			}
			if (index + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, data[index:index+skippy]...)
			index += skippy
		}
	}
	return nil
}
func (m *Transaction) Unmarshal(data []byte) error {
	l := len(data)
	index := 0
	for index < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if index >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[index]
			index++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if index >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[index]
				index++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := index + int(stringLen)
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(data[index:postIndex])
			index = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if index >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[index]
				index++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := index + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Key.Unmarshal(data[index:postIndex]); err != nil {
				return err
			}
			index = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if index >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[index]
				index++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := index + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ID = append([]byte{}, data[index:postIndex]...)
			index = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Priority", wireType)
			}
			for shift := uint(0); ; shift += 7 {
				if index >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[index]
				index++
				m.Priority |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Isolation", wireType)
			}
			for shift := uint(0); ; shift += 7 {
				if index >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[index]
				index++
				m.Isolation |= (IsolationType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			for shift := uint(0); ; shift += 7 {
				if index >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[index]
				index++
				m.Status |= (TransactionStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Epoch", wireType)
			}
			for shift := uint(0); ; shift += 7 {
				if index >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[index]
				index++
				m.Epoch |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastHeartbeat", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if index >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[index]
				index++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := index + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LastHeartbeat == nil {
				m.LastHeartbeat = &Timestamp{}
			}
			if err := m.LastHeartbeat.Unmarshal(data[index:postIndex]); err != nil {
				return err
			}
			index = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if index >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[index]
				index++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := index + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Timestamp.Unmarshal(data[index:postIndex]); err != nil {
				return err
			}
			index = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrigTimestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if index >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[index]
				index++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := index + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.OrigTimestamp.Unmarshal(data[index:postIndex]); err != nil {
				return err
			}
			index = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxTimestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if index >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[index]
				index++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := index + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MaxTimestamp.Unmarshal(data[index:postIndex]); err != nil {
				return err
			}
			index = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CertainNodes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if index >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[index]
				index++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := index + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.CertainNodes.Unmarshal(data[index:postIndex]); err != nil {
				return err
			}
			index = postIndex
		default:
			var sizeOfWire int
			for {
				sizeOfWire++
				wire >>= 7
				if wire == 0 {
					break
				}
			}
			index -= sizeOfWire
			skippy, err := github_com_gogo_protobuf_proto.Skip(data[index:])
			if err != nil {
				return err
			}
			if (index + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, data[index:index+skippy]...)
			index += skippy
		}
	}
	return nil
}
func (m *Lease) Unmarshal(data []byte) error {
	l := len(data)
	index := 0
	for index < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if index >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[index]
			index++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Expiration", wireType)
			}
			for shift := uint(0); ; shift += 7 {
				if index >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[index]
				index++
				m.Expiration |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Duration", wireType)
			}
			for shift := uint(0); ; shift += 7 {
				if index >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[index]
				index++
				m.Duration |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Term", wireType)
			}
			for shift := uint(0); ; shift += 7 {
				if index >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[index]
				index++
				m.Term |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RaftNodeID", wireType)
			}
			for shift := uint(0); ; shift += 7 {
				if index >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[index]
				index++
				m.RaftNodeID |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			var sizeOfWire int
			for {
				sizeOfWire++
				wire >>= 7
				if wire == 0 {
					break
				}
			}
			index -= sizeOfWire
			skippy, err := github_com_gogo_protobuf_proto.Skip(data[index:])
			if err != nil {
				return err
			}
			if (index + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, data[index:index+skippy]...)
			index += skippy
		}
	}
	return nil
}
func (m *MVCCMetadata) Unmarshal(data []byte) error {
	l := len(data)
	index := 0
	for index < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if index >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[index]
			index++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Txn", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if index >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[index]
				index++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := index + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Txn == nil {
				m.Txn = &Transaction{}
			}
			if err := m.Txn.Unmarshal(data[index:postIndex]); err != nil {
				return err
			}
			index = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if index >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[index]
				index++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := index + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Timestamp.Unmarshal(data[index:postIndex]); err != nil {
				return err
			}
			index = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Deleted", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if index >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[index]
				index++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Deleted = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyBytes", wireType)
			}
			for shift := uint(0); ; shift += 7 {
				if index >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[index]
				index++
				m.KeyBytes |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValBytes", wireType)
			}
			for shift := uint(0); ; shift += 7 {
				if index >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[index]
				index++
				m.ValBytes |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if index >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[index]
				index++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := index + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Value == nil {
				m.Value = &Value{}
			}
			if err := m.Value.Unmarshal(data[index:postIndex]); err != nil {
				return err
			}
			index = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastEvicted", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if index >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[index]
				index++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := index + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.LastEvicted.Unmarshal(data[index:postIndex]); err != nil {
				return err
			}
			index = postIndex
		default:
			var sizeOfWire int
			for {
				sizeOfWire++
				wire >>= 7
				if wire == 0 {
					break
				}
			}
			index -= sizeOfWire
			skippy, err := github_com_gogo_protobuf_proto.Skip(data[index:])
			if err != nil {
				return err
			}
			if (index + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, data[index:index+skippy]...)
			index += skippy
		}
	}
	return nil
}
func (m *GCMetadata) Unmarshal(data []byte) error {
	l := len(data)
	index := 0
	for index < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if index >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[index]
			index++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastScanNanos", wireType)
			}
			for shift := uint(0); ; shift += 7 {
				if index >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[index]
				index++
				m.LastScanNanos |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OldestIntentNanos", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if index >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[index]
				index++
				v |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.OldestIntentNanos = &v
		default:
			var sizeOfWire int
			for {
				sizeOfWire++
				wire >>= 7
				if wire == 0 {
					break
				}
			}
			index -= sizeOfWire
			skippy, err := github_com_gogo_protobuf_proto.Skip(data[index:])
			if err != nil {
				return err
			}
			if (index + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, data[index:index+skippy]...)
			index += skippy
		}
	}
	return nil
}
func (m *TimeSeriesDatapoint) Unmarshal(data []byte) error {
	l := len(data)
	index := 0
	for index < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if index >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[index]
			index++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimestampNanos", wireType)
			}
			for shift := uint(0); ; shift += 7 {
				if index >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[index]
				index++
				m.TimestampNanos |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IntValue", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if index >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[index]
				index++
				v |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IntValue = &v
		case 3:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field FloatValue", wireType)
			}
			var v uint32
			i := index + 4
			if i > l {
				return io.ErrUnexpectedEOF
			}
			index = i
			v = uint32(data[i-4])
			v |= uint32(data[i-3]) << 8
			v |= uint32(data[i-2]) << 16
			v |= uint32(data[i-1]) << 24
			v2 := math.Float32frombits(v)
			m.FloatValue = &v2
		default:
			var sizeOfWire int
			for {
				sizeOfWire++
				wire >>= 7
				if wire == 0 {
					break
				}
			}
			index -= sizeOfWire
			skippy, err := github_com_gogo_protobuf_proto.Skip(data[index:])
			if err != nil {
				return err
			}
			if (index + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, data[index:index+skippy]...)
			index += skippy
		}
	}
	return nil
}
func (m *TimeSeriesData) Unmarshal(data []byte) error {
	l := len(data)
	index := 0
	for index < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if index >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[index]
			index++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if index >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[index]
				index++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := index + int(stringLen)
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(data[index:postIndex])
			index = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Source", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if index >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[index]
				index++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := index + int(stringLen)
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Source = string(data[index:postIndex])
			index = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Datapoints", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if index >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[index]
				index++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := index + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Datapoints = append(m.Datapoints, &TimeSeriesDatapoint{})
			m.Datapoints[len(m.Datapoints)-1].Unmarshal(data[index:postIndex])
			index = postIndex
		default:
			var sizeOfWire int
			for {
				sizeOfWire++
				wire >>= 7
				if wire == 0 {
					break
				}
			}
			index -= sizeOfWire
			skippy, err := github_com_gogo_protobuf_proto.Skip(data[index:])
			if err != nil {
				return err
			}
			if (index + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, data[index:index+skippy]...)
			index += skippy
		}
	}
	return nil
}
func (m *MVCCStats) Unmarshal(data []byte) error {
	l := len(data)
	index := 0
	for index < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if index >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[index]
			index++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LiveBytes", wireType)
			}
			for shift := uint(0); ; shift += 7 {
				if index >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[index]
				index++
				m.LiveBytes |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyBytes", wireType)
			}
			for shift := uint(0); ; shift += 7 {
				if index >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[index]
				index++
				m.KeyBytes |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValBytes", wireType)
			}
			for shift := uint(0); ; shift += 7 {
				if index >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[index]
				index++
				m.ValBytes |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IntentBytes", wireType)
			}
			for shift := uint(0); ; shift += 7 {
				if index >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[index]
				index++
				m.IntentBytes |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LiveCount", wireType)
			}
			for shift := uint(0); ; shift += 7 {
				if index >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[index]
				index++
				m.LiveCount |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyCount", wireType)
			}
			for shift := uint(0); ; shift += 7 {
				if index >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[index]
				index++
				m.KeyCount |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValCount", wireType)
			}
			for shift := uint(0); ; shift += 7 {
				if index >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[index]
				index++
				m.ValCount |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IntentCount", wireType)
			}
			for shift := uint(0); ; shift += 7 {
				if index >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[index]
				index++
				m.IntentCount |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IntentAge", wireType)
			}
			for shift := uint(0); ; shift += 7 {
				if index >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[index]
				index++
				m.IntentAge |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GCBytesAge", wireType)
			}
			for shift := uint(0); ; shift += 7 {
				if index >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[index]
				index++
				m.GCBytesAge |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastUpdateNanos", wireType)
			}
			for shift := uint(0); ; shift += 7 {
				if index >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[index]
				index++
				m.LastUpdateNanos |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			var sizeOfWire int
			for {
				sizeOfWire++
				wire >>= 7
				if wire == 0 {
					break
				}
			}
			index -= sizeOfWire
			skippy, err := github_com_gogo_protobuf_proto.Skip(data[index:])
			if err != nil {
				return err
			}
			if (index + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, data[index:index+skippy]...)
			index += skippy
		}
	}
	return nil
}
func (m *Timestamp) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovData(uint64(m.WallTime))
	n += 1 + sovData(uint64(m.Logical))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Value) Size() (n int) {
	var l int
	_ = l
	if m.Bytes != nil {
		l = len(m.Bytes)
		n += 1 + l + sovData(uint64(l))
	}
	if m.Integer != nil {
		n += 1 + sovData(uint64(*m.Integer))
	}
	if m.Checksum != nil {
		n += 5
	}
	if m.Timestamp != nil {
		l = m.Timestamp.Size()
		n += 1 + l + sovData(uint64(l))
	}
	if m.Tag != nil {
		l = len(*m.Tag)
		n += 1 + l + sovData(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MVCCValue) Size() (n int) {
	var l int
	_ = l
	n += 2
	if m.Value != nil {
		l = m.Value.Size()
		n += 1 + l + sovData(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *KeyValue) Size() (n int) {
	var l int
	_ = l
	l = m.Key.Size()
	n += 1 + l + sovData(uint64(l))
	l = m.Value.Size()
	n += 1 + l + sovData(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RawKeyValue) Size() (n int) {
	var l int
	_ = l
	l = m.Key.Size()
	n += 1 + l + sovData(uint64(l))
	if m.Value != nil {
		l = len(m.Value)
		n += 1 + l + sovData(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *StoreIdent) Size() (n int) {
	var l int
	_ = l
	l = len(m.ClusterID)
	n += 1 + l + sovData(uint64(l))
	n += 1 + sovData(uint64(m.NodeID))
	n += 1 + sovData(uint64(m.StoreID))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SplitTrigger) Size() (n int) {
	var l int
	_ = l
	l = m.UpdatedDesc.Size()
	n += 1 + l + sovData(uint64(l))
	l = m.NewDesc.Size()
	n += 1 + l + sovData(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MergeTrigger) Size() (n int) {
	var l int
	_ = l
	l = m.UpdatedDesc.Size()
	n += 1 + l + sovData(uint64(l))
	n += 1 + sovData(uint64(m.SubsumedRaftID))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ChangeReplicasTrigger) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovData(uint64(m.NodeID))
	n += 1 + sovData(uint64(m.StoreID))
	n += 1 + sovData(uint64(m.ChangeType))
	if len(m.UpdatedReplicas) > 0 {
		for _, e := range m.UpdatedReplicas {
			l = e.Size()
			n += 1 + l + sovData(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *InternalCommitTrigger) Size() (n int) {
	var l int
	_ = l
	if m.SplitTrigger != nil {
		l = m.SplitTrigger.Size()
		n += 1 + l + sovData(uint64(l))
	}
	if m.MergeTrigger != nil {
		l = m.MergeTrigger.Size()
		n += 1 + l + sovData(uint64(l))
	}
	if m.ChangeReplicasTrigger != nil {
		l = m.ChangeReplicasTrigger.Size()
		n += 1 + l + sovData(uint64(l))
	}
	if len(m.Intents) > 0 {
		for _, e := range m.Intents {
			l = e.Size()
			n += 1 + l + sovData(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *NodeList) Size() (n int) {
	var l int
	_ = l
	if len(m.Nodes) > 0 {
		l = 0
		for _, e := range m.Nodes {
			l += sovData(uint64(e))
		}
		n += 1 + sovData(uint64(l)) + l
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Transaction) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	n += 1 + l + sovData(uint64(l))
	l = m.Key.Size()
	n += 1 + l + sovData(uint64(l))
	if m.ID != nil {
		l = len(m.ID)
		n += 1 + l + sovData(uint64(l))
	}
	n += 1 + sovData(uint64(m.Priority))
	n += 1 + sovData(uint64(m.Isolation))
	n += 1 + sovData(uint64(m.Status))
	n += 1 + sovData(uint64(m.Epoch))
	if m.LastHeartbeat != nil {
		l = m.LastHeartbeat.Size()
		n += 1 + l + sovData(uint64(l))
	}
	l = m.Timestamp.Size()
	n += 1 + l + sovData(uint64(l))
	l = m.OrigTimestamp.Size()
	n += 1 + l + sovData(uint64(l))
	l = m.MaxTimestamp.Size()
	n += 1 + l + sovData(uint64(l))
	l = m.CertainNodes.Size()
	n += 1 + l + sovData(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Lease) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovData(uint64(m.Expiration))
	n += 1 + sovData(uint64(m.Duration))
	n += 1 + sovData(uint64(m.Term))
	n += 1 + sovData(uint64(m.RaftNodeID))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MVCCMetadata) Size() (n int) {
	var l int
	_ = l
	if m.Txn != nil {
		l = m.Txn.Size()
		n += 1 + l + sovData(uint64(l))
	}
	l = m.Timestamp.Size()
	n += 1 + l + sovData(uint64(l))
	n += 2
	n += 1 + sovData(uint64(m.KeyBytes))
	n += 1 + sovData(uint64(m.ValBytes))
	if m.Value != nil {
		l = m.Value.Size()
		n += 1 + l + sovData(uint64(l))
	}
	l = m.LastEvicted.Size()
	n += 1 + l + sovData(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GCMetadata) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovData(uint64(m.LastScanNanos))
	if m.OldestIntentNanos != nil {
		n += 1 + sovData(uint64(*m.OldestIntentNanos))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TimeSeriesDatapoint) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovData(uint64(m.TimestampNanos))
	if m.IntValue != nil {
		n += 1 + sovData(uint64(*m.IntValue))
	}
	if m.FloatValue != nil {
		n += 5
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TimeSeriesData) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	n += 1 + l + sovData(uint64(l))
	l = len(m.Source)
	n += 1 + l + sovData(uint64(l))
	if len(m.Datapoints) > 0 {
		for _, e := range m.Datapoints {
			l = e.Size()
			n += 1 + l + sovData(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MVCCStats) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovData(uint64(m.LiveBytes))
	n += 1 + sovData(uint64(m.KeyBytes))
	n += 1 + sovData(uint64(m.ValBytes))
	n += 1 + sovData(uint64(m.IntentBytes))
	n += 1 + sovData(uint64(m.LiveCount))
	n += 1 + sovData(uint64(m.KeyCount))
	n += 1 + sovData(uint64(m.ValCount))
	n += 1 + sovData(uint64(m.IntentCount))
	n += 1 + sovData(uint64(m.IntentAge))
	n += 1 + sovData(uint64(m.GCBytesAge))
	n += 1 + sovData(uint64(m.LastUpdateNanos))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovData(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozData(x uint64) (n int) {
	return sovData(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Timestamp) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Timestamp) MarshalTo(data []byte) (n int, err error) {
	var i int
	_ = i
	var l int
	_ = l
	data[i] = 0x8
	i++
	i = encodeVarintData(data, i, uint64(m.WallTime))
	data[i] = 0x10
	i++
	i = encodeVarintData(data, i, uint64(m.Logical))
	if m.XXX_unrecognized != nil {
		i += copy(data[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Value) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Value) MarshalTo(data []byte) (n int, err error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Bytes != nil {
		data[i] = 0xa
		i++
		i = encodeVarintData(data, i, uint64(len(m.Bytes)))
		i += copy(data[i:], m.Bytes)
	}
	if m.Integer != nil {
		data[i] = 0x10
		i++
		i = encodeVarintData(data, i, uint64(*m.Integer))
	}
	if m.Checksum != nil {
		data[i] = 0x1d
		i++
		i = encodeFixed32Data(data, i, uint32(*m.Checksum))
	}
	if m.Timestamp != nil {
		data[i] = 0x22
		i++
		i = encodeVarintData(data, i, uint64(m.Timestamp.Size()))
		n1, err := m.Timestamp.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if m.Tag != nil {
		data[i] = 0x2a
		i++
		i = encodeVarintData(data, i, uint64(len(*m.Tag)))
		i += copy(data[i:], *m.Tag)
	}
	if m.XXX_unrecognized != nil {
		i += copy(data[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *MVCCValue) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *MVCCValue) MarshalTo(data []byte) (n int, err error) {
	var i int
	_ = i
	var l int
	_ = l
	data[i] = 0x8
	i++
	if m.Deleted {
		data[i] = 1
	} else {
		data[i] = 0
	}
	i++
	if m.Value != nil {
		data[i] = 0x12
		i++
		i = encodeVarintData(data, i, uint64(m.Value.Size()))
		n2, err := m.Value.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	if m.XXX_unrecognized != nil {
		i += copy(data[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *KeyValue) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *KeyValue) MarshalTo(data []byte) (n int, err error) {
	var i int
	_ = i
	var l int
	_ = l
	data[i] = 0xa
	i++
	i = encodeVarintData(data, i, uint64(m.Key.Size()))
	n3, err := m.Key.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n3
	data[i] = 0x12
	i++
	i = encodeVarintData(data, i, uint64(m.Value.Size()))
	n4, err := m.Value.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n4
	if m.XXX_unrecognized != nil {
		i += copy(data[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *RawKeyValue) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *RawKeyValue) MarshalTo(data []byte) (n int, err error) {
	var i int
	_ = i
	var l int
	_ = l
	data[i] = 0xa
	i++
	i = encodeVarintData(data, i, uint64(m.Key.Size()))
	n5, err := m.Key.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n5
	if m.Value != nil {
		data[i] = 0x12
		i++
		i = encodeVarintData(data, i, uint64(len(m.Value)))
		i += copy(data[i:], m.Value)
	}
	if m.XXX_unrecognized != nil {
		i += copy(data[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *StoreIdent) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *StoreIdent) MarshalTo(data []byte) (n int, err error) {
	var i int
	_ = i
	var l int
	_ = l
	data[i] = 0xa
	i++
	i = encodeVarintData(data, i, uint64(len(m.ClusterID)))
	i += copy(data[i:], m.ClusterID)
	data[i] = 0x10
	i++
	i = encodeVarintData(data, i, uint64(m.NodeID))
	data[i] = 0x18
	i++
	i = encodeVarintData(data, i, uint64(m.StoreID))
	if m.XXX_unrecognized != nil {
		i += copy(data[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *SplitTrigger) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *SplitTrigger) MarshalTo(data []byte) (n int, err error) {
	var i int
	_ = i
	var l int
	_ = l
	data[i] = 0xa
	i++
	i = encodeVarintData(data, i, uint64(m.UpdatedDesc.Size()))
	n6, err := m.UpdatedDesc.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n6
	data[i] = 0x12
	i++
	i = encodeVarintData(data, i, uint64(m.NewDesc.Size()))
	n7, err := m.NewDesc.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n7
	if m.XXX_unrecognized != nil {
		i += copy(data[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *MergeTrigger) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *MergeTrigger) MarshalTo(data []byte) (n int, err error) {
	var i int
	_ = i
	var l int
	_ = l
	data[i] = 0xa
	i++
	i = encodeVarintData(data, i, uint64(m.UpdatedDesc.Size()))
	n8, err := m.UpdatedDesc.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n8
	data[i] = 0x10
	i++
	i = encodeVarintData(data, i, uint64(m.SubsumedRaftID))
	if m.XXX_unrecognized != nil {
		i += copy(data[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ChangeReplicasTrigger) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *ChangeReplicasTrigger) MarshalTo(data []byte) (n int, err error) {
	var i int
	_ = i
	var l int
	_ = l
	data[i] = 0x8
	i++
	i = encodeVarintData(data, i, uint64(m.NodeID))
	data[i] = 0x10
	i++
	i = encodeVarintData(data, i, uint64(m.StoreID))
	data[i] = 0x18
	i++
	i = encodeVarintData(data, i, uint64(m.ChangeType))
	if len(m.UpdatedReplicas) > 0 {
		for _, msg := range m.UpdatedReplicas {
			data[i] = 0x22
			i++
			i = encodeVarintData(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(data[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *InternalCommitTrigger) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *InternalCommitTrigger) MarshalTo(data []byte) (n int, err error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.SplitTrigger != nil {
		data[i] = 0xa
		i++
		i = encodeVarintData(data, i, uint64(m.SplitTrigger.Size()))
		n9, err := m.SplitTrigger.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	if m.MergeTrigger != nil {
		data[i] = 0x12
		i++
		i = encodeVarintData(data, i, uint64(m.MergeTrigger.Size()))
		n10, err := m.MergeTrigger.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n10
	}
	if m.ChangeReplicasTrigger != nil {
		data[i] = 0x1a
		i++
		i = encodeVarintData(data, i, uint64(m.ChangeReplicasTrigger.Size()))
		n11, err := m.ChangeReplicasTrigger.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n11
	}
	if len(m.Intents) > 0 {
		for _, msg := range m.Intents {
			data[i] = 0x22
			i++
			i = encodeVarintData(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(data[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *NodeList) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *NodeList) MarshalTo(data []byte) (n int, err error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Nodes) > 0 {
		data13 := make([]byte, len(m.Nodes)*10)
		var j12 int
		for _, num1 := range m.Nodes {
			num := uint64(num1)
			for num >= 1<<7 {
				data13[j12] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j12++
			}
			data13[j12] = uint8(num)
			j12++
		}
		data[i] = 0xa
		i++
		i = encodeVarintData(data, i, uint64(j12))
		i += copy(data[i:], data13[:j12])
	}
	if m.XXX_unrecognized != nil {
		i += copy(data[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Transaction) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Transaction) MarshalTo(data []byte) (n int, err error) {
	var i int
	_ = i
	var l int
	_ = l
	data[i] = 0xa
	i++
	i = encodeVarintData(data, i, uint64(len(m.Name)))
	i += copy(data[i:], m.Name)
	data[i] = 0x12
	i++
	i = encodeVarintData(data, i, uint64(m.Key.Size()))
	n14, err := m.Key.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n14
	if m.ID != nil {
		data[i] = 0x1a
		i++
		i = encodeVarintData(data, i, uint64(len(m.ID)))
		i += copy(data[i:], m.ID)
	}
	data[i] = 0x20
	i++
	i = encodeVarintData(data, i, uint64(m.Priority))
	data[i] = 0x28
	i++
	i = encodeVarintData(data, i, uint64(m.Isolation))
	data[i] = 0x30
	i++
	i = encodeVarintData(data, i, uint64(m.Status))
	data[i] = 0x38
	i++
	i = encodeVarintData(data, i, uint64(m.Epoch))
	if m.LastHeartbeat != nil {
		data[i] = 0x42
		i++
		i = encodeVarintData(data, i, uint64(m.LastHeartbeat.Size()))
		n15, err := m.LastHeartbeat.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n15
	}
	data[i] = 0x4a
	i++
	i = encodeVarintData(data, i, uint64(m.Timestamp.Size()))
	n16, err := m.Timestamp.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n16
	data[i] = 0x52
	i++
	i = encodeVarintData(data, i, uint64(m.OrigTimestamp.Size()))
	n17, err := m.OrigTimestamp.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n17
	data[i] = 0x5a
	i++
	i = encodeVarintData(data, i, uint64(m.MaxTimestamp.Size()))
	n18, err := m.MaxTimestamp.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n18
	data[i] = 0x62
	i++
	i = encodeVarintData(data, i, uint64(m.CertainNodes.Size()))
	n19, err := m.CertainNodes.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n19
	if m.XXX_unrecognized != nil {
		i += copy(data[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Lease) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Lease) MarshalTo(data []byte) (n int, err error) {
	var i int
	_ = i
	var l int
	_ = l
	data[i] = 0x8
	i++
	i = encodeVarintData(data, i, uint64(m.Expiration))
	data[i] = 0x10
	i++
	i = encodeVarintData(data, i, uint64(m.Duration))
	data[i] = 0x18
	i++
	i = encodeVarintData(data, i, uint64(m.Term))
	data[i] = 0x20
	i++
	i = encodeVarintData(data, i, uint64(m.RaftNodeID))
	if m.XXX_unrecognized != nil {
		i += copy(data[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *MVCCMetadata) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *MVCCMetadata) MarshalTo(data []byte) (n int, err error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Txn != nil {
		data[i] = 0xa
		i++
		i = encodeVarintData(data, i, uint64(m.Txn.Size()))
		n20, err := m.Txn.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n20
	}
	data[i] = 0x12
	i++
	i = encodeVarintData(data, i, uint64(m.Timestamp.Size()))
	n21, err := m.Timestamp.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n21
	data[i] = 0x18
	i++
	if m.Deleted {
		data[i] = 1
	} else {
		data[i] = 0
	}
	i++
	data[i] = 0x20
	i++
	i = encodeVarintData(data, i, uint64(m.KeyBytes))
	data[i] = 0x28
	i++
	i = encodeVarintData(data, i, uint64(m.ValBytes))
	if m.Value != nil {
		data[i] = 0x32
		i++
		i = encodeVarintData(data, i, uint64(m.Value.Size()))
		n22, err := m.Value.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n22
	}
	data[i] = 0x3a
	i++
	i = encodeVarintData(data, i, uint64(m.LastEvicted.Size()))
	n23, err := m.LastEvicted.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n23
	if m.XXX_unrecognized != nil {
		i += copy(data[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *GCMetadata) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *GCMetadata) MarshalTo(data []byte) (n int, err error) {
	var i int
	_ = i
	var l int
	_ = l
	data[i] = 0x8
	i++
	i = encodeVarintData(data, i, uint64(m.LastScanNanos))
	if m.OldestIntentNanos != nil {
		data[i] = 0x10
		i++
		i = encodeVarintData(data, i, uint64(*m.OldestIntentNanos))
	}
	if m.XXX_unrecognized != nil {
		i += copy(data[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *TimeSeriesDatapoint) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *TimeSeriesDatapoint) MarshalTo(data []byte) (n int, err error) {
	var i int
	_ = i
	var l int
	_ = l
	data[i] = 0x8
	i++
	i = encodeVarintData(data, i, uint64(m.TimestampNanos))
	if m.IntValue != nil {
		data[i] = 0x10
		i++
		i = encodeVarintData(data, i, uint64(*m.IntValue))
	}
	if m.FloatValue != nil {
		data[i] = 0x1d
		i++
		i = encodeFixed32Data(data, i, uint32(math.Float32bits(*m.FloatValue)))
	}
	if m.XXX_unrecognized != nil {
		i += copy(data[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *TimeSeriesData) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *TimeSeriesData) MarshalTo(data []byte) (n int, err error) {
	var i int
	_ = i
	var l int
	_ = l
	data[i] = 0xa
	i++
	i = encodeVarintData(data, i, uint64(len(m.Name)))
	i += copy(data[i:], m.Name)
	data[i] = 0x12
	i++
	i = encodeVarintData(data, i, uint64(len(m.Source)))
	i += copy(data[i:], m.Source)
	if len(m.Datapoints) > 0 {
		for _, msg := range m.Datapoints {
			data[i] = 0x1a
			i++
			i = encodeVarintData(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(data[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *MVCCStats) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *MVCCStats) MarshalTo(data []byte) (n int, err error) {
	var i int
	_ = i
	var l int
	_ = l
	data[i] = 0x8
	i++
	i = encodeVarintData(data, i, uint64(m.LiveBytes))
	data[i] = 0x10
	i++
	i = encodeVarintData(data, i, uint64(m.KeyBytes))
	data[i] = 0x18
	i++
	i = encodeVarintData(data, i, uint64(m.ValBytes))
	data[i] = 0x20
	i++
	i = encodeVarintData(data, i, uint64(m.IntentBytes))
	data[i] = 0x28
	i++
	i = encodeVarintData(data, i, uint64(m.LiveCount))
	data[i] = 0x30
	i++
	i = encodeVarintData(data, i, uint64(m.KeyCount))
	data[i] = 0x38
	i++
	i = encodeVarintData(data, i, uint64(m.ValCount))
	data[i] = 0x40
	i++
	i = encodeVarintData(data, i, uint64(m.IntentCount))
	data[i] = 0x48
	i++
	i = encodeVarintData(data, i, uint64(m.IntentAge))
	data[i] = 0x50
	i++
	i = encodeVarintData(data, i, uint64(m.GCBytesAge))
	data[i] = 0x58
	i++
	i = encodeVarintData(data, i, uint64(m.LastUpdateNanos))
	if m.XXX_unrecognized != nil {
		i += copy(data[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func encodeFixed64Data(data []byte, offset int, v uint64) int {
	data[offset] = uint8(v)
	data[offset+1] = uint8(v >> 8)
	data[offset+2] = uint8(v >> 16)
	data[offset+3] = uint8(v >> 24)
	data[offset+4] = uint8(v >> 32)
	data[offset+5] = uint8(v >> 40)
	data[offset+6] = uint8(v >> 48)
	data[offset+7] = uint8(v >> 56)
	return offset + 8
}
func encodeFixed32Data(data []byte, offset int, v uint32) int {
	data[offset] = uint8(v)
	data[offset+1] = uint8(v >> 8)
	data[offset+2] = uint8(v >> 16)
	data[offset+3] = uint8(v >> 24)
	return offset + 4
}
func encodeVarintData(data []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		data[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	data[offset] = uint8(v)
	return offset + 1
}
