// Code generated by protoc-gen-gogo.
// source: cockroach/proto/internal.proto
// DO NOT EDIT!

package proto

import proto1 "github.com/gogo/protobuf/proto"
import math "math"

// discarding unused import gogoproto "gogoproto"

import io "io"

import fmt "fmt"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto1.Marshal
var _ = math.Inf

// InternalValueType defines a set of string constants placed in the
// "tag" field of Value messages which are created internally. These
// are defined as a protocol buffer enumeration so that they can be
// used portably between our Go and C code. The tags are used by the
// RocksDB Merge Operator to perform specialized merges.
type InternalValueType int32

const (
	// _CR_TS is applied to values which contain InternalTimeSeriesData.
	_CR_TS InternalValueType = 1
)

var InternalValueType_name = map[int32]string{
	1: "_CR_TS",
}
var InternalValueType_value = map[string]int32{
	"_CR_TS": 1,
}

func (x InternalValueType) Enum() *InternalValueType {
	p := new(InternalValueType)
	*p = x
	return p
}
func (x InternalValueType) String() string {
	return proto1.EnumName(InternalValueType_name, int32(x))
}
func (x *InternalValueType) UnmarshalJSON(data []byte) error {
	value, err := proto1.UnmarshalJSONEnum(InternalValueType_value, data, "InternalValueType")
	if err != nil {
		return err
	}
	*x = InternalValueType(value)
	return nil
}

// A ResponseCacheEntry is a union type containing instances of all
// mutating commands. Note that any entry added here must be handled
// in storage/engine/db.cc in GetResponseHeader(). This message is used
// for storing responses to mutating commands in the response cache.
type ResponseCacheEntry struct {
	Put                *PutResponse                `protobuf:"bytes,1,opt,name=put" json:"put,omitempty"`
	ConditionalPut     *ConditionalPutResponse     `protobuf:"bytes,2,opt,name=conditional_put" json:"conditional_put,omitempty"`
	Increment          *IncrementResponse          `protobuf:"bytes,3,opt,name=increment" json:"increment,omitempty"`
	Delete             *DeleteResponse             `protobuf:"bytes,4,opt,name=delete" json:"delete,omitempty"`
	DeleteRange        *DeleteRangeResponse        `protobuf:"bytes,5,opt,name=delete_range" json:"delete_range,omitempty"`
	EndTransaction     *EndTransactionResponse     `protobuf:"bytes,6,opt,name=end_transaction" json:"end_transaction,omitempty"`
	HeartbeatTxn       *HeartbeatTxnResponse       `protobuf:"bytes,7,opt,name=heartbeat_txn" json:"heartbeat_txn,omitempty"`
	Gc                 *GCResponse                 `protobuf:"bytes,8,opt,name=gc" json:"gc,omitempty"`
	PushTxn            *PushTxnResponse            `protobuf:"bytes,9,opt,name=push_txn" json:"push_txn,omitempty"`
	ResolveIntent      *ResolveIntentResponse      `protobuf:"bytes,10,opt,name=resolve_intent" json:"resolve_intent,omitempty"`
	ResolveIntentRange *ResolveIntentRangeResponse `protobuf:"bytes,11,opt,name=resolve_intent_range" json:"resolve_intent_range,omitempty"`
	Merge              *MergeResponse              `protobuf:"bytes,12,opt,name=merge" json:"merge,omitempty"`
	TruncateLog        *TruncateLogResponse        `protobuf:"bytes,13,opt,name=truncate_log" json:"truncate_log,omitempty"`
	LeaderLease        *LeaderLeaseResponse        `protobuf:"bytes,14,opt,name=leader_lease" json:"leader_lease,omitempty"`
	Batch              *BatchResponse              `protobuf:"bytes,30,opt,name=batch" json:"batch,omitempty"`
	XXX_unrecognized   []byte                      `json:"-"`
}

func (m *ResponseCacheEntry) Reset()         { *m = ResponseCacheEntry{} }
func (m *ResponseCacheEntry) String() string { return proto1.CompactTextString(m) }
func (*ResponseCacheEntry) ProtoMessage()    {}

func (m *ResponseCacheEntry) GetPut() *PutResponse {
	if m != nil {
		return m.Put
	}
	return nil
}

func (m *ResponseCacheEntry) GetConditionalPut() *ConditionalPutResponse {
	if m != nil {
		return m.ConditionalPut
	}
	return nil
}

func (m *ResponseCacheEntry) GetIncrement() *IncrementResponse {
	if m != nil {
		return m.Increment
	}
	return nil
}

func (m *ResponseCacheEntry) GetDelete() *DeleteResponse {
	if m != nil {
		return m.Delete
	}
	return nil
}

func (m *ResponseCacheEntry) GetDeleteRange() *DeleteRangeResponse {
	if m != nil {
		return m.DeleteRange
	}
	return nil
}

func (m *ResponseCacheEntry) GetEndTransaction() *EndTransactionResponse {
	if m != nil {
		return m.EndTransaction
	}
	return nil
}

func (m *ResponseCacheEntry) GetHeartbeatTxn() *HeartbeatTxnResponse {
	if m != nil {
		return m.HeartbeatTxn
	}
	return nil
}

func (m *ResponseCacheEntry) GetGc() *GCResponse {
	if m != nil {
		return m.Gc
	}
	return nil
}

func (m *ResponseCacheEntry) GetPushTxn() *PushTxnResponse {
	if m != nil {
		return m.PushTxn
	}
	return nil
}

func (m *ResponseCacheEntry) GetResolveIntent() *ResolveIntentResponse {
	if m != nil {
		return m.ResolveIntent
	}
	return nil
}

func (m *ResponseCacheEntry) GetResolveIntentRange() *ResolveIntentRangeResponse {
	if m != nil {
		return m.ResolveIntentRange
	}
	return nil
}

func (m *ResponseCacheEntry) GetMerge() *MergeResponse {
	if m != nil {
		return m.Merge
	}
	return nil
}

func (m *ResponseCacheEntry) GetTruncateLog() *TruncateLogResponse {
	if m != nil {
		return m.TruncateLog
	}
	return nil
}

func (m *ResponseCacheEntry) GetLeaderLease() *LeaderLeaseResponse {
	if m != nil {
		return m.LeaderLease
	}
	return nil
}

func (m *ResponseCacheEntry) GetBatch() *BatchResponse {
	if m != nil {
		return m.Batch
	}
	return nil
}

// A RaftCommandUnion is the union of all commands which can be sent
// via raft.
type RaftCommandUnion struct {
	// Non-batched external requests. This section is the same as RequestUnion.
	Get                *GetRequest                `protobuf:"bytes,1,opt,name=get" json:"get,omitempty"`
	Put                *PutRequest                `protobuf:"bytes,2,opt,name=put" json:"put,omitempty"`
	ConditionalPut     *ConditionalPutRequest     `protobuf:"bytes,3,opt,name=conditional_put" json:"conditional_put,omitempty"`
	Increment          *IncrementRequest          `protobuf:"bytes,4,opt,name=increment" json:"increment,omitempty"`
	Delete             *DeleteRequest             `protobuf:"bytes,5,opt,name=delete" json:"delete,omitempty"`
	DeleteRange        *DeleteRangeRequest        `protobuf:"bytes,6,opt,name=delete_range" json:"delete_range,omitempty"`
	Scan               *ScanRequest               `protobuf:"bytes,7,opt,name=scan" json:"scan,omitempty"`
	EndTransaction     *EndTransactionRequest     `protobuf:"bytes,8,opt,name=end_transaction" json:"end_transaction,omitempty"`
	RangeLookup        *RangeLookupRequest        `protobuf:"bytes,9,opt,name=range_lookup" json:"range_lookup,omitempty"`
	HeartbeatTxn       *HeartbeatTxnRequest       `protobuf:"bytes,10,opt,name=heartbeat_txn" json:"heartbeat_txn,omitempty"`
	GC                 *GCRequest                 `protobuf:"bytes,11,opt,name=gc" json:"gc,omitempty"`
	PushTxn            *PushTxnRequest            `protobuf:"bytes,12,opt,name=push_txn" json:"push_txn,omitempty"`
	ResolveIntent      *ResolveIntentRequest      `protobuf:"bytes,13,opt,name=resolve_intent" json:"resolve_intent,omitempty"`
	ResolveIntentRange *ResolveIntentRangeRequest `protobuf:"bytes,14,opt,name=resolve_intent_range" json:"resolve_intent_range,omitempty"`
	MergeResponse      *MergeRequest              `protobuf:"bytes,15,opt,name=merge_response" json:"merge_response,omitempty"`
	TruncateLog        *TruncateLogRequest        `protobuf:"bytes,16,opt,name=truncate_log" json:"truncate_log,omitempty"`
	Lease              *LeaderLeaseRequest        `protobuf:"bytes,17,opt,name=lease" json:"lease,omitempty"`
	ReverseScan        *ReverseScanRequest        `protobuf:"bytes,18,opt,name=reverse_scan" json:"reverse_scan,omitempty"`
	// Other requests. Allow a gap in tag numbers so the previous list can
	// be copy/pasted from RequestUnion.
	Batch            *BatchRequest `protobuf:"bytes,30,opt,name=batch" json:"batch,omitempty"`
	XXX_unrecognized []byte        `json:"-"`
}

func (m *RaftCommandUnion) Reset()         { *m = RaftCommandUnion{} }
func (m *RaftCommandUnion) String() string { return proto1.CompactTextString(m) }
func (*RaftCommandUnion) ProtoMessage()    {}

func (m *RaftCommandUnion) GetGet() *GetRequest {
	if m != nil {
		return m.Get
	}
	return nil
}

func (m *RaftCommandUnion) GetPut() *PutRequest {
	if m != nil {
		return m.Put
	}
	return nil
}

func (m *RaftCommandUnion) GetConditionalPut() *ConditionalPutRequest {
	if m != nil {
		return m.ConditionalPut
	}
	return nil
}

func (m *RaftCommandUnion) GetIncrement() *IncrementRequest {
	if m != nil {
		return m.Increment
	}
	return nil
}

func (m *RaftCommandUnion) GetDelete() *DeleteRequest {
	if m != nil {
		return m.Delete
	}
	return nil
}

func (m *RaftCommandUnion) GetDeleteRange() *DeleteRangeRequest {
	if m != nil {
		return m.DeleteRange
	}
	return nil
}

func (m *RaftCommandUnion) GetScan() *ScanRequest {
	if m != nil {
		return m.Scan
	}
	return nil
}

func (m *RaftCommandUnion) GetEndTransaction() *EndTransactionRequest {
	if m != nil {
		return m.EndTransaction
	}
	return nil
}

func (m *RaftCommandUnion) GetRangeLookup() *RangeLookupRequest {
	if m != nil {
		return m.RangeLookup
	}
	return nil
}

func (m *RaftCommandUnion) GetHeartbeatTxn() *HeartbeatTxnRequest {
	if m != nil {
		return m.HeartbeatTxn
	}
	return nil
}

func (m *RaftCommandUnion) GetGC() *GCRequest {
	if m != nil {
		return m.GC
	}
	return nil
}

func (m *RaftCommandUnion) GetPushTxn() *PushTxnRequest {
	if m != nil {
		return m.PushTxn
	}
	return nil
}

func (m *RaftCommandUnion) GetResolveIntent() *ResolveIntentRequest {
	if m != nil {
		return m.ResolveIntent
	}
	return nil
}

func (m *RaftCommandUnion) GetResolveIntentRange() *ResolveIntentRangeRequest {
	if m != nil {
		return m.ResolveIntentRange
	}
	return nil
}

func (m *RaftCommandUnion) GetMergeResponse() *MergeRequest {
	if m != nil {
		return m.MergeResponse
	}
	return nil
}

func (m *RaftCommandUnion) GetTruncateLog() *TruncateLogRequest {
	if m != nil {
		return m.TruncateLog
	}
	return nil
}

func (m *RaftCommandUnion) GetLease() *LeaderLeaseRequest {
	if m != nil {
		return m.Lease
	}
	return nil
}

func (m *RaftCommandUnion) GetReverseScan() *ReverseScanRequest {
	if m != nil {
		return m.ReverseScan
	}
	return nil
}

func (m *RaftCommandUnion) GetBatch() *BatchRequest {
	if m != nil {
		return m.Batch
	}
	return nil
}

// A RaftCommand is a command which can be serialized and sent via
// raft.
type RaftCommand struct {
	RangeID          RangeID          `protobuf:"varint,1,opt,name=range_id,casttype=RangeID" json:"range_id"`
	OriginNodeID     RaftNodeID       `protobuf:"varint,2,opt,name=origin_node_id,casttype=RaftNodeID" json:"origin_node_id"`
	Cmd              RaftCommandUnion `protobuf:"bytes,3,opt,name=cmd" json:"cmd"`
	XXX_unrecognized []byte           `json:"-"`
}

func (m *RaftCommand) Reset()         { *m = RaftCommand{} }
func (m *RaftCommand) String() string { return proto1.CompactTextString(m) }
func (*RaftCommand) ProtoMessage()    {}

func (m *RaftCommand) GetRangeID() RangeID {
	if m != nil {
		return m.RangeID
	}
	return 0
}

func (m *RaftCommand) GetOriginNodeID() RaftNodeID {
	if m != nil {
		return m.OriginNodeID
	}
	return 0
}

func (m *RaftCommand) GetCmd() RaftCommandUnion {
	if m != nil {
		return m.Cmd
	}
	return RaftCommandUnion{}
}

// RaftMessageRequest is the request used to send raft messages using our
// protobuf-based RPC codec. Unlike most of the requests defined in this file
// and api.proto, this one is implemented in a separate service defined in
// server/transport.go.
//
// This is the equivalent of the non-protobuf multiraft.RaftMessageRequest.
type RaftMessageRequest struct {
	GroupID RangeID `protobuf:"varint,1,opt,name=group_id,casttype=RangeID" json:"group_id"`
	// The raft payload, an encoded raftpb.Message. We transmit the message as
	// an opaque blob to avoid the complexity of importing proto files across
	// packages.
	Msg              []byte `protobuf:"bytes,2,opt,name=msg" json:"msg,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *RaftMessageRequest) Reset()         { *m = RaftMessageRequest{} }
func (m *RaftMessageRequest) String() string { return proto1.CompactTextString(m) }
func (*RaftMessageRequest) ProtoMessage()    {}

func (m *RaftMessageRequest) GetGroupID() RangeID {
	if m != nil {
		return m.GroupID
	}
	return 0
}

func (m *RaftMessageRequest) GetMsg() []byte {
	if m != nil {
		return m.Msg
	}
	return nil
}

// RaftMessageResponse is an empty message returned by raft RPCs.
type RaftMessageResponse struct {
	XXX_unrecognized []byte `json:"-"`
}

func (m *RaftMessageResponse) Reset()         { *m = RaftMessageResponse{} }
func (m *RaftMessageResponse) String() string { return proto1.CompactTextString(m) }
func (*RaftMessageResponse) ProtoMessage()    {}

// InternalTimeSeriesData is a collection of data samples for some
// measurable value, where each sample is taken over a uniform time
// interval.
//
// The collection itself contains a start timestamp (in seconds since the unix
// epoch) and a sample duration (in milliseconds). Each sample in the collection
// will contain a positive integer offset that indicates the length of time
// between the start_timestamp of the collection and the time when the sample
// began, expressed as an whole number of sample intervals. For example, if the
// sample duration is 60000 (indicating 1 minute), then a contained sample with
// an offset value of 5 begins (5*60000ms = 300000ms = 5 minutes) after the
// start timestamp of this data.
//
// This is meant to be an efficient internal representation of time series data,
// ensuring that very little redundant data is stored on disk. With this goal in
// mind, this message does not identify the variable which is actually being
// measured; that information is expected be encoded in the key where this
// message is stored.
type InternalTimeSeriesData struct {
	// Holds a wall time, expressed as a unix epoch time in nanoseconds. This
	// represents the earliest possible timestamp for a sample within the
	// collection.
	StartTimestampNanos int64 `protobuf:"varint,1,opt,name=start_timestamp_nanos" json:"start_timestamp_nanos"`
	// The duration of each sample interval, expressed in nanoseconds.
	SampleDurationNanos int64 `protobuf:"varint,2,opt,name=sample_duration_nanos" json:"sample_duration_nanos"`
	// The actual data samples for this metric.
	Samples          []*InternalTimeSeriesSample `protobuf:"bytes,3,rep,name=samples" json:"samples,omitempty"`
	XXX_unrecognized []byte                      `json:"-"`
}

func (m *InternalTimeSeriesData) Reset()         { *m = InternalTimeSeriesData{} }
func (m *InternalTimeSeriesData) String() string { return proto1.CompactTextString(m) }
func (*InternalTimeSeriesData) ProtoMessage()    {}

func (m *InternalTimeSeriesData) GetStartTimestampNanos() int64 {
	if m != nil {
		return m.StartTimestampNanos
	}
	return 0
}

func (m *InternalTimeSeriesData) GetSampleDurationNanos() int64 {
	if m != nil {
		return m.SampleDurationNanos
	}
	return 0
}

func (m *InternalTimeSeriesData) GetSamples() []*InternalTimeSeriesSample {
	if m != nil {
		return m.Samples
	}
	return nil
}

// A InternalTimeSeriesSample represents data gathered from multiple
// measurements of a variable value over a given period of time. The
// length of that period of time is stored in an
// InternalTimeSeriesData message; a sample cannot be interpreted
// correctly without a start timestamp and sample duration.
//
// Each sample may contain data gathered from multiple measurements of the same
// variable, as long as all of those measurements occured within the sample
// period. The sample stores several aggregated values from these measurements:
// - The sum of all measured values
// - A count of all measurements taken
// - The maximum individual measurement seen
// - The minimum individual measurement seen
//
// If zero measurements are present in a sample, then it should be omitted
// entirely from any collection it would be a part of.
//
// If the count of measurements is 1, then max and min fields may be omitted
// and assumed equal to the sum field.
type InternalTimeSeriesSample struct {
	// Temporal offset from the "start_timestamp" of the InternalTimeSeriesData
	// collection this data point is part in. The units of this value are
	// determined by the value of the "sample_duration_milliseconds" field of
	// the TimeSeriesData collection.
	Offset int32 `protobuf:"varint,1,opt,name=offset" json:"offset"`
	// Count of measurements taken within this sample.
	Count uint32 `protobuf:"varint,6,opt,name=count" json:"count"`
	// Sum of all measurements.
	Sum float64 `protobuf:"fixed64,7,opt,name=sum" json:"sum"`
	// Maximum encountered measurement in this sample.
	Max *float64 `protobuf:"fixed64,8,opt,name=max" json:"max,omitempty"`
	// Minimum encountered measurement in this sample.
	Min              *float64 `protobuf:"fixed64,9,opt,name=min" json:"min,omitempty"`
	XXX_unrecognized []byte   `json:"-"`
}

func (m *InternalTimeSeriesSample) Reset()         { *m = InternalTimeSeriesSample{} }
func (m *InternalTimeSeriesSample) String() string { return proto1.CompactTextString(m) }
func (*InternalTimeSeriesSample) ProtoMessage()    {}

func (m *InternalTimeSeriesSample) GetOffset() int32 {
	if m != nil {
		return m.Offset
	}
	return 0
}

func (m *InternalTimeSeriesSample) GetCount() uint32 {
	if m != nil {
		return m.Count
	}
	return 0
}

func (m *InternalTimeSeriesSample) GetSum() float64 {
	if m != nil {
		return m.Sum
	}
	return 0
}

func (m *InternalTimeSeriesSample) GetMax() float64 {
	if m != nil && m.Max != nil {
		return *m.Max
	}
	return 0
}

func (m *InternalTimeSeriesSample) GetMin() float64 {
	if m != nil && m.Min != nil {
		return *m.Min
	}
	return 0
}

// RaftTruncatedState contains metadata about the truncated portion of the raft log.
// Raft requires access to the term of the last truncated log entry even after the
// rest of the entry has been discarded.
type RaftTruncatedState struct {
	// The highest index that has been removed from the log.
	Index uint64 `protobuf:"varint,1,opt,name=index" json:"index"`
	// The term corresponding to 'index'.
	Term             uint64 `protobuf:"varint,2,opt,name=term" json:"term"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *RaftTruncatedState) Reset()         { *m = RaftTruncatedState{} }
func (m *RaftTruncatedState) String() string { return proto1.CompactTextString(m) }
func (*RaftTruncatedState) ProtoMessage()    {}

func (m *RaftTruncatedState) GetIndex() uint64 {
	if m != nil {
		return m.Index
	}
	return 0
}

func (m *RaftTruncatedState) GetTerm() uint64 {
	if m != nil {
		return m.Term
	}
	return 0
}

// RaftSnapshotData is the payload of a raftpb.Snapshot. It contains a raw copy of
// all of the range's data and metadata, including the raft log, response cache, etc.
type RaftSnapshotData struct {
	// The latest RangeDescriptor
	RangeDescriptor  RangeDescriptor              `protobuf:"bytes,1,opt,name=range_descriptor" json:"range_descriptor"`
	KV               []*RaftSnapshotData_KeyValue `protobuf:"bytes,2,rep" json:"KV,omitempty"`
	XXX_unrecognized []byte                       `json:"-"`
}

func (m *RaftSnapshotData) Reset()         { *m = RaftSnapshotData{} }
func (m *RaftSnapshotData) String() string { return proto1.CompactTextString(m) }
func (*RaftSnapshotData) ProtoMessage()    {}

func (m *RaftSnapshotData) GetRangeDescriptor() RangeDescriptor {
	if m != nil {
		return m.RangeDescriptor
	}
	return RangeDescriptor{}
}

func (m *RaftSnapshotData) GetKV() []*RaftSnapshotData_KeyValue {
	if m != nil {
		return m.KV
	}
	return nil
}

type RaftSnapshotData_KeyValue struct {
	Key              []byte `protobuf:"bytes,1,opt,name=key" json:"key,omitempty"`
	Value            []byte `protobuf:"bytes,2,opt,name=value" json:"value,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *RaftSnapshotData_KeyValue) Reset()         { *m = RaftSnapshotData_KeyValue{} }
func (m *RaftSnapshotData_KeyValue) String() string { return proto1.CompactTextString(m) }
func (*RaftSnapshotData_KeyValue) ProtoMessage()    {}

func (m *RaftSnapshotData_KeyValue) GetKey() []byte {
	if m != nil {
		return m.Key
	}
	return nil
}

func (m *RaftSnapshotData_KeyValue) GetValue() []byte {
	if m != nil {
		return m.Value
	}
	return nil
}

func init() {
	proto1.RegisterEnum("cockroach.proto.InternalValueType", InternalValueType_name, InternalValueType_value)
}
func (m *ResponseCacheEntry) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Put", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + msglen
			if msglen < 0 {
				return ErrInvalidLengthInternal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Put == nil {
				m.Put = &PutResponse{}
			}
			if err := m.Put.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConditionalPut", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + msglen
			if msglen < 0 {
				return ErrInvalidLengthInternal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ConditionalPut == nil {
				m.ConditionalPut = &ConditionalPutResponse{}
			}
			if err := m.ConditionalPut.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Increment", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + msglen
			if msglen < 0 {
				return ErrInvalidLengthInternal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Increment == nil {
				m.Increment = &IncrementResponse{}
			}
			if err := m.Increment.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Delete", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + msglen
			if msglen < 0 {
				return ErrInvalidLengthInternal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Delete == nil {
				m.Delete = &DeleteResponse{}
			}
			if err := m.Delete.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeleteRange", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + msglen
			if msglen < 0 {
				return ErrInvalidLengthInternal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DeleteRange == nil {
				m.DeleteRange = &DeleteRangeResponse{}
			}
			if err := m.DeleteRange.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndTransaction", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + msglen
			if msglen < 0 {
				return ErrInvalidLengthInternal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EndTransaction == nil {
				m.EndTransaction = &EndTransactionResponse{}
			}
			if err := m.EndTransaction.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HeartbeatTxn", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + msglen
			if msglen < 0 {
				return ErrInvalidLengthInternal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.HeartbeatTxn == nil {
				m.HeartbeatTxn = &HeartbeatTxnResponse{}
			}
			if err := m.HeartbeatTxn.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Gc", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + msglen
			if msglen < 0 {
				return ErrInvalidLengthInternal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Gc == nil {
				m.Gc = &GCResponse{}
			}
			if err := m.Gc.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PushTxn", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + msglen
			if msglen < 0 {
				return ErrInvalidLengthInternal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PushTxn == nil {
				m.PushTxn = &PushTxnResponse{}
			}
			if err := m.PushTxn.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResolveIntent", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + msglen
			if msglen < 0 {
				return ErrInvalidLengthInternal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ResolveIntent == nil {
				m.ResolveIntent = &ResolveIntentResponse{}
			}
			if err := m.ResolveIntent.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResolveIntentRange", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + msglen
			if msglen < 0 {
				return ErrInvalidLengthInternal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ResolveIntentRange == nil {
				m.ResolveIntentRange = &ResolveIntentRangeResponse{}
			}
			if err := m.ResolveIntentRange.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Merge", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + msglen
			if msglen < 0 {
				return ErrInvalidLengthInternal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Merge == nil {
				m.Merge = &MergeResponse{}
			}
			if err := m.Merge.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TruncateLog", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + msglen
			if msglen < 0 {
				return ErrInvalidLengthInternal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TruncateLog == nil {
				m.TruncateLog = &TruncateLogResponse{}
			}
			if err := m.TruncateLog.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LeaderLease", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + msglen
			if msglen < 0 {
				return ErrInvalidLengthInternal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LeaderLease == nil {
				m.LeaderLease = &LeaderLeaseResponse{}
			}
			if err := m.LeaderLease.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 30:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Batch", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + msglen
			if msglen < 0 {
				return ErrInvalidLengthInternal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Batch == nil {
				m.Batch = &BatchResponse{}
			}
			if err := m.Batch.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			var sizeOfWire int
			for {
				sizeOfWire++
				wire >>= 7
				if wire == 0 {
					break
				}
			}
			iNdEx -= sizeOfWire
			skippy, err := skipInternal(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthInternal
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, data[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	return nil
}
func (m *RaftCommandUnion) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Get", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + msglen
			if msglen < 0 {
				return ErrInvalidLengthInternal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Get == nil {
				m.Get = &GetRequest{}
			}
			if err := m.Get.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Put", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + msglen
			if msglen < 0 {
				return ErrInvalidLengthInternal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Put == nil {
				m.Put = &PutRequest{}
			}
			if err := m.Put.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConditionalPut", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + msglen
			if msglen < 0 {
				return ErrInvalidLengthInternal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ConditionalPut == nil {
				m.ConditionalPut = &ConditionalPutRequest{}
			}
			if err := m.ConditionalPut.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Increment", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + msglen
			if msglen < 0 {
				return ErrInvalidLengthInternal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Increment == nil {
				m.Increment = &IncrementRequest{}
			}
			if err := m.Increment.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Delete", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + msglen
			if msglen < 0 {
				return ErrInvalidLengthInternal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Delete == nil {
				m.Delete = &DeleteRequest{}
			}
			if err := m.Delete.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeleteRange", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + msglen
			if msglen < 0 {
				return ErrInvalidLengthInternal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DeleteRange == nil {
				m.DeleteRange = &DeleteRangeRequest{}
			}
			if err := m.DeleteRange.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Scan", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + msglen
			if msglen < 0 {
				return ErrInvalidLengthInternal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Scan == nil {
				m.Scan = &ScanRequest{}
			}
			if err := m.Scan.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndTransaction", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + msglen
			if msglen < 0 {
				return ErrInvalidLengthInternal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EndTransaction == nil {
				m.EndTransaction = &EndTransactionRequest{}
			}
			if err := m.EndTransaction.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RangeLookup", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + msglen
			if msglen < 0 {
				return ErrInvalidLengthInternal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RangeLookup == nil {
				m.RangeLookup = &RangeLookupRequest{}
			}
			if err := m.RangeLookup.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HeartbeatTxn", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + msglen
			if msglen < 0 {
				return ErrInvalidLengthInternal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.HeartbeatTxn == nil {
				m.HeartbeatTxn = &HeartbeatTxnRequest{}
			}
			if err := m.HeartbeatTxn.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GC", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + msglen
			if msglen < 0 {
				return ErrInvalidLengthInternal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.GC == nil {
				m.GC = &GCRequest{}
			}
			if err := m.GC.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PushTxn", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + msglen
			if msglen < 0 {
				return ErrInvalidLengthInternal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PushTxn == nil {
				m.PushTxn = &PushTxnRequest{}
			}
			if err := m.PushTxn.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResolveIntent", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + msglen
			if msglen < 0 {
				return ErrInvalidLengthInternal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ResolveIntent == nil {
				m.ResolveIntent = &ResolveIntentRequest{}
			}
			if err := m.ResolveIntent.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResolveIntentRange", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + msglen
			if msglen < 0 {
				return ErrInvalidLengthInternal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ResolveIntentRange == nil {
				m.ResolveIntentRange = &ResolveIntentRangeRequest{}
			}
			if err := m.ResolveIntentRange.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MergeResponse", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + msglen
			if msglen < 0 {
				return ErrInvalidLengthInternal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MergeResponse == nil {
				m.MergeResponse = &MergeRequest{}
			}
			if err := m.MergeResponse.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TruncateLog", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + msglen
			if msglen < 0 {
				return ErrInvalidLengthInternal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TruncateLog == nil {
				m.TruncateLog = &TruncateLogRequest{}
			}
			if err := m.TruncateLog.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lease", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + msglen
			if msglen < 0 {
				return ErrInvalidLengthInternal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Lease == nil {
				m.Lease = &LeaderLeaseRequest{}
			}
			if err := m.Lease.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReverseScan", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + msglen
			if msglen < 0 {
				return ErrInvalidLengthInternal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ReverseScan == nil {
				m.ReverseScan = &ReverseScanRequest{}
			}
			if err := m.ReverseScan.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 30:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Batch", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + msglen
			if msglen < 0 {
				return ErrInvalidLengthInternal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Batch == nil {
				m.Batch = &BatchRequest{}
			}
			if err := m.Batch.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			var sizeOfWire int
			for {
				sizeOfWire++
				wire >>= 7
				if wire == 0 {
					break
				}
			}
			iNdEx -= sizeOfWire
			skippy, err := skipInternal(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthInternal
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, data[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	return nil
}
func (m *RaftCommand) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RangeID", wireType)
			}
			m.RangeID = 0
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.RangeID |= (RangeID(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OriginNodeID", wireType)
			}
			m.OriginNodeID = 0
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.OriginNodeID |= (RaftNodeID(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cmd", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + msglen
			if msglen < 0 {
				return ErrInvalidLengthInternal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Cmd.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			var sizeOfWire int
			for {
				sizeOfWire++
				wire >>= 7
				if wire == 0 {
					break
				}
			}
			iNdEx -= sizeOfWire
			skippy, err := skipInternal(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthInternal
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, data[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	return nil
}
func (m *RaftMessageRequest) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupID", wireType)
			}
			m.GroupID = 0
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.GroupID |= (RangeID(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msg", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthInternal
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Msg = append([]byte{}, data[iNdEx:postIndex]...)
			iNdEx = postIndex
		default:
			var sizeOfWire int
			for {
				sizeOfWire++
				wire >>= 7
				if wire == 0 {
					break
				}
			}
			iNdEx -= sizeOfWire
			skippy, err := skipInternal(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthInternal
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, data[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	return nil
}
func (m *RaftMessageResponse) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		switch fieldNum {
		default:
			var sizeOfWire int
			for {
				sizeOfWire++
				wire >>= 7
				if wire == 0 {
					break
				}
			}
			iNdEx -= sizeOfWire
			skippy, err := skipInternal(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthInternal
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, data[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	return nil
}
func (m *InternalTimeSeriesData) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartTimestampNanos", wireType)
			}
			m.StartTimestampNanos = 0
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.StartTimestampNanos |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SampleDurationNanos", wireType)
			}
			m.SampleDurationNanos = 0
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.SampleDurationNanos |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Samples", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + msglen
			if msglen < 0 {
				return ErrInvalidLengthInternal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Samples = append(m.Samples, &InternalTimeSeriesSample{})
			if err := m.Samples[len(m.Samples)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			var sizeOfWire int
			for {
				sizeOfWire++
				wire >>= 7
				if wire == 0 {
					break
				}
			}
			iNdEx -= sizeOfWire
			skippy, err := skipInternal(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthInternal
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, data[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	return nil
}
func (m *InternalTimeSeriesSample) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Offset", wireType)
			}
			m.Offset = 0
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Offset |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			m.Count = 0
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Count |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sum", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(data[iNdEx-8])
			v |= uint64(data[iNdEx-7]) << 8
			v |= uint64(data[iNdEx-6]) << 16
			v |= uint64(data[iNdEx-5]) << 24
			v |= uint64(data[iNdEx-4]) << 32
			v |= uint64(data[iNdEx-3]) << 40
			v |= uint64(data[iNdEx-2]) << 48
			v |= uint64(data[iNdEx-1]) << 56
			m.Sum = float64(math.Float64frombits(v))
		case 8:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Max", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(data[iNdEx-8])
			v |= uint64(data[iNdEx-7]) << 8
			v |= uint64(data[iNdEx-6]) << 16
			v |= uint64(data[iNdEx-5]) << 24
			v |= uint64(data[iNdEx-4]) << 32
			v |= uint64(data[iNdEx-3]) << 40
			v |= uint64(data[iNdEx-2]) << 48
			v |= uint64(data[iNdEx-1]) << 56
			v2 := float64(math.Float64frombits(v))
			m.Max = &v2
		case 9:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Min", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(data[iNdEx-8])
			v |= uint64(data[iNdEx-7]) << 8
			v |= uint64(data[iNdEx-6]) << 16
			v |= uint64(data[iNdEx-5]) << 24
			v |= uint64(data[iNdEx-4]) << 32
			v |= uint64(data[iNdEx-3]) << 40
			v |= uint64(data[iNdEx-2]) << 48
			v |= uint64(data[iNdEx-1]) << 56
			v2 := float64(math.Float64frombits(v))
			m.Min = &v2
		default:
			var sizeOfWire int
			for {
				sizeOfWire++
				wire >>= 7
				if wire == 0 {
					break
				}
			}
			iNdEx -= sizeOfWire
			skippy, err := skipInternal(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthInternal
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, data[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	return nil
}
func (m *RaftTruncatedState) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			m.Index = 0
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Index |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Term", wireType)
			}
			m.Term = 0
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Term |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			var sizeOfWire int
			for {
				sizeOfWire++
				wire >>= 7
				if wire == 0 {
					break
				}
			}
			iNdEx -= sizeOfWire
			skippy, err := skipInternal(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthInternal
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, data[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	return nil
}
func (m *RaftSnapshotData) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RangeDescriptor", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + msglen
			if msglen < 0 {
				return ErrInvalidLengthInternal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RangeDescriptor.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KV", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + msglen
			if msglen < 0 {
				return ErrInvalidLengthInternal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.KV = append(m.KV, &RaftSnapshotData_KeyValue{})
			if err := m.KV[len(m.KV)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			var sizeOfWire int
			for {
				sizeOfWire++
				wire >>= 7
				if wire == 0 {
					break
				}
			}
			iNdEx -= sizeOfWire
			skippy, err := skipInternal(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthInternal
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, data[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	return nil
}
func (m *RaftSnapshotData_KeyValue) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthInternal
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = append([]byte{}, data[iNdEx:postIndex]...)
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthInternal
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = append([]byte{}, data[iNdEx:postIndex]...)
			iNdEx = postIndex
		default:
			var sizeOfWire int
			for {
				sizeOfWire++
				wire >>= 7
				if wire == 0 {
					break
				}
			}
			iNdEx -= sizeOfWire
			skippy, err := skipInternal(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthInternal
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, data[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	return nil
}
func skipInternal(data []byte) (n int, err error) {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for {
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if data[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthInternal
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipInternal(data[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthInternal = fmt.Errorf("proto: negative length found during unmarshaling")
)

func (this *ResponseCacheEntry) GetValue() interface{} {
	if this.Put != nil {
		return this.Put
	}
	if this.ConditionalPut != nil {
		return this.ConditionalPut
	}
	if this.Increment != nil {
		return this.Increment
	}
	if this.Delete != nil {
		return this.Delete
	}
	if this.DeleteRange != nil {
		return this.DeleteRange
	}
	if this.EndTransaction != nil {
		return this.EndTransaction
	}
	if this.HeartbeatTxn != nil {
		return this.HeartbeatTxn
	}
	if this.Gc != nil {
		return this.Gc
	}
	if this.PushTxn != nil {
		return this.PushTxn
	}
	if this.ResolveIntent != nil {
		return this.ResolveIntent
	}
	if this.ResolveIntentRange != nil {
		return this.ResolveIntentRange
	}
	if this.Merge != nil {
		return this.Merge
	}
	if this.TruncateLog != nil {
		return this.TruncateLog
	}
	if this.LeaderLease != nil {
		return this.LeaderLease
	}
	if this.Batch != nil {
		return this.Batch
	}
	return nil
}

func (this *ResponseCacheEntry) SetValue(value interface{}) bool {
	switch vt := value.(type) {
	case *PutResponse:
		this.Put = vt
	case *ConditionalPutResponse:
		this.ConditionalPut = vt
	case *IncrementResponse:
		this.Increment = vt
	case *DeleteResponse:
		this.Delete = vt
	case *DeleteRangeResponse:
		this.DeleteRange = vt
	case *EndTransactionResponse:
		this.EndTransaction = vt
	case *HeartbeatTxnResponse:
		this.HeartbeatTxn = vt
	case *GCResponse:
		this.Gc = vt
	case *PushTxnResponse:
		this.PushTxn = vt
	case *ResolveIntentResponse:
		this.ResolveIntent = vt
	case *ResolveIntentRangeResponse:
		this.ResolveIntentRange = vt
	case *MergeResponse:
		this.Merge = vt
	case *TruncateLogResponse:
		this.TruncateLog = vt
	case *LeaderLeaseResponse:
		this.LeaderLease = vt
	case *BatchResponse:
		this.Batch = vt
	default:
		return false
	}
	return true
}
func (this *RaftCommandUnion) GetValue() interface{} {
	if this.Get != nil {
		return this.Get
	}
	if this.Put != nil {
		return this.Put
	}
	if this.ConditionalPut != nil {
		return this.ConditionalPut
	}
	if this.Increment != nil {
		return this.Increment
	}
	if this.Delete != nil {
		return this.Delete
	}
	if this.DeleteRange != nil {
		return this.DeleteRange
	}
	if this.Scan != nil {
		return this.Scan
	}
	if this.EndTransaction != nil {
		return this.EndTransaction
	}
	if this.RangeLookup != nil {
		return this.RangeLookup
	}
	if this.HeartbeatTxn != nil {
		return this.HeartbeatTxn
	}
	if this.GC != nil {
		return this.GC
	}
	if this.PushTxn != nil {
		return this.PushTxn
	}
	if this.ResolveIntent != nil {
		return this.ResolveIntent
	}
	if this.ResolveIntentRange != nil {
		return this.ResolveIntentRange
	}
	if this.MergeResponse != nil {
		return this.MergeResponse
	}
	if this.TruncateLog != nil {
		return this.TruncateLog
	}
	if this.Lease != nil {
		return this.Lease
	}
	if this.ReverseScan != nil {
		return this.ReverseScan
	}
	if this.Batch != nil {
		return this.Batch
	}
	return nil
}

func (this *RaftCommandUnion) SetValue(value interface{}) bool {
	switch vt := value.(type) {
	case *GetRequest:
		this.Get = vt
	case *PutRequest:
		this.Put = vt
	case *ConditionalPutRequest:
		this.ConditionalPut = vt
	case *IncrementRequest:
		this.Increment = vt
	case *DeleteRequest:
		this.Delete = vt
	case *DeleteRangeRequest:
		this.DeleteRange = vt
	case *ScanRequest:
		this.Scan = vt
	case *EndTransactionRequest:
		this.EndTransaction = vt
	case *RangeLookupRequest:
		this.RangeLookup = vt
	case *HeartbeatTxnRequest:
		this.HeartbeatTxn = vt
	case *GCRequest:
		this.GC = vt
	case *PushTxnRequest:
		this.PushTxn = vt
	case *ResolveIntentRequest:
		this.ResolveIntent = vt
	case *ResolveIntentRangeRequest:
		this.ResolveIntentRange = vt
	case *MergeRequest:
		this.MergeResponse = vt
	case *TruncateLogRequest:
		this.TruncateLog = vt
	case *LeaderLeaseRequest:
		this.Lease = vt
	case *ReverseScanRequest:
		this.ReverseScan = vt
	case *BatchRequest:
		this.Batch = vt
	default:
		return false
	}
	return true
}
func (m *ResponseCacheEntry) Size() (n int) {
	var l int
	_ = l
	if m.Put != nil {
		l = m.Put.Size()
		n += 1 + l + sovInternal(uint64(l))
	}
	if m.ConditionalPut != nil {
		l = m.ConditionalPut.Size()
		n += 1 + l + sovInternal(uint64(l))
	}
	if m.Increment != nil {
		l = m.Increment.Size()
		n += 1 + l + sovInternal(uint64(l))
	}
	if m.Delete != nil {
		l = m.Delete.Size()
		n += 1 + l + sovInternal(uint64(l))
	}
	if m.DeleteRange != nil {
		l = m.DeleteRange.Size()
		n += 1 + l + sovInternal(uint64(l))
	}
	if m.EndTransaction != nil {
		l = m.EndTransaction.Size()
		n += 1 + l + sovInternal(uint64(l))
	}
	if m.HeartbeatTxn != nil {
		l = m.HeartbeatTxn.Size()
		n += 1 + l + sovInternal(uint64(l))
	}
	if m.Gc != nil {
		l = m.Gc.Size()
		n += 1 + l + sovInternal(uint64(l))
	}
	if m.PushTxn != nil {
		l = m.PushTxn.Size()
		n += 1 + l + sovInternal(uint64(l))
	}
	if m.ResolveIntent != nil {
		l = m.ResolveIntent.Size()
		n += 1 + l + sovInternal(uint64(l))
	}
	if m.ResolveIntentRange != nil {
		l = m.ResolveIntentRange.Size()
		n += 1 + l + sovInternal(uint64(l))
	}
	if m.Merge != nil {
		l = m.Merge.Size()
		n += 1 + l + sovInternal(uint64(l))
	}
	if m.TruncateLog != nil {
		l = m.TruncateLog.Size()
		n += 1 + l + sovInternal(uint64(l))
	}
	if m.LeaderLease != nil {
		l = m.LeaderLease.Size()
		n += 1 + l + sovInternal(uint64(l))
	}
	if m.Batch != nil {
		l = m.Batch.Size()
		n += 2 + l + sovInternal(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RaftCommandUnion) Size() (n int) {
	var l int
	_ = l
	if m.Get != nil {
		l = m.Get.Size()
		n += 1 + l + sovInternal(uint64(l))
	}
	if m.Put != nil {
		l = m.Put.Size()
		n += 1 + l + sovInternal(uint64(l))
	}
	if m.ConditionalPut != nil {
		l = m.ConditionalPut.Size()
		n += 1 + l + sovInternal(uint64(l))
	}
	if m.Increment != nil {
		l = m.Increment.Size()
		n += 1 + l + sovInternal(uint64(l))
	}
	if m.Delete != nil {
		l = m.Delete.Size()
		n += 1 + l + sovInternal(uint64(l))
	}
	if m.DeleteRange != nil {
		l = m.DeleteRange.Size()
		n += 1 + l + sovInternal(uint64(l))
	}
	if m.Scan != nil {
		l = m.Scan.Size()
		n += 1 + l + sovInternal(uint64(l))
	}
	if m.EndTransaction != nil {
		l = m.EndTransaction.Size()
		n += 1 + l + sovInternal(uint64(l))
	}
	if m.RangeLookup != nil {
		l = m.RangeLookup.Size()
		n += 1 + l + sovInternal(uint64(l))
	}
	if m.HeartbeatTxn != nil {
		l = m.HeartbeatTxn.Size()
		n += 1 + l + sovInternal(uint64(l))
	}
	if m.GC != nil {
		l = m.GC.Size()
		n += 1 + l + sovInternal(uint64(l))
	}
	if m.PushTxn != nil {
		l = m.PushTxn.Size()
		n += 1 + l + sovInternal(uint64(l))
	}
	if m.ResolveIntent != nil {
		l = m.ResolveIntent.Size()
		n += 1 + l + sovInternal(uint64(l))
	}
	if m.ResolveIntentRange != nil {
		l = m.ResolveIntentRange.Size()
		n += 1 + l + sovInternal(uint64(l))
	}
	if m.MergeResponse != nil {
		l = m.MergeResponse.Size()
		n += 1 + l + sovInternal(uint64(l))
	}
	if m.TruncateLog != nil {
		l = m.TruncateLog.Size()
		n += 2 + l + sovInternal(uint64(l))
	}
	if m.Lease != nil {
		l = m.Lease.Size()
		n += 2 + l + sovInternal(uint64(l))
	}
	if m.ReverseScan != nil {
		l = m.ReverseScan.Size()
		n += 2 + l + sovInternal(uint64(l))
	}
	if m.Batch != nil {
		l = m.Batch.Size()
		n += 2 + l + sovInternal(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RaftCommand) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovInternal(uint64(m.RangeID))
	n += 1 + sovInternal(uint64(m.OriginNodeID))
	l = m.Cmd.Size()
	n += 1 + l + sovInternal(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RaftMessageRequest) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovInternal(uint64(m.GroupID))
	if m.Msg != nil {
		l = len(m.Msg)
		n += 1 + l + sovInternal(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RaftMessageResponse) Size() (n int) {
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *InternalTimeSeriesData) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovInternal(uint64(m.StartTimestampNanos))
	n += 1 + sovInternal(uint64(m.SampleDurationNanos))
	if len(m.Samples) > 0 {
		for _, e := range m.Samples {
			l = e.Size()
			n += 1 + l + sovInternal(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *InternalTimeSeriesSample) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovInternal(uint64(m.Offset))
	n += 1 + sovInternal(uint64(m.Count))
	n += 9
	if m.Max != nil {
		n += 9
	}
	if m.Min != nil {
		n += 9
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RaftTruncatedState) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovInternal(uint64(m.Index))
	n += 1 + sovInternal(uint64(m.Term))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RaftSnapshotData) Size() (n int) {
	var l int
	_ = l
	l = m.RangeDescriptor.Size()
	n += 1 + l + sovInternal(uint64(l))
	if len(m.KV) > 0 {
		for _, e := range m.KV {
			l = e.Size()
			n += 1 + l + sovInternal(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RaftSnapshotData_KeyValue) Size() (n int) {
	var l int
	_ = l
	if m.Key != nil {
		l = len(m.Key)
		n += 1 + l + sovInternal(uint64(l))
	}
	if m.Value != nil {
		l = len(m.Value)
		n += 1 + l + sovInternal(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovInternal(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozInternal(x uint64) (n int) {
	return sovInternal(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *ResponseCacheEntry) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *ResponseCacheEntry) MarshalTo(data []byte) (n int, err error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Put != nil {
		data[i] = 0xa
		i++
		i = encodeVarintInternal(data, i, uint64(m.Put.Size()))
		n1, err := m.Put.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if m.ConditionalPut != nil {
		data[i] = 0x12
		i++
		i = encodeVarintInternal(data, i, uint64(m.ConditionalPut.Size()))
		n2, err := m.ConditionalPut.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	if m.Increment != nil {
		data[i] = 0x1a
		i++
		i = encodeVarintInternal(data, i, uint64(m.Increment.Size()))
		n3, err := m.Increment.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	if m.Delete != nil {
		data[i] = 0x22
		i++
		i = encodeVarintInternal(data, i, uint64(m.Delete.Size()))
		n4, err := m.Delete.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	if m.DeleteRange != nil {
		data[i] = 0x2a
		i++
		i = encodeVarintInternal(data, i, uint64(m.DeleteRange.Size()))
		n5, err := m.DeleteRange.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	if m.EndTransaction != nil {
		data[i] = 0x32
		i++
		i = encodeVarintInternal(data, i, uint64(m.EndTransaction.Size()))
		n6, err := m.EndTransaction.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	if m.HeartbeatTxn != nil {
		data[i] = 0x3a
		i++
		i = encodeVarintInternal(data, i, uint64(m.HeartbeatTxn.Size()))
		n7, err := m.HeartbeatTxn.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	if m.Gc != nil {
		data[i] = 0x42
		i++
		i = encodeVarintInternal(data, i, uint64(m.Gc.Size()))
		n8, err := m.Gc.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	if m.PushTxn != nil {
		data[i] = 0x4a
		i++
		i = encodeVarintInternal(data, i, uint64(m.PushTxn.Size()))
		n9, err := m.PushTxn.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	if m.ResolveIntent != nil {
		data[i] = 0x52
		i++
		i = encodeVarintInternal(data, i, uint64(m.ResolveIntent.Size()))
		n10, err := m.ResolveIntent.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n10
	}
	if m.ResolveIntentRange != nil {
		data[i] = 0x5a
		i++
		i = encodeVarintInternal(data, i, uint64(m.ResolveIntentRange.Size()))
		n11, err := m.ResolveIntentRange.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n11
	}
	if m.Merge != nil {
		data[i] = 0x62
		i++
		i = encodeVarintInternal(data, i, uint64(m.Merge.Size()))
		n12, err := m.Merge.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n12
	}
	if m.TruncateLog != nil {
		data[i] = 0x6a
		i++
		i = encodeVarintInternal(data, i, uint64(m.TruncateLog.Size()))
		n13, err := m.TruncateLog.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n13
	}
	if m.LeaderLease != nil {
		data[i] = 0x72
		i++
		i = encodeVarintInternal(data, i, uint64(m.LeaderLease.Size()))
		n14, err := m.LeaderLease.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n14
	}
	if m.Batch != nil {
		data[i] = 0xf2
		i++
		data[i] = 0x1
		i++
		i = encodeVarintInternal(data, i, uint64(m.Batch.Size()))
		n15, err := m.Batch.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n15
	}
	if m.XXX_unrecognized != nil {
		i += copy(data[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *RaftCommandUnion) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *RaftCommandUnion) MarshalTo(data []byte) (n int, err error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Get != nil {
		data[i] = 0xa
		i++
		i = encodeVarintInternal(data, i, uint64(m.Get.Size()))
		n16, err := m.Get.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n16
	}
	if m.Put != nil {
		data[i] = 0x12
		i++
		i = encodeVarintInternal(data, i, uint64(m.Put.Size()))
		n17, err := m.Put.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n17
	}
	if m.ConditionalPut != nil {
		data[i] = 0x1a
		i++
		i = encodeVarintInternal(data, i, uint64(m.ConditionalPut.Size()))
		n18, err := m.ConditionalPut.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n18
	}
	if m.Increment != nil {
		data[i] = 0x22
		i++
		i = encodeVarintInternal(data, i, uint64(m.Increment.Size()))
		n19, err := m.Increment.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n19
	}
	if m.Delete != nil {
		data[i] = 0x2a
		i++
		i = encodeVarintInternal(data, i, uint64(m.Delete.Size()))
		n20, err := m.Delete.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n20
	}
	if m.DeleteRange != nil {
		data[i] = 0x32
		i++
		i = encodeVarintInternal(data, i, uint64(m.DeleteRange.Size()))
		n21, err := m.DeleteRange.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n21
	}
	if m.Scan != nil {
		data[i] = 0x3a
		i++
		i = encodeVarintInternal(data, i, uint64(m.Scan.Size()))
		n22, err := m.Scan.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n22
	}
	if m.EndTransaction != nil {
		data[i] = 0x42
		i++
		i = encodeVarintInternal(data, i, uint64(m.EndTransaction.Size()))
		n23, err := m.EndTransaction.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n23
	}
	if m.RangeLookup != nil {
		data[i] = 0x4a
		i++
		i = encodeVarintInternal(data, i, uint64(m.RangeLookup.Size()))
		n24, err := m.RangeLookup.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n24
	}
	if m.HeartbeatTxn != nil {
		data[i] = 0x52
		i++
		i = encodeVarintInternal(data, i, uint64(m.HeartbeatTxn.Size()))
		n25, err := m.HeartbeatTxn.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n25
	}
	if m.GC != nil {
		data[i] = 0x5a
		i++
		i = encodeVarintInternal(data, i, uint64(m.GC.Size()))
		n26, err := m.GC.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n26
	}
	if m.PushTxn != nil {
		data[i] = 0x62
		i++
		i = encodeVarintInternal(data, i, uint64(m.PushTxn.Size()))
		n27, err := m.PushTxn.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n27
	}
	if m.ResolveIntent != nil {
		data[i] = 0x6a
		i++
		i = encodeVarintInternal(data, i, uint64(m.ResolveIntent.Size()))
		n28, err := m.ResolveIntent.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n28
	}
	if m.ResolveIntentRange != nil {
		data[i] = 0x72
		i++
		i = encodeVarintInternal(data, i, uint64(m.ResolveIntentRange.Size()))
		n29, err := m.ResolveIntentRange.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n29
	}
	if m.MergeResponse != nil {
		data[i] = 0x7a
		i++
		i = encodeVarintInternal(data, i, uint64(m.MergeResponse.Size()))
		n30, err := m.MergeResponse.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n30
	}
	if m.TruncateLog != nil {
		data[i] = 0x82
		i++
		data[i] = 0x1
		i++
		i = encodeVarintInternal(data, i, uint64(m.TruncateLog.Size()))
		n31, err := m.TruncateLog.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n31
	}
	if m.Lease != nil {
		data[i] = 0x8a
		i++
		data[i] = 0x1
		i++
		i = encodeVarintInternal(data, i, uint64(m.Lease.Size()))
		n32, err := m.Lease.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n32
	}
	if m.ReverseScan != nil {
		data[i] = 0x92
		i++
		data[i] = 0x1
		i++
		i = encodeVarintInternal(data, i, uint64(m.ReverseScan.Size()))
		n33, err := m.ReverseScan.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n33
	}
	if m.Batch != nil {
		data[i] = 0xf2
		i++
		data[i] = 0x1
		i++
		i = encodeVarintInternal(data, i, uint64(m.Batch.Size()))
		n34, err := m.Batch.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n34
	}
	if m.XXX_unrecognized != nil {
		i += copy(data[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *RaftCommand) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *RaftCommand) MarshalTo(data []byte) (n int, err error) {
	var i int
	_ = i
	var l int
	_ = l
	data[i] = 0x8
	i++
	i = encodeVarintInternal(data, i, uint64(m.RangeID))
	data[i] = 0x10
	i++
	i = encodeVarintInternal(data, i, uint64(m.OriginNodeID))
	data[i] = 0x1a
	i++
	i = encodeVarintInternal(data, i, uint64(m.Cmd.Size()))
	n35, err := m.Cmd.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n35
	if m.XXX_unrecognized != nil {
		i += copy(data[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *RaftMessageRequest) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *RaftMessageRequest) MarshalTo(data []byte) (n int, err error) {
	var i int
	_ = i
	var l int
	_ = l
	data[i] = 0x8
	i++
	i = encodeVarintInternal(data, i, uint64(m.GroupID))
	if m.Msg != nil {
		data[i] = 0x12
		i++
		i = encodeVarintInternal(data, i, uint64(len(m.Msg)))
		i += copy(data[i:], m.Msg)
	}
	if m.XXX_unrecognized != nil {
		i += copy(data[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *RaftMessageResponse) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *RaftMessageResponse) MarshalTo(data []byte) (n int, err error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i += copy(data[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *InternalTimeSeriesData) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *InternalTimeSeriesData) MarshalTo(data []byte) (n int, err error) {
	var i int
	_ = i
	var l int
	_ = l
	data[i] = 0x8
	i++
	i = encodeVarintInternal(data, i, uint64(m.StartTimestampNanos))
	data[i] = 0x10
	i++
	i = encodeVarintInternal(data, i, uint64(m.SampleDurationNanos))
	if len(m.Samples) > 0 {
		for _, msg := range m.Samples {
			data[i] = 0x1a
			i++
			i = encodeVarintInternal(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(data[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *InternalTimeSeriesSample) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *InternalTimeSeriesSample) MarshalTo(data []byte) (n int, err error) {
	var i int
	_ = i
	var l int
	_ = l
	data[i] = 0x8
	i++
	i = encodeVarintInternal(data, i, uint64(m.Offset))
	data[i] = 0x30
	i++
	i = encodeVarintInternal(data, i, uint64(m.Count))
	data[i] = 0x39
	i++
	i = encodeFixed64Internal(data, i, uint64(math.Float64bits(m.Sum)))
	if m.Max != nil {
		data[i] = 0x41
		i++
		i = encodeFixed64Internal(data, i, uint64(math.Float64bits(*m.Max)))
	}
	if m.Min != nil {
		data[i] = 0x49
		i++
		i = encodeFixed64Internal(data, i, uint64(math.Float64bits(*m.Min)))
	}
	if m.XXX_unrecognized != nil {
		i += copy(data[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *RaftTruncatedState) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *RaftTruncatedState) MarshalTo(data []byte) (n int, err error) {
	var i int
	_ = i
	var l int
	_ = l
	data[i] = 0x8
	i++
	i = encodeVarintInternal(data, i, uint64(m.Index))
	data[i] = 0x10
	i++
	i = encodeVarintInternal(data, i, uint64(m.Term))
	if m.XXX_unrecognized != nil {
		i += copy(data[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *RaftSnapshotData) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *RaftSnapshotData) MarshalTo(data []byte) (n int, err error) {
	var i int
	_ = i
	var l int
	_ = l
	data[i] = 0xa
	i++
	i = encodeVarintInternal(data, i, uint64(m.RangeDescriptor.Size()))
	n36, err := m.RangeDescriptor.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n36
	if len(m.KV) > 0 {
		for _, msg := range m.KV {
			data[i] = 0x12
			i++
			i = encodeVarintInternal(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(data[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *RaftSnapshotData_KeyValue) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *RaftSnapshotData_KeyValue) MarshalTo(data []byte) (n int, err error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Key != nil {
		data[i] = 0xa
		i++
		i = encodeVarintInternal(data, i, uint64(len(m.Key)))
		i += copy(data[i:], m.Key)
	}
	if m.Value != nil {
		data[i] = 0x12
		i++
		i = encodeVarintInternal(data, i, uint64(len(m.Value)))
		i += copy(data[i:], m.Value)
	}
	if m.XXX_unrecognized != nil {
		i += copy(data[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func encodeFixed64Internal(data []byte, offset int, v uint64) int {
	data[offset] = uint8(v)
	data[offset+1] = uint8(v >> 8)
	data[offset+2] = uint8(v >> 16)
	data[offset+3] = uint8(v >> 24)
	data[offset+4] = uint8(v >> 32)
	data[offset+5] = uint8(v >> 40)
	data[offset+6] = uint8(v >> 48)
	data[offset+7] = uint8(v >> 56)
	return offset + 8
}
func encodeFixed32Internal(data []byte, offset int, v uint32) int {
	data[offset] = uint8(v)
	data[offset+1] = uint8(v >> 8)
	data[offset+2] = uint8(v >> 16)
	data[offset+3] = uint8(v >> 24)
	return offset + 4
}
func encodeVarintInternal(data []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		data[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	data[offset] = uint8(v)
	return offset + 1
}
