// Code generated by protoc-gen-gogo.
// source: cockroach/proto/internal.proto
// DO NOT EDIT!

package proto

import proto1 "github.com/gogo/protobuf/proto"
import math "math"

// discarding unused import gogoproto "gogoproto/gogo.pb"

import io "io"
import fmt "fmt"
import github_com_gogo_protobuf_proto "github.com/gogo/protobuf/proto"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto1.Marshal
var _ = math.Inf

// InternalValueType defines a set of string constants placed in the "tag" field
// of Value messages which are created internally. These are defined as a
// protocol buffer enumeration so that they can be used portably between our Go
// and C code.
type InternalValueType int32

const (
	// _CR_TS is applied to values which contain InternalTimeSeriesData. This
	// tag is used by the RocksDB Merge Operator to perform a specialized merge
	// for this data.
	_CR_TS InternalValueType = 1
)

var InternalValueType_name = map[int32]string{
	1: "_CR_TS",
}
var InternalValueType_value = map[string]int32{
	"_CR_TS": 1,
}

func (x InternalValueType) Enum() *InternalValueType {
	p := new(InternalValueType)
	*p = x
	return p
}
func (x InternalValueType) String() string {
	return proto1.EnumName(InternalValueType_name, int32(x))
}
func (x *InternalValueType) UnmarshalJSON(data []byte) error {
	value, err := proto1.UnmarshalJSONEnum(InternalValueType_value, data, "InternalValueType")
	if err != nil {
		return err
	}
	*x = InternalValueType(value)
	return nil
}

// An InternalRangeLookupRequest is arguments to the
// InternalRangeLookup() method. It specifies the key for which the
// containing range is being requested, and the maximum number of
// total range descriptors that should be returned, if there are
// additional consecutive addressable ranges. Specify max_ranges > 1
// to pre-fill the range descriptor cache.
type InternalRangeLookupRequest struct {
	RequestHeader    `protobuf:"bytes,1,opt,name=header,embedded=header" json:"header"`
	MaxRanges        int32  `protobuf:"varint,2,opt,name=max_ranges" json:"max_ranges"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *InternalRangeLookupRequest) Reset()         { *m = InternalRangeLookupRequest{} }
func (m *InternalRangeLookupRequest) String() string { return proto1.CompactTextString(m) }
func (*InternalRangeLookupRequest) ProtoMessage()    {}

func (m *InternalRangeLookupRequest) GetMaxRanges() int32 {
	if m != nil {
		return m.MaxRanges
	}
	return 0
}

// An InternalRangeLookupResponse is the return value from the
// InternalRangeLookup() method. It returns metadata for the range
// containing the requested key, optionally returning the metadata for
// additional consecutive ranges beyond the requested range to pre-fill
// the range descriptor cache.
type InternalRangeLookupResponse struct {
	ResponseHeader   `protobuf:"bytes,1,opt,name=header,embedded=header" json:"header"`
	Ranges           []RangeDescriptor `protobuf:"bytes,2,rep,name=ranges" json:"ranges"`
	XXX_unrecognized []byte            `json:"-"`
}

func (m *InternalRangeLookupResponse) Reset()         { *m = InternalRangeLookupResponse{} }
func (m *InternalRangeLookupResponse) String() string { return proto1.CompactTextString(m) }
func (*InternalRangeLookupResponse) ProtoMessage()    {}

func (m *InternalRangeLookupResponse) GetRanges() []RangeDescriptor {
	if m != nil {
		return m.Ranges
	}
	return nil
}

// An InternalHeartbeatTxnRequest is arguments to the
// InternalHeartbeatTxn() method. It's sent by transaction
// coordinators to let the system know that the transaction is still
// ongoing. Note that this heartbeat message is different from the
// heartbeat message in the gossip protocol.
type InternalHeartbeatTxnRequest struct {
	RequestHeader    `protobuf:"bytes,1,opt,name=header,embedded=header" json:"header"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *InternalHeartbeatTxnRequest) Reset()         { *m = InternalHeartbeatTxnRequest{} }
func (m *InternalHeartbeatTxnRequest) String() string { return proto1.CompactTextString(m) }
func (*InternalHeartbeatTxnRequest) ProtoMessage()    {}

// An InternalHeartbeatTxnResponse is the return value from the
// InternalHeartbeatTxn() method. It returns the transaction info in
// the response header. The returned transaction lets the coordinator
// know the disposition of the transaction (i.e. aborted, committed or
// pending).
type InternalHeartbeatTxnResponse struct {
	ResponseHeader   `protobuf:"bytes,1,opt,name=header,embedded=header" json:"header"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *InternalHeartbeatTxnResponse) Reset()         { *m = InternalHeartbeatTxnResponse{} }
func (m *InternalHeartbeatTxnResponse) String() string { return proto1.CompactTextString(m) }
func (*InternalHeartbeatTxnResponse) ProtoMessage()    {}

// An InternalGCRequest is arguments to the InternalGC() method. It's
// sent by range leaders after scanning range data to find expired
// MVCC values.
type InternalGCRequest struct {
	RequestHeader    `protobuf:"bytes,1,opt,name=header,embedded=header" json:"header"`
	GCMeta           GCMetadata                `protobuf:"bytes,2,opt,name=gc_meta" json:"gc_meta"`
	Keys             []InternalGCRequest_GCKey `protobuf:"bytes,3,rep,name=keys" json:"keys"`
	XXX_unrecognized []byte                    `json:"-"`
}

func (m *InternalGCRequest) Reset()         { *m = InternalGCRequest{} }
func (m *InternalGCRequest) String() string { return proto1.CompactTextString(m) }
func (*InternalGCRequest) ProtoMessage()    {}

func (m *InternalGCRequest) GetGCMeta() GCMetadata {
	if m != nil {
		return m.GCMeta
	}
	return GCMetadata{}
}

func (m *InternalGCRequest) GetKeys() []InternalGCRequest_GCKey {
	if m != nil {
		return m.Keys
	}
	return nil
}

type InternalGCRequest_GCKey struct {
	Key              Key       `protobuf:"bytes,1,opt,name=key,customtype=Key" json:"key"`
	Timestamp        Timestamp `protobuf:"bytes,2,opt,name=timestamp" json:"timestamp"`
	XXX_unrecognized []byte    `json:"-"`
}

func (m *InternalGCRequest_GCKey) Reset()         { *m = InternalGCRequest_GCKey{} }
func (m *InternalGCRequest_GCKey) String() string { return proto1.CompactTextString(m) }
func (*InternalGCRequest_GCKey) ProtoMessage()    {}

func (m *InternalGCRequest_GCKey) GetTimestamp() Timestamp {
	if m != nil {
		return m.Timestamp
	}
	return Timestamp{}
}

// An InternalGCResponse is the return value from the InternalGC()
// method.
type InternalGCResponse struct {
	ResponseHeader   `protobuf:"bytes,1,opt,name=header,embedded=header" json:"header"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *InternalGCResponse) Reset()         { *m = InternalGCResponse{} }
func (m *InternalGCResponse) String() string { return proto1.CompactTextString(m) }
func (*InternalGCResponse) ProtoMessage()    {}

// An InternalPushTxnRequest is arguments to the InternalPushTxn()
// method. It's sent by readers or writers which have encountered an
// "intent" laid down by another transaction. The goal is to resolve
// the conflict. Note that args.Key should be set to the txn ID of
// args.PusheeTxn, not args.Txn, as is usual. This RPC is addressed
// to the range which owns the pushee's txn record.
//
// Resolution is trivial if the txn which owns the intent has either
// been committed or aborted already. Otherwise, the existing txn can
// either be aborted (for write/write conflicts), or its commit
// timestamp can be moved forward (for read/write conflicts). The
// course of action is determined by the owning txn's status and also
// by comparing priorities.
type InternalPushTxnRequest struct {
	RequestHeader `protobuf:"bytes,1,opt,name=header,embedded=header" json:"header"`
	PusheeTxn     Transaction `protobuf:"bytes,2,opt,name=pushee_txn" json:"pushee_txn"`
	// Set to true to request that the PushTxn be aborted if possible.
	// This is done in the event of a writer conflicting with PusheeTxn.
	// Readers set this to false and instead attempt to move PusheeTxn's
	// commit timestamp forward.
	Abort            bool   `protobuf:"varint,3,opt" json:"Abort"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *InternalPushTxnRequest) Reset()         { *m = InternalPushTxnRequest{} }
func (m *InternalPushTxnRequest) String() string { return proto1.CompactTextString(m) }
func (*InternalPushTxnRequest) ProtoMessage()    {}

func (m *InternalPushTxnRequest) GetPusheeTxn() Transaction {
	if m != nil {
		return m.PusheeTxn
	}
	return Transaction{}
}

func (m *InternalPushTxnRequest) GetAbort() bool {
	if m != nil {
		return m.Abort
	}
	return false
}

// An InternalPushTxnResponse is the return value from the
// InternalPushTxn() method. It returns success and the resulting
// state of PusheeTxn if the conflict was resolved in favor of the
// caller; the caller should subsequently invoke
// InternalResolveIntent() on the conflicted key. It returns an error
// otherwise.
type InternalPushTxnResponse struct {
	ResponseHeader `protobuf:"bytes,1,opt,name=header,embedded=header" json:"header"`
	// Txn is non-nil if the transaction could be heartbeat and contains
	// the current value of the transaction.
	PusheeTxn        *Transaction `protobuf:"bytes,2,opt,name=pushee_txn" json:"pushee_txn,omitempty"`
	XXX_unrecognized []byte       `json:"-"`
}

func (m *InternalPushTxnResponse) Reset()         { *m = InternalPushTxnResponse{} }
func (m *InternalPushTxnResponse) String() string { return proto1.CompactTextString(m) }
func (*InternalPushTxnResponse) ProtoMessage()    {}

func (m *InternalPushTxnResponse) GetPusheeTxn() *Transaction {
	if m != nil {
		return m.PusheeTxn
	}
	return nil
}

// An InternalResolveIntentRequest is arguments to the
// InternalResolveIntent() method. It is sent by transaction
// coordinators and after success calling InternalPushTxn to clean up
// write intents: either to remove them or commit them.
type InternalResolveIntentRequest struct {
	RequestHeader    `protobuf:"bytes,1,opt,name=header,embedded=header" json:"header"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *InternalResolveIntentRequest) Reset()         { *m = InternalResolveIntentRequest{} }
func (m *InternalResolveIntentRequest) String() string { return proto1.CompactTextString(m) }
func (*InternalResolveIntentRequest) ProtoMessage()    {}

// An InternalResolveIntentResponse is the return value from the
// InternalResolveIntent() method.
type InternalResolveIntentResponse struct {
	ResponseHeader   `protobuf:"bytes,1,opt,name=header,embedded=header" json:"header"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *InternalResolveIntentResponse) Reset()         { *m = InternalResolveIntentResponse{} }
func (m *InternalResolveIntentResponse) String() string { return proto1.CompactTextString(m) }
func (*InternalResolveIntentResponse) ProtoMessage()    {}

// An InternalMergeRequest contains arguments to the InternalMerge() method. It
// specifies a key and a value which should be merged into the existing value at
// that key.
type InternalMergeRequest struct {
	RequestHeader    `protobuf:"bytes,1,opt,name=header,embedded=header" json:"header"`
	Value            Value  `protobuf:"bytes,2,opt,name=value" json:"value"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *InternalMergeRequest) Reset()         { *m = InternalMergeRequest{} }
func (m *InternalMergeRequest) String() string { return proto1.CompactTextString(m) }
func (*InternalMergeRequest) ProtoMessage()    {}

func (m *InternalMergeRequest) GetValue() Value {
	if m != nil {
		return m.Value
	}
	return Value{}
}

// InternalMergeResponse is the response to an InternalMerge() operation.
type InternalMergeResponse struct {
	ResponseHeader   `protobuf:"bytes,1,opt,name=header,embedded=header" json:"header"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *InternalMergeResponse) Reset()         { *m = InternalMergeResponse{} }
func (m *InternalMergeResponse) String() string { return proto1.CompactTextString(m) }
func (*InternalMergeResponse) ProtoMessage()    {}

// InternalTruncateLogRequest is used to remove a prefix of the raft log. While there
// is no requirement for correctness that the raft log truncation be synchronized across
// replicas, it is nice to preserve the property that all replicas of a range are as close
// to identical as possible. The raft leader can also inform decisions about the cutoff point
// with its knowledge of the replicas' acknowledgement status.
type InternalTruncateLogRequest struct {
	RequestHeader `protobuf:"bytes,1,opt,name=header,embedded=header" json:"header"`
	// Log entries < this index are to be discarded.
	Index            uint64 `protobuf:"varint,2,opt,name=index" json:"index"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *InternalTruncateLogRequest) Reset()         { *m = InternalTruncateLogRequest{} }
func (m *InternalTruncateLogRequest) String() string { return proto1.CompactTextString(m) }
func (*InternalTruncateLogRequest) ProtoMessage()    {}

func (m *InternalTruncateLogRequest) GetIndex() uint64 {
	if m != nil {
		return m.Index
	}
	return 0
}

// InternalTruncateLogResponse is the response to an InternalTruncateLog() operation.
type InternalTruncateLogResponse struct {
	ResponseHeader   `protobuf:"bytes,1,opt,name=header,embedded=header" json:"header"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *InternalTruncateLogResponse) Reset()         { *m = InternalTruncateLogResponse{} }
func (m *InternalTruncateLogResponse) String() string { return proto1.CompactTextString(m) }
func (*InternalTruncateLogResponse) ProtoMessage()    {}

// A ReadWriteCmdResponse is a union type containing instances of all
// mutating commands. Note that any entry added here must be handled
// in storage/engine/db.cc in GetResponseHeader().
type ReadWriteCmdResponse struct {
	Put                   *PutResponse                   `protobuf:"bytes,1,opt,name=put" json:"put,omitempty"`
	ConditionalPut        *ConditionalPutResponse        `protobuf:"bytes,2,opt,name=conditional_put" json:"conditional_put,omitempty"`
	Increment             *IncrementResponse             `protobuf:"bytes,3,opt,name=increment" json:"increment,omitempty"`
	Delete                *DeleteResponse                `protobuf:"bytes,4,opt,name=delete" json:"delete,omitempty"`
	DeleteRange           *DeleteRangeResponse           `protobuf:"bytes,5,opt,name=delete_range" json:"delete_range,omitempty"`
	EndTransaction        *EndTransactionResponse        `protobuf:"bytes,6,opt,name=end_transaction" json:"end_transaction,omitempty"`
	ReapQueue             *ReapQueueResponse             `protobuf:"bytes,7,opt,name=reap_queue" json:"reap_queue,omitempty"`
	EnqueueUpdate         *EnqueueUpdateResponse         `protobuf:"bytes,8,opt,name=enqueue_update" json:"enqueue_update,omitempty"`
	EnqueueMessage        *EnqueueMessageResponse        `protobuf:"bytes,9,opt,name=enqueue_message" json:"enqueue_message,omitempty"`
	InternalHeartbeatTxn  *InternalHeartbeatTxnResponse  `protobuf:"bytes,10,opt,name=internal_heartbeat_txn" json:"internal_heartbeat_txn,omitempty"`
	InternalPushTxn       *InternalPushTxnResponse       `protobuf:"bytes,11,opt,name=internal_push_txn" json:"internal_push_txn,omitempty"`
	InternalResolveIntent *InternalResolveIntentResponse `protobuf:"bytes,12,opt,name=internal_resolve_intent" json:"internal_resolve_intent,omitempty"`
	InternalMerge         *InternalMergeResponse         `protobuf:"bytes,13,opt,name=internal_merge" json:"internal_merge,omitempty"`
	InternalTruncateLog   *InternalTruncateLogResponse   `protobuf:"bytes,14,opt,name=internal_truncate_log" json:"internal_truncate_log,omitempty"`
	InternalGc            *InternalGCResponse            `protobuf:"bytes,15,opt,name=internal_gc" json:"internal_gc,omitempty"`
	XXX_unrecognized      []byte                         `json:"-"`
}

func (m *ReadWriteCmdResponse) Reset()         { *m = ReadWriteCmdResponse{} }
func (m *ReadWriteCmdResponse) String() string { return proto1.CompactTextString(m) }
func (*ReadWriteCmdResponse) ProtoMessage()    {}

func (m *ReadWriteCmdResponse) GetPut() *PutResponse {
	if m != nil {
		return m.Put
	}
	return nil
}

func (m *ReadWriteCmdResponse) GetConditionalPut() *ConditionalPutResponse {
	if m != nil {
		return m.ConditionalPut
	}
	return nil
}

func (m *ReadWriteCmdResponse) GetIncrement() *IncrementResponse {
	if m != nil {
		return m.Increment
	}
	return nil
}

func (m *ReadWriteCmdResponse) GetDelete() *DeleteResponse {
	if m != nil {
		return m.Delete
	}
	return nil
}

func (m *ReadWriteCmdResponse) GetDeleteRange() *DeleteRangeResponse {
	if m != nil {
		return m.DeleteRange
	}
	return nil
}

func (m *ReadWriteCmdResponse) GetEndTransaction() *EndTransactionResponse {
	if m != nil {
		return m.EndTransaction
	}
	return nil
}

func (m *ReadWriteCmdResponse) GetReapQueue() *ReapQueueResponse {
	if m != nil {
		return m.ReapQueue
	}
	return nil
}

func (m *ReadWriteCmdResponse) GetEnqueueUpdate() *EnqueueUpdateResponse {
	if m != nil {
		return m.EnqueueUpdate
	}
	return nil
}

func (m *ReadWriteCmdResponse) GetEnqueueMessage() *EnqueueMessageResponse {
	if m != nil {
		return m.EnqueueMessage
	}
	return nil
}

func (m *ReadWriteCmdResponse) GetInternalHeartbeatTxn() *InternalHeartbeatTxnResponse {
	if m != nil {
		return m.InternalHeartbeatTxn
	}
	return nil
}

func (m *ReadWriteCmdResponse) GetInternalPushTxn() *InternalPushTxnResponse {
	if m != nil {
		return m.InternalPushTxn
	}
	return nil
}

func (m *ReadWriteCmdResponse) GetInternalResolveIntent() *InternalResolveIntentResponse {
	if m != nil {
		return m.InternalResolveIntent
	}
	return nil
}

func (m *ReadWriteCmdResponse) GetInternalMerge() *InternalMergeResponse {
	if m != nil {
		return m.InternalMerge
	}
	return nil
}

func (m *ReadWriteCmdResponse) GetInternalTruncateLog() *InternalTruncateLogResponse {
	if m != nil {
		return m.InternalTruncateLog
	}
	return nil
}

func (m *ReadWriteCmdResponse) GetInternalGc() *InternalGCResponse {
	if m != nil {
		return m.InternalGc
	}
	return nil
}

// An InternalRaftCommandUnion is the union of all commands which can be
// sent via raft.
type InternalRaftCommandUnion struct {
	// Non-batched external requests. This section is the same as RequestUnion.
	Contains       *ContainsRequest       `protobuf:"bytes,1,opt,name=contains" json:"contains,omitempty"`
	Get            *GetRequest            `protobuf:"bytes,2,opt,name=get" json:"get,omitempty"`
	Put            *PutRequest            `protobuf:"bytes,3,opt,name=put" json:"put,omitempty"`
	ConditionalPut *ConditionalPutRequest `protobuf:"bytes,4,opt,name=conditional_put" json:"conditional_put,omitempty"`
	Increment      *IncrementRequest      `protobuf:"bytes,5,opt,name=increment" json:"increment,omitempty"`
	Delete         *DeleteRequest         `protobuf:"bytes,6,opt,name=delete" json:"delete,omitempty"`
	DeleteRange    *DeleteRangeRequest    `protobuf:"bytes,7,opt,name=delete_range" json:"delete_range,omitempty"`
	Scan           *ScanRequest           `protobuf:"bytes,8,opt,name=scan" json:"scan,omitempty"`
	EndTransaction *EndTransactionRequest `protobuf:"bytes,9,opt,name=end_transaction" json:"end_transaction,omitempty"`
	ReapQueue      *ReapQueueRequest      `protobuf:"bytes,10,opt,name=reap_queue" json:"reap_queue,omitempty"`
	EnqueueUpdate  *EnqueueUpdateRequest  `protobuf:"bytes,11,opt,name=enqueue_update" json:"enqueue_update,omitempty"`
	EnqueueMessage *EnqueueMessageRequest `protobuf:"bytes,12,opt,name=enqueue_message" json:"enqueue_message,omitempty"`
	// Other requests. Allow a gap in tag numbers so the previous list can
	// be copy/pasted from RequestUnion.
	Batch                 *BatchRequest                 `protobuf:"bytes,30,opt,name=batch" json:"batch,omitempty"`
	InternalRangeLookup   *InternalRangeLookupRequest   `protobuf:"bytes,31,opt,name=internal_range_lookup" json:"internal_range_lookup,omitempty"`
	InternalHeartbeatTxn  *InternalHeartbeatTxnRequest  `protobuf:"bytes,32,opt,name=internal_heartbeat_txn" json:"internal_heartbeat_txn,omitempty"`
	InternalPushTxn       *InternalPushTxnRequest       `protobuf:"bytes,33,opt,name=internal_push_txn" json:"internal_push_txn,omitempty"`
	InternalResolveIntent *InternalResolveIntentRequest `protobuf:"bytes,34,opt,name=internal_resolve_intent" json:"internal_resolve_intent,omitempty"`
	InternalMergeResponse *InternalMergeRequest         `protobuf:"bytes,35,opt,name=internal_merge_response" json:"internal_merge_response,omitempty"`
	InternalTruncateLog   *InternalTruncateLogRequest   `protobuf:"bytes,36,opt,name=internal_truncate_log" json:"internal_truncate_log,omitempty"`
	InternalGc            *InternalGCRequest            `protobuf:"bytes,37,opt,name=internal_gc" json:"internal_gc,omitempty"`
	XXX_unrecognized      []byte                        `json:"-"`
}

func (m *InternalRaftCommandUnion) Reset()         { *m = InternalRaftCommandUnion{} }
func (m *InternalRaftCommandUnion) String() string { return proto1.CompactTextString(m) }
func (*InternalRaftCommandUnion) ProtoMessage()    {}

func (m *InternalRaftCommandUnion) GetContains() *ContainsRequest {
	if m != nil {
		return m.Contains
	}
	return nil
}

func (m *InternalRaftCommandUnion) GetGet() *GetRequest {
	if m != nil {
		return m.Get
	}
	return nil
}

func (m *InternalRaftCommandUnion) GetPut() *PutRequest {
	if m != nil {
		return m.Put
	}
	return nil
}

func (m *InternalRaftCommandUnion) GetConditionalPut() *ConditionalPutRequest {
	if m != nil {
		return m.ConditionalPut
	}
	return nil
}

func (m *InternalRaftCommandUnion) GetIncrement() *IncrementRequest {
	if m != nil {
		return m.Increment
	}
	return nil
}

func (m *InternalRaftCommandUnion) GetDelete() *DeleteRequest {
	if m != nil {
		return m.Delete
	}
	return nil
}

func (m *InternalRaftCommandUnion) GetDeleteRange() *DeleteRangeRequest {
	if m != nil {
		return m.DeleteRange
	}
	return nil
}

func (m *InternalRaftCommandUnion) GetScan() *ScanRequest {
	if m != nil {
		return m.Scan
	}
	return nil
}

func (m *InternalRaftCommandUnion) GetEndTransaction() *EndTransactionRequest {
	if m != nil {
		return m.EndTransaction
	}
	return nil
}

func (m *InternalRaftCommandUnion) GetReapQueue() *ReapQueueRequest {
	if m != nil {
		return m.ReapQueue
	}
	return nil
}

func (m *InternalRaftCommandUnion) GetEnqueueUpdate() *EnqueueUpdateRequest {
	if m != nil {
		return m.EnqueueUpdate
	}
	return nil
}

func (m *InternalRaftCommandUnion) GetEnqueueMessage() *EnqueueMessageRequest {
	if m != nil {
		return m.EnqueueMessage
	}
	return nil
}

func (m *InternalRaftCommandUnion) GetBatch() *BatchRequest {
	if m != nil {
		return m.Batch
	}
	return nil
}

func (m *InternalRaftCommandUnion) GetInternalRangeLookup() *InternalRangeLookupRequest {
	if m != nil {
		return m.InternalRangeLookup
	}
	return nil
}

func (m *InternalRaftCommandUnion) GetInternalHeartbeatTxn() *InternalHeartbeatTxnRequest {
	if m != nil {
		return m.InternalHeartbeatTxn
	}
	return nil
}

func (m *InternalRaftCommandUnion) GetInternalPushTxn() *InternalPushTxnRequest {
	if m != nil {
		return m.InternalPushTxn
	}
	return nil
}

func (m *InternalRaftCommandUnion) GetInternalResolveIntent() *InternalResolveIntentRequest {
	if m != nil {
		return m.InternalResolveIntent
	}
	return nil
}

func (m *InternalRaftCommandUnion) GetInternalMergeResponse() *InternalMergeRequest {
	if m != nil {
		return m.InternalMergeResponse
	}
	return nil
}

func (m *InternalRaftCommandUnion) GetInternalTruncateLog() *InternalTruncateLogRequest {
	if m != nil {
		return m.InternalTruncateLog
	}
	return nil
}

func (m *InternalRaftCommandUnion) GetInternalGc() *InternalGCRequest {
	if m != nil {
		return m.InternalGc
	}
	return nil
}

// An InternalRaftCommand is a command which can be serialized and
// sent via raft.
type InternalRaftCommand struct {
	RaftID           int64                    `protobuf:"varint,2,opt,name=raft_id" json:"raft_id"`
	Cmd              InternalRaftCommandUnion `protobuf:"bytes,3,opt,name=cmd" json:"cmd"`
	XXX_unrecognized []byte                   `json:"-"`
}

func (m *InternalRaftCommand) Reset()         { *m = InternalRaftCommand{} }
func (m *InternalRaftCommand) String() string { return proto1.CompactTextString(m) }
func (*InternalRaftCommand) ProtoMessage()    {}

func (m *InternalRaftCommand) GetRaftID() int64 {
	if m != nil {
		return m.RaftID
	}
	return 0
}

func (m *InternalRaftCommand) GetCmd() InternalRaftCommandUnion {
	if m != nil {
		return m.Cmd
	}
	return InternalRaftCommandUnion{}
}

// RaftMessageRequest is the request used to send raft messages using our
// protobuf-based RPC codec. Unlike most of the requests defined in this file
// and api.proto, this one is implemented in a separate service defined in
// server/transport.go.
//
// This is the equivalent of the non-protobuf multiraft.RaftMessageRequest.
type RaftMessageRequest struct {
	GroupID uint64 `protobuf:"varint,1,opt,name=group_id" json:"group_id"`
	// The raft payload, an encoded raftpb.Message. We transmit the message as
	// an opaque blob to avoid the complexity of importing proto files across
	// packages.
	Msg              []byte `protobuf:"bytes,2,opt,name=msg" json:"msg,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *RaftMessageRequest) Reset()         { *m = RaftMessageRequest{} }
func (m *RaftMessageRequest) String() string { return proto1.CompactTextString(m) }
func (*RaftMessageRequest) ProtoMessage()    {}

func (m *RaftMessageRequest) GetGroupID() uint64 {
	if m != nil {
		return m.GroupID
	}
	return 0
}

func (m *RaftMessageRequest) GetMsg() []byte {
	if m != nil {
		return m.Msg
	}
	return nil
}

// RaftMessageResponse is an empty message returned by raft RPCs.
type RaftMessageResponse struct {
	XXX_unrecognized []byte `json:"-"`
}

func (m *RaftMessageResponse) Reset()         { *m = RaftMessageResponse{} }
func (m *RaftMessageResponse) String() string { return proto1.CompactTextString(m) }
func (*RaftMessageResponse) ProtoMessage()    {}

// InternalTimeSeriesData is a collection of data samples for some measurable
// value, where each sample is taken over a uniform time interval.
//
// The collection itself contains a start timestamp (in seconds since the unix
// epoch) and a sample duration (in milliseconds). Each sample in the collection
// will contain a positive integer offset that indicates the length of time
// between the start_timestamp of the collection and the time when the sample
// began, expressed as an whole number of sample intervals. For example, if the
// sample duration is 60000 (indicating 1 minute), then a contained sample with
// an offset value of 5 begins (5*60000ms = 300000ms = 5 minutes) after the
// start timestamp of this data.
//
// This is meant to be an efficient internal representation of time series data,
// ensuring that very little redundant data is stored on disk. With this goal in
// mind, this message does not identify the variable which is actually being
// measured; that information is expected be encoded in the key where this
// message is stored.
type InternalTimeSeriesData struct {
	// Holds a wall time, expressed as a unix epoch time in nanoseconds. This
	// represents the earliest possible timestamp for a sample within the
	// collection.
	StartTimestampNanos int64 `protobuf:"varint,1,opt,name=start_timestamp_nanos" json:"start_timestamp_nanos"`
	// The duration of each sample interval, expressed in nanoseconds.
	SampleDurationNanos int64 `protobuf:"varint,2,opt,name=sample_duration_nanos" json:"sample_duration_nanos"`
	// The actual data samples for this metric.
	Samples          []*InternalTimeSeriesSample `protobuf:"bytes,3,rep,name=samples" json:"samples,omitempty"`
	XXX_unrecognized []byte                      `json:"-"`
}

func (m *InternalTimeSeriesData) Reset()         { *m = InternalTimeSeriesData{} }
func (m *InternalTimeSeriesData) String() string { return proto1.CompactTextString(m) }
func (*InternalTimeSeriesData) ProtoMessage()    {}

func (m *InternalTimeSeriesData) GetStartTimestampNanos() int64 {
	if m != nil {
		return m.StartTimestampNanos
	}
	return 0
}

func (m *InternalTimeSeriesData) GetSampleDurationNanos() int64 {
	if m != nil {
		return m.SampleDurationNanos
	}
	return 0
}

func (m *InternalTimeSeriesData) GetSamples() []*InternalTimeSeriesSample {
	if m != nil {
		return m.Samples
	}
	return nil
}

// A InternalTimeSeriesSample represents data gathered from multiple
// measurements of a variable value over a given period of time. The length of
// that period of time is stored in an InternalTimeSeriesData message; a sample
// cannot be interpreted correctly without a start timestamp and sample
// duration.
//
// Each sample may contain data gathered from multiple measurements of the same
// variable, as long as all of those measurements occured within the sample
// period. The sample stores several aggregated values from these measurements:
// - The sum of all measured values
// - A count of all measurements taken
// - The maximum individual measurement seen
// - The minimum individual measurement seen
//
// If zero measurements are present in a sample, then it should be omitted
// entirely from any collection it would be a part of.
//
// If the count of measurements is 1, then max and min fields may be omitted
// and assumed equal to the sum field.
//
// The variable being measured may be either an integer or a floating point;
// therefore, there are two fields each for "sum", "max" and "min" to hold
// either an integer or floating point number. In practice, only one set of
// these fields should be present for any individual sample; however, int and
// float values are recorded in parallel, allowing clients to write both floats
// and integers to the same value. These are recorded separately to retain
// precision, but are easily combined by higher-level logic at query time.
type InternalTimeSeriesSample struct {
	// Temporal offset from the "start_timestamp" of the InternalTimeSeriesData
	// collection this data point is part in. The units of this value are
	// determined by the value of the "sample_duration_milliseconds" field of
	// the TimeSeriesData collection.
	Offset int32 `protobuf:"varint,1,opt,name=offset" json:"offset"`
	// Count of integer measurements taken within this sample.
	IntCount uint32 `protobuf:"varint,2,opt,name=int_count" json:"int_count"`
	// Sum of all integer measurements.
	IntSum *int64 `protobuf:"varint,3,opt,name=int_sum" json:"int_sum,omitempty"`
	// Maximum encountered integer measurement in this sample.
	IntMax *int64 `protobuf:"varint,4,opt,name=int_max" json:"int_max,omitempty"`
	// Minimum encountered integer measurement in this sample.
	IntMin *int64 `protobuf:"varint,5,opt,name=int_min" json:"int_min,omitempty"`
	// Count of floating point measurements taken within this sample.
	FloatCount uint32 `protobuf:"varint,6,opt,name=float_count" json:"float_count"`
	// Sum of all floating point measurements.
	FloatSum *float32 `protobuf:"fixed32,7,opt,name=float_sum" json:"float_sum,omitempty"`
	// Maximum encountered floating point measurement in this sample.
	FloatMax *float32 `protobuf:"fixed32,8,opt,name=float_max" json:"float_max,omitempty"`
	// Minimum encountered floating point measurement in this sample.
	FloatMin         *float32 `protobuf:"fixed32,9,opt,name=float_min" json:"float_min,omitempty"`
	XXX_unrecognized []byte   `json:"-"`
}

func (m *InternalTimeSeriesSample) Reset()         { *m = InternalTimeSeriesSample{} }
func (m *InternalTimeSeriesSample) String() string { return proto1.CompactTextString(m) }
func (*InternalTimeSeriesSample) ProtoMessage()    {}

func (m *InternalTimeSeriesSample) GetOffset() int32 {
	if m != nil {
		return m.Offset
	}
	return 0
}

func (m *InternalTimeSeriesSample) GetIntCount() uint32 {
	if m != nil {
		return m.IntCount
	}
	return 0
}

func (m *InternalTimeSeriesSample) GetIntSum() int64 {
	if m != nil && m.IntSum != nil {
		return *m.IntSum
	}
	return 0
}

func (m *InternalTimeSeriesSample) GetIntMax() int64 {
	if m != nil && m.IntMax != nil {
		return *m.IntMax
	}
	return 0
}

func (m *InternalTimeSeriesSample) GetIntMin() int64 {
	if m != nil && m.IntMin != nil {
		return *m.IntMin
	}
	return 0
}

func (m *InternalTimeSeriesSample) GetFloatCount() uint32 {
	if m != nil {
		return m.FloatCount
	}
	return 0
}

func (m *InternalTimeSeriesSample) GetFloatSum() float32 {
	if m != nil && m.FloatSum != nil {
		return *m.FloatSum
	}
	return 0
}

func (m *InternalTimeSeriesSample) GetFloatMax() float32 {
	if m != nil && m.FloatMax != nil {
		return *m.FloatMax
	}
	return 0
}

func (m *InternalTimeSeriesSample) GetFloatMin() float32 {
	if m != nil && m.FloatMin != nil {
		return *m.FloatMin
	}
	return 0
}

// RaftTruncatedState contains metadata about the truncated portion of the raft log.
// Raft requires access to the term of the last truncated log entry even after the
// rest of the entry has been discarded.
type RaftTruncatedState struct {
	// The highest index that has been removed from the log.
	Index uint64 `protobuf:"varint,1,opt,name=index" json:"index"`
	// The term corresponding to 'index'.
	Term             uint64 `protobuf:"varint,2,opt,name=term" json:"term"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *RaftTruncatedState) Reset()         { *m = RaftTruncatedState{} }
func (m *RaftTruncatedState) String() string { return proto1.CompactTextString(m) }
func (*RaftTruncatedState) ProtoMessage()    {}

func (m *RaftTruncatedState) GetIndex() uint64 {
	if m != nil {
		return m.Index
	}
	return 0
}

func (m *RaftTruncatedState) GetTerm() uint64 {
	if m != nil {
		return m.Term
	}
	return 0
}

// RaftSnapshotData is the payload of a raftpb.Snapshot. It contains a raw copy of
// all of the range's data and metadata, including the raft log, response cache, etc.
type RaftSnapshotData struct {
	KV               []*RaftSnapshotData_KeyValue `protobuf:"bytes,1,rep" json:"KV,omitempty"`
	XXX_unrecognized []byte                       `json:"-"`
}

func (m *RaftSnapshotData) Reset()         { *m = RaftSnapshotData{} }
func (m *RaftSnapshotData) String() string { return proto1.CompactTextString(m) }
func (*RaftSnapshotData) ProtoMessage()    {}

func (m *RaftSnapshotData) GetKV() []*RaftSnapshotData_KeyValue {
	if m != nil {
		return m.KV
	}
	return nil
}

type RaftSnapshotData_KeyValue struct {
	Key              []byte `protobuf:"bytes,1,opt,name=key" json:"key,omitempty"`
	Value            []byte `protobuf:"bytes,2,opt,name=value" json:"value,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *RaftSnapshotData_KeyValue) Reset()         { *m = RaftSnapshotData_KeyValue{} }
func (m *RaftSnapshotData_KeyValue) String() string { return proto1.CompactTextString(m) }
func (*RaftSnapshotData_KeyValue) ProtoMessage()    {}

func (m *RaftSnapshotData_KeyValue) GetKey() []byte {
	if m != nil {
		return m.Key
	}
	return nil
}

func (m *RaftSnapshotData_KeyValue) GetValue() []byte {
	if m != nil {
		return m.Value
	}
	return nil
}

func init() {
	proto1.RegisterEnum("cockroach.proto.InternalValueType", InternalValueType_name, InternalValueType_value)
}
func (m *InternalRangeLookupRequest) Unmarshal(data []byte) error {
	l := len(data)
	index := 0
	for index < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if index >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[index]
			index++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestHeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if index >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[index]
				index++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := index + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RequestHeader.Unmarshal(data[index:postIndex]); err != nil {
				return err
			}
			index = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxRanges", wireType)
			}
			for shift := uint(0); ; shift += 7 {
				if index >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[index]
				index++
				m.MaxRanges |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			var sizeOfWire int
			for {
				sizeOfWire++
				wire >>= 7
				if wire == 0 {
					break
				}
			}
			index -= sizeOfWire
			skippy, err := github_com_gogo_protobuf_proto.Skip(data[index:])
			if err != nil {
				return err
			}
			if (index + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, data[index:index+skippy]...)
			index += skippy
		}
	}
	return nil
}
func (m *InternalRangeLookupResponse) Unmarshal(data []byte) error {
	l := len(data)
	index := 0
	for index < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if index >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[index]
			index++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResponseHeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if index >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[index]
				index++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := index + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ResponseHeader.Unmarshal(data[index:postIndex]); err != nil {
				return err
			}
			index = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ranges", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if index >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[index]
				index++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := index + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ranges = append(m.Ranges, RangeDescriptor{})
			m.Ranges[len(m.Ranges)-1].Unmarshal(data[index:postIndex])
			index = postIndex
		default:
			var sizeOfWire int
			for {
				sizeOfWire++
				wire >>= 7
				if wire == 0 {
					break
				}
			}
			index -= sizeOfWire
			skippy, err := github_com_gogo_protobuf_proto.Skip(data[index:])
			if err != nil {
				return err
			}
			if (index + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, data[index:index+skippy]...)
			index += skippy
		}
	}
	return nil
}
func (m *InternalHeartbeatTxnRequest) Unmarshal(data []byte) error {
	l := len(data)
	index := 0
	for index < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if index >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[index]
			index++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestHeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if index >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[index]
				index++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := index + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RequestHeader.Unmarshal(data[index:postIndex]); err != nil {
				return err
			}
			index = postIndex
		default:
			var sizeOfWire int
			for {
				sizeOfWire++
				wire >>= 7
				if wire == 0 {
					break
				}
			}
			index -= sizeOfWire
			skippy, err := github_com_gogo_protobuf_proto.Skip(data[index:])
			if err != nil {
				return err
			}
			if (index + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, data[index:index+skippy]...)
			index += skippy
		}
	}
	return nil
}
func (m *InternalHeartbeatTxnResponse) Unmarshal(data []byte) error {
	l := len(data)
	index := 0
	for index < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if index >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[index]
			index++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResponseHeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if index >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[index]
				index++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := index + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ResponseHeader.Unmarshal(data[index:postIndex]); err != nil {
				return err
			}
			index = postIndex
		default:
			var sizeOfWire int
			for {
				sizeOfWire++
				wire >>= 7
				if wire == 0 {
					break
				}
			}
			index -= sizeOfWire
			skippy, err := github_com_gogo_protobuf_proto.Skip(data[index:])
			if err != nil {
				return err
			}
			if (index + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, data[index:index+skippy]...)
			index += skippy
		}
	}
	return nil
}
func (m *InternalGCRequest) Unmarshal(data []byte) error {
	l := len(data)
	index := 0
	for index < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if index >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[index]
			index++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestHeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if index >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[index]
				index++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := index + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RequestHeader.Unmarshal(data[index:postIndex]); err != nil {
				return err
			}
			index = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GCMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if index >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[index]
				index++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := index + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.GCMeta.Unmarshal(data[index:postIndex]); err != nil {
				return err
			}
			index = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Keys", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if index >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[index]
				index++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := index + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Keys = append(m.Keys, InternalGCRequest_GCKey{})
			m.Keys[len(m.Keys)-1].Unmarshal(data[index:postIndex])
			index = postIndex
		default:
			var sizeOfWire int
			for {
				sizeOfWire++
				wire >>= 7
				if wire == 0 {
					break
				}
			}
			index -= sizeOfWire
			skippy, err := github_com_gogo_protobuf_proto.Skip(data[index:])
			if err != nil {
				return err
			}
			if (index + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, data[index:index+skippy]...)
			index += skippy
		}
	}
	return nil
}
func (m *InternalGCRequest_GCKey) Unmarshal(data []byte) error {
	l := len(data)
	index := 0
	for index < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if index >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[index]
			index++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if index >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[index]
				index++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := index + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Key.Unmarshal(data[index:postIndex]); err != nil {
				return err
			}
			index = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if index >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[index]
				index++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := index + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Timestamp.Unmarshal(data[index:postIndex]); err != nil {
				return err
			}
			index = postIndex
		default:
			var sizeOfWire int
			for {
				sizeOfWire++
				wire >>= 7
				if wire == 0 {
					break
				}
			}
			index -= sizeOfWire
			skippy, err := github_com_gogo_protobuf_proto.Skip(data[index:])
			if err != nil {
				return err
			}
			if (index + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, data[index:index+skippy]...)
			index += skippy
		}
	}
	return nil
}
func (m *InternalGCResponse) Unmarshal(data []byte) error {
	l := len(data)
	index := 0
	for index < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if index >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[index]
			index++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResponseHeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if index >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[index]
				index++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := index + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ResponseHeader.Unmarshal(data[index:postIndex]); err != nil {
				return err
			}
			index = postIndex
		default:
			var sizeOfWire int
			for {
				sizeOfWire++
				wire >>= 7
				if wire == 0 {
					break
				}
			}
			index -= sizeOfWire
			skippy, err := github_com_gogo_protobuf_proto.Skip(data[index:])
			if err != nil {
				return err
			}
			if (index + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, data[index:index+skippy]...)
			index += skippy
		}
	}
	return nil
}
func (m *InternalPushTxnRequest) Unmarshal(data []byte) error {
	l := len(data)
	index := 0
	for index < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if index >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[index]
			index++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestHeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if index >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[index]
				index++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := index + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RequestHeader.Unmarshal(data[index:postIndex]); err != nil {
				return err
			}
			index = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PusheeTxn", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if index >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[index]
				index++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := index + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.PusheeTxn.Unmarshal(data[index:postIndex]); err != nil {
				return err
			}
			index = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Abort", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if index >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[index]
				index++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Abort = bool(v != 0)
		default:
			var sizeOfWire int
			for {
				sizeOfWire++
				wire >>= 7
				if wire == 0 {
					break
				}
			}
			index -= sizeOfWire
			skippy, err := github_com_gogo_protobuf_proto.Skip(data[index:])
			if err != nil {
				return err
			}
			if (index + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, data[index:index+skippy]...)
			index += skippy
		}
	}
	return nil
}
func (m *InternalPushTxnResponse) Unmarshal(data []byte) error {
	l := len(data)
	index := 0
	for index < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if index >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[index]
			index++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResponseHeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if index >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[index]
				index++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := index + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ResponseHeader.Unmarshal(data[index:postIndex]); err != nil {
				return err
			}
			index = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PusheeTxn", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if index >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[index]
				index++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := index + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PusheeTxn == nil {
				m.PusheeTxn = &Transaction{}
			}
			if err := m.PusheeTxn.Unmarshal(data[index:postIndex]); err != nil {
				return err
			}
			index = postIndex
		default:
			var sizeOfWire int
			for {
				sizeOfWire++
				wire >>= 7
				if wire == 0 {
					break
				}
			}
			index -= sizeOfWire
			skippy, err := github_com_gogo_protobuf_proto.Skip(data[index:])
			if err != nil {
				return err
			}
			if (index + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, data[index:index+skippy]...)
			index += skippy
		}
	}
	return nil
}
func (m *InternalResolveIntentRequest) Unmarshal(data []byte) error {
	l := len(data)
	index := 0
	for index < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if index >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[index]
			index++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestHeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if index >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[index]
				index++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := index + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RequestHeader.Unmarshal(data[index:postIndex]); err != nil {
				return err
			}
			index = postIndex
		default:
			var sizeOfWire int
			for {
				sizeOfWire++
				wire >>= 7
				if wire == 0 {
					break
				}
			}
			index -= sizeOfWire
			skippy, err := github_com_gogo_protobuf_proto.Skip(data[index:])
			if err != nil {
				return err
			}
			if (index + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, data[index:index+skippy]...)
			index += skippy
		}
	}
	return nil
}
func (m *InternalResolveIntentResponse) Unmarshal(data []byte) error {
	l := len(data)
	index := 0
	for index < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if index >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[index]
			index++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResponseHeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if index >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[index]
				index++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := index + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ResponseHeader.Unmarshal(data[index:postIndex]); err != nil {
				return err
			}
			index = postIndex
		default:
			var sizeOfWire int
			for {
				sizeOfWire++
				wire >>= 7
				if wire == 0 {
					break
				}
			}
			index -= sizeOfWire
			skippy, err := github_com_gogo_protobuf_proto.Skip(data[index:])
			if err != nil {
				return err
			}
			if (index + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, data[index:index+skippy]...)
			index += skippy
		}
	}
	return nil
}
func (m *InternalMergeRequest) Unmarshal(data []byte) error {
	l := len(data)
	index := 0
	for index < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if index >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[index]
			index++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestHeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if index >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[index]
				index++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := index + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RequestHeader.Unmarshal(data[index:postIndex]); err != nil {
				return err
			}
			index = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if index >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[index]
				index++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := index + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Value.Unmarshal(data[index:postIndex]); err != nil {
				return err
			}
			index = postIndex
		default:
			var sizeOfWire int
			for {
				sizeOfWire++
				wire >>= 7
				if wire == 0 {
					break
				}
			}
			index -= sizeOfWire
			skippy, err := github_com_gogo_protobuf_proto.Skip(data[index:])
			if err != nil {
				return err
			}
			if (index + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, data[index:index+skippy]...)
			index += skippy
		}
	}
	return nil
}
func (m *InternalMergeResponse) Unmarshal(data []byte) error {
	l := len(data)
	index := 0
	for index < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if index >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[index]
			index++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResponseHeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if index >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[index]
				index++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := index + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ResponseHeader.Unmarshal(data[index:postIndex]); err != nil {
				return err
			}
			index = postIndex
		default:
			var sizeOfWire int
			for {
				sizeOfWire++
				wire >>= 7
				if wire == 0 {
					break
				}
			}
			index -= sizeOfWire
			skippy, err := github_com_gogo_protobuf_proto.Skip(data[index:])
			if err != nil {
				return err
			}
			if (index + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, data[index:index+skippy]...)
			index += skippy
		}
	}
	return nil
}
func (m *InternalTruncateLogRequest) Unmarshal(data []byte) error {
	l := len(data)
	index := 0
	for index < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if index >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[index]
			index++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestHeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if index >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[index]
				index++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := index + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RequestHeader.Unmarshal(data[index:postIndex]); err != nil {
				return err
			}
			index = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			for shift := uint(0); ; shift += 7 {
				if index >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[index]
				index++
				m.Index |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			var sizeOfWire int
			for {
				sizeOfWire++
				wire >>= 7
				if wire == 0 {
					break
				}
			}
			index -= sizeOfWire
			skippy, err := github_com_gogo_protobuf_proto.Skip(data[index:])
			if err != nil {
				return err
			}
			if (index + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, data[index:index+skippy]...)
			index += skippy
		}
	}
	return nil
}
func (m *InternalTruncateLogResponse) Unmarshal(data []byte) error {
	l := len(data)
	index := 0
	for index < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if index >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[index]
			index++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResponseHeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if index >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[index]
				index++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := index + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ResponseHeader.Unmarshal(data[index:postIndex]); err != nil {
				return err
			}
			index = postIndex
		default:
			var sizeOfWire int
			for {
				sizeOfWire++
				wire >>= 7
				if wire == 0 {
					break
				}
			}
			index -= sizeOfWire
			skippy, err := github_com_gogo_protobuf_proto.Skip(data[index:])
			if err != nil {
				return err
			}
			if (index + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, data[index:index+skippy]...)
			index += skippy
		}
	}
	return nil
}
func (m *ReadWriteCmdResponse) Unmarshal(data []byte) error {
	l := len(data)
	index := 0
	for index < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if index >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[index]
			index++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Put", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if index >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[index]
				index++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := index + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Put == nil {
				m.Put = &PutResponse{}
			}
			if err := m.Put.Unmarshal(data[index:postIndex]); err != nil {
				return err
			}
			index = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConditionalPut", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if index >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[index]
				index++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := index + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ConditionalPut == nil {
				m.ConditionalPut = &ConditionalPutResponse{}
			}
			if err := m.ConditionalPut.Unmarshal(data[index:postIndex]); err != nil {
				return err
			}
			index = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Increment", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if index >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[index]
				index++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := index + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Increment == nil {
				m.Increment = &IncrementResponse{}
			}
			if err := m.Increment.Unmarshal(data[index:postIndex]); err != nil {
				return err
			}
			index = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Delete", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if index >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[index]
				index++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := index + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Delete == nil {
				m.Delete = &DeleteResponse{}
			}
			if err := m.Delete.Unmarshal(data[index:postIndex]); err != nil {
				return err
			}
			index = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeleteRange", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if index >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[index]
				index++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := index + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DeleteRange == nil {
				m.DeleteRange = &DeleteRangeResponse{}
			}
			if err := m.DeleteRange.Unmarshal(data[index:postIndex]); err != nil {
				return err
			}
			index = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndTransaction", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if index >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[index]
				index++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := index + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EndTransaction == nil {
				m.EndTransaction = &EndTransactionResponse{}
			}
			if err := m.EndTransaction.Unmarshal(data[index:postIndex]); err != nil {
				return err
			}
			index = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReapQueue", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if index >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[index]
				index++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := index + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ReapQueue == nil {
				m.ReapQueue = &ReapQueueResponse{}
			}
			if err := m.ReapQueue.Unmarshal(data[index:postIndex]); err != nil {
				return err
			}
			index = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnqueueUpdate", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if index >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[index]
				index++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := index + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EnqueueUpdate == nil {
				m.EnqueueUpdate = &EnqueueUpdateResponse{}
			}
			if err := m.EnqueueUpdate.Unmarshal(data[index:postIndex]); err != nil {
				return err
			}
			index = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnqueueMessage", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if index >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[index]
				index++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := index + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EnqueueMessage == nil {
				m.EnqueueMessage = &EnqueueMessageResponse{}
			}
			if err := m.EnqueueMessage.Unmarshal(data[index:postIndex]); err != nil {
				return err
			}
			index = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InternalHeartbeatTxn", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if index >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[index]
				index++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := index + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.InternalHeartbeatTxn == nil {
				m.InternalHeartbeatTxn = &InternalHeartbeatTxnResponse{}
			}
			if err := m.InternalHeartbeatTxn.Unmarshal(data[index:postIndex]); err != nil {
				return err
			}
			index = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InternalPushTxn", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if index >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[index]
				index++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := index + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.InternalPushTxn == nil {
				m.InternalPushTxn = &InternalPushTxnResponse{}
			}
			if err := m.InternalPushTxn.Unmarshal(data[index:postIndex]); err != nil {
				return err
			}
			index = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InternalResolveIntent", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if index >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[index]
				index++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := index + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.InternalResolveIntent == nil {
				m.InternalResolveIntent = &InternalResolveIntentResponse{}
			}
			if err := m.InternalResolveIntent.Unmarshal(data[index:postIndex]); err != nil {
				return err
			}
			index = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InternalMerge", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if index >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[index]
				index++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := index + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.InternalMerge == nil {
				m.InternalMerge = &InternalMergeResponse{}
			}
			if err := m.InternalMerge.Unmarshal(data[index:postIndex]); err != nil {
				return err
			}
			index = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InternalTruncateLog", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if index >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[index]
				index++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := index + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.InternalTruncateLog == nil {
				m.InternalTruncateLog = &InternalTruncateLogResponse{}
			}
			if err := m.InternalTruncateLog.Unmarshal(data[index:postIndex]); err != nil {
				return err
			}
			index = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InternalGc", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if index >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[index]
				index++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := index + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.InternalGc == nil {
				m.InternalGc = &InternalGCResponse{}
			}
			if err := m.InternalGc.Unmarshal(data[index:postIndex]); err != nil {
				return err
			}
			index = postIndex
		default:
			var sizeOfWire int
			for {
				sizeOfWire++
				wire >>= 7
				if wire == 0 {
					break
				}
			}
			index -= sizeOfWire
			skippy, err := github_com_gogo_protobuf_proto.Skip(data[index:])
			if err != nil {
				return err
			}
			if (index + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, data[index:index+skippy]...)
			index += skippy
		}
	}
	return nil
}
func (m *InternalRaftCommandUnion) Unmarshal(data []byte) error {
	l := len(data)
	index := 0
	for index < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if index >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[index]
			index++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Contains", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if index >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[index]
				index++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := index + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Contains == nil {
				m.Contains = &ContainsRequest{}
			}
			if err := m.Contains.Unmarshal(data[index:postIndex]); err != nil {
				return err
			}
			index = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Get", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if index >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[index]
				index++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := index + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Get == nil {
				m.Get = &GetRequest{}
			}
			if err := m.Get.Unmarshal(data[index:postIndex]); err != nil {
				return err
			}
			index = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Put", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if index >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[index]
				index++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := index + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Put == nil {
				m.Put = &PutRequest{}
			}
			if err := m.Put.Unmarshal(data[index:postIndex]); err != nil {
				return err
			}
			index = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConditionalPut", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if index >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[index]
				index++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := index + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ConditionalPut == nil {
				m.ConditionalPut = &ConditionalPutRequest{}
			}
			if err := m.ConditionalPut.Unmarshal(data[index:postIndex]); err != nil {
				return err
			}
			index = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Increment", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if index >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[index]
				index++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := index + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Increment == nil {
				m.Increment = &IncrementRequest{}
			}
			if err := m.Increment.Unmarshal(data[index:postIndex]); err != nil {
				return err
			}
			index = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Delete", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if index >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[index]
				index++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := index + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Delete == nil {
				m.Delete = &DeleteRequest{}
			}
			if err := m.Delete.Unmarshal(data[index:postIndex]); err != nil {
				return err
			}
			index = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeleteRange", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if index >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[index]
				index++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := index + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DeleteRange == nil {
				m.DeleteRange = &DeleteRangeRequest{}
			}
			if err := m.DeleteRange.Unmarshal(data[index:postIndex]); err != nil {
				return err
			}
			index = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Scan", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if index >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[index]
				index++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := index + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Scan == nil {
				m.Scan = &ScanRequest{}
			}
			if err := m.Scan.Unmarshal(data[index:postIndex]); err != nil {
				return err
			}
			index = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndTransaction", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if index >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[index]
				index++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := index + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EndTransaction == nil {
				m.EndTransaction = &EndTransactionRequest{}
			}
			if err := m.EndTransaction.Unmarshal(data[index:postIndex]); err != nil {
				return err
			}
			index = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReapQueue", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if index >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[index]
				index++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := index + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ReapQueue == nil {
				m.ReapQueue = &ReapQueueRequest{}
			}
			if err := m.ReapQueue.Unmarshal(data[index:postIndex]); err != nil {
				return err
			}
			index = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnqueueUpdate", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if index >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[index]
				index++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := index + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EnqueueUpdate == nil {
				m.EnqueueUpdate = &EnqueueUpdateRequest{}
			}
			if err := m.EnqueueUpdate.Unmarshal(data[index:postIndex]); err != nil {
				return err
			}
			index = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnqueueMessage", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if index >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[index]
				index++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := index + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EnqueueMessage == nil {
				m.EnqueueMessage = &EnqueueMessageRequest{}
			}
			if err := m.EnqueueMessage.Unmarshal(data[index:postIndex]); err != nil {
				return err
			}
			index = postIndex
		case 30:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Batch", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if index >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[index]
				index++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := index + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Batch == nil {
				m.Batch = &BatchRequest{}
			}
			if err := m.Batch.Unmarshal(data[index:postIndex]); err != nil {
				return err
			}
			index = postIndex
		case 31:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InternalRangeLookup", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if index >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[index]
				index++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := index + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.InternalRangeLookup == nil {
				m.InternalRangeLookup = &InternalRangeLookupRequest{}
			}
			if err := m.InternalRangeLookup.Unmarshal(data[index:postIndex]); err != nil {
				return err
			}
			index = postIndex
		case 32:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InternalHeartbeatTxn", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if index >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[index]
				index++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := index + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.InternalHeartbeatTxn == nil {
				m.InternalHeartbeatTxn = &InternalHeartbeatTxnRequest{}
			}
			if err := m.InternalHeartbeatTxn.Unmarshal(data[index:postIndex]); err != nil {
				return err
			}
			index = postIndex
		case 33:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InternalPushTxn", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if index >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[index]
				index++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := index + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.InternalPushTxn == nil {
				m.InternalPushTxn = &InternalPushTxnRequest{}
			}
			if err := m.InternalPushTxn.Unmarshal(data[index:postIndex]); err != nil {
				return err
			}
			index = postIndex
		case 34:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InternalResolveIntent", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if index >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[index]
				index++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := index + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.InternalResolveIntent == nil {
				m.InternalResolveIntent = &InternalResolveIntentRequest{}
			}
			if err := m.InternalResolveIntent.Unmarshal(data[index:postIndex]); err != nil {
				return err
			}
			index = postIndex
		case 35:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InternalMergeResponse", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if index >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[index]
				index++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := index + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.InternalMergeResponse == nil {
				m.InternalMergeResponse = &InternalMergeRequest{}
			}
			if err := m.InternalMergeResponse.Unmarshal(data[index:postIndex]); err != nil {
				return err
			}
			index = postIndex
		case 36:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InternalTruncateLog", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if index >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[index]
				index++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := index + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.InternalTruncateLog == nil {
				m.InternalTruncateLog = &InternalTruncateLogRequest{}
			}
			if err := m.InternalTruncateLog.Unmarshal(data[index:postIndex]); err != nil {
				return err
			}
			index = postIndex
		case 37:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InternalGc", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if index >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[index]
				index++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := index + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.InternalGc == nil {
				m.InternalGc = &InternalGCRequest{}
			}
			if err := m.InternalGc.Unmarshal(data[index:postIndex]); err != nil {
				return err
			}
			index = postIndex
		default:
			var sizeOfWire int
			for {
				sizeOfWire++
				wire >>= 7
				if wire == 0 {
					break
				}
			}
			index -= sizeOfWire
			skippy, err := github_com_gogo_protobuf_proto.Skip(data[index:])
			if err != nil {
				return err
			}
			if (index + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, data[index:index+skippy]...)
			index += skippy
		}
	}
	return nil
}
func (m *InternalRaftCommand) Unmarshal(data []byte) error {
	l := len(data)
	index := 0
	for index < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if index >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[index]
			index++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		switch fieldNum {
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RaftID", wireType)
			}
			for shift := uint(0); ; shift += 7 {
				if index >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[index]
				index++
				m.RaftID |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cmd", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if index >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[index]
				index++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := index + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Cmd.Unmarshal(data[index:postIndex]); err != nil {
				return err
			}
			index = postIndex
		default:
			var sizeOfWire int
			for {
				sizeOfWire++
				wire >>= 7
				if wire == 0 {
					break
				}
			}
			index -= sizeOfWire
			skippy, err := github_com_gogo_protobuf_proto.Skip(data[index:])
			if err != nil {
				return err
			}
			if (index + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, data[index:index+skippy]...)
			index += skippy
		}
	}
	return nil
}
func (m *RaftMessageRequest) Unmarshal(data []byte) error {
	l := len(data)
	index := 0
	for index < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if index >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[index]
			index++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupID", wireType)
			}
			for shift := uint(0); ; shift += 7 {
				if index >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[index]
				index++
				m.GroupID |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msg", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if index >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[index]
				index++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := index + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Msg = append([]byte{}, data[index:postIndex]...)
			index = postIndex
		default:
			var sizeOfWire int
			for {
				sizeOfWire++
				wire >>= 7
				if wire == 0 {
					break
				}
			}
			index -= sizeOfWire
			skippy, err := github_com_gogo_protobuf_proto.Skip(data[index:])
			if err != nil {
				return err
			}
			if (index + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, data[index:index+skippy]...)
			index += skippy
		}
	}
	return nil
}
func (m *RaftMessageResponse) Unmarshal(data []byte) error {
	l := len(data)
	index := 0
	for index < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if index >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[index]
			index++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		switch fieldNum {
		default:
			var sizeOfWire int
			for {
				sizeOfWire++
				wire >>= 7
				if wire == 0 {
					break
				}
			}
			index -= sizeOfWire
			skippy, err := github_com_gogo_protobuf_proto.Skip(data[index:])
			if err != nil {
				return err
			}
			if (index + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, data[index:index+skippy]...)
			index += skippy
		}
	}
	return nil
}
func (m *InternalTimeSeriesData) Unmarshal(data []byte) error {
	l := len(data)
	index := 0
	for index < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if index >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[index]
			index++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartTimestampNanos", wireType)
			}
			for shift := uint(0); ; shift += 7 {
				if index >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[index]
				index++
				m.StartTimestampNanos |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SampleDurationNanos", wireType)
			}
			for shift := uint(0); ; shift += 7 {
				if index >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[index]
				index++
				m.SampleDurationNanos |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Samples", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if index >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[index]
				index++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := index + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Samples = append(m.Samples, &InternalTimeSeriesSample{})
			m.Samples[len(m.Samples)-1].Unmarshal(data[index:postIndex])
			index = postIndex
		default:
			var sizeOfWire int
			for {
				sizeOfWire++
				wire >>= 7
				if wire == 0 {
					break
				}
			}
			index -= sizeOfWire
			skippy, err := github_com_gogo_protobuf_proto.Skip(data[index:])
			if err != nil {
				return err
			}
			if (index + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, data[index:index+skippy]...)
			index += skippy
		}
	}
	return nil
}
func (m *InternalTimeSeriesSample) Unmarshal(data []byte) error {
	l := len(data)
	index := 0
	for index < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if index >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[index]
			index++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Offset", wireType)
			}
			for shift := uint(0); ; shift += 7 {
				if index >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[index]
				index++
				m.Offset |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IntCount", wireType)
			}
			for shift := uint(0); ; shift += 7 {
				if index >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[index]
				index++
				m.IntCount |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IntSum", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if index >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[index]
				index++
				v |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IntSum = &v
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IntMax", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if index >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[index]
				index++
				v |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IntMax = &v
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IntMin", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if index >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[index]
				index++
				v |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IntMin = &v
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FloatCount", wireType)
			}
			for shift := uint(0); ; shift += 7 {
				if index >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[index]
				index++
				m.FloatCount |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field FloatSum", wireType)
			}
			var v uint32
			i := index + 4
			if i > l {
				return io.ErrUnexpectedEOF
			}
			index = i
			v = uint32(data[i-4])
			v |= uint32(data[i-3]) << 8
			v |= uint32(data[i-2]) << 16
			v |= uint32(data[i-1]) << 24
			v2 := math.Float32frombits(v)
			m.FloatSum = &v2
		case 8:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field FloatMax", wireType)
			}
			var v uint32
			i := index + 4
			if i > l {
				return io.ErrUnexpectedEOF
			}
			index = i
			v = uint32(data[i-4])
			v |= uint32(data[i-3]) << 8
			v |= uint32(data[i-2]) << 16
			v |= uint32(data[i-1]) << 24
			v2 := math.Float32frombits(v)
			m.FloatMax = &v2
		case 9:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field FloatMin", wireType)
			}
			var v uint32
			i := index + 4
			if i > l {
				return io.ErrUnexpectedEOF
			}
			index = i
			v = uint32(data[i-4])
			v |= uint32(data[i-3]) << 8
			v |= uint32(data[i-2]) << 16
			v |= uint32(data[i-1]) << 24
			v2 := math.Float32frombits(v)
			m.FloatMin = &v2
		default:
			var sizeOfWire int
			for {
				sizeOfWire++
				wire >>= 7
				if wire == 0 {
					break
				}
			}
			index -= sizeOfWire
			skippy, err := github_com_gogo_protobuf_proto.Skip(data[index:])
			if err != nil {
				return err
			}
			if (index + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, data[index:index+skippy]...)
			index += skippy
		}
	}
	return nil
}
func (m *RaftTruncatedState) Unmarshal(data []byte) error {
	l := len(data)
	index := 0
	for index < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if index >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[index]
			index++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			for shift := uint(0); ; shift += 7 {
				if index >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[index]
				index++
				m.Index |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Term", wireType)
			}
			for shift := uint(0); ; shift += 7 {
				if index >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[index]
				index++
				m.Term |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			var sizeOfWire int
			for {
				sizeOfWire++
				wire >>= 7
				if wire == 0 {
					break
				}
			}
			index -= sizeOfWire
			skippy, err := github_com_gogo_protobuf_proto.Skip(data[index:])
			if err != nil {
				return err
			}
			if (index + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, data[index:index+skippy]...)
			index += skippy
		}
	}
	return nil
}
func (m *RaftSnapshotData) Unmarshal(data []byte) error {
	l := len(data)
	index := 0
	for index < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if index >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[index]
			index++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KV", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if index >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[index]
				index++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := index + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.KV = append(m.KV, &RaftSnapshotData_KeyValue{})
			m.KV[len(m.KV)-1].Unmarshal(data[index:postIndex])
			index = postIndex
		default:
			var sizeOfWire int
			for {
				sizeOfWire++
				wire >>= 7
				if wire == 0 {
					break
				}
			}
			index -= sizeOfWire
			skippy, err := github_com_gogo_protobuf_proto.Skip(data[index:])
			if err != nil {
				return err
			}
			if (index + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, data[index:index+skippy]...)
			index += skippy
		}
	}
	return nil
}
func (m *RaftSnapshotData_KeyValue) Unmarshal(data []byte) error {
	l := len(data)
	index := 0
	for index < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if index >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[index]
			index++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if index >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[index]
				index++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := index + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = append([]byte{}, data[index:postIndex]...)
			index = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if index >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[index]
				index++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := index + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = append([]byte{}, data[index:postIndex]...)
			index = postIndex
		default:
			var sizeOfWire int
			for {
				sizeOfWire++
				wire >>= 7
				if wire == 0 {
					break
				}
			}
			index -= sizeOfWire
			skippy, err := github_com_gogo_protobuf_proto.Skip(data[index:])
			if err != nil {
				return err
			}
			if (index + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, data[index:index+skippy]...)
			index += skippy
		}
	}
	return nil
}
func (this *ReadWriteCmdResponse) GetValue() interface{} {
	if this.Put != nil {
		return this.Put
	}
	if this.ConditionalPut != nil {
		return this.ConditionalPut
	}
	if this.Increment != nil {
		return this.Increment
	}
	if this.Delete != nil {
		return this.Delete
	}
	if this.DeleteRange != nil {
		return this.DeleteRange
	}
	if this.EndTransaction != nil {
		return this.EndTransaction
	}
	if this.ReapQueue != nil {
		return this.ReapQueue
	}
	if this.EnqueueUpdate != nil {
		return this.EnqueueUpdate
	}
	if this.EnqueueMessage != nil {
		return this.EnqueueMessage
	}
	if this.InternalHeartbeatTxn != nil {
		return this.InternalHeartbeatTxn
	}
	if this.InternalPushTxn != nil {
		return this.InternalPushTxn
	}
	if this.InternalResolveIntent != nil {
		return this.InternalResolveIntent
	}
	if this.InternalMerge != nil {
		return this.InternalMerge
	}
	if this.InternalTruncateLog != nil {
		return this.InternalTruncateLog
	}
	if this.InternalGc != nil {
		return this.InternalGc
	}
	return nil
}

func (this *ReadWriteCmdResponse) SetValue(value interface{}) bool {
	switch vt := value.(type) {
	case *PutResponse:
		this.Put = vt
	case *ConditionalPutResponse:
		this.ConditionalPut = vt
	case *IncrementResponse:
		this.Increment = vt
	case *DeleteResponse:
		this.Delete = vt
	case *DeleteRangeResponse:
		this.DeleteRange = vt
	case *EndTransactionResponse:
		this.EndTransaction = vt
	case *ReapQueueResponse:
		this.ReapQueue = vt
	case *EnqueueUpdateResponse:
		this.EnqueueUpdate = vt
	case *EnqueueMessageResponse:
		this.EnqueueMessage = vt
	case *InternalHeartbeatTxnResponse:
		this.InternalHeartbeatTxn = vt
	case *InternalPushTxnResponse:
		this.InternalPushTxn = vt
	case *InternalResolveIntentResponse:
		this.InternalResolveIntent = vt
	case *InternalMergeResponse:
		this.InternalMerge = vt
	case *InternalTruncateLogResponse:
		this.InternalTruncateLog = vt
	case *InternalGCResponse:
		this.InternalGc = vt
	default:
		return false
	}
	return true
}
func (this *InternalRaftCommandUnion) GetValue() interface{} {
	if this.Contains != nil {
		return this.Contains
	}
	if this.Get != nil {
		return this.Get
	}
	if this.Put != nil {
		return this.Put
	}
	if this.ConditionalPut != nil {
		return this.ConditionalPut
	}
	if this.Increment != nil {
		return this.Increment
	}
	if this.Delete != nil {
		return this.Delete
	}
	if this.DeleteRange != nil {
		return this.DeleteRange
	}
	if this.Scan != nil {
		return this.Scan
	}
	if this.EndTransaction != nil {
		return this.EndTransaction
	}
	if this.ReapQueue != nil {
		return this.ReapQueue
	}
	if this.EnqueueUpdate != nil {
		return this.EnqueueUpdate
	}
	if this.EnqueueMessage != nil {
		return this.EnqueueMessage
	}
	if this.Batch != nil {
		return this.Batch
	}
	if this.InternalRangeLookup != nil {
		return this.InternalRangeLookup
	}
	if this.InternalHeartbeatTxn != nil {
		return this.InternalHeartbeatTxn
	}
	if this.InternalPushTxn != nil {
		return this.InternalPushTxn
	}
	if this.InternalResolveIntent != nil {
		return this.InternalResolveIntent
	}
	if this.InternalMergeResponse != nil {
		return this.InternalMergeResponse
	}
	if this.InternalTruncateLog != nil {
		return this.InternalTruncateLog
	}
	if this.InternalGc != nil {
		return this.InternalGc
	}
	return nil
}

func (this *InternalRaftCommandUnion) SetValue(value interface{}) bool {
	switch vt := value.(type) {
	case *ContainsRequest:
		this.Contains = vt
	case *GetRequest:
		this.Get = vt
	case *PutRequest:
		this.Put = vt
	case *ConditionalPutRequest:
		this.ConditionalPut = vt
	case *IncrementRequest:
		this.Increment = vt
	case *DeleteRequest:
		this.Delete = vt
	case *DeleteRangeRequest:
		this.DeleteRange = vt
	case *ScanRequest:
		this.Scan = vt
	case *EndTransactionRequest:
		this.EndTransaction = vt
	case *ReapQueueRequest:
		this.ReapQueue = vt
	case *EnqueueUpdateRequest:
		this.EnqueueUpdate = vt
	case *EnqueueMessageRequest:
		this.EnqueueMessage = vt
	case *BatchRequest:
		this.Batch = vt
	case *InternalRangeLookupRequest:
		this.InternalRangeLookup = vt
	case *InternalHeartbeatTxnRequest:
		this.InternalHeartbeatTxn = vt
	case *InternalPushTxnRequest:
		this.InternalPushTxn = vt
	case *InternalResolveIntentRequest:
		this.InternalResolveIntent = vt
	case *InternalMergeRequest:
		this.InternalMergeResponse = vt
	case *InternalTruncateLogRequest:
		this.InternalTruncateLog = vt
	case *InternalGCRequest:
		this.InternalGc = vt
	default:
		return false
	}
	return true
}
func (m *InternalRangeLookupRequest) Size() (n int) {
	var l int
	_ = l
	l = m.RequestHeader.Size()
	n += 1 + l + sovInternal(uint64(l))
	n += 1 + sovInternal(uint64(m.MaxRanges))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *InternalRangeLookupResponse) Size() (n int) {
	var l int
	_ = l
	l = m.ResponseHeader.Size()
	n += 1 + l + sovInternal(uint64(l))
	if len(m.Ranges) > 0 {
		for _, e := range m.Ranges {
			l = e.Size()
			n += 1 + l + sovInternal(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *InternalHeartbeatTxnRequest) Size() (n int) {
	var l int
	_ = l
	l = m.RequestHeader.Size()
	n += 1 + l + sovInternal(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *InternalHeartbeatTxnResponse) Size() (n int) {
	var l int
	_ = l
	l = m.ResponseHeader.Size()
	n += 1 + l + sovInternal(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *InternalGCRequest) Size() (n int) {
	var l int
	_ = l
	l = m.RequestHeader.Size()
	n += 1 + l + sovInternal(uint64(l))
	l = m.GCMeta.Size()
	n += 1 + l + sovInternal(uint64(l))
	if len(m.Keys) > 0 {
		for _, e := range m.Keys {
			l = e.Size()
			n += 1 + l + sovInternal(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *InternalGCRequest_GCKey) Size() (n int) {
	var l int
	_ = l
	l = m.Key.Size()
	n += 1 + l + sovInternal(uint64(l))
	l = m.Timestamp.Size()
	n += 1 + l + sovInternal(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *InternalGCResponse) Size() (n int) {
	var l int
	_ = l
	l = m.ResponseHeader.Size()
	n += 1 + l + sovInternal(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *InternalPushTxnRequest) Size() (n int) {
	var l int
	_ = l
	l = m.RequestHeader.Size()
	n += 1 + l + sovInternal(uint64(l))
	l = m.PusheeTxn.Size()
	n += 1 + l + sovInternal(uint64(l))
	n += 2
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *InternalPushTxnResponse) Size() (n int) {
	var l int
	_ = l
	l = m.ResponseHeader.Size()
	n += 1 + l + sovInternal(uint64(l))
	if m.PusheeTxn != nil {
		l = m.PusheeTxn.Size()
		n += 1 + l + sovInternal(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *InternalResolveIntentRequest) Size() (n int) {
	var l int
	_ = l
	l = m.RequestHeader.Size()
	n += 1 + l + sovInternal(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *InternalResolveIntentResponse) Size() (n int) {
	var l int
	_ = l
	l = m.ResponseHeader.Size()
	n += 1 + l + sovInternal(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *InternalMergeRequest) Size() (n int) {
	var l int
	_ = l
	l = m.RequestHeader.Size()
	n += 1 + l + sovInternal(uint64(l))
	l = m.Value.Size()
	n += 1 + l + sovInternal(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *InternalMergeResponse) Size() (n int) {
	var l int
	_ = l
	l = m.ResponseHeader.Size()
	n += 1 + l + sovInternal(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *InternalTruncateLogRequest) Size() (n int) {
	var l int
	_ = l
	l = m.RequestHeader.Size()
	n += 1 + l + sovInternal(uint64(l))
	n += 1 + sovInternal(uint64(m.Index))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *InternalTruncateLogResponse) Size() (n int) {
	var l int
	_ = l
	l = m.ResponseHeader.Size()
	n += 1 + l + sovInternal(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ReadWriteCmdResponse) Size() (n int) {
	var l int
	_ = l
	if m.Put != nil {
		l = m.Put.Size()
		n += 1 + l + sovInternal(uint64(l))
	}
	if m.ConditionalPut != nil {
		l = m.ConditionalPut.Size()
		n += 1 + l + sovInternal(uint64(l))
	}
	if m.Increment != nil {
		l = m.Increment.Size()
		n += 1 + l + sovInternal(uint64(l))
	}
	if m.Delete != nil {
		l = m.Delete.Size()
		n += 1 + l + sovInternal(uint64(l))
	}
	if m.DeleteRange != nil {
		l = m.DeleteRange.Size()
		n += 1 + l + sovInternal(uint64(l))
	}
	if m.EndTransaction != nil {
		l = m.EndTransaction.Size()
		n += 1 + l + sovInternal(uint64(l))
	}
	if m.ReapQueue != nil {
		l = m.ReapQueue.Size()
		n += 1 + l + sovInternal(uint64(l))
	}
	if m.EnqueueUpdate != nil {
		l = m.EnqueueUpdate.Size()
		n += 1 + l + sovInternal(uint64(l))
	}
	if m.EnqueueMessage != nil {
		l = m.EnqueueMessage.Size()
		n += 1 + l + sovInternal(uint64(l))
	}
	if m.InternalHeartbeatTxn != nil {
		l = m.InternalHeartbeatTxn.Size()
		n += 1 + l + sovInternal(uint64(l))
	}
	if m.InternalPushTxn != nil {
		l = m.InternalPushTxn.Size()
		n += 1 + l + sovInternal(uint64(l))
	}
	if m.InternalResolveIntent != nil {
		l = m.InternalResolveIntent.Size()
		n += 1 + l + sovInternal(uint64(l))
	}
	if m.InternalMerge != nil {
		l = m.InternalMerge.Size()
		n += 1 + l + sovInternal(uint64(l))
	}
	if m.InternalTruncateLog != nil {
		l = m.InternalTruncateLog.Size()
		n += 1 + l + sovInternal(uint64(l))
	}
	if m.InternalGc != nil {
		l = m.InternalGc.Size()
		n += 1 + l + sovInternal(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *InternalRaftCommandUnion) Size() (n int) {
	var l int
	_ = l
	if m.Contains != nil {
		l = m.Contains.Size()
		n += 1 + l + sovInternal(uint64(l))
	}
	if m.Get != nil {
		l = m.Get.Size()
		n += 1 + l + sovInternal(uint64(l))
	}
	if m.Put != nil {
		l = m.Put.Size()
		n += 1 + l + sovInternal(uint64(l))
	}
	if m.ConditionalPut != nil {
		l = m.ConditionalPut.Size()
		n += 1 + l + sovInternal(uint64(l))
	}
	if m.Increment != nil {
		l = m.Increment.Size()
		n += 1 + l + sovInternal(uint64(l))
	}
	if m.Delete != nil {
		l = m.Delete.Size()
		n += 1 + l + sovInternal(uint64(l))
	}
	if m.DeleteRange != nil {
		l = m.DeleteRange.Size()
		n += 1 + l + sovInternal(uint64(l))
	}
	if m.Scan != nil {
		l = m.Scan.Size()
		n += 1 + l + sovInternal(uint64(l))
	}
	if m.EndTransaction != nil {
		l = m.EndTransaction.Size()
		n += 1 + l + sovInternal(uint64(l))
	}
	if m.ReapQueue != nil {
		l = m.ReapQueue.Size()
		n += 1 + l + sovInternal(uint64(l))
	}
	if m.EnqueueUpdate != nil {
		l = m.EnqueueUpdate.Size()
		n += 1 + l + sovInternal(uint64(l))
	}
	if m.EnqueueMessage != nil {
		l = m.EnqueueMessage.Size()
		n += 1 + l + sovInternal(uint64(l))
	}
	if m.Batch != nil {
		l = m.Batch.Size()
		n += 2 + l + sovInternal(uint64(l))
	}
	if m.InternalRangeLookup != nil {
		l = m.InternalRangeLookup.Size()
		n += 2 + l + sovInternal(uint64(l))
	}
	if m.InternalHeartbeatTxn != nil {
		l = m.InternalHeartbeatTxn.Size()
		n += 2 + l + sovInternal(uint64(l))
	}
	if m.InternalPushTxn != nil {
		l = m.InternalPushTxn.Size()
		n += 2 + l + sovInternal(uint64(l))
	}
	if m.InternalResolveIntent != nil {
		l = m.InternalResolveIntent.Size()
		n += 2 + l + sovInternal(uint64(l))
	}
	if m.InternalMergeResponse != nil {
		l = m.InternalMergeResponse.Size()
		n += 2 + l + sovInternal(uint64(l))
	}
	if m.InternalTruncateLog != nil {
		l = m.InternalTruncateLog.Size()
		n += 2 + l + sovInternal(uint64(l))
	}
	if m.InternalGc != nil {
		l = m.InternalGc.Size()
		n += 2 + l + sovInternal(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *InternalRaftCommand) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovInternal(uint64(m.RaftID))
	l = m.Cmd.Size()
	n += 1 + l + sovInternal(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RaftMessageRequest) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovInternal(uint64(m.GroupID))
	if m.Msg != nil {
		l = len(m.Msg)
		n += 1 + l + sovInternal(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RaftMessageResponse) Size() (n int) {
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *InternalTimeSeriesData) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovInternal(uint64(m.StartTimestampNanos))
	n += 1 + sovInternal(uint64(m.SampleDurationNanos))
	if len(m.Samples) > 0 {
		for _, e := range m.Samples {
			l = e.Size()
			n += 1 + l + sovInternal(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *InternalTimeSeriesSample) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovInternal(uint64(m.Offset))
	n += 1 + sovInternal(uint64(m.IntCount))
	if m.IntSum != nil {
		n += 1 + sovInternal(uint64(*m.IntSum))
	}
	if m.IntMax != nil {
		n += 1 + sovInternal(uint64(*m.IntMax))
	}
	if m.IntMin != nil {
		n += 1 + sovInternal(uint64(*m.IntMin))
	}
	n += 1 + sovInternal(uint64(m.FloatCount))
	if m.FloatSum != nil {
		n += 5
	}
	if m.FloatMax != nil {
		n += 5
	}
	if m.FloatMin != nil {
		n += 5
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RaftTruncatedState) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovInternal(uint64(m.Index))
	n += 1 + sovInternal(uint64(m.Term))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RaftSnapshotData) Size() (n int) {
	var l int
	_ = l
	if len(m.KV) > 0 {
		for _, e := range m.KV {
			l = e.Size()
			n += 1 + l + sovInternal(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RaftSnapshotData_KeyValue) Size() (n int) {
	var l int
	_ = l
	if m.Key != nil {
		l = len(m.Key)
		n += 1 + l + sovInternal(uint64(l))
	}
	if m.Value != nil {
		l = len(m.Value)
		n += 1 + l + sovInternal(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovInternal(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozInternal(x uint64) (n int) {
	return sovInternal(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *InternalRangeLookupRequest) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *InternalRangeLookupRequest) MarshalTo(data []byte) (n int, err error) {
	var i int
	_ = i
	var l int
	_ = l
	data[i] = 0xa
	i++
	i = encodeVarintInternal(data, i, uint64(m.RequestHeader.Size()))
	n1, err := m.RequestHeader.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n1
	data[i] = 0x10
	i++
	i = encodeVarintInternal(data, i, uint64(m.MaxRanges))
	if m.XXX_unrecognized != nil {
		i += copy(data[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *InternalRangeLookupResponse) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *InternalRangeLookupResponse) MarshalTo(data []byte) (n int, err error) {
	var i int
	_ = i
	var l int
	_ = l
	data[i] = 0xa
	i++
	i = encodeVarintInternal(data, i, uint64(m.ResponseHeader.Size()))
	n2, err := m.ResponseHeader.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n2
	if len(m.Ranges) > 0 {
		for _, msg := range m.Ranges {
			data[i] = 0x12
			i++
			i = encodeVarintInternal(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(data[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *InternalHeartbeatTxnRequest) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *InternalHeartbeatTxnRequest) MarshalTo(data []byte) (n int, err error) {
	var i int
	_ = i
	var l int
	_ = l
	data[i] = 0xa
	i++
	i = encodeVarintInternal(data, i, uint64(m.RequestHeader.Size()))
	n3, err := m.RequestHeader.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n3
	if m.XXX_unrecognized != nil {
		i += copy(data[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *InternalHeartbeatTxnResponse) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *InternalHeartbeatTxnResponse) MarshalTo(data []byte) (n int, err error) {
	var i int
	_ = i
	var l int
	_ = l
	data[i] = 0xa
	i++
	i = encodeVarintInternal(data, i, uint64(m.ResponseHeader.Size()))
	n4, err := m.ResponseHeader.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n4
	if m.XXX_unrecognized != nil {
		i += copy(data[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *InternalGCRequest) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *InternalGCRequest) MarshalTo(data []byte) (n int, err error) {
	var i int
	_ = i
	var l int
	_ = l
	data[i] = 0xa
	i++
	i = encodeVarintInternal(data, i, uint64(m.RequestHeader.Size()))
	n5, err := m.RequestHeader.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n5
	data[i] = 0x12
	i++
	i = encodeVarintInternal(data, i, uint64(m.GCMeta.Size()))
	n6, err := m.GCMeta.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n6
	if len(m.Keys) > 0 {
		for _, msg := range m.Keys {
			data[i] = 0x1a
			i++
			i = encodeVarintInternal(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(data[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *InternalGCRequest_GCKey) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *InternalGCRequest_GCKey) MarshalTo(data []byte) (n int, err error) {
	var i int
	_ = i
	var l int
	_ = l
	data[i] = 0xa
	i++
	i = encodeVarintInternal(data, i, uint64(m.Key.Size()))
	n7, err := m.Key.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n7
	data[i] = 0x12
	i++
	i = encodeVarintInternal(data, i, uint64(m.Timestamp.Size()))
	n8, err := m.Timestamp.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n8
	if m.XXX_unrecognized != nil {
		i += copy(data[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *InternalGCResponse) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *InternalGCResponse) MarshalTo(data []byte) (n int, err error) {
	var i int
	_ = i
	var l int
	_ = l
	data[i] = 0xa
	i++
	i = encodeVarintInternal(data, i, uint64(m.ResponseHeader.Size()))
	n9, err := m.ResponseHeader.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n9
	if m.XXX_unrecognized != nil {
		i += copy(data[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *InternalPushTxnRequest) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *InternalPushTxnRequest) MarshalTo(data []byte) (n int, err error) {
	var i int
	_ = i
	var l int
	_ = l
	data[i] = 0xa
	i++
	i = encodeVarintInternal(data, i, uint64(m.RequestHeader.Size()))
	n10, err := m.RequestHeader.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n10
	data[i] = 0x12
	i++
	i = encodeVarintInternal(data, i, uint64(m.PusheeTxn.Size()))
	n11, err := m.PusheeTxn.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n11
	data[i] = 0x18
	i++
	if m.Abort {
		data[i] = 1
	} else {
		data[i] = 0
	}
	i++
	if m.XXX_unrecognized != nil {
		i += copy(data[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *InternalPushTxnResponse) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *InternalPushTxnResponse) MarshalTo(data []byte) (n int, err error) {
	var i int
	_ = i
	var l int
	_ = l
	data[i] = 0xa
	i++
	i = encodeVarintInternal(data, i, uint64(m.ResponseHeader.Size()))
	n12, err := m.ResponseHeader.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n12
	if m.PusheeTxn != nil {
		data[i] = 0x12
		i++
		i = encodeVarintInternal(data, i, uint64(m.PusheeTxn.Size()))
		n13, err := m.PusheeTxn.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n13
	}
	if m.XXX_unrecognized != nil {
		i += copy(data[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *InternalResolveIntentRequest) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *InternalResolveIntentRequest) MarshalTo(data []byte) (n int, err error) {
	var i int
	_ = i
	var l int
	_ = l
	data[i] = 0xa
	i++
	i = encodeVarintInternal(data, i, uint64(m.RequestHeader.Size()))
	n14, err := m.RequestHeader.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n14
	if m.XXX_unrecognized != nil {
		i += copy(data[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *InternalResolveIntentResponse) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *InternalResolveIntentResponse) MarshalTo(data []byte) (n int, err error) {
	var i int
	_ = i
	var l int
	_ = l
	data[i] = 0xa
	i++
	i = encodeVarintInternal(data, i, uint64(m.ResponseHeader.Size()))
	n15, err := m.ResponseHeader.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n15
	if m.XXX_unrecognized != nil {
		i += copy(data[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *InternalMergeRequest) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *InternalMergeRequest) MarshalTo(data []byte) (n int, err error) {
	var i int
	_ = i
	var l int
	_ = l
	data[i] = 0xa
	i++
	i = encodeVarintInternal(data, i, uint64(m.RequestHeader.Size()))
	n16, err := m.RequestHeader.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n16
	data[i] = 0x12
	i++
	i = encodeVarintInternal(data, i, uint64(m.Value.Size()))
	n17, err := m.Value.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n17
	if m.XXX_unrecognized != nil {
		i += copy(data[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *InternalMergeResponse) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *InternalMergeResponse) MarshalTo(data []byte) (n int, err error) {
	var i int
	_ = i
	var l int
	_ = l
	data[i] = 0xa
	i++
	i = encodeVarintInternal(data, i, uint64(m.ResponseHeader.Size()))
	n18, err := m.ResponseHeader.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n18
	if m.XXX_unrecognized != nil {
		i += copy(data[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *InternalTruncateLogRequest) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *InternalTruncateLogRequest) MarshalTo(data []byte) (n int, err error) {
	var i int
	_ = i
	var l int
	_ = l
	data[i] = 0xa
	i++
	i = encodeVarintInternal(data, i, uint64(m.RequestHeader.Size()))
	n19, err := m.RequestHeader.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n19
	data[i] = 0x10
	i++
	i = encodeVarintInternal(data, i, uint64(m.Index))
	if m.XXX_unrecognized != nil {
		i += copy(data[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *InternalTruncateLogResponse) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *InternalTruncateLogResponse) MarshalTo(data []byte) (n int, err error) {
	var i int
	_ = i
	var l int
	_ = l
	data[i] = 0xa
	i++
	i = encodeVarintInternal(data, i, uint64(m.ResponseHeader.Size()))
	n20, err := m.ResponseHeader.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n20
	if m.XXX_unrecognized != nil {
		i += copy(data[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ReadWriteCmdResponse) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *ReadWriteCmdResponse) MarshalTo(data []byte) (n int, err error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Put != nil {
		data[i] = 0xa
		i++
		i = encodeVarintInternal(data, i, uint64(m.Put.Size()))
		n21, err := m.Put.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n21
	}
	if m.ConditionalPut != nil {
		data[i] = 0x12
		i++
		i = encodeVarintInternal(data, i, uint64(m.ConditionalPut.Size()))
		n22, err := m.ConditionalPut.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n22
	}
	if m.Increment != nil {
		data[i] = 0x1a
		i++
		i = encodeVarintInternal(data, i, uint64(m.Increment.Size()))
		n23, err := m.Increment.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n23
	}
	if m.Delete != nil {
		data[i] = 0x22
		i++
		i = encodeVarintInternal(data, i, uint64(m.Delete.Size()))
		n24, err := m.Delete.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n24
	}
	if m.DeleteRange != nil {
		data[i] = 0x2a
		i++
		i = encodeVarintInternal(data, i, uint64(m.DeleteRange.Size()))
		n25, err := m.DeleteRange.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n25
	}
	if m.EndTransaction != nil {
		data[i] = 0x32
		i++
		i = encodeVarintInternal(data, i, uint64(m.EndTransaction.Size()))
		n26, err := m.EndTransaction.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n26
	}
	if m.ReapQueue != nil {
		data[i] = 0x3a
		i++
		i = encodeVarintInternal(data, i, uint64(m.ReapQueue.Size()))
		n27, err := m.ReapQueue.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n27
	}
	if m.EnqueueUpdate != nil {
		data[i] = 0x42
		i++
		i = encodeVarintInternal(data, i, uint64(m.EnqueueUpdate.Size()))
		n28, err := m.EnqueueUpdate.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n28
	}
	if m.EnqueueMessage != nil {
		data[i] = 0x4a
		i++
		i = encodeVarintInternal(data, i, uint64(m.EnqueueMessage.Size()))
		n29, err := m.EnqueueMessage.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n29
	}
	if m.InternalHeartbeatTxn != nil {
		data[i] = 0x52
		i++
		i = encodeVarintInternal(data, i, uint64(m.InternalHeartbeatTxn.Size()))
		n30, err := m.InternalHeartbeatTxn.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n30
	}
	if m.InternalPushTxn != nil {
		data[i] = 0x5a
		i++
		i = encodeVarintInternal(data, i, uint64(m.InternalPushTxn.Size()))
		n31, err := m.InternalPushTxn.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n31
	}
	if m.InternalResolveIntent != nil {
		data[i] = 0x62
		i++
		i = encodeVarintInternal(data, i, uint64(m.InternalResolveIntent.Size()))
		n32, err := m.InternalResolveIntent.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n32
	}
	if m.InternalMerge != nil {
		data[i] = 0x6a
		i++
		i = encodeVarintInternal(data, i, uint64(m.InternalMerge.Size()))
		n33, err := m.InternalMerge.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n33
	}
	if m.InternalTruncateLog != nil {
		data[i] = 0x72
		i++
		i = encodeVarintInternal(data, i, uint64(m.InternalTruncateLog.Size()))
		n34, err := m.InternalTruncateLog.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n34
	}
	if m.InternalGc != nil {
		data[i] = 0x7a
		i++
		i = encodeVarintInternal(data, i, uint64(m.InternalGc.Size()))
		n35, err := m.InternalGc.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n35
	}
	if m.XXX_unrecognized != nil {
		i += copy(data[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *InternalRaftCommandUnion) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *InternalRaftCommandUnion) MarshalTo(data []byte) (n int, err error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Contains != nil {
		data[i] = 0xa
		i++
		i = encodeVarintInternal(data, i, uint64(m.Contains.Size()))
		n36, err := m.Contains.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n36
	}
	if m.Get != nil {
		data[i] = 0x12
		i++
		i = encodeVarintInternal(data, i, uint64(m.Get.Size()))
		n37, err := m.Get.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n37
	}
	if m.Put != nil {
		data[i] = 0x1a
		i++
		i = encodeVarintInternal(data, i, uint64(m.Put.Size()))
		n38, err := m.Put.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n38
	}
	if m.ConditionalPut != nil {
		data[i] = 0x22
		i++
		i = encodeVarintInternal(data, i, uint64(m.ConditionalPut.Size()))
		n39, err := m.ConditionalPut.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n39
	}
	if m.Increment != nil {
		data[i] = 0x2a
		i++
		i = encodeVarintInternal(data, i, uint64(m.Increment.Size()))
		n40, err := m.Increment.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n40
	}
	if m.Delete != nil {
		data[i] = 0x32
		i++
		i = encodeVarintInternal(data, i, uint64(m.Delete.Size()))
		n41, err := m.Delete.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n41
	}
	if m.DeleteRange != nil {
		data[i] = 0x3a
		i++
		i = encodeVarintInternal(data, i, uint64(m.DeleteRange.Size()))
		n42, err := m.DeleteRange.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n42
	}
	if m.Scan != nil {
		data[i] = 0x42
		i++
		i = encodeVarintInternal(data, i, uint64(m.Scan.Size()))
		n43, err := m.Scan.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n43
	}
	if m.EndTransaction != nil {
		data[i] = 0x4a
		i++
		i = encodeVarintInternal(data, i, uint64(m.EndTransaction.Size()))
		n44, err := m.EndTransaction.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n44
	}
	if m.ReapQueue != nil {
		data[i] = 0x52
		i++
		i = encodeVarintInternal(data, i, uint64(m.ReapQueue.Size()))
		n45, err := m.ReapQueue.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n45
	}
	if m.EnqueueUpdate != nil {
		data[i] = 0x5a
		i++
		i = encodeVarintInternal(data, i, uint64(m.EnqueueUpdate.Size()))
		n46, err := m.EnqueueUpdate.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n46
	}
	if m.EnqueueMessage != nil {
		data[i] = 0x62
		i++
		i = encodeVarintInternal(data, i, uint64(m.EnqueueMessage.Size()))
		n47, err := m.EnqueueMessage.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n47
	}
	if m.Batch != nil {
		data[i] = 0xf2
		i++
		data[i] = 0x1
		i++
		i = encodeVarintInternal(data, i, uint64(m.Batch.Size()))
		n48, err := m.Batch.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n48
	}
	if m.InternalRangeLookup != nil {
		data[i] = 0xfa
		i++
		data[i] = 0x1
		i++
		i = encodeVarintInternal(data, i, uint64(m.InternalRangeLookup.Size()))
		n49, err := m.InternalRangeLookup.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n49
	}
	if m.InternalHeartbeatTxn != nil {
		data[i] = 0x82
		i++
		data[i] = 0x2
		i++
		i = encodeVarintInternal(data, i, uint64(m.InternalHeartbeatTxn.Size()))
		n50, err := m.InternalHeartbeatTxn.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n50
	}
	if m.InternalPushTxn != nil {
		data[i] = 0x8a
		i++
		data[i] = 0x2
		i++
		i = encodeVarintInternal(data, i, uint64(m.InternalPushTxn.Size()))
		n51, err := m.InternalPushTxn.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n51
	}
	if m.InternalResolveIntent != nil {
		data[i] = 0x92
		i++
		data[i] = 0x2
		i++
		i = encodeVarintInternal(data, i, uint64(m.InternalResolveIntent.Size()))
		n52, err := m.InternalResolveIntent.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n52
	}
	if m.InternalMergeResponse != nil {
		data[i] = 0x9a
		i++
		data[i] = 0x2
		i++
		i = encodeVarintInternal(data, i, uint64(m.InternalMergeResponse.Size()))
		n53, err := m.InternalMergeResponse.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n53
	}
	if m.InternalTruncateLog != nil {
		data[i] = 0xa2
		i++
		data[i] = 0x2
		i++
		i = encodeVarintInternal(data, i, uint64(m.InternalTruncateLog.Size()))
		n54, err := m.InternalTruncateLog.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n54
	}
	if m.InternalGc != nil {
		data[i] = 0xaa
		i++
		data[i] = 0x2
		i++
		i = encodeVarintInternal(data, i, uint64(m.InternalGc.Size()))
		n55, err := m.InternalGc.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n55
	}
	if m.XXX_unrecognized != nil {
		i += copy(data[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *InternalRaftCommand) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *InternalRaftCommand) MarshalTo(data []byte) (n int, err error) {
	var i int
	_ = i
	var l int
	_ = l
	data[i] = 0x10
	i++
	i = encodeVarintInternal(data, i, uint64(m.RaftID))
	data[i] = 0x1a
	i++
	i = encodeVarintInternal(data, i, uint64(m.Cmd.Size()))
	n56, err := m.Cmd.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n56
	if m.XXX_unrecognized != nil {
		i += copy(data[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *RaftMessageRequest) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *RaftMessageRequest) MarshalTo(data []byte) (n int, err error) {
	var i int
	_ = i
	var l int
	_ = l
	data[i] = 0x8
	i++
	i = encodeVarintInternal(data, i, uint64(m.GroupID))
	if m.Msg != nil {
		data[i] = 0x12
		i++
		i = encodeVarintInternal(data, i, uint64(len(m.Msg)))
		i += copy(data[i:], m.Msg)
	}
	if m.XXX_unrecognized != nil {
		i += copy(data[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *RaftMessageResponse) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *RaftMessageResponse) MarshalTo(data []byte) (n int, err error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i += copy(data[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *InternalTimeSeriesData) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *InternalTimeSeriesData) MarshalTo(data []byte) (n int, err error) {
	var i int
	_ = i
	var l int
	_ = l
	data[i] = 0x8
	i++
	i = encodeVarintInternal(data, i, uint64(m.StartTimestampNanos))
	data[i] = 0x10
	i++
	i = encodeVarintInternal(data, i, uint64(m.SampleDurationNanos))
	if len(m.Samples) > 0 {
		for _, msg := range m.Samples {
			data[i] = 0x1a
			i++
			i = encodeVarintInternal(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(data[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *InternalTimeSeriesSample) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *InternalTimeSeriesSample) MarshalTo(data []byte) (n int, err error) {
	var i int
	_ = i
	var l int
	_ = l
	data[i] = 0x8
	i++
	i = encodeVarintInternal(data, i, uint64(m.Offset))
	data[i] = 0x10
	i++
	i = encodeVarintInternal(data, i, uint64(m.IntCount))
	if m.IntSum != nil {
		data[i] = 0x18
		i++
		i = encodeVarintInternal(data, i, uint64(*m.IntSum))
	}
	if m.IntMax != nil {
		data[i] = 0x20
		i++
		i = encodeVarintInternal(data, i, uint64(*m.IntMax))
	}
	if m.IntMin != nil {
		data[i] = 0x28
		i++
		i = encodeVarintInternal(data, i, uint64(*m.IntMin))
	}
	data[i] = 0x30
	i++
	i = encodeVarintInternal(data, i, uint64(m.FloatCount))
	if m.FloatSum != nil {
		data[i] = 0x3d
		i++
		i = encodeFixed32Internal(data, i, uint32(math.Float32bits(*m.FloatSum)))
	}
	if m.FloatMax != nil {
		data[i] = 0x45
		i++
		i = encodeFixed32Internal(data, i, uint32(math.Float32bits(*m.FloatMax)))
	}
	if m.FloatMin != nil {
		data[i] = 0x4d
		i++
		i = encodeFixed32Internal(data, i, uint32(math.Float32bits(*m.FloatMin)))
	}
	if m.XXX_unrecognized != nil {
		i += copy(data[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *RaftTruncatedState) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *RaftTruncatedState) MarshalTo(data []byte) (n int, err error) {
	var i int
	_ = i
	var l int
	_ = l
	data[i] = 0x8
	i++
	i = encodeVarintInternal(data, i, uint64(m.Index))
	data[i] = 0x10
	i++
	i = encodeVarintInternal(data, i, uint64(m.Term))
	if m.XXX_unrecognized != nil {
		i += copy(data[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *RaftSnapshotData) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *RaftSnapshotData) MarshalTo(data []byte) (n int, err error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.KV) > 0 {
		for _, msg := range m.KV {
			data[i] = 0xa
			i++
			i = encodeVarintInternal(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(data[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *RaftSnapshotData_KeyValue) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *RaftSnapshotData_KeyValue) MarshalTo(data []byte) (n int, err error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Key != nil {
		data[i] = 0xa
		i++
		i = encodeVarintInternal(data, i, uint64(len(m.Key)))
		i += copy(data[i:], m.Key)
	}
	if m.Value != nil {
		data[i] = 0x12
		i++
		i = encodeVarintInternal(data, i, uint64(len(m.Value)))
		i += copy(data[i:], m.Value)
	}
	if m.XXX_unrecognized != nil {
		i += copy(data[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func encodeFixed64Internal(data []byte, offset int, v uint64) int {
	data[offset] = uint8(v)
	data[offset+1] = uint8(v >> 8)
	data[offset+2] = uint8(v >> 16)
	data[offset+3] = uint8(v >> 24)
	data[offset+4] = uint8(v >> 32)
	data[offset+5] = uint8(v >> 40)
	data[offset+6] = uint8(v >> 48)
	data[offset+7] = uint8(v >> 56)
	return offset + 8
}
func encodeFixed32Internal(data []byte, offset int, v uint32) int {
	data[offset] = uint8(v)
	data[offset+1] = uint8(v >> 8)
	data[offset+2] = uint8(v >> 16)
	data[offset+3] = uint8(v >> 24)
	return offset + 4
}
func encodeVarintInternal(data []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		data[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	data[offset] = uint8(v)
	return offset + 1
}
