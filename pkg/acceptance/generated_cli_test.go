// Copyright 2023 The Cockroach Authors.
//
// Use of this software is governed by the Business Source License
// included in the file licenses/BSL.txt.
//
// As of the Change Date specified in that file, in accordance with
// the Business Source License, use of this software will be governed
// by the Apache License, Version 2.0, included in the file
// licenses/APL.txt.

// Code generated by generate-acceptance-tests, DO NOT EDIT.

package acceptance

import (
	"context"
	"fmt"
	"path/filepath"
	"testing"

	"github.com/cockroachdb/cockroach/pkg/acceptance/cluster"
	"github.com/cockroachdb/cockroach/pkg/build/bazel"
	"github.com/cockroachdb/cockroach/pkg/security/username"
	"github.com/cockroachdb/cockroach/pkg/testutils/skip"
	"github.com/cockroachdb/cockroach/pkg/util/log"
)

var cmdBase = []string{
	"/usr/bin/env",
	"COCKROACH_SKIP_UPDATE_CHECK=1",
	"COCKROACH_CRASH_REPORTS=",
	"/bin/bash",
	"-c",
}

func TestDockerCLI_test_audit_log(t *testing.T) {
	s := log.Scope(t)
	defer s.Close(t)

	containerConfig := defaultContainerConfig()
	containerConfig.Cmd = []string{"stat", cluster.CockroachBinaryInContainer}
	containerConfig.Env = []string{
		"CI=1", // Disables the initial color query by the termenv library.
		fmt.Sprintf("PGUSER=%s", username.RootUser),
	}
	ctx := context.Background()
	if err := testDockerOneShot(ctx, t, "cli_test_test_audit_log", containerConfig); err != nil {
		skip.IgnoreLintf(t, "TODO(dt): No binary in one-shot container, see #6086: %s", err)
	}

	containerPath := "/go/src/github.com/cockroachdb/cockroach/cli/interactive_tests"
	if bazel.BuiltWithBazel() {
		containerPath = "/mnt/interactive_tests"
	}
	testFile := filepath.Base("../cli/interactive_tests/test_audit_log.tcl")
	testPath := filepath.Join(containerPath, testFile)
	t.Run(testFile, func(t *testing.T) {
		log.Infof(ctx, "-- starting tests from: %s", testFile)

		// Symlink the logs directory to /logs, which is visible outside of the
		// container and preserved if the test fails. (They don't write to /logs
		// directly because they are often run manually outside of Docker, where
		// /logs is unlikely to exist.)
		cmd := "ln -s /logs logs"

		// We run the expect command using 'bash -c "(expect ...)"'.
		//
		// We cannot run "expect" directly, nor "bash -c 'expect ...'",
		// because both cause Expect to become the PID 1 process inside
		// the container. On Unix, orphan processes need to be wait()ed
		// upon by the PID 1 process when they terminate, lest they
		// remain forever in the zombie state. Unfortunately, Expect
		// does not contain code to do this. Bash does.
		cmd += "; (expect -d -f " + testPath + " " + cluster.CockroachBinaryInContainer + ")"
		containerConfig.Cmd = append(cmdBase, cmd)

		if err := testDockerOneShot(ctx, t, "cli_test_test_audit_log", containerConfig); err != nil {
			t.Error(err)
		}
	})
}

func TestDockerCLI_test_auto_trace(t *testing.T) {
	s := log.Scope(t)
	defer s.Close(t)

	containerConfig := defaultContainerConfig()
	containerConfig.Cmd = []string{"stat", cluster.CockroachBinaryInContainer}
	containerConfig.Env = []string{
		"CI=1", // Disables the initial color query by the termenv library.
		fmt.Sprintf("PGUSER=%s", username.RootUser),
	}
	ctx := context.Background()
	if err := testDockerOneShot(ctx, t, "cli_test_test_auto_trace", containerConfig); err != nil {
		skip.IgnoreLintf(t, "TODO(dt): No binary in one-shot container, see #6086: %s", err)
	}

	containerPath := "/go/src/github.com/cockroachdb/cockroach/cli/interactive_tests"
	if bazel.BuiltWithBazel() {
		containerPath = "/mnt/interactive_tests"
	}
	testFile := filepath.Base("../cli/interactive_tests/test_auto_trace.tcl")
	testPath := filepath.Join(containerPath, testFile)
	t.Run(testFile, func(t *testing.T) {
		log.Infof(ctx, "-- starting tests from: %s", testFile)

		// Symlink the logs directory to /logs, which is visible outside of the
		// container and preserved if the test fails. (They don't write to /logs
		// directly because they are often run manually outside of Docker, where
		// /logs is unlikely to exist.)
		cmd := "ln -s /logs logs"

		// We run the expect command using 'bash -c "(expect ...)"'.
		//
		// We cannot run "expect" directly, nor "bash -c 'expect ...'",
		// because both cause Expect to become the PID 1 process inside
		// the container. On Unix, orphan processes need to be wait()ed
		// upon by the PID 1 process when they terminate, lest they
		// remain forever in the zombie state. Unfortunately, Expect
		// does not contain code to do this. Bash does.
		cmd += "; (expect -d -f " + testPath + " " + cluster.CockroachBinaryInContainer + ")"
		containerConfig.Cmd = append(cmdBase, cmd)

		if err := testDockerOneShot(ctx, t, "cli_test_test_auto_trace", containerConfig); err != nil {
			t.Error(err)
		}
	})
}

func TestDockerCLI_test_cert_advisory_validation(t *testing.T) {
	s := log.Scope(t)
	defer s.Close(t)

	containerConfig := defaultContainerConfig()
	containerConfig.Cmd = []string{"stat", cluster.CockroachBinaryInContainer}
	containerConfig.Env = []string{
		"CI=1", // Disables the initial color query by the termenv library.
		fmt.Sprintf("PGUSER=%s", username.RootUser),
	}
	ctx := context.Background()
	if err := testDockerOneShot(ctx, t, "cli_test_test_cert_advisory_validation", containerConfig); err != nil {
		skip.IgnoreLintf(t, "TODO(dt): No binary in one-shot container, see #6086: %s", err)
	}

	containerPath := "/go/src/github.com/cockroachdb/cockroach/cli/interactive_tests"
	if bazel.BuiltWithBazel() {
		containerPath = "/mnt/interactive_tests"
	}
	testFile := filepath.Base("../cli/interactive_tests/test_cert_advisory_validation.tcl")
	testPath := filepath.Join(containerPath, testFile)
	t.Run(testFile, func(t *testing.T) {
		log.Infof(ctx, "-- starting tests from: %s", testFile)

		// Symlink the logs directory to /logs, which is visible outside of the
		// container and preserved if the test fails. (They don't write to /logs
		// directly because they are often run manually outside of Docker, where
		// /logs is unlikely to exist.)
		cmd := "ln -s /logs logs"

		// We run the expect command using 'bash -c "(expect ...)"'.
		//
		// We cannot run "expect" directly, nor "bash -c 'expect ...'",
		// because both cause Expect to become the PID 1 process inside
		// the container. On Unix, orphan processes need to be wait()ed
		// upon by the PID 1 process when they terminate, lest they
		// remain forever in the zombie state. Unfortunately, Expect
		// does not contain code to do this. Bash does.
		cmd += "; (expect -d -f " + testPath + " " + cluster.CockroachBinaryInContainer + ")"
		containerConfig.Cmd = append(cmdBase, cmd)

		if err := testDockerOneShot(ctx, t, "cli_test_test_cert_advisory_validation", containerConfig); err != nil {
			t.Error(err)
		}
	})
}

func TestDockerCLI_test_changefeed(t *testing.T) {
	s := log.Scope(t)
	defer s.Close(t)

	containerConfig := defaultContainerConfig()
	containerConfig.Cmd = []string{"stat", cluster.CockroachBinaryInContainer}
	containerConfig.Env = []string{
		"CI=1", // Disables the initial color query by the termenv library.
		fmt.Sprintf("PGUSER=%s", username.RootUser),
	}
	ctx := context.Background()
	if err := testDockerOneShot(ctx, t, "cli_test_test_changefeed", containerConfig); err != nil {
		skip.IgnoreLintf(t, "TODO(dt): No binary in one-shot container, see #6086: %s", err)
	}

	containerPath := "/go/src/github.com/cockroachdb/cockroach/cli/interactive_tests"
	if bazel.BuiltWithBazel() {
		containerPath = "/mnt/interactive_tests"
	}
	testFile := filepath.Base("../cli/interactive_tests/test_changefeed.tcl")
	testPath := filepath.Join(containerPath, testFile)
	t.Run(testFile, func(t *testing.T) {
		log.Infof(ctx, "-- starting tests from: %s", testFile)

		// Symlink the logs directory to /logs, which is visible outside of the
		// container and preserved if the test fails. (They don't write to /logs
		// directly because they are often run manually outside of Docker, where
		// /logs is unlikely to exist.)
		cmd := "ln -s /logs logs"

		// We run the expect command using 'bash -c "(expect ...)"'.
		//
		// We cannot run "expect" directly, nor "bash -c 'expect ...'",
		// because both cause Expect to become the PID 1 process inside
		// the container. On Unix, orphan processes need to be wait()ed
		// upon by the PID 1 process when they terminate, lest they
		// remain forever in the zombie state. Unfortunately, Expect
		// does not contain code to do this. Bash does.
		cmd += "; (expect -d -f " + testPath + " " + cluster.CockroachBinaryInContainer + ")"
		containerConfig.Cmd = append(cmdBase, cmd)

		if err := testDockerOneShot(ctx, t, "cli_test_test_changefeed", containerConfig); err != nil {
			t.Error(err)
		}
	})
}

func TestDockerCLI_test_client_side_checking(t *testing.T) {
	s := log.Scope(t)
	defer s.Close(t)

	containerConfig := defaultContainerConfig()
	containerConfig.Cmd = []string{"stat", cluster.CockroachBinaryInContainer}
	containerConfig.Env = []string{
		"CI=1", // Disables the initial color query by the termenv library.
		fmt.Sprintf("PGUSER=%s", username.RootUser),
	}
	ctx := context.Background()
	if err := testDockerOneShot(ctx, t, "cli_test_test_client_side_checking", containerConfig); err != nil {
		skip.IgnoreLintf(t, "TODO(dt): No binary in one-shot container, see #6086: %s", err)
	}

	containerPath := "/go/src/github.com/cockroachdb/cockroach/cli/interactive_tests"
	if bazel.BuiltWithBazel() {
		containerPath = "/mnt/interactive_tests"
	}
	testFile := filepath.Base("../cli/interactive_tests/test_client_side_checking.tcl")
	testPath := filepath.Join(containerPath, testFile)
	t.Run(testFile, func(t *testing.T) {
		log.Infof(ctx, "-- starting tests from: %s", testFile)

		// Symlink the logs directory to /logs, which is visible outside of the
		// container and preserved if the test fails. (They don't write to /logs
		// directly because they are often run manually outside of Docker, where
		// /logs is unlikely to exist.)
		cmd := "ln -s /logs logs"

		// We run the expect command using 'bash -c "(expect ...)"'.
		//
		// We cannot run "expect" directly, nor "bash -c 'expect ...'",
		// because both cause Expect to become the PID 1 process inside
		// the container. On Unix, orphan processes need to be wait()ed
		// upon by the PID 1 process when they terminate, lest they
		// remain forever in the zombie state. Unfortunately, Expect
		// does not contain code to do this. Bash does.
		cmd += "; (expect -d -f " + testPath + " " + cluster.CockroachBinaryInContainer + ")"
		containerConfig.Cmd = append(cmdBase, cmd)

		if err := testDockerOneShot(ctx, t, "cli_test_test_client_side_checking", containerConfig); err != nil {
			t.Error(err)
		}
	})
}

func TestDockerCLI_test_cluster_name(t *testing.T) {
	s := log.Scope(t)
	defer s.Close(t)

	containerConfig := defaultContainerConfig()
	containerConfig.Cmd = []string{"stat", cluster.CockroachBinaryInContainer}
	containerConfig.Env = []string{
		"CI=1", // Disables the initial color query by the termenv library.
		fmt.Sprintf("PGUSER=%s", username.RootUser),
	}
	ctx := context.Background()
	if err := testDockerOneShot(ctx, t, "cli_test_test_cluster_name", containerConfig); err != nil {
		skip.IgnoreLintf(t, "TODO(dt): No binary in one-shot container, see #6086: %s", err)
	}

	containerPath := "/go/src/github.com/cockroachdb/cockroach/cli/interactive_tests"
	if bazel.BuiltWithBazel() {
		containerPath = "/mnt/interactive_tests"
	}
	testFile := filepath.Base("../cli/interactive_tests/test_cluster_name.tcl")
	testPath := filepath.Join(containerPath, testFile)
	t.Run(testFile, func(t *testing.T) {
		log.Infof(ctx, "-- starting tests from: %s", testFile)

		// Symlink the logs directory to /logs, which is visible outside of the
		// container and preserved if the test fails. (They don't write to /logs
		// directly because they are often run manually outside of Docker, where
		// /logs is unlikely to exist.)
		cmd := "ln -s /logs logs"

		// We run the expect command using 'bash -c "(expect ...)"'.
		//
		// We cannot run "expect" directly, nor "bash -c 'expect ...'",
		// because both cause Expect to become the PID 1 process inside
		// the container. On Unix, orphan processes need to be wait()ed
		// upon by the PID 1 process when they terminate, lest they
		// remain forever in the zombie state. Unfortunately, Expect
		// does not contain code to do this. Bash does.
		cmd += "; (expect -d -f " + testPath + " " + cluster.CockroachBinaryInContainer + ")"
		containerConfig.Cmd = append(cmdBase, cmd)

		if err := testDockerOneShot(ctx, t, "cli_test_test_cluster_name", containerConfig); err != nil {
			t.Error(err)
		}
	})
}

func TestDockerCLI_test_connect(t *testing.T) {
	s := log.Scope(t)
	defer s.Close(t)

	containerConfig := defaultContainerConfig()
	containerConfig.Cmd = []string{"stat", cluster.CockroachBinaryInContainer}
	containerConfig.Env = []string{
		"CI=1", // Disables the initial color query by the termenv library.
		fmt.Sprintf("PGUSER=%s", username.RootUser),
	}
	ctx := context.Background()
	if err := testDockerOneShot(ctx, t, "cli_test_test_connect", containerConfig); err != nil {
		skip.IgnoreLintf(t, "TODO(dt): No binary in one-shot container, see #6086: %s", err)
	}

	containerPath := "/go/src/github.com/cockroachdb/cockroach/cli/interactive_tests"
	if bazel.BuiltWithBazel() {
		containerPath = "/mnt/interactive_tests"
	}
	testFile := filepath.Base("../cli/interactive_tests/test_connect.tcl")
	testPath := filepath.Join(containerPath, testFile)
	t.Run(testFile, func(t *testing.T) {
		log.Infof(ctx, "-- starting tests from: %s", testFile)

		// Symlink the logs directory to /logs, which is visible outside of the
		// container and preserved if the test fails. (They don't write to /logs
		// directly because they are often run manually outside of Docker, where
		// /logs is unlikely to exist.)
		cmd := "ln -s /logs logs"

		// We run the expect command using 'bash -c "(expect ...)"'.
		//
		// We cannot run "expect" directly, nor "bash -c 'expect ...'",
		// because both cause Expect to become the PID 1 process inside
		// the container. On Unix, orphan processes need to be wait()ed
		// upon by the PID 1 process when they terminate, lest they
		// remain forever in the zombie state. Unfortunately, Expect
		// does not contain code to do this. Bash does.
		cmd += "; (expect -d -f " + testPath + " " + cluster.CockroachBinaryInContainer + ")"
		containerConfig.Cmd = append(cmdBase, cmd)

		if err := testDockerOneShot(ctx, t, "cli_test_test_connect", containerConfig); err != nil {
			t.Error(err)
		}
	})
}

func TestDockerCLI_test_connect_cmd(t *testing.T) {
	s := log.Scope(t)
	defer s.Close(t)

	containerConfig := defaultContainerConfig()
	containerConfig.Cmd = []string{"stat", cluster.CockroachBinaryInContainer}
	containerConfig.Env = []string{
		"CI=1", // Disables the initial color query by the termenv library.
		fmt.Sprintf("PGUSER=%s", username.RootUser),
	}
	ctx := context.Background()
	if err := testDockerOneShot(ctx, t, "cli_test_test_connect_cmd", containerConfig); err != nil {
		skip.IgnoreLintf(t, "TODO(dt): No binary in one-shot container, see #6086: %s", err)
	}

	containerPath := "/go/src/github.com/cockroachdb/cockroach/cli/interactive_tests"
	if bazel.BuiltWithBazel() {
		containerPath = "/mnt/interactive_tests"
	}
	testFile := filepath.Base("../cli/interactive_tests/test_connect_cmd.tcl")
	testPath := filepath.Join(containerPath, testFile)
	t.Run(testFile, func(t *testing.T) {
		log.Infof(ctx, "-- starting tests from: %s", testFile)

		// Symlink the logs directory to /logs, which is visible outside of the
		// container and preserved if the test fails. (They don't write to /logs
		// directly because they are often run manually outside of Docker, where
		// /logs is unlikely to exist.)
		cmd := "ln -s /logs logs"

		// We run the expect command using 'bash -c "(expect ...)"'.
		//
		// We cannot run "expect" directly, nor "bash -c 'expect ...'",
		// because both cause Expect to become the PID 1 process inside
		// the container. On Unix, orphan processes need to be wait()ed
		// upon by the PID 1 process when they terminate, lest they
		// remain forever in the zombie state. Unfortunately, Expect
		// does not contain code to do this. Bash does.
		cmd += "; (expect -d -f " + testPath + " " + cluster.CockroachBinaryInContainer + ")"
		containerConfig.Cmd = append(cmdBase, cmd)

		if err := testDockerOneShot(ctx, t, "cli_test_test_connect_cmd", containerConfig); err != nil {
			t.Error(err)
		}
	})
}

func TestDockerCLI_test_contextual_help(t *testing.T) {
	s := log.Scope(t)
	defer s.Close(t)

	containerConfig := defaultContainerConfig()
	containerConfig.Cmd = []string{"stat", cluster.CockroachBinaryInContainer}
	containerConfig.Env = []string{
		"CI=1", // Disables the initial color query by the termenv library.
		fmt.Sprintf("PGUSER=%s", username.RootUser),
	}
	ctx := context.Background()
	if err := testDockerOneShot(ctx, t, "cli_test_test_contextual_help", containerConfig); err != nil {
		skip.IgnoreLintf(t, "TODO(dt): No binary in one-shot container, see #6086: %s", err)
	}

	containerPath := "/go/src/github.com/cockroachdb/cockroach/cli/interactive_tests"
	if bazel.BuiltWithBazel() {
		containerPath = "/mnt/interactive_tests"
	}
	testFile := filepath.Base("../cli/interactive_tests/test_contextual_help.tcl")
	testPath := filepath.Join(containerPath, testFile)
	t.Run(testFile, func(t *testing.T) {
		log.Infof(ctx, "-- starting tests from: %s", testFile)

		// Symlink the logs directory to /logs, which is visible outside of the
		// container and preserved if the test fails. (They don't write to /logs
		// directly because they are often run manually outside of Docker, where
		// /logs is unlikely to exist.)
		cmd := "ln -s /logs logs"

		// We run the expect command using 'bash -c "(expect ...)"'.
		//
		// We cannot run "expect" directly, nor "bash -c 'expect ...'",
		// because both cause Expect to become the PID 1 process inside
		// the container. On Unix, orphan processes need to be wait()ed
		// upon by the PID 1 process when they terminate, lest they
		// remain forever in the zombie state. Unfortunately, Expect
		// does not contain code to do this. Bash does.
		cmd += "; (expect -d -f " + testPath + " " + cluster.CockroachBinaryInContainer + ")"
		containerConfig.Cmd = append(cmdBase, cmd)

		if err := testDockerOneShot(ctx, t, "cli_test_test_contextual_help", containerConfig); err != nil {
			t.Error(err)
		}
	})
}

func TestDockerCLI_test_copy(t *testing.T) {
	s := log.Scope(t)
	defer s.Close(t)

	containerConfig := defaultContainerConfig()
	containerConfig.Cmd = []string{"stat", cluster.CockroachBinaryInContainer}
	containerConfig.Env = []string{
		"CI=1", // Disables the initial color query by the termenv library.
		fmt.Sprintf("PGUSER=%s", username.RootUser),
	}
	ctx := context.Background()
	if err := testDockerOneShot(ctx, t, "cli_test_test_copy", containerConfig); err != nil {
		skip.IgnoreLintf(t, "TODO(dt): No binary in one-shot container, see #6086: %s", err)
	}

	containerPath := "/go/src/github.com/cockroachdb/cockroach/cli/interactive_tests"
	if bazel.BuiltWithBazel() {
		containerPath = "/mnt/interactive_tests"
	}
	testFile := filepath.Base("../cli/interactive_tests/test_copy.tcl")
	testPath := filepath.Join(containerPath, testFile)
	t.Run(testFile, func(t *testing.T) {
		log.Infof(ctx, "-- starting tests from: %s", testFile)

		// Symlink the logs directory to /logs, which is visible outside of the
		// container and preserved if the test fails. (They don't write to /logs
		// directly because they are often run manually outside of Docker, where
		// /logs is unlikely to exist.)
		cmd := "ln -s /logs logs"

		// We run the expect command using 'bash -c "(expect ...)"'.
		//
		// We cannot run "expect" directly, nor "bash -c 'expect ...'",
		// because both cause Expect to become the PID 1 process inside
		// the container. On Unix, orphan processes need to be wait()ed
		// upon by the PID 1 process when they terminate, lest they
		// remain forever in the zombie state. Unfortunately, Expect
		// does not contain code to do this. Bash does.
		cmd += "; (expect -d -f " + testPath + " " + cluster.CockroachBinaryInContainer + ")"
		containerConfig.Cmd = append(cmdBase, cmd)

		if err := testDockerOneShot(ctx, t, "cli_test_test_copy", containerConfig); err != nil {
			t.Error(err)
		}
	})
}

func TestDockerCLI_test_demo_changefeeds(t *testing.T) {
	s := log.Scope(t)
	defer s.Close(t)

	containerConfig := defaultContainerConfig()
	containerConfig.Cmd = []string{"stat", cluster.CockroachBinaryInContainer}
	containerConfig.Env = []string{
		"CI=1", // Disables the initial color query by the termenv library.
		fmt.Sprintf("PGUSER=%s", username.RootUser),
	}
	ctx := context.Background()
	if err := testDockerOneShot(ctx, t, "cli_test_test_demo_changefeeds", containerConfig); err != nil {
		skip.IgnoreLintf(t, "TODO(dt): No binary in one-shot container, see #6086: %s", err)
	}

	containerPath := "/go/src/github.com/cockroachdb/cockroach/cli/interactive_tests"
	if bazel.BuiltWithBazel() {
		containerPath = "/mnt/interactive_tests"
	}
	testFile := filepath.Base("../cli/interactive_tests/test_demo_changefeeds.tcl")
	testPath := filepath.Join(containerPath, testFile)
	t.Run(testFile, func(t *testing.T) {
		log.Infof(ctx, "-- starting tests from: %s", testFile)

		// Symlink the logs directory to /logs, which is visible outside of the
		// container and preserved if the test fails. (They don't write to /logs
		// directly because they are often run manually outside of Docker, where
		// /logs is unlikely to exist.)
		cmd := "ln -s /logs logs"

		// We run the expect command using 'bash -c "(expect ...)"'.
		//
		// We cannot run "expect" directly, nor "bash -c 'expect ...'",
		// because both cause Expect to become the PID 1 process inside
		// the container. On Unix, orphan processes need to be wait()ed
		// upon by the PID 1 process when they terminate, lest they
		// remain forever in the zombie state. Unfortunately, Expect
		// does not contain code to do this. Bash does.
		cmd += "; (expect -d -f " + testPath + " " + cluster.CockroachBinaryInContainer + ")"
		containerConfig.Cmd = append(cmdBase, cmd)

		if err := testDockerOneShot(ctx, t, "cli_test_test_demo_changefeeds", containerConfig); err != nil {
			t.Error(err)
		}
	})
}

func TestDockerCLI_test_demo_global(t *testing.T) {
	s := log.Scope(t)
	defer s.Close(t)

	containerConfig := defaultContainerConfig()
	containerConfig.Cmd = []string{"stat", cluster.CockroachBinaryInContainer}
	containerConfig.Env = []string{
		"CI=1", // Disables the initial color query by the termenv library.
		fmt.Sprintf("PGUSER=%s", username.RootUser),
	}
	ctx := context.Background()
	if err := testDockerOneShot(ctx, t, "cli_test_test_demo_global", containerConfig); err != nil {
		skip.IgnoreLintf(t, "TODO(dt): No binary in one-shot container, see #6086: %s", err)
	}

	containerPath := "/go/src/github.com/cockroachdb/cockroach/cli/interactive_tests"
	if bazel.BuiltWithBazel() {
		containerPath = "/mnt/interactive_tests"
	}
	testFile := filepath.Base("../cli/interactive_tests/test_demo_global.tcl")
	testPath := filepath.Join(containerPath, testFile)
	t.Run(testFile, func(t *testing.T) {
		log.Infof(ctx, "-- starting tests from: %s", testFile)

		// Symlink the logs directory to /logs, which is visible outside of the
		// container and preserved if the test fails. (They don't write to /logs
		// directly because they are often run manually outside of Docker, where
		// /logs is unlikely to exist.)
		cmd := "ln -s /logs logs"

		// We run the expect command using 'bash -c "(expect ...)"'.
		//
		// We cannot run "expect" directly, nor "bash -c 'expect ...'",
		// because both cause Expect to become the PID 1 process inside
		// the container. On Unix, orphan processes need to be wait()ed
		// upon by the PID 1 process when they terminate, lest they
		// remain forever in the zombie state. Unfortunately, Expect
		// does not contain code to do this. Bash does.
		cmd += "; (expect -d -f " + testPath + " " + cluster.CockroachBinaryInContainer + ")"
		containerConfig.Cmd = append(cmdBase, cmd)

		if err := testDockerOneShot(ctx, t, "cli_test_test_demo_global", containerConfig); err != nil {
			t.Error(err)
		}
	})
}

func TestDockerCLI_test_demo_global_insecure(t *testing.T) {
	s := log.Scope(t)
	defer s.Close(t)

	containerConfig := defaultContainerConfig()
	containerConfig.Cmd = []string{"stat", cluster.CockroachBinaryInContainer}
	containerConfig.Env = []string{
		"CI=1", // Disables the initial color query by the termenv library.
		fmt.Sprintf("PGUSER=%s", username.RootUser),
	}
	ctx := context.Background()
	if err := testDockerOneShot(ctx, t, "cli_test_test_demo_global_insecure", containerConfig); err != nil {
		skip.IgnoreLintf(t, "TODO(dt): No binary in one-shot container, see #6086: %s", err)
	}

	containerPath := "/go/src/github.com/cockroachdb/cockroach/cli/interactive_tests"
	if bazel.BuiltWithBazel() {
		containerPath = "/mnt/interactive_tests"
	}
	testFile := filepath.Base("../cli/interactive_tests/test_demo_global_insecure.tcl")
	testPath := filepath.Join(containerPath, testFile)
	t.Run(testFile, func(t *testing.T) {
		log.Infof(ctx, "-- starting tests from: %s", testFile)

		// Symlink the logs directory to /logs, which is visible outside of the
		// container and preserved if the test fails. (They don't write to /logs
		// directly because they are often run manually outside of Docker, where
		// /logs is unlikely to exist.)
		cmd := "ln -s /logs logs"

		// We run the expect command using 'bash -c "(expect ...)"'.
		//
		// We cannot run "expect" directly, nor "bash -c 'expect ...'",
		// because both cause Expect to become the PID 1 process inside
		// the container. On Unix, orphan processes need to be wait()ed
		// upon by the PID 1 process when they terminate, lest they
		// remain forever in the zombie state. Unfortunately, Expect
		// does not contain code to do this. Bash does.
		cmd += "; (expect -d -f " + testPath + " " + cluster.CockroachBinaryInContainer + ")"
		containerConfig.Cmd = append(cmdBase, cmd)

		if err := testDockerOneShot(ctx, t, "cli_test_test_demo_global_insecure", containerConfig); err != nil {
			t.Error(err)
		}
	})
}

func TestDockerCLI_test_demo_locality_error(t *testing.T) {
	s := log.Scope(t)
	defer s.Close(t)

	containerConfig := defaultContainerConfig()
	containerConfig.Cmd = []string{"stat", cluster.CockroachBinaryInContainer}
	containerConfig.Env = []string{
		"CI=1", // Disables the initial color query by the termenv library.
		fmt.Sprintf("PGUSER=%s", username.RootUser),
	}
	ctx := context.Background()
	if err := testDockerOneShot(ctx, t, "cli_test_test_demo_locality_error", containerConfig); err != nil {
		skip.IgnoreLintf(t, "TODO(dt): No binary in one-shot container, see #6086: %s", err)
	}

	containerPath := "/go/src/github.com/cockroachdb/cockroach/cli/interactive_tests"
	if bazel.BuiltWithBazel() {
		containerPath = "/mnt/interactive_tests"
	}
	testFile := filepath.Base("../cli/interactive_tests/test_demo_locality_error.tcl")
	testPath := filepath.Join(containerPath, testFile)
	t.Run(testFile, func(t *testing.T) {
		log.Infof(ctx, "-- starting tests from: %s", testFile)

		// Symlink the logs directory to /logs, which is visible outside of the
		// container and preserved if the test fails. (They don't write to /logs
		// directly because they are often run manually outside of Docker, where
		// /logs is unlikely to exist.)
		cmd := "ln -s /logs logs"

		// We run the expect command using 'bash -c "(expect ...)"'.
		//
		// We cannot run "expect" directly, nor "bash -c 'expect ...'",
		// because both cause Expect to become the PID 1 process inside
		// the container. On Unix, orphan processes need to be wait()ed
		// upon by the PID 1 process when they terminate, lest they
		// remain forever in the zombie state. Unfortunately, Expect
		// does not contain code to do this. Bash does.
		cmd += "; (expect -d -f " + testPath + " " + cluster.CockroachBinaryInContainer + ")"
		containerConfig.Cmd = append(cmdBase, cmd)

		if err := testDockerOneShot(ctx, t, "cli_test_test_demo_locality_error", containerConfig); err != nil {
			t.Error(err)
		}
	})
}

func TestDockerCLI_test_demo_memory_warning(t *testing.T) {
	s := log.Scope(t)
	defer s.Close(t)

	containerConfig := defaultContainerConfig()
	containerConfig.Cmd = []string{"stat", cluster.CockroachBinaryInContainer}
	containerConfig.Env = []string{
		"CI=1", // Disables the initial color query by the termenv library.
		fmt.Sprintf("PGUSER=%s", username.RootUser),
	}
	ctx := context.Background()
	if err := testDockerOneShot(ctx, t, "cli_test_test_demo_memory_warning", containerConfig); err != nil {
		skip.IgnoreLintf(t, "TODO(dt): No binary in one-shot container, see #6086: %s", err)
	}

	containerPath := "/go/src/github.com/cockroachdb/cockroach/cli/interactive_tests"
	if bazel.BuiltWithBazel() {
		containerPath = "/mnt/interactive_tests"
	}
	testFile := filepath.Base("../cli/interactive_tests/test_demo_memory_warning.tcl")
	testPath := filepath.Join(containerPath, testFile)
	t.Run(testFile, func(t *testing.T) {
		log.Infof(ctx, "-- starting tests from: %s", testFile)

		// Symlink the logs directory to /logs, which is visible outside of the
		// container and preserved if the test fails. (They don't write to /logs
		// directly because they are often run manually outside of Docker, where
		// /logs is unlikely to exist.)
		cmd := "ln -s /logs logs"

		// We run the expect command using 'bash -c "(expect ...)"'.
		//
		// We cannot run "expect" directly, nor "bash -c 'expect ...'",
		// because both cause Expect to become the PID 1 process inside
		// the container. On Unix, orphan processes need to be wait()ed
		// upon by the PID 1 process when they terminate, lest they
		// remain forever in the zombie state. Unfortunately, Expect
		// does not contain code to do this. Bash does.
		cmd += "; (expect -d -f " + testPath + " " + cluster.CockroachBinaryInContainer + ")"
		containerConfig.Cmd = append(cmdBase, cmd)

		if err := testDockerOneShot(ctx, t, "cli_test_test_demo_memory_warning", containerConfig); err != nil {
			t.Error(err)
		}
	})
}

func TestDockerCLI_test_demo_node_cmds(t *testing.T) {
	s := log.Scope(t)
	defer s.Close(t)

	containerConfig := defaultContainerConfig()
	containerConfig.Cmd = []string{"stat", cluster.CockroachBinaryInContainer}
	containerConfig.Env = []string{
		"CI=1", // Disables the initial color query by the termenv library.
		fmt.Sprintf("PGUSER=%s", username.RootUser),
	}
	ctx := context.Background()
	if err := testDockerOneShot(ctx, t, "cli_test_test_demo_node_cmds", containerConfig); err != nil {
		skip.IgnoreLintf(t, "TODO(dt): No binary in one-shot container, see #6086: %s", err)
	}

	containerPath := "/go/src/github.com/cockroachdb/cockroach/cli/interactive_tests"
	if bazel.BuiltWithBazel() {
		containerPath = "/mnt/interactive_tests"
	}
	testFile := filepath.Base("../cli/interactive_tests/test_demo_node_cmds.tcl")
	testPath := filepath.Join(containerPath, testFile)
	t.Run(testFile, func(t *testing.T) {
		log.Infof(ctx, "-- starting tests from: %s", testFile)

		// Symlink the logs directory to /logs, which is visible outside of the
		// container and preserved if the test fails. (They don't write to /logs
		// directly because they are often run manually outside of Docker, where
		// /logs is unlikely to exist.)
		cmd := "ln -s /logs logs"

		// We run the expect command using 'bash -c "(expect ...)"'.
		//
		// We cannot run "expect" directly, nor "bash -c 'expect ...'",
		// because both cause Expect to become the PID 1 process inside
		// the container. On Unix, orphan processes need to be wait()ed
		// upon by the PID 1 process when they terminate, lest they
		// remain forever in the zombie state. Unfortunately, Expect
		// does not contain code to do this. Bash does.
		cmd += "; (expect -d -f " + testPath + " " + cluster.CockroachBinaryInContainer + ")"
		containerConfig.Cmd = append(cmdBase, cmd)

		if err := testDockerOneShot(ctx, t, "cli_test_test_demo_node_cmds", containerConfig); err != nil {
			t.Error(err)
		}
	})
}

func TestDockerCLI_test_demo_telemetry(t *testing.T) {
	s := log.Scope(t)
	defer s.Close(t)

	containerConfig := defaultContainerConfig()
	containerConfig.Cmd = []string{"stat", cluster.CockroachBinaryInContainer}
	containerConfig.Env = []string{
		"CI=1", // Disables the initial color query by the termenv library.
		fmt.Sprintf("PGUSER=%s", username.RootUser),
	}
	ctx := context.Background()
	if err := testDockerOneShot(ctx, t, "cli_test_test_demo_telemetry", containerConfig); err != nil {
		skip.IgnoreLintf(t, "TODO(dt): No binary in one-shot container, see #6086: %s", err)
	}

	containerPath := "/go/src/github.com/cockroachdb/cockroach/cli/interactive_tests"
	if bazel.BuiltWithBazel() {
		containerPath = "/mnt/interactive_tests"
	}
	testFile := filepath.Base("../cli/interactive_tests/test_demo_telemetry.tcl")
	testPath := filepath.Join(containerPath, testFile)
	t.Run(testFile, func(t *testing.T) {
		log.Infof(ctx, "-- starting tests from: %s", testFile)

		// Symlink the logs directory to /logs, which is visible outside of the
		// container and preserved if the test fails. (They don't write to /logs
		// directly because they are often run manually outside of Docker, where
		// /logs is unlikely to exist.)
		cmd := "ln -s /logs logs"

		// We run the expect command using 'bash -c "(expect ...)"'.
		//
		// We cannot run "expect" directly, nor "bash -c 'expect ...'",
		// because both cause Expect to become the PID 1 process inside
		// the container. On Unix, orphan processes need to be wait()ed
		// upon by the PID 1 process when they terminate, lest they
		// remain forever in the zombie state. Unfortunately, Expect
		// does not contain code to do this. Bash does.
		cmd += "; (expect -d -f " + testPath + " " + cluster.CockroachBinaryInContainer + ")"
		containerConfig.Cmd = append(cmdBase, cmd)

		if err := testDockerOneShot(ctx, t, "cli_test_test_demo_telemetry", containerConfig); err != nil {
			t.Error(err)
		}
	})
}

func TestDockerCLI_test_demo_workload(t *testing.T) {
	s := log.Scope(t)
	defer s.Close(t)

	containerConfig := defaultContainerConfig()
	containerConfig.Cmd = []string{"stat", cluster.CockroachBinaryInContainer}
	containerConfig.Env = []string{
		"CI=1", // Disables the initial color query by the termenv library.
		fmt.Sprintf("PGUSER=%s", username.RootUser),
	}
	ctx := context.Background()
	if err := testDockerOneShot(ctx, t, "cli_test_test_demo_workload", containerConfig); err != nil {
		skip.IgnoreLintf(t, "TODO(dt): No binary in one-shot container, see #6086: %s", err)
	}

	containerPath := "/go/src/github.com/cockroachdb/cockroach/cli/interactive_tests"
	if bazel.BuiltWithBazel() {
		containerPath = "/mnt/interactive_tests"
	}
	testFile := filepath.Base("../cli/interactive_tests/test_demo_workload.tcl")
	testPath := filepath.Join(containerPath, testFile)
	t.Run(testFile, func(t *testing.T) {
		log.Infof(ctx, "-- starting tests from: %s", testFile)

		// Symlink the logs directory to /logs, which is visible outside of the
		// container and preserved if the test fails. (They don't write to /logs
		// directly because they are often run manually outside of Docker, where
		// /logs is unlikely to exist.)
		cmd := "ln -s /logs logs"

		// We run the expect command using 'bash -c "(expect ...)"'.
		//
		// We cannot run "expect" directly, nor "bash -c 'expect ...'",
		// because both cause Expect to become the PID 1 process inside
		// the container. On Unix, orphan processes need to be wait()ed
		// upon by the PID 1 process when they terminate, lest they
		// remain forever in the zombie state. Unfortunately, Expect
		// does not contain code to do this. Bash does.
		cmd += "; (expect -d -f " + testPath + " " + cluster.CockroachBinaryInContainer + ")"
		containerConfig.Cmd = append(cmdBase, cmd)

		if err := testDockerOneShot(ctx, t, "cli_test_test_demo_workload", containerConfig); err != nil {
			t.Error(err)
		}
	})
}

func TestDockerCLI_test_disable_replication(t *testing.T) {
	s := log.Scope(t)
	defer s.Close(t)

	containerConfig := defaultContainerConfig()
	containerConfig.Cmd = []string{"stat", cluster.CockroachBinaryInContainer}
	containerConfig.Env = []string{
		"CI=1", // Disables the initial color query by the termenv library.
		fmt.Sprintf("PGUSER=%s", username.RootUser),
	}
	ctx := context.Background()
	if err := testDockerOneShot(ctx, t, "cli_test_test_disable_replication", containerConfig); err != nil {
		skip.IgnoreLintf(t, "TODO(dt): No binary in one-shot container, see #6086: %s", err)
	}

	containerPath := "/go/src/github.com/cockroachdb/cockroach/cli/interactive_tests"
	if bazel.BuiltWithBazel() {
		containerPath = "/mnt/interactive_tests"
	}
	testFile := filepath.Base("../cli/interactive_tests/test_disable_replication.tcl")
	testPath := filepath.Join(containerPath, testFile)
	t.Run(testFile, func(t *testing.T) {
		log.Infof(ctx, "-- starting tests from: %s", testFile)

		// Symlink the logs directory to /logs, which is visible outside of the
		// container and preserved if the test fails. (They don't write to /logs
		// directly because they are often run manually outside of Docker, where
		// /logs is unlikely to exist.)
		cmd := "ln -s /logs logs"

		// We run the expect command using 'bash -c "(expect ...)"'.
		//
		// We cannot run "expect" directly, nor "bash -c 'expect ...'",
		// because both cause Expect to become the PID 1 process inside
		// the container. On Unix, orphan processes need to be wait()ed
		// upon by the PID 1 process when they terminate, lest they
		// remain forever in the zombie state. Unfortunately, Expect
		// does not contain code to do this. Bash does.
		cmd += "; (expect -d -f " + testPath + " " + cluster.CockroachBinaryInContainer + ")"
		containerConfig.Cmd = append(cmdBase, cmd)

		if err := testDockerOneShot(ctx, t, "cli_test_test_disable_replication", containerConfig); err != nil {
			t.Error(err)
		}
	})
}

func TestDockerCLI_test_dump_sig(t *testing.T) {
	s := log.Scope(t)
	defer s.Close(t)

	containerConfig := defaultContainerConfig()
	containerConfig.Cmd = []string{"stat", cluster.CockroachBinaryInContainer}
	containerConfig.Env = []string{
		"CI=1", // Disables the initial color query by the termenv library.
		fmt.Sprintf("PGUSER=%s", username.RootUser),
	}
	ctx := context.Background()
	if err := testDockerOneShot(ctx, t, "cli_test_test_dump_sig", containerConfig); err != nil {
		skip.IgnoreLintf(t, "TODO(dt): No binary in one-shot container, see #6086: %s", err)
	}

	containerPath := "/go/src/github.com/cockroachdb/cockroach/cli/interactive_tests"
	if bazel.BuiltWithBazel() {
		containerPath = "/mnt/interactive_tests"
	}
	testFile := filepath.Base("../cli/interactive_tests/test_dump_sig.tcl")
	testPath := filepath.Join(containerPath, testFile)
	t.Run(testFile, func(t *testing.T) {
		log.Infof(ctx, "-- starting tests from: %s", testFile)

		// Symlink the logs directory to /logs, which is visible outside of the
		// container and preserved if the test fails. (They don't write to /logs
		// directly because they are often run manually outside of Docker, where
		// /logs is unlikely to exist.)
		cmd := "ln -s /logs logs"

		// We run the expect command using 'bash -c "(expect ...)"'.
		//
		// We cannot run "expect" directly, nor "bash -c 'expect ...'",
		// because both cause Expect to become the PID 1 process inside
		// the container. On Unix, orphan processes need to be wait()ed
		// upon by the PID 1 process when they terminate, lest they
		// remain forever in the zombie state. Unfortunately, Expect
		// does not contain code to do this. Bash does.
		cmd += "; (expect -d -f " + testPath + " " + cluster.CockroachBinaryInContainer + ")"
		containerConfig.Cmd = append(cmdBase, cmd)

		if err := testDockerOneShot(ctx, t, "cli_test_test_dump_sig", containerConfig); err != nil {
			t.Error(err)
		}
	})
}

func TestDockerCLI_test_encryption(t *testing.T) {
	s := log.Scope(t)
	defer s.Close(t)

	containerConfig := defaultContainerConfig()
	containerConfig.Cmd = []string{"stat", cluster.CockroachBinaryInContainer}
	containerConfig.Env = []string{
		"CI=1", // Disables the initial color query by the termenv library.
		fmt.Sprintf("PGUSER=%s", username.RootUser),
	}
	ctx := context.Background()
	if err := testDockerOneShot(ctx, t, "cli_test_test_encryption", containerConfig); err != nil {
		skip.IgnoreLintf(t, "TODO(dt): No binary in one-shot container, see #6086: %s", err)
	}

	containerPath := "/go/src/github.com/cockroachdb/cockroach/cli/interactive_tests"
	if bazel.BuiltWithBazel() {
		containerPath = "/mnt/interactive_tests"
	}
	testFile := filepath.Base("../cli/interactive_tests/test_encryption.tcl")
	testPath := filepath.Join(containerPath, testFile)
	t.Run(testFile, func(t *testing.T) {
		log.Infof(ctx, "-- starting tests from: %s", testFile)

		// Symlink the logs directory to /logs, which is visible outside of the
		// container and preserved if the test fails. (They don't write to /logs
		// directly because they are often run manually outside of Docker, where
		// /logs is unlikely to exist.)
		cmd := "ln -s /logs logs"

		// We run the expect command using 'bash -c "(expect ...)"'.
		//
		// We cannot run "expect" directly, nor "bash -c 'expect ...'",
		// because both cause Expect to become the PID 1 process inside
		// the container. On Unix, orphan processes need to be wait()ed
		// upon by the PID 1 process when they terminate, lest they
		// remain forever in the zombie state. Unfortunately, Expect
		// does not contain code to do this. Bash does.
		cmd += "; (expect -d -f " + testPath + " " + cluster.CockroachBinaryInContainer + ")"
		containerConfig.Cmd = append(cmdBase, cmd)

		if err := testDockerOneShot(ctx, t, "cli_test_test_encryption", containerConfig); err != nil {
			t.Error(err)
		}
	})
}

func TestDockerCLI_test_error_handling(t *testing.T) {
	s := log.Scope(t)
	defer s.Close(t)

	containerConfig := defaultContainerConfig()
	containerConfig.Cmd = []string{"stat", cluster.CockroachBinaryInContainer}
	containerConfig.Env = []string{
		"CI=1", // Disables the initial color query by the termenv library.
		fmt.Sprintf("PGUSER=%s", username.RootUser),
	}
	ctx := context.Background()
	if err := testDockerOneShot(ctx, t, "cli_test_test_error_handling", containerConfig); err != nil {
		skip.IgnoreLintf(t, "TODO(dt): No binary in one-shot container, see #6086: %s", err)
	}

	containerPath := "/go/src/github.com/cockroachdb/cockroach/cli/interactive_tests"
	if bazel.BuiltWithBazel() {
		containerPath = "/mnt/interactive_tests"
	}
	testFile := filepath.Base("../cli/interactive_tests/test_error_handling.tcl")
	testPath := filepath.Join(containerPath, testFile)
	t.Run(testFile, func(t *testing.T) {
		log.Infof(ctx, "-- starting tests from: %s", testFile)

		// Symlink the logs directory to /logs, which is visible outside of the
		// container and preserved if the test fails. (They don't write to /logs
		// directly because they are often run manually outside of Docker, where
		// /logs is unlikely to exist.)
		cmd := "ln -s /logs logs"

		// We run the expect command using 'bash -c "(expect ...)"'.
		//
		// We cannot run "expect" directly, nor "bash -c 'expect ...'",
		// because both cause Expect to become the PID 1 process inside
		// the container. On Unix, orphan processes need to be wait()ed
		// upon by the PID 1 process when they terminate, lest they
		// remain forever in the zombie state. Unfortunately, Expect
		// does not contain code to do this. Bash does.
		cmd += "; (expect -d -f " + testPath + " " + cluster.CockroachBinaryInContainer + ")"
		containerConfig.Cmd = append(cmdBase, cmd)

		if err := testDockerOneShot(ctx, t, "cli_test_test_error_handling", containerConfig); err != nil {
			t.Error(err)
		}
	})
}

func TestDockerCLI_test_error_hints(t *testing.T) {
	s := log.Scope(t)
	defer s.Close(t)

	containerConfig := defaultContainerConfig()
	containerConfig.Cmd = []string{"stat", cluster.CockroachBinaryInContainer}
	containerConfig.Env = []string{
		"CI=1", // Disables the initial color query by the termenv library.
		fmt.Sprintf("PGUSER=%s", username.RootUser),
	}
	ctx := context.Background()
	if err := testDockerOneShot(ctx, t, "cli_test_test_error_hints", containerConfig); err != nil {
		skip.IgnoreLintf(t, "TODO(dt): No binary in one-shot container, see #6086: %s", err)
	}

	containerPath := "/go/src/github.com/cockroachdb/cockroach/cli/interactive_tests"
	if bazel.BuiltWithBazel() {
		containerPath = "/mnt/interactive_tests"
	}
	testFile := filepath.Base("../cli/interactive_tests/test_error_hints.tcl")
	testPath := filepath.Join(containerPath, testFile)
	t.Run(testFile, func(t *testing.T) {
		log.Infof(ctx, "-- starting tests from: %s", testFile)

		// Symlink the logs directory to /logs, which is visible outside of the
		// container and preserved if the test fails. (They don't write to /logs
		// directly because they are often run manually outside of Docker, where
		// /logs is unlikely to exist.)
		cmd := "ln -s /logs logs"

		// We run the expect command using 'bash -c "(expect ...)"'.
		//
		// We cannot run "expect" directly, nor "bash -c 'expect ...'",
		// because both cause Expect to become the PID 1 process inside
		// the container. On Unix, orphan processes need to be wait()ed
		// upon by the PID 1 process when they terminate, lest they
		// remain forever in the zombie state. Unfortunately, Expect
		// does not contain code to do this. Bash does.
		cmd += "; (expect -d -f " + testPath + " " + cluster.CockroachBinaryInContainer + ")"
		containerConfig.Cmd = append(cmdBase, cmd)

		if err := testDockerOneShot(ctx, t, "cli_test_test_error_hints", containerConfig); err != nil {
			t.Error(err)
		}
	})
}

func TestDockerCLI_test_example_data(t *testing.T) {
	s := log.Scope(t)
	defer s.Close(t)

	containerConfig := defaultContainerConfig()
	containerConfig.Cmd = []string{"stat", cluster.CockroachBinaryInContainer}
	containerConfig.Env = []string{
		"CI=1", // Disables the initial color query by the termenv library.
		fmt.Sprintf("PGUSER=%s", username.RootUser),
	}
	ctx := context.Background()
	if err := testDockerOneShot(ctx, t, "cli_test_test_example_data", containerConfig); err != nil {
		skip.IgnoreLintf(t, "TODO(dt): No binary in one-shot container, see #6086: %s", err)
	}

	containerPath := "/go/src/github.com/cockroachdb/cockroach/cli/interactive_tests"
	if bazel.BuiltWithBazel() {
		containerPath = "/mnt/interactive_tests"
	}
	testFile := filepath.Base("../cli/interactive_tests/test_example_data.tcl")
	testPath := filepath.Join(containerPath, testFile)
	t.Run(testFile, func(t *testing.T) {
		log.Infof(ctx, "-- starting tests from: %s", testFile)

		// Symlink the logs directory to /logs, which is visible outside of the
		// container and preserved if the test fails. (They don't write to /logs
		// directly because they are often run manually outside of Docker, where
		// /logs is unlikely to exist.)
		cmd := "ln -s /logs logs"

		// We run the expect command using 'bash -c "(expect ...)"'.
		//
		// We cannot run "expect" directly, nor "bash -c 'expect ...'",
		// because both cause Expect to become the PID 1 process inside
		// the container. On Unix, orphan processes need to be wait()ed
		// upon by the PID 1 process when they terminate, lest they
		// remain forever in the zombie state. Unfortunately, Expect
		// does not contain code to do this. Bash does.
		cmd += "; (expect -d -f " + testPath + " " + cluster.CockroachBinaryInContainer + ")"
		containerConfig.Cmd = append(cmdBase, cmd)

		if err := testDockerOneShot(ctx, t, "cli_test_test_example_data", containerConfig); err != nil {
			t.Error(err)
		}
	})
}

func TestDockerCLI_test_exec_log(t *testing.T) {
	s := log.Scope(t)
	defer s.Close(t)

	containerConfig := defaultContainerConfig()
	containerConfig.Cmd = []string{"stat", cluster.CockroachBinaryInContainer}
	containerConfig.Env = []string{
		"CI=1", // Disables the initial color query by the termenv library.
		fmt.Sprintf("PGUSER=%s", username.RootUser),
	}
	ctx := context.Background()
	if err := testDockerOneShot(ctx, t, "cli_test_test_exec_log", containerConfig); err != nil {
		skip.IgnoreLintf(t, "TODO(dt): No binary in one-shot container, see #6086: %s", err)
	}

	containerPath := "/go/src/github.com/cockroachdb/cockroach/cli/interactive_tests"
	if bazel.BuiltWithBazel() {
		containerPath = "/mnt/interactive_tests"
	}
	testFile := filepath.Base("../cli/interactive_tests/test_exec_log.tcl")
	testPath := filepath.Join(containerPath, testFile)
	t.Run(testFile, func(t *testing.T) {
		log.Infof(ctx, "-- starting tests from: %s", testFile)

		// Symlink the logs directory to /logs, which is visible outside of the
		// container and preserved if the test fails. (They don't write to /logs
		// directly because they are often run manually outside of Docker, where
		// /logs is unlikely to exist.)
		cmd := "ln -s /logs logs"

		// We run the expect command using 'bash -c "(expect ...)"'.
		//
		// We cannot run "expect" directly, nor "bash -c 'expect ...'",
		// because both cause Expect to become the PID 1 process inside
		// the container. On Unix, orphan processes need to be wait()ed
		// upon by the PID 1 process when they terminate, lest they
		// remain forever in the zombie state. Unfortunately, Expect
		// does not contain code to do this. Bash does.
		cmd += "; (expect -d -f " + testPath + " " + cluster.CockroachBinaryInContainer + ")"
		containerConfig.Cmd = append(cmdBase, cmd)

		if err := testDockerOneShot(ctx, t, "cli_test_test_exec_log", containerConfig); err != nil {
			t.Error(err)
		}
	})
}

func TestDockerCLI_test_explain_analyze(t *testing.T) {
	s := log.Scope(t)
	defer s.Close(t)

	containerConfig := defaultContainerConfig()
	containerConfig.Cmd = []string{"stat", cluster.CockroachBinaryInContainer}
	containerConfig.Env = []string{
		"CI=1", // Disables the initial color query by the termenv library.
		fmt.Sprintf("PGUSER=%s", username.RootUser),
	}
	ctx := context.Background()
	if err := testDockerOneShot(ctx, t, "cli_test_test_explain_analyze", containerConfig); err != nil {
		skip.IgnoreLintf(t, "TODO(dt): No binary in one-shot container, see #6086: %s", err)
	}

	containerPath := "/go/src/github.com/cockroachdb/cockroach/cli/interactive_tests"
	if bazel.BuiltWithBazel() {
		containerPath = "/mnt/interactive_tests"
	}
	testFile := filepath.Base("../cli/interactive_tests/test_explain_analyze.tcl")
	testPath := filepath.Join(containerPath, testFile)
	t.Run(testFile, func(t *testing.T) {
		log.Infof(ctx, "-- starting tests from: %s", testFile)

		// Symlink the logs directory to /logs, which is visible outside of the
		// container and preserved if the test fails. (They don't write to /logs
		// directly because they are often run manually outside of Docker, where
		// /logs is unlikely to exist.)
		cmd := "ln -s /logs logs"

		// We run the expect command using 'bash -c "(expect ...)"'.
		//
		// We cannot run "expect" directly, nor "bash -c 'expect ...'",
		// because both cause Expect to become the PID 1 process inside
		// the container. On Unix, orphan processes need to be wait()ed
		// upon by the PID 1 process when they terminate, lest they
		// remain forever in the zombie state. Unfortunately, Expect
		// does not contain code to do this. Bash does.
		cmd += "; (expect -d -f " + testPath + " " + cluster.CockroachBinaryInContainer + ")"
		containerConfig.Cmd = append(cmdBase, cmd)

		if err := testDockerOneShot(ctx, t, "cli_test_test_explain_analyze", containerConfig); err != nil {
			t.Error(err)
		}
	})
}

func TestDockerCLI_test_explain_analyze_debug(t *testing.T) {
	s := log.Scope(t)
	defer s.Close(t)

	containerConfig := defaultContainerConfig()
	containerConfig.Cmd = []string{"stat", cluster.CockroachBinaryInContainer}
	containerConfig.Env = []string{
		"CI=1", // Disables the initial color query by the termenv library.
		fmt.Sprintf("PGUSER=%s", username.RootUser),
	}
	ctx := context.Background()
	if err := testDockerOneShot(ctx, t, "cli_test_test_explain_analyze_debug", containerConfig); err != nil {
		skip.IgnoreLintf(t, "TODO(dt): No binary in one-shot container, see #6086: %s", err)
	}

	containerPath := "/go/src/github.com/cockroachdb/cockroach/cli/interactive_tests"
	if bazel.BuiltWithBazel() {
		containerPath = "/mnt/interactive_tests"
	}
	testFile := filepath.Base("../cli/interactive_tests/test_explain_analyze_debug.tcl")
	testPath := filepath.Join(containerPath, testFile)
	t.Run(testFile, func(t *testing.T) {
		log.Infof(ctx, "-- starting tests from: %s", testFile)

		// Symlink the logs directory to /logs, which is visible outside of the
		// container and preserved if the test fails. (They don't write to /logs
		// directly because they are often run manually outside of Docker, where
		// /logs is unlikely to exist.)
		cmd := "ln -s /logs logs"

		// We run the expect command using 'bash -c "(expect ...)"'.
		//
		// We cannot run "expect" directly, nor "bash -c 'expect ...'",
		// because both cause Expect to become the PID 1 process inside
		// the container. On Unix, orphan processes need to be wait()ed
		// upon by the PID 1 process when they terminate, lest they
		// remain forever in the zombie state. Unfortunately, Expect
		// does not contain code to do this. Bash does.
		cmd += "; (expect -d -f " + testPath + " " + cluster.CockroachBinaryInContainer + ")"
		containerConfig.Cmd = append(cmdBase, cmd)

		if err := testDockerOneShot(ctx, t, "cli_test_test_explain_analyze_debug", containerConfig); err != nil {
			t.Error(err)
		}
	})
}

func TestDockerCLI_test_extern_dir(t *testing.T) {
	s := log.Scope(t)
	defer s.Close(t)

	containerConfig := defaultContainerConfig()
	containerConfig.Cmd = []string{"stat", cluster.CockroachBinaryInContainer}
	containerConfig.Env = []string{
		"CI=1", // Disables the initial color query by the termenv library.
		fmt.Sprintf("PGUSER=%s", username.RootUser),
	}
	ctx := context.Background()
	if err := testDockerOneShot(ctx, t, "cli_test_test_extern_dir", containerConfig); err != nil {
		skip.IgnoreLintf(t, "TODO(dt): No binary in one-shot container, see #6086: %s", err)
	}

	containerPath := "/go/src/github.com/cockroachdb/cockroach/cli/interactive_tests"
	if bazel.BuiltWithBazel() {
		containerPath = "/mnt/interactive_tests"
	}
	testFile := filepath.Base("../cli/interactive_tests/test_extern_dir.tcl")
	testPath := filepath.Join(containerPath, testFile)
	t.Run(testFile, func(t *testing.T) {
		log.Infof(ctx, "-- starting tests from: %s", testFile)

		// Symlink the logs directory to /logs, which is visible outside of the
		// container and preserved if the test fails. (They don't write to /logs
		// directly because they are often run manually outside of Docker, where
		// /logs is unlikely to exist.)
		cmd := "ln -s /logs logs"

		// We run the expect command using 'bash -c "(expect ...)"'.
		//
		// We cannot run "expect" directly, nor "bash -c 'expect ...'",
		// because both cause Expect to become the PID 1 process inside
		// the container. On Unix, orphan processes need to be wait()ed
		// upon by the PID 1 process when they terminate, lest they
		// remain forever in the zombie state. Unfortunately, Expect
		// does not contain code to do this. Bash does.
		cmd += "; (expect -d -f " + testPath + " " + cluster.CockroachBinaryInContainer + ")"
		containerConfig.Cmd = append(cmdBase, cmd)

		if err := testDockerOneShot(ctx, t, "cli_test_test_extern_dir", containerConfig); err != nil {
			t.Error(err)
		}
	})
}

func TestDockerCLI_test_flags(t *testing.T) {
	s := log.Scope(t)
	defer s.Close(t)

	containerConfig := defaultContainerConfig()
	containerConfig.Cmd = []string{"stat", cluster.CockroachBinaryInContainer}
	containerConfig.Env = []string{
		"CI=1", // Disables the initial color query by the termenv library.
		fmt.Sprintf("PGUSER=%s", username.RootUser),
	}
	ctx := context.Background()
	if err := testDockerOneShot(ctx, t, "cli_test_test_flags", containerConfig); err != nil {
		skip.IgnoreLintf(t, "TODO(dt): No binary in one-shot container, see #6086: %s", err)
	}

	containerPath := "/go/src/github.com/cockroachdb/cockroach/cli/interactive_tests"
	if bazel.BuiltWithBazel() {
		containerPath = "/mnt/interactive_tests"
	}
	testFile := filepath.Base("../cli/interactive_tests/test_flags.tcl")
	testPath := filepath.Join(containerPath, testFile)
	t.Run(testFile, func(t *testing.T) {
		log.Infof(ctx, "-- starting tests from: %s", testFile)

		// Symlink the logs directory to /logs, which is visible outside of the
		// container and preserved if the test fails. (They don't write to /logs
		// directly because they are often run manually outside of Docker, where
		// /logs is unlikely to exist.)
		cmd := "ln -s /logs logs"

		// We run the expect command using 'bash -c "(expect ...)"'.
		//
		// We cannot run "expect" directly, nor "bash -c 'expect ...'",
		// because both cause Expect to become the PID 1 process inside
		// the container. On Unix, orphan processes need to be wait()ed
		// upon by the PID 1 process when they terminate, lest they
		// remain forever in the zombie state. Unfortunately, Expect
		// does not contain code to do this. Bash does.
		cmd += "; (expect -d -f " + testPath + " " + cluster.CockroachBinaryInContainer + ")"
		containerConfig.Cmd = append(cmdBase, cmd)

		if err := testDockerOneShot(ctx, t, "cli_test_test_flags", containerConfig); err != nil {
			t.Error(err)
		}
	})
}

func TestDockerCLI_test_high_verbosity(t *testing.T) {
	s := log.Scope(t)
	defer s.Close(t)

	containerConfig := defaultContainerConfig()
	containerConfig.Cmd = []string{"stat", cluster.CockroachBinaryInContainer}
	containerConfig.Env = []string{
		"CI=1", // Disables the initial color query by the termenv library.
		fmt.Sprintf("PGUSER=%s", username.RootUser),
	}
	ctx := context.Background()
	if err := testDockerOneShot(ctx, t, "cli_test_test_high_verbosity", containerConfig); err != nil {
		skip.IgnoreLintf(t, "TODO(dt): No binary in one-shot container, see #6086: %s", err)
	}

	containerPath := "/go/src/github.com/cockroachdb/cockroach/cli/interactive_tests"
	if bazel.BuiltWithBazel() {
		containerPath = "/mnt/interactive_tests"
	}
	testFile := filepath.Base("../cli/interactive_tests/test_high_verbosity.tcl")
	testPath := filepath.Join(containerPath, testFile)
	t.Run(testFile, func(t *testing.T) {
		log.Infof(ctx, "-- starting tests from: %s", testFile)

		// Symlink the logs directory to /logs, which is visible outside of the
		// container and preserved if the test fails. (They don't write to /logs
		// directly because they are often run manually outside of Docker, where
		// /logs is unlikely to exist.)
		cmd := "ln -s /logs logs"

		// We run the expect command using 'bash -c "(expect ...)"'.
		//
		// We cannot run "expect" directly, nor "bash -c 'expect ...'",
		// because both cause Expect to become the PID 1 process inside
		// the container. On Unix, orphan processes need to be wait()ed
		// upon by the PID 1 process when they terminate, lest they
		// remain forever in the zombie state. Unfortunately, Expect
		// does not contain code to do this. Bash does.
		cmd += "; (expect -d -f " + testPath + " " + cluster.CockroachBinaryInContainer + ")"
		containerConfig.Cmd = append(cmdBase, cmd)

		if err := testDockerOneShot(ctx, t, "cli_test_test_high_verbosity", containerConfig); err != nil {
			t.Error(err)
		}
	})
}

func TestDockerCLI_test_history(t *testing.T) {
	s := log.Scope(t)
	defer s.Close(t)

	containerConfig := defaultContainerConfig()
	containerConfig.Cmd = []string{"stat", cluster.CockroachBinaryInContainer}
	containerConfig.Env = []string{
		"CI=1", // Disables the initial color query by the termenv library.
		fmt.Sprintf("PGUSER=%s", username.RootUser),
	}
	ctx := context.Background()
	if err := testDockerOneShot(ctx, t, "cli_test_test_history", containerConfig); err != nil {
		skip.IgnoreLintf(t, "TODO(dt): No binary in one-shot container, see #6086: %s", err)
	}

	containerPath := "/go/src/github.com/cockroachdb/cockroach/cli/interactive_tests"
	if bazel.BuiltWithBazel() {
		containerPath = "/mnt/interactive_tests"
	}
	testFile := filepath.Base("../cli/interactive_tests/test_history.tcl")
	testPath := filepath.Join(containerPath, testFile)
	t.Run(testFile, func(t *testing.T) {
		log.Infof(ctx, "-- starting tests from: %s", testFile)

		// Symlink the logs directory to /logs, which is visible outside of the
		// container and preserved if the test fails. (They don't write to /logs
		// directly because they are often run manually outside of Docker, where
		// /logs is unlikely to exist.)
		cmd := "ln -s /logs logs"

		// We run the expect command using 'bash -c "(expect ...)"'.
		//
		// We cannot run "expect" directly, nor "bash -c 'expect ...'",
		// because both cause Expect to become the PID 1 process inside
		// the container. On Unix, orphan processes need to be wait()ed
		// upon by the PID 1 process when they terminate, lest they
		// remain forever in the zombie state. Unfortunately, Expect
		// does not contain code to do this. Bash does.
		cmd += "; (expect -d -f " + testPath + " " + cluster.CockroachBinaryInContainer + ")"
		containerConfig.Cmd = append(cmdBase, cmd)

		if err := testDockerOneShot(ctx, t, "cli_test_test_history", containerConfig); err != nil {
			t.Error(err)
		}
	})
}

func TestDockerCLI_test_init_command(t *testing.T) {
	s := log.Scope(t)
	defer s.Close(t)

	containerConfig := defaultContainerConfig()
	containerConfig.Cmd = []string{"stat", cluster.CockroachBinaryInContainer}
	containerConfig.Env = []string{
		"CI=1", // Disables the initial color query by the termenv library.
		fmt.Sprintf("PGUSER=%s", username.RootUser),
	}
	ctx := context.Background()
	if err := testDockerOneShot(ctx, t, "cli_test_test_init_command", containerConfig); err != nil {
		skip.IgnoreLintf(t, "TODO(dt): No binary in one-shot container, see #6086: %s", err)
	}

	containerPath := "/go/src/github.com/cockroachdb/cockroach/cli/interactive_tests"
	if bazel.BuiltWithBazel() {
		containerPath = "/mnt/interactive_tests"
	}
	testFile := filepath.Base("../cli/interactive_tests/test_init_command.tcl")
	testPath := filepath.Join(containerPath, testFile)
	t.Run(testFile, func(t *testing.T) {
		log.Infof(ctx, "-- starting tests from: %s", testFile)

		// Symlink the logs directory to /logs, which is visible outside of the
		// container and preserved if the test fails. (They don't write to /logs
		// directly because they are often run manually outside of Docker, where
		// /logs is unlikely to exist.)
		cmd := "ln -s /logs logs"

		// We run the expect command using 'bash -c "(expect ...)"'.
		//
		// We cannot run "expect" directly, nor "bash -c 'expect ...'",
		// because both cause Expect to become the PID 1 process inside
		// the container. On Unix, orphan processes need to be wait()ed
		// upon by the PID 1 process when they terminate, lest they
		// remain forever in the zombie state. Unfortunately, Expect
		// does not contain code to do this. Bash does.
		cmd += "; (expect -d -f " + testPath + " " + cluster.CockroachBinaryInContainer + ")"
		containerConfig.Cmd = append(cmdBase, cmd)

		if err := testDockerOneShot(ctx, t, "cli_test_test_init_command", containerConfig); err != nil {
			t.Error(err)
		}
	})
}

func TestDockerCLI_test_interrupt(t *testing.T) {
	s := log.Scope(t)
	defer s.Close(t)

	containerConfig := defaultContainerConfig()
	containerConfig.Cmd = []string{"stat", cluster.CockroachBinaryInContainer}
	containerConfig.Env = []string{
		"CI=1", // Disables the initial color query by the termenv library.
		fmt.Sprintf("PGUSER=%s", username.RootUser),
	}
	ctx := context.Background()
	if err := testDockerOneShot(ctx, t, "cli_test_test_interrupt", containerConfig); err != nil {
		skip.IgnoreLintf(t, "TODO(dt): No binary in one-shot container, see #6086: %s", err)
	}

	containerPath := "/go/src/github.com/cockroachdb/cockroach/cli/interactive_tests"
	if bazel.BuiltWithBazel() {
		containerPath = "/mnt/interactive_tests"
	}
	testFile := filepath.Base("../cli/interactive_tests/test_interrupt.tcl")
	testPath := filepath.Join(containerPath, testFile)
	t.Run(testFile, func(t *testing.T) {
		log.Infof(ctx, "-- starting tests from: %s", testFile)

		// Symlink the logs directory to /logs, which is visible outside of the
		// container and preserved if the test fails. (They don't write to /logs
		// directly because they are often run manually outside of Docker, where
		// /logs is unlikely to exist.)
		cmd := "ln -s /logs logs"

		// We run the expect command using 'bash -c "(expect ...)"'.
		//
		// We cannot run "expect" directly, nor "bash -c 'expect ...'",
		// because both cause Expect to become the PID 1 process inside
		// the container. On Unix, orphan processes need to be wait()ed
		// upon by the PID 1 process when they terminate, lest they
		// remain forever in the zombie state. Unfortunately, Expect
		// does not contain code to do this. Bash does.
		cmd += "; (expect -d -f " + testPath + " " + cluster.CockroachBinaryInContainer + ")"
		containerConfig.Cmd = append(cmdBase, cmd)

		if err := testDockerOneShot(ctx, t, "cli_test_test_interrupt", containerConfig); err != nil {
			t.Error(err)
		}
	})
}

func TestDockerCLI_test_last_statement(t *testing.T) {
	s := log.Scope(t)
	defer s.Close(t)

	containerConfig := defaultContainerConfig()
	containerConfig.Cmd = []string{"stat", cluster.CockroachBinaryInContainer}
	containerConfig.Env = []string{
		"CI=1", // Disables the initial color query by the termenv library.
		fmt.Sprintf("PGUSER=%s", username.RootUser),
	}
	ctx := context.Background()
	if err := testDockerOneShot(ctx, t, "cli_test_test_last_statement", containerConfig); err != nil {
		skip.IgnoreLintf(t, "TODO(dt): No binary in one-shot container, see #6086: %s", err)
	}

	containerPath := "/go/src/github.com/cockroachdb/cockroach/cli/interactive_tests"
	if bazel.BuiltWithBazel() {
		containerPath = "/mnt/interactive_tests"
	}
	testFile := filepath.Base("../cli/interactive_tests/test_last_statement.tcl")
	testPath := filepath.Join(containerPath, testFile)
	t.Run(testFile, func(t *testing.T) {
		log.Infof(ctx, "-- starting tests from: %s", testFile)

		// Symlink the logs directory to /logs, which is visible outside of the
		// container and preserved if the test fails. (They don't write to /logs
		// directly because they are often run manually outside of Docker, where
		// /logs is unlikely to exist.)
		cmd := "ln -s /logs logs"

		// We run the expect command using 'bash -c "(expect ...)"'.
		//
		// We cannot run "expect" directly, nor "bash -c 'expect ...'",
		// because both cause Expect to become the PID 1 process inside
		// the container. On Unix, orphan processes need to be wait()ed
		// upon by the PID 1 process when they terminate, lest they
		// remain forever in the zombie state. Unfortunately, Expect
		// does not contain code to do this. Bash does.
		cmd += "; (expect -d -f " + testPath + " " + cluster.CockroachBinaryInContainer + ")"
		containerConfig.Cmd = append(cmdBase, cmd)

		if err := testDockerOneShot(ctx, t, "cli_test_test_last_statement", containerConfig); err != nil {
			t.Error(err)
		}
	})
}

func TestDockerCLI_test_local_cmds(t *testing.T) {
	s := log.Scope(t)
	defer s.Close(t)

	containerConfig := defaultContainerConfig()
	containerConfig.Cmd = []string{"stat", cluster.CockroachBinaryInContainer}
	containerConfig.Env = []string{
		"CI=1", // Disables the initial color query by the termenv library.
		fmt.Sprintf("PGUSER=%s", username.RootUser),
	}
	ctx := context.Background()
	if err := testDockerOneShot(ctx, t, "cli_test_test_local_cmds", containerConfig); err != nil {
		skip.IgnoreLintf(t, "TODO(dt): No binary in one-shot container, see #6086: %s", err)
	}

	containerPath := "/go/src/github.com/cockroachdb/cockroach/cli/interactive_tests"
	if bazel.BuiltWithBazel() {
		containerPath = "/mnt/interactive_tests"
	}
	testFile := filepath.Base("../cli/interactive_tests/test_local_cmds.tcl")
	testPath := filepath.Join(containerPath, testFile)
	t.Run(testFile, func(t *testing.T) {
		log.Infof(ctx, "-- starting tests from: %s", testFile)

		// Symlink the logs directory to /logs, which is visible outside of the
		// container and preserved if the test fails. (They don't write to /logs
		// directly because they are often run manually outside of Docker, where
		// /logs is unlikely to exist.)
		cmd := "ln -s /logs logs"

		// We run the expect command using 'bash -c "(expect ...)"'.
		//
		// We cannot run "expect" directly, nor "bash -c 'expect ...'",
		// because both cause Expect to become the PID 1 process inside
		// the container. On Unix, orphan processes need to be wait()ed
		// upon by the PID 1 process when they terminate, lest they
		// remain forever in the zombie state. Unfortunately, Expect
		// does not contain code to do this. Bash does.
		cmd += "; (expect -d -f " + testPath + " " + cluster.CockroachBinaryInContainer + ")"
		containerConfig.Cmd = append(cmdBase, cmd)

		if err := testDockerOneShot(ctx, t, "cli_test_test_local_cmds", containerConfig); err != nil {
			t.Error(err)
		}
	})
}

func TestDockerCLI_test_log_config_msg(t *testing.T) {
	s := log.Scope(t)
	defer s.Close(t)

	containerConfig := defaultContainerConfig()
	containerConfig.Cmd = []string{"stat", cluster.CockroachBinaryInContainer}
	containerConfig.Env = []string{
		"CI=1", // Disables the initial color query by the termenv library.
		fmt.Sprintf("PGUSER=%s", username.RootUser),
	}
	ctx := context.Background()
	if err := testDockerOneShot(ctx, t, "cli_test_test_log_config_msg", containerConfig); err != nil {
		skip.IgnoreLintf(t, "TODO(dt): No binary in one-shot container, see #6086: %s", err)
	}

	containerPath := "/go/src/github.com/cockroachdb/cockroach/cli/interactive_tests"
	if bazel.BuiltWithBazel() {
		containerPath = "/mnt/interactive_tests"
	}
	testFile := filepath.Base("../cli/interactive_tests/test_log_config_msg.tcl")
	testPath := filepath.Join(containerPath, testFile)
	t.Run(testFile, func(t *testing.T) {
		log.Infof(ctx, "-- starting tests from: %s", testFile)

		// Symlink the logs directory to /logs, which is visible outside of the
		// container and preserved if the test fails. (They don't write to /logs
		// directly because they are often run manually outside of Docker, where
		// /logs is unlikely to exist.)
		cmd := "ln -s /logs logs"

		// We run the expect command using 'bash -c "(expect ...)"'.
		//
		// We cannot run "expect" directly, nor "bash -c 'expect ...'",
		// because both cause Expect to become the PID 1 process inside
		// the container. On Unix, orphan processes need to be wait()ed
		// upon by the PID 1 process when they terminate, lest they
		// remain forever in the zombie state. Unfortunately, Expect
		// does not contain code to do this. Bash does.
		cmd += "; (expect -d -f " + testPath + " " + cluster.CockroachBinaryInContainer + ")"
		containerConfig.Cmd = append(cmdBase, cmd)

		if err := testDockerOneShot(ctx, t, "cli_test_test_log_config_msg", containerConfig); err != nil {
			t.Error(err)
		}
	})
}

func TestDockerCLI_test_log_flags(t *testing.T) {
	s := log.Scope(t)
	defer s.Close(t)

	containerConfig := defaultContainerConfig()
	containerConfig.Cmd = []string{"stat", cluster.CockroachBinaryInContainer}
	containerConfig.Env = []string{
		"CI=1", // Disables the initial color query by the termenv library.
		fmt.Sprintf("PGUSER=%s", username.RootUser),
	}
	ctx := context.Background()
	if err := testDockerOneShot(ctx, t, "cli_test_test_log_flags", containerConfig); err != nil {
		skip.IgnoreLintf(t, "TODO(dt): No binary in one-shot container, see #6086: %s", err)
	}

	containerPath := "/go/src/github.com/cockroachdb/cockroach/cli/interactive_tests"
	if bazel.BuiltWithBazel() {
		containerPath = "/mnt/interactive_tests"
	}
	testFile := filepath.Base("../cli/interactive_tests/test_log_flags.tcl")
	testPath := filepath.Join(containerPath, testFile)
	t.Run(testFile, func(t *testing.T) {
		log.Infof(ctx, "-- starting tests from: %s", testFile)

		// Symlink the logs directory to /logs, which is visible outside of the
		// container and preserved if the test fails. (They don't write to /logs
		// directly because they are often run manually outside of Docker, where
		// /logs is unlikely to exist.)
		cmd := "ln -s /logs logs"

		// We run the expect command using 'bash -c "(expect ...)"'.
		//
		// We cannot run "expect" directly, nor "bash -c 'expect ...'",
		// because both cause Expect to become the PID 1 process inside
		// the container. On Unix, orphan processes need to be wait()ed
		// upon by the PID 1 process when they terminate, lest they
		// remain forever in the zombie state. Unfortunately, Expect
		// does not contain code to do this. Bash does.
		cmd += "; (expect -d -f " + testPath + " " + cluster.CockroachBinaryInContainer + ")"
		containerConfig.Cmd = append(cmdBase, cmd)

		if err := testDockerOneShot(ctx, t, "cli_test_test_log_flags", containerConfig); err != nil {
			t.Error(err)
		}
	})
}

func TestDockerCLI_test_multiline_statements_libedit(t *testing.T) {
	s := log.Scope(t)
	defer s.Close(t)

	containerConfig := defaultContainerConfig()
	containerConfig.Cmd = []string{"stat", cluster.CockroachBinaryInContainer}
	containerConfig.Env = []string{
		"CI=1", // Disables the initial color query by the termenv library.
		fmt.Sprintf("PGUSER=%s", username.RootUser),
	}
	ctx := context.Background()
	if err := testDockerOneShot(ctx, t, "cli_test_test_multiline_statements_libedit", containerConfig); err != nil {
		skip.IgnoreLintf(t, "TODO(dt): No binary in one-shot container, see #6086: %s", err)
	}

	containerPath := "/go/src/github.com/cockroachdb/cockroach/cli/interactive_tests"
	if bazel.BuiltWithBazel() {
		containerPath = "/mnt/interactive_tests"
	}
	testFile := filepath.Base("../cli/interactive_tests/test_multiline_statements_libedit.tcl")
	testPath := filepath.Join(containerPath, testFile)
	t.Run(testFile, func(t *testing.T) {
		log.Infof(ctx, "-- starting tests from: %s", testFile)

		// Symlink the logs directory to /logs, which is visible outside of the
		// container and preserved if the test fails. (They don't write to /logs
		// directly because they are often run manually outside of Docker, where
		// /logs is unlikely to exist.)
		cmd := "ln -s /logs logs"

		// We run the expect command using 'bash -c "(expect ...)"'.
		//
		// We cannot run "expect" directly, nor "bash -c 'expect ...'",
		// because both cause Expect to become the PID 1 process inside
		// the container. On Unix, orphan processes need to be wait()ed
		// upon by the PID 1 process when they terminate, lest they
		// remain forever in the zombie state. Unfortunately, Expect
		// does not contain code to do this. Bash does.
		cmd += "; (expect -d -f " + testPath + " " + cluster.CockroachBinaryInContainer + ")"
		containerConfig.Cmd = append(cmdBase, cmd)

		if err := testDockerOneShot(ctx, t, "cli_test_test_multiline_statements_libedit", containerConfig); err != nil {
			t.Error(err)
		}
	})
}

func TestDockerCLI_test_multiple_nodes(t *testing.T) {
	s := log.Scope(t)
	defer s.Close(t)

	containerConfig := defaultContainerConfig()
	containerConfig.Cmd = []string{"stat", cluster.CockroachBinaryInContainer}
	containerConfig.Env = []string{
		"CI=1", // Disables the initial color query by the termenv library.
		fmt.Sprintf("PGUSER=%s", username.RootUser),
	}
	ctx := context.Background()
	if err := testDockerOneShot(ctx, t, "cli_test_test_multiple_nodes", containerConfig); err != nil {
		skip.IgnoreLintf(t, "TODO(dt): No binary in one-shot container, see #6086: %s", err)
	}

	containerPath := "/go/src/github.com/cockroachdb/cockroach/cli/interactive_tests"
	if bazel.BuiltWithBazel() {
		containerPath = "/mnt/interactive_tests"
	}
	testFile := filepath.Base("../cli/interactive_tests/test_multiple_nodes.tcl")
	testPath := filepath.Join(containerPath, testFile)
	t.Run(testFile, func(t *testing.T) {
		log.Infof(ctx, "-- starting tests from: %s", testFile)

		// Symlink the logs directory to /logs, which is visible outside of the
		// container and preserved if the test fails. (They don't write to /logs
		// directly because they are often run manually outside of Docker, where
		// /logs is unlikely to exist.)
		cmd := "ln -s /logs logs"

		// We run the expect command using 'bash -c "(expect ...)"'.
		//
		// We cannot run "expect" directly, nor "bash -c 'expect ...'",
		// because both cause Expect to become the PID 1 process inside
		// the container. On Unix, orphan processes need to be wait()ed
		// upon by the PID 1 process when they terminate, lest they
		// remain forever in the zombie state. Unfortunately, Expect
		// does not contain code to do this. Bash does.
		cmd += "; (expect -d -f " + testPath + " " + cluster.CockroachBinaryInContainer + ")"
		containerConfig.Cmd = append(cmdBase, cmd)

		if err := testDockerOneShot(ctx, t, "cli_test_test_multiple_nodes", containerConfig); err != nil {
			t.Error(err)
		}
	})
}

func TestDockerCLI_test_notice(t *testing.T) {
	s := log.Scope(t)
	defer s.Close(t)

	containerConfig := defaultContainerConfig()
	containerConfig.Cmd = []string{"stat", cluster.CockroachBinaryInContainer}
	containerConfig.Env = []string{
		"CI=1", // Disables the initial color query by the termenv library.
		fmt.Sprintf("PGUSER=%s", username.RootUser),
	}
	ctx := context.Background()
	if err := testDockerOneShot(ctx, t, "cli_test_test_notice", containerConfig); err != nil {
		skip.IgnoreLintf(t, "TODO(dt): No binary in one-shot container, see #6086: %s", err)
	}

	containerPath := "/go/src/github.com/cockroachdb/cockroach/cli/interactive_tests"
	if bazel.BuiltWithBazel() {
		containerPath = "/mnt/interactive_tests"
	}
	testFile := filepath.Base("../cli/interactive_tests/test_notice.tcl")
	testPath := filepath.Join(containerPath, testFile)
	t.Run(testFile, func(t *testing.T) {
		log.Infof(ctx, "-- starting tests from: %s", testFile)

		// Symlink the logs directory to /logs, which is visible outside of the
		// container and preserved if the test fails. (They don't write to /logs
		// directly because they are often run manually outside of Docker, where
		// /logs is unlikely to exist.)
		cmd := "ln -s /logs logs"

		// We run the expect command using 'bash -c "(expect ...)"'.
		//
		// We cannot run "expect" directly, nor "bash -c 'expect ...'",
		// because both cause Expect to become the PID 1 process inside
		// the container. On Unix, orphan processes need to be wait()ed
		// upon by the PID 1 process when they terminate, lest they
		// remain forever in the zombie state. Unfortunately, Expect
		// does not contain code to do this. Bash does.
		cmd += "; (expect -d -f " + testPath + " " + cluster.CockroachBinaryInContainer + ")"
		containerConfig.Cmd = append(cmdBase, cmd)

		if err := testDockerOneShot(ctx, t, "cli_test_test_notice", containerConfig); err != nil {
			t.Error(err)
		}
	})
}

func TestDockerCLI_test_password(t *testing.T) {
	s := log.Scope(t)
	defer s.Close(t)

	containerConfig := defaultContainerConfig()
	containerConfig.Cmd = []string{"stat", cluster.CockroachBinaryInContainer}
	containerConfig.Env = []string{
		"CI=1", // Disables the initial color query by the termenv library.
		fmt.Sprintf("PGUSER=%s", username.RootUser),
	}
	ctx := context.Background()
	if err := testDockerOneShot(ctx, t, "cli_test_test_password", containerConfig); err != nil {
		skip.IgnoreLintf(t, "TODO(dt): No binary in one-shot container, see #6086: %s", err)
	}

	containerPath := "/go/src/github.com/cockroachdb/cockroach/cli/interactive_tests"
	if bazel.BuiltWithBazel() {
		containerPath = "/mnt/interactive_tests"
	}
	testFile := filepath.Base("../cli/interactive_tests/test_password.tcl")
	testPath := filepath.Join(containerPath, testFile)
	t.Run(testFile, func(t *testing.T) {
		log.Infof(ctx, "-- starting tests from: %s", testFile)

		// Symlink the logs directory to /logs, which is visible outside of the
		// container and preserved if the test fails. (They don't write to /logs
		// directly because they are often run manually outside of Docker, where
		// /logs is unlikely to exist.)
		cmd := "ln -s /logs logs"

		// We run the expect command using 'bash -c "(expect ...)"'.
		//
		// We cannot run "expect" directly, nor "bash -c 'expect ...'",
		// because both cause Expect to become the PID 1 process inside
		// the container. On Unix, orphan processes need to be wait()ed
		// upon by the PID 1 process when they terminate, lest they
		// remain forever in the zombie state. Unfortunately, Expect
		// does not contain code to do this. Bash does.
		cmd += "; (expect -d -f " + testPath + " " + cluster.CockroachBinaryInContainer + ")"
		containerConfig.Cmd = append(cmdBase, cmd)

		if err := testDockerOneShot(ctx, t, "cli_test_test_password", containerConfig); err != nil {
			t.Error(err)
		}
	})
}

func TestDockerCLI_test_read_only(t *testing.T) {
	s := log.Scope(t)
	defer s.Close(t)

	containerConfig := defaultContainerConfig()
	containerConfig.Cmd = []string{"stat", cluster.CockroachBinaryInContainer}
	containerConfig.Env = []string{
		"CI=1", // Disables the initial color query by the termenv library.
		fmt.Sprintf("PGUSER=%s", username.RootUser),
	}
	ctx := context.Background()
	if err := testDockerOneShot(ctx, t, "cli_test_test_read_only", containerConfig); err != nil {
		skip.IgnoreLintf(t, "TODO(dt): No binary in one-shot container, see #6086: %s", err)
	}

	containerPath := "/go/src/github.com/cockroachdb/cockroach/cli/interactive_tests"
	if bazel.BuiltWithBazel() {
		containerPath = "/mnt/interactive_tests"
	}
	testFile := filepath.Base("../cli/interactive_tests/test_read_only.tcl")
	testPath := filepath.Join(containerPath, testFile)
	t.Run(testFile, func(t *testing.T) {
		log.Infof(ctx, "-- starting tests from: %s", testFile)

		// Symlink the logs directory to /logs, which is visible outside of the
		// container and preserved if the test fails. (They don't write to /logs
		// directly because they are often run manually outside of Docker, where
		// /logs is unlikely to exist.)
		cmd := "ln -s /logs logs"

		// We run the expect command using 'bash -c "(expect ...)"'.
		//
		// We cannot run "expect" directly, nor "bash -c 'expect ...'",
		// because both cause Expect to become the PID 1 process inside
		// the container. On Unix, orphan processes need to be wait()ed
		// upon by the PID 1 process when they terminate, lest they
		// remain forever in the zombie state. Unfortunately, Expect
		// does not contain code to do this. Bash does.
		cmd += "; (expect -d -f " + testPath + " " + cluster.CockroachBinaryInContainer + ")"
		containerConfig.Cmd = append(cmdBase, cmd)

		if err := testDockerOneShot(ctx, t, "cli_test_test_read_only", containerConfig); err != nil {
			t.Error(err)
		}
	})
}

func TestDockerCLI_test_reconnect(t *testing.T) {
	s := log.Scope(t)
	defer s.Close(t)

	containerConfig := defaultContainerConfig()
	containerConfig.Cmd = []string{"stat", cluster.CockroachBinaryInContainer}
	containerConfig.Env = []string{
		"CI=1", // Disables the initial color query by the termenv library.
		fmt.Sprintf("PGUSER=%s", username.RootUser),
	}
	ctx := context.Background()
	if err := testDockerOneShot(ctx, t, "cli_test_test_reconnect", containerConfig); err != nil {
		skip.IgnoreLintf(t, "TODO(dt): No binary in one-shot container, see #6086: %s", err)
	}

	containerPath := "/go/src/github.com/cockroachdb/cockroach/cli/interactive_tests"
	if bazel.BuiltWithBazel() {
		containerPath = "/mnt/interactive_tests"
	}
	testFile := filepath.Base("../cli/interactive_tests/test_reconnect.tcl")
	testPath := filepath.Join(containerPath, testFile)
	t.Run(testFile, func(t *testing.T) {
		log.Infof(ctx, "-- starting tests from: %s", testFile)

		// Symlink the logs directory to /logs, which is visible outside of the
		// container and preserved if the test fails. (They don't write to /logs
		// directly because they are often run manually outside of Docker, where
		// /logs is unlikely to exist.)
		cmd := "ln -s /logs logs"

		// We run the expect command using 'bash -c "(expect ...)"'.
		//
		// We cannot run "expect" directly, nor "bash -c 'expect ...'",
		// because both cause Expect to become the PID 1 process inside
		// the container. On Unix, orphan processes need to be wait()ed
		// upon by the PID 1 process when they terminate, lest they
		// remain forever in the zombie state. Unfortunately, Expect
		// does not contain code to do this. Bash does.
		cmd += "; (expect -d -f " + testPath + " " + cluster.CockroachBinaryInContainer + ")"
		containerConfig.Cmd = append(cmdBase, cmd)

		if err := testDockerOneShot(ctx, t, "cli_test_test_reconnect", containerConfig); err != nil {
			t.Error(err)
		}
	})
}

func TestDockerCLI_test_secure(t *testing.T) {
	s := log.Scope(t)
	defer s.Close(t)

	containerConfig := defaultContainerConfig()
	containerConfig.Cmd = []string{"stat", cluster.CockroachBinaryInContainer}
	containerConfig.Env = []string{
		"CI=1", // Disables the initial color query by the termenv library.
		fmt.Sprintf("PGUSER=%s", username.RootUser),
	}
	ctx := context.Background()
	if err := testDockerOneShot(ctx, t, "cli_test_test_secure", containerConfig); err != nil {
		skip.IgnoreLintf(t, "TODO(dt): No binary in one-shot container, see #6086: %s", err)
	}

	containerPath := "/go/src/github.com/cockroachdb/cockroach/cli/interactive_tests"
	if bazel.BuiltWithBazel() {
		containerPath = "/mnt/interactive_tests"
	}
	testFile := filepath.Base("../cli/interactive_tests/test_secure.tcl")
	testPath := filepath.Join(containerPath, testFile)
	t.Run(testFile, func(t *testing.T) {
		log.Infof(ctx, "-- starting tests from: %s", testFile)

		// Symlink the logs directory to /logs, which is visible outside of the
		// container and preserved if the test fails. (They don't write to /logs
		// directly because they are often run manually outside of Docker, where
		// /logs is unlikely to exist.)
		cmd := "ln -s /logs logs"

		// We run the expect command using 'bash -c "(expect ...)"'.
		//
		// We cannot run "expect" directly, nor "bash -c 'expect ...'",
		// because both cause Expect to become the PID 1 process inside
		// the container. On Unix, orphan processes need to be wait()ed
		// upon by the PID 1 process when they terminate, lest they
		// remain forever in the zombie state. Unfortunately, Expect
		// does not contain code to do this. Bash does.
		cmd += "; (expect -d -f " + testPath + " " + cluster.CockroachBinaryInContainer + ")"
		containerConfig.Cmd = append(cmdBase, cmd)

		if err := testDockerOneShot(ctx, t, "cli_test_test_secure", containerConfig); err != nil {
			t.Error(err)
		}
	})
}

func TestDockerCLI_test_secure_ocsp(t *testing.T) {
	s := log.Scope(t)
	defer s.Close(t)

	containerConfig := defaultContainerConfig()
	containerConfig.Cmd = []string{"stat", cluster.CockroachBinaryInContainer}
	containerConfig.Env = []string{
		"CI=1", // Disables the initial color query by the termenv library.
		fmt.Sprintf("PGUSER=%s", username.RootUser),
	}
	ctx := context.Background()
	if err := testDockerOneShot(ctx, t, "cli_test_test_secure_ocsp", containerConfig); err != nil {
		skip.IgnoreLintf(t, "TODO(dt): No binary in one-shot container, see #6086: %s", err)
	}

	containerPath := "/go/src/github.com/cockroachdb/cockroach/cli/interactive_tests"
	if bazel.BuiltWithBazel() {
		containerPath = "/mnt/interactive_tests"
	}
	testFile := filepath.Base("../cli/interactive_tests/test_secure_ocsp.tcl")
	testPath := filepath.Join(containerPath, testFile)
	t.Run(testFile, func(t *testing.T) {
		log.Infof(ctx, "-- starting tests from: %s", testFile)

		// Symlink the logs directory to /logs, which is visible outside of the
		// container and preserved if the test fails. (They don't write to /logs
		// directly because they are often run manually outside of Docker, where
		// /logs is unlikely to exist.)
		cmd := "ln -s /logs logs"

		// We run the expect command using 'bash -c "(expect ...)"'.
		//
		// We cannot run "expect" directly, nor "bash -c 'expect ...'",
		// because both cause Expect to become the PID 1 process inside
		// the container. On Unix, orphan processes need to be wait()ed
		// upon by the PID 1 process when they terminate, lest they
		// remain forever in the zombie state. Unfortunately, Expect
		// does not contain code to do this. Bash does.
		cmd += "; (expect -d -f " + testPath + " " + cluster.CockroachBinaryInContainer + ")"
		containerConfig.Cmd = append(cmdBase, cmd)

		if err := testDockerOneShot(ctx, t, "cli_test_test_secure_ocsp", containerConfig); err != nil {
			t.Error(err)
		}
	})
}

func TestDockerCLI_test_server_restart(t *testing.T) {
	s := log.Scope(t)
	defer s.Close(t)

	containerConfig := defaultContainerConfig()
	containerConfig.Cmd = []string{"stat", cluster.CockroachBinaryInContainer}
	containerConfig.Env = []string{
		"CI=1", // Disables the initial color query by the termenv library.
		fmt.Sprintf("PGUSER=%s", username.RootUser),
	}
	ctx := context.Background()
	if err := testDockerOneShot(ctx, t, "cli_test_test_server_restart", containerConfig); err != nil {
		skip.IgnoreLintf(t, "TODO(dt): No binary in one-shot container, see #6086: %s", err)
	}

	containerPath := "/go/src/github.com/cockroachdb/cockroach/cli/interactive_tests"
	if bazel.BuiltWithBazel() {
		containerPath = "/mnt/interactive_tests"
	}
	testFile := filepath.Base("../cli/interactive_tests/test_server_restart.tcl")
	testPath := filepath.Join(containerPath, testFile)
	t.Run(testFile, func(t *testing.T) {
		log.Infof(ctx, "-- starting tests from: %s", testFile)

		// Symlink the logs directory to /logs, which is visible outside of the
		// container and preserved if the test fails. (They don't write to /logs
		// directly because they are often run manually outside of Docker, where
		// /logs is unlikely to exist.)
		cmd := "ln -s /logs logs"

		// We run the expect command using 'bash -c "(expect ...)"'.
		//
		// We cannot run "expect" directly, nor "bash -c 'expect ...'",
		// because both cause Expect to become the PID 1 process inside
		// the container. On Unix, orphan processes need to be wait()ed
		// upon by the PID 1 process when they terminate, lest they
		// remain forever in the zombie state. Unfortunately, Expect
		// does not contain code to do this. Bash does.
		cmd += "; (expect -d -f " + testPath + " " + cluster.CockroachBinaryInContainer + ")"
		containerConfig.Cmd = append(cmdBase, cmd)

		if err := testDockerOneShot(ctx, t, "cli_test_test_server_restart", containerConfig); err != nil {
			t.Error(err)
		}
	})
}

func TestDockerCLI_test_socket_name(t *testing.T) {
	s := log.Scope(t)
	defer s.Close(t)

	containerConfig := defaultContainerConfig()
	containerConfig.Cmd = []string{"stat", cluster.CockroachBinaryInContainer}
	containerConfig.Env = []string{
		"CI=1", // Disables the initial color query by the termenv library.
		fmt.Sprintf("PGUSER=%s", username.RootUser),
	}
	ctx := context.Background()
	if err := testDockerOneShot(ctx, t, "cli_test_test_socket_name", containerConfig); err != nil {
		skip.IgnoreLintf(t, "TODO(dt): No binary in one-shot container, see #6086: %s", err)
	}

	containerPath := "/go/src/github.com/cockroachdb/cockroach/cli/interactive_tests"
	if bazel.BuiltWithBazel() {
		containerPath = "/mnt/interactive_tests"
	}
	testFile := filepath.Base("../cli/interactive_tests/test_socket_name.tcl")
	testPath := filepath.Join(containerPath, testFile)
	t.Run(testFile, func(t *testing.T) {
		log.Infof(ctx, "-- starting tests from: %s", testFile)

		// Symlink the logs directory to /logs, which is visible outside of the
		// container and preserved if the test fails. (They don't write to /logs
		// directly because they are often run manually outside of Docker, where
		// /logs is unlikely to exist.)
		cmd := "ln -s /logs logs"

		// We run the expect command using 'bash -c "(expect ...)"'.
		//
		// We cannot run "expect" directly, nor "bash -c 'expect ...'",
		// because both cause Expect to become the PID 1 process inside
		// the container. On Unix, orphan processes need to be wait()ed
		// upon by the PID 1 process when they terminate, lest they
		// remain forever in the zombie state. Unfortunately, Expect
		// does not contain code to do this. Bash does.
		cmd += "; (expect -d -f " + testPath + " " + cluster.CockroachBinaryInContainer + ")"
		containerConfig.Cmd = append(cmdBase, cmd)

		if err := testDockerOneShot(ctx, t, "cli_test_test_socket_name", containerConfig); err != nil {
			t.Error(err)
		}
	})
}

func TestDockerCLI_test_sql_demo_node_cmds(t *testing.T) {
	s := log.Scope(t)
	defer s.Close(t)

	containerConfig := defaultContainerConfig()
	containerConfig.Cmd = []string{"stat", cluster.CockroachBinaryInContainer}
	containerConfig.Env = []string{
		"CI=1", // Disables the initial color query by the termenv library.
		fmt.Sprintf("PGUSER=%s", username.RootUser),
	}
	ctx := context.Background()
	if err := testDockerOneShot(ctx, t, "cli_test_test_sql_demo_node_cmds", containerConfig); err != nil {
		skip.IgnoreLintf(t, "TODO(dt): No binary in one-shot container, see #6086: %s", err)
	}

	containerPath := "/go/src/github.com/cockroachdb/cockroach/cli/interactive_tests"
	if bazel.BuiltWithBazel() {
		containerPath = "/mnt/interactive_tests"
	}
	testFile := filepath.Base("../cli/interactive_tests/test_sql_demo_node_cmds.tcl")
	testPath := filepath.Join(containerPath, testFile)
	t.Run(testFile, func(t *testing.T) {
		log.Infof(ctx, "-- starting tests from: %s", testFile)

		// Symlink the logs directory to /logs, which is visible outside of the
		// container and preserved if the test fails. (They don't write to /logs
		// directly because they are often run manually outside of Docker, where
		// /logs is unlikely to exist.)
		cmd := "ln -s /logs logs"

		// We run the expect command using 'bash -c "(expect ...)"'.
		//
		// We cannot run "expect" directly, nor "bash -c 'expect ...'",
		// because both cause Expect to become the PID 1 process inside
		// the container. On Unix, orphan processes need to be wait()ed
		// upon by the PID 1 process when they terminate, lest they
		// remain forever in the zombie state. Unfortunately, Expect
		// does not contain code to do this. Bash does.
		cmd += "; (expect -d -f " + testPath + " " + cluster.CockroachBinaryInContainer + ")"
		containerConfig.Cmd = append(cmdBase, cmd)

		if err := testDockerOneShot(ctx, t, "cli_test_test_sql_demo_node_cmds", containerConfig); err != nil {
			t.Error(err)
		}
	})
}

func TestDockerCLI_test_sql_safe_updates(t *testing.T) {
	s := log.Scope(t)
	defer s.Close(t)

	containerConfig := defaultContainerConfig()
	containerConfig.Cmd = []string{"stat", cluster.CockroachBinaryInContainer}
	containerConfig.Env = []string{
		"CI=1", // Disables the initial color query by the termenv library.
		fmt.Sprintf("PGUSER=%s", username.RootUser),
	}
	ctx := context.Background()
	if err := testDockerOneShot(ctx, t, "cli_test_test_sql_safe_updates", containerConfig); err != nil {
		skip.IgnoreLintf(t, "TODO(dt): No binary in one-shot container, see #6086: %s", err)
	}

	containerPath := "/go/src/github.com/cockroachdb/cockroach/cli/interactive_tests"
	if bazel.BuiltWithBazel() {
		containerPath = "/mnt/interactive_tests"
	}
	testFile := filepath.Base("../cli/interactive_tests/test_sql_safe_updates.tcl")
	testPath := filepath.Join(containerPath, testFile)
	t.Run(testFile, func(t *testing.T) {
		log.Infof(ctx, "-- starting tests from: %s", testFile)

		// Symlink the logs directory to /logs, which is visible outside of the
		// container and preserved if the test fails. (They don't write to /logs
		// directly because they are often run manually outside of Docker, where
		// /logs is unlikely to exist.)
		cmd := "ln -s /logs logs"

		// We run the expect command using 'bash -c "(expect ...)"'.
		//
		// We cannot run "expect" directly, nor "bash -c 'expect ...'",
		// because both cause Expect to become the PID 1 process inside
		// the container. On Unix, orphan processes need to be wait()ed
		// upon by the PID 1 process when they terminate, lest they
		// remain forever in the zombie state. Unfortunately, Expect
		// does not contain code to do this. Bash does.
		cmd += "; (expect -d -f " + testPath + " " + cluster.CockroachBinaryInContainer + ")"
		containerConfig.Cmd = append(cmdBase, cmd)

		if err := testDockerOneShot(ctx, t, "cli_test_test_sql_safe_updates", containerConfig); err != nil {
			t.Error(err)
		}
	})
}

func TestDockerCLI_test_sql_version_reporting(t *testing.T) {
	s := log.Scope(t)
	defer s.Close(t)

	containerConfig := defaultContainerConfig()
	containerConfig.Cmd = []string{"stat", cluster.CockroachBinaryInContainer}
	containerConfig.Env = []string{
		"CI=1", // Disables the initial color query by the termenv library.
		fmt.Sprintf("PGUSER=%s", username.RootUser),
	}
	ctx := context.Background()
	if err := testDockerOneShot(ctx, t, "cli_test_test_sql_version_reporting", containerConfig); err != nil {
		skip.IgnoreLintf(t, "TODO(dt): No binary in one-shot container, see #6086: %s", err)
	}

	containerPath := "/go/src/github.com/cockroachdb/cockroach/cli/interactive_tests"
	if bazel.BuiltWithBazel() {
		containerPath = "/mnt/interactive_tests"
	}
	testFile := filepath.Base("../cli/interactive_tests/test_sql_version_reporting.tcl")
	testPath := filepath.Join(containerPath, testFile)
	t.Run(testFile, func(t *testing.T) {
		log.Infof(ctx, "-- starting tests from: %s", testFile)

		// Symlink the logs directory to /logs, which is visible outside of the
		// container and preserved if the test fails. (They don't write to /logs
		// directly because they are often run manually outside of Docker, where
		// /logs is unlikely to exist.)
		cmd := "ln -s /logs logs"

		// We run the expect command using 'bash -c "(expect ...)"'.
		//
		// We cannot run "expect" directly, nor "bash -c 'expect ...'",
		// because both cause Expect to become the PID 1 process inside
		// the container. On Unix, orphan processes need to be wait()ed
		// upon by the PID 1 process when they terminate, lest they
		// remain forever in the zombie state. Unfortunately, Expect
		// does not contain code to do this. Bash does.
		cmd += "; (expect -d -f " + testPath + " " + cluster.CockroachBinaryInContainer + ")"
		containerConfig.Cmd = append(cmdBase, cmd)

		if err := testDockerOneShot(ctx, t, "cli_test_test_sql_version_reporting", containerConfig); err != nil {
			t.Error(err)
		}
	})
}

func TestDockerCLI_test_style_enabled(t *testing.T) {
	s := log.Scope(t)
	defer s.Close(t)

	containerConfig := defaultContainerConfig()
	containerConfig.Cmd = []string{"stat", cluster.CockroachBinaryInContainer}
	containerConfig.Env = []string{
		"CI=1", // Disables the initial color query by the termenv library.
		fmt.Sprintf("PGUSER=%s", username.RootUser),
	}
	ctx := context.Background()
	if err := testDockerOneShot(ctx, t, "cli_test_test_style_enabled", containerConfig); err != nil {
		skip.IgnoreLintf(t, "TODO(dt): No binary in one-shot container, see #6086: %s", err)
	}

	containerPath := "/go/src/github.com/cockroachdb/cockroach/cli/interactive_tests"
	if bazel.BuiltWithBazel() {
		containerPath = "/mnt/interactive_tests"
	}
	testFile := filepath.Base("../cli/interactive_tests/test_style_enabled.tcl")
	testPath := filepath.Join(containerPath, testFile)
	t.Run(testFile, func(t *testing.T) {
		log.Infof(ctx, "-- starting tests from: %s", testFile)

		// Symlink the logs directory to /logs, which is visible outside of the
		// container and preserved if the test fails. (They don't write to /logs
		// directly because they are often run manually outside of Docker, where
		// /logs is unlikely to exist.)
		cmd := "ln -s /logs logs"

		// We run the expect command using 'bash -c "(expect ...)"'.
		//
		// We cannot run "expect" directly, nor "bash -c 'expect ...'",
		// because both cause Expect to become the PID 1 process inside
		// the container. On Unix, orphan processes need to be wait()ed
		// upon by the PID 1 process when they terminate, lest they
		// remain forever in the zombie state. Unfortunately, Expect
		// does not contain code to do this. Bash does.
		cmd += "; (expect -d -f " + testPath + " " + cluster.CockroachBinaryInContainer + ")"
		containerConfig.Cmd = append(cmdBase, cmd)

		if err := testDockerOneShot(ctx, t, "cli_test_test_style_enabled", containerConfig); err != nil {
			t.Error(err)
		}
	})
}

func TestDockerCLI_test_temp_dir(t *testing.T) {
	s := log.Scope(t)
	defer s.Close(t)

	containerConfig := defaultContainerConfig()
	containerConfig.Cmd = []string{"stat", cluster.CockroachBinaryInContainer}
	containerConfig.Env = []string{
		"CI=1", // Disables the initial color query by the termenv library.
		fmt.Sprintf("PGUSER=%s", username.RootUser),
	}
	ctx := context.Background()
	if err := testDockerOneShot(ctx, t, "cli_test_test_temp_dir", containerConfig); err != nil {
		skip.IgnoreLintf(t, "TODO(dt): No binary in one-shot container, see #6086: %s", err)
	}

	containerPath := "/go/src/github.com/cockroachdb/cockroach/cli/interactive_tests"
	if bazel.BuiltWithBazel() {
		containerPath = "/mnt/interactive_tests"
	}
	testFile := filepath.Base("../cli/interactive_tests/test_temp_dir.tcl")
	testPath := filepath.Join(containerPath, testFile)
	t.Run(testFile, func(t *testing.T) {
		log.Infof(ctx, "-- starting tests from: %s", testFile)

		// Symlink the logs directory to /logs, which is visible outside of the
		// container and preserved if the test fails. (They don't write to /logs
		// directly because they are often run manually outside of Docker, where
		// /logs is unlikely to exist.)
		cmd := "ln -s /logs logs"

		// We run the expect command using 'bash -c "(expect ...)"'.
		//
		// We cannot run "expect" directly, nor "bash -c 'expect ...'",
		// because both cause Expect to become the PID 1 process inside
		// the container. On Unix, orphan processes need to be wait()ed
		// upon by the PID 1 process when they terminate, lest they
		// remain forever in the zombie state. Unfortunately, Expect
		// does not contain code to do this. Bash does.
		cmd += "; (expect -d -f " + testPath + " " + cluster.CockroachBinaryInContainer + ")"
		containerConfig.Cmd = append(cmdBase, cmd)

		if err := testDockerOneShot(ctx, t, "cli_test_test_temp_dir", containerConfig); err != nil {
			t.Error(err)
		}
	})
}

func TestDockerCLI_test_timing(t *testing.T) {
	s := log.Scope(t)
	defer s.Close(t)

	containerConfig := defaultContainerConfig()
	containerConfig.Cmd = []string{"stat", cluster.CockroachBinaryInContainer}
	containerConfig.Env = []string{
		"CI=1", // Disables the initial color query by the termenv library.
		fmt.Sprintf("PGUSER=%s", username.RootUser),
	}
	ctx := context.Background()
	if err := testDockerOneShot(ctx, t, "cli_test_test_timing", containerConfig); err != nil {
		skip.IgnoreLintf(t, "TODO(dt): No binary in one-shot container, see #6086: %s", err)
	}

	containerPath := "/go/src/github.com/cockroachdb/cockroach/cli/interactive_tests"
	if bazel.BuiltWithBazel() {
		containerPath = "/mnt/interactive_tests"
	}
	testFile := filepath.Base("../cli/interactive_tests/test_timing.tcl")
	testPath := filepath.Join(containerPath, testFile)
	t.Run(testFile, func(t *testing.T) {
		log.Infof(ctx, "-- starting tests from: %s", testFile)

		// Symlink the logs directory to /logs, which is visible outside of the
		// container and preserved if the test fails. (They don't write to /logs
		// directly because they are often run manually outside of Docker, where
		// /logs is unlikely to exist.)
		cmd := "ln -s /logs logs"

		// We run the expect command using 'bash -c "(expect ...)"'.
		//
		// We cannot run "expect" directly, nor "bash -c 'expect ...'",
		// because both cause Expect to become the PID 1 process inside
		// the container. On Unix, orphan processes need to be wait()ed
		// upon by the PID 1 process when they terminate, lest they
		// remain forever in the zombie state. Unfortunately, Expect
		// does not contain code to do this. Bash does.
		cmd += "; (expect -d -f " + testPath + " " + cluster.CockroachBinaryInContainer + ")"
		containerConfig.Cmd = append(cmdBase, cmd)

		if err := testDockerOneShot(ctx, t, "cli_test_test_timing", containerConfig); err != nil {
			t.Error(err)
		}
	})
}

func TestDockerCLI_test_txn_prompt(t *testing.T) {
	s := log.Scope(t)
	defer s.Close(t)

	containerConfig := defaultContainerConfig()
	containerConfig.Cmd = []string{"stat", cluster.CockroachBinaryInContainer}
	containerConfig.Env = []string{
		"CI=1", // Disables the initial color query by the termenv library.
		fmt.Sprintf("PGUSER=%s", username.RootUser),
	}
	ctx := context.Background()
	if err := testDockerOneShot(ctx, t, "cli_test_test_txn_prompt", containerConfig); err != nil {
		skip.IgnoreLintf(t, "TODO(dt): No binary in one-shot container, see #6086: %s", err)
	}

	containerPath := "/go/src/github.com/cockroachdb/cockroach/cli/interactive_tests"
	if bazel.BuiltWithBazel() {
		containerPath = "/mnt/interactive_tests"
	}
	testFile := filepath.Base("../cli/interactive_tests/test_txn_prompt.tcl")
	testPath := filepath.Join(containerPath, testFile)
	t.Run(testFile, func(t *testing.T) {
		log.Infof(ctx, "-- starting tests from: %s", testFile)

		// Symlink the logs directory to /logs, which is visible outside of the
		// container and preserved if the test fails. (They don't write to /logs
		// directly because they are often run manually outside of Docker, where
		// /logs is unlikely to exist.)
		cmd := "ln -s /logs logs"

		// We run the expect command using 'bash -c "(expect ...)"'.
		//
		// We cannot run "expect" directly, nor "bash -c 'expect ...'",
		// because both cause Expect to become the PID 1 process inside
		// the container. On Unix, orphan processes need to be wait()ed
		// upon by the PID 1 process when they terminate, lest they
		// remain forever in the zombie state. Unfortunately, Expect
		// does not contain code to do this. Bash does.
		cmd += "; (expect -d -f " + testPath + " " + cluster.CockroachBinaryInContainer + ")"
		containerConfig.Cmd = append(cmdBase, cmd)

		if err := testDockerOneShot(ctx, t, "cli_test_test_txn_prompt", containerConfig); err != nil {
			t.Error(err)
		}
	})
}

func TestDockerCLI_test_url_db_override(t *testing.T) {
	s := log.Scope(t)
	defer s.Close(t)

	containerConfig := defaultContainerConfig()
	containerConfig.Cmd = []string{"stat", cluster.CockroachBinaryInContainer}
	containerConfig.Env = []string{
		"CI=1", // Disables the initial color query by the termenv library.
		fmt.Sprintf("PGUSER=%s", username.RootUser),
	}
	ctx := context.Background()
	if err := testDockerOneShot(ctx, t, "cli_test_test_url_db_override", containerConfig); err != nil {
		skip.IgnoreLintf(t, "TODO(dt): No binary in one-shot container, see #6086: %s", err)
	}

	containerPath := "/go/src/github.com/cockroachdb/cockroach/cli/interactive_tests"
	if bazel.BuiltWithBazel() {
		containerPath = "/mnt/interactive_tests"
	}
	testFile := filepath.Base("../cli/interactive_tests/test_url_db_override.tcl")
	testPath := filepath.Join(containerPath, testFile)
	t.Run(testFile, func(t *testing.T) {
		log.Infof(ctx, "-- starting tests from: %s", testFile)

		// Symlink the logs directory to /logs, which is visible outside of the
		// container and preserved if the test fails. (They don't write to /logs
		// directly because they are often run manually outside of Docker, where
		// /logs is unlikely to exist.)
		cmd := "ln -s /logs logs"

		// We run the expect command using 'bash -c "(expect ...)"'.
		//
		// We cannot run "expect" directly, nor "bash -c 'expect ...'",
		// because both cause Expect to become the PID 1 process inside
		// the container. On Unix, orphan processes need to be wait()ed
		// upon by the PID 1 process when they terminate, lest they
		// remain forever in the zombie state. Unfortunately, Expect
		// does not contain code to do this. Bash does.
		cmd += "; (expect -d -f " + testPath + " " + cluster.CockroachBinaryInContainer + ")"
		containerConfig.Cmd = append(cmdBase, cmd)

		if err := testDockerOneShot(ctx, t, "cli_test_test_url_db_override", containerConfig); err != nil {
			t.Error(err)
		}
	})
}

func TestDockerCLI_test_url_login(t *testing.T) {
	s := log.Scope(t)
	defer s.Close(t)

	containerConfig := defaultContainerConfig()
	containerConfig.Cmd = []string{"stat", cluster.CockroachBinaryInContainer}
	containerConfig.Env = []string{
		"CI=1", // Disables the initial color query by the termenv library.
		fmt.Sprintf("PGUSER=%s", username.RootUser),
	}
	ctx := context.Background()
	if err := testDockerOneShot(ctx, t, "cli_test_test_url_login", containerConfig); err != nil {
		skip.IgnoreLintf(t, "TODO(dt): No binary in one-shot container, see #6086: %s", err)
	}

	containerPath := "/go/src/github.com/cockroachdb/cockroach/cli/interactive_tests"
	if bazel.BuiltWithBazel() {
		containerPath = "/mnt/interactive_tests"
	}
	testFile := filepath.Base("../cli/interactive_tests/test_url_login.tcl")
	testPath := filepath.Join(containerPath, testFile)
	t.Run(testFile, func(t *testing.T) {
		log.Infof(ctx, "-- starting tests from: %s", testFile)

		// Symlink the logs directory to /logs, which is visible outside of the
		// container and preserved if the test fails. (They don't write to /logs
		// directly because they are often run manually outside of Docker, where
		// /logs is unlikely to exist.)
		cmd := "ln -s /logs logs"

		// We run the expect command using 'bash -c "(expect ...)"'.
		//
		// We cannot run "expect" directly, nor "bash -c 'expect ...'",
		// because both cause Expect to become the PID 1 process inside
		// the container. On Unix, orphan processes need to be wait()ed
		// upon by the PID 1 process when they terminate, lest they
		// remain forever in the zombie state. Unfortunately, Expect
		// does not contain code to do this. Bash does.
		cmd += "; (expect -d -f " + testPath + " " + cluster.CockroachBinaryInContainer + ")"
		containerConfig.Cmd = append(cmdBase, cmd)

		if err := testDockerOneShot(ctx, t, "cli_test_test_url_login", containerConfig); err != nil {
			t.Error(err)
		}
	})
}

func TestDockerCLI_test_workload(t *testing.T) {
	s := log.Scope(t)
	defer s.Close(t)

	containerConfig := defaultContainerConfig()
	containerConfig.Cmd = []string{"stat", cluster.CockroachBinaryInContainer}
	containerConfig.Env = []string{
		"CI=1", // Disables the initial color query by the termenv library.
		fmt.Sprintf("PGUSER=%s", username.RootUser),
	}
	ctx := context.Background()
	if err := testDockerOneShot(ctx, t, "cli_test_test_workload", containerConfig); err != nil {
		skip.IgnoreLintf(t, "TODO(dt): No binary in one-shot container, see #6086: %s", err)
	}

	containerPath := "/go/src/github.com/cockroachdb/cockroach/cli/interactive_tests"
	if bazel.BuiltWithBazel() {
		containerPath = "/mnt/interactive_tests"
	}
	testFile := filepath.Base("../cli/interactive_tests/test_workload.tcl")
	testPath := filepath.Join(containerPath, testFile)
	t.Run(testFile, func(t *testing.T) {
		log.Infof(ctx, "-- starting tests from: %s", testFile)

		// Symlink the logs directory to /logs, which is visible outside of the
		// container and preserved if the test fails. (They don't write to /logs
		// directly because they are often run manually outside of Docker, where
		// /logs is unlikely to exist.)
		cmd := "ln -s /logs logs"

		// We run the expect command using 'bash -c "(expect ...)"'.
		//
		// We cannot run "expect" directly, nor "bash -c 'expect ...'",
		// because both cause Expect to become the PID 1 process inside
		// the container. On Unix, orphan processes need to be wait()ed
		// upon by the PID 1 process when they terminate, lest they
		// remain forever in the zombie state. Unfortunately, Expect
		// does not contain code to do this. Bash does.
		cmd += "; (expect -d -f " + testPath + " " + cluster.CockroachBinaryInContainer + ")"
		containerConfig.Cmd = append(cmdBase, cmd)

		if err := testDockerOneShot(ctx, t, "cli_test_test_workload", containerConfig); err != nil {
			t.Error(err)
		}
	})
}

func TestDockerCLI_test_zero_directory(t *testing.T) {
	s := log.Scope(t)
	defer s.Close(t)

	containerConfig := defaultContainerConfig()
	containerConfig.Cmd = []string{"stat", cluster.CockroachBinaryInContainer}
	containerConfig.Env = []string{
		"CI=1", // Disables the initial color query by the termenv library.
		fmt.Sprintf("PGUSER=%s", username.RootUser),
	}
	ctx := context.Background()
	if err := testDockerOneShot(ctx, t, "cli_test_test_zero_directory", containerConfig); err != nil {
		skip.IgnoreLintf(t, "TODO(dt): No binary in one-shot container, see #6086: %s", err)
	}

	containerPath := "/go/src/github.com/cockroachdb/cockroach/cli/interactive_tests"
	if bazel.BuiltWithBazel() {
		containerPath = "/mnt/interactive_tests"
	}
	testFile := filepath.Base("../cli/interactive_tests/test_zero_directory.tcl")
	testPath := filepath.Join(containerPath, testFile)
	t.Run(testFile, func(t *testing.T) {
		log.Infof(ctx, "-- starting tests from: %s", testFile)

		// Symlink the logs directory to /logs, which is visible outside of the
		// container and preserved if the test fails. (They don't write to /logs
		// directly because they are often run manually outside of Docker, where
		// /logs is unlikely to exist.)
		cmd := "ln -s /logs logs"

		// We run the expect command using 'bash -c "(expect ...)"'.
		//
		// We cannot run "expect" directly, nor "bash -c 'expect ...'",
		// because both cause Expect to become the PID 1 process inside
		// the container. On Unix, orphan processes need to be wait()ed
		// upon by the PID 1 process when they terminate, lest they
		// remain forever in the zombie state. Unfortunately, Expect
		// does not contain code to do this. Bash does.
		cmd += "; (expect -d -f " + testPath + " " + cluster.CockroachBinaryInContainer + ")"
		containerConfig.Cmd = append(cmdBase, cmd)

		if err := testDockerOneShot(ctx, t, "cli_test_test_zero_directory", containerConfig); err != nil {
			t.Error(err)
		}
	})
}

func TestDockerCLI_test_zip_filter(t *testing.T) {
	s := log.Scope(t)
	defer s.Close(t)

	containerConfig := defaultContainerConfig()
	containerConfig.Cmd = []string{"stat", cluster.CockroachBinaryInContainer}
	containerConfig.Env = []string{
		"CI=1", // Disables the initial color query by the termenv library.
		fmt.Sprintf("PGUSER=%s", username.RootUser),
	}
	ctx := context.Background()
	if err := testDockerOneShot(ctx, t, "cli_test_test_zip_filter", containerConfig); err != nil {
		skip.IgnoreLintf(t, "TODO(dt): No binary in one-shot container, see #6086: %s", err)
	}

	containerPath := "/go/src/github.com/cockroachdb/cockroach/cli/interactive_tests"
	if bazel.BuiltWithBazel() {
		containerPath = "/mnt/interactive_tests"
	}
	testFile := filepath.Base("../cli/interactive_tests/test_zip_filter.tcl")
	testPath := filepath.Join(containerPath, testFile)
	t.Run(testFile, func(t *testing.T) {
		log.Infof(ctx, "-- starting tests from: %s", testFile)

		// Symlink the logs directory to /logs, which is visible outside of the
		// container and preserved if the test fails. (They don't write to /logs
		// directly because they are often run manually outside of Docker, where
		// /logs is unlikely to exist.)
		cmd := "ln -s /logs logs"

		// We run the expect command using 'bash -c "(expect ...)"'.
		//
		// We cannot run "expect" directly, nor "bash -c 'expect ...'",
		// because both cause Expect to become the PID 1 process inside
		// the container. On Unix, orphan processes need to be wait()ed
		// upon by the PID 1 process when they terminate, lest they
		// remain forever in the zombie state. Unfortunately, Expect
		// does not contain code to do this. Bash does.
		cmd += "; (expect -d -f " + testPath + " " + cluster.CockroachBinaryInContainer + ")"
		containerConfig.Cmd = append(cmdBase, cmd)

		if err := testDockerOneShot(ctx, t, "cli_test_test_zip_filter", containerConfig); err != nil {
			t.Error(err)
		}
	})
}

// TestDockerUnixSocket verifies that CockroachDB initializes a unix
// socket useable by 'psql', even when the server runs insecurely.
// TODO(knz): Replace this with a roachtest when roachtest/roachprod
// know how to start secure clusters.
func TestDockerUnixSocket(t *testing.T) {
	s := log.Scope(t)
	defer s.Close(t)

	containerConfig := defaultContainerConfig()
	containerConfig.Cmd = []string{"stat", cluster.CockroachBinaryInContainer}
	ctx := context.Background()

	if err := testDockerOneShot(ctx, t, "cli_test", containerConfig); err != nil {
		skip.IgnoreLintf(t, "TODO(dt): No binary in one-shot container, see #6086: %s", err)
	}

	containerConfig.Env = []string{fmt.Sprintf("PGUSER=%s", username.RootUser)}
	containerConfig.Cmd = append(cmdBase,
		"/mnt/data/psql/test-psql-unix.sh "+cluster.CockroachBinaryInContainer)
	if err := testDockerOneShot(ctx, t, "unix_socket_test", containerConfig); err != nil {
		t.Error(err)
	}
}

// TestSQLWithoutTLS verifies that CockroachDB can accept clients
// without a TLS handshake in secure mode.
// TODO(knz): Replace this with a roachtest when roachtest/roachprod
// know how to start secure clusters.
func TestSQLWithoutTLS(t *testing.T) {
	s := log.Scope(t)
	defer s.Close(t)

	containerConfig := defaultContainerConfig()
	containerConfig.Cmd = []string{"stat", cluster.CockroachBinaryInContainer}
	ctx := context.Background()

	if err := testDockerOneShot(ctx, t, "cli_test", containerConfig); err != nil {
		skip.IgnoreLintf(t, "TODO(dt): No binary in one-shot container, see #6086: %s", err)
	}

	containerConfig.Env = []string{fmt.Sprintf("PGUSER=%s", username.RootUser)}
	containerConfig.Cmd = append(cmdBase,
		"/mnt/data/psql/test-psql-notls.sh "+cluster.CockroachBinaryInContainer)
	if err := testDockerOneShot(ctx, t, "notls_secure_test", containerConfig); err != nil {
		t.Error(err)
	}
}
