// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: storage/storagebase/proposer_kv.proto

/*
	Package storagebase is a generated protocol buffer package.

	It is generated from these files:
		storage/storagebase/proposer_kv.proto
		storage/storagebase/state.proto

	It has these top-level messages:
		Split
		Merge
		ChangeReplicas
		SuggestedCompaction
		ReplicatedEvalResult
		WriteBatch
		RaftCommand
		ReplicaState
		RangeInfo
		CommandQueuesSnapshot
*/
package storagebase

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import cockroach_roachpb3 "github.com/cockroachdb/cockroach/pkg/roachpb"
import cockroach_roachpb1 "github.com/cockroachdb/cockroach/pkg/roachpb"
import cockroach_roachpb "github.com/cockroachdb/cockroach/pkg/roachpb"
import cockroach_storage_engine_enginepb1 "github.com/cockroachdb/cockroach/pkg/storage/engine/enginepb"
import cockroach_storage_engine_enginepb2 "github.com/cockroachdb/cockroach/pkg/storage/engine/enginepb"
import cockroach_storage_engine_enginepb "github.com/cockroachdb/cockroach/pkg/storage/engine/enginepb"
import cockroach_util_hlc "github.com/cockroachdb/cockroach/pkg/util/hlc"

import github_com_cockroachdb_cockroach_pkg_roachpb "github.com/cockroachdb/cockroach/pkg/roachpb"

import bytes "bytes"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

// Split is emitted when a Replica commits a split trigger. It signals that the
// Replica has prepared the on-disk state for both the left and right hand
// sides of the split, and that the left hand side Replica should be updated as
// well as the right hand side created.
type Split struct {
	cockroach_roachpb1.SplitTrigger `protobuf:"bytes,1,opt,name=trigger,embedded=trigger" json:"trigger"`
	// RHSDelta holds the statistics for what was written to what is now the
	// right-hand side of the split during the batch which executed it.
	// The on-disk state of the right-hand side is already correct, but the
	// Store must learn about this delta to update its counters appropriately.
	RHSDelta cockroach_storage_engine_enginepb2.MVCCStats `protobuf:"bytes,2,opt,name=rhs_delta,json=rhsDelta" json:"rhs_delta"`
}

func (m *Split) Reset()                    { *m = Split{} }
func (m *Split) String() string            { return proto.CompactTextString(m) }
func (*Split) ProtoMessage()               {}
func (*Split) Descriptor() ([]byte, []int) { return fileDescriptorProposerKv, []int{0} }

// Merge is emitted by a Replica which commits a transaction with
// a MergeTrigger (i.e. absorbs its right neighbor).
type Merge struct {
	cockroach_roachpb1.MergeTrigger `protobuf:"bytes,1,opt,name=trigger,embedded=trigger" json:"trigger"`
}

func (m *Merge) Reset()                    { *m = Merge{} }
func (m *Merge) String() string            { return proto.CompactTextString(m) }
func (*Merge) ProtoMessage()               {}
func (*Merge) Descriptor() ([]byte, []int) { return fileDescriptorProposerKv, []int{1} }

// ChangeReplicas is emitted by a Replica which commits a transaction with
// a ChangeReplicasTrigger.
type ChangeReplicas struct {
	cockroach_roachpb1.ChangeReplicasTrigger `protobuf:"bytes,1,opt,name=trigger,embedded=trigger" json:"trigger"`
}

func (m *ChangeReplicas) Reset()                    { *m = ChangeReplicas{} }
func (*ChangeReplicas) ProtoMessage()               {}
func (*ChangeReplicas) Descriptor() ([]byte, []int) { return fileDescriptorProposerKv, []int{2} }

// SuggestedCompaction holds start and end keys in conjunction with
// the suggested compaction.
type SuggestedCompaction struct {
	StartKey   github_com_cockroachdb_cockroach_pkg_roachpb.RKey `protobuf:"bytes,1,opt,name=start_key,json=startKey,proto3,casttype=github.com/cockroachdb/cockroach/pkg/roachpb.RKey" json:"start_key,omitempty"`
	EndKey     github_com_cockroachdb_cockroach_pkg_roachpb.RKey `protobuf:"bytes,2,opt,name=end_key,json=endKey,proto3,casttype=github.com/cockroachdb/cockroach/pkg/roachpb.RKey" json:"end_key,omitempty"`
	Compaction cockroach_storage_engine_enginepb1.Compaction     `protobuf:"bytes,3,opt,name=compaction" json:"compaction"`
}

func (m *SuggestedCompaction) Reset()                    { *m = SuggestedCompaction{} }
func (m *SuggestedCompaction) String() string            { return proto.CompactTextString(m) }
func (*SuggestedCompaction) ProtoMessage()               {}
func (*SuggestedCompaction) Descriptor() ([]byte, []int) { return fileDescriptorProposerKv, []int{3} }

// ReplicatedEvalResult is the structured information which together with
// a RocksDB WriteBatch constitutes the proposal payload in proposer-evaluated
// KV. For the majority of proposals, we expect ReplicatedEvalResult to be
// trivial; only changes to the metadata state (splits, merges, rebalances,
// leases, log truncation, ...) of the Replica or certain special commands must
// sideline information here based on which all Replicas must take action.
type ReplicatedEvalResult struct {
	StartKey github_com_cockroachdb_cockroach_pkg_roachpb.RKey `protobuf:"bytes,14,opt,name=start_key,json=startKey,proto3,casttype=github.com/cockroachdb/cockroach/pkg/roachpb.RKey" json:"start_key,omitempty"`
	EndKey   github_com_cockroachdb_cockroach_pkg_roachpb.RKey `protobuf:"bytes,15,opt,name=end_key,json=endKey,proto3,casttype=github.com/cockroachdb/cockroach/pkg/roachpb.RKey" json:"end_key,omitempty"`
	// Whether to block concurrent readers while processing the proposal data.
	BlockReads bool `protobuf:"varint,1,opt,name=block_reads,json=blockReads,proto3" json:"block_reads,omitempty"`
	// Updates to the Replica's ReplicaState. By convention and as outlined on
	// the comment on the ReplicaState message, this field is sparsely populated
	// and any field set overwrites the corresponding field in the state, perhaps
	// which additional side effects (for instance on a descriptor update).
	State           *ReplicaState                              `protobuf:"bytes,2,opt,name=state" json:"state,omitempty"`
	Split           *Split                                     `protobuf:"bytes,3,opt,name=split" json:"split,omitempty"`
	Merge           *Merge                                     `protobuf:"bytes,4,opt,name=merge" json:"merge,omitempty"`
	ComputeChecksum *cockroach_roachpb3.ComputeChecksumRequest `protobuf:"bytes,5,opt,name=compute_checksum,json=computeChecksum" json:"compute_checksum,omitempty"`
	IsLeaseRequest  bool                                       `protobuf:"varint,6,opt,name=is_lease_request,json=isLeaseRequest,proto3" json:"is_lease_request,omitempty"`
	// Duplicates BatchRequest.Timestamp for proposer-evaluated KV. Used
	// to verify the validity of the command (for lease coverage and GC
	// threshold).
	Timestamp            cockroach_util_hlc.Timestamp `protobuf:"bytes,8,opt,name=timestamp" json:"timestamp"`
	IsConsistencyRelated bool                         `protobuf:"varint,9,opt,name=is_consistency_related,json=isConsistencyRelated,proto3" json:"is_consistency_related,omitempty"`
	// The stats delta corresponding to the data in this WriteBatch. On
	// a split, contains only the contributions to the left-hand side.
	DeprecatedDelta *cockroach_storage_engine_enginepb2.MVCCStats      `protobuf:"bytes,10,opt,name=deprecated_delta,json=deprecatedDelta" json:"deprecated_delta,omitempty"`
	Delta           cockroach_storage_engine_enginepb.MVCCNetworkStats `protobuf:"bytes,18,opt,name=delta" json:"delta"`
	ChangeReplicas  *ChangeReplicas                                    `protobuf:"bytes,12,opt,name=change_replicas,json=changeReplicas" json:"change_replicas,omitempty"`
	RaftLogDelta    int64                                              `protobuf:"varint,13,opt,name=raft_log_delta,json=raftLogDelta,proto3" json:"raft_log_delta,omitempty"`
	AddSSTable      *ReplicatedEvalResult_AddSSTable                   `protobuf:"bytes,17,opt,name=add_sstable,json=addSstable" json:"add_sstable,omitempty"`
	// suggested_compactions are sent to the engine's compactor to
	// reclaim storage space after garbage collection or cleared /
	// rebalanced ranges.
	SuggestedCompactions []SuggestedCompaction `protobuf:"bytes,19,rep,name=suggested_compactions,json=suggestedCompactions" json:"suggested_compactions"`
}

func (m *ReplicatedEvalResult) Reset()                    { *m = ReplicatedEvalResult{} }
func (m *ReplicatedEvalResult) String() string            { return proto.CompactTextString(m) }
func (*ReplicatedEvalResult) ProtoMessage()               {}
func (*ReplicatedEvalResult) Descriptor() ([]byte, []int) { return fileDescriptorProposerKv, []int{4} }

// AddSSTable is a side effect that must execute before the Raft application
// is committed. It must be idempotent to account for an ill-timed crash after
// applying the side effect, but before committing the batch.
//
// TODO(tschottdorf): additionally, after the crash, the node must not serve
// traffic until the persisted committed log has fully applied. Otherwise, we
// risk exposing data created through such a side effect whose corresponding
// Raft command hasn't committed yet. This isn't so much an issue with AddSSTable
// since these Ranges are not user-visible, but it is a general concern assuming
// other such side effects are added.
type ReplicatedEvalResult_AddSSTable struct {
	Data  []byte `protobuf:"bytes,1,opt,name=data,proto3" json:"data,omitempty"`
	CRC32 uint32 `protobuf:"varint,2,opt,name=crc32,proto3" json:"crc32,omitempty"`
}

func (m *ReplicatedEvalResult_AddSSTable) Reset()         { *m = ReplicatedEvalResult_AddSSTable{} }
func (m *ReplicatedEvalResult_AddSSTable) String() string { return proto.CompactTextString(m) }
func (*ReplicatedEvalResult_AddSSTable) ProtoMessage()    {}
func (*ReplicatedEvalResult_AddSSTable) Descriptor() ([]byte, []int) {
	return fileDescriptorProposerKv, []int{4, 0}
}

// WriteBatch is the serialized representation of a RocksDB write
// batch. A wrapper message is used so that the absence of the field
// can be distinguished from a zero-length batch, and so structs
// containing pointers to it can be compared with the == operator (we
// rely on this in storage.EvalResult)
type WriteBatch struct {
	Data []byte `protobuf:"bytes,1,opt,name=data,proto3" json:"data,omitempty"`
}

func (m *WriteBatch) Reset()                    { *m = WriteBatch{} }
func (m *WriteBatch) String() string            { return proto.CompactTextString(m) }
func (*WriteBatch) ProtoMessage()               {}
func (*WriteBatch) Descriptor() ([]byte, []int) { return fileDescriptorProposerKv, []int{5} }

// RaftCommand is the message written to the raft log. It contains
// some metadata about the proposal itself, then either a BatchRequest
// (legacy mode) or a ReplicatedEvalResult + WriteBatch
// (proposer-evaluated KV mode).
type RaftCommand struct {
	// proposer_replica is the replica which proposed this command, to be
	// used for lease validation.
	ProposerReplica cockroach_roachpb.ReplicaDescriptor `protobuf:"bytes,2,opt,name=proposer_replica,json=proposerReplica" json:"proposer_replica"`
	// proposer_lease is provided to verify at raft command apply-time that
	// the lease under which the command was proposed remains in effect.
	//
	// To see why lease verification downstream of Raft is required, consider the
	// following example:
	// - replica 1 receives a client request for a write
	// - replica 1 checks the lease; the write is permitted
	// - replica 1 proposes the command
	// - time passes, replica 2 commits a new lease
	// - the command applies on replica 1
	// - replica 2 serves anomalous reads which don't see the write
	// - the command applies on replica 2
	ProposerLease cockroach_roachpb1.Lease `protobuf:"bytes,5,opt,name=proposer_lease,json=proposerLease" json:"proposer_lease"`
	// When the command is applied, its result is an error if the lease log
	// counter has already reached (or exceeded) max_lease_index.
	//
	// The lease index is a reorder protection mechanism - we don't want Raft
	// commands (proposed by a single node, the one with proposer_lease) executing
	// in a different order than the one in which the corresponding KV requests
	// were evaluated and the commands were proposed. This is important because
	// the CommandQueue does not fully serialize commands - mostly when it comes
	// to updates to the internal state of the range (this should be re-evaluated
	// once proposer-evaluated KV is completed - see #10413).
	// Similar to the Raft applied index, it is strictly increasing, but may have
	// gaps. A command will only apply successfully if its max_lease_index has not
	// been surpassed by the Range's applied lease index (in which case the
	// command may need to be retried, that is, regenerated with a higher
	// max_lease_index). When the command applies, the new lease index will
	// increase to max_lease_index (so a potential later replay will fail).
	//
	// This mechanism was introduced as a simpler alternative to using the Raft
	// applied index, which is fraught with complexity due to the need to predict
	// exactly the log position at which a command will apply, even when the Raft
	// leader is not colocated with the lease holder (which usually proposes all
	// commands).
	//
	// Pinning the lease-index to the assigned slot (as opposed to allowing gaps
	// as we do now) is an interesting venue to explore from the standpoint of
	// parallelization: One could hope to enforce command ordering in that way
	// (without recourse to a higher-level locking primitive such as the command
	// queue). This is a hard problem: First of all, managing the pending
	// commands gets more involved; a command must not be removed if others have
	// been added after it, and on removal, the assignment counters must be
	// updated accordingly. Managing retry of proposals becomes trickier as
	// well as that uproots whatever ordering was originally envisioned.
	MaxLeaseIndex uint64 `protobuf:"varint,4,opt,name=max_lease_index,json=maxLeaseIndex,proto3" json:"max_lease_index,omitempty"`
	// testing_batch_request is the KV request that generated this Raft command.
	//
	// TODO(bdarnell): This used to be a pre-proposer-evaluated-kv field; we're
	// now exclusively proposer-evaluated, but it is still needed by certain tests
	// that use TestingEvalFilter. See #10493.
	TestingBatchRequest  *cockroach_roachpb3.BatchRequest `protobuf:"bytes,3,opt,name=testing_batch_request,json=testingBatchRequest" json:"testing_batch_request,omitempty"`
	ReplicatedEvalResult ReplicatedEvalResult             `protobuf:"bytes,13,opt,name=replicated_eval_result,json=replicatedEvalResult" json:"replicated_eval_result"`
	WriteBatch           *WriteBatch                      `protobuf:"bytes,14,opt,name=write_batch,json=writeBatch" json:"write_batch,omitempty"`
}

func (m *RaftCommand) Reset()                    { *m = RaftCommand{} }
func (m *RaftCommand) String() string            { return proto.CompactTextString(m) }
func (*RaftCommand) ProtoMessage()               {}
func (*RaftCommand) Descriptor() ([]byte, []int) { return fileDescriptorProposerKv, []int{6} }

func init() {
	proto.RegisterType((*Split)(nil), "cockroach.storage.storagebase.Split")
	proto.RegisterType((*Merge)(nil), "cockroach.storage.storagebase.Merge")
	proto.RegisterType((*ChangeReplicas)(nil), "cockroach.storage.storagebase.ChangeReplicas")
	proto.RegisterType((*SuggestedCompaction)(nil), "cockroach.storage.storagebase.SuggestedCompaction")
	proto.RegisterType((*ReplicatedEvalResult)(nil), "cockroach.storage.storagebase.ReplicatedEvalResult")
	proto.RegisterType((*ReplicatedEvalResult_AddSSTable)(nil), "cockroach.storage.storagebase.ReplicatedEvalResult.AddSSTable")
	proto.RegisterType((*WriteBatch)(nil), "cockroach.storage.storagebase.WriteBatch")
	proto.RegisterType((*RaftCommand)(nil), "cockroach.storage.storagebase.RaftCommand")
}
func (this *Split) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Split)
	if !ok {
		that2, ok := that.(Split)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.SplitTrigger.Equal(&that1.SplitTrigger) {
		return false
	}
	if !this.RHSDelta.Equal(&that1.RHSDelta) {
		return false
	}
	return true
}
func (this *Merge) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Merge)
	if !ok {
		that2, ok := that.(Merge)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.MergeTrigger.Equal(&that1.MergeTrigger) {
		return false
	}
	return true
}
func (this *ChangeReplicas) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*ChangeReplicas)
	if !ok {
		that2, ok := that.(ChangeReplicas)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.ChangeReplicasTrigger.Equal(&that1.ChangeReplicasTrigger) {
		return false
	}
	return true
}
func (this *SuggestedCompaction) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*SuggestedCompaction)
	if !ok {
		that2, ok := that.(SuggestedCompaction)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !bytes.Equal(this.StartKey, that1.StartKey) {
		return false
	}
	if !bytes.Equal(this.EndKey, that1.EndKey) {
		return false
	}
	if !this.Compaction.Equal(&that1.Compaction) {
		return false
	}
	return true
}
func (this *ReplicatedEvalResult) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*ReplicatedEvalResult)
	if !ok {
		that2, ok := that.(ReplicatedEvalResult)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !bytes.Equal(this.StartKey, that1.StartKey) {
		return false
	}
	if !bytes.Equal(this.EndKey, that1.EndKey) {
		return false
	}
	if this.BlockReads != that1.BlockReads {
		return false
	}
	if !this.State.Equal(that1.State) {
		return false
	}
	if !this.Split.Equal(that1.Split) {
		return false
	}
	if !this.Merge.Equal(that1.Merge) {
		return false
	}
	if !this.ComputeChecksum.Equal(that1.ComputeChecksum) {
		return false
	}
	if this.IsLeaseRequest != that1.IsLeaseRequest {
		return false
	}
	if !this.Timestamp.Equal(&that1.Timestamp) {
		return false
	}
	if this.IsConsistencyRelated != that1.IsConsistencyRelated {
		return false
	}
	if !this.DeprecatedDelta.Equal(that1.DeprecatedDelta) {
		return false
	}
	if !this.Delta.Equal(&that1.Delta) {
		return false
	}
	if !this.ChangeReplicas.Equal(that1.ChangeReplicas) {
		return false
	}
	if this.RaftLogDelta != that1.RaftLogDelta {
		return false
	}
	if !this.AddSSTable.Equal(that1.AddSSTable) {
		return false
	}
	if len(this.SuggestedCompactions) != len(that1.SuggestedCompactions) {
		return false
	}
	for i := range this.SuggestedCompactions {
		if !this.SuggestedCompactions[i].Equal(&that1.SuggestedCompactions[i]) {
			return false
		}
	}
	return true
}
func (this *ReplicatedEvalResult_AddSSTable) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*ReplicatedEvalResult_AddSSTable)
	if !ok {
		that2, ok := that.(ReplicatedEvalResult_AddSSTable)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !bytes.Equal(this.Data, that1.Data) {
		return false
	}
	if this.CRC32 != that1.CRC32 {
		return false
	}
	return true
}
func (m *Split) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Split) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintProposerKv(dAtA, i, uint64(m.SplitTrigger.Size()))
	n1, err := m.SplitTrigger.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n1
	dAtA[i] = 0x12
	i++
	i = encodeVarintProposerKv(dAtA, i, uint64(m.RHSDelta.Size()))
	n2, err := m.RHSDelta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n2
	return i, nil
}

func (m *Merge) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Merge) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintProposerKv(dAtA, i, uint64(m.MergeTrigger.Size()))
	n3, err := m.MergeTrigger.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n3
	return i, nil
}

func (m *ChangeReplicas) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ChangeReplicas) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintProposerKv(dAtA, i, uint64(m.ChangeReplicasTrigger.Size()))
	n4, err := m.ChangeReplicasTrigger.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n4
	return i, nil
}

func (m *SuggestedCompaction) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SuggestedCompaction) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.StartKey) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintProposerKv(dAtA, i, uint64(len(m.StartKey)))
		i += copy(dAtA[i:], m.StartKey)
	}
	if len(m.EndKey) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintProposerKv(dAtA, i, uint64(len(m.EndKey)))
		i += copy(dAtA[i:], m.EndKey)
	}
	dAtA[i] = 0x1a
	i++
	i = encodeVarintProposerKv(dAtA, i, uint64(m.Compaction.Size()))
	n5, err := m.Compaction.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n5
	return i, nil
}

func (m *ReplicatedEvalResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReplicatedEvalResult) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.BlockReads {
		dAtA[i] = 0x8
		i++
		if m.BlockReads {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.State != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintProposerKv(dAtA, i, uint64(m.State.Size()))
		n6, err := m.State.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	if m.Split != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintProposerKv(dAtA, i, uint64(m.Split.Size()))
		n7, err := m.Split.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	if m.Merge != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintProposerKv(dAtA, i, uint64(m.Merge.Size()))
		n8, err := m.Merge.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	if m.ComputeChecksum != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintProposerKv(dAtA, i, uint64(m.ComputeChecksum.Size()))
		n9, err := m.ComputeChecksum.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	if m.IsLeaseRequest {
		dAtA[i] = 0x30
		i++
		if m.IsLeaseRequest {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	dAtA[i] = 0x42
	i++
	i = encodeVarintProposerKv(dAtA, i, uint64(m.Timestamp.Size()))
	n10, err := m.Timestamp.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n10
	if m.IsConsistencyRelated {
		dAtA[i] = 0x48
		i++
		if m.IsConsistencyRelated {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.DeprecatedDelta != nil {
		dAtA[i] = 0x52
		i++
		i = encodeVarintProposerKv(dAtA, i, uint64(m.DeprecatedDelta.Size()))
		n11, err := m.DeprecatedDelta.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n11
	}
	if m.ChangeReplicas != nil {
		dAtA[i] = 0x62
		i++
		i = encodeVarintProposerKv(dAtA, i, uint64(m.ChangeReplicas.Size()))
		n12, err := m.ChangeReplicas.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n12
	}
	if m.RaftLogDelta != 0 {
		dAtA[i] = 0x68
		i++
		i = encodeVarintProposerKv(dAtA, i, uint64(m.RaftLogDelta))
	}
	if len(m.StartKey) > 0 {
		dAtA[i] = 0x72
		i++
		i = encodeVarintProposerKv(dAtA, i, uint64(len(m.StartKey)))
		i += copy(dAtA[i:], m.StartKey)
	}
	if len(m.EndKey) > 0 {
		dAtA[i] = 0x7a
		i++
		i = encodeVarintProposerKv(dAtA, i, uint64(len(m.EndKey)))
		i += copy(dAtA[i:], m.EndKey)
	}
	if m.AddSSTable != nil {
		dAtA[i] = 0x8a
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintProposerKv(dAtA, i, uint64(m.AddSSTable.Size()))
		n13, err := m.AddSSTable.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n13
	}
	dAtA[i] = 0x92
	i++
	dAtA[i] = 0x1
	i++
	i = encodeVarintProposerKv(dAtA, i, uint64(m.Delta.Size()))
	n14, err := m.Delta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n14
	if len(m.SuggestedCompactions) > 0 {
		for _, msg := range m.SuggestedCompactions {
			dAtA[i] = 0x9a
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintProposerKv(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *ReplicatedEvalResult_AddSSTable) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReplicatedEvalResult_AddSSTable) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Data) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintProposerKv(dAtA, i, uint64(len(m.Data)))
		i += copy(dAtA[i:], m.Data)
	}
	if m.CRC32 != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintProposerKv(dAtA, i, uint64(m.CRC32))
	}
	return i, nil
}

func (m *WriteBatch) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WriteBatch) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Data) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintProposerKv(dAtA, i, uint64(len(m.Data)))
		i += copy(dAtA[i:], m.Data)
	}
	return i, nil
}

func (m *RaftCommand) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RaftCommand) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x12
	i++
	i = encodeVarintProposerKv(dAtA, i, uint64(m.ProposerReplica.Size()))
	n15, err := m.ProposerReplica.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n15
	if m.TestingBatchRequest != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintProposerKv(dAtA, i, uint64(m.TestingBatchRequest.Size()))
		n16, err := m.TestingBatchRequest.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n16
	}
	if m.MaxLeaseIndex != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintProposerKv(dAtA, i, uint64(m.MaxLeaseIndex))
	}
	dAtA[i] = 0x2a
	i++
	i = encodeVarintProposerKv(dAtA, i, uint64(m.ProposerLease.Size()))
	n17, err := m.ProposerLease.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n17
	dAtA[i] = 0x6a
	i++
	i = encodeVarintProposerKv(dAtA, i, uint64(m.ReplicatedEvalResult.Size()))
	n18, err := m.ReplicatedEvalResult.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n18
	if m.WriteBatch != nil {
		dAtA[i] = 0x72
		i++
		i = encodeVarintProposerKv(dAtA, i, uint64(m.WriteBatch.Size()))
		n19, err := m.WriteBatch.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n19
	}
	return i, nil
}

func encodeVarintProposerKv(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *Split) Size() (n int) {
	var l int
	_ = l
	l = m.SplitTrigger.Size()
	n += 1 + l + sovProposerKv(uint64(l))
	l = m.RHSDelta.Size()
	n += 1 + l + sovProposerKv(uint64(l))
	return n
}

func (m *Merge) Size() (n int) {
	var l int
	_ = l
	l = m.MergeTrigger.Size()
	n += 1 + l + sovProposerKv(uint64(l))
	return n
}

func (m *ChangeReplicas) Size() (n int) {
	var l int
	_ = l
	l = m.ChangeReplicasTrigger.Size()
	n += 1 + l + sovProposerKv(uint64(l))
	return n
}

func (m *SuggestedCompaction) Size() (n int) {
	var l int
	_ = l
	l = len(m.StartKey)
	if l > 0 {
		n += 1 + l + sovProposerKv(uint64(l))
	}
	l = len(m.EndKey)
	if l > 0 {
		n += 1 + l + sovProposerKv(uint64(l))
	}
	l = m.Compaction.Size()
	n += 1 + l + sovProposerKv(uint64(l))
	return n
}

func (m *ReplicatedEvalResult) Size() (n int) {
	var l int
	_ = l
	if m.BlockReads {
		n += 2
	}
	if m.State != nil {
		l = m.State.Size()
		n += 1 + l + sovProposerKv(uint64(l))
	}
	if m.Split != nil {
		l = m.Split.Size()
		n += 1 + l + sovProposerKv(uint64(l))
	}
	if m.Merge != nil {
		l = m.Merge.Size()
		n += 1 + l + sovProposerKv(uint64(l))
	}
	if m.ComputeChecksum != nil {
		l = m.ComputeChecksum.Size()
		n += 1 + l + sovProposerKv(uint64(l))
	}
	if m.IsLeaseRequest {
		n += 2
	}
	l = m.Timestamp.Size()
	n += 1 + l + sovProposerKv(uint64(l))
	if m.IsConsistencyRelated {
		n += 2
	}
	if m.DeprecatedDelta != nil {
		l = m.DeprecatedDelta.Size()
		n += 1 + l + sovProposerKv(uint64(l))
	}
	if m.ChangeReplicas != nil {
		l = m.ChangeReplicas.Size()
		n += 1 + l + sovProposerKv(uint64(l))
	}
	if m.RaftLogDelta != 0 {
		n += 1 + sovProposerKv(uint64(m.RaftLogDelta))
	}
	l = len(m.StartKey)
	if l > 0 {
		n += 1 + l + sovProposerKv(uint64(l))
	}
	l = len(m.EndKey)
	if l > 0 {
		n += 1 + l + sovProposerKv(uint64(l))
	}
	if m.AddSSTable != nil {
		l = m.AddSSTable.Size()
		n += 2 + l + sovProposerKv(uint64(l))
	}
	l = m.Delta.Size()
	n += 2 + l + sovProposerKv(uint64(l))
	if len(m.SuggestedCompactions) > 0 {
		for _, e := range m.SuggestedCompactions {
			l = e.Size()
			n += 2 + l + sovProposerKv(uint64(l))
		}
	}
	return n
}

func (m *ReplicatedEvalResult_AddSSTable) Size() (n int) {
	var l int
	_ = l
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovProposerKv(uint64(l))
	}
	if m.CRC32 != 0 {
		n += 1 + sovProposerKv(uint64(m.CRC32))
	}
	return n
}

func (m *WriteBatch) Size() (n int) {
	var l int
	_ = l
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovProposerKv(uint64(l))
	}
	return n
}

func (m *RaftCommand) Size() (n int) {
	var l int
	_ = l
	l = m.ProposerReplica.Size()
	n += 1 + l + sovProposerKv(uint64(l))
	if m.TestingBatchRequest != nil {
		l = m.TestingBatchRequest.Size()
		n += 1 + l + sovProposerKv(uint64(l))
	}
	if m.MaxLeaseIndex != 0 {
		n += 1 + sovProposerKv(uint64(m.MaxLeaseIndex))
	}
	l = m.ProposerLease.Size()
	n += 1 + l + sovProposerKv(uint64(l))
	l = m.ReplicatedEvalResult.Size()
	n += 1 + l + sovProposerKv(uint64(l))
	if m.WriteBatch != nil {
		l = m.WriteBatch.Size()
		n += 1 + l + sovProposerKv(uint64(l))
	}
	return n
}

func sovProposerKv(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozProposerKv(x uint64) (n int) {
	return sovProposerKv(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Split) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProposerKv
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Split: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Split: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SplitTrigger", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProposerKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProposerKv
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.SplitTrigger.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RHSDelta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProposerKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProposerKv
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RHSDelta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProposerKv(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProposerKv
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Merge) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProposerKv
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Merge: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Merge: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MergeTrigger", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProposerKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProposerKv
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MergeTrigger.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProposerKv(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProposerKv
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ChangeReplicas) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProposerKv
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ChangeReplicas: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ChangeReplicas: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChangeReplicasTrigger", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProposerKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProposerKv
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ChangeReplicasTrigger.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProposerKv(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProposerKv
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SuggestedCompaction) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProposerKv
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SuggestedCompaction: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SuggestedCompaction: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProposerKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthProposerKv
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StartKey = append(m.StartKey[:0], dAtA[iNdEx:postIndex]...)
			if m.StartKey == nil {
				m.StartKey = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProposerKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthProposerKv
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EndKey = append(m.EndKey[:0], dAtA[iNdEx:postIndex]...)
			if m.EndKey == nil {
				m.EndKey = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Compaction", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProposerKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProposerKv
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Compaction.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProposerKv(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProposerKv
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReplicatedEvalResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProposerKv
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReplicatedEvalResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReplicatedEvalResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockReads", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProposerKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.BlockReads = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProposerKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProposerKv
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.State == nil {
				m.State = &ReplicaState{}
			}
			if err := m.State.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Split", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProposerKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProposerKv
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Split == nil {
				m.Split = &Split{}
			}
			if err := m.Split.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Merge", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProposerKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProposerKv
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Merge == nil {
				m.Merge = &Merge{}
			}
			if err := m.Merge.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ComputeChecksum", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProposerKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProposerKv
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ComputeChecksum == nil {
				m.ComputeChecksum = &cockroach_roachpb3.ComputeChecksumRequest{}
			}
			if err := m.ComputeChecksum.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsLeaseRequest", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProposerKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsLeaseRequest = bool(v != 0)
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProposerKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProposerKv
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Timestamp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsConsistencyRelated", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProposerKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsConsistencyRelated = bool(v != 0)
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeprecatedDelta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProposerKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProposerKv
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DeprecatedDelta == nil {
				m.DeprecatedDelta = &cockroach_storage_engine_enginepb2.MVCCStats{}
			}
			if err := m.DeprecatedDelta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChangeReplicas", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProposerKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProposerKv
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ChangeReplicas == nil {
				m.ChangeReplicas = &ChangeReplicas{}
			}
			if err := m.ChangeReplicas.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RaftLogDelta", wireType)
			}
			m.RaftLogDelta = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProposerKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RaftLogDelta |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProposerKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthProposerKv
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StartKey = append(m.StartKey[:0], dAtA[iNdEx:postIndex]...)
			if m.StartKey == nil {
				m.StartKey = []byte{}
			}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProposerKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthProposerKv
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EndKey = append(m.EndKey[:0], dAtA[iNdEx:postIndex]...)
			if m.EndKey == nil {
				m.EndKey = []byte{}
			}
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AddSSTable", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProposerKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProposerKv
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AddSSTable == nil {
				m.AddSSTable = &ReplicatedEvalResult_AddSSTable{}
			}
			if err := m.AddSSTable.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Delta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProposerKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProposerKv
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Delta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SuggestedCompactions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProposerKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProposerKv
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SuggestedCompactions = append(m.SuggestedCompactions, SuggestedCompaction{})
			if err := m.SuggestedCompactions[len(m.SuggestedCompactions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProposerKv(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProposerKv
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReplicatedEvalResult_AddSSTable) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProposerKv
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AddSSTable: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AddSSTable: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProposerKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthProposerKv
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CRC32", wireType)
			}
			m.CRC32 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProposerKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CRC32 |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipProposerKv(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProposerKv
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WriteBatch) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProposerKv
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WriteBatch: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WriteBatch: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProposerKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthProposerKv
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProposerKv(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProposerKv
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RaftCommand) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProposerKv
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RaftCommand: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RaftCommand: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProposerReplica", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProposerKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProposerKv
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ProposerReplica.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TestingBatchRequest", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProposerKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProposerKv
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TestingBatchRequest == nil {
				m.TestingBatchRequest = &cockroach_roachpb3.BatchRequest{}
			}
			if err := m.TestingBatchRequest.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxLeaseIndex", wireType)
			}
			m.MaxLeaseIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProposerKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxLeaseIndex |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProposerLease", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProposerKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProposerKv
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ProposerLease.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplicatedEvalResult", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProposerKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProposerKv
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ReplicatedEvalResult.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WriteBatch", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProposerKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProposerKv
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.WriteBatch == nil {
				m.WriteBatch = &WriteBatch{}
			}
			if err := m.WriteBatch.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProposerKv(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProposerKv
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipProposerKv(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowProposerKv
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowProposerKv
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowProposerKv
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthProposerKv
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowProposerKv
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipProposerKv(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthProposerKv = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowProposerKv   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("storage/storagebase/proposer_kv.proto", fileDescriptorProposerKv) }

var fileDescriptorProposerKv = []byte{
	// 1124 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x56, 0x4d, 0x6f, 0x23, 0x45,
	0x13, 0xce, 0x24, 0x76, 0x32, 0x6e, 0x27, 0xb6, 0xd3, 0xc9, 0x46, 0xa3, 0x48, 0xeb, 0x89, 0xf2,
	0x66, 0x5f, 0x05, 0x01, 0x63, 0x91, 0xc0, 0x65, 0x0f, 0x48, 0xb1, 0x77, 0x05, 0x64, 0xb3, 0x41,
	0x6a, 0x87, 0x5d, 0x09, 0x0e, 0xa3, 0x76, 0x4f, 0xef, 0x78, 0xe4, 0xf9, 0xa2, 0xbb, 0x9d, 0x8f,
	0x7f, 0x01, 0x12, 0x07, 0x4e, 0xb0, 0xff, 0x80, 0xbf, 0x91, 0xe3, 0x1e, 0x39, 0x59, 0x60, 0x2e,
	0xdc, 0xb9, 0xed, 0x09, 0x4d, 0x77, 0x8f, 0x3f, 0x88, 0x93, 0x18, 0xb1, 0x97, 0xb8, 0x53, 0x53,
	0xf5, 0x54, 0x57, 0xd5, 0x53, 0xcf, 0x0c, 0x78, 0xc4, 0x45, 0xc2, 0xb0, 0x4f, 0x1b, 0xfa, 0xb7,
	0x83, 0x39, 0x6d, 0xa4, 0x2c, 0x49, 0x13, 0x4e, 0x99, 0xdb, 0x3b, 0x77, 0x52, 0x96, 0x88, 0x04,
	0x3e, 0x24, 0x09, 0xe9, 0xb1, 0x04, 0x93, 0xae, 0xa3, 0x1d, 0x9d, 0x89, 0x80, 0xed, 0x75, 0xf9,
	0x28, 0xed, 0x34, 0x70, 0x1a, 0xa8, 0x88, 0x6d, 0x98, 0x9b, 0x3c, 0x2c, 0xb0, 0xb6, 0x6d, 0xe5,
	0xb6, 0x88, 0x0a, 0x3c, 0x61, 0x1f, 0x5d, 0x82, 0xc6, 0x7e, 0x10, 0xe7, 0x3f, 0x69, 0xa7, 0x41,
	0x92, 0x28, 0xc5, 0x44, 0x68, 0xb7, 0xdd, 0xdb, 0xdc, 0xa2, 0x73, 0x42, 0xb4, 0xcf, 0xff, 0xee,
	0xf2, 0x39, 0xd4, 0x4e, 0xf6, 0xac, 0xa2, 0xb9, 0xc0, 0x82, 0x6a, 0x07, 0xab, 0x2f, 0x82, 0xb0,
	0xd1, 0x0d, 0x49, 0x43, 0x04, 0x11, 0xe5, 0x02, 0x47, 0xa9, 0x7e, 0xb2, 0xe9, 0x27, 0x7e, 0x22,
	0x8f, 0x8d, 0xec, 0xa4, 0xac, 0xbb, 0xbf, 0x18, 0xa0, 0xd8, 0x4e, 0xc3, 0x40, 0xc0, 0x16, 0x58,
	0x11, 0x2c, 0xf0, 0x7d, 0xca, 0x2c, 0x63, 0xc7, 0xd8, 0x2f, 0x1f, 0xd8, 0xce, 0xb8, 0x75, 0xba,
	0x7c, 0x47, 0xba, 0x9e, 0x29, 0xb7, 0xa6, 0x79, 0x3d, 0xb0, 0x17, 0xde, 0x0c, 0x6c, 0x03, 0xe5,
	0x91, 0xf0, 0x1b, 0x50, 0x62, 0x5d, 0xee, 0x7a, 0x34, 0x14, 0xd8, 0x5a, 0x94, 0x30, 0x1f, 0x38,
	0x37, 0x27, 0xa0, 0x6a, 0x73, 0xf2, 0x12, 0x9d, 0xe7, 0x2f, 0x5a, 0xad, 0xb6, 0xc0, 0x82, 0x37,
	0x6b, 0x19, 0xe6, 0x70, 0x60, 0x9b, 0xe8, 0xf3, 0xf6, 0x93, 0x0c, 0x05, 0x99, 0xac, 0xcb, 0xe5,
	0xe9, 0x71, 0xe1, 0xcf, 0xd7, 0xb6, 0xb1, 0x8b, 0x40, 0xf1, 0x39, 0x65, 0x3e, 0x9d, 0xef, 0xc2,
	0xd2, 0xf5, 0xf6, 0x0b, 0x6b, 0xcc, 0x2e, 0xa8, 0xb4, 0xba, 0x38, 0xf6, 0x29, 0xa2, 0x69, 0x18,
	0x10, 0xcc, 0xe1, 0xc9, 0x3f, 0xc1, 0xf7, 0x67, 0x80, 0x4f, 0xc7, 0xdc, 0x91, 0xc5, 0xfc, 0xf1,
	0xb5, 0xbd, 0x20, 0x33, 0xfd, 0xb0, 0x08, 0x36, 0xda, 0x7d, 0xdf, 0xa7, 0x5c, 0x50, 0xaf, 0xa5,
	0x48, 0x12, 0x24, 0x31, 0x44, 0xa0, 0xc4, 0x05, 0x66, 0xc2, 0xed, 0xd1, 0x2b, 0x99, 0x71, 0xb5,
	0xf9, 0xc9, 0xdb, 0x81, 0xfd, 0x91, 0x1f, 0x88, 0x6e, 0xbf, 0xe3, 0x90, 0x24, 0x6a, 0x8c, 0xf2,
	0x7b, 0x9d, 0xf1, 0xb9, 0x91, 0xf6, 0xfc, 0x46, 0x7e, 0x1f, 0xf4, 0x8c, 0x5e, 0x21, 0x53, 0xe2,
	0x3c, 0xa3, 0x57, 0xf0, 0x14, 0xac, 0xd0, 0xd8, 0x93, 0x88, 0x8b, 0xff, 0x05, 0x71, 0x99, 0xc6,
	0x5e, 0x86, 0xd7, 0x06, 0x80, 0x8c, 0x6e, 0x6c, 0x2d, 0xc9, 0xb6, 0x7c, 0x38, 0xc7, 0x74, 0xc7,
	0x65, 0x36, 0x0b, 0x59, 0x6f, 0xd0, 0x04, 0x8c, 0x1e, 0xc0, 0xdb, 0x12, 0xd8, 0xd4, 0x7d, 0x14,
	0xd4, 0x7b, 0x7a, 0x8e, 0x43, 0x44, 0x79, 0x3f, 0x14, 0xd0, 0x06, 0xe5, 0x4e, 0x98, 0x90, 0x9e,
	0xcb, 0x28, 0xf6, 0xb8, 0xec, 0x8c, 0x89, 0x80, 0x34, 0xa1, 0xcc, 0x02, 0x8f, 0x40, 0x51, 0xf2,
	0x5f, 0xb3, 0xed, 0x7d, 0xe7, 0xce, 0x7d, 0x77, 0x74, 0x92, 0x8c, 0x6c, 0x14, 0xa9, 0x48, 0xf8,
	0x18, 0x14, 0x79, 0xc6, 0x6b, 0x5d, 0xd2, 0xde, 0x3d, 0x10, 0x72, 0x07, 0x90, 0x0a, 0xc9, 0x62,
	0xa3, 0x8c, 0x62, 0x56, 0x61, 0xae, 0x58, 0x49, 0x47, 0xa4, 0x42, 0xe0, 0x19, 0xa8, 0x65, 0x8d,
	0xe8, 0x0b, 0xea, 0x92, 0x2e, 0x25, 0x3d, 0xde, 0x8f, 0xac, 0xa2, 0x84, 0x79, 0x6f, 0x16, 0xd9,
	0x94, 0x6b, 0x4b, 0x7b, 0x22, 0xfa, 0x6d, 0x9f, 0x72, 0x81, 0xaa, 0x64, 0xda, 0x0e, 0xf7, 0x41,
	0x2d, 0xe0, 0x6e, 0x48, 0x31, 0xa7, 0x2e, 0x53, 0x4e, 0xd6, 0xb2, 0x6c, 0x5b, 0x25, 0xe0, 0x27,
	0x99, 0x59, 0x87, 0xc2, 0x23, 0x50, 0x1a, 0x89, 0x84, 0x65, 0xca, 0xc4, 0x0f, 0x27, 0x12, 0x67,
	0x4a, 0xe2, 0x74, 0x43, 0xe2, 0x9c, 0xe5, 0x4e, 0x7a, 0x7c, 0xe3, 0x28, 0xf8, 0x31, 0xd8, 0x0a,
	0xb8, 0x4b, 0x92, 0x98, 0x07, 0x5c, 0xd0, 0x98, 0x5c, 0xb9, 0x8c, 0x86, 0xd9, 0x08, 0xad, 0x92,
	0x4c, 0xb9, 0x19, 0xf0, 0xd6, 0xf8, 0x21, 0x52, 0xcf, 0xe0, 0x4b, 0x50, 0xf3, 0x68, 0xca, 0xa8,
	0x1c, 0xb6, 0x16, 0x0b, 0xf0, 0xef, 0xc5, 0x02, 0x55, 0xc7, 0x28, 0x52, 0x21, 0xe0, 0x0b, 0x50,
	0x25, 0x72, 0x27, 0x5d, 0xa6, 0x97, 0xd2, 0x5a, 0xbd, 0x95, 0xa6, 0x93, 0x73, 0x99, 0xde, 0x64,
	0x54, 0x21, 0xd3, 0x6a, 0xb0, 0x07, 0x2a, 0x0c, 0xbf, 0x12, 0x6e, 0x98, 0xf8, 0xfa, 0xba, 0x6b,
	0x3b, 0xc6, 0xfe, 0x12, 0x5a, 0xcd, 0xac, 0x27, 0x89, 0xaf, 0xb2, 0x4f, 0xed, 0x70, 0xe5, 0x9d,
	0xef, 0x70, 0xf5, 0x5d, 0xec, 0x70, 0x02, 0xca, 0xd8, 0xf3, 0x5c, 0xce, 0x05, 0xee, 0x84, 0xd4,
	0x5a, 0x97, 0xdd, 0xf9, 0x74, 0xbe, 0xa5, 0x99, 0xda, 0x4c, 0xe7, 0xc8, 0xf3, 0xda, 0xed, 0xb3,
	0x0c, 0xa5, 0x59, 0x19, 0x0e, 0x6c, 0x30, 0xfe, 0x1f, 0x01, 0xec, 0x79, 0x6d, 0x95, 0x01, 0x7e,
	0x09, 0x8a, 0xaa, 0x63, 0x50, 0xa6, 0x3a, 0x9c, 0x73, 0xc0, 0xa7, 0x54, 0x5c, 0x24, 0xac, 0xa7,
	0x5e, 0x0a, 0x8a, 0x76, 0x0a, 0x07, 0x46, 0xe0, 0x01, 0xcf, 0x05, 0xd4, 0x1d, 0x0b, 0x09, 0xb7,
	0x36, 0x76, 0x96, 0xf6, 0xcb, 0x07, 0x07, 0xf7, 0x6d, 0xef, 0x4d, 0xf1, 0xd5, 0xf8, 0x9b, 0xfc,
	0xe6, 0x23, 0xbe, 0xfd, 0x19, 0x98, 0xa8, 0x0c, 0x42, 0x50, 0xc8, 0xde, 0xfe, 0x4a, 0xa1, 0x91,
	0x3c, 0x43, 0x1b, 0x14, 0x09, 0x23, 0x87, 0x07, 0x52, 0x81, 0xd6, 0x9a, 0xa5, 0xe1, 0xc0, 0x2e,
	0xb6, 0x50, 0xeb, 0xf0, 0x00, 0x29, 0xbb, 0x92, 0x38, 0xf5, 0xf7, 0xb8, 0x60, 0xae, 0xd4, 0xcc,
	0xe3, 0x82, 0x59, 0xab, 0xad, 0x1f, 0x2f, 0x9b, 0xdf, 0x9f, 0xd6, 0x7e, 0x3a, 0xdd, 0xdd, 0x01,
	0xe0, 0x25, 0x0b, 0x04, 0x6d, 0x62, 0x41, 0xba, 0xb3, 0x52, 0xec, 0xfe, 0xb5, 0x04, 0xca, 0x08,
	0xbf, 0x12, 0xad, 0x24, 0x8a, 0x70, 0xec, 0xc1, 0xaf, 0x40, 0x6d, 0xf4, 0xa5, 0xa3, 0x99, 0xae,
	0xf5, 0x6f, 0x6f, 0x86, 0x72, 0xe8, 0xf1, 0x3d, 0xa1, 0x9c, 0xb0, 0x20, 0x15, 0x09, 0xd3, 0x05,
	0x57, 0x73, 0x0c, 0xed, 0x00, 0xdb, 0xe0, 0x81, 0xa0, 0x5c, 0x04, 0xb1, 0xef, 0x76, 0xb2, 0xbb,
	0x8c, 0xf4, 0x63, 0xe9, 0xd6, 0xf7, 0xab, 0xbc, 0x73, 0xae, 0x45, 0x1b, 0x3a, 0x7a, 0xd2, 0x08,
	0xff, 0x0f, 0xaa, 0x11, 0xbe, 0xd4, 0x82, 0x14, 0xc4, 0x1e, 0xbd, 0x94, 0x5a, 0x59, 0x40, 0x6b,
	0x11, 0xbe, 0x94, 0x7a, 0xf4, 0x45, 0x66, 0x84, 0x4f, 0x41, 0x65, 0x54, 0x93, 0x74, 0xd6, 0x5a,
	0x68, 0xcd, 0xc8, 0x2a, 0xc3, 0x74, 0x15, 0x6b, 0x79, 0x94, 0x34, 0xc2, 0x04, 0x6c, 0xb1, 0x11,
	0x5d, 0x5d, 0x7a, 0x8e, 0x43, 0x97, 0x49, 0xc2, 0xca, 0x95, 0x9d, 0x4d, 0xc0, 0xfb, 0xb8, 0x9e,
	0x13, 0x84, 0xcd, 0x7a, 0x43, 0x1d, 0x83, 0xf2, 0x45, 0x36, 0x3d, 0xd5, 0x32, 0xb9, 0xf7, 0xd3,
	0x02, 0x3e, 0x2b, 0xcb, 0x78, 0xde, 0x08, 0x5c, 0x8c, 0xce, 0xc7, 0x05, 0xd3, 0xa8, 0x2d, 0x2a,
	0x5e, 0xfc, 0x7c, 0xda, 0x7c, 0x74, 0xfd, 0x7b, 0x7d, 0xe1, 0x7a, 0x58, 0x37, 0xde, 0x0c, 0xeb,
	0xc6, 0xaf, 0xc3, 0xba, 0xf1, 0xdb, 0xb0, 0x6e, 0x7c, 0xf7, 0x47, 0x7d, 0xe1, 0xeb, 0xf2, 0x04,
	0x56, 0x67, 0x59, 0x7e, 0xc9, 0x1d, 0xfe, 0x1d, 0x00, 0x00, 0xff, 0xff, 0x53, 0x42, 0x27, 0xe1,
	0x11, 0x0b, 0x00, 0x00,
}
