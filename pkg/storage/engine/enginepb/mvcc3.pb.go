// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: storage/engine/enginepb/mvcc3.proto

package enginepb

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import hlc "github.com/cockroachdb/cockroach/pkg/util/hlc"

import github_com_cockroachdb_cockroach_pkg_util_uuid "github.com/cockroachdb/cockroach/pkg/util/uuid"

import bytes "bytes"

import encoding_binary "encoding/binary"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

// TxnMeta is the metadata of a Transaction record.
type TxnMeta struct {
	// id is a unique UUID value which identifies the transaction.
	// This field is always filled in.
	ID github_com_cockroachdb_cockroach_pkg_util_uuid.UUID `protobuf:"bytes,1,opt,name=id,proto3,customtype=github.com/cockroachdb/cockroach/pkg/util/uuid.UUID" json:"id"`
	// key is the key which anchors the transaction. This is typically
	// the first key read or written during the transaction and
	// determines which range in the cluster will hold the transaction
	// record.
	Key []byte `protobuf:"bytes,3,opt,name=key,proto3" json:"key,omitempty"`
	// Incremented on txn retry.
	Epoch TxnEpoch `protobuf:"varint,4,opt,name=epoch,proto3,casttype=TxnEpoch" json:"epoch,omitempty"`
	// The proposed timestamp for the transaction. This starts as the current wall
	// time on the txn coordinator, and is forwarded by the timestamp cache if the
	// txn attempts to write "beneath" another txn's writes.
	//
	// Writes within the txn are performed using the most up-to-date value of this
	// timestamp that is available. For example, suppose a txn starts at some
	// timestamp, writes a key/value, and has its timestamp forwarded while doing
	// so because a later version already exists at that key. As soon as the txn
	// coordinator learns of the updated timestamp, it will begin performing
	// writes at the updated timestamp. The coordinator may, however, continue
	// issuing writes at the original timestamp before it learns about the
	// forwarded timestamp. The process of resolving the intents when the txn
	// commits will bump any intents written at an older timestamp to the final
	// commit timestamp.
	//
	// Note that reads do not occur at this timestamp; they instead occur at
	// ReadTimestamp, which is tracked in the containing roachpb.Transaction.
	//
	// Writes used to be performed at the txn's read timestamp, which was
	// necessary to avoid lost update anomalies in snapshot isolation mode. We no
	// longer support snapshot isolation mode, and there are now several important
	// reasons that writes are performed at this timestamp instead of the txn's
	// original timestamp:
	//
	//    1. This timestamp is forwarded by the timestamp cache when this
	//       transaction attempts to write beneath a more recent read. Leaving the
	//       intent at the original timestamp would write beneath that read, which
	//       would violate an invariant that time-bound iterators rely on.
	//
	//       For example, consider a client that uses a time-bound iterator to
	//       poll for changes to a key. The client reads (ts5, ts10], sees no
	//       writes, and reports that no changes have occurred up to t10. Then a
	//       txn writes an intent at its original timestamp ts7. The txn's
	//       timestamp is forwarded to ts11 by the timestamp cache thanks to the
	//       client's read. Meanwhile, the client reads (ts10, ts15] and, again
	//       seeing no intents, reports that no changes have occurred to the key
	//       up to t15. Now the txn commits at ts11 and bumps the intent to ts11.
	//       But the client thinks it has seen all changes up to t15, and so never
	//       sees the intent! We avoid this problem by writing intents at the
	//       provisional commit timestamp insteadr. In this example, the intent
	//       would instead be written at ts11 and picked up by the client's next
	//       read from (ts10, ts15].
	//
	//    2. Unnecessary PushTxn roundtrips are avoided. If a transaction is
	//       forwarded from ts5 to ts10, the rest of its intents will be written
	//       at ts10. Reads at t < ts10 that encounter these intents can ignore
	//       them; if the intents had instead been left at ts5, these reads would
	//       have needed to send PushTxn requests just to find out that the txn
	//       had, in fact, been forwarded to a non-conflicting time.
	//
	//    3. Unnecessary intent rewriting is avoided. Writing at the original
	//       timestamp when this timestamp has been forwarded guarantees that the
	//       value will need to be rewritten at the forwarded timestamp if the
	//       transaction commits.
	//
	WriteTimestamp hlc.Timestamp `protobuf:"bytes,5,opt,name=write_timestamp,json=writeTimestamp,proto3" json:"write_timestamp"`
	// The timestamp that the transaction was assigned by its gateway when it
	// began its first epoch. This is the earliest timestamp that the transaction
	// could have written any of its intents at.
	//
	// The timestamp is currently used in two places:
	// 1. by the transaction itself and by concurrent transactions when
	//    determining whether this transaction's record can be initially
	//    written. The timestamp is compared against the transaction's
	//    corresponding timestamp cache entry to ensure that a
	//    finalized transaction can never commit, either after a replay
	//    or a transaction abort. See CanCreateTxnRecord.
	// 2. by intent resolution to efficiently scan for intents while
	//    using a time-bound iterator - i.e. there can be intents to
	//    resolve up to the timestamp that the txn started with.
	MinTimestamp hlc.Timestamp `protobuf:"bytes,9,opt,name=min_timestamp,json=minTimestamp,proto3" json:"min_timestamp"`
	// The transaction's priority, ratcheted on transaction pushes.
	Priority TxnPriority `protobuf:"varint,6,opt,name=priority,proto3,casttype=TxnPriority" json:"priority,omitempty"`
	// A zero-indexed sequence number which is increased on each request
	// sent as part of the transaction. When set in the header of a batch of
	// requests, the value will correspond to the sequence number of the
	// last request. Used to provide idempotency and to protect against
	// out-of-order application (by means of a transaction retry).
	Sequence TxnSeq `protobuf:"varint,7,opt,name=sequence,proto3,casttype=TxnSeq" json:"sequence,omitempty"`
}

func (m *TxnMeta) Reset()      { *m = TxnMeta{} }
func (*TxnMeta) ProtoMessage() {}
func (*TxnMeta) Descriptor() ([]byte, []int) {
	return fileDescriptor_mvcc3_0c66a9929b41cdeb, []int{0}
}
func (m *TxnMeta) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TxnMeta) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *TxnMeta) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TxnMeta.Merge(dst, src)
}
func (m *TxnMeta) XXX_Size() int {
	return m.Size()
}
func (m *TxnMeta) XXX_DiscardUnknown() {
	xxx_messageInfo_TxnMeta.DiscardUnknown(m)
}

var xxx_messageInfo_TxnMeta proto.InternalMessageInfo

// IgnoredSeqNumRange describes a range of ignored seqnums.
// The range is inclusive on both ends.
type IgnoredSeqNumRange struct {
	Start TxnSeq `protobuf:"varint,1,opt,name=start,proto3,casttype=TxnSeq" json:"start,omitempty"`
	End   TxnSeq `protobuf:"varint,2,opt,name=end,proto3,casttype=TxnSeq" json:"end,omitempty"`
}

func (m *IgnoredSeqNumRange) Reset()         { *m = IgnoredSeqNumRange{} }
func (m *IgnoredSeqNumRange) String() string { return proto.CompactTextString(m) }
func (*IgnoredSeqNumRange) ProtoMessage()    {}
func (*IgnoredSeqNumRange) Descriptor() ([]byte, []int) {
	return fileDescriptor_mvcc3_0c66a9929b41cdeb, []int{1}
}
func (m *IgnoredSeqNumRange) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IgnoredSeqNumRange) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *IgnoredSeqNumRange) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IgnoredSeqNumRange.Merge(dst, src)
}
func (m *IgnoredSeqNumRange) XXX_Size() int {
	return m.Size()
}
func (m *IgnoredSeqNumRange) XXX_DiscardUnknown() {
	xxx_messageInfo_IgnoredSeqNumRange.DiscardUnknown(m)
}

var xxx_messageInfo_IgnoredSeqNumRange proto.InternalMessageInfo

// MVCCStatsDelta is convertible to MVCCStats, but uses signed variable width
// encodings for most fields that make it more efficient to store negative
// values. This makes the encodings incompatible.
type MVCCStatsDelta struct {
	ContainsEstimates int64 `protobuf:"varint,14,opt,name=contains_estimates,json=containsEstimates,proto3" json:"contains_estimates,omitempty"`
	LastUpdateNanos   int64 `protobuf:"fixed64,1,opt,name=last_update_nanos,json=lastUpdateNanos,proto3" json:"last_update_nanos,omitempty"`
	IntentAge         int64 `protobuf:"fixed64,2,opt,name=intent_age,json=intentAge,proto3" json:"intent_age,omitempty"`
	GCBytesAge        int64 `protobuf:"fixed64,3,opt,name=gc_bytes_age,json=gcBytesAge,proto3" json:"gc_bytes_age,omitempty"`
	LiveBytes         int64 `protobuf:"zigzag64,4,opt,name=live_bytes,json=liveBytes,proto3" json:"live_bytes,omitempty"`
	LiveCount         int64 `protobuf:"zigzag64,5,opt,name=live_count,json=liveCount,proto3" json:"live_count,omitempty"`
	KeyBytes          int64 `protobuf:"zigzag64,6,opt,name=key_bytes,json=keyBytes,proto3" json:"key_bytes,omitempty"`
	KeyCount          int64 `protobuf:"zigzag64,7,opt,name=key_count,json=keyCount,proto3" json:"key_count,omitempty"`
	ValBytes          int64 `protobuf:"zigzag64,8,opt,name=val_bytes,json=valBytes,proto3" json:"val_bytes,omitempty"`
	ValCount          int64 `protobuf:"zigzag64,9,opt,name=val_count,json=valCount,proto3" json:"val_count,omitempty"`
	IntentBytes       int64 `protobuf:"zigzag64,10,opt,name=intent_bytes,json=intentBytes,proto3" json:"intent_bytes,omitempty"`
	IntentCount       int64 `protobuf:"zigzag64,11,opt,name=intent_count,json=intentCount,proto3" json:"intent_count,omitempty"`
	SysBytes          int64 `protobuf:"zigzag64,12,opt,name=sys_bytes,json=sysBytes,proto3" json:"sys_bytes,omitempty"`
	SysCount          int64 `protobuf:"zigzag64,13,opt,name=sys_count,json=sysCount,proto3" json:"sys_count,omitempty"`
}

func (m *MVCCStatsDelta) Reset()         { *m = MVCCStatsDelta{} }
func (m *MVCCStatsDelta) String() string { return proto.CompactTextString(m) }
func (*MVCCStatsDelta) ProtoMessage()    {}
func (*MVCCStatsDelta) Descriptor() ([]byte, []int) {
	return fileDescriptor_mvcc3_0c66a9929b41cdeb, []int{2}
}
func (m *MVCCStatsDelta) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MVCCStatsDelta) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *MVCCStatsDelta) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MVCCStatsDelta.Merge(dst, src)
}
func (m *MVCCStatsDelta) XXX_Size() int {
	return m.Size()
}
func (m *MVCCStatsDelta) XXX_DiscardUnknown() {
	xxx_messageInfo_MVCCStatsDelta.DiscardUnknown(m)
}

var xxx_messageInfo_MVCCStatsDelta proto.InternalMessageInfo

// MVCCPersistentStats is convertible to MVCCStats, but uses signed variable
// width encodings for most fields that make it efficient to store positive
// values but inefficient to store negative values. This makes the encodings
// incompatible.
type MVCCPersistentStats struct {
	ContainsEstimates int64 `protobuf:"varint,14,opt,name=contains_estimates,json=containsEstimates,proto3" json:"contains_estimates,omitempty"`
	LastUpdateNanos   int64 `protobuf:"fixed64,1,opt,name=last_update_nanos,json=lastUpdateNanos,proto3" json:"last_update_nanos,omitempty"`
	IntentAge         int64 `protobuf:"fixed64,2,opt,name=intent_age,json=intentAge,proto3" json:"intent_age,omitempty"`
	GCBytesAge        int64 `protobuf:"fixed64,3,opt,name=gc_bytes_age,json=gcBytesAge,proto3" json:"gc_bytes_age,omitempty"`
	LiveBytes         int64 `protobuf:"varint,4,opt,name=live_bytes,json=liveBytes,proto3" json:"live_bytes,omitempty"`
	LiveCount         int64 `protobuf:"varint,5,opt,name=live_count,json=liveCount,proto3" json:"live_count,omitempty"`
	KeyBytes          int64 `protobuf:"varint,6,opt,name=key_bytes,json=keyBytes,proto3" json:"key_bytes,omitempty"`
	KeyCount          int64 `protobuf:"varint,7,opt,name=key_count,json=keyCount,proto3" json:"key_count,omitempty"`
	ValBytes          int64 `protobuf:"varint,8,opt,name=val_bytes,json=valBytes,proto3" json:"val_bytes,omitempty"`
	ValCount          int64 `protobuf:"varint,9,opt,name=val_count,json=valCount,proto3" json:"val_count,omitempty"`
	IntentBytes       int64 `protobuf:"varint,10,opt,name=intent_bytes,json=intentBytes,proto3" json:"intent_bytes,omitempty"`
	IntentCount       int64 `protobuf:"varint,11,opt,name=intent_count,json=intentCount,proto3" json:"intent_count,omitempty"`
	SysBytes          int64 `protobuf:"varint,12,opt,name=sys_bytes,json=sysBytes,proto3" json:"sys_bytes,omitempty"`
	SysCount          int64 `protobuf:"varint,13,opt,name=sys_count,json=sysCount,proto3" json:"sys_count,omitempty"`
}

func (m *MVCCPersistentStats) Reset()         { *m = MVCCPersistentStats{} }
func (m *MVCCPersistentStats) String() string { return proto.CompactTextString(m) }
func (*MVCCPersistentStats) ProtoMessage()    {}
func (*MVCCPersistentStats) Descriptor() ([]byte, []int) {
	return fileDescriptor_mvcc3_0c66a9929b41cdeb, []int{3}
}
func (m *MVCCPersistentStats) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MVCCPersistentStats) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *MVCCPersistentStats) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MVCCPersistentStats.Merge(dst, src)
}
func (m *MVCCPersistentStats) XXX_Size() int {
	return m.Size()
}
func (m *MVCCPersistentStats) XXX_DiscardUnknown() {
	xxx_messageInfo_MVCCPersistentStats.DiscardUnknown(m)
}

var xxx_messageInfo_MVCCPersistentStats proto.InternalMessageInfo

// RangeAppliedState combines the raft and lease applied indices with
// mvcc stats. These are all persisted on each transition of the Raft
// state machine (i.e. on each Raft application), so they are stored
// in the same RocksDB key for efficiency.
type RangeAppliedState struct {
	// raft_applied_index is the highest (and last) index applied to the Raft
	// state machine.
	RaftAppliedIndex uint64 `protobuf:"varint,1,opt,name=raft_applied_index,json=raftAppliedIndex,proto3" json:"raft_applied_index,omitempty"`
	// lease_applied_index is the highest (and last) lease index applied to the
	// Raft state machine.
	LeaseAppliedIndex uint64 `protobuf:"varint,2,opt,name=lease_applied_index,json=leaseAppliedIndex,proto3" json:"lease_applied_index,omitempty"`
	// range_stats is the set of mvcc stats that accounts for the current value
	// of the Raft state machine.
	RangeStats MVCCPersistentStats `protobuf:"bytes,3,opt,name=range_stats,json=rangeStats,proto3" json:"range_stats"`
}

func (m *RangeAppliedState) Reset()         { *m = RangeAppliedState{} }
func (m *RangeAppliedState) String() string { return proto.CompactTextString(m) }
func (*RangeAppliedState) ProtoMessage()    {}
func (*RangeAppliedState) Descriptor() ([]byte, []int) {
	return fileDescriptor_mvcc3_0c66a9929b41cdeb, []int{4}
}
func (m *RangeAppliedState) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RangeAppliedState) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *RangeAppliedState) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RangeAppliedState.Merge(dst, src)
}
func (m *RangeAppliedState) XXX_Size() int {
	return m.Size()
}
func (m *RangeAppliedState) XXX_DiscardUnknown() {
	xxx_messageInfo_RangeAppliedState.DiscardUnknown(m)
}

var xxx_messageInfo_RangeAppliedState proto.InternalMessageInfo

// MVCCWriteValueOp corresponds to a value being written outside of a
// transaction.
type MVCCWriteValueOp struct {
	Key       []byte        `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
	Timestamp hlc.Timestamp `protobuf:"bytes,2,opt,name=timestamp,proto3" json:"timestamp"`
	Value     []byte        `protobuf:"bytes,3,opt,name=value,proto3" json:"value,omitempty"`
	PrevValue []byte        `protobuf:"bytes,4,opt,name=prev_value,json=prevValue,proto3" json:"prev_value,omitempty"`
}

func (m *MVCCWriteValueOp) Reset()         { *m = MVCCWriteValueOp{} }
func (m *MVCCWriteValueOp) String() string { return proto.CompactTextString(m) }
func (*MVCCWriteValueOp) ProtoMessage()    {}
func (*MVCCWriteValueOp) Descriptor() ([]byte, []int) {
	return fileDescriptor_mvcc3_0c66a9929b41cdeb, []int{5}
}
func (m *MVCCWriteValueOp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MVCCWriteValueOp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *MVCCWriteValueOp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MVCCWriteValueOp.Merge(dst, src)
}
func (m *MVCCWriteValueOp) XXX_Size() int {
	return m.Size()
}
func (m *MVCCWriteValueOp) XXX_DiscardUnknown() {
	xxx_messageInfo_MVCCWriteValueOp.DiscardUnknown(m)
}

var xxx_messageInfo_MVCCWriteValueOp proto.InternalMessageInfo

// MVCCUpdateIntentOp corresponds to an intent being written for a given
// transaction.
type MVCCWriteIntentOp struct {
	TxnID           github_com_cockroachdb_cockroach_pkg_util_uuid.UUID `protobuf:"bytes,1,opt,name=txn_id,json=txnId,proto3,customtype=github.com/cockroachdb/cockroach/pkg/util/uuid.UUID" json:"txn_id"`
	TxnKey          []byte                                              `protobuf:"bytes,2,opt,name=txn_key,json=txnKey,proto3" json:"txn_key,omitempty"`
	TxnMinTimestamp hlc.Timestamp                                       `protobuf:"bytes,4,opt,name=txn_min_timestamp,json=txnMinTimestamp,proto3" json:"txn_min_timestamp"`
	Timestamp       hlc.Timestamp                                       `protobuf:"bytes,3,opt,name=timestamp,proto3" json:"timestamp"`
}

func (m *MVCCWriteIntentOp) Reset()         { *m = MVCCWriteIntentOp{} }
func (m *MVCCWriteIntentOp) String() string { return proto.CompactTextString(m) }
func (*MVCCWriteIntentOp) ProtoMessage()    {}
func (*MVCCWriteIntentOp) Descriptor() ([]byte, []int) {
	return fileDescriptor_mvcc3_0c66a9929b41cdeb, []int{6}
}
func (m *MVCCWriteIntentOp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MVCCWriteIntentOp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *MVCCWriteIntentOp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MVCCWriteIntentOp.Merge(dst, src)
}
func (m *MVCCWriteIntentOp) XXX_Size() int {
	return m.Size()
}
func (m *MVCCWriteIntentOp) XXX_DiscardUnknown() {
	xxx_messageInfo_MVCCWriteIntentOp.DiscardUnknown(m)
}

var xxx_messageInfo_MVCCWriteIntentOp proto.InternalMessageInfo

// MVCCUpdateIntentOp corresponds to an intent being updates at a larger
// timestamp for a given transaction.
type MVCCUpdateIntentOp struct {
	TxnID     github_com_cockroachdb_cockroach_pkg_util_uuid.UUID `protobuf:"bytes,1,opt,name=txn_id,json=txnId,proto3,customtype=github.com/cockroachdb/cockroach/pkg/util/uuid.UUID" json:"txn_id"`
	Timestamp hlc.Timestamp                                       `protobuf:"bytes,2,opt,name=timestamp,proto3" json:"timestamp"`
}

func (m *MVCCUpdateIntentOp) Reset()         { *m = MVCCUpdateIntentOp{} }
func (m *MVCCUpdateIntentOp) String() string { return proto.CompactTextString(m) }
func (*MVCCUpdateIntentOp) ProtoMessage()    {}
func (*MVCCUpdateIntentOp) Descriptor() ([]byte, []int) {
	return fileDescriptor_mvcc3_0c66a9929b41cdeb, []int{7}
}
func (m *MVCCUpdateIntentOp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MVCCUpdateIntentOp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *MVCCUpdateIntentOp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MVCCUpdateIntentOp.Merge(dst, src)
}
func (m *MVCCUpdateIntentOp) XXX_Size() int {
	return m.Size()
}
func (m *MVCCUpdateIntentOp) XXX_DiscardUnknown() {
	xxx_messageInfo_MVCCUpdateIntentOp.DiscardUnknown(m)
}

var xxx_messageInfo_MVCCUpdateIntentOp proto.InternalMessageInfo

// MVCCCommitIntentOp corresponds to an intent being committed for a given
// transaction.
type MVCCCommitIntentOp struct {
	TxnID     github_com_cockroachdb_cockroach_pkg_util_uuid.UUID `protobuf:"bytes,1,opt,name=txn_id,json=txnId,proto3,customtype=github.com/cockroachdb/cockroach/pkg/util/uuid.UUID" json:"txn_id"`
	Key       []byte                                              `protobuf:"bytes,2,opt,name=key,proto3" json:"key,omitempty"`
	Timestamp hlc.Timestamp                                       `protobuf:"bytes,3,opt,name=timestamp,proto3" json:"timestamp"`
	Value     []byte                                              `protobuf:"bytes,4,opt,name=value,proto3" json:"value,omitempty"`
	PrevValue []byte                                              `protobuf:"bytes,5,opt,name=prev_value,json=prevValue,proto3" json:"prev_value,omitempty"`
}

func (m *MVCCCommitIntentOp) Reset()         { *m = MVCCCommitIntentOp{} }
func (m *MVCCCommitIntentOp) String() string { return proto.CompactTextString(m) }
func (*MVCCCommitIntentOp) ProtoMessage()    {}
func (*MVCCCommitIntentOp) Descriptor() ([]byte, []int) {
	return fileDescriptor_mvcc3_0c66a9929b41cdeb, []int{8}
}
func (m *MVCCCommitIntentOp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MVCCCommitIntentOp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *MVCCCommitIntentOp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MVCCCommitIntentOp.Merge(dst, src)
}
func (m *MVCCCommitIntentOp) XXX_Size() int {
	return m.Size()
}
func (m *MVCCCommitIntentOp) XXX_DiscardUnknown() {
	xxx_messageInfo_MVCCCommitIntentOp.DiscardUnknown(m)
}

var xxx_messageInfo_MVCCCommitIntentOp proto.InternalMessageInfo

// MVCCAbortIntentOp corresponds to an intent being aborted for a given
// transaction.
//
// This operation does not necessarily indicate that the intent's transaction
// was aborted, just that an intent was removed without being committed. For
// instance, a committed transaction will abort any intents it decided not to
// write in its final epoch.
type MVCCAbortIntentOp struct {
	TxnID github_com_cockroachdb_cockroach_pkg_util_uuid.UUID `protobuf:"bytes,1,opt,name=txn_id,json=txnId,proto3,customtype=github.com/cockroachdb/cockroach/pkg/util/uuid.UUID" json:"txn_id"`
}

func (m *MVCCAbortIntentOp) Reset()         { *m = MVCCAbortIntentOp{} }
func (m *MVCCAbortIntentOp) String() string { return proto.CompactTextString(m) }
func (*MVCCAbortIntentOp) ProtoMessage()    {}
func (*MVCCAbortIntentOp) Descriptor() ([]byte, []int) {
	return fileDescriptor_mvcc3_0c66a9929b41cdeb, []int{9}
}
func (m *MVCCAbortIntentOp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MVCCAbortIntentOp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *MVCCAbortIntentOp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MVCCAbortIntentOp.Merge(dst, src)
}
func (m *MVCCAbortIntentOp) XXX_Size() int {
	return m.Size()
}
func (m *MVCCAbortIntentOp) XXX_DiscardUnknown() {
	xxx_messageInfo_MVCCAbortIntentOp.DiscardUnknown(m)
}

var xxx_messageInfo_MVCCAbortIntentOp proto.InternalMessageInfo

// MVCCAbortTxnOp corresponds to an entire transaction being aborted. The
// operation indicates that none of the transaction's intents will ever be
// committed.
type MVCCAbortTxnOp struct {
	TxnID github_com_cockroachdb_cockroach_pkg_util_uuid.UUID `protobuf:"bytes,1,opt,name=txn_id,json=txnId,proto3,customtype=github.com/cockroachdb/cockroach/pkg/util/uuid.UUID" json:"txn_id"`
}

func (m *MVCCAbortTxnOp) Reset()         { *m = MVCCAbortTxnOp{} }
func (m *MVCCAbortTxnOp) String() string { return proto.CompactTextString(m) }
func (*MVCCAbortTxnOp) ProtoMessage()    {}
func (*MVCCAbortTxnOp) Descriptor() ([]byte, []int) {
	return fileDescriptor_mvcc3_0c66a9929b41cdeb, []int{10}
}
func (m *MVCCAbortTxnOp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MVCCAbortTxnOp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *MVCCAbortTxnOp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MVCCAbortTxnOp.Merge(dst, src)
}
func (m *MVCCAbortTxnOp) XXX_Size() int {
	return m.Size()
}
func (m *MVCCAbortTxnOp) XXX_DiscardUnknown() {
	xxx_messageInfo_MVCCAbortTxnOp.DiscardUnknown(m)
}

var xxx_messageInfo_MVCCAbortTxnOp proto.InternalMessageInfo

// MVCCLogicalOp is a union of all logical MVCC operation types.
type MVCCLogicalOp struct {
	WriteValue   *MVCCWriteValueOp   `protobuf:"bytes,1,opt,name=write_value,json=writeValue,proto3" json:"write_value,omitempty"`
	WriteIntent  *MVCCWriteIntentOp  `protobuf:"bytes,2,opt,name=write_intent,json=writeIntent,proto3" json:"write_intent,omitempty"`
	UpdateIntent *MVCCUpdateIntentOp `protobuf:"bytes,3,opt,name=update_intent,json=updateIntent,proto3" json:"update_intent,omitempty"`
	CommitIntent *MVCCCommitIntentOp `protobuf:"bytes,4,opt,name=commit_intent,json=commitIntent,proto3" json:"commit_intent,omitempty"`
	AbortIntent  *MVCCAbortIntentOp  `protobuf:"bytes,5,opt,name=abort_intent,json=abortIntent,proto3" json:"abort_intent,omitempty"`
	AbortTxn     *MVCCAbortTxnOp     `protobuf:"bytes,6,opt,name=abort_txn,json=abortTxn,proto3" json:"abort_txn,omitempty"`
}

func (m *MVCCLogicalOp) Reset()         { *m = MVCCLogicalOp{} }
func (m *MVCCLogicalOp) String() string { return proto.CompactTextString(m) }
func (*MVCCLogicalOp) ProtoMessage()    {}
func (*MVCCLogicalOp) Descriptor() ([]byte, []int) {
	return fileDescriptor_mvcc3_0c66a9929b41cdeb, []int{11}
}
func (m *MVCCLogicalOp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MVCCLogicalOp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *MVCCLogicalOp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MVCCLogicalOp.Merge(dst, src)
}
func (m *MVCCLogicalOp) XXX_Size() int {
	return m.Size()
}
func (m *MVCCLogicalOp) XXX_DiscardUnknown() {
	xxx_messageInfo_MVCCLogicalOp.DiscardUnknown(m)
}

var xxx_messageInfo_MVCCLogicalOp proto.InternalMessageInfo

func init() {
	proto.RegisterType((*TxnMeta)(nil), "cockroach.storage.engine.enginepb.TxnMeta")
	proto.RegisterType((*IgnoredSeqNumRange)(nil), "cockroach.storage.engine.enginepb.IgnoredSeqNumRange")
	proto.RegisterType((*MVCCStatsDelta)(nil), "cockroach.storage.engine.enginepb.MVCCStatsDelta")
	proto.RegisterType((*MVCCPersistentStats)(nil), "cockroach.storage.engine.enginepb.MVCCPersistentStats")
	proto.RegisterType((*RangeAppliedState)(nil), "cockroach.storage.engine.enginepb.RangeAppliedState")
	proto.RegisterType((*MVCCWriteValueOp)(nil), "cockroach.storage.engine.enginepb.MVCCWriteValueOp")
	proto.RegisterType((*MVCCWriteIntentOp)(nil), "cockroach.storage.engine.enginepb.MVCCWriteIntentOp")
	proto.RegisterType((*MVCCUpdateIntentOp)(nil), "cockroach.storage.engine.enginepb.MVCCUpdateIntentOp")
	proto.RegisterType((*MVCCCommitIntentOp)(nil), "cockroach.storage.engine.enginepb.MVCCCommitIntentOp")
	proto.RegisterType((*MVCCAbortIntentOp)(nil), "cockroach.storage.engine.enginepb.MVCCAbortIntentOp")
	proto.RegisterType((*MVCCAbortTxnOp)(nil), "cockroach.storage.engine.enginepb.MVCCAbortTxnOp")
	proto.RegisterType((*MVCCLogicalOp)(nil), "cockroach.storage.engine.enginepb.MVCCLogicalOp")
}
func (this *TxnMeta) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TxnMeta)
	if !ok {
		that2, ok := that.(TxnMeta)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.ID.Equal(that1.ID) {
		return false
	}
	if !bytes.Equal(this.Key, that1.Key) {
		return false
	}
	if this.Epoch != that1.Epoch {
		return false
	}
	if !this.WriteTimestamp.Equal(&that1.WriteTimestamp) {
		return false
	}
	if !this.MinTimestamp.Equal(&that1.MinTimestamp) {
		return false
	}
	if this.Priority != that1.Priority {
		return false
	}
	if this.Sequence != that1.Sequence {
		return false
	}
	return true
}
func (this *IgnoredSeqNumRange) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*IgnoredSeqNumRange)
	if !ok {
		that2, ok := that.(IgnoredSeqNumRange)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Start != that1.Start {
		return false
	}
	if this.End != that1.End {
		return false
	}
	return true
}
func (this *MVCCStatsDelta) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*MVCCStatsDelta)
	if !ok {
		that2, ok := that.(MVCCStatsDelta)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ContainsEstimates != that1.ContainsEstimates {
		return false
	}
	if this.LastUpdateNanos != that1.LastUpdateNanos {
		return false
	}
	if this.IntentAge != that1.IntentAge {
		return false
	}
	if this.GCBytesAge != that1.GCBytesAge {
		return false
	}
	if this.LiveBytes != that1.LiveBytes {
		return false
	}
	if this.LiveCount != that1.LiveCount {
		return false
	}
	if this.KeyBytes != that1.KeyBytes {
		return false
	}
	if this.KeyCount != that1.KeyCount {
		return false
	}
	if this.ValBytes != that1.ValBytes {
		return false
	}
	if this.ValCount != that1.ValCount {
		return false
	}
	if this.IntentBytes != that1.IntentBytes {
		return false
	}
	if this.IntentCount != that1.IntentCount {
		return false
	}
	if this.SysBytes != that1.SysBytes {
		return false
	}
	if this.SysCount != that1.SysCount {
		return false
	}
	return true
}
func (this *MVCCPersistentStats) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*MVCCPersistentStats)
	if !ok {
		that2, ok := that.(MVCCPersistentStats)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ContainsEstimates != that1.ContainsEstimates {
		return false
	}
	if this.LastUpdateNanos != that1.LastUpdateNanos {
		return false
	}
	if this.IntentAge != that1.IntentAge {
		return false
	}
	if this.GCBytesAge != that1.GCBytesAge {
		return false
	}
	if this.LiveBytes != that1.LiveBytes {
		return false
	}
	if this.LiveCount != that1.LiveCount {
		return false
	}
	if this.KeyBytes != that1.KeyBytes {
		return false
	}
	if this.KeyCount != that1.KeyCount {
		return false
	}
	if this.ValBytes != that1.ValBytes {
		return false
	}
	if this.ValCount != that1.ValCount {
		return false
	}
	if this.IntentBytes != that1.IntentBytes {
		return false
	}
	if this.IntentCount != that1.IntentCount {
		return false
	}
	if this.SysBytes != that1.SysBytes {
		return false
	}
	if this.SysCount != that1.SysCount {
		return false
	}
	return true
}
func (this *RangeAppliedState) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RangeAppliedState)
	if !ok {
		that2, ok := that.(RangeAppliedState)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.RaftAppliedIndex != that1.RaftAppliedIndex {
		return false
	}
	if this.LeaseAppliedIndex != that1.LeaseAppliedIndex {
		return false
	}
	if !this.RangeStats.Equal(&that1.RangeStats) {
		return false
	}
	return true
}
func (m *TxnMeta) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TxnMeta) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintMvcc3(dAtA, i, uint64(m.ID.Size()))
	n1, err := m.ID.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n1
	if len(m.Key) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintMvcc3(dAtA, i, uint64(len(m.Key)))
		i += copy(dAtA[i:], m.Key)
	}
	if m.Epoch != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintMvcc3(dAtA, i, uint64(m.Epoch))
	}
	dAtA[i] = 0x2a
	i++
	i = encodeVarintMvcc3(dAtA, i, uint64(m.WriteTimestamp.Size()))
	n2, err := m.WriteTimestamp.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n2
	if m.Priority != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintMvcc3(dAtA, i, uint64(m.Priority))
	}
	if m.Sequence != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintMvcc3(dAtA, i, uint64(m.Sequence))
	}
	dAtA[i] = 0x4a
	i++
	i = encodeVarintMvcc3(dAtA, i, uint64(m.MinTimestamp.Size()))
	n3, err := m.MinTimestamp.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n3
	return i, nil
}

func (m *IgnoredSeqNumRange) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IgnoredSeqNumRange) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Start != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMvcc3(dAtA, i, uint64(m.Start))
	}
	if m.End != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintMvcc3(dAtA, i, uint64(m.End))
	}
	return i, nil
}

func (m *MVCCStatsDelta) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MVCCStatsDelta) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.LastUpdateNanos != 0 {
		dAtA[i] = 0x9
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.LastUpdateNanos))
		i += 8
	}
	if m.IntentAge != 0 {
		dAtA[i] = 0x11
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.IntentAge))
		i += 8
	}
	if m.GCBytesAge != 0 {
		dAtA[i] = 0x19
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.GCBytesAge))
		i += 8
	}
	if m.LiveBytes != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintMvcc3(dAtA, i, uint64((uint64(m.LiveBytes)<<1)^uint64((m.LiveBytes>>63))))
	}
	if m.LiveCount != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintMvcc3(dAtA, i, uint64((uint64(m.LiveCount)<<1)^uint64((m.LiveCount>>63))))
	}
	if m.KeyBytes != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintMvcc3(dAtA, i, uint64((uint64(m.KeyBytes)<<1)^uint64((m.KeyBytes>>63))))
	}
	if m.KeyCount != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintMvcc3(dAtA, i, uint64((uint64(m.KeyCount)<<1)^uint64((m.KeyCount>>63))))
	}
	if m.ValBytes != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintMvcc3(dAtA, i, uint64((uint64(m.ValBytes)<<1)^uint64((m.ValBytes>>63))))
	}
	if m.ValCount != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintMvcc3(dAtA, i, uint64((uint64(m.ValCount)<<1)^uint64((m.ValCount>>63))))
	}
	if m.IntentBytes != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintMvcc3(dAtA, i, uint64((uint64(m.IntentBytes)<<1)^uint64((m.IntentBytes>>63))))
	}
	if m.IntentCount != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintMvcc3(dAtA, i, uint64((uint64(m.IntentCount)<<1)^uint64((m.IntentCount>>63))))
	}
	if m.SysBytes != 0 {
		dAtA[i] = 0x60
		i++
		i = encodeVarintMvcc3(dAtA, i, uint64((uint64(m.SysBytes)<<1)^uint64((m.SysBytes>>63))))
	}
	if m.SysCount != 0 {
		dAtA[i] = 0x68
		i++
		i = encodeVarintMvcc3(dAtA, i, uint64((uint64(m.SysCount)<<1)^uint64((m.SysCount>>63))))
	}
	if m.ContainsEstimates != 0 {
		dAtA[i] = 0x70
		i++
		i = encodeVarintMvcc3(dAtA, i, uint64(m.ContainsEstimates))
	}
	return i, nil
}

func (m *MVCCPersistentStats) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MVCCPersistentStats) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.LastUpdateNanos != 0 {
		dAtA[i] = 0x9
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.LastUpdateNanos))
		i += 8
	}
	if m.IntentAge != 0 {
		dAtA[i] = 0x11
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.IntentAge))
		i += 8
	}
	if m.GCBytesAge != 0 {
		dAtA[i] = 0x19
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.GCBytesAge))
		i += 8
	}
	if m.LiveBytes != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintMvcc3(dAtA, i, uint64(m.LiveBytes))
	}
	if m.LiveCount != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintMvcc3(dAtA, i, uint64(m.LiveCount))
	}
	if m.KeyBytes != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintMvcc3(dAtA, i, uint64(m.KeyBytes))
	}
	if m.KeyCount != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintMvcc3(dAtA, i, uint64(m.KeyCount))
	}
	if m.ValBytes != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintMvcc3(dAtA, i, uint64(m.ValBytes))
	}
	if m.ValCount != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintMvcc3(dAtA, i, uint64(m.ValCount))
	}
	if m.IntentBytes != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintMvcc3(dAtA, i, uint64(m.IntentBytes))
	}
	if m.IntentCount != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintMvcc3(dAtA, i, uint64(m.IntentCount))
	}
	if m.SysBytes != 0 {
		dAtA[i] = 0x60
		i++
		i = encodeVarintMvcc3(dAtA, i, uint64(m.SysBytes))
	}
	if m.SysCount != 0 {
		dAtA[i] = 0x68
		i++
		i = encodeVarintMvcc3(dAtA, i, uint64(m.SysCount))
	}
	if m.ContainsEstimates != 0 {
		dAtA[i] = 0x70
		i++
		i = encodeVarintMvcc3(dAtA, i, uint64(m.ContainsEstimates))
	}
	return i, nil
}

func (m *RangeAppliedState) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RangeAppliedState) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.RaftAppliedIndex != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMvcc3(dAtA, i, uint64(m.RaftAppliedIndex))
	}
	if m.LeaseAppliedIndex != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintMvcc3(dAtA, i, uint64(m.LeaseAppliedIndex))
	}
	dAtA[i] = 0x1a
	i++
	i = encodeVarintMvcc3(dAtA, i, uint64(m.RangeStats.Size()))
	n4, err := m.RangeStats.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n4
	return i, nil
}

func (m *MVCCWriteValueOp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MVCCWriteValueOp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Key) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMvcc3(dAtA, i, uint64(len(m.Key)))
		i += copy(dAtA[i:], m.Key)
	}
	dAtA[i] = 0x12
	i++
	i = encodeVarintMvcc3(dAtA, i, uint64(m.Timestamp.Size()))
	n5, err := m.Timestamp.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n5
	if len(m.Value) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintMvcc3(dAtA, i, uint64(len(m.Value)))
		i += copy(dAtA[i:], m.Value)
	}
	if len(m.PrevValue) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintMvcc3(dAtA, i, uint64(len(m.PrevValue)))
		i += copy(dAtA[i:], m.PrevValue)
	}
	return i, nil
}

func (m *MVCCWriteIntentOp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MVCCWriteIntentOp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintMvcc3(dAtA, i, uint64(m.TxnID.Size()))
	n6, err := m.TxnID.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n6
	if len(m.TxnKey) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMvcc3(dAtA, i, uint64(len(m.TxnKey)))
		i += copy(dAtA[i:], m.TxnKey)
	}
	dAtA[i] = 0x1a
	i++
	i = encodeVarintMvcc3(dAtA, i, uint64(m.Timestamp.Size()))
	n7, err := m.Timestamp.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n7
	dAtA[i] = 0x22
	i++
	i = encodeVarintMvcc3(dAtA, i, uint64(m.TxnMinTimestamp.Size()))
	n8, err := m.TxnMinTimestamp.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n8
	return i, nil
}

func (m *MVCCUpdateIntentOp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MVCCUpdateIntentOp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintMvcc3(dAtA, i, uint64(m.TxnID.Size()))
	n9, err := m.TxnID.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n9
	dAtA[i] = 0x12
	i++
	i = encodeVarintMvcc3(dAtA, i, uint64(m.Timestamp.Size()))
	n10, err := m.Timestamp.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n10
	return i, nil
}

func (m *MVCCCommitIntentOp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MVCCCommitIntentOp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintMvcc3(dAtA, i, uint64(m.TxnID.Size()))
	n11, err := m.TxnID.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n11
	if len(m.Key) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMvcc3(dAtA, i, uint64(len(m.Key)))
		i += copy(dAtA[i:], m.Key)
	}
	dAtA[i] = 0x1a
	i++
	i = encodeVarintMvcc3(dAtA, i, uint64(m.Timestamp.Size()))
	n12, err := m.Timestamp.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n12
	if len(m.Value) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintMvcc3(dAtA, i, uint64(len(m.Value)))
		i += copy(dAtA[i:], m.Value)
	}
	if len(m.PrevValue) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintMvcc3(dAtA, i, uint64(len(m.PrevValue)))
		i += copy(dAtA[i:], m.PrevValue)
	}
	return i, nil
}

func (m *MVCCAbortIntentOp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MVCCAbortIntentOp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintMvcc3(dAtA, i, uint64(m.TxnID.Size()))
	n13, err := m.TxnID.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n13
	return i, nil
}

func (m *MVCCAbortTxnOp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MVCCAbortTxnOp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintMvcc3(dAtA, i, uint64(m.TxnID.Size()))
	n14, err := m.TxnID.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n14
	return i, nil
}

func (m *MVCCLogicalOp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MVCCLogicalOp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.WriteValue != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMvcc3(dAtA, i, uint64(m.WriteValue.Size()))
		n15, err := m.WriteValue.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n15
	}
	if m.WriteIntent != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMvcc3(dAtA, i, uint64(m.WriteIntent.Size()))
		n16, err := m.WriteIntent.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n16
	}
	if m.UpdateIntent != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintMvcc3(dAtA, i, uint64(m.UpdateIntent.Size()))
		n17, err := m.UpdateIntent.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n17
	}
	if m.CommitIntent != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintMvcc3(dAtA, i, uint64(m.CommitIntent.Size()))
		n18, err := m.CommitIntent.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n18
	}
	if m.AbortIntent != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintMvcc3(dAtA, i, uint64(m.AbortIntent.Size()))
		n19, err := m.AbortIntent.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n19
	}
	if m.AbortTxn != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintMvcc3(dAtA, i, uint64(m.AbortTxn.Size()))
		n20, err := m.AbortTxn.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n20
	}
	return i, nil
}

func encodeVarintMvcc3(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func NewPopulatedTxnMeta(r randyMvcc3, easy bool) *TxnMeta {
	this := &TxnMeta{}
	v1 := github_com_cockroachdb_cockroach_pkg_util_uuid.NewPopulatedUUID(r)
	this.ID = *v1
	v2 := r.Intn(100)
	this.Key = make([]byte, v2)
	for i := 0; i < v2; i++ {
		this.Key[i] = byte(r.Intn(256))
	}
	this.Epoch = TxnEpoch(r.Int31())
	if r.Intn(2) == 0 {
		this.Epoch *= -1
	}
	v3 := hlc.NewPopulatedTimestamp(r, easy)
	this.WriteTimestamp = *v3
	this.Priority = TxnPriority(r.Int31())
	if r.Intn(2) == 0 {
		this.Priority *= -1
	}
	this.Sequence = TxnSeq(r.Int31())
	if r.Intn(2) == 0 {
		this.Sequence *= -1
	}
	v4 := hlc.NewPopulatedTimestamp(r, easy)
	this.MinTimestamp = *v4
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedIgnoredSeqNumRange(r randyMvcc3, easy bool) *IgnoredSeqNumRange {
	this := &IgnoredSeqNumRange{}
	this.Start = TxnSeq(r.Int31())
	if r.Intn(2) == 0 {
		this.Start *= -1
	}
	this.End = TxnSeq(r.Int31())
	if r.Intn(2) == 0 {
		this.End *= -1
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedMVCCPersistentStats(r randyMvcc3, easy bool) *MVCCPersistentStats {
	this := &MVCCPersistentStats{}
	this.LastUpdateNanos = int64(r.Int63())
	if r.Intn(2) == 0 {
		this.LastUpdateNanos *= -1
	}
	this.IntentAge = int64(r.Int63())
	if r.Intn(2) == 0 {
		this.IntentAge *= -1
	}
	this.GCBytesAge = int64(r.Int63())
	if r.Intn(2) == 0 {
		this.GCBytesAge *= -1
	}
	this.LiveBytes = int64(r.Int63())
	if r.Intn(2) == 0 {
		this.LiveBytes *= -1
	}
	this.LiveCount = int64(r.Int63())
	if r.Intn(2) == 0 {
		this.LiveCount *= -1
	}
	this.KeyBytes = int64(r.Int63())
	if r.Intn(2) == 0 {
		this.KeyBytes *= -1
	}
	this.KeyCount = int64(r.Int63())
	if r.Intn(2) == 0 {
		this.KeyCount *= -1
	}
	this.ValBytes = int64(r.Int63())
	if r.Intn(2) == 0 {
		this.ValBytes *= -1
	}
	this.ValCount = int64(r.Int63())
	if r.Intn(2) == 0 {
		this.ValCount *= -1
	}
	this.IntentBytes = int64(r.Int63())
	if r.Intn(2) == 0 {
		this.IntentBytes *= -1
	}
	this.IntentCount = int64(r.Int63())
	if r.Intn(2) == 0 {
		this.IntentCount *= -1
	}
	this.SysBytes = int64(r.Int63())
	if r.Intn(2) == 0 {
		this.SysBytes *= -1
	}
	this.SysCount = int64(r.Int63())
	if r.Intn(2) == 0 {
		this.SysCount *= -1
	}
	this.ContainsEstimates = int64(r.Int63())
	if r.Intn(2) == 0 {
		this.ContainsEstimates *= -1
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedRangeAppliedState(r randyMvcc3, easy bool) *RangeAppliedState {
	this := &RangeAppliedState{}
	this.RaftAppliedIndex = uint64(uint64(r.Uint32()))
	this.LeaseAppliedIndex = uint64(uint64(r.Uint32()))
	v5 := NewPopulatedMVCCPersistentStats(r, easy)
	this.RangeStats = *v5
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

type randyMvcc3 interface {
	Float32() float32
	Float64() float64
	Int63() int64
	Int31() int32
	Uint32() uint32
	Intn(n int) int
}

func randUTF8RuneMvcc3(r randyMvcc3) rune {
	ru := r.Intn(62)
	if ru < 10 {
		return rune(ru + 48)
	} else if ru < 36 {
		return rune(ru + 55)
	}
	return rune(ru + 61)
}
func randStringMvcc3(r randyMvcc3) string {
	v6 := r.Intn(100)
	tmps := make([]rune, v6)
	for i := 0; i < v6; i++ {
		tmps[i] = randUTF8RuneMvcc3(r)
	}
	return string(tmps)
}
func randUnrecognizedMvcc3(r randyMvcc3, maxFieldNumber int) (dAtA []byte) {
	l := r.Intn(5)
	for i := 0; i < l; i++ {
		wire := r.Intn(4)
		if wire == 3 {
			wire = 5
		}
		fieldNumber := maxFieldNumber + r.Intn(100)
		dAtA = randFieldMvcc3(dAtA, r, fieldNumber, wire)
	}
	return dAtA
}
func randFieldMvcc3(dAtA []byte, r randyMvcc3, fieldNumber int, wire int) []byte {
	key := uint32(fieldNumber)<<3 | uint32(wire)
	switch wire {
	case 0:
		dAtA = encodeVarintPopulateMvcc3(dAtA, uint64(key))
		v7 := r.Int63()
		if r.Intn(2) == 0 {
			v7 *= -1
		}
		dAtA = encodeVarintPopulateMvcc3(dAtA, uint64(v7))
	case 1:
		dAtA = encodeVarintPopulateMvcc3(dAtA, uint64(key))
		dAtA = append(dAtA, byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)))
	case 2:
		dAtA = encodeVarintPopulateMvcc3(dAtA, uint64(key))
		ll := r.Intn(100)
		dAtA = encodeVarintPopulateMvcc3(dAtA, uint64(ll))
		for j := 0; j < ll; j++ {
			dAtA = append(dAtA, byte(r.Intn(256)))
		}
	default:
		dAtA = encodeVarintPopulateMvcc3(dAtA, uint64(key))
		dAtA = append(dAtA, byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)))
	}
	return dAtA
}
func encodeVarintPopulateMvcc3(dAtA []byte, v uint64) []byte {
	for v >= 1<<7 {
		dAtA = append(dAtA, uint8(uint64(v)&0x7f|0x80))
		v >>= 7
	}
	dAtA = append(dAtA, uint8(v))
	return dAtA
}
func (m *TxnMeta) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.ID.Size()
	n += 1 + l + sovMvcc3(uint64(l))
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovMvcc3(uint64(l))
	}
	if m.Epoch != 0 {
		n += 1 + sovMvcc3(uint64(m.Epoch))
	}
	l = m.WriteTimestamp.Size()
	n += 1 + l + sovMvcc3(uint64(l))
	if m.Priority != 0 {
		n += 1 + sovMvcc3(uint64(m.Priority))
	}
	if m.Sequence != 0 {
		n += 1 + sovMvcc3(uint64(m.Sequence))
	}
	l = m.MinTimestamp.Size()
	n += 1 + l + sovMvcc3(uint64(l))
	return n
}

func (m *IgnoredSeqNumRange) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Start != 0 {
		n += 1 + sovMvcc3(uint64(m.Start))
	}
	if m.End != 0 {
		n += 1 + sovMvcc3(uint64(m.End))
	}
	return n
}

func (m *MVCCStatsDelta) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.LastUpdateNanos != 0 {
		n += 9
	}
	if m.IntentAge != 0 {
		n += 9
	}
	if m.GCBytesAge != 0 {
		n += 9
	}
	if m.LiveBytes != 0 {
		n += 1 + sozMvcc3(uint64(m.LiveBytes))
	}
	if m.LiveCount != 0 {
		n += 1 + sozMvcc3(uint64(m.LiveCount))
	}
	if m.KeyBytes != 0 {
		n += 1 + sozMvcc3(uint64(m.KeyBytes))
	}
	if m.KeyCount != 0 {
		n += 1 + sozMvcc3(uint64(m.KeyCount))
	}
	if m.ValBytes != 0 {
		n += 1 + sozMvcc3(uint64(m.ValBytes))
	}
	if m.ValCount != 0 {
		n += 1 + sozMvcc3(uint64(m.ValCount))
	}
	if m.IntentBytes != 0 {
		n += 1 + sozMvcc3(uint64(m.IntentBytes))
	}
	if m.IntentCount != 0 {
		n += 1 + sozMvcc3(uint64(m.IntentCount))
	}
	if m.SysBytes != 0 {
		n += 1 + sozMvcc3(uint64(m.SysBytes))
	}
	if m.SysCount != 0 {
		n += 1 + sozMvcc3(uint64(m.SysCount))
	}
	if m.ContainsEstimates != 0 {
		n += 1 + sovMvcc3(uint64(m.ContainsEstimates))
	}
	return n
}

func (m *MVCCPersistentStats) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.LastUpdateNanos != 0 {
		n += 9
	}
	if m.IntentAge != 0 {
		n += 9
	}
	if m.GCBytesAge != 0 {
		n += 9
	}
	if m.LiveBytes != 0 {
		n += 1 + sovMvcc3(uint64(m.LiveBytes))
	}
	if m.LiveCount != 0 {
		n += 1 + sovMvcc3(uint64(m.LiveCount))
	}
	if m.KeyBytes != 0 {
		n += 1 + sovMvcc3(uint64(m.KeyBytes))
	}
	if m.KeyCount != 0 {
		n += 1 + sovMvcc3(uint64(m.KeyCount))
	}
	if m.ValBytes != 0 {
		n += 1 + sovMvcc3(uint64(m.ValBytes))
	}
	if m.ValCount != 0 {
		n += 1 + sovMvcc3(uint64(m.ValCount))
	}
	if m.IntentBytes != 0 {
		n += 1 + sovMvcc3(uint64(m.IntentBytes))
	}
	if m.IntentCount != 0 {
		n += 1 + sovMvcc3(uint64(m.IntentCount))
	}
	if m.SysBytes != 0 {
		n += 1 + sovMvcc3(uint64(m.SysBytes))
	}
	if m.SysCount != 0 {
		n += 1 + sovMvcc3(uint64(m.SysCount))
	}
	if m.ContainsEstimates != 0 {
		n += 1 + sovMvcc3(uint64(m.ContainsEstimates))
	}
	return n
}

func (m *RangeAppliedState) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RaftAppliedIndex != 0 {
		n += 1 + sovMvcc3(uint64(m.RaftAppliedIndex))
	}
	if m.LeaseAppliedIndex != 0 {
		n += 1 + sovMvcc3(uint64(m.LeaseAppliedIndex))
	}
	l = m.RangeStats.Size()
	n += 1 + l + sovMvcc3(uint64(l))
	return n
}

func (m *MVCCWriteValueOp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovMvcc3(uint64(l))
	}
	l = m.Timestamp.Size()
	n += 1 + l + sovMvcc3(uint64(l))
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovMvcc3(uint64(l))
	}
	l = len(m.PrevValue)
	if l > 0 {
		n += 1 + l + sovMvcc3(uint64(l))
	}
	return n
}

func (m *MVCCWriteIntentOp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.TxnID.Size()
	n += 1 + l + sovMvcc3(uint64(l))
	l = len(m.TxnKey)
	if l > 0 {
		n += 1 + l + sovMvcc3(uint64(l))
	}
	l = m.Timestamp.Size()
	n += 1 + l + sovMvcc3(uint64(l))
	l = m.TxnMinTimestamp.Size()
	n += 1 + l + sovMvcc3(uint64(l))
	return n
}

func (m *MVCCUpdateIntentOp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.TxnID.Size()
	n += 1 + l + sovMvcc3(uint64(l))
	l = m.Timestamp.Size()
	n += 1 + l + sovMvcc3(uint64(l))
	return n
}

func (m *MVCCCommitIntentOp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.TxnID.Size()
	n += 1 + l + sovMvcc3(uint64(l))
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovMvcc3(uint64(l))
	}
	l = m.Timestamp.Size()
	n += 1 + l + sovMvcc3(uint64(l))
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovMvcc3(uint64(l))
	}
	l = len(m.PrevValue)
	if l > 0 {
		n += 1 + l + sovMvcc3(uint64(l))
	}
	return n
}

func (m *MVCCAbortIntentOp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.TxnID.Size()
	n += 1 + l + sovMvcc3(uint64(l))
	return n
}

func (m *MVCCAbortTxnOp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.TxnID.Size()
	n += 1 + l + sovMvcc3(uint64(l))
	return n
}

func (m *MVCCLogicalOp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.WriteValue != nil {
		l = m.WriteValue.Size()
		n += 1 + l + sovMvcc3(uint64(l))
	}
	if m.WriteIntent != nil {
		l = m.WriteIntent.Size()
		n += 1 + l + sovMvcc3(uint64(l))
	}
	if m.UpdateIntent != nil {
		l = m.UpdateIntent.Size()
		n += 1 + l + sovMvcc3(uint64(l))
	}
	if m.CommitIntent != nil {
		l = m.CommitIntent.Size()
		n += 1 + l + sovMvcc3(uint64(l))
	}
	if m.AbortIntent != nil {
		l = m.AbortIntent.Size()
		n += 1 + l + sovMvcc3(uint64(l))
	}
	if m.AbortTxn != nil {
		l = m.AbortTxn.Size()
		n += 1 + l + sovMvcc3(uint64(l))
	}
	return n
}

func sovMvcc3(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozMvcc3(x uint64) (n int) {
	return sovMvcc3(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *MVCCLogicalOp) GetValue() interface{} {
	if this.WriteValue != nil {
		return this.WriteValue
	}
	if this.WriteIntent != nil {
		return this.WriteIntent
	}
	if this.UpdateIntent != nil {
		return this.UpdateIntent
	}
	if this.CommitIntent != nil {
		return this.CommitIntent
	}
	if this.AbortIntent != nil {
		return this.AbortIntent
	}
	if this.AbortTxn != nil {
		return this.AbortTxn
	}
	return nil
}

func (this *MVCCLogicalOp) SetValue(value interface{}) bool {
	switch vt := value.(type) {
	case *MVCCWriteValueOp:
		this.WriteValue = vt
	case *MVCCWriteIntentOp:
		this.WriteIntent = vt
	case *MVCCUpdateIntentOp:
		this.UpdateIntent = vt
	case *MVCCCommitIntentOp:
		this.CommitIntent = vt
	case *MVCCAbortIntentOp:
		this.AbortIntent = vt
	case *MVCCAbortTxnOp:
		this.AbortTxn = vt
	default:
		return false
	}
	return true
}
func (m *TxnMeta) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMvcc3
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TxnMeta: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TxnMeta: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMvcc3
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMvcc3
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ID.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMvcc3
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMvcc3
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = append(m.Key[:0], dAtA[iNdEx:postIndex]...)
			if m.Key == nil {
				m.Key = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Epoch", wireType)
			}
			m.Epoch = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMvcc3
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Epoch |= (TxnEpoch(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WriteTimestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMvcc3
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMvcc3
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.WriteTimestamp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Priority", wireType)
			}
			m.Priority = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMvcc3
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Priority |= (TxnPriority(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sequence", wireType)
			}
			m.Sequence = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMvcc3
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Sequence |= (TxnSeq(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinTimestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMvcc3
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMvcc3
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MinTimestamp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMvcc3(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMvcc3
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IgnoredSeqNumRange) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMvcc3
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IgnoredSeqNumRange: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IgnoredSeqNumRange: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Start", wireType)
			}
			m.Start = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMvcc3
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Start |= (TxnSeq(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field End", wireType)
			}
			m.End = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMvcc3
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.End |= (TxnSeq(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMvcc3(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMvcc3
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MVCCStatsDelta) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMvcc3
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MVCCStatsDelta: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MVCCStatsDelta: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastUpdateNanos", wireType)
			}
			m.LastUpdateNanos = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.LastUpdateNanos = int64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field IntentAge", wireType)
			}
			m.IntentAge = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.IntentAge = int64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
		case 3:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field GCBytesAge", wireType)
			}
			m.GCBytesAge = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.GCBytesAge = int64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LiveBytes", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMvcc3
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
			m.LiveBytes = int64(v)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LiveCount", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMvcc3
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
			m.LiveCount = int64(v)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyBytes", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMvcc3
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
			m.KeyBytes = int64(v)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyCount", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMvcc3
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
			m.KeyCount = int64(v)
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValBytes", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMvcc3
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
			m.ValBytes = int64(v)
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValCount", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMvcc3
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
			m.ValCount = int64(v)
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IntentBytes", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMvcc3
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
			m.IntentBytes = int64(v)
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IntentCount", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMvcc3
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
			m.IntentCount = int64(v)
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SysBytes", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMvcc3
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
			m.SysBytes = int64(v)
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SysCount", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMvcc3
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
			m.SysCount = int64(v)
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContainsEstimates", wireType)
			}
			m.ContainsEstimates = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMvcc3
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ContainsEstimates |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMvcc3(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMvcc3
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MVCCPersistentStats) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMvcc3
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MVCCPersistentStats: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MVCCPersistentStats: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastUpdateNanos", wireType)
			}
			m.LastUpdateNanos = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.LastUpdateNanos = int64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field IntentAge", wireType)
			}
			m.IntentAge = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.IntentAge = int64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
		case 3:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field GCBytesAge", wireType)
			}
			m.GCBytesAge = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.GCBytesAge = int64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LiveBytes", wireType)
			}
			m.LiveBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMvcc3
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LiveBytes |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LiveCount", wireType)
			}
			m.LiveCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMvcc3
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LiveCount |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyBytes", wireType)
			}
			m.KeyBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMvcc3
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.KeyBytes |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyCount", wireType)
			}
			m.KeyCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMvcc3
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.KeyCount |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValBytes", wireType)
			}
			m.ValBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMvcc3
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ValBytes |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValCount", wireType)
			}
			m.ValCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMvcc3
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ValCount |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IntentBytes", wireType)
			}
			m.IntentBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMvcc3
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IntentBytes |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IntentCount", wireType)
			}
			m.IntentCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMvcc3
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IntentCount |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SysBytes", wireType)
			}
			m.SysBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMvcc3
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SysBytes |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SysCount", wireType)
			}
			m.SysCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMvcc3
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SysCount |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContainsEstimates", wireType)
			}
			m.ContainsEstimates = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMvcc3
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ContainsEstimates |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMvcc3(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMvcc3
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RangeAppliedState) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMvcc3
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RangeAppliedState: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RangeAppliedState: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RaftAppliedIndex", wireType)
			}
			m.RaftAppliedIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMvcc3
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RaftAppliedIndex |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LeaseAppliedIndex", wireType)
			}
			m.LeaseAppliedIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMvcc3
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LeaseAppliedIndex |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RangeStats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMvcc3
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMvcc3
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RangeStats.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMvcc3(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMvcc3
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MVCCWriteValueOp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMvcc3
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MVCCWriteValueOp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MVCCWriteValueOp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMvcc3
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMvcc3
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = append(m.Key[:0], dAtA[iNdEx:postIndex]...)
			if m.Key == nil {
				m.Key = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMvcc3
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMvcc3
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Timestamp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMvcc3
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMvcc3
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = append(m.Value[:0], dAtA[iNdEx:postIndex]...)
			if m.Value == nil {
				m.Value = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrevValue", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMvcc3
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMvcc3
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PrevValue = append(m.PrevValue[:0], dAtA[iNdEx:postIndex]...)
			if m.PrevValue == nil {
				m.PrevValue = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMvcc3(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMvcc3
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MVCCWriteIntentOp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMvcc3
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MVCCWriteIntentOp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MVCCWriteIntentOp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxnID", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMvcc3
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMvcc3
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TxnID.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxnKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMvcc3
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMvcc3
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TxnKey = append(m.TxnKey[:0], dAtA[iNdEx:postIndex]...)
			if m.TxnKey == nil {
				m.TxnKey = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMvcc3
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMvcc3
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Timestamp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxnMinTimestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMvcc3
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMvcc3
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TxnMinTimestamp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMvcc3(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMvcc3
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MVCCUpdateIntentOp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMvcc3
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MVCCUpdateIntentOp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MVCCUpdateIntentOp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxnID", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMvcc3
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMvcc3
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TxnID.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMvcc3
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMvcc3
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Timestamp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMvcc3(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMvcc3
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MVCCCommitIntentOp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMvcc3
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MVCCCommitIntentOp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MVCCCommitIntentOp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxnID", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMvcc3
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMvcc3
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TxnID.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMvcc3
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMvcc3
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = append(m.Key[:0], dAtA[iNdEx:postIndex]...)
			if m.Key == nil {
				m.Key = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMvcc3
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMvcc3
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Timestamp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMvcc3
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMvcc3
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = append(m.Value[:0], dAtA[iNdEx:postIndex]...)
			if m.Value == nil {
				m.Value = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrevValue", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMvcc3
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMvcc3
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PrevValue = append(m.PrevValue[:0], dAtA[iNdEx:postIndex]...)
			if m.PrevValue == nil {
				m.PrevValue = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMvcc3(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMvcc3
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MVCCAbortIntentOp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMvcc3
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MVCCAbortIntentOp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MVCCAbortIntentOp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxnID", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMvcc3
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMvcc3
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TxnID.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMvcc3(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMvcc3
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MVCCAbortTxnOp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMvcc3
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MVCCAbortTxnOp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MVCCAbortTxnOp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxnID", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMvcc3
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMvcc3
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TxnID.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMvcc3(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMvcc3
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MVCCLogicalOp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMvcc3
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MVCCLogicalOp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MVCCLogicalOp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WriteValue", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMvcc3
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMvcc3
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.WriteValue == nil {
				m.WriteValue = &MVCCWriteValueOp{}
			}
			if err := m.WriteValue.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WriteIntent", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMvcc3
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMvcc3
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.WriteIntent == nil {
				m.WriteIntent = &MVCCWriteIntentOp{}
			}
			if err := m.WriteIntent.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateIntent", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMvcc3
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMvcc3
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UpdateIntent == nil {
				m.UpdateIntent = &MVCCUpdateIntentOp{}
			}
			if err := m.UpdateIntent.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommitIntent", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMvcc3
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMvcc3
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CommitIntent == nil {
				m.CommitIntent = &MVCCCommitIntentOp{}
			}
			if err := m.CommitIntent.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AbortIntent", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMvcc3
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMvcc3
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AbortIntent == nil {
				m.AbortIntent = &MVCCAbortIntentOp{}
			}
			if err := m.AbortIntent.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AbortTxn", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMvcc3
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMvcc3
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AbortTxn == nil {
				m.AbortTxn = &MVCCAbortTxnOp{}
			}
			if err := m.AbortTxn.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMvcc3(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMvcc3
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipMvcc3(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowMvcc3
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowMvcc3
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowMvcc3
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthMvcc3
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowMvcc3
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipMvcc3(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthMvcc3 = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowMvcc3   = fmt.Errorf("proto: integer overflow")
)

func init() {
	proto.RegisterFile("storage/engine/enginepb/mvcc3.proto", fileDescriptor_mvcc3_0c66a9929b41cdeb)
}

var fileDescriptor_mvcc3_0c66a9929b41cdeb = []byte{
	// 1175 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xcc, 0x57, 0x4f, 0x6f, 0x1b, 0x45,
	0x14, 0xf7, 0x7a, 0xd7, 0x89, 0xfd, 0xec, 0x24, 0xf6, 0xb4, 0x12, 0x56, 0xa1, 0xb6, 0x6b, 0x24,
	0x14, 0xf1, 0x67, 0x0d, 0x09, 0x70, 0xc8, 0xcd, 0x4e, 0x2a, 0x70, 0x69, 0x92, 0xb2, 0x71, 0x5a,
	0x09, 0x04, 0xd6, 0x78, 0x3d, 0x6c, 0x56, 0x59, 0xcf, 0x6e, 0x76, 0xc7, 0xae, 0xfd, 0x2d, 0x38,
	0x82, 0x04, 0x52, 0x2e, 0x7c, 0x03, 0x0e, 0x7c, 0x84, 0x1c, 0x7b, 0xac, 0x7a, 0xb0, 0xc0, 0xb9,
	0xf0, 0x01, 0x38, 0x05, 0x21, 0xa1, 0x99, 0x59, 0xaf, 0xed, 0x40, 0x9d, 0xa4, 0x11, 0x11, 0xa7,
	0xcc, 0xbc, 0xdf, 0x7b, 0xbf, 0xf7, 0xfc, 0xde, 0xcf, 0xf3, 0x1c, 0x78, 0x33, 0x60, 0xae, 0x8f,
	0x2d, 0x52, 0x21, 0xd4, 0xb2, 0xe9, 0xf8, 0x8f, 0xd7, 0xaa, 0x74, 0x7a, 0xa6, 0xb9, 0xae, 0x7b,
	0xbe, 0xcb, 0x5c, 0x74, 0xcf, 0x74, 0xcd, 0x43, 0xdf, 0xc5, 0xe6, 0x81, 0x1e, 0xba, 0xeb, 0xd2,
	0x4f, 0x1f, 0xbb, 0xdf, 0xc9, 0x77, 0x99, 0xed, 0x54, 0x0e, 0x1c, 0xb3, 0xc2, 0xec, 0x0e, 0x09,
	0x18, 0xee, 0x78, 0x32, 0xf8, 0xce, 0x6d, 0xcb, 0xb5, 0x5c, 0x71, 0xac, 0xf0, 0x93, 0xb4, 0x96,
	0xbf, 0x57, 0x61, 0xb1, 0xd1, 0xa7, 0xdb, 0x84, 0x61, 0xf4, 0x39, 0xc4, 0xed, 0x76, 0x5e, 0x29,
	0x29, 0xab, 0x99, 0x5a, 0xf5, 0x64, 0x58, 0x8c, 0xbd, 0x18, 0x16, 0xd7, 0x2d, 0x9b, 0x1d, 0x74,
	0x5b, 0xba, 0xe9, 0x76, 0x2a, 0x51, 0xf6, 0x76, 0x6b, 0x72, 0xae, 0x78, 0x87, 0x56, 0x45, 0x24,
	0xed, 0x76, 0xed, 0xb6, 0xbe, 0xbf, 0x5f, 0xdf, 0x1a, 0x0d, 0x8b, 0xf1, 0xfa, 0x96, 0x11, 0xb7,
	0xdb, 0x28, 0x0b, 0xea, 0x21, 0x19, 0xe4, 0x55, 0xce, 0x69, 0xf0, 0x23, 0x2a, 0x43, 0x82, 0x78,
	0xae, 0x79, 0x90, 0xd7, 0x4a, 0xca, 0x6a, 0xa2, 0x96, 0x39, 0x1b, 0x16, 0x93, 0x8d, 0x3e, 0xbd,
	0xcf, 0x6d, 0x86, 0x84, 0xd0, 0x43, 0x58, 0x79, 0xea, 0xdb, 0x8c, 0x34, 0xa3, 0xcf, 0x90, 0x4f,
	0x94, 0x94, 0xd5, 0xf4, 0xda, 0x5d, 0x7d, 0xd2, 0x01, 0x9e, 0x53, 0x3f, 0x70, 0x4c, 0xbd, 0x31,
	0x76, 0xaa, 0x69, 0xbc, 0x68, 0x63, 0x59, 0xc4, 0x46, 0x56, 0xf4, 0x0e, 0x24, 0x3d, 0xdf, 0x76,
	0x7d, 0x9b, 0x0d, 0xf2, 0x0b, 0x22, 0xe9, 0xca, 0xd9, 0xb0, 0x98, 0x6e, 0xf4, 0xe9, 0xa3, 0xd0,
	0x6c, 0x44, 0x0e, 0xe8, 0x2d, 0x48, 0x06, 0xe4, 0xa8, 0x4b, 0xa8, 0x49, 0xf2, 0x8b, 0xc2, 0x19,
	0xce, 0x86, 0xc5, 0x85, 0x46, 0x9f, 0xee, 0x91, 0x23, 0x23, 0xc2, 0xd0, 0xa7, 0xb0, 0xd4, 0xb1,
	0xe9, 0x54, 0x81, 0xa9, 0xcb, 0x17, 0x98, 0xe9, 0xd8, 0x34, 0xb2, 0x6d, 0x64, 0xbe, 0x3b, 0x2e,
	0xc6, 0x7e, 0x39, 0x2e, 0x2a, 0xbf, 0x1f, 0x17, 0x95, 0x07, 0x5a, 0x32, 0x9e, 0x55, 0x1f, 0x68,
	0xc9, 0x64, 0x36, 0x55, 0xfe, 0x1a, 0x50, 0xdd, 0xa2, 0xae, 0x4f, 0xda, 0x7b, 0xe4, 0x68, 0xa7,
	0xdb, 0x31, 0x30, 0xb5, 0x08, 0x2a, 0x41, 0x22, 0x60, 0xd8, 0x67, 0x62, 0x50, 0xb3, 0xe5, 0x49,
	0x00, 0xbd, 0x01, 0x2a, 0xa1, 0xed, 0x7c, 0xfc, 0x1f, 0x38, 0x37, 0x6f, 0x24, 0xc7, 0xb9, 0xca,
	0x7f, 0xa8, 0xb0, 0xbc, 0xfd, 0x78, 0x73, 0x73, 0x8f, 0x61, 0x16, 0x6c, 0x11, 0x87, 0x61, 0xf4,
	0x36, 0xe4, 0x1c, 0x1c, 0xb0, 0x66, 0xd7, 0x6b, 0x63, 0x46, 0x9a, 0x14, 0x53, 0x37, 0x10, 0x89,
	0xb2, 0xc6, 0x0a, 0x07, 0xf6, 0x85, 0x7d, 0x87, 0x9b, 0xd1, 0x5d, 0x00, 0x9b, 0x32, 0x42, 0x59,
	0x13, 0x5b, 0x44, 0x64, 0xcb, 0x1a, 0x29, 0x69, 0xa9, 0x5a, 0x04, 0xbd, 0x0f, 0x19, 0xcb, 0x6c,
	0xb6, 0x06, 0x8c, 0x04, 0xc2, 0x81, 0x6b, 0x20, 0x5b, 0x5b, 0x1e, 0x0d, 0x8b, 0xf0, 0xc9, 0x66,
	0x8d, 0x9b, 0xab, 0x16, 0x31, 0xc0, 0x32, 0xc7, 0x67, 0x4e, 0xe8, 0xd8, 0x3d, 0x22, 0x63, 0x84,
	0x3e, 0x90, 0x91, 0xe2, 0x16, 0xe1, 0x11, 0xc1, 0xa6, 0xdb, 0xa5, 0x4c, 0x08, 0x22, 0x84, 0x37,
	0xb9, 0x01, 0xbd, 0x0e, 0xa9, 0x43, 0x32, 0x08, 0x83, 0x17, 0x04, 0x9a, 0x3c, 0x24, 0x03, 0x19,
	0x1b, 0x82, 0x32, 0x74, 0x31, 0x02, 0xa3, 0xc8, 0x1e, 0x76, 0xc2, 0xc8, 0xa4, 0x04, 0x7b, 0xd8,
	0x89, 0x22, 0x39, 0x28, 0x23, 0x53, 0x11, 0x28, 0x23, 0xef, 0x41, 0x26, 0x6c, 0x81, 0x0c, 0x06,
	0x81, 0xa7, 0xa5, 0x4d, 0xc6, 0x4f, 0x5c, 0x24, 0x45, 0x7a, 0xda, 0x25, 0xca, 0x1f, 0x0c, 0x82,
	0x90, 0x22, 0x23, 0x53, 0x04, 0x83, 0x20, 0xca, 0xcf, 0x41, 0x19, 0xbc, 0x14, 0x81, 0x32, 0xf2,
	0x3d, 0x40, 0xa6, 0x4b, 0x19, 0xb6, 0x69, 0xd0, 0x24, 0x01, 0xb3, 0x3b, 0x98, 0x53, 0x2c, 0x97,
	0x94, 0x55, 0xd5, 0xc8, 0x8d, 0x91, 0xfb, 0x63, 0x60, 0x43, 0x13, 0x63, 0xff, 0x4b, 0x85, 0x5b,
	0x7c, 0xec, 0x8f, 0x88, 0x1f, 0xd8, 0x01, 0x2f, 0x43, 0x08, 0xe0, 0xff, 0x36, 0x7b, 0x75, 0xfe,
	0xec, 0xd5, 0xb9, 0xb3, 0x57, 0xe7, 0xcd, 0x5e, 0x9d, 0x37, 0x7b, 0x75, 0xde, 0xec, 0xd5, 0x0b,
	0x66, 0xaf, 0x5e, 0x3c, 0x7b, 0xf5, 0x82, 0xd9, 0xab, 0xf3, 0x66, 0xaf, 0xbe, 0xfa, 0xec, 0x27,
	0x5f, 0xfb, 0x17, 0x0a, 0xe4, 0xc4, 0x53, 0x52, 0xf5, 0x3c, 0xc7, 0x26, 0x6d, 0x3e, 0x7d, 0x82,
	0xde, 0x05, 0xe4, 0xe3, 0x6f, 0x58, 0x13, 0x4b, 0x63, 0xd3, 0xa6, 0x6d, 0xd2, 0x17, 0xe3, 0xd7,
	0x8c, 0x2c, 0x47, 0x42, 0xef, 0x3a, 0xb7, 0x23, 0x1d, 0x6e, 0x39, 0x04, 0x07, 0xe4, 0x9c, 0x7b,
	0x5c, 0xb8, 0xe7, 0x04, 0x34, 0xe3, 0xff, 0x15, 0xa4, 0x7d, 0x9e, 0xb2, 0x19, 0x70, 0xa9, 0x09,
	0x3d, 0xa4, 0xd7, 0x3e, 0xd6, 0x2f, 0xdc, 0x67, 0xfa, 0xbf, 0x08, 0x35, 0x7c, 0x45, 0x41, 0x10,
	0x0a, 0xcb, 0xd4, 0x87, 0xfb, 0x41, 0x81, 0x2c, 0x8f, 0x79, 0xc2, 0x77, 0xc0, 0x63, 0xec, 0x74,
	0xc9, 0xae, 0x37, 0xde, 0x42, 0xca, 0x64, 0x0b, 0x55, 0x21, 0x35, 0x79, 0xba, 0xe3, 0x97, 0x7f,
	0xba, 0x27, 0x51, 0xe8, 0x36, 0x24, 0x7a, 0x9c, 0x3f, 0x5c, 0x6e, 0xf2, 0xc2, 0x85, 0xea, 0xf9,
	0xa4, 0xd7, 0x94, 0x90, 0x26, 0xa0, 0x14, 0xb7, 0x88, 0x5a, 0xca, 0x3f, 0xc6, 0x21, 0x17, 0x95,
	0x57, 0x17, 0x3a, 0xd8, 0xf5, 0xd0, 0x97, 0xb0, 0xc0, 0xfa, 0xb4, 0x19, 0x2d, 0xdf, 0xad, 0xeb,
	0x2d, 0xdf, 0x44, 0xa3, 0x4f, 0xeb, 0x5b, 0x46, 0x82, 0xf5, 0x69, 0xbd, 0x8d, 0x5e, 0x83, 0x45,
	0x4e, 0xce, 0x1b, 0x10, 0x17, 0xe5, 0xf0, 0x5c, 0x9f, 0x9d, 0xef, 0x81, 0xfa, 0x4a, 0x3d, 0xd8,
	0x85, 0x1c, 0xe7, 0x9e, 0xdd, 0x84, 0xda, 0xe5, 0xa9, 0x56, 0x58, 0x9f, 0x6e, 0x4f, 0x2d, 0xc3,
	0xf2, 0xcf, 0x0a, 0x20, 0xde, 0x1f, 0xf9, 0xd6, 0xdc, 0x4c, 0x83, 0xae, 0xaf, 0x85, 0xf2, 0x9f,
	0x61, 0xd9, 0x9b, 0x6e, 0xa7, 0x63, 0xb3, 0x9b, 0x29, 0x3b, 0x14, 0x75, 0xfc, 0x25, 0xa2, 0x56,
	0xaf, 0x27, 0x6a, 0xed, 0xe5, 0xa2, 0x4e, 0x9c, 0x17, 0xb5, 0x27, 0x35, 0x5d, 0x6d, 0xb9, 0xfe,
	0xcd, 0x7c, 0xf6, 0x72, 0x47, 0xfe, 0x70, 0x11, 0x19, 0x1b, 0x7d, 0xfa, 0x5f, 0xa7, 0xfb, 0x49,
	0x83, 0x25, 0x9e, 0xef, 0xa1, 0x6b, 0xd9, 0x26, 0x76, 0x76, 0x3d, 0xd4, 0x80, 0xb4, 0xfc, 0x85,
	0x2a, 0x5b, 0xa2, 0x88, 0x66, 0xaf, 0x5f, 0xf2, 0x3d, 0x9b, 0x7e, 0x9b, 0x0c, 0x78, 0x1a, 0xdd,
	0xd0, 0x13, 0xc8, 0x48, 0x56, 0xb9, 0x21, 0x42, 0x31, 0x7e, 0x78, 0x15, 0xda, 0x71, 0xff, 0x0d,
	0x59, 0x9f, 0xbc, 0xa2, 0x2f, 0x60, 0x29, 0xdc, 0xea, 0x21, 0xb3, 0x54, 0xc7, 0x47, 0x97, 0x64,
	0x9e, 0xfd, 0x36, 0x1a, 0x99, 0xee, 0xd4, 0x9d, 0x73, 0x9b, 0x42, 0xf6, 0x63, 0x6e, 0xed, 0x4a,
	0xdc, 0xb3, 0x5f, 0x19, 0x23, 0x63, 0x4e, 0xdd, 0x79, 0x43, 0x30, 0x9f, 0xf1, 0x98, 0x3a, 0x71,
	0xa5, 0x86, 0xcc, 0x08, 0xd2, 0x48, 0xe3, 0xc9, 0x15, 0xed, 0x40, 0x4a, 0x12, 0xb3, 0x3e, 0x15,
	0x3f, 0x18, 0xd2, 0x6b, 0x1f, 0x5c, 0x85, 0x55, 0x88, 0xce, 0x48, 0xe2, 0xf0, 0xbc, 0xa1, 0x9d,
	0x1c, 0x17, 0x95, 0x5a, 0xe9, 0xe4, 0xb7, 0x42, 0xec, 0x64, 0x54, 0x50, 0x9e, 0x8d, 0x0a, 0xca,
	0xf3, 0x51, 0x41, 0xf9, 0x75, 0x54, 0x50, 0xbe, 0x3d, 0x2d, 0xc4, 0x9e, 0x9d, 0x16, 0x62, 0xcf,
	0x4f, 0x0b, 0xb1, 0xd6, 0x82, 0xf8, 0xaf, 0x6b, 0xfd, 0xef, 0x00, 0x00, 0x00, 0xff, 0xff, 0x4d,
	0x60, 0x0d, 0x7f, 0xef, 0x0d, 0x00, 0x00,
}
