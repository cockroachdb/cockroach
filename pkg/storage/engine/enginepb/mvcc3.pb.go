// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: storage/engine/enginepb/mvcc3.proto

package enginepb

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import cockroach_util_hlc "github.com/cockroachdb/cockroach/pkg/util/hlc"

import github_com_cockroachdb_cockroach_pkg_util_uuid "github.com/cockroachdb/cockroach/pkg/util/uuid"

import bytes "bytes"

import binary "encoding/binary"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// TODO(tschottdorf): Should not live in enginepb (but can't live in roachpb
// either).
type IsolationType int32

const (
	SERIALIZABLE IsolationType = 0
	SNAPSHOT     IsolationType = 1
)

var IsolationType_name = map[int32]string{
	0: "SERIALIZABLE",
	1: "SNAPSHOT",
}
var IsolationType_value = map[string]int32{
	"SERIALIZABLE": 0,
	"SNAPSHOT":     1,
}

func (x IsolationType) String() string {
	return proto.EnumName(IsolationType_name, int32(x))
}
func (IsolationType) EnumDescriptor() ([]byte, []int) { return fileDescriptorMvcc3, []int{0} }

// TxnMeta is the metadata of a Transaction record.
type TxnMeta struct {
	// id is a unique UUID value which identifies the transaction.
	// This field is always filled in.
	ID        github_com_cockroachdb_cockroach_pkg_util_uuid.UUID `protobuf:"bytes,1,opt,name=id,proto3,customtype=github.com/cockroachdb/cockroach/pkg/util/uuid.UUID" json:"id"`
	Isolation IsolationType                                       `protobuf:"varint,2,opt,name=isolation,proto3,enum=cockroach.storage.engine.enginepb.IsolationType" json:"isolation,omitempty"`
	// key is the key which anchors the transaction. This is typically
	// the first key read or written during the transaction and
	// determines which range in the cluster will hold the transaction
	// record.
	Key []byte `protobuf:"bytes,3,opt,name=key,proto3" json:"key,omitempty"`
	// Incremented on txn retry.
	Epoch uint32 `protobuf:"varint,4,opt,name=epoch,proto3" json:"epoch,omitempty"`
	// The proposed timestamp for the transaction. This starts as the
	// current wall time on the txn coordinator. This is the timestamp
	// at which all of the transaction's writes are performed: even if
	// intents have been laid down at different timestamps, the process
	// of resolving them (e.g. when the txn commits) will bump them to
	// this timestamp. SERIALIZABLE transactions only commit when
	// timestamp == orig_timestamp. SNAPSHOT transactions can commit
	// even when they've performed their reads (at orig_timestamp) at a
	// different timestamp than their writes (at timestamp).
	Timestamp cockroach_util_hlc.Timestamp `protobuf:"bytes,5,opt,name=timestamp" json:"timestamp"`
	Priority  int32                        `protobuf:"varint,6,opt,name=priority,proto3" json:"priority,omitempty"`
	// A one-indexed sequence number which is increased on each batch
	// sent as part of the transaction. Used to prevent replay and
	// out-of-order application protection (by means of a transaction
	// retry).
	Sequence int32 `protobuf:"varint,7,opt,name=sequence,proto3" json:"sequence,omitempty"`
	// A zero-indexed sequence number indicating the index of a command
	// within a batch. This disambiguate Raft replays of a batch from
	// multiple commands in a batch which modify the same key.
	BatchIndex int32 `protobuf:"varint,8,opt,name=batch_index,json=batchIndex,proto3" json:"batch_index,omitempty"`
}

func (m *TxnMeta) Reset()                    { *m = TxnMeta{} }
func (m *TxnMeta) String() string            { return proto.CompactTextString(m) }
func (*TxnMeta) ProtoMessage()               {}
func (*TxnMeta) Descriptor() ([]byte, []int) { return fileDescriptorMvcc3, []int{0} }

// MVCCNetworkStats is convertible to MVCCStats, but uses variable width
// encodings for most fields. This makes the encodings incompatible. Note that
// with proto3, zero-valued primitive types will not be encoded at all.
type MVCCNetworkStats struct {
	ContainsEstimates bool  `protobuf:"varint,14,opt,name=contains_estimates,json=containsEstimates,proto3" json:"contains_estimates,omitempty"`
	LastUpdateNanos   int64 `protobuf:"fixed64,1,opt,name=last_update_nanos,json=lastUpdateNanos,proto3" json:"last_update_nanos,omitempty"`
	IntentAge         int64 `protobuf:"fixed64,2,opt,name=intent_age,json=intentAge,proto3" json:"intent_age,omitempty"`
	GCBytesAge        int64 `protobuf:"fixed64,3,opt,name=gc_bytes_age,json=gcBytesAge,proto3" json:"gc_bytes_age,omitempty"`
	LiveBytes         int64 `protobuf:"zigzag64,4,opt,name=live_bytes,json=liveBytes,proto3" json:"live_bytes,omitempty"`
	LiveCount         int64 `protobuf:"zigzag64,5,opt,name=live_count,json=liveCount,proto3" json:"live_count,omitempty"`
	KeyBytes          int64 `protobuf:"zigzag64,6,opt,name=key_bytes,json=keyBytes,proto3" json:"key_bytes,omitempty"`
	KeyCount          int64 `protobuf:"zigzag64,7,opt,name=key_count,json=keyCount,proto3" json:"key_count,omitempty"`
	ValBytes          int64 `protobuf:"zigzag64,8,opt,name=val_bytes,json=valBytes,proto3" json:"val_bytes,omitempty"`
	ValCount          int64 `protobuf:"zigzag64,9,opt,name=val_count,json=valCount,proto3" json:"val_count,omitempty"`
	IntentBytes       int64 `protobuf:"zigzag64,10,opt,name=intent_bytes,json=intentBytes,proto3" json:"intent_bytes,omitempty"`
	IntentCount       int64 `protobuf:"zigzag64,11,opt,name=intent_count,json=intentCount,proto3" json:"intent_count,omitempty"`
	SysBytes          int64 `protobuf:"zigzag64,12,opt,name=sys_bytes,json=sysBytes,proto3" json:"sys_bytes,omitempty"`
	SysCount          int64 `protobuf:"zigzag64,13,opt,name=sys_count,json=sysCount,proto3" json:"sys_count,omitempty"`
}

func (m *MVCCNetworkStats) Reset()                    { *m = MVCCNetworkStats{} }
func (m *MVCCNetworkStats) String() string            { return proto.CompactTextString(m) }
func (*MVCCNetworkStats) ProtoMessage()               {}
func (*MVCCNetworkStats) Descriptor() ([]byte, []int) { return fileDescriptorMvcc3, []int{1} }

func init() {
	proto.RegisterType((*TxnMeta)(nil), "cockroach.storage.engine.enginepb.TxnMeta")
	proto.RegisterType((*MVCCNetworkStats)(nil), "cockroach.storage.engine.enginepb.MVCCNetworkStats")
	proto.RegisterEnum("cockroach.storage.engine.enginepb.IsolationType", IsolationType_name, IsolationType_value)
}
func (this *TxnMeta) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TxnMeta)
	if !ok {
		that2, ok := that.(TxnMeta)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.ID.Equal(that1.ID) {
		return false
	}
	if this.Isolation != that1.Isolation {
		return false
	}
	if !bytes.Equal(this.Key, that1.Key) {
		return false
	}
	if this.Epoch != that1.Epoch {
		return false
	}
	if !this.Timestamp.Equal(&that1.Timestamp) {
		return false
	}
	if this.Priority != that1.Priority {
		return false
	}
	if this.Sequence != that1.Sequence {
		return false
	}
	if this.BatchIndex != that1.BatchIndex {
		return false
	}
	return true
}
func (this *MVCCNetworkStats) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*MVCCNetworkStats)
	if !ok {
		that2, ok := that.(MVCCNetworkStats)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ContainsEstimates != that1.ContainsEstimates {
		return false
	}
	if this.LastUpdateNanos != that1.LastUpdateNanos {
		return false
	}
	if this.IntentAge != that1.IntentAge {
		return false
	}
	if this.GCBytesAge != that1.GCBytesAge {
		return false
	}
	if this.LiveBytes != that1.LiveBytes {
		return false
	}
	if this.LiveCount != that1.LiveCount {
		return false
	}
	if this.KeyBytes != that1.KeyBytes {
		return false
	}
	if this.KeyCount != that1.KeyCount {
		return false
	}
	if this.ValBytes != that1.ValBytes {
		return false
	}
	if this.ValCount != that1.ValCount {
		return false
	}
	if this.IntentBytes != that1.IntentBytes {
		return false
	}
	if this.IntentCount != that1.IntentCount {
		return false
	}
	if this.SysBytes != that1.SysBytes {
		return false
	}
	if this.SysCount != that1.SysCount {
		return false
	}
	return true
}
func (m *TxnMeta) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TxnMeta) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintMvcc3(dAtA, i, uint64(m.ID.Size()))
	n1, err := m.ID.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n1
	if m.Isolation != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintMvcc3(dAtA, i, uint64(m.Isolation))
	}
	if len(m.Key) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintMvcc3(dAtA, i, uint64(len(m.Key)))
		i += copy(dAtA[i:], m.Key)
	}
	if m.Epoch != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintMvcc3(dAtA, i, uint64(m.Epoch))
	}
	dAtA[i] = 0x2a
	i++
	i = encodeVarintMvcc3(dAtA, i, uint64(m.Timestamp.Size()))
	n2, err := m.Timestamp.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n2
	if m.Priority != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintMvcc3(dAtA, i, uint64(m.Priority))
	}
	if m.Sequence != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintMvcc3(dAtA, i, uint64(m.Sequence))
	}
	if m.BatchIndex != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintMvcc3(dAtA, i, uint64(m.BatchIndex))
	}
	return i, nil
}

func (m *MVCCNetworkStats) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MVCCNetworkStats) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.LastUpdateNanos != 0 {
		dAtA[i] = 0x9
		i++
		binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.LastUpdateNanos))
		i += 8
	}
	if m.IntentAge != 0 {
		dAtA[i] = 0x11
		i++
		binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.IntentAge))
		i += 8
	}
	if m.GCBytesAge != 0 {
		dAtA[i] = 0x19
		i++
		binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.GCBytesAge))
		i += 8
	}
	if m.LiveBytes != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintMvcc3(dAtA, i, uint64((uint64(m.LiveBytes)<<1)^uint64((m.LiveBytes>>63))))
	}
	if m.LiveCount != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintMvcc3(dAtA, i, uint64((uint64(m.LiveCount)<<1)^uint64((m.LiveCount>>63))))
	}
	if m.KeyBytes != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintMvcc3(dAtA, i, uint64((uint64(m.KeyBytes)<<1)^uint64((m.KeyBytes>>63))))
	}
	if m.KeyCount != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintMvcc3(dAtA, i, uint64((uint64(m.KeyCount)<<1)^uint64((m.KeyCount>>63))))
	}
	if m.ValBytes != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintMvcc3(dAtA, i, uint64((uint64(m.ValBytes)<<1)^uint64((m.ValBytes>>63))))
	}
	if m.ValCount != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintMvcc3(dAtA, i, uint64((uint64(m.ValCount)<<1)^uint64((m.ValCount>>63))))
	}
	if m.IntentBytes != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintMvcc3(dAtA, i, uint64((uint64(m.IntentBytes)<<1)^uint64((m.IntentBytes>>63))))
	}
	if m.IntentCount != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintMvcc3(dAtA, i, uint64((uint64(m.IntentCount)<<1)^uint64((m.IntentCount>>63))))
	}
	if m.SysBytes != 0 {
		dAtA[i] = 0x60
		i++
		i = encodeVarintMvcc3(dAtA, i, uint64((uint64(m.SysBytes)<<1)^uint64((m.SysBytes>>63))))
	}
	if m.SysCount != 0 {
		dAtA[i] = 0x68
		i++
		i = encodeVarintMvcc3(dAtA, i, uint64((uint64(m.SysCount)<<1)^uint64((m.SysCount>>63))))
	}
	if m.ContainsEstimates {
		dAtA[i] = 0x70
		i++
		if m.ContainsEstimates {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func encodeVarintMvcc3(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func NewPopulatedTxnMeta(r randyMvcc3, easy bool) *TxnMeta {
	this := &TxnMeta{}
	v1 := github_com_cockroachdb_cockroach_pkg_util_uuid.NewPopulatedUUID(r)
	this.ID = *v1
	this.Isolation = IsolationType([]int32{0, 1}[r.Intn(2)])
	v2 := r.Intn(100)
	this.Key = make([]byte, v2)
	for i := 0; i < v2; i++ {
		this.Key[i] = byte(r.Intn(256))
	}
	this.Epoch = uint32(r.Uint32())
	v3 := cockroach_util_hlc.NewPopulatedTimestamp(r, easy)
	this.Timestamp = *v3
	this.Priority = int32(r.Int31())
	if r.Intn(2) == 0 {
		this.Priority *= -1
	}
	this.Sequence = int32(r.Int31())
	if r.Intn(2) == 0 {
		this.Sequence *= -1
	}
	this.BatchIndex = int32(r.Int31())
	if r.Intn(2) == 0 {
		this.BatchIndex *= -1
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

type randyMvcc3 interface {
	Float32() float32
	Float64() float64
	Int63() int64
	Int31() int32
	Uint32() uint32
	Intn(n int) int
}

func randUTF8RuneMvcc3(r randyMvcc3) rune {
	ru := r.Intn(62)
	if ru < 10 {
		return rune(ru + 48)
	} else if ru < 36 {
		return rune(ru + 55)
	}
	return rune(ru + 61)
}
func randStringMvcc3(r randyMvcc3) string {
	v4 := r.Intn(100)
	tmps := make([]rune, v4)
	for i := 0; i < v4; i++ {
		tmps[i] = randUTF8RuneMvcc3(r)
	}
	return string(tmps)
}
func randUnrecognizedMvcc3(r randyMvcc3, maxFieldNumber int) (dAtA []byte) {
	l := r.Intn(5)
	for i := 0; i < l; i++ {
		wire := r.Intn(4)
		if wire == 3 {
			wire = 5
		}
		fieldNumber := maxFieldNumber + r.Intn(100)
		dAtA = randFieldMvcc3(dAtA, r, fieldNumber, wire)
	}
	return dAtA
}
func randFieldMvcc3(dAtA []byte, r randyMvcc3, fieldNumber int, wire int) []byte {
	key := uint32(fieldNumber)<<3 | uint32(wire)
	switch wire {
	case 0:
		dAtA = encodeVarintPopulateMvcc3(dAtA, uint64(key))
		v5 := r.Int63()
		if r.Intn(2) == 0 {
			v5 *= -1
		}
		dAtA = encodeVarintPopulateMvcc3(dAtA, uint64(v5))
	case 1:
		dAtA = encodeVarintPopulateMvcc3(dAtA, uint64(key))
		dAtA = append(dAtA, byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)))
	case 2:
		dAtA = encodeVarintPopulateMvcc3(dAtA, uint64(key))
		ll := r.Intn(100)
		dAtA = encodeVarintPopulateMvcc3(dAtA, uint64(ll))
		for j := 0; j < ll; j++ {
			dAtA = append(dAtA, byte(r.Intn(256)))
		}
	default:
		dAtA = encodeVarintPopulateMvcc3(dAtA, uint64(key))
		dAtA = append(dAtA, byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)))
	}
	return dAtA
}
func encodeVarintPopulateMvcc3(dAtA []byte, v uint64) []byte {
	for v >= 1<<7 {
		dAtA = append(dAtA, uint8(uint64(v)&0x7f|0x80))
		v >>= 7
	}
	dAtA = append(dAtA, uint8(v))
	return dAtA
}
func (m *TxnMeta) Size() (n int) {
	var l int
	_ = l
	l = m.ID.Size()
	n += 1 + l + sovMvcc3(uint64(l))
	if m.Isolation != 0 {
		n += 1 + sovMvcc3(uint64(m.Isolation))
	}
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovMvcc3(uint64(l))
	}
	if m.Epoch != 0 {
		n += 1 + sovMvcc3(uint64(m.Epoch))
	}
	l = m.Timestamp.Size()
	n += 1 + l + sovMvcc3(uint64(l))
	if m.Priority != 0 {
		n += 1 + sovMvcc3(uint64(m.Priority))
	}
	if m.Sequence != 0 {
		n += 1 + sovMvcc3(uint64(m.Sequence))
	}
	if m.BatchIndex != 0 {
		n += 1 + sovMvcc3(uint64(m.BatchIndex))
	}
	return n
}

func (m *MVCCNetworkStats) Size() (n int) {
	var l int
	_ = l
	if m.LastUpdateNanos != 0 {
		n += 9
	}
	if m.IntentAge != 0 {
		n += 9
	}
	if m.GCBytesAge != 0 {
		n += 9
	}
	if m.LiveBytes != 0 {
		n += 1 + sozMvcc3(uint64(m.LiveBytes))
	}
	if m.LiveCount != 0 {
		n += 1 + sozMvcc3(uint64(m.LiveCount))
	}
	if m.KeyBytes != 0 {
		n += 1 + sozMvcc3(uint64(m.KeyBytes))
	}
	if m.KeyCount != 0 {
		n += 1 + sozMvcc3(uint64(m.KeyCount))
	}
	if m.ValBytes != 0 {
		n += 1 + sozMvcc3(uint64(m.ValBytes))
	}
	if m.ValCount != 0 {
		n += 1 + sozMvcc3(uint64(m.ValCount))
	}
	if m.IntentBytes != 0 {
		n += 1 + sozMvcc3(uint64(m.IntentBytes))
	}
	if m.IntentCount != 0 {
		n += 1 + sozMvcc3(uint64(m.IntentCount))
	}
	if m.SysBytes != 0 {
		n += 1 + sozMvcc3(uint64(m.SysBytes))
	}
	if m.SysCount != 0 {
		n += 1 + sozMvcc3(uint64(m.SysCount))
	}
	if m.ContainsEstimates {
		n += 2
	}
	return n
}

func sovMvcc3(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozMvcc3(x uint64) (n int) {
	return sovMvcc3(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *TxnMeta) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMvcc3
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TxnMeta: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TxnMeta: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMvcc3
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMvcc3
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ID.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Isolation", wireType)
			}
			m.Isolation = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMvcc3
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Isolation |= (IsolationType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMvcc3
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMvcc3
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = append(m.Key[:0], dAtA[iNdEx:postIndex]...)
			if m.Key == nil {
				m.Key = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Epoch", wireType)
			}
			m.Epoch = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMvcc3
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Epoch |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMvcc3
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMvcc3
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Timestamp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Priority", wireType)
			}
			m.Priority = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMvcc3
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Priority |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sequence", wireType)
			}
			m.Sequence = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMvcc3
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Sequence |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BatchIndex", wireType)
			}
			m.BatchIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMvcc3
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BatchIndex |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMvcc3(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMvcc3
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MVCCNetworkStats) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMvcc3
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MVCCNetworkStats: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MVCCNetworkStats: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastUpdateNanos", wireType)
			}
			m.LastUpdateNanos = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.LastUpdateNanos = int64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field IntentAge", wireType)
			}
			m.IntentAge = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.IntentAge = int64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
		case 3:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field GCBytesAge", wireType)
			}
			m.GCBytesAge = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.GCBytesAge = int64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LiveBytes", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMvcc3
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
			m.LiveBytes = int64(v)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LiveCount", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMvcc3
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
			m.LiveCount = int64(v)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyBytes", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMvcc3
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
			m.KeyBytes = int64(v)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyCount", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMvcc3
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
			m.KeyCount = int64(v)
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValBytes", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMvcc3
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
			m.ValBytes = int64(v)
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValCount", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMvcc3
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
			m.ValCount = int64(v)
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IntentBytes", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMvcc3
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
			m.IntentBytes = int64(v)
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IntentCount", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMvcc3
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
			m.IntentCount = int64(v)
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SysBytes", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMvcc3
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
			m.SysBytes = int64(v)
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SysCount", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMvcc3
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
			m.SysCount = int64(v)
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContainsEstimates", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMvcc3
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ContainsEstimates = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipMvcc3(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMvcc3
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipMvcc3(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowMvcc3
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowMvcc3
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowMvcc3
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthMvcc3
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowMvcc3
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipMvcc3(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthMvcc3 = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowMvcc3   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("storage/engine/enginepb/mvcc3.proto", fileDescriptorMvcc3) }

var fileDescriptorMvcc3 = []byte{
	// 659 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x84, 0x93, 0xc1, 0x6e, 0x12, 0x41,
	0x18, 0xc7, 0x19, 0x4a, 0x5b, 0x18, 0x68, 0xdd, 0x4e, 0x7a, 0xd8, 0x60, 0x0a, 0xb4, 0x5e, 0x48,
	0x13, 0x77, 0x9b, 0x36, 0x5e, 0x7a, 0x03, 0xda, 0x28, 0x49, 0x8b, 0xba, 0x50, 0x0f, 0x5e, 0xc8,
	0x30, 0x4c, 0x96, 0x09, 0xcb, 0xce, 0xca, 0x0c, 0xd8, 0x7d, 0x03, 0x8f, 0x3e, 0x42, 0x13, 0x5f,
	0xc2, 0x47, 0xe8, 0xd1, 0xa3, 0xf1, 0x40, 0x14, 0x2f, 0x3e, 0x81, 0x07, 0x4f, 0x66, 0x66, 0xd8,
	0xa5, 0x9e, 0x3c, 0xf1, 0xcd, 0xff, 0xf7, 0xff, 0x7f, 0xdf, 0xce, 0xb7, 0x2c, 0x7c, 0x22, 0x24,
	0x9f, 0x62, 0x9f, 0xba, 0x34, 0xf4, 0x59, 0x98, 0xfc, 0x44, 0x03, 0x77, 0x32, 0x27, 0xe4, 0xcc,
	0x89, 0xa6, 0x5c, 0x72, 0x74, 0x48, 0x38, 0x19, 0x4f, 0x39, 0x26, 0x23, 0x67, 0x65, 0x77, 0x8c,
	0xcf, 0x49, 0xec, 0x65, 0x7b, 0x26, 0x59, 0xe0, 0x8e, 0x02, 0xe2, 0x4a, 0x36, 0xa1, 0x42, 0xe2,
	0x49, 0x64, 0xc2, 0xe5, 0x7d, 0x9f, 0xfb, 0x5c, 0x97, 0xae, 0xaa, 0x8c, 0x7a, 0xf4, 0x27, 0x0b,
	0xb7, 0x7b, 0xb7, 0xe1, 0x35, 0x95, 0x18, 0xbd, 0x86, 0x59, 0x36, 0xb4, 0x41, 0x0d, 0xd4, 0x4b,
	0xcd, 0xc6, 0xfd, 0xa2, 0x9a, 0xf9, 0xb6, 0xa8, 0x9e, 0xf9, 0x4c, 0x8e, 0x66, 0x03, 0x87, 0xf0,
	0x89, 0x9b, 0x4e, 0x1f, 0x0e, 0xd6, 0xb5, 0x1b, 0x8d, 0x7d, 0x57, 0x0f, 0x9d, 0xcd, 0xd8, 0xd0,
	0xb9, 0xb9, 0x69, 0x5f, 0x2c, 0x17, 0xd5, 0x6c, 0xfb, 0xc2, 0xcb, 0xb2, 0x21, 0xea, 0xc0, 0x02,
	0x13, 0x3c, 0xc0, 0x92, 0xf1, 0xd0, 0xce, 0xd6, 0x40, 0x7d, 0xf7, 0xf4, 0xc4, 0xf9, 0xef, 0x2d,
	0x9c, 0x76, 0x92, 0xe9, 0xc5, 0x11, 0xf5, 0xd6, 0x2d, 0x90, 0x05, 0x37, 0xc6, 0x34, 0xb6, 0x37,
	0xd4, 0x33, 0x7a, 0xaa, 0x44, 0xfb, 0x70, 0x93, 0x46, 0x9c, 0x8c, 0xec, 0x5c, 0x0d, 0xd4, 0x77,
	0x3c, 0x73, 0x40, 0x0d, 0x58, 0x48, 0xef, 0x6f, 0x6f, 0xd6, 0x40, 0xbd, 0x78, 0x7a, 0xf0, 0x60,
	0xae, 0x7a, 0x5e, 0x67, 0x14, 0x10, 0xa7, 0x97, 0x98, 0x9a, 0x39, 0x75, 0x61, 0x6f, 0x9d, 0x42,
	0x65, 0x98, 0x8f, 0xa6, 0x8c, 0x4f, 0x99, 0x8c, 0xed, 0xad, 0x1a, 0xa8, 0x6f, 0x7a, 0xe9, 0x59,
	0x31, 0x41, 0xdf, 0xcd, 0x68, 0x48, 0xa8, 0xbd, 0x6d, 0x58, 0x72, 0x46, 0x55, 0x58, 0x1c, 0x60,
	0x49, 0x46, 0x7d, 0x16, 0x0e, 0xe9, 0xad, 0x9d, 0xd7, 0x18, 0x6a, 0xa9, 0xad, 0x94, 0xf3, 0xfc,
	0xe7, 0xbb, 0x2a, 0xf8, 0x75, 0x57, 0x05, 0x47, 0xbf, 0x37, 0xa0, 0x75, 0xfd, 0xa6, 0xd5, 0xea,
	0x50, 0xf9, 0x9e, 0x4f, 0xc7, 0x5d, 0x89, 0xa5, 0x40, 0xc7, 0x70, 0x2f, 0xc0, 0x42, 0xf6, 0x67,
	0xd1, 0x10, 0x4b, 0xda, 0x0f, 0x71, 0xc8, 0x85, 0x7e, 0x29, 0x96, 0xf7, 0x48, 0x81, 0x1b, 0xad,
	0x77, 0x94, 0x8c, 0x0e, 0x20, 0x64, 0xa1, 0xa4, 0xa1, 0xec, 0x63, 0x9f, 0xea, 0xfd, 0x5a, 0x5e,
	0xc1, 0x28, 0x0d, 0x9f, 0xa2, 0x13, 0x58, 0xf2, 0x49, 0x7f, 0x10, 0x4b, 0x2a, 0xb4, 0x41, 0xad,
	0xcd, 0x6a, 0xee, 0x2e, 0x17, 0x55, 0xf8, 0xbc, 0xd5, 0x54, 0x72, 0xc3, 0xa7, 0x1e, 0xf4, 0x49,
	0x52, 0xab, 0x86, 0x01, 0x9b, 0x53, 0x93, 0xd1, 0x2b, 0x45, 0x5e, 0x41, 0x29, 0xda, 0x91, 0x62,
	0xc2, 0x67, 0xa1, 0xd4, 0x7b, 0x5d, 0xe1, 0x96, 0x12, 0xd0, 0x63, 0x58, 0x18, 0xd3, 0x78, 0x15,
	0xde, 0xd2, 0x34, 0x3f, 0xa6, 0xb1, 0xc9, 0xae, 0xa0, 0x89, 0x6e, 0xa7, 0x30, 0x4d, 0xce, 0x71,
	0xb0, 0x4a, 0xe6, 0x0d, 0x9c, 0xe3, 0x20, 0x4d, 0x2a, 0x68, 0x92, 0x85, 0x14, 0x9a, 0xe4, 0x21,
	0x2c, 0xad, 0x56, 0x60, 0xc2, 0x50, 0xf3, 0xa2, 0xd1, 0x4c, 0x7e, 0x6d, 0x31, 0x2d, 0x8a, 0x0f,
	0x2d, 0xe9, 0x7c, 0x11, 0x8b, 0x55, 0x8b, 0x92, 0x19, 0x21, 0x62, 0x91, 0xce, 0x57, 0xd0, 0x84,
	0x77, 0x52, 0x68, 0x92, 0x4f, 0x21, 0x22, 0x3c, 0x94, 0x98, 0x85, 0xa2, 0x4f, 0x85, 0x64, 0x13,
	0xac, 0x5a, 0xec, 0xd6, 0x40, 0x3d, 0xef, 0xed, 0x25, 0xe4, 0x32, 0x01, 0xe7, 0x39, 0xf5, 0xe2,
	0x8f, 0x9f, 0xc1, 0x9d, 0x7f, 0xfe, 0xe2, 0xc8, 0x82, 0xa5, 0xee, 0xa5, 0xd7, 0x6e, 0x5c, 0xb5,
	0xdf, 0x36, 0x9a, 0x57, 0x97, 0x56, 0x06, 0x95, 0x60, 0xbe, 0xdb, 0x69, 0xbc, 0xea, 0xbe, 0x78,
	0xd9, 0xb3, 0x40, 0x39, 0xf7, 0xe1, 0x53, 0x25, 0xd3, 0xb4, 0xef, 0x7f, 0x54, 0x32, 0xf7, 0xcb,
	0x0a, 0xf8, 0xb2, 0xac, 0x80, 0xaf, 0xcb, 0x0a, 0xf8, 0xbe, 0xac, 0x80, 0x8f, 0x3f, 0x2b, 0x99,
	0xc1, 0x96, 0xfe, 0x9a, 0xcf, 0xfe, 0x06, 0x00, 0x00, 0xff, 0xff, 0x24, 0xe4, 0xa2, 0x02, 0x47,
	0x04, 0x00, 0x00,
}
