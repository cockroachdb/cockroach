// Copyright 2022 The Cockroach Authors.
//
// Use of this software is governed by the Business Source License
// included in the file licenses/BSL.txt.
//
// As of the Change Date specified in that file, in accordance with
// the Business Source License, use of this software will be governed
// by the Apache License, Version 2.0, included in the file
// licenses/APL.txt.

package kvserverbase

import "fmt"

// RaftCommandEncodingVersion versions CockroachDB's raft entries.
type RaftCommandEncodingVersion byte

// Raft commands are encoded with a 1-byte version (currently 0 or 1), an 8-byte
// ID, followed by the payload. This inflexible encoding is used so we can
// efficiently parse the command id while processing the logs.
//
// TODO(bdarnell): is this commandID still appropriate for our needs?
const (
	// RaftVersionStandard is the initial Raft command version, used for all regular Raft traffic.
	RaftVersionStandard RaftCommandEncodingVersion = 0
	// RaftVersionSideloaded indicates a proposal containing an SSTable which
	// preferably should be sideloaded (i.e. not stored in the Raft log
	// wholesale). Can be treated as a regular proposal when arriving on the wire,
	// but when retrieved from the local Raft log it necessary to inline the
	// payload first as it has usually been sideloaded.
	RaftVersionSideloaded RaftCommandEncodingVersion = 1
	// RaftCommandIDLen is the length for each command ID.
	RaftCommandIDLen = 8
	// RaftCommandPrefixLen is the prescribed length of each encoded command's prefix.
	RaftCommandPrefixLen = 1 + RaftCommandIDLen
	// RaftCommandNoSplitBit is deprecated.
	// The no-split bit is now unused, but we still apply the mask to the first
	// byte of the command for backward compatibility.
	//
	// TODO(tschottdorf): predates v1.0 by a significant margin. Remove.
	RaftCommandNoSplitBit = 1 << 7
	// RaftCommandNoSplitMask is deprecated.
	RaftCommandNoSplitMask = RaftCommandNoSplitBit - 1
)

// EncodeRaftCommand encodes a raft command (including the versioning prefix).
func EncodeRaftCommand(
	version RaftCommandEncodingVersion, commandID CmdIDKey, command []byte,
) []byte {
	b := make([]byte, RaftCommandPrefixLen+len(command))
	EncodeRaftCommandPrefix(b[:RaftCommandPrefixLen], version, commandID)
	copy(b[RaftCommandPrefixLen:], command)
	return b
}

// EncodeRaftCommandPrefix encodes the versioning prefix for a Raft command.
func EncodeRaftCommandPrefix(b []byte, version RaftCommandEncodingVersion, commandID CmdIDKey) {
	if len(commandID) != RaftCommandIDLen {
		panic(fmt.Sprintf("invalid command ID length; %d != %d", len(commandID), RaftCommandIDLen))
	}
	if len(b) != RaftCommandPrefixLen {
		panic(fmt.Sprintf("invalid command prefix length; %d != %d", len(b), RaftCommandPrefixLen))
	}
	b[0] = byte(version)
	copy(b[1:], []byte(commandID))
}

// DecodeRaftCommand splits a raftpb.Entry.Data into its commandID and
// command portions. The caller is responsible for checking that the data
// is not empty (which indicates a dummy entry generated by raft rather
// than a real command). Usage is mostly internal to the storage package
// but is exported for use by debugging tools.
func DecodeRaftCommand(data []byte) (CmdIDKey, []byte) {
	v := RaftCommandEncodingVersion(data[0] & RaftCommandNoSplitMask)
	if v != RaftVersionStandard && v != RaftVersionSideloaded {
		panic(fmt.Sprintf("unknown command encoding version %v", data[0]))
	}
	return CmdIDKey(data[1 : 1+RaftCommandIDLen]), data[1+RaftCommandIDLen:]
}
