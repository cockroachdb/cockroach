# All CPU values are in cores (1 core = 1e9 ns/s).

# Normal case: single store on a node. All node CPU usage comes from store work.
# Node is at 50% utilization.
compute store-load=8 node-cpu-usage=8 node-cpu-capacity=16 total-stores-cpu-usage=8 num-stores=1
----
              node-cpu-capacity/num-stores: 16.00 cores/store
naive:        kv-capacity: 16.00 cores, kv-util: 50.00% (8.00/16.00 cores)
capped_mult:  kv-capacity: 16.00 cores, kv-util: 50.00% (8.00/16.00 cores)
sql_model:    kv-capacity: 16.00 cores, kv-util: 50.00% (8.00/16.00 cores)

# Normal case: 2 stores on a node with uneven load. Node at 80% utilization, all
# from store work. This store uses 7 cores, other uses 3. This store at 112%
# util will shed load to other at 48%.
compute store-load=7 node-cpu-usage=12.8 node-cpu-capacity=16 total-stores-cpu-usage=10 num-stores=2
----
              node-cpu-capacity/num-stores: 8.00 cores/store
naive:        kv-capacity: 6.25 cores, kv-util: 112.00% (7.00/6.25 cores)
capped_mult:  kv-capacity: 6.25 cores, kv-util: 112.00% (7.00/6.25 cores)
sql_model:    kv-capacity: 6.25 cores, kv-util: 112.00% (7.00/6.25 cores)

# Measurement lag: stores report more CPU than node is using (implicit mult < 1).
# This can happen due to timing differences in measurement collection. The
# implicit multiplier would be 0.5 (= 4/8), but it gets clamped to 1.0.
# *** SIGNIFICANT DIFFERENCE: capped_mult is 2x better (16 vs 32 cores) ***
# Reasoning: When stores report more CPU than node uses, naive/sql_model assume
# stores are underutilized (12.5% util). Capped_mult clamps multiplier to 1.0,
# giving more realistic 25% utilization that matches actual node usage.
compute store-load=4 node-cpu-usage=4 node-cpu-capacity=16 total-stores-cpu-usage=8 num-stores=1
----
              node-cpu-capacity/num-stores: 16.00 cores/store
naive:        kv-capacity: 32.00 cores, kv-util: 12.50% (4.00/32.00 cores)
capped_mult:  kv-capacity: 16.00 cores, kv-util: 25.00% (4.00/16.00 cores)
sql_model:    kv-capacity: 32.00 cores, kv-util: 12.50% (4.00/32.00 cores)

# Moderate indirect overhead: store uses 4 cores, node uses 8 cores (2x overhead).
# Implicit multiplier is 2.0 (= 8/4), which is between 1 and 3, so it's used
# directly. This represents moderate indirect CPU overhead (RPC, compactions, etc.).
compute store-load=4 node-cpu-usage=8 node-cpu-capacity=16 total-stores-cpu-usage=4 num-stores=1
----
              node-cpu-capacity/num-stores: 16.00 cores/store
naive:        kv-capacity: 8.00 cores, kv-util: 50.00% (4.00/8.00 cores)
capped_mult:  kv-capacity: 8.00 cores, kv-util: 50.00% (4.00/8.00 cores)
sql_model:    kv-capacity: 8.00 cores, kv-util: 50.00% (4.00/8.00 cores)

# Low utilization fallback: node CPU utilization is very low (< 1%).
# Naive model assumes 50% overhead and gives 4 cores capacity.
# Capped_mult gives 8 cores (half of node capacity per store) since it
# doesn't assume overhead.
compute store-load=0.1 node-cpu-usage=0.1 node-cpu-capacity=16 total-stores-cpu-usage=0.1 num-stores=2
----
              node-cpu-capacity/num-stores: 8.00 cores/store
naive:        kv-capacity: 4.00 cores, kv-util: 2.50% (0.10/4.00 cores)
capped_mult:  kv-capacity: 8.00 cores, kv-util: 1.25% (0.10/8.00 cores)
sql_model:    kv-capacity: 8.00 cores, kv-util: 1.25% (0.10/8.00 cores)

# StoresCPURate is zero: no replicas reporting CPU usage yet (startup or
# measurement lag). Node at 50% utilization, but stores haven't reported any
# CPU. Naive gives 8 cores. Capped_mult gives 2.67 cores (more conservative,
# assumes all node usage is background).
compute store-load=0 node-cpu-usage=8 node-cpu-capacity=16 total-stores-cpu-usage=0 num-stores=1
----
              node-cpu-capacity/num-stores: 16.00 cores/store
naive:        kv-capacity: 8.00 cores, kv-util: 0.00% (0.00/8.00 cores)
capped_mult:  kv-capacity: 2.67 cores, kv-util: 0.00% (0.00/2.67 cores)
sql_model:    kv-capacity: 5.33 cores, kv-util: 0.00% (0.00/5.33 cores)

# Unknown capacity: node CPU capacity is 0 (mixed version cluster or missing
# metrics). Both models fall back to assuming 50% utilization.
compute store-load=4 node-cpu-usage=8 node-cpu-capacity=0 total-stores-cpu-usage=4 num-stores=1
----
              node-cpu-capacity/num-stores: 0.00 cores/store
naive:        kv-capacity: 8.00 cores, kv-util: 50.00% (4.00/8.00 cores)
capped_mult:  kv-capacity: 8.00 cores, kv-util: 50.00% (4.00/8.00 cores)
sql_model:    kv-capacity: 8.00 cores, kv-util: 50.00% (4.00/8.00 cores)

# Invalid case: num-stores is 0 (should not happen in production).
# Both models return 0 capacity.
compute store-load=4 node-cpu-usage=8 node-cpu-capacity=16 total-stores-cpu-usage=4 num-stores=0
----
              node-cpu-capacity/num-stores: +Inf cores/store
naive:        kv-capacity: 0.00 cores, kv-util: +Inf% (4.00/0.00 cores)
capped_mult:  kv-capacity: 8.00 cores, kv-util: 50.00% (4.00/8.00 cores)
sql_model:    kv-capacity: 8.00 cores, kv-util: 50.00% (4.00/8.00 cores)

# ---------------------------------------------------------------------------
# Problems with the naive model
# ---------------------------------------------------------------------------
# The naive model assumes ALL node CPU usage is caused by store work, so
# store utilization always equals node utilization. When there is significant
# non-store CPU (SQL, GC, etc.), it assigns unrealistically low capacity,
# causing premature load shedding.

# Problem case 1: naive model over-attributes non-store CPU to stores.
# Store uses only 0.1 cores, but node uses 6.4 cores. 6.3 cores are from
# non-store work. Naive model: 0.25 cores capacity, store appears 40% utilized
# (matches node util). Capped_mult: 3.3 cores capacity, store appears 3%
# utilized (more realistic given only 0.1 cores actual usage).
# *** MAJOR DIFFERENCE: capped_mult is 13x better than naive/sql_model (3.3 vs 0.25 cores) ***
# Reasoning: Store using only 0.1 cores cannot be 40% utilized. Capped_mult correctly
# attributes most node CPU to background (GC, system work), preventing false overload alarms.
compute store-load=0.1 node-cpu-usage=6.4 node-cpu-capacity=16 total-stores-cpu-usage=0.1 num-stores=1
----
              node-cpu-capacity/num-stores: 16.00 cores/store
naive:        kv-capacity: 0.25 cores, kv-util: 40.00% (0.10/0.25 cores)
capped_mult:  kv-capacity: 3.30 cores, kv-util: 3.03% (0.10/3.30 cores)
sql_model:    kv-capacity: 0.25 cores, kv-util: 40.00% (0.10/0.25 cores)

# Problem case 2: naive model over-attributes non-store CPU in multi-store
# scenario. 4 stores using 1.0 cores total, but node uses 6.4 cores. 5.4 cores
# are non-store work. Fair share would be 4 cores per store. This store uses
# only 0.1 cores. Naive model: 0.62 cores capacity, store appears 16% utilized
# (inflated by non-store CPU). Capped_mult: 1.05 cores capacity, store appears
# 9.5% utilized (still conservative but better).
compute store-load=0.1 node-cpu-usage=6.4 node-cpu-capacity=16 total-stores-cpu-usage=1.0 num-stores=4
----
              node-cpu-capacity/num-stores: 4.00 cores/store
naive:        kv-capacity: 0.62 cores, kv-util: 16.00% (0.10/0.62 cores)
capped_mult:  kv-capacity: 1.05 cores, kv-util: 9.52% (0.10/1.05 cores)
sql_model:    kv-capacity: 0.62 cores, kv-util: 16.00% (0.10/0.62 cores)

# Overloaded node: node CPU usage exceeds capacity (nodeCPURateUsage > nodeCPURateCapacity).
# When backgroundLoad exceeds nodeCPURateCapacity, mmaShareOfCapacity would be negative
# without clamping. The fix clamps it to 0, resulting in 0 capacity (correct behavior).
compute store-load=1 node-cpu-usage=32 node-cpu-capacity=16 total-stores-cpu-usage=2 num-stores=1
----
              node-cpu-capacity/num-stores: 16.00 cores/store
naive:        kv-capacity: 1.00 cores, kv-util: 100.00% (1.00/1.00 cores)
capped_mult:  kv-capacity: 0.00 cores, kv-util: +Inf% (1.00/0.00 cores)
sql_model:    kv-capacity: 1.00 cores, kv-util: 100.00% (1.00/1.00 cores)

# ---------------------------------------------------------------------------
# SQL model test cases
# ---------------------------------------------------------------------------

# Example from PDF: SSCR=10, SQL_DIST=10, SQL_G=40, NCR=120, NCRC=150, N=1
# K1 = 120/(10+10+40) = 2.0, K2 = 10/10 = 1.0
# NodeCapacity = (150 - 40*2.0)/((1.0+1)*2.0) = 70/4 = 17.5
# This demonstrates how SQL model correctly attributes gateway SQL CPU as background.
compute store-load=10 node-cpu-usage=120 node-cpu-capacity=150 total-stores-cpu-usage=10 num-stores=1 sql-gateway-cpu=40 sql-dist-cpu=10
----
              node-cpu-capacity/num-stores: 150.00 cores/store
naive:        kv-capacity: 12.50 cores, kv-util: 80.00% (10.00/12.50 cores)
capped_mult:  kv-capacity: 20.00 cores, kv-util: 50.00% (10.00/20.00 cores)
sql_model:    kv-capacity: 17.50 cores, kv-util: 57.14% (10.00/17.50 cores)

# SQL model: Gateway SQL CPU is significant but distributed SQL is zero.
# Store uses 2 cores, gateway SQL uses 8 cores, node uses 12 cores total.
# K1 = 12/(2+0+8) = 1.2, K2 = 0/2 = 0
# NodeCapacity = (16 - 8*1.2)/((0+1)*1.2) = 6.4/1.2 = 5.33
# *** MAJOR DIFFERENCE: sql_model is 2x better than naive, 1.6x better than capped_mult ***
# Reasoning: Gateway SQL is background load (doesn't scale with store work). SQL model
# explicitly accounts for this, while naive/capped_mult incorrectly attribute gateway SQL
# to store work, causing false overload (75% vs 37.5% utilization).
compute store-load=2 node-cpu-usage=12 node-cpu-capacity=16 total-stores-cpu-usage=2 num-stores=1 sql-gateway-cpu=8 sql-dist-cpu=0
----
              node-cpu-capacity/num-stores: 16.00 cores/store
naive:        kv-capacity: 2.67 cores, kv-util: 75.00% (2.00/2.67 cores)
capped_mult:  kv-capacity: 3.33 cores, kv-util: 60.00% (2.00/3.33 cores)
sql_model:    kv-capacity: 5.33 cores, kv-util: 37.50% (2.00/5.33 cores)

# SQL model: Distributed SQL CPU scales with store work (K2=1.0).
# Store uses 4 cores, distributed SQL uses 4 cores (1:1 ratio), gateway uses 8 cores.
# K1 = 20/(4+4+8) = 1.25, K2 = 4/4 = 1.0
# NodeCapacity = (16 - 8*1.25)/((1.0+1)*1.25) = 6/2.5 = 2.4
compute store-load=4 node-cpu-usage=20 node-cpu-capacity=16 total-stores-cpu-usage=4 num-stores=1 sql-gateway-cpu=8 sql-dist-cpu=4
----
              node-cpu-capacity/num-stores: 16.00 cores/store
naive:        kv-capacity: 3.20 cores, kv-util: 125.00% (4.00/3.20 cores)
capped_mult:  kv-capacity: 2.67 cores, kv-util: 150.00% (4.00/2.67 cores)
sql_model:    kv-capacity: 2.40 cores, kv-util: 166.67% (4.00/2.40 cores)

# SQL model: Multi-store scenario with SQL CPU.
# 2 stores, each using 2 cores. Total stores CPU = 4, distributed SQL = 2, gateway = 6.
# K1 = 16/(4+2+6) = 1.33, K2 = 2/4 = 0.5
# NodeCapacity = (16 - 6*1.33)/((0.5+1)*1.33) = 8/2 = 4.0
# Per-store = 4.0/2 = 2.0
compute store-load=2 node-cpu-usage=16 node-cpu-capacity=16 total-stores-cpu-usage=4 num-stores=2 sql-gateway-cpu=6 sql-dist-cpu=2
----
              node-cpu-capacity/num-stores: 8.00 cores/store
naive:        kv-capacity: 2.00 cores, kv-util: 100.00% (2.00/2.00 cores)
capped_mult:  kv-capacity: 2.00 cores, kv-util: 100.00% (2.00/2.00 cores)
sql_model:    kv-capacity: 2.00 cores, kv-util: 100.00% (2.00/2.00 cores)

# SQL model: High distributed SQL overhead (K2 > 1).
# Store uses 2 cores, distributed SQL uses 6 cores (3:1 ratio), gateway uses 4 cores.
# K1 = 16/(2+6+4) = 1.33, K2 = 6/2 = 3.0
# NodeCapacity = (16 - 4*1.33)/((3.0+1)*1.33) = 10.67/5.33 = 2.0
compute store-load=2 node-cpu-usage=16 node-cpu-capacity=16 total-stores-cpu-usage=2 num-stores=1 sql-gateway-cpu=4 sql-dist-cpu=6
----
              node-cpu-capacity/num-stores: 16.00 cores/store
naive:        kv-capacity: 2.00 cores, kv-util: 100.00% (2.00/2.00 cores)
capped_mult:  kv-capacity: 2.00 cores, kv-util: 100.00% (2.00/2.00 cores)
sql_model:    kv-capacity: 2.00 cores, kv-util: 100.00% (2.00/2.00 cores)

# SQL model: Gateway SQL dominates, minimal store and distributed SQL.
# Store uses 0.5 cores, distributed SQL uses 0.5 cores, gateway uses 15 cores.
# K1 = 16/(0.5+0.5+15) = 1.0, K2 = 0.5/0.5 = 1.0
# NodeCapacity = (16 - 15*1.0)/((1.0+1)*1.0) = 1/2 = 0.5
compute store-load=0.5 node-cpu-usage=16 node-cpu-capacity=16 total-stores-cpu-usage=0.5 num-stores=1 sql-gateway-cpu=15 sql-dist-cpu=0.5
----
              node-cpu-capacity/num-stores: 16.00 cores/store
naive:        kv-capacity: 0.50 cores, kv-util: 100.00% (0.50/0.50 cores)
capped_mult:  kv-capacity: 0.50 cores, kv-util: 100.00% (0.50/0.50 cores)
sql_model:    kv-capacity: 0.50 cores, kv-util: 100.00% (0.50/0.50 cores)

# ---------------------------------------------------------------------------
# Extreme cases highlighting model differences
# ---------------------------------------------------------------------------

# Extreme case 1: Massive non-store CPU, minimal store work.
# Store uses 0.5 cores, but node uses 14 cores. 13.5 cores are non-store work.
# Naive/sql_model: 0.57 cores capacity (store appears 88% utilized - FALSE ALARM).
# Capped_mult: 4.67 cores capacity (store appears 11% utilized - more realistic).
# *** EXTREME DIFFERENCE: capped_mult is 8x better (4.67 vs 0.57 cores) ***
# Reasoning: Store is only using 0.5 cores, so 88% utilization is implausible.
# Capped_mult correctly attributes most node CPU to background, avoiding false overload.
compute store-load=0.5 node-cpu-usage=14 node-cpu-capacity=16 total-stores-cpu-usage=0.5 num-stores=1
----
              node-cpu-capacity/num-stores: 16.00 cores/store
naive:        kv-capacity: 0.57 cores, kv-util: 87.50% (0.50/0.57 cores)
capped_mult:  kv-capacity: 4.67 cores, kv-util: 10.71% (0.50/4.67 cores)
sql_model:    kv-capacity: 0.57 cores, kv-util: 87.50% (0.50/0.57 cores)

# Extreme case 2: High gateway SQL with moderate store work.
# Store uses 4 cores, gateway SQL uses 10 cores, distributed SQL uses 2 cores.
# Node uses 16 cores total. K1 = 16/(4+2+10) = 1.0, K2 = 2/4 = 0.5
# NodeCapacity = (16 - 10*1.0)/((0.5+1)*1.0) = 6/1.5 = 4.0
# Naive: 2.67 cores (150% util - FALSE OVERLOAD). Capped_mult: 2.67 cores (150% util).
# SQL model: 4.0 cores (100% util - more accurate, accounts for gateway SQL as background).
# *** SIGNIFICANT DIFFERENCE: sql_model is 1.5x better (4.0 vs 2.67 cores) ***
# Reasoning: Gateway SQL is known background load that doesn't scale with store work.
# SQL model explicitly accounts for this, while naive/capped_mult incorrectly attribute it to stores.
compute store-load=4 node-cpu-usage=16 node-cpu-capacity=16 total-stores-cpu-usage=4 num-stores=1 sql-gateway-cpu=10 sql-dist-cpu=2
----
              node-cpu-capacity/num-stores: 16.00 cores/store
naive:        kv-capacity: 2.67 cores, kv-util: 150.00% (4.00/2.67 cores)
capped_mult:  kv-capacity: 2.67 cores, kv-util: 150.00% (4.00/2.67 cores)
sql_model:    kv-capacity: 4.00 cores, kv-util: 100.00% (4.00/4.00 cores)

# Extreme case 3: Multi-store with high non-store CPU.
# 3 stores using 0.2 cores each (0.6 total), but node uses 12 cores.
# 11.4 cores are non-store work. Fair share would be 5.33 cores per store.
# Naive/sql_model: 0.53 cores capacity (store appears 38% utilized - FALSE ALARM).
# Capped_mult: 1.33 cores capacity (store appears 15% utilized - more realistic).
# *** SIGNIFICANT DIFFERENCE: capped_mult is 2.5x better (1.33 vs 0.53 cores) ***
# Reasoning: Store using only 0.2 cores cannot be 38% utilized. Capped_mult correctly
# attributes most node CPU to background, giving more realistic utilization estimate.
compute store-load=0.2 node-cpu-usage=12 node-cpu-capacity=16 total-stores-cpu-usage=0.6 num-stores=3
----
              node-cpu-capacity/num-stores: 5.33 cores/store
naive:        kv-capacity: 0.53 cores, kv-util: 37.50% (0.20/0.53 cores)
capped_mult:  kv-capacity: 1.33 cores, kv-util: 15.00% (0.20/1.33 cores)
sql_model:    kv-capacity: 0.53 cores, kv-util: 37.50% (0.20/0.53 cores)
