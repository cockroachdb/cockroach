# All CPU values are in cores (1 core = 1e9 ns/s).

# Normal case: single store on a node. All node CPU usage comes from store work.
# Node is at 50% utilization.
compute store-load=8 node-cpu-usage=8 node-cpu-capacity=16 total-stores-cpu-usage=8 num-stores=1
----
              node-cpu-capacity/num-stores: 16.00 cores/store
naive:        kv-capacity: 16.00 cores, kv-util: 50.00% (8.00/16.00 cores)
capped_mult: (steps below)
  mult        = max(1, min(8.00/8.00, 3)) = 1.0
  background  = max(0, 8.00 - 8.00*1.0) = 0.00 cores
  mma-share   = 16.00 - 0.00 = 16.00 cores
  mma-direct  = 16.00 / 1.0 = 16.00 cores
  per-store   = 16.00 / 1 = 16.00 cores
  kv-capacity: 16.00 cores, kv-util: 50.00% (8.00/16.00 cores)

# Normal case: 2 stores on a node with uneven load. Node at 80% utilization, all
# from store work. This store uses 7 cores, other uses 3. This store at 112%
# util will shed load to other at 48%.
compute store-load=7 node-cpu-usage=12.8 node-cpu-capacity=16 total-stores-cpu-usage=10 num-stores=2
----
              node-cpu-capacity/num-stores: 8.00 cores/store
naive:        kv-capacity: 6.25 cores, kv-util: 112.00% (7.00/6.25 cores)
capped_mult: (steps below)
  mult        = max(1, min(12.80/10.00, 3)) = 1.3
  background  = max(0, 12.80 - 10.00*1.3) = 0.00 cores
  mma-share   = 16.00 - 0.00 = 16.00 cores
  mma-direct  = 16.00 / 1.3 = 12.50 cores
  per-store   = 12.50 / 2 = 6.25 cores
  kv-capacity: 6.25 cores, kv-util: 112.00% (7.00/6.25 cores)

# Measurement lag: stores report more CPU than node is using (implicit mult < 1).
# This can happen due to timing differences in measurement collection. The
# implicit multiplier would be 0.5 (= 4/8), but it gets clamped to 1.0.
compute store-load=4 node-cpu-usage=4 node-cpu-capacity=16 total-stores-cpu-usage=8 num-stores=1
----
              node-cpu-capacity/num-stores: 16.00 cores/store
naive:        kv-capacity: 32.00 cores, kv-util: 12.50% (4.00/32.00 cores)
capped_mult: (steps below)
  mult        = max(1, min(4.00/8.00, 3)) = 1.0
  background  = max(0, 4.00 - 8.00*1.0) = 0.00 cores
  mma-share   = 16.00 - 0.00 = 16.00 cores
  mma-direct  = 16.00 / 1.0 = 16.00 cores
  per-store   = 16.00 / 1 = 16.00 cores
  kv-capacity: 16.00 cores, kv-util: 25.00% (4.00/16.00 cores)

# Moderate indirect overhead: stores use 4 cores, node uses 8 cores (2x overhead).
# Implicit multiplier is 2.0 (= 8/4), which is between 1 and 3, so it's used
# directly. This represents moderate indirect CPU overhead (RPC, compactions, etc.).
compute store-load=2 node-cpu-usage=8 node-cpu-capacity=16 total-stores-cpu-usage=4 num-stores=1
----
              node-cpu-capacity/num-stores: 16.00 cores/store
naive:        kv-capacity: 8.00 cores, kv-util: 25.00% (2.00/8.00 cores)
capped_mult: (steps below)
  mult        = max(1, min(8.00/4.00, 3)) = 2.0
  background  = max(0, 8.00 - 4.00*2.0) = 0.00 cores
  mma-share   = 16.00 - 0.00 = 16.00 cores
  mma-direct  = 16.00 / 2.0 = 8.00 cores
  per-store   = 8.00 / 1 = 8.00 cores
  kv-capacity: 8.00 cores, kv-util: 25.00% (2.00/8.00 cores)

# Low utilization fallback: node CPU utilization is very low (< 1%).
# Naive model assumes 50% overhead and gives 4 cores capacity.
# Capped_mult gives 8 cores (half of node capacity per store) since it
# doesn't assume overhead.
compute store-load=0.1 node-cpu-usage=0.1 node-cpu-capacity=16 total-stores-cpu-usage=0.1 num-stores=2
----
              node-cpu-capacity/num-stores: 8.00 cores/store
naive:        kv-capacity: 4.00 cores, kv-util: 2.50% (0.10/4.00 cores)
capped_mult: (steps below)
  mult        = max(1, min(0.10/0.10, 3)) = 1.0
  background  = max(0, 0.10 - 0.10*1.0) = 0.00 cores
  mma-share   = 16.00 - 0.00 = 16.00 cores
  mma-direct  = 16.00 / 1.0 = 16.00 cores
  per-store   = 16.00 / 2 = 8.00 cores
  kv-capacity: 8.00 cores, kv-util: 1.25% (0.10/8.00 cores)

# StoresCPURate is zero: no replicas reporting CPU usage yet (startup or
# measurement lag). Node at 50% utilization, but stores haven't reported any
# CPU. Naive gives 8 cores. Capped_mult gives 2.67 cores (more conservative,
# assumes all node usage is background).
compute store-load=0 node-cpu-usage=8 node-cpu-capacity=16 total-stores-cpu-usage=0 num-stores=1
----
              node-cpu-capacity/num-stores: 16.00 cores/store
naive:        kv-capacity: 8.00 cores, kv-util: 0.00% (0.00/8.00 cores)
capped_mult: (steps below)
  mult        = max(1, min(8.00/0.00, 3)) = 3.0
  background  = max(0, 8.00 - 0.00*3.0) = 8.00 cores
  mma-share   = 16.00 - 8.00 = 8.00 cores
  mma-direct  = 8.00 / 3.0 = 2.67 cores
  per-store   = 2.67 / 1 = 2.67 cores
  kv-capacity: 2.67 cores, kv-util: 0.00% (0.00/2.67 cores)

# Unknown capacity: node CPU capacity is 0 (mixed version cluster or missing
# metrics). Both models fall back to assuming 50% utilization.
compute store-load=4 node-cpu-usage=8 node-cpu-capacity=0 total-stores-cpu-usage=4 num-stores=1
----
              node-cpu-capacity/num-stores: 0.00 cores/store
naive:        kv-capacity: 8.00 cores, kv-util: 50.00% (4.00/8.00 cores)
capped_mult: (node-cpu-capacity unknown, assuming 50% util)
  kv-capacity: 8.00 cores, kv-util: 50.00% (4.00/8.00 cores)

# Invalid case: num-stores is 0 (should not happen in production).
# Both models return 0 capacity.
compute store-load=4 node-cpu-usage=8 node-cpu-capacity=16 total-stores-cpu-usage=4 num-stores=0
----
              node-cpu-capacity/num-stores: +Inf cores/store
naive:        kv-capacity: 0.00 cores, kv-util: +Inf% (4.00/0.00 cores)
capped_mult: (early return: num-stores=0)
  kv-capacity: 8.00 cores, kv-util: 50.00% (4.00/8.00 cores)

# ---------------------------------------------------------------------------
# Problems with the naive model
# ---------------------------------------------------------------------------
# The naive model assumes ALL node CPU usage is caused by store work, so
# store utilization always equals node utilization. When there is significant
# non-store CPU (SQL, GC, etc.), it assigns unrealistically low capacity,
# causing premature load shedding.

# Problem case 1: naive model over-attributes non-store CPU to stores.
# Store uses only 0.1 cores, but node uses 6.4 cores. 6.3 cores are from
# non-store work. Naive model: 0.25 cores capacity, store appears 40% utilized
# (matches node util). Capped_mult: 3.3 cores capacity, store appears 3%
# utilized (correctly low).
compute store-load=0.1 node-cpu-usage=6.4 node-cpu-capacity=16 total-stores-cpu-usage=0.1 num-stores=1
----
              node-cpu-capacity/num-stores: 16.00 cores/store
naive:        kv-capacity: 0.25 cores, kv-util: 40.00% (0.10/0.25 cores)
capped_mult: (steps below)
  mult        = max(1, min(6.40/0.10, 3)) = 3.0
  background  = max(0, 6.40 - 0.10*3.0) = 6.10 cores
  mma-share   = 16.00 - 6.10 = 9.90 cores
  mma-direct  = 9.90 / 3.0 = 3.30 cores
  per-store   = 3.30 / 1 = 3.30 cores
  kv-capacity: 3.30 cores, kv-util: 3.03% (0.10/3.30 cores)

# Problem case 2: naive model over-attributes non-store CPU in multi-store
# scenario. 4 stores using 1.0 cores total, but node uses 6.4 cores. 5.4 cores
# are non-store work. Fair share would be 4 cores per store. This store uses
# only 0.1 cores. Naive model: 0.62 cores capacity, store appears 16% utilized
# (inflated by non-store CPU). Capped_mult: 1.05 cores capacity, store appears
# 9.5% utilized (still conservative but better).
compute store-load=0.1 node-cpu-usage=6.4 node-cpu-capacity=16 total-stores-cpu-usage=1.0 num-stores=4
----
              node-cpu-capacity/num-stores: 4.00 cores/store
naive:        kv-capacity: 0.62 cores, kv-util: 16.00% (0.10/0.62 cores)
capped_mult: (steps below)
  mult        = max(1, min(6.40/1.00, 3)) = 3.0
  background  = max(0, 6.40 - 1.00*3.0) = 3.40 cores
  mma-share   = 16.00 - 3.40 = 12.60 cores
  mma-direct  = 12.60 / 3.0 = 4.20 cores
  per-store   = 4.20 / 4 = 1.05 cores
  kv-capacity: 1.05 cores, kv-util: 9.52% (0.10/1.05 cores)

# Overloaded node: node CPU usage exceeds capacity (nodeCPURateUsage > nodeCPURateCapacity).
# When backgroundLoad exceeds nodeCPURateCapacity, mmaShareOfCapacity would be negative
# without clamping. The fix clamps it to 0, resulting in 0 capacity (correct behavior).
compute store-load=1 node-cpu-usage=32 node-cpu-capacity=16 total-stores-cpu-usage=2 num-stores=1
----
              node-cpu-capacity/num-stores: 16.00 cores/store
naive:        kv-capacity: 1.00 cores, kv-util: 100.00% (1.00/1.00 cores)
capped_mult: (steps below)
  mult        = max(1, min(32.00/2.00, 3)) = 3.0
  background  = max(0, 32.00 - 2.00*3.0) = 26.00 cores
  mma-share   = max(0, 16.00 - 26.00) = 0.00 cores
  mma-direct  = 0.00 / 3.0 = 0.00 cores
  per-store   = 0.00 / 1 = 0.00 cores
  kv-capacity: 0.00 cores, kv-util: N/A (1.00/0.00 cores)
