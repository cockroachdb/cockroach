// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: kv/kvserver/kvserverpb/proposer_kv.proto

package kvserverpb

import (
	bytes "bytes"
	fmt "fmt"
	rspb "github.com/cockroachdb/cockroach/pkg/kv/kvserver/readsummary/rspb"
	github_com_cockroachdb_cockroach_pkg_roachpb "github.com/cockroachdb/cockroach/pkg/roachpb"
	roachpb "github.com/cockroachdb/cockroach/pkg/roachpb"
	enginepb "github.com/cockroachdb/cockroach/pkg/storage/enginepb"
	github_com_cockroachdb_cockroach_pkg_util_hlc "github.com/cockroachdb/cockroach/pkg/util/hlc"
	hlc "github.com/cockroachdb/cockroach/pkg/util/hlc"
	github_com_cockroachdb_cockroach_pkg_util_uuid "github.com/cockroachdb/cockroach/pkg/util/uuid"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	github_com_gogo_protobuf_sortkeys "github.com/gogo/protobuf/sortkeys"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// Split is emitted when a Replica commits a split trigger. It signals that the
// Replica has prepared the on-disk state for both the left and right hand
// sides of the split, and that the left hand side Replica should be updated as
// well as the right hand side created.
type Split struct {
	roachpb.SplitTrigger `protobuf:"bytes,1,opt,name=trigger,proto3,embedded=trigger" json:"trigger"`
	// RHSDelta holds the statistics for what was written to what is now the
	// right-hand side of the split during the batch which executed it.
	// The on-disk state of the right-hand side is already correct, but the
	// Store must learn about this delta to update its counters appropriately.
	RHSDelta enginepb.MVCCStats `protobuf:"bytes,2,opt,name=rhs_delta,json=rhsDelta,proto3" json:"rhs_delta"`
}

func (m *Split) Reset()         { *m = Split{} }
func (m *Split) String() string { return proto.CompactTextString(m) }
func (*Split) ProtoMessage()    {}
func (*Split) Descriptor() ([]byte, []int) {
	return fileDescriptor_19df0b186dd19269, []int{0}
}
func (m *Split) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Split) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *Split) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Split.Merge(m, src)
}
func (m *Split) XXX_Size() int {
	return m.Size()
}
func (m *Split) XXX_DiscardUnknown() {
	xxx_messageInfo_Split.DiscardUnknown(m)
}

var xxx_messageInfo_Split proto.InternalMessageInfo

// Merge is emitted by a Replica which commits a transaction with
// a MergeTrigger (i.e. absorbs its right neighbor).
type Merge struct {
	roachpb.MergeTrigger `protobuf:"bytes,1,opt,name=trigger,proto3,embedded=trigger" json:"trigger"`
}

func (m *Merge) Reset()         { *m = Merge{} }
func (m *Merge) String() string { return proto.CompactTextString(m) }
func (*Merge) ProtoMessage()    {}
func (*Merge) Descriptor() ([]byte, []int) {
	return fileDescriptor_19df0b186dd19269, []int{1}
}
func (m *Merge) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Merge) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *Merge) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Merge.Merge(m, src)
}
func (m *Merge) XXX_Size() int {
	return m.Size()
}
func (m *Merge) XXX_DiscardUnknown() {
	xxx_messageInfo_Merge.DiscardUnknown(m)
}

var xxx_messageInfo_Merge proto.InternalMessageInfo

// ChangeReplicas is emitted by a Replica which commits a transaction with
// a ChangeReplicasTrigger.
type ChangeReplicas struct {
	roachpb.ChangeReplicasTrigger `protobuf:"bytes,1,opt,name=trigger,proto3,embedded=trigger" json:"trigger"`
}

func (m *ChangeReplicas) Reset()      { *m = ChangeReplicas{} }
func (*ChangeReplicas) ProtoMessage() {}
func (*ChangeReplicas) Descriptor() ([]byte, []int) {
	return fileDescriptor_19df0b186dd19269, []int{2}
}
func (m *ChangeReplicas) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ChangeReplicas) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ChangeReplicas) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ChangeReplicas.Merge(m, src)
}
func (m *ChangeReplicas) XXX_Size() int {
	return m.Size()
}
func (m *ChangeReplicas) XXX_DiscardUnknown() {
	xxx_messageInfo_ChangeReplicas.DiscardUnknown(m)
}

var xxx_messageInfo_ChangeReplicas proto.InternalMessageInfo

// ComputeChecksum is emitted when a ComputeChecksum request is evaluated. It
// instructs the replica to compute a checksum at the time the command is
// applied.
type ComputeChecksum struct {
	// ChecksumID is a handle by which the checksum can be retrieved in a later
	// CollectChecksum request.
	ChecksumID github_com_cockroachdb_cockroach_pkg_util_uuid.UUID `protobuf:"bytes,1,opt,name=checksum_id,json=checksumId,proto3,customtype=github.com/cockroachdb/cockroach/pkg/util/uuid.UUID" json:"checksum_id"`
	// The version used to pick the checksum method. Only when the version matches
	// that hardcoded in the binary will a computation be carried out.
	Version uint32 `protobuf:"varint,5,opt,name=version,proto3" json:"version,omitempty"`
	// SaveSnapshot indicates that the snapshot used to compute the checksum
	// should be saved so that a diff of divergent replicas can later be computed.
	SaveSnapshot bool                 `protobuf:"varint,2,opt,name=save_snapshot,json=saveSnapshot,proto3" json:"save_snapshot,omitempty"`
	Mode         roachpb.ChecksumMode `protobuf:"varint,3,opt,name=mode,proto3,enum=cockroach.roachpb.ChecksumMode" json:"mode,omitempty"`
	// If set, a checkpoint (i.e. cheap backup) of the engine will be taken. This
	// is expected to be set only if we already know that there is an
	// inconsistency and we want to preserve as much state as possible.
	Checkpoint bool `protobuf:"varint,4,opt,name=checkpoint,proto3" json:"checkpoint,omitempty"`
	// Replicas processing this command which find themselves in this slice will
	// terminate. See `CheckConsistencyRequest.Terminate`.
	Terminate []roachpb.ReplicaDescriptor `protobuf:"bytes,6,rep,name=terminate,proto3" json:"terminate"`
}

func (m *ComputeChecksum) Reset()         { *m = ComputeChecksum{} }
func (m *ComputeChecksum) String() string { return proto.CompactTextString(m) }
func (*ComputeChecksum) ProtoMessage()    {}
func (*ComputeChecksum) Descriptor() ([]byte, []int) {
	return fileDescriptor_19df0b186dd19269, []int{3}
}
func (m *ComputeChecksum) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ComputeChecksum) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ComputeChecksum) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ComputeChecksum.Merge(m, src)
}
func (m *ComputeChecksum) XXX_Size() int {
	return m.Size()
}
func (m *ComputeChecksum) XXX_DiscardUnknown() {
	xxx_messageInfo_ComputeChecksum.DiscardUnknown(m)
}

var xxx_messageInfo_ComputeChecksum proto.InternalMessageInfo

// Compaction holds core details about a suggested compaction.
type Compaction struct {
	// bytes indicates the expected space reclamation from compaction.
	Bytes int64 `protobuf:"varint,1,opt,name=bytes,proto3" json:"bytes,omitempty"`
	// suggested_at is nanoseconds since the epoch.
	SuggestedAtNanos int64 `protobuf:"varint,2,opt,name=suggested_at_nanos,json=suggestedAtNanos,proto3" json:"suggested_at_nanos,omitempty"`
}

func (m *Compaction) Reset()         { *m = Compaction{} }
func (m *Compaction) String() string { return proto.CompactTextString(m) }
func (*Compaction) ProtoMessage()    {}
func (*Compaction) Descriptor() ([]byte, []int) {
	return fileDescriptor_19df0b186dd19269, []int{4}
}
func (m *Compaction) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Compaction) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *Compaction) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Compaction.Merge(m, src)
}
func (m *Compaction) XXX_Size() int {
	return m.Size()
}
func (m *Compaction) XXX_DiscardUnknown() {
	xxx_messageInfo_Compaction.DiscardUnknown(m)
}

var xxx_messageInfo_Compaction proto.InternalMessageInfo

// SuggestedCompaction holds start and end keys in conjunction with
// the compaction details.
type SuggestedCompaction struct {
	StartKey   github_com_cockroachdb_cockroach_pkg_roachpb.Key `protobuf:"bytes,1,opt,name=start_key,json=startKey,proto3,casttype=github.com/cockroachdb/cockroach/pkg/roachpb.Key" json:"start_key,omitempty"`
	EndKey     github_com_cockroachdb_cockroach_pkg_roachpb.Key `protobuf:"bytes,2,opt,name=end_key,json=endKey,proto3,casttype=github.com/cockroachdb/cockroach/pkg/roachpb.Key" json:"end_key,omitempty"`
	Compaction `protobuf:"bytes,3,opt,name=compaction,proto3,embedded=compaction" json:"compaction"`
}

func (m *SuggestedCompaction) Reset()         { *m = SuggestedCompaction{} }
func (m *SuggestedCompaction) String() string { return proto.CompactTextString(m) }
func (*SuggestedCompaction) ProtoMessage()    {}
func (*SuggestedCompaction) Descriptor() ([]byte, []int) {
	return fileDescriptor_19df0b186dd19269, []int{5}
}
func (m *SuggestedCompaction) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SuggestedCompaction) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *SuggestedCompaction) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SuggestedCompaction.Merge(m, src)
}
func (m *SuggestedCompaction) XXX_Size() int {
	return m.Size()
}
func (m *SuggestedCompaction) XXX_DiscardUnknown() {
	xxx_messageInfo_SuggestedCompaction.DiscardUnknown(m)
}

var xxx_messageInfo_SuggestedCompaction proto.InternalMessageInfo

// ReplicatedEvalResult is the structured information which together with a
// RocksDB WriteBatch constitutes the proposal payload.
// For the majority of proposals, we expect ReplicatedEvalResult to be
// trivial; only changes to the metadata state (splits, merges, rebalances,
// leases, log truncation, ...) of the Replica or certain special commands must
// sideline information here based on which all Replicas must take action.
type ReplicatedEvalResult struct {
	// Updates to the Replica's ReplicaState. By convention and as outlined on
	// the comment on the ReplicaState message, this field is sparsely populated
	// and any field set overwrites the corresponding field in the state, perhaps
	// with additional side effects (for instance on a descriptor update).
	State           *ReplicaState    `protobuf:"bytes,2,opt,name=state,proto3" json:"state,omitempty"`
	Split           *Split           `protobuf:"bytes,3,opt,name=split,proto3" json:"split,omitempty"`
	Merge           *Merge           `protobuf:"bytes,4,opt,name=merge,proto3" json:"merge,omitempty"`
	ComputeChecksum *ComputeChecksum `protobuf:"bytes,21,opt,name=compute_checksum,json=computeChecksum,proto3" json:"compute_checksum,omitempty"`
	IsLeaseRequest  bool             `protobuf:"varint,6,opt,name=is_lease_request,json=isLeaseRequest,proto3" json:"is_lease_request,omitempty"`
	// The timestamp at which this command is writing. Used to verify the validity
	// of the command against the GC threshold and to update the followers'
	// clocks. If the request that produced this command is not a write that cares
	// about the timestamp cache, then the request's write timestamp is
	// meaningless; for such request's, this field is simply a clock reading from
	// the proposer.
	WriteTimestamp hlc.Timestamp `protobuf:"bytes,8,opt,name=write_timestamp,json=writeTimestamp,proto3" json:"write_timestamp"`
	// The stats delta corresponding to the data in this WriteBatch. On
	// a split, contains only the contributions to the left-hand side.
	DeprecatedDelta *enginepb.MVCCStats              `protobuf:"bytes,10,opt,name=deprecated_delta,json=deprecatedDelta,proto3" json:"deprecated_delta,omitempty"`
	Delta           enginepb.MVCCStatsDelta          `protobuf:"bytes,18,opt,name=delta,proto3" json:"delta"`
	ChangeReplicas  *ChangeReplicas                  `protobuf:"bytes,12,opt,name=change_replicas,json=changeReplicas,proto3" json:"change_replicas,omitempty"`
	RaftLogDelta    int64                            `protobuf:"varint,13,opt,name=raft_log_delta,json=raftLogDelta,proto3" json:"raft_log_delta,omitempty"`
	AddSSTable      *ReplicatedEvalResult_AddSSTable `protobuf:"bytes,17,opt,name=add_sstable,json=addSstable,proto3" json:"add_sstable,omitempty"`
	// This is the proposal timestamp for the active lease while evaluating a lease request.
	// It will be used to make sure we know if a lease was extended after we sent out the request
	// but before we tried to apply it.
	PrevLeaseProposal *github_com_cockroachdb_cockroach_pkg_util_hlc.ClockTimestamp `protobuf:"bytes,20,opt,name=prev_lease_proposal,json=prevLeaseProposal,proto3,casttype=github.com/cockroachdb/cockroach/pkg/util/hlc.ClockTimestamp" json:"prev_lease_proposal,omitempty"`
	// PriorReadSummary is a summary of the reads that have been served on the
	// range prior to this proposal, which must be a lease change (request or
	// transfer) if the field is set. The read summary is used to update the new
	// leaseholder's timestamp cache to prevent them from serving writes that
	// violate previously served reads.
	//
	// The summary, when available, can be used in place of bumping the new
	// leaseholder's timestamp cache to the new lease's start time. It has two
	// distinct advantages:
	// 1. it can transfer a higher-resolution snapshot of the reads on the range
	//    through a lease transfer, to make the lease transfers less disruptive to
	//    writes because the timestamp cache won't be bumped as high.
	// 2. it can transfer information about reads with synthetic timestamps, which
	//    are not otherwise captured by the new lease's start time.
	//
	// When a ReadSummary is set in a ReplicatedEvalResult, there is always also a
	// write to the RangePriorReadSummaryKey in the RaftCommand.WriteBatch. The
	// persisted summary may be identical to the summary in this field, but it
	// does not have to be. Notably, we intended for the summary included in the
	// ReplicatedEvalResult to eventually be a much higher-resolution version of
	// the ReadSummmary than the version persisted. This scheme of persisting a
	// compressed ReadSummary indefinitely and including a higher-resolution
	// ReadSummary on the RaftCommand allows us to optimize for the common case
	// where the lease transfer is applied on the new leaseholder through Raft log
	// application while ensuring correctness in the case where the lease transfer
	// is applied on the new leaseholder through a Raft snapshot.
	PriorReadSummary *rspb.ReadSummary `protobuf:"bytes,22,opt,name=prior_read_summary,json=priorReadSummary,proto3" json:"prior_read_summary,omitempty"`
}

func (m *ReplicatedEvalResult) Reset()         { *m = ReplicatedEvalResult{} }
func (m *ReplicatedEvalResult) String() string { return proto.CompactTextString(m) }
func (*ReplicatedEvalResult) ProtoMessage()    {}
func (*ReplicatedEvalResult) Descriptor() ([]byte, []int) {
	return fileDescriptor_19df0b186dd19269, []int{6}
}
func (m *ReplicatedEvalResult) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReplicatedEvalResult) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ReplicatedEvalResult) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReplicatedEvalResult.Merge(m, src)
}
func (m *ReplicatedEvalResult) XXX_Size() int {
	return m.Size()
}
func (m *ReplicatedEvalResult) XXX_DiscardUnknown() {
	xxx_messageInfo_ReplicatedEvalResult.DiscardUnknown(m)
}

var xxx_messageInfo_ReplicatedEvalResult proto.InternalMessageInfo

// AddSSTable is a side effect that must execute before the Raft application
// is committed. It must be idempotent to account for an ill-timed crash after
// applying the side effect, but before committing the batch.
//
// TODO(tschottdorf): additionally, after the crash, the node must not serve
// traffic until the persisted committed log has fully applied. Otherwise, we
// risk exposing data created through such a side effect whose corresponding
// Raft command hasn't committed yet. This isn't so much an issue with AddSSTable
// since these Ranges are not user-visible, but it is a general concern assuming
// other such side effects are added.
type ReplicatedEvalResult_AddSSTable struct {
	Data          []byte       `protobuf:"bytes,1,opt,name=data,proto3" json:"data,omitempty"`
	CRC32         uint32       `protobuf:"varint,2,opt,name=crc32,proto3" json:"crc32,omitempty"`
	Span          roachpb.Span `protobuf:"bytes,3,opt,name=span,proto3" json:"span"`
	EmitRangefeed bool         `protobuf:"varint,4,opt,name=emit_rangefeed,json=emitRangefeed,proto3" json:"emit_rangefeed,omitempty"`
}

func (m *ReplicatedEvalResult_AddSSTable) Reset()         { *m = ReplicatedEvalResult_AddSSTable{} }
func (m *ReplicatedEvalResult_AddSSTable) String() string { return proto.CompactTextString(m) }
func (*ReplicatedEvalResult_AddSSTable) ProtoMessage()    {}
func (*ReplicatedEvalResult_AddSSTable) Descriptor() ([]byte, []int) {
	return fileDescriptor_19df0b186dd19269, []int{6, 0}
}
func (m *ReplicatedEvalResult_AddSSTable) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReplicatedEvalResult_AddSSTable) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ReplicatedEvalResult_AddSSTable) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReplicatedEvalResult_AddSSTable.Merge(m, src)
}
func (m *ReplicatedEvalResult_AddSSTable) XXX_Size() int {
	return m.Size()
}
func (m *ReplicatedEvalResult_AddSSTable) XXX_DiscardUnknown() {
	xxx_messageInfo_ReplicatedEvalResult_AddSSTable.DiscardUnknown(m)
}

var xxx_messageInfo_ReplicatedEvalResult_AddSSTable proto.InternalMessageInfo

// WriteBatch is the serialized representation of a RocksDB write
// batch. A wrapper message is used so that the absence of the field
// can be distinguished from a zero-length batch, and so structs
// containing pointers to it can be compared with the == operator.
type WriteBatch struct {
	Data []byte `protobuf:"bytes,1,opt,name=data,proto3" json:"data,omitempty"`
}

func (m *WriteBatch) Reset()         { *m = WriteBatch{} }
func (m *WriteBatch) String() string { return proto.CompactTextString(m) }
func (*WriteBatch) ProtoMessage()    {}
func (*WriteBatch) Descriptor() ([]byte, []int) {
	return fileDescriptor_19df0b186dd19269, []int{7}
}
func (m *WriteBatch) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WriteBatch) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *WriteBatch) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WriteBatch.Merge(m, src)
}
func (m *WriteBatch) XXX_Size() int {
	return m.Size()
}
func (m *WriteBatch) XXX_DiscardUnknown() {
	xxx_messageInfo_WriteBatch.DiscardUnknown(m)
}

var xxx_messageInfo_WriteBatch proto.InternalMessageInfo

// LogicalOpLog is a log of logical MVCC operations. A wrapper message
// is used so that the absence of the field can be distinguished from a
// zero-length batch, and so structs containing pointers to it can be
// compared with the == operator.
type LogicalOpLog struct {
	Ops []enginepb.MVCCLogicalOp `protobuf:"bytes,1,rep,name=ops,proto3" json:"ops"`
}

func (m *LogicalOpLog) Reset()         { *m = LogicalOpLog{} }
func (m *LogicalOpLog) String() string { return proto.CompactTextString(m) }
func (*LogicalOpLog) ProtoMessage()    {}
func (*LogicalOpLog) Descriptor() ([]byte, []int) {
	return fileDescriptor_19df0b186dd19269, []int{8}
}
func (m *LogicalOpLog) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LogicalOpLog) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *LogicalOpLog) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LogicalOpLog.Merge(m, src)
}
func (m *LogicalOpLog) XXX_Size() int {
	return m.Size()
}
func (m *LogicalOpLog) XXX_DiscardUnknown() {
	xxx_messageInfo_LogicalOpLog.DiscardUnknown(m)
}

var xxx_messageInfo_LogicalOpLog proto.InternalMessageInfo

// RaftCommand is the message written to the raft log. It contains some metadata
// about the proposal itself and a ReplicatedEvalResult + WriteBatch
type RaftCommand struct {
	// proposer_lease_seq is provided to verify at raft command apply-time
	// that the lease under which the command was proposed remains in effect.
	//
	// To see why lease verification downstream of Raft is required, consider the
	// following example:
	// - replica 1 receives a client request for a write
	// - replica 1 checks the lease; the write is permitted
	// - replica 1 proposes the command
	// - time passes, replica 2 commits a new lease
	// - the command applies on replica 1
	// - replica 2 serves anomalous reads which don't see the write
	// - the command applies on replica 2
	ProposerLeaseSequence github_com_cockroachdb_cockroach_pkg_roachpb.LeaseSequence `protobuf:"varint,6,opt,name=proposer_lease_sequence,json=proposerLeaseSequence,proto3,casttype=github.com/cockroachdb/cockroach/pkg/roachpb.LeaseSequence" json:"proposer_lease_sequence,omitempty"`
	// deprecated_proposer_lease served the same purpose as proposer_lease_seq.
	// As of VersionLeaseSequence, it is no longer in use.
	//
	// However, unless we add a check that all existing Raft logs on all nodes
	// in the cluster contain only "new" leases, we won't be able to remove the
	// legacy code.
	DeprecatedProposerLease *roachpb.Lease `protobuf:"bytes,5,opt,name=deprecated_proposer_lease,json=deprecatedProposerLease,proto3" json:"deprecated_proposer_lease,omitempty"`
	// When the command is applied, its result is an error if the lease log
	// counter has already reached (or exceeded) max_lease_index.
	//
	// The lease index is a reorder protection mechanism - we don't want Raft
	// commands (proposed by a single node, the one with proposer_lease) executing
	// in a different order than the one in which the corresponding KV requests
	// were evaluated and the commands were proposed. This is important because
	// latching does not fully serialize commands - mostly when it comes to
	// updates to the internal state of the range (this should be re-evaluated
	// once proposer-evaluated KV is completed - see #10413).
	// Similar to the Raft applied index, it is strictly increasing, but may have
	// gaps. A command will only apply successfully if its max_lease_index has not
	// been surpassed by the Range's applied lease index (in which case the
	// command may need to be retried, that is, regenerated with a higher
	// max_lease_index). When the command applies, the new lease index will
	// increase to max_lease_index (so a potential later replay will fail).
	//
	// This mechanism was introduced as a simpler alternative to using the Raft
	// applied index, which is fraught with complexity due to the need to predict
	// exactly the log position at which a command will apply, even when the Raft
	// leader is not colocated with the lease holder (which usually proposes all
	// commands).
	//
	// Pinning the lease-index to the assigned slot (as opposed to allowing gaps
	// as we do now) is an interesting venue to explore from the standpoint of
	// parallelization: One could hope to enforce command ordering in that way
	// (without recourse to a higher-level locking primitive such as the command
	// queue). This is a hard problem: First of all, managing the pending
	// commands gets more involved; a command must not be removed if others have
	// been added after it, and on removal, the assignment counters must be
	// updated accordingly. Managing retry of proposals becomes trickier as
	// well as that uproots whatever ordering was originally envisioned.
	//
	// This field is set through MaxLeaseFooter hackery. Unlike with the
	// ClosedTimestamp, which needs to be nullable in this proto (see comment),
	// there are no nullability concerns with this field. This is because
	// max_lease_index is a primitive type, so it does not get encoded when zero.
	// This alone ensures that the field is not encoded twice in the combined
	// RaftCommand+MaxLeaseFooter proto.
	MaxLeaseIndex uint64 `protobuf:"varint,4,opt,name=max_lease_index,json=maxLeaseIndex,proto3" json:"max_lease_index,omitempty"`
	// The closed timestamp carried by this command. Once a follower is told to
	// apply this command, it knows that there will be no further writes at
	// timestamps <= closed_timestamp. Note that the command itself might
	// represent a write at a lower timestamp, so the closed timestamp can only be
	// used after this command is applied.
	//
	// The field can be zero, which is to be interpreted as no closed timestamp
	// update. If the value is not zero, the value is greater or equal to that of
	// the previous commands (and all before it).
	//
	// This field is set through ClosedTimestampFooter hackery. The field is
	// nullable so that it does not get encoded when empty. This prevents the
	// field from being encoded twice in the combined
	// RaftCommand+ClosedTimestampFooter proto (encoding it twice is not illegal
	// as far as proto goes - the last value wins when decoding - but it is a
	// problem for sideloading, which reduces the size of the proto).
	ClosedTimestamp *hlc.Timestamp `protobuf:"bytes,17,opt,name=closed_timestamp,json=closedTimestamp,proto3" json:"closed_timestamp,omitempty"`
	// replicated_eval_result is a set of structured information that instructs
	// replicated state changes to the part of a Range's replicated state machine
	// that exists outside of RocksDB.
	ReplicatedEvalResult ReplicatedEvalResult `protobuf:"bytes,13,opt,name=replicated_eval_result,json=replicatedEvalResult,proto3" json:"replicated_eval_result"`
	// write_batch is a RocksDB WriteBatch that will be applied to RockDB during
	// the application of the Raft command. The batch can be thought of as a
	// series of replicated instructions that inform a RocksDB engine on how to
	// change.
	WriteBatch *WriteBatch `protobuf:"bytes,14,opt,name=write_batch,json=writeBatch,proto3" json:"write_batch,omitempty"`
	// logical_op_log contains a series of logical MVCC operations that correspond
	// to the physical operations being made in the write_batch.
	LogicalOpLog *LogicalOpLog `protobuf:"bytes,15,opt,name=logical_op_log,json=logicalOpLog,proto3" json:"logical_op_log,omitempty"`
	// trace_data, if not empty, contains details of the proposer's trace as
	// returned by Tracer.InjectMetaInto(sp.Meta(), ...). This is used to create
	// spans for the command application process on all the replicas that "follow
	// from" the proposer.
	TraceData map[string]string `protobuf:"bytes,16,rep,name=trace_data,json=traceData,proto3" json:"trace_data,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *RaftCommand) Reset()         { *m = RaftCommand{} }
func (m *RaftCommand) String() string { return proto.CompactTextString(m) }
func (*RaftCommand) ProtoMessage()    {}
func (*RaftCommand) Descriptor() ([]byte, []int) {
	return fileDescriptor_19df0b186dd19269, []int{9}
}
func (m *RaftCommand) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RaftCommand) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *RaftCommand) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RaftCommand.Merge(m, src)
}
func (m *RaftCommand) XXX_Size() int {
	return m.Size()
}
func (m *RaftCommand) XXX_DiscardUnknown() {
	xxx_messageInfo_RaftCommand.DiscardUnknown(m)
}

var xxx_messageInfo_RaftCommand proto.InternalMessageInfo

// RaftCommandFooter contains a subset of the fields in RaftCommand. It is used
// to optimize a pattern where most of the fields in RaftCommand are marshaled
// outside of a heavily contended critical section, except for the fields in the
// footer, which are assigned and marshaled inside of the critical section and
// appended to the marshaled byte buffer. This minimizes the memory allocation
// and marshaling work performed under lock.
type RaftCommandFooter struct {
	MaxLeaseIndex uint64 `protobuf:"varint,4,opt,name=max_lease_index,json=maxLeaseIndex,proto3" json:"max_lease_index,omitempty"`
	// NOTE: unlike in RaftCommand, there's no reason to make this field nullable
	// and so we make it non-nullable in order to save allocations. This means
	// that the field on a decoded RaftCommand will also never be nil, but we
	// don't rely on that.
	ClosedTimestamp hlc.Timestamp `protobuf:"bytes,17,opt,name=closed_timestamp,json=closedTimestamp,proto3" json:"closed_timestamp"`
}

func (m *RaftCommandFooter) Reset()         { *m = RaftCommandFooter{} }
func (m *RaftCommandFooter) String() string { return proto.CompactTextString(m) }
func (*RaftCommandFooter) ProtoMessage()    {}
func (*RaftCommandFooter) Descriptor() ([]byte, []int) {
	return fileDescriptor_19df0b186dd19269, []int{10}
}
func (m *RaftCommandFooter) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RaftCommandFooter) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *RaftCommandFooter) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RaftCommandFooter.Merge(m, src)
}
func (m *RaftCommandFooter) XXX_Size() int {
	return m.Size()
}
func (m *RaftCommandFooter) XXX_DiscardUnknown() {
	xxx_messageInfo_RaftCommandFooter.DiscardUnknown(m)
}

var xxx_messageInfo_RaftCommandFooter proto.InternalMessageInfo

func init() {
	proto.RegisterType((*Split)(nil), "cockroach.kv.kvserver.storagepb.Split")
	proto.RegisterType((*Merge)(nil), "cockroach.kv.kvserver.storagepb.Merge")
	proto.RegisterType((*ChangeReplicas)(nil), "cockroach.kv.kvserver.storagepb.ChangeReplicas")
	proto.RegisterType((*ComputeChecksum)(nil), "cockroach.kv.kvserver.storagepb.ComputeChecksum")
	proto.RegisterType((*Compaction)(nil), "cockroach.kv.kvserver.storagepb.Compaction")
	proto.RegisterType((*SuggestedCompaction)(nil), "cockroach.kv.kvserver.storagepb.SuggestedCompaction")
	proto.RegisterType((*ReplicatedEvalResult)(nil), "cockroach.kv.kvserver.storagepb.ReplicatedEvalResult")
	proto.RegisterType((*ReplicatedEvalResult_AddSSTable)(nil), "cockroach.kv.kvserver.storagepb.ReplicatedEvalResult.AddSSTable")
	proto.RegisterType((*WriteBatch)(nil), "cockroach.kv.kvserver.storagepb.WriteBatch")
	proto.RegisterType((*LogicalOpLog)(nil), "cockroach.kv.kvserver.storagepb.LogicalOpLog")
	proto.RegisterType((*RaftCommand)(nil), "cockroach.kv.kvserver.storagepb.RaftCommand")
	proto.RegisterMapType((map[string]string)(nil), "cockroach.kv.kvserver.storagepb.RaftCommand.TraceDataEntry")
	proto.RegisterType((*RaftCommandFooter)(nil), "cockroach.kv.kvserver.storagepb.RaftCommandFooter")
}

func init() {
	proto.RegisterFile("kv/kvserver/kvserverpb/proposer_kv.proto", fileDescriptor_19df0b186dd19269)
}

var fileDescriptor_19df0b186dd19269 = []byte{
	// 1546 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xa4, 0x57, 0x5f, 0x6f, 0x1b, 0x4b,
	0x15, 0xcf, 0xc6, 0xeb, 0x64, 0x3d, 0x4e, 0xec, 0xcd, 0x34, 0xb7, 0x5d, 0x02, 0xd8, 0x91, 0xb9,
	0xf7, 0x2a, 0x5c, 0x2e, 0xeb, 0x4b, 0x02, 0x12, 0x2a, 0x15, 0xba, 0xb5, 0x73, 0xaf, 0x1a, 0xdf,
	0x24, 0xb4, 0xe3, 0xb4, 0xa0, 0x82, 0xb4, 0x1a, 0xef, 0x4e, 0xd7, 0x8b, 0xf7, 0x5f, 0x67, 0xc6,
	0x6e, 0xf3, 0x19, 0x78, 0x00, 0x24, 0x24, 0x90, 0x90, 0xa0, 0x8f, 0x7c, 0x94, 0x3e, 0xf6, 0xb1,
	0xe2, 0xc1, 0xa2, 0xe9, 0x0b, 0x9f, 0xa1, 0x2f, 0xa0, 0x99, 0x9d, 0xb5, 0x37, 0x95, 0x4b, 0xdc,
	0xf2, 0x36, 0x7b, 0xe6, 0x9c, 0xdf, 0xcc, 0x9c, 0xf3, 0x3b, 0xbf, 0x99, 0x05, 0x7b, 0xa3, 0x49,
	0x7b, 0x34, 0x61, 0x84, 0x4e, 0x08, 0x9d, 0x0d, 0xd2, 0x41, 0x3b, 0xa5, 0x49, 0x9a, 0x30, 0x42,
	0x9d, 0xd1, 0xc4, 0x4e, 0x69, 0xc2, 0x13, 0xd8, 0x74, 0x13, 0x77, 0x44, 0x13, 0xec, 0x0e, 0xed,
	0xd1, 0xc4, 0xce, 0x5d, 0x6d, 0xc6, 0x13, 0x8a, 0x7d, 0x92, 0x0e, 0x76, 0xb6, 0xe4, 0x64, 0x3a,
	0x68, 0xe3, 0x34, 0xc8, 0x62, 0x76, 0x60, 0x6e, 0xf2, 0x30, 0xc7, 0xca, 0x76, 0x3d, 0xb7, 0x45,
	0x84, 0xe3, 0x82, 0xfd, 0xdb, 0x0a, 0xa9, 0x4d, 0x62, 0x3f, 0x88, 0x89, 0x70, 0x98, 0xb8, 0xae,
	0x9a, 0xfc, 0xce, 0xc2, 0xc9, 0x03, 0x35, 0xdb, 0x7a, 0xc7, 0x21, 0x18, 0xc7, 0x9c, 0x28, 0x9f,
	0xcf, 0x8a, 0x3e, 0x94, 0x60, 0x8f, 0x8d, 0xa3, 0x08, 0xd3, 0xf3, 0x36, 0x65, 0xc2, 0x33, 0xfb,
	0x50, 0xbe, 0xd6, 0x98, 0x07, 0x61, 0x7b, 0x18, 0xba, 0x6d, 0x1e, 0x44, 0x84, 0x71, 0x1c, 0xa5,
	0x6a, 0x66, 0xdb, 0x4f, 0xfc, 0x44, 0x0e, 0xdb, 0x62, 0x94, 0x59, 0x5b, 0xff, 0xd0, 0x40, 0xb9,
	0x9f, 0x86, 0x01, 0x87, 0x5d, 0xb0, 0xce, 0x69, 0xe0, 0xfb, 0x84, 0x5a, 0xda, 0xae, 0xb6, 0x57,
	0xdd, 0x6f, 0xda, 0xf3, 0xb4, 0xa9, 0x83, 0xdb, 0xd2, 0xf5, 0x2c, 0x73, 0xeb, 0x18, 0xcf, 0xa7,
	0xcd, 0x95, 0x17, 0xd3, 0xa6, 0x86, 0xf2, 0x48, 0x78, 0x06, 0x2a, 0x74, 0xc8, 0x1c, 0x8f, 0x84,
	0x1c, 0x5b, 0xab, 0x12, 0xe6, 0x93, 0x02, 0x8c, 0x4a, 0x85, 0x9d, 0xa7, 0xc2, 0x3e, 0x79, 0xd0,
	0xed, 0xf6, 0x39, 0xe6, 0xac, 0x63, 0x0a, 0xb0, 0x8b, 0x69, 0xd3, 0x40, 0x77, 0xfa, 0x87, 0x22,
	0x1c, 0x19, 0x74, 0xc8, 0xe4, 0xe8, 0xa6, 0xfe, 0xef, 0x67, 0x4d, 0xad, 0x85, 0x40, 0xf9, 0x84,
	0x50, 0x9f, 0x2c, 0xb7, 0x53, 0xe9, 0xfa, 0xee, 0x9d, 0x2a, 0x4c, 0x0f, 0xd4, 0xba, 0x43, 0x1c,
	0xfb, 0x04, 0x91, 0x34, 0x0c, 0x5c, 0xcc, 0xe0, 0xf1, 0xdb, 0xe0, 0x7b, 0x0b, 0xc0, 0x2f, 0xc7,
	0xfc, 0xaf, 0x55, 0xfe, 0xf2, 0xac, 0xb9, 0xd2, 0x7a, 0xb5, 0x0a, 0xea, 0xdd, 0x24, 0x4a, 0xc7,
	0x9c, 0x74, 0x87, 0xc4, 0x1d, 0xb1, 0x71, 0x04, 0x7f, 0x0b, 0xaa, 0xae, 0x1a, 0x3b, 0x81, 0x27,
	0xd7, 0xda, 0xe8, 0x1c, 0x09, 0x84, 0x7f, 0x4e, 0x9b, 0x07, 0x7e, 0xc0, 0x87, 0xe3, 0x81, 0xed,
	0x26, 0x51, 0x7b, 0xb6, 0xba, 0x37, 0x98, 0x8f, 0xdb, 0xe9, 0xc8, 0x6f, 0xcb, 0x52, 0x8f, 0xc7,
	0x81, 0x67, 0xdf, 0xbf, 0x7f, 0x74, 0x78, 0x31, 0x6d, 0x82, 0x1c, 0xfd, 0xe8, 0x10, 0x81, 0x1c,
	0xfd, 0xc8, 0x83, 0x16, 0x58, 0x9f, 0x10, 0xca, 0x82, 0x24, 0xb6, 0xca, 0xbb, 0xda, 0xde, 0x26,
	0xca, 0x3f, 0xe1, 0xf7, 0xc0, 0x26, 0xc3, 0x13, 0xe2, 0xb0, 0x18, 0xa7, 0x6c, 0x98, 0x70, 0x59,
	0x33, 0x03, 0x6d, 0x08, 0x63, 0x5f, 0xd9, 0xe0, 0x01, 0xd0, 0xa3, 0xc4, 0x23, 0x56, 0x69, 0x57,
	0xdb, 0xab, 0x2d, 0x4c, 0x76, 0xbe, 0xee, 0x49, 0xe2, 0x11, 0x24, 0x9d, 0x61, 0x03, 0x64, 0x3b,
	0x48, 0x93, 0x20, 0xe6, 0x96, 0x2e, 0x61, 0x0b, 0x16, 0x78, 0x07, 0x54, 0x38, 0xa1, 0x51, 0x10,
	0x63, 0x4e, 0xac, 0xb5, 0xdd, 0xd2, 0x5e, 0x75, 0xff, 0xe3, 0x05, 0xc8, 0x2a, 0xc7, 0x87, 0x84,
	0xb9, 0x34, 0x48, 0x79, 0x42, 0x3b, 0xba, 0xc8, 0x11, 0x9a, 0x07, 0xab, 0x4a, 0x3e, 0x00, 0x40,
	0xa4, 0x18, 0xbb, 0x5c, 0x9c, 0x6b, 0x1b, 0x94, 0x07, 0xe7, 0x9c, 0x30, 0x99, 0xd7, 0x12, 0xca,
	0x3e, 0xe0, 0xe7, 0x00, 0xb2, 0xb1, 0xef, 0x13, 0xc6, 0x89, 0xe7, 0x60, 0xee, 0xc4, 0x38, 0x4e,
	0x98, 0x3c, 0x72, 0x09, 0x99, 0xb3, 0x99, 0xdb, 0xfc, 0x54, 0xd8, 0x15, 0xee, 0x9f, 0x56, 0xc1,
	0xb5, 0x7e, 0x3e, 0x55, 0x58, 0xe1, 0x1e, 0xa8, 0x30, 0x8e, 0x29, 0x77, 0x46, 0xe4, 0x5c, 0x55,
	0xef, 0xc7, 0x6f, 0xa6, 0xcd, 0x2f, 0x96, 0xaa, 0x5c, 0x7e, 0xba, 0x6f, 0xc8, 0x39, 0x32, 0x24,
	0xcc, 0x37, 0xe4, 0x1c, 0x9e, 0x80, 0x75, 0x12, 0x7b, 0x12, 0x70, 0xf5, 0xff, 0x00, 0x5c, 0x23,
	0xb1, 0x27, 0xe0, 0xee, 0x03, 0xe0, 0xce, 0xf6, 0x2b, 0x8b, 0x57, 0xdd, 0xff, 0x81, 0x7d, 0x85,
	0x14, 0xda, 0xf3, 0x23, 0x16, 0xf8, 0x5c, 0x00, 0x52, 0x69, 0xf9, 0x4f, 0x05, 0x6c, 0xab, 0xda,
	0x70, 0xe2, 0x7d, 0x35, 0xc1, 0x21, 0x22, 0x6c, 0x1c, 0x0a, 0x19, 0x29, 0x4b, 0xed, 0x52, 0xdd,
	0xff, 0xc3, 0x2b, 0x17, 0x54, 0x28, 0x42, 0x05, 0x08, 0xca, 0x62, 0xe1, 0x2d, 0x50, 0x66, 0x42,
	0x69, 0xd4, 0xae, 0x3f, 0xbd, 0x12, 0x44, 0xea, 0x12, 0xca, 0x82, 0x44, 0x74, 0x24, 0xba, 0x5f,
	0xb2, 0x6e, 0x99, 0x68, 0xa9, 0x15, 0x28, 0x0b, 0x82, 0xbf, 0x06, 0xa6, 0x9b, 0xf5, 0xaa, 0x93,
	0xb7, 0x90, 0xf5, 0x91, 0x04, 0xfa, 0x62, 0xa9, 0xe4, 0x15, 0x9a, 0x1c, 0xd5, 0xdd, 0xb7, 0xba,
	0x7e, 0x0f, 0x98, 0x01, 0x73, 0x42, 0x82, 0x19, 0x71, 0x28, 0x79, 0x3c, 0x26, 0x8c, 0x5b, 0x6b,
	0xb2, 0x37, 0x6a, 0x01, 0x3b, 0x16, 0x66, 0x94, 0x59, 0xe1, 0x31, 0xa8, 0x3f, 0xa1, 0x01, 0x27,
	0xce, 0x4c, 0xc7, 0x2d, 0x43, 0xee, 0xe2, 0xbb, 0x85, 0x5d, 0x08, 0x05, 0xb0, 0x87, 0xa1, 0x6b,
	0x9f, 0xe5, 0x4e, 0xaa, 0x3d, 0x6a, 0x32, 0x76, 0x66, 0x85, 0x77, 0x81, 0xe9, 0x91, 0x94, 0x12,
	0x59, 0x2d, 0x25, 0xcf, 0xe0, 0x3d, 0xe4, 0x19, 0xd5, 0xe7, 0xe1, 0x52, 0x93, 0xe1, 0xd7, 0xa0,
	0x9c, 0xc1, 0x40, 0x09, 0xf3, 0xd9, 0x52, 0x30, 0x32, 0x54, 0x6d, 0x31, 0x0b, 0x87, 0xbf, 0x02,
	0x75, 0x57, 0xaa, 0xa9, 0x43, 0x95, 0x9c, 0x5a, 0x1b, 0x12, 0xb1, 0x7d, 0x75, 0xb6, 0x2f, 0xa9,
	0x30, 0xaa, 0xb9, 0x97, 0x95, 0xfc, 0x63, 0x50, 0xa3, 0xf8, 0x11, 0x77, 0xc2, 0xc4, 0x57, 0x27,
	0xde, 0x94, 0x9d, 0xbe, 0x21, 0xac, 0xc7, 0x89, 0x9f, 0x9d, 0xe3, 0x31, 0xa8, 0x62, 0xcf, 0x73,
	0x18, 0xe3, 0x78, 0x10, 0x12, 0x6b, 0x4b, 0xae, 0xfd, 0xe5, 0xb2, 0xac, 0xbd, 0xc4, 0x7d, 0xfb,
	0xb6, 0xe7, 0xf5, 0xfb, 0x67, 0x02, 0xa7, 0x53, 0x13, 0x72, 0x3c, 0xff, 0x46, 0x00, 0x7b, 0x5e,
	0x3f, 0x5b, 0x03, 0xfe, 0x5e, 0x03, 0xd7, 0x52, 0x4a, 0x26, 0x8a, 0x07, 0xd9, 0x7b, 0x05, 0x87,
	0xd6, 0xf6, 0x32, 0xf5, 0xfd, 0xf2, 0xcd, 0xb4, 0x79, 0x6b, 0xf9, 0xeb, 0x41, 0x04, 0x77, 0xc3,
	0xc4, 0x1d, 0xcd, 0x10, 0xd0, 0x96, 0x58, 0x5b, 0x72, 0xed, 0xae, 0x5a, 0x19, 0xfe, 0x06, 0xc0,
	0x94, 0x06, 0x09, 0x75, 0xc4, 0xeb, 0xc2, 0x51, 0x2f, 0x0a, 0xeb, 0xba, 0xdc, 0x8f, 0xfd, 0x8e,
	0x5c, 0x14, 0x1e, 0x22, 0x36, 0x22, 0xd8, 0xeb, 0x67, 0x63, 0x64, 0x4a, 0xa4, 0x82, 0x65, 0xe7,
	0xaf, 0x1a, 0x28, 0xa4, 0x02, 0x42, 0xa0, 0x8b, 0xb7, 0x53, 0x26, 0x9a, 0x48, 0x8e, 0x61, 0x13,
	0x94, 0x5d, 0xea, 0x1e, 0xec, 0x4b, 0xd5, 0xd8, 0xec, 0x54, 0x2e, 0xa6, 0xcd, 0x72, 0x17, 0x75,
	0x0f, 0xf6, 0x51, 0x66, 0x87, 0x3f, 0x02, 0x3a, 0x4b, 0x71, 0x2e, 0x63, 0x37, 0x16, 0x3e, 0x4d,
	0x70, 0xac, 0xa8, 0x25, 0x5d, 0xe1, 0x27, 0xa0, 0x46, 0xa2, 0x80, 0x3b, 0x54, 0xb0, 0xe2, 0x11,
	0x21, 0x9e, 0xba, 0x85, 0x36, 0x85, 0x15, 0xe5, 0xc6, 0x9e, 0x6e, 0x68, 0xe6, 0x6a, 0x4f, 0x37,
	0xca, 0xe6, 0x5a, 0x4f, 0x37, 0xd6, 0x4d, 0xa3, 0xa7, 0x1b, 0x15, 0x13, 0xf4, 0x74, 0xa3, 0x66,
	0xd6, 0x7b, 0xba, 0x51, 0x37, 0xcd, 0x9e, 0x6e, 0x98, 0xe6, 0x56, 0x4f, 0x37, 0xae, 0x99, 0xdb,
	0xbd, 0x35, 0xe3, 0x8f, 0xa7, 0xe6, 0xdf, 0x4e, 0x5b, 0xbb, 0x00, 0xfc, 0x52, 0x34, 0x59, 0x07,
	0x73, 0x77, 0xb8, 0xe8, 0x50, 0xad, 0x7b, 0x60, 0xe3, 0x38, 0xf1, 0x03, 0x17, 0x87, 0xbf, 0x48,
	0x8f, 0x13, 0x1f, 0xde, 0x06, 0xa5, 0x24, 0x15, 0x57, 0x92, 0xb8, 0xec, 0xbe, 0x7f, 0x55, 0xc3,
	0xcc, 0x42, 0xd5, 0xa1, 0x44, 0x6c, 0xeb, 0xcf, 0x6b, 0xa0, 0x8a, 0xf0, 0x23, 0xde, 0x4d, 0xa2,
	0x08, 0xc7, 0x1e, 0x9c, 0x80, 0x1b, 0xb3, 0xe7, 0x6e, 0xc6, 0x26, 0x26, 0xf4, 0x23, 0x76, 0x89,
	0x94, 0x95, 0x52, 0xe7, 0xe7, 0x6f, 0xa6, 0xcd, 0x9b, 0xef, 0x75, 0x85, 0x48, 0x66, 0xf4, 0x15,
	0x0a, 0xfa, 0x28, 0x87, 0xbf, 0x64, 0x86, 0x67, 0xe0, 0x5b, 0x05, 0x3d, 0xb9, 0xbc, 0x05, 0xf9,
	0xc6, 0xa8, 0xee, 0x5b, 0x0b, 0x6a, 0x94, 0x29, 0xdc, 0x8d, 0x79, 0xe8, 0xdd, 0x22, 0x3a, 0xfc,
	0x14, 0xd4, 0x23, 0xfc, 0x54, 0x1d, 0x24, 0x88, 0x3d, 0xf2, 0x54, 0x96, 0x4c, 0x47, 0x9b, 0x11,
	0x7e, 0x2a, 0x5d, 0x8e, 0x84, 0x11, 0xde, 0x01, 0xa6, 0x1b, 0x26, 0x8c, 0x78, 0x05, 0x71, 0xdc,
	0x5a, 0xa2, 0x79, 0x50, 0x3d, 0x0b, 0x9b, 0xeb, 0xe2, 0x63, 0x70, 0x9d, 0xce, 0x3a, 0xd9, 0x21,
	0x13, 0x1c, 0x3a, 0x54, 0xf6, 0xb2, 0xd4, 0x8a, 0xea, 0xfe, 0x4f, 0x3e, 0x48, 0x08, 0x54, 0xc5,
	0xb6, 0xe9, 0xa2, 0x0b, 0xf2, 0x18, 0x54, 0x33, 0x61, 0x1f, 0x08, 0xe2, 0x58, 0xb5, 0x25, 0xef,
	0xe5, 0x39, 0xd7, 0x10, 0x78, 0x32, 0xe7, 0x5d, 0x1f, 0xd4, 0xc2, 0x8c, 0x28, 0x4e, 0x92, 0x0a,
	0xa9, 0xb3, 0xea, 0x4b, 0xde, 0xbb, 0x45, 0x6a, 0xa2, 0x8d, 0xb0, 0x48, 0xd4, 0x87, 0x00, 0x70,
	0x8a, 0x5d, 0xe2, 0x48, 0x4a, 0x9b, 0x92, 0xaf, 0x3f, 0xbb, 0x3a, 0x13, 0x73, 0x5e, 0xda, 0x67,
	0x22, 0xfc, 0x10, 0x73, 0xfc, 0x55, 0xcc, 0xe9, 0x39, 0xaa, 0xf0, 0xfc, 0x7b, 0xe7, 0x16, 0xa8,
	0x5d, 0x9e, 0x84, 0x26, 0x28, 0xe5, 0x6f, 0xa8, 0x0a, 0x12, 0x43, 0xf1, 0x7a, 0x9b, 0xe0, 0x70,
	0x9c, 0xbd, 0x21, 0x2a, 0x28, 0xfb, 0xb8, 0xb9, 0xfa, 0x53, 0xad, 0xa7, 0x1b, 0x25, 0x53, 0x9f,
	0xb5, 0xec, 0xaa, 0x59, 0xca, 0xda, 0xf1, 0xef, 0xa7, 0xad, 0xdf, 0x69, 0x60, 0xab, 0xb0, 0x83,
	0xaf, 0x93, 0x84, 0x13, 0xba, 0x34, 0xa3, 0x4e, 0x3f, 0x90, 0x51, 0xaa, 0xd2, 0x6f, 0xf3, 0xaa,
	0xf3, 0xf9, 0xf3, 0x57, 0x8d, 0x95, 0xe7, 0x17, 0x0d, 0xed, 0xc5, 0x45, 0x43, 0x7b, 0x79, 0xd1,
	0xd0, 0xfe, 0x75, 0xd1, 0xd0, 0xfe, 0xf0, 0xba, 0xb1, 0xf2, 0xe2, 0x75, 0x63, 0xe5, 0xe5, 0xeb,
	0xc6, 0xca, 0x43, 0x30, 0xff, 0xd9, 0x1b, 0xac, 0xc9, 0x7f, 0xb1, 0x83, 0xff, 0x06, 0x00, 0x00,
	0xff, 0xff, 0x8b, 0x63, 0x18, 0x47, 0xd2, 0x0e, 0x00, 0x00,
}

func (this *Split) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Split)
	if !ok {
		that2, ok := that.(Split)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.SplitTrigger.Equal(&that1.SplitTrigger) {
		return false
	}
	if !this.RHSDelta.Equal(&that1.RHSDelta) {
		return false
	}
	return true
}
func (this *Merge) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Merge)
	if !ok {
		that2, ok := that.(Merge)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.MergeTrigger.Equal(&that1.MergeTrigger) {
		return false
	}
	return true
}
func (this *ComputeChecksum) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ComputeChecksum)
	if !ok {
		that2, ok := that.(ComputeChecksum)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.ChecksumID.Equal(that1.ChecksumID) {
		return false
	}
	if this.Version != that1.Version {
		return false
	}
	if this.SaveSnapshot != that1.SaveSnapshot {
		return false
	}
	if this.Mode != that1.Mode {
		return false
	}
	if this.Checkpoint != that1.Checkpoint {
		return false
	}
	if len(this.Terminate) != len(that1.Terminate) {
		return false
	}
	for i := range this.Terminate {
		if !this.Terminate[i].Equal(&that1.Terminate[i]) {
			return false
		}
	}
	return true
}
func (this *Compaction) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Compaction)
	if !ok {
		that2, ok := that.(Compaction)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Bytes != that1.Bytes {
		return false
	}
	if this.SuggestedAtNanos != that1.SuggestedAtNanos {
		return false
	}
	return true
}
func (this *SuggestedCompaction) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SuggestedCompaction)
	if !ok {
		that2, ok := that.(SuggestedCompaction)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !bytes.Equal(this.StartKey, that1.StartKey) {
		return false
	}
	if !bytes.Equal(this.EndKey, that1.EndKey) {
		return false
	}
	if !this.Compaction.Equal(&that1.Compaction) {
		return false
	}
	return true
}
func (m *Split) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Split) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Split) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.RHSDelta.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintProposerKv(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.SplitTrigger.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintProposerKv(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *Merge) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Merge) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Merge) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.MergeTrigger.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintProposerKv(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *ChangeReplicas) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ChangeReplicas) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ChangeReplicas) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.ChangeReplicasTrigger.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintProposerKv(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *ComputeChecksum) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ComputeChecksum) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ComputeChecksum) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Terminate) > 0 {
		for iNdEx := len(m.Terminate) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Terminate[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintProposerKv(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if m.Version != 0 {
		i = encodeVarintProposerKv(dAtA, i, uint64(m.Version))
		i--
		dAtA[i] = 0x28
	}
	if m.Checkpoint {
		i--
		if m.Checkpoint {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.Mode != 0 {
		i = encodeVarintProposerKv(dAtA, i, uint64(m.Mode))
		i--
		dAtA[i] = 0x18
	}
	if m.SaveSnapshot {
		i--
		if m.SaveSnapshot {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	{
		size := m.ChecksumID.Size()
		i -= size
		if _, err := m.ChecksumID.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintProposerKv(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *Compaction) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Compaction) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Compaction) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.SuggestedAtNanos != 0 {
		i = encodeVarintProposerKv(dAtA, i, uint64(m.SuggestedAtNanos))
		i--
		dAtA[i] = 0x10
	}
	if m.Bytes != 0 {
		i = encodeVarintProposerKv(dAtA, i, uint64(m.Bytes))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SuggestedCompaction) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SuggestedCompaction) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SuggestedCompaction) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Compaction.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintProposerKv(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if len(m.EndKey) > 0 {
		i -= len(m.EndKey)
		copy(dAtA[i:], m.EndKey)
		i = encodeVarintProposerKv(dAtA, i, uint64(len(m.EndKey)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.StartKey) > 0 {
		i -= len(m.StartKey)
		copy(dAtA[i:], m.StartKey)
		i = encodeVarintProposerKv(dAtA, i, uint64(len(m.StartKey)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ReplicatedEvalResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReplicatedEvalResult) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReplicatedEvalResult) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.PriorReadSummary != nil {
		{
			size, err := m.PriorReadSummary.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintProposerKv(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb2
	}
	if m.ComputeChecksum != nil {
		{
			size, err := m.ComputeChecksum.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintProposerKv(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xaa
	}
	if m.PrevLeaseProposal != nil {
		{
			size, err := m.PrevLeaseProposal.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintProposerKv(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa2
	}
	{
		size, err := m.Delta.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintProposerKv(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0x92
	if m.AddSSTable != nil {
		{
			size, err := m.AddSSTable.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintProposerKv(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x8a
	}
	if m.RaftLogDelta != 0 {
		i = encodeVarintProposerKv(dAtA, i, uint64(m.RaftLogDelta))
		i--
		dAtA[i] = 0x68
	}
	if m.ChangeReplicas != nil {
		{
			size, err := m.ChangeReplicas.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintProposerKv(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x62
	}
	if m.DeprecatedDelta != nil {
		{
			size, err := m.DeprecatedDelta.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintProposerKv(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	{
		size, err := m.WriteTimestamp.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintProposerKv(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x42
	if m.IsLeaseRequest {
		i--
		if m.IsLeaseRequest {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if m.Merge != nil {
		{
			size, err := m.Merge.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintProposerKv(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.Split != nil {
		{
			size, err := m.Split.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintProposerKv(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.State != nil {
		{
			size, err := m.State.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintProposerKv(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}

func (m *ReplicatedEvalResult_AddSSTable) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReplicatedEvalResult_AddSSTable) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReplicatedEvalResult_AddSSTable) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.EmitRangefeed {
		i--
		if m.EmitRangefeed {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	{
		size, err := m.Span.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintProposerKv(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if m.CRC32 != 0 {
		i = encodeVarintProposerKv(dAtA, i, uint64(m.CRC32))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Data) > 0 {
		i -= len(m.Data)
		copy(dAtA[i:], m.Data)
		i = encodeVarintProposerKv(dAtA, i, uint64(len(m.Data)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *WriteBatch) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WriteBatch) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WriteBatch) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Data) > 0 {
		i -= len(m.Data)
		copy(dAtA[i:], m.Data)
		i = encodeVarintProposerKv(dAtA, i, uint64(len(m.Data)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *LogicalOpLog) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LogicalOpLog) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LogicalOpLog) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Ops) > 0 {
		for iNdEx := len(m.Ops) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Ops[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintProposerKv(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *RaftCommand) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RaftCommand) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RaftCommand) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ClosedTimestamp != nil {
		{
			size, err := m.ClosedTimestamp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintProposerKv(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x8a
	}
	if len(m.TraceData) > 0 {
		keysForTraceData := make([]string, 0, len(m.TraceData))
		for k := range m.TraceData {
			keysForTraceData = append(keysForTraceData, string(k))
		}
		github_com_gogo_protobuf_sortkeys.Strings(keysForTraceData)
		for iNdEx := len(keysForTraceData) - 1; iNdEx >= 0; iNdEx-- {
			v := m.TraceData[string(keysForTraceData[iNdEx])]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintProposerKv(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(keysForTraceData[iNdEx])
			copy(dAtA[i:], keysForTraceData[iNdEx])
			i = encodeVarintProposerKv(dAtA, i, uint64(len(keysForTraceData[iNdEx])))
			i--
			dAtA[i] = 0xa
			i = encodeVarintProposerKv(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0x82
		}
	}
	if m.LogicalOpLog != nil {
		{
			size, err := m.LogicalOpLog.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintProposerKv(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x7a
	}
	if m.WriteBatch != nil {
		{
			size, err := m.WriteBatch.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintProposerKv(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x72
	}
	{
		size, err := m.ReplicatedEvalResult.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintProposerKv(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x6a
	if m.ProposerLeaseSequence != 0 {
		i = encodeVarintProposerKv(dAtA, i, uint64(m.ProposerLeaseSequence))
		i--
		dAtA[i] = 0x30
	}
	if m.DeprecatedProposerLease != nil {
		{
			size, err := m.DeprecatedProposerLease.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintProposerKv(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.MaxLeaseIndex != 0 {
		i = encodeVarintProposerKv(dAtA, i, uint64(m.MaxLeaseIndex))
		i--
		dAtA[i] = 0x20
	}
	return len(dAtA) - i, nil
}

func (m *RaftCommandFooter) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RaftCommandFooter) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RaftCommandFooter) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.ClosedTimestamp.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintProposerKv(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0x8a
	if m.MaxLeaseIndex != 0 {
		i = encodeVarintProposerKv(dAtA, i, uint64(m.MaxLeaseIndex))
		i--
		dAtA[i] = 0x20
	}
	return len(dAtA) - i, nil
}

func encodeVarintProposerKv(dAtA []byte, offset int, v uint64) int {
	offset -= sovProposerKv(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Split) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.SplitTrigger.Size()
	n += 1 + l + sovProposerKv(uint64(l))
	l = m.RHSDelta.Size()
	n += 1 + l + sovProposerKv(uint64(l))
	return n
}

func (m *Merge) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.MergeTrigger.Size()
	n += 1 + l + sovProposerKv(uint64(l))
	return n
}

func (m *ChangeReplicas) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.ChangeReplicasTrigger.Size()
	n += 1 + l + sovProposerKv(uint64(l))
	return n
}

func (m *ComputeChecksum) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.ChecksumID.Size()
	n += 1 + l + sovProposerKv(uint64(l))
	if m.SaveSnapshot {
		n += 2
	}
	if m.Mode != 0 {
		n += 1 + sovProposerKv(uint64(m.Mode))
	}
	if m.Checkpoint {
		n += 2
	}
	if m.Version != 0 {
		n += 1 + sovProposerKv(uint64(m.Version))
	}
	if len(m.Terminate) > 0 {
		for _, e := range m.Terminate {
			l = e.Size()
			n += 1 + l + sovProposerKv(uint64(l))
		}
	}
	return n
}

func (m *Compaction) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Bytes != 0 {
		n += 1 + sovProposerKv(uint64(m.Bytes))
	}
	if m.SuggestedAtNanos != 0 {
		n += 1 + sovProposerKv(uint64(m.SuggestedAtNanos))
	}
	return n
}

func (m *SuggestedCompaction) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.StartKey)
	if l > 0 {
		n += 1 + l + sovProposerKv(uint64(l))
	}
	l = len(m.EndKey)
	if l > 0 {
		n += 1 + l + sovProposerKv(uint64(l))
	}
	l = m.Compaction.Size()
	n += 1 + l + sovProposerKv(uint64(l))
	return n
}

func (m *ReplicatedEvalResult) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.State != nil {
		l = m.State.Size()
		n += 1 + l + sovProposerKv(uint64(l))
	}
	if m.Split != nil {
		l = m.Split.Size()
		n += 1 + l + sovProposerKv(uint64(l))
	}
	if m.Merge != nil {
		l = m.Merge.Size()
		n += 1 + l + sovProposerKv(uint64(l))
	}
	if m.IsLeaseRequest {
		n += 2
	}
	l = m.WriteTimestamp.Size()
	n += 1 + l + sovProposerKv(uint64(l))
	if m.DeprecatedDelta != nil {
		l = m.DeprecatedDelta.Size()
		n += 1 + l + sovProposerKv(uint64(l))
	}
	if m.ChangeReplicas != nil {
		l = m.ChangeReplicas.Size()
		n += 1 + l + sovProposerKv(uint64(l))
	}
	if m.RaftLogDelta != 0 {
		n += 1 + sovProposerKv(uint64(m.RaftLogDelta))
	}
	if m.AddSSTable != nil {
		l = m.AddSSTable.Size()
		n += 2 + l + sovProposerKv(uint64(l))
	}
	l = m.Delta.Size()
	n += 2 + l + sovProposerKv(uint64(l))
	if m.PrevLeaseProposal != nil {
		l = m.PrevLeaseProposal.Size()
		n += 2 + l + sovProposerKv(uint64(l))
	}
	if m.ComputeChecksum != nil {
		l = m.ComputeChecksum.Size()
		n += 2 + l + sovProposerKv(uint64(l))
	}
	if m.PriorReadSummary != nil {
		l = m.PriorReadSummary.Size()
		n += 2 + l + sovProposerKv(uint64(l))
	}
	return n
}

func (m *ReplicatedEvalResult_AddSSTable) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovProposerKv(uint64(l))
	}
	if m.CRC32 != 0 {
		n += 1 + sovProposerKv(uint64(m.CRC32))
	}
	l = m.Span.Size()
	n += 1 + l + sovProposerKv(uint64(l))
	if m.EmitRangefeed {
		n += 2
	}
	return n
}

func (m *WriteBatch) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovProposerKv(uint64(l))
	}
	return n
}

func (m *LogicalOpLog) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Ops) > 0 {
		for _, e := range m.Ops {
			l = e.Size()
			n += 1 + l + sovProposerKv(uint64(l))
		}
	}
	return n
}

func (m *RaftCommand) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MaxLeaseIndex != 0 {
		n += 1 + sovProposerKv(uint64(m.MaxLeaseIndex))
	}
	if m.DeprecatedProposerLease != nil {
		l = m.DeprecatedProposerLease.Size()
		n += 1 + l + sovProposerKv(uint64(l))
	}
	if m.ProposerLeaseSequence != 0 {
		n += 1 + sovProposerKv(uint64(m.ProposerLeaseSequence))
	}
	l = m.ReplicatedEvalResult.Size()
	n += 1 + l + sovProposerKv(uint64(l))
	if m.WriteBatch != nil {
		l = m.WriteBatch.Size()
		n += 1 + l + sovProposerKv(uint64(l))
	}
	if m.LogicalOpLog != nil {
		l = m.LogicalOpLog.Size()
		n += 1 + l + sovProposerKv(uint64(l))
	}
	if len(m.TraceData) > 0 {
		for k, v := range m.TraceData {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovProposerKv(uint64(len(k))) + 1 + len(v) + sovProposerKv(uint64(len(v)))
			n += mapEntrySize + 2 + sovProposerKv(uint64(mapEntrySize))
		}
	}
	if m.ClosedTimestamp != nil {
		l = m.ClosedTimestamp.Size()
		n += 2 + l + sovProposerKv(uint64(l))
	}
	return n
}

func (m *RaftCommandFooter) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MaxLeaseIndex != 0 {
		n += 1 + sovProposerKv(uint64(m.MaxLeaseIndex))
	}
	l = m.ClosedTimestamp.Size()
	n += 2 + l + sovProposerKv(uint64(l))
	return n
}

func sovProposerKv(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozProposerKv(x uint64) (n int) {
	return sovProposerKv(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Split) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProposerKv
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Split: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Split: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SplitTrigger", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProposerKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProposerKv
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProposerKv
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.SplitTrigger.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RHSDelta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProposerKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProposerKv
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProposerKv
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RHSDelta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProposerKv(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthProposerKv
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Merge) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProposerKv
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Merge: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Merge: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MergeTrigger", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProposerKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProposerKv
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProposerKv
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MergeTrigger.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProposerKv(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthProposerKv
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ChangeReplicas) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProposerKv
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ChangeReplicas: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ChangeReplicas: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChangeReplicasTrigger", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProposerKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProposerKv
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProposerKv
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ChangeReplicasTrigger.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProposerKv(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthProposerKv
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ComputeChecksum) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProposerKv
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ComputeChecksum: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ComputeChecksum: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChecksumID", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProposerKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthProposerKv
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthProposerKv
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ChecksumID.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SaveSnapshot", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProposerKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SaveSnapshot = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mode", wireType)
			}
			m.Mode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProposerKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mode |= roachpb.ChecksumMode(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Checkpoint", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProposerKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Checkpoint = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			m.Version = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProposerKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Version |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Terminate", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProposerKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProposerKv
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProposerKv
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Terminate = append(m.Terminate, roachpb.ReplicaDescriptor{})
			if err := m.Terminate[len(m.Terminate)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProposerKv(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthProposerKv
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Compaction) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProposerKv
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Compaction: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Compaction: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bytes", wireType)
			}
			m.Bytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProposerKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Bytes |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SuggestedAtNanos", wireType)
			}
			m.SuggestedAtNanos = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProposerKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SuggestedAtNanos |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipProposerKv(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthProposerKv
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SuggestedCompaction) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProposerKv
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SuggestedCompaction: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SuggestedCompaction: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProposerKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthProposerKv
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthProposerKv
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StartKey = append(m.StartKey[:0], dAtA[iNdEx:postIndex]...)
			if m.StartKey == nil {
				m.StartKey = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProposerKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthProposerKv
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthProposerKv
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EndKey = append(m.EndKey[:0], dAtA[iNdEx:postIndex]...)
			if m.EndKey == nil {
				m.EndKey = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Compaction", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProposerKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProposerKv
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProposerKv
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Compaction.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProposerKv(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthProposerKv
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReplicatedEvalResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProposerKv
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReplicatedEvalResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReplicatedEvalResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProposerKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProposerKv
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProposerKv
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.State == nil {
				m.State = &ReplicaState{}
			}
			if err := m.State.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Split", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProposerKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProposerKv
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProposerKv
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Split == nil {
				m.Split = &Split{}
			}
			if err := m.Split.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Merge", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProposerKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProposerKv
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProposerKv
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Merge == nil {
				m.Merge = &Merge{}
			}
			if err := m.Merge.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsLeaseRequest", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProposerKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsLeaseRequest = bool(v != 0)
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WriteTimestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProposerKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProposerKv
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProposerKv
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.WriteTimestamp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeprecatedDelta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProposerKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProposerKv
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProposerKv
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DeprecatedDelta == nil {
				m.DeprecatedDelta = &enginepb.MVCCStats{}
			}
			if err := m.DeprecatedDelta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChangeReplicas", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProposerKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProposerKv
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProposerKv
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ChangeReplicas == nil {
				m.ChangeReplicas = &ChangeReplicas{}
			}
			if err := m.ChangeReplicas.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RaftLogDelta", wireType)
			}
			m.RaftLogDelta = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProposerKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RaftLogDelta |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AddSSTable", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProposerKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProposerKv
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProposerKv
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AddSSTable == nil {
				m.AddSSTable = &ReplicatedEvalResult_AddSSTable{}
			}
			if err := m.AddSSTable.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Delta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProposerKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProposerKv
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProposerKv
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Delta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrevLeaseProposal", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProposerKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProposerKv
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProposerKv
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PrevLeaseProposal == nil {
				m.PrevLeaseProposal = &github_com_cockroachdb_cockroach_pkg_util_hlc.ClockTimestamp{}
			}
			if err := m.PrevLeaseProposal.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ComputeChecksum", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProposerKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProposerKv
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProposerKv
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ComputeChecksum == nil {
				m.ComputeChecksum = &ComputeChecksum{}
			}
			if err := m.ComputeChecksum.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PriorReadSummary", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProposerKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProposerKv
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProposerKv
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PriorReadSummary == nil {
				m.PriorReadSummary = &rspb.ReadSummary{}
			}
			if err := m.PriorReadSummary.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProposerKv(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthProposerKv
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReplicatedEvalResult_AddSSTable) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProposerKv
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AddSSTable: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AddSSTable: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProposerKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthProposerKv
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthProposerKv
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CRC32", wireType)
			}
			m.CRC32 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProposerKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CRC32 |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Span", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProposerKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProposerKv
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProposerKv
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Span.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EmitRangefeed", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProposerKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.EmitRangefeed = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipProposerKv(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthProposerKv
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WriteBatch) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProposerKv
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WriteBatch: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WriteBatch: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProposerKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthProposerKv
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthProposerKv
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProposerKv(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthProposerKv
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LogicalOpLog) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProposerKv
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LogicalOpLog: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LogicalOpLog: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ops", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProposerKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProposerKv
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProposerKv
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ops = append(m.Ops, enginepb.MVCCLogicalOp{})
			if err := m.Ops[len(m.Ops)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProposerKv(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthProposerKv
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RaftCommand) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProposerKv
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RaftCommand: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RaftCommand: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxLeaseIndex", wireType)
			}
			m.MaxLeaseIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProposerKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxLeaseIndex |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeprecatedProposerLease", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProposerKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProposerKv
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProposerKv
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DeprecatedProposerLease == nil {
				m.DeprecatedProposerLease = &roachpb.Lease{}
			}
			if err := m.DeprecatedProposerLease.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProposerLeaseSequence", wireType)
			}
			m.ProposerLeaseSequence = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProposerKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ProposerLeaseSequence |= github_com_cockroachdb_cockroach_pkg_roachpb.LeaseSequence(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplicatedEvalResult", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProposerKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProposerKv
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProposerKv
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ReplicatedEvalResult.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WriteBatch", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProposerKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProposerKv
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProposerKv
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.WriteBatch == nil {
				m.WriteBatch = &WriteBatch{}
			}
			if err := m.WriteBatch.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LogicalOpLog", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProposerKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProposerKv
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProposerKv
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LogicalOpLog == nil {
				m.LogicalOpLog = &LogicalOpLog{}
			}
			if err := m.LogicalOpLog.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TraceData", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProposerKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProposerKv
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProposerKv
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TraceData == nil {
				m.TraceData = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowProposerKv
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowProposerKv
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthProposerKv
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthProposerKv
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowProposerKv
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthProposerKv
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthProposerKv
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipProposerKv(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthProposerKv
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.TraceData[mapkey] = mapvalue
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClosedTimestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProposerKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProposerKv
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProposerKv
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ClosedTimestamp == nil {
				m.ClosedTimestamp = &hlc.Timestamp{}
			}
			if err := m.ClosedTimestamp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProposerKv(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthProposerKv
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RaftCommandFooter) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProposerKv
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RaftCommandFooter: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RaftCommandFooter: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxLeaseIndex", wireType)
			}
			m.MaxLeaseIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProposerKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxLeaseIndex |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClosedTimestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProposerKv
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProposerKv
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProposerKv
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ClosedTimestamp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProposerKv(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthProposerKv
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipProposerKv(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowProposerKv
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowProposerKv
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowProposerKv
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthProposerKv
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupProposerKv
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthProposerKv
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthProposerKv        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowProposerKv          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupProposerKv = fmt.Errorf("proto: unexpected end of group")
)
