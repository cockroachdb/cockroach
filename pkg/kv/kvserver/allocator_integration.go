// Copyright 2025 The Cockroach Authors.
//
// Use of this software is governed by the CockroachDB Software License
// included in the /LICENSE file.

package kvserver

import (
	"github.com/cockroachdb/cockroach/pkg/kv/kvpb"
	"github.com/cockroachdb/cockroach/pkg/kv/kvserver/allocator"
	"github.com/cockroachdb/cockroach/pkg/kv/kvserver/allocator/mma"
	"github.com/cockroachdb/cockroach/pkg/kv/kvserver/allocator/storepool"
	"github.com/cockroachdb/cockroach/pkg/roachpb"
)

// AllocatorSync updates the storepool.Storepool and the mma.Allocator to be in
// sync with eachother, notifying each other of changes generated by the other.
//
// - Storepool
//   - pre-apply:
//   - nothing
//   - post-apply:
//   - UpdateLocalStoreAfterRebalance()
//   - UpdateLocalStoreAfterLeaseTransfer()
//     (only for store rebalancer)
//   - UpdateLocalStoreAfterRelocate()
//
// - mma.Allocator
//   - pre-apply (from the replicate queue / lease queue / storerebalancer):
//   - RegisterExternalPendingChange(change) -> []ChangeID
//   - post-apply (both)
//   - AdjustPendingChangesDisposition(changeIDs)
//
// AllocatorSync doesn't apply the changes itself because simulation (asim)
// applies changes without blocking the goroutine, while in production code we
// apply the changes synchronously on the same goroutine.
type AllocatorSync struct {
	sp          storepool.StorePool
	mmAllocator mma.Allocator
	// TODO: Track ChangeIDs->(Usage,operation type) mapping, to be able to call
	// AdjustPendingChangesDisposition after applying changes.
}

func (as *AllocatorSync) NonMMAPreTransferLease(
	desc *roachpb.RangeDescriptor,
	usage allocator.RangeUsageInfo,
	existing, target roachpb.ReplicationTarget,
) []mma.ChangeID {
	// TODO: convert this into two ReplicaChanges which are then passed to
	// the mma.Allocator to register the change.
	panic("unimplemented")
}

func (as *AllocatorSync) NonMMAPreChangeReplicas(
	desc *roachpb.RangeDescriptor, usage allocator.RangeUsageInfo, changes kvpb.ReplicationChanges,
) []mma.ChangeID {
	// TODO: convert this into two ReplicaChanges which are then passed to
	// the mma.Allocator to register the change.
	panic("unimplemented")
}

func (as *AllocatorSync) NonMMAPreRelocateRange(
	desc *roachpb.RangeDescriptor,
	usage allocator.RangeUsageInfo,
	voterTargets, nonVoterTargets []roachpb.ReplicationTarget,
) []mma.ChangeID {
	// TODO: convert this into ReplicaChanges which are then passed to
	// the mma.Allocator to register the change.
	panic("unimplemented")
}

func (as *AllocatorSync) PostApply(changeIDs []mma.ChangeID, success bool) {
	// TODO: Call AdjustPendingChangesDisposition on the mma.Allocator, call
	// storepool.UpdateLocalStoreAfterX on the storepool.
	panic("unimplemented")
}
