// Copyright 2025 The Cockroach Authors.
//
// Use of this software is governed by the CockroachDB Software License
// included in the /LICENSE file.

package kvserver

import (
	"context"
	fmt "fmt"

	"github.com/cockroachdb/cockroach/pkg/kv/kvpb"
	"github.com/cockroachdb/cockroach/pkg/kv/kvserver/allocator"
	"github.com/cockroachdb/cockroach/pkg/kv/kvserver/allocator/mma"
	"github.com/cockroachdb/cockroach/pkg/kv/kvserver/allocator/storepool"
	"github.com/cockroachdb/cockroach/pkg/roachpb"
	"github.com/cockroachdb/cockroach/pkg/util/log"
	"github.com/cockroachdb/cockroach/pkg/util/syncutil"
)

type SyncChangeID uint64

const InvalidSyncChangeID SyncChangeID = 0

func (id SyncChangeID) IsValid() bool {
	return id != 0
}

// The expected usage for the non-mma components is:
// changeIDs := allocatorSync.NonMMA(PreTransferLease|PreChangeReplicas)()
// // Actually apply the change, or when simulating, queue up the change to be
// // applied.
// allocatorSync.PostApply(changeIDs, success)

// AllocatorSync updates the storepool.Storepool and the mma.Allocator to be in
// sync with eachother, notifying each other of changes generated by the other.
//
// AllocatorSync doesn't apply the changes itself because simulation (asim)
// applies changes without blocking the goroutine, while in production code we
// apply the changes synchronously on the same goroutine.
type AllocatorSync struct {
	sp          *storepool.StorePool
	mmAllocator mma.Allocator
	mu          struct {
		syncutil.Mutex
		changeSeqGen   SyncChangeID
		trackedChanges map[SyncChangeID]trackedAllocatorChange
	}
}

func NewAllocatorSync(sp *storepool.StorePool, mmAllocator mma.Allocator) *AllocatorSync {
	as := &AllocatorSync{
		sp:          sp,
		mmAllocator: mmAllocator,
	}
	as.mu.trackedChanges = make(map[SyncChangeID]trackedAllocatorChange)
	return as
}

// AllocatorChangeType is used to identify the type of change that is being
// made.
type AllocatorChangeType int

// TODO(kvoli): These overlap with the operations in the plan pkg. We could do
// with just one set.
const (
	// AllocatorChangeTypeLeaseTransfer corresponds to TransferLease.
	AllocatorChangeTypeLeaseTransfer AllocatorChangeType = iota
	// AllocatorChangeTypeChangeReplicas corresponds to ChangeReplicas.
	AllocatorChangeTypeChangeReplicas
	// AllocatorChangeTypeRelocateRange corresponds to RelocateRange.
	AllocatorChangeTypeRelocateRange
)

type trackedAllocatorChange struct {
	typ       AllocatorChangeType
	usage     allocator.RangeUsageInfo
	changeIDs []mma.ChangeID

	chgs                     kvpb.ReplicationChanges
	transferFrom, transferTo roachpb.StoreID
}

func (as *AllocatorSync) NonMMAPreTransferLease(
	desc *roachpb.RangeDescriptor,
	usage allocator.RangeUsageInfo,
	transferFrom, transferTo roachpb.ReplicationTarget,
) SyncChangeID {
	existingReplicas := make([]mma.StoreIDAndReplicaState, len(desc.InternalReplicas))
	for i, replica := range desc.Replicas().Descriptors() {
		existingReplicas[i] = allocator.ReplicaDescriptorToReplicaIDAndType(replica, transferFrom.StoreID)
	}
	replicaChanges := mma.MakeLeaseTransferChanges(desc.RangeID,
		existingReplicas,
		allocator.UsageInfoToMMALoad(usage),
		transferTo,
		transferFrom,
	)
	log.Infof(context.Background(), "registering external lease transfer change: usage=%v changes=%v",
		usage, replicaChanges)
	changeIDs := as.mmAllocator.RegisterExternalChanges(replicaChanges[:])
	if changeIDs == nil {
		log.Info(context.Background(), "mma did not track lease transfer, skipping")
	}
	trackedChange := trackedAllocatorChange{
		typ:          AllocatorChangeTypeLeaseTransfer,
		usage:        usage,
		changeIDs:    changeIDs,
		transferFrom: transferFrom.StoreID,
		transferTo:   transferTo.StoreID,
	}
	// We only track one of the changeIDs, since they are the same for both
	// lease transfer.
	as.mu.Lock()
	defer as.mu.Unlock()
	syncChangeID := as.newSyncChangeIDLocked()
	as.mu.trackedChanges[syncChangeID] = trackedChange
	return syncChangeID
}

func (as *AllocatorSync) NonMMAPreChangeReplicas(
	desc *roachpb.RangeDescriptor,
	usage allocator.RangeUsageInfo,
	changes kvpb.ReplicationChanges,
	leaseholder roachpb.StoreID,
) SyncChangeID {
	rLoad := allocator.UsageInfoToMMALoad(usage)
	replicaChanges := make([]mma.ReplicaChange, 0, len(changes))
	replicaSet := desc.Replicas()

	var lhBeingRemoved bool
	for _, chg := range changes {
		if chg.ChangeType == roachpb.REMOVE_VOTER || chg.ChangeType == roachpb.REMOVE_NON_VOTER {
			filteredSet := replicaSet.Filter(func(r roachpb.ReplicaDescriptor) bool {
				return r.StoreID == chg.Target.StoreID
			})
			replDescriptors := filteredSet.Descriptors()
			if len(replDescriptors) != 1 {
				panic(fmt.Sprintf(
					"no replica found for removal target=%v post-filter=%v pre-filter=%v",
					chg.Target.StoreID, replDescriptors, desc))
			}
			replDesc := replDescriptors[0]
			lhBeingRemoved = replDesc.StoreID == leaseholder
			replicaChanges = append(replicaChanges, mma.MakeRemoveReplicaChange(
				desc.RangeID, rLoad, mma.ReplicaState{
					ReplicaIDAndType: mma.ReplicaIDAndType{
						ReplicaID: replDesc.ReplicaID,
						ReplicaType: mma.ReplicaType{
							ReplicaType:   replDesc.Type,
							IsLeaseholder: lhBeingRemoved,
						},
					},
				},
				chg.Target))
		}
	}

	for _, chg := range changes {
		if chg.ChangeType == roachpb.ADD_VOTER ||
			chg.ChangeType == roachpb.ADD_NON_VOTER {
			rType := roachpb.VOTER_FULL
			if chg.ChangeType == roachpb.ADD_NON_VOTER {
				rType = roachpb.NON_VOTER
			}
			replicaChanges = append(replicaChanges, mma.MakeAddReplicaChange(
				desc.RangeID, rLoad, mma.ReplicaState{
					ReplicaIDAndType: mma.ReplicaIDAndType{
						ReplicaType: mma.ReplicaType{
							ReplicaType: rType,
							// TODO(sumeer): can there be multiple ADD_VOTERs?
							IsLeaseholder: lhBeingRemoved && chg.ChangeType == roachpb.ADD_VOTER,
						},
					},
				}, chg.Target))
		} else if chg.ChangeType == roachpb.REMOVE_VOTER ||
			chg.ChangeType == roachpb.REMOVE_NON_VOTER {
			// Handled above.
			continue
		} else {
			panic("unimplemented change type")
		}
	}

	log.Infof(context.Background(), "registering external replica change: chgs=%v usage=%v changes=%v",
		changes, usage, replicaChanges)
	changeIDs := as.mmAllocator.RegisterExternalChanges(replicaChanges)
	if changeIDs == nil {
		log.Info(context.Background(), "cluster does not have a range for the external replica change, skipping")
	}
	trackedChange := trackedAllocatorChange{
		typ:       AllocatorChangeTypeChangeReplicas,
		usage:     usage,
		changeIDs: changeIDs,
		chgs:      changes,
	}
	log.Infof(context.Background(), "registered external replica change: chgs=%v change_ids=%v",
		changes, changeIDs)

	as.mu.Lock()
	defer as.mu.Unlock()
	syncChangeID := as.newSyncChangeIDLocked()
	as.mu.trackedChanges[syncChangeID] = trackedChange
	return syncChangeID
}

func (as *AllocatorSync) newSyncChangeIDLocked() SyncChangeID {
	as.mu.changeSeqGen += 1
	return as.mu.changeSeqGen
}

func (as *AllocatorSync) NonMMAPreRelocateRange(
	desc *roachpb.RangeDescriptor,
	usage allocator.RangeUsageInfo,
	voterTargets, nonVoterTargets []roachpb.ReplicationTarget,
) []mma.ChangeID {
	// TODO(sumeer): implement this, since it is needed for the old store
	// rebalancer to work.
	panic("unimplemented")
}

// MMAPreApply is called before mma generated changes are applied to the
// cluster.
func (as *AllocatorSync) MMAPreApply(
	usage allocator.RangeUsageInfo, pendingChange mma.PendingRangeChange,
) SyncChangeID {
	var trackedChange trackedAllocatorChange
	trackedChange.usage = usage
	trackedChange.changeIDs = pendingChange.ChangeIDs()
	if pendingChange.IsTransferLease() {
		trackedChange.typ = AllocatorChangeTypeLeaseTransfer
		trackedChange.transferTo = pendingChange.LeaseTransferTarget()
		trackedChange.transferFrom = pendingChange.LeaseTransferFrom()
	} else if pendingChange.IsChangeReplicas() {
		trackedChange.typ = AllocatorChangeTypeChangeReplicas
		trackedChange.chgs = pendingChange.ReplicationChanges()
	} else {
		panic("unexpected change type")
	}
	as.mu.Lock()
	defer as.mu.Unlock()
	syncChangeID := as.newSyncChangeIDLocked()
	as.mu.trackedChanges[syncChangeID] = trackedChange
	return syncChangeID
}

// PostApply is called after changes have been applied to the cluster, by both
// the old allocator components (lease queue, replicate queue and store
// rebalancer), as well as the new mma.Allocator.
func (as *AllocatorSync) PostApply(ctx context.Context, syncChangeID SyncChangeID, success bool) {
	var tracked trackedAllocatorChange
	func() {
		as.mu.Lock()
		defer as.mu.Unlock()
		var ok bool
		tracked, ok = as.mu.trackedChanges[syncChangeID]
		if !ok {
			panic("PostApply called with unknown SyncChangeID")
		}
		delete(as.mu.trackedChanges, syncChangeID)
	}()
	log.Infof(ctx, "PostApply: syncChangeID=%d success=%t tracked=%v",
		syncChangeID, success, tracked)

	if changeIDs := tracked.changeIDs; changeIDs != nil {
		as.mmAllocator.AdjustPendingChangesDisposition(changeIDs, success)
	}
	switch tracked.typ {
	case AllocatorChangeTypeLeaseTransfer:
		as.sp.UpdateLocalStoresAfterLeaseTransfer(tracked.transferFrom,
			tracked.transferTo, tracked.usage)
	case AllocatorChangeTypeChangeReplicas:
		for _, chg := range tracked.chgs {
			as.sp.UpdateLocalStoreAfterRebalance(
				chg.Target.StoreID, tracked.usage, chg.ChangeType)
		}
	case AllocatorChangeTypeRelocateRange:
		// TODO(kvoli): We don't need to implement this until later, as only one
		// store rebalancer will run at a time and only the old store rebalancer
		// issues relocate range commands.
		//
		// TODO(sumeer): We should implement it, and make all changes flow through
		// AllocatorSync, even when the mma.Allocator is not used, since that
		// simplifies the code.
		panic("unimplemented")
	}
}
