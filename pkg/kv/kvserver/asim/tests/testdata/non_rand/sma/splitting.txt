# This test verifies load-based splitting behavior in a single-store cluster.
# It tests both uniform and zipfian access patterns to ensure the split
# algorithm works correctly under different load distributions. With a 10k QPS
# load and 2.5k QPS split threshold, we expect approximately 4 splits for
# uniform access and more splits for zipfian due to hotspotting.
skip_under_ci
----

# Explore how load based and sized based splitting occur in isolation. In this
# example, there is only one store so no rebalancing activity should occur. 
gen_cluster nodes=1
----

gen_ranges ranges=1 repl_factor=1
----

# Create a load generator, where there is higher ops/s than the qps split
# threshold set above. Also set to use only reads, to avoid size based splits
# (we could also disable this via setting the range max size).
gen_load rate=10000 rw_ratio=1.0
----

setting split_qps_threshold=2500
----

# Assert that the number of replicas should not change at all during the last 6
# ticks of the simulation.
assertion stat=replicas type=steady ticks=6 exact_bound=0.00
----
asserting: |replicas(t)/mean_{T}(replicas) - 1| = 0.00 ∀ t∈T and each store (T=last 6 ticks)


# Examine the number of replicas. Here there were 5 load based splits. This
# roughly lines up with expectations, given a rate of 10,000 QPS and 2,500 QPS
# split threshold.
eval duration=5m samples=2 seed=42 metrics=(replicas) cfgs=(sma-count,mma-only)
----
replicas#1: first: [s1=1] (stddev=0.00, mean=1.00, sum=1)
replicas#1: last:  [s1=7] (stddev=0.00, mean=7.00, sum=7)
replicas#1: thrash_pct: [s1=0%]  (sum=0%)
replicas#2: first: [s1=1] (stddev=0.00, mean=1.00, sum=1)
replicas#2: last:  [s1=6] (stddev=0.00, mean=6.00, sum=6)
replicas#2: thrash_pct: [s1=0%]  (sum=0%)
artifacts[sma-count]: e66c4f62d98e923b
==========================
replicas#1: first: [s1=1] (stddev=0.00, mean=1.00, sum=1)
replicas#1: last:  [s1=7] (stddev=0.00, mean=7.00, sum=7)
replicas#1: thrash_pct: [s1=0%]  (sum=0%)
replicas#2: first: [s1=1] (stddev=0.00, mean=1.00, sum=1)
replicas#2: last:  [s1=6] (stddev=0.00, mean=6.00, sum=6)
replicas#2: thrash_pct: [s1=0%]  (sum=0%)
artifacts[mma-only]: e66c4f62d98e923b
==========================

# Update the load generator to use a zipfian distribution instead of a uniform.
# Now the load based splitter must find a split key from a skewed distribution
# repeatedly - if the load split algorithm is good, we should expect the same
# number of splits as the uniform workload. However, that is not the case as we
# require more splits with a zipfian distribution.
gen_load rate=10000 rw_ratio=1.0 access_skew=true replace=true
----

eval duration=5m samples=2 seed=42 metrics=(replicas) cfgs=(sma-count,mma-only)
----
replicas#1: first: [s1=1] (stddev=0.00, mean=1.00, sum=1)
replicas#1: last:  [s1=9] (stddev=0.00, mean=9.00, sum=9)
replicas#1: thrash_pct: [s1=0%]  (sum=0%)
replicas#2: first: [s1=1] (stddev=0.00, mean=1.00, sum=1)
replicas#2: last:  [s1=9] (stddev=0.00, mean=9.00, sum=9)
replicas#2: thrash_pct: [s1=0%]  (sum=0%)
artifacts[sma-count]: 9c1f11eaffcdb4e
==========================
replicas#1: first: [s1=1] (stddev=0.00, mean=1.00, sum=1)
replicas#1: last:  [s1=9] (stddev=0.00, mean=9.00, sum=9)
replicas#1: thrash_pct: [s1=0%]  (sum=0%)
replicas#2: first: [s1=1] (stddev=0.00, mean=1.00, sum=1)
replicas#2: last:  [s1=9] (stddev=0.00, mean=9.00, sum=9)
replicas#2: thrash_pct: [s1=0%]  (sum=0%)
artifacts[mma-only]: 9c1f11eaffcdb4e
==========================
