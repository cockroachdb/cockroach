skip_under_ci
----

# Explore how load based and sized based splitting occur in isolation. In this
# example, there is only one store so no rebalancing activity should occur. 
gen_cluster nodes=1
----

gen_ranges ranges=1 repl_factor=1
----

# Create a load generator, where there is higher ops/s than the qps split
# threshold set above. Also set to use only reads, to avoid size based splits
# (we could also disable this via setting the range max size).
gen_load rate=10000 rw_ratio=1
----

setting split_qps_threshold=2500
----

# Assert that the number of replicas should not change at all during the last 6
# ticks of the simulation.
assertion stat=replicas type=steady ticks=6 upper_bound=0.00
----

eval duration=5m samples=2 seed=42
----
[nodes: 1, stores_per_node:1, store_disk_capacity: 256GiB, node_capacity: 0cpu-sec/sec]
[workload: 10000ops/s(r:1,w:0), 1-1B/op, key=[1,10000]
[ranges: num_ranges=1, key=[0,10000], rf=1, range_size=0 MiB (even across stores)]
OK

# Examine the number of replicas. Here there were 5 load based splits. This
# roughly lines up with expectations, given a rate of 10,000 QPS and 2,500 QPS
# split threshold.
plot stat=replicas sample=2
----
 6.00 ┤         ╭─────────────────────────────────────────────────────────────────────
 5.67 ┤         │
 5.33 ┤         │
 5.00 ┤         │
 4.67 ┤         │
 4.33 ┤         │
 4.00 ┤      ╭──╯
 3.67 ┤      │
 3.33 ┤      │
 3.00 ┤      │
 2.67 ┤      │
 2.33 ┤      │
 2.00 ┤   ╭──╯
 1.67 ┤   │
 1.33 ┤   │
 1.00 ┼───╯
                                           replicas
initial store values: [s1=1] (stddev=0.00, mean=1.00, sum=1)
last store values: [s1=6] (stddev=0.00, mean=6.00, sum=6)

# Update the load generator to use a zipfian distribution instead of a uniform.
# Now the load based splitter must find a split key from a skewed distribution
# repeatedly - if the load split algorithm is good, we should expect the same
# number of splits as the uniform workload. However, that is not the case as we
# require more splits with a zipfian distribution.
gen_load rate=10000 rw_ratio=1 access_skew=true replace=true
----

eval duration=5m samples=2 seed=42
----
[nodes: 1, stores_per_node:1, store_disk_capacity: 256GiB, node_capacity: 0cpu-sec/sec]
[workload: 10000ops/s(r:1,w:0), 1-1B/op, key=[1,10000]
[ranges: num_ranges=1, key=[0,10000], rf=1, range_size=0 MiB (even across stores)]
OK

plot stat=replicas sample=4
----
 9.00 ┤                          ╭────────────────────────────────────────────────────
 8.47 ┤                          │
 7.93 ┤                      ╭───╯
 7.40 ┤                      │
 6.87 ┤                   ╭──╯
 6.33 ┤                   │
 5.80 ┤               ╭───╯
 5.27 ┤               │
 4.73 ┤            ╭──╯
 4.20 ┤         ╭──╯
 3.67 ┤         │
 3.13 ┤      ╭──╯
 2.60 ┤      │
 2.07 ┤   ╭──╯
 1.53 ┤   │
 1.00 ┼───╯
                                           replicas
initial store values: [s1=1] (stddev=0.00, mean=1.00, sum=1)
last store values: [s1=9] (stddev=0.00, mean=9.00, sum=9)

# vim:ft=sh
