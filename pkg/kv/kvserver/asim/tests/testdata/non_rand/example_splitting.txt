skip_under_ci
----

# Explore how load based and sized based splitting occur in isolation. In this
# example, there is only one store so no rebalancing activity should occur. 
gen_cluster nodes=1
----

gen_ranges ranges=1 repl_factor=1
----

# Create a load generator, where there is higher ops/s than the qps split
# threshold set above. Also set to use only reads, to avoid size based splits
# (we could also disable this via setting the range max size).
gen_load rate=10000 rw_ratio=1.0
----

setting split_qps_threshold=2500
----

# Assert that the number of replicas should not change at all during the last 6
# ticks of the simulation.
assertion stat=replicas type=steady ticks=6 exact_bound=0.00
----
asserting: |replicas(t)/mean_{T}(replicas) - 1| = 0.00 ∀ t∈T and each store (T=last 6 ticks)


# Examine the number of replicas. Here there were 5 load based splits. This
# roughly lines up with expectations, given a rate of 10,000 QPS and 2,500 QPS
# split threshold.
eval duration=5m samples=2 seed=42 metrics=(replicas) cfgs=(sma-count,mma-only,mma-count)
----
replicas#1: first: [s1=1] (stddev=0.00, mean=1.00, sum=1)
replicas#1: last:  [s1=6] (stddev=0.00, mean=6.00, sum=6)
replicas#1: thrash_pct: [s1=0%]  (sum=0%)
replicas#2: first: [s1=1] (stddev=0.00, mean=1.00, sum=1)
replicas#2: last:  [s1=6] (stddev=0.00, mean=6.00, sum=6)
replicas#2: thrash_pct: [s1=0%]  (sum=0%)
artifacts[sma-count]: 62ac1b2595570a64
==========================
replicas#1: first: [s1=1] (stddev=0.00, mean=1.00, sum=1)
replicas#1: last:  [s1=6] (stddev=0.00, mean=6.00, sum=6)
replicas#1: thrash_pct: [s1=0%]  (sum=0%)
replicas#2: first: [s1=1] (stddev=0.00, mean=1.00, sum=1)
replicas#2: last:  [s1=6] (stddev=0.00, mean=6.00, sum=6)
replicas#2: thrash_pct: [s1=0%]  (sum=0%)
artifacts[mma-only]: 7f8cb11357cb8494
==========================
replicas#1: first: [s1=1] (stddev=0.00, mean=1.00, sum=1)
replicas#1: last:  [s1=6] (stddev=0.00, mean=6.00, sum=6)
replicas#1: thrash_pct: [s1=0%]  (sum=0%)
replicas#2: first: [s1=1] (stddev=0.00, mean=1.00, sum=1)
replicas#2: last:  [s1=6] (stddev=0.00, mean=6.00, sum=6)
replicas#2: thrash_pct: [s1=0%]  (sum=0%)
artifacts[mma-count]: a851ba80a6edc423
==========================

# Update the load generator to use a zipfian distribution instead of a uniform.
# Now the load based splitter must find a split key from a skewed distribution
# repeatedly - if the load split algorithm is good, we should expect the same
# number of splits as the uniform workload. However, that is not the case as we
# require more splits with a zipfian distribution.
gen_load rate=10000 rw_ratio=1.0 access_skew=true replace=true
----

eval duration=5m samples=2 seed=42 metrics=(replicas) cfgs=(sma-count,mma-only,mma-count)
----
replicas#1: first: [s1=1] (stddev=0.00, mean=1.00, sum=1)
replicas#1: last:  [s1=9] (stddev=0.00, mean=9.00, sum=9)
replicas#1: thrash_pct: [s1=0%]  (sum=0%)
replicas#2: first: [s1=1] (stddev=0.00, mean=1.00, sum=1)
replicas#2: last:  [s1=9] (stddev=0.00, mean=9.00, sum=9)
replicas#2: thrash_pct: [s1=0%]  (sum=0%)
artifacts[sma-count]: fcc6171fb20aaf96
==========================
replicas#1: first: [s1=1] (stddev=0.00, mean=1.00, sum=1)
replicas#1: last:  [s1=10] (stddev=0.00, mean=10.00, sum=10)
replicas#1: thrash_pct: [s1=0%]  (sum=0%)
replicas#2: first: [s1=1] (stddev=0.00, mean=1.00, sum=1)
replicas#2: last:  [s1=9] (stddev=0.00, mean=9.00, sum=9)
replicas#2: thrash_pct: [s1=0%]  (sum=0%)
artifacts[mma-only]: 78253b79ec7c7d5a
==========================
replicas#1: first: [s1=1] (stddev=0.00, mean=1.00, sum=1)
replicas#1: last:  [s1=9] (stddev=0.00, mean=9.00, sum=9)
replicas#1: thrash_pct: [s1=0%]  (sum=0%)
replicas#2: first: [s1=1] (stddev=0.00, mean=1.00, sum=1)
replicas#2: last:  [s1=9] (stddev=0.00, mean=9.00, sum=9)
replicas#2: thrash_pct: [s1=0%]  (sum=0%)
artifacts[mma-count]: f7e0109322e2ee3c
==========================
