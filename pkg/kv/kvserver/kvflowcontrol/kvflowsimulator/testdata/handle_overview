# Walk through the basics of the datadriven syntax for handle tests.

# Initialize testing components, including a named handle h.
init
handle=h
----

# Connect the handle to three replication streams (like the leader+leaseholder
# for a triply replicated range would).
# - Start writing to the range at 2MiB/s across 10 reqs/s. 
# - Grab s1 snapshots at t=2 and t=3, to compare how things evolve.
# - Partway through, at t=4s, disconnect s2. 
# - From t=[10s,18s), start returning tokens from s1 and s3.
# - Grab s1 snapshots at t=16s, t=17s and t=19s to compare how things evolve.
# - Start writing to the range again at t=[20s,21s) at 2MiB/s across 10 reqs/s. 
# - At t=22s, close the handle. 
timeline
t=0s        handle=h op=connect    stream=t1/s1   log-position=4/0
t=0s        handle=h op=connect    stream=t1/s2   log-position=4/0
t=0s        handle=h op=connect    stream=t1/s3   log-position=4/0
t=2s        handle=h op=snapshot   stream=t1/s1
t=3s        handle=h op=snapshot   stream=t1/s1
t=4s        handle=h op=disconnect stream=t1/s2
t=[0s,8s)   handle=h class=regular adjust=-2MiB/s rate=10/s
t=[10s,18s) handle=h class=regular adjust=+2MiB/s rate=10/s stream=t1/s1
t=[10s,18s) handle=h class=regular adjust=+2MiB/s rate=10/s stream=t1/s3
t=16s       handle=h op=snapshot   stream=t1/s1
t=17s       handle=h op=snapshot   stream=t1/s1
t=19s       handle=h op=snapshot   stream=t1/s1
t=[20s,21s) handle=h class=regular adjust=-2MiB/s rate=10/s
t=21s       handle=h op=snapshot   stream=t1/s1
t=22s       handle=h op=close
----


simulate t=[0s,24s)
----

# We should observe a few things.
# - We've lazily instantiated three streams for regular traffic. Even when the
#   handle disconnects the stream from itself, it's still tracked by the
#   controller.
#   - Given there are three streams, we start off with 3*16MiB = 48MiB of
#     regular tokens.
#   - When three streams are connected, quorum writes at 2MiB/s translates to
#     token deductions at 3*2MiB/s = 6MiB/s. 
# - When s2 is disconnected from h:
#   - All s2-specific flow tokens deducted by h are returned. By t=4s, this
#     translates to 4s * 2MiB/s = 8MiB. We see this in both
#     regular_tokens_available and the 8MiB/s spike in
#     rate(regular_tokens_returned).
#   - The rate of token deductions decreases to 2*2MiB/s = 4MiB/s.
# - By the time quorum writes are blocked, the available regular tokens is
#   16MiB, corresponding to s2's fully available regular tokens.
plot t=[0s,10s)
kvadmission.flow_controller.regular_stream_count               unit=streams
kvadmission.flow_controller.regular_tokens_available           unit=MiB
kvadmission.flow_controller.regular_tokens_{deducted,returned} unit=MiB/s rate=true
----
----
 3.0 ┼───────────────────────────────────────
           regular_stream_count (streams)


 47.4 ┼╮
 45.3 ┤╰╮
 43.2 ┤ ╰╮
 41.1 ┤  ╰─╮
 39.0 ┤    ╰╮
 36.9 ┤     ╰─╮
 34.8 ┤       ╰╮
 32.7 ┤        ╰╮
 30.7 ┤         ╰─╮   ╭╮
 28.6 ┤           ╰╮  │╰──╮
 26.5 ┤            ╰╮ │   ╰─╮
 24.4 ┤             ╰─╯     ╰─╮
 22.3 ┤                       ╰─╮
 20.2 ┤                         ╰─╮
 18.1 ┤                           ╰─╮
 16.0 ┤                             ╰─────────
            regular_tokens_available (MiB)


 8.0 ┤               ╭───╮
 7.5 ┤               │   │
 6.9 ┤               │   │
 6.4 ┤               │   │
 5.9 ┤   ╭───────────│╮  │
 5.3 ┤   │           │╰╮ │
 4.8 ┤   │           │ ╰╮│
 4.3 ┤   │           │  ╰│───────────╮
 3.7 ┤   │           │   │           │
 3.2 ┤   │           │   │           ╰╮
 2.7 ┤   │           │   │            │
 2.1 ┤   │           │   │            ╰╮
 1.6 ┤   │           │   │             │
 1.1 ┤   │           │   │             ╰╮
 0.5 ┤   │           │   │              │
 0.0 ┼───────────────╯   ╰───────────────────
      rate(regular_tokens_{deducted,returned}) (MiB/s)
----
----


# This period corresponds to:
#   t=[20s,21s) handle=h class=regular adjust=-2MiB/s rate=10/s
#   t=22s       handle=h op=close
# Where the handle is connected to t1/s1 and t1/s3. Note how when the handle is
# closed, all 2MiB*2 = 4MiB tokens for s1 and s3 are returned.
plot t=[19s,24s)
kvadmission.flow_controller.regular_tokens_available           unit=MiB
kvadmission.flow_controller.regular_tokens_{deducted,returned} unit=MiB/s rate=true
----
----
 48.0 ┼───────╮               ╭───────────────
 47.7 ┤       │               │
 47.5 ┤       ╰╮              │
 47.2 ┤        ╰╮             │
 46.9 ┤         │             │
 46.7 ┤         ╰╮            │
 46.4 ┤          │            │
 46.1 ┤          ╰╮           │
 45.9 ┤           │           │
 45.6 ┤           ╰╮          │
 45.3 ┤            │          │
 45.1 ┤            ╰╮         │
 44.8 ┤             │         │
 44.5 ┤             ╰╮        │
 44.3 ┤              │        │
 44.0 ┤              ╰────────╯
            regular_tokens_available (MiB)


 4.0 ┤              ╭╮       ╭───────╮
 3.7 ┤              ││       │       │
 3.5 ┤             ╭╯╰╮      │       │
 3.2 ┤             │  │      │       │
 2.9 ┤            ╭╯  ╰╮     │       │
 2.7 ┤            │    ╰╮    │       │
 2.4 ┤           ╭╯     │    │       │
 2.1 ┤           │      ╰╮   │       │
 1.9 ┤          ╭╯       │   │       │
 1.6 ┤          │        ╰╮  │       │
 1.3 ┤         ╭╯         │  │       │
 1.1 ┤         │          ╰╮ │       │
 0.8 ┤        ╭╯           │ │       │
 0.5 ┤       ╭╯            ╰╮│       │
 0.3 ┤       │              ││       │
 0.0 ┼───────────────────────╯───────╰───────
      rate(regular_tokens_{deducted,returned}) (MiB/s)
----
----

# Observe captured snapshots.
# - At 10 reqs/s, by t=2s we have 10*2=20 tracked tokens from log positions
#   4/1 to 4/20. We add 10 more by t=3s, going up to 4/30.
# - At t=16s the we're tracking tokens from log positions 4/62 to 4/80. We
#   return tokens in 10 increments of 205KiB over the next second, so at t=17s
#   we've reduced the remaining tracked tokens by 10, now starting at 4/62.
# - At t=19s we have no outstanding tokens being tracked -- we've returned
#   everything.
# - At t=21s we've tracked a few more tokens; tokens we haven't returned yet.
#
# TODO(irfansharif): Support filtering this output by stream and time range.
snapshots handle=h
----
----
t=2s stream=t1/s1
 pri=normal-pri
  tokens=205KiB log-position=4/1
  tokens=205KiB log-position=4/2
  tokens=205KiB log-position=4/3
  tokens=205KiB log-position=4/4
  tokens=205KiB log-position=4/5
  tokens=205KiB log-position=4/6
  tokens=205KiB log-position=4/7
  tokens=205KiB log-position=4/8
  tokens=205KiB log-position=4/9
  tokens=205KiB log-position=4/10
  tokens=205KiB log-position=4/11
  tokens=205KiB log-position=4/12
  tokens=205KiB log-position=4/13
  tokens=205KiB log-position=4/14
  tokens=205KiB log-position=4/15
  tokens=205KiB log-position=4/16
  tokens=205KiB log-position=4/17
  tokens=205KiB log-position=4/18
  tokens=205KiB log-position=4/19
  tokens=205KiB log-position=4/20

t=3s stream=t1/s1
 pri=normal-pri
  tokens=205KiB log-position=4/1
  tokens=205KiB log-position=4/2
  tokens=205KiB log-position=4/3
  tokens=205KiB log-position=4/4
  tokens=205KiB log-position=4/5
  tokens=205KiB log-position=4/6
  tokens=205KiB log-position=4/7
  tokens=205KiB log-position=4/8
  tokens=205KiB log-position=4/9
  tokens=205KiB log-position=4/10
  tokens=205KiB log-position=4/11
  tokens=205KiB log-position=4/12
  tokens=205KiB log-position=4/13
  tokens=205KiB log-position=4/14
  tokens=205KiB log-position=4/15
  tokens=205KiB log-position=4/16
  tokens=205KiB log-position=4/17
  tokens=205KiB log-position=4/18
  tokens=205KiB log-position=4/19
  tokens=205KiB log-position=4/20
  tokens=205KiB log-position=4/21
  tokens=205KiB log-position=4/22
  tokens=205KiB log-position=4/23
  tokens=205KiB log-position=4/24
  tokens=205KiB log-position=4/25
  tokens=205KiB log-position=4/26
  tokens=205KiB log-position=4/27
  tokens=205KiB log-position=4/28
  tokens=205KiB log-position=4/29
  tokens=205KiB log-position=4/30

t=16s stream=t1/s1
 pri=normal-pri
  tokens=205KiB log-position=4/62
  tokens=205KiB log-position=4/63
  tokens=205KiB log-position=4/64
  tokens=205KiB log-position=4/65
  tokens=205KiB log-position=4/66
  tokens=205KiB log-position=4/67
  tokens=205KiB log-position=4/68
  tokens=205KiB log-position=4/69
  tokens=205KiB log-position=4/70
  tokens=205KiB log-position=4/71
  tokens=205KiB log-position=4/72
  tokens=205KiB log-position=4/73
  tokens=205KiB log-position=4/74
  tokens=205KiB log-position=4/75
  tokens=205KiB log-position=4/76
  tokens=205KiB log-position=4/77
  tokens=205KiB log-position=4/78
  tokens=205KiB log-position=4/79
  tokens=205KiB log-position=4/80

t=17s stream=t1/s1
 pri=normal-pri
  tokens=205KiB log-position=4/72
  tokens=205KiB log-position=4/73
  tokens=205KiB log-position=4/74
  tokens=205KiB log-position=4/75
  tokens=205KiB log-position=4/76
  tokens=205KiB log-position=4/77
  tokens=205KiB log-position=4/78
  tokens=205KiB log-position=4/79
  tokens=205KiB log-position=4/80

t=19s stream=t1/s1
 
t=21s stream=t1/s1
 pri=normal-pri
  tokens=205KiB log-position=4/81
  tokens=205KiB log-position=4/82
  tokens=205KiB log-position=4/83
  tokens=205KiB log-position=4/84
  tokens=205KiB log-position=4/85
  tokens=205KiB log-position=4/86
  tokens=205KiB log-position=4/87
  tokens=205KiB log-position=4/88
  tokens=205KiB log-position=4/89
  tokens=205KiB log-position=4/90
----
----

# vim:ft=conf
