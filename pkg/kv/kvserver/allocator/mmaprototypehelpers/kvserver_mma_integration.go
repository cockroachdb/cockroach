// Copyright 2025 The Cockroach Authors.
//
// Use of this software is governed by the CockroachDB Software License
// included in the /LICENSE file.

package mmaprototypehelpers

import (
	"context"
	"fmt"

	"github.com/cockroachdb/cockroach/pkg/kv/kvpb"
	"github.com/cockroachdb/cockroach/pkg/kv/kvserver/allocator"
	"github.com/cockroachdb/cockroach/pkg/kv/kvserver/allocator/mmaprototype"
	"github.com/cockroachdb/cockroach/pkg/kv/kvserver/allocator/storepool"
	"github.com/cockroachdb/cockroach/pkg/kv/kvserver/kvserverbase"
	"github.com/cockroachdb/cockroach/pkg/roachpb"
	"github.com/cockroachdb/cockroach/pkg/settings/cluster"
	"github.com/cockroachdb/cockroach/pkg/util/log"
	"github.com/cockroachdb/cockroach/pkg/util/syncutil"
)

type SyncChangeID uint64

const InvalidSyncChangeID SyncChangeID = 0

func (id SyncChangeID) IsValid() bool {
	return id != 0
}

type Author uint64

const (
	LeaseQueue Author = iota
	ReplicateQueue
	MMA
)

func (s Author) External() bool {
	switch s {
	case LeaseQueue:
		return true
	case ReplicateQueue:
		return true
	case MMA:
		return false
	default:
		panic("unknown Author")
	}
}

// The expected usage for the non-mma components is:
// changeIDs := allocatorSync.NonMMA(PreTransferLease|PreChangeReplicas)()
// // Actually apply the change, or when simulating, queue up the change to be
// // applied.
// allocatorSync.PostApply(changeIDs, success)

// AllocatorSync updates the storepool.Storepool and the mmaprototype.Allocator to be in
// sync with eachother, notifying each other of changes generated by the other.
//
// AllocatorSync doesn't apply the changes itself because simulation (asim)
// applies changes without blocking the goroutine, while in production code we
// apply the changes synchronously on the same goroutine.
type AllocatorSync struct {
	// TODO(wenyihu6): sp and mmAllocator shouldn't be exported but we are
	// exporting them for integration since they are used in the asim package.
	sp          *storepool.StorePool
	st          *cluster.Settings
	mmAllocator mmaprototype.Allocator
	mu          struct {
		syncutil.Mutex
		changeSeqGen   SyncChangeID
		trackedChanges map[SyncChangeID]trackedAllocatorChange
	}
}

func NewAllocatorSync(
	sp *storepool.StorePool, mmAllocator mmaprototype.Allocator, st *cluster.Settings,
) *AllocatorSync {
	as := &AllocatorSync{
		sp:          sp,
		mmAllocator: mmAllocator,
		st:          st,
	}
	as.mu.trackedChanges = make(map[SyncChangeID]trackedAllocatorChange)
	return as
}

type leaseTransferOp struct {
	transferFrom, transferTo roachpb.StoreID
	usage                    allocator.RangeUsageInfo
}

type changeReplicasOp struct {
	chgs  kvpb.ReplicationChanges
	usage allocator.RangeUsageInfo
}

type trackedAllocatorChange struct {
	author    Author
	usage     allocator.RangeUsageInfo
	changeIDs []mmaprototype.ChangeID

	leaseTransferOp  *leaseTransferOp
	changeReplicasOp *changeReplicasOp
}

func (as *AllocatorSync) NonMMAPreTransferLease(
	ctx context.Context,
	desc *roachpb.RangeDescriptor,
	usage allocator.RangeUsageInfo,
	transferFrom, transferTo roachpb.ReplicationTarget,
	author Author,
) SyncChangeID {
	existingReplicas := make([]mmaprototype.StoreIDAndReplicaState, len(desc.InternalReplicas))
	for i, replica := range desc.Replicas().Descriptors() {
		existingReplicas[i] = ReplicaDescriptorToReplicaIDAndType(replica, transferFrom.StoreID)
	}
	replicaChanges := mmaprototype.MakeLeaseTransferChanges(desc.RangeID,
		existingReplicas,
		UsageInfoToMMALoad(usage),
		transferTo,
		transferFrom,
	)
	log.Infof(ctx, "registering external lease transfer change: usage=%v changes=%v",
		usage, replicaChanges)
	var changeIDs []mmaprototype.ChangeID
	if kvserverbase.LoadBasedRebalancingMode.Get(&as.st.SV) == kvserverbase.LBRebalancingMultiMetric {
		changeIDs = as.mmAllocator.RegisterExternalChanges(replicaChanges[:])
		if changeIDs == nil {
			log.Info(ctx, "mma did not track lease transfer, skipping")
		}
	}
	trackedChange := trackedAllocatorChange{
		changeIDs: changeIDs,
		author:    author,
		leaseTransferOp: &leaseTransferOp{
			transferFrom: transferFrom.StoreID,
			transferTo:   transferTo.StoreID,
			usage:        usage,
		},
	}
	// We only track one of the changeIDs, since they are the same for both
	// lease transfer.
	as.mu.Lock()
	defer as.mu.Unlock()
	syncChangeID := as.newSyncChangeIDLocked()
	as.mu.trackedChanges[syncChangeID] = trackedChange
	return syncChangeID
}

func (as *AllocatorSync) NonMMAPreChangeReplicas(
	ctx context.Context,
	desc *roachpb.RangeDescriptor,
	usage allocator.RangeUsageInfo,
	changes kvpb.ReplicationChanges,
	leaseholder roachpb.StoreID,
) SyncChangeID {
	rLoad := UsageInfoToMMALoad(usage)
	replicaChanges := make([]mmaprototype.ReplicaChange, 0, len(changes))
	replicaSet := desc.Replicas()

	var lhBeingRemoved bool
	for _, chg := range changes {
		if chg.ChangeType == roachpb.REMOVE_VOTER || chg.ChangeType == roachpb.REMOVE_NON_VOTER {
			filteredSet := replicaSet.Filter(func(r roachpb.ReplicaDescriptor) bool {
				return r.StoreID == chg.Target.StoreID
			})
			replDescriptors := filteredSet.Descriptors()
			if len(replDescriptors) != 1 {
				panic(fmt.Sprintf(
					"no replica found for removal target=%v post-filter=%v pre-filter=%v",
					chg.Target.StoreID, replDescriptors, desc))
			}
			replDesc := replDescriptors[0]
			lhBeingRemoved = replDesc.StoreID == leaseholder
			replicaChanges = append(replicaChanges, mmaprototype.MakeRemoveReplicaChange(
				desc.RangeID, rLoad, mmaprototype.ReplicaState{
					ReplicaIDAndType: mmaprototype.ReplicaIDAndType{
						ReplicaID: replDesc.ReplicaID,
						ReplicaType: mmaprototype.ReplicaType{
							ReplicaType:   replDesc.Type,
							IsLeaseholder: lhBeingRemoved,
						},
					},
				},
				chg.Target))
		}
	}

	for _, chg := range changes {
		if chg.ChangeType == roachpb.ADD_VOTER ||
			chg.ChangeType == roachpb.ADD_NON_VOTER {
			rType := roachpb.VOTER_FULL
			if chg.ChangeType == roachpb.ADD_NON_VOTER {
				rType = roachpb.NON_VOTER
			}
			replicaChanges = append(replicaChanges, mmaprototype.MakeAddReplicaChange(
				desc.RangeID, rLoad, mmaprototype.ReplicaState{
					ReplicaIDAndType: mmaprototype.ReplicaIDAndType{
						ReplicaType: mmaprototype.ReplicaType{
							ReplicaType: rType,
							// TODO(sumeer): can there be multiple ADD_VOTERs?
							IsLeaseholder: lhBeingRemoved && chg.ChangeType == roachpb.ADD_VOTER,
						},
					},
				}, chg.Target))
		} else if chg.ChangeType == roachpb.REMOVE_VOTER ||
			chg.ChangeType == roachpb.REMOVE_NON_VOTER {
			// Handled above.
			continue
		} else {
			panic("unimplemented change type")
		}
	}

	log.Infof(ctx, "registering external replica change: chgs=%v usage=%v changes=%v",
		changes, usage, replicaChanges)
	var changeIDs []mmaprototype.ChangeID
	if kvserverbase.LoadBasedRebalancingMode.Get(&as.st.SV) == kvserverbase.LBRebalancingMultiMetric {
		changeIDs = as.mmAllocator.RegisterExternalChanges(replicaChanges)
		if changeIDs == nil {
			log.Info(ctx, "cluster does not have a range for the external replica change, skipping")
		}
	}
	trackedChange := trackedAllocatorChange{
		changeIDs: changeIDs,
		author:    ReplicateQueue,
		changeReplicasOp: &changeReplicasOp{
			chgs:  changes,
			usage: usage,
		},
	}
	log.Infof(ctx, "registered external replica change: chgs=%v change_ids=%v",
		changes, changeIDs)

	as.mu.Lock()
	defer as.mu.Unlock()
	syncChangeID := as.newSyncChangeIDLocked()
	as.mu.trackedChanges[syncChangeID] = trackedChange
	return syncChangeID
}

func (as *AllocatorSync) newSyncChangeIDLocked() SyncChangeID {
	as.mu.changeSeqGen += 1
	return as.mu.changeSeqGen
}

func (as *AllocatorSync) NonMMAPreRelocateRange(
	desc *roachpb.RangeDescriptor,
	usage allocator.RangeUsageInfo,
	voterTargets, nonVoterTargets []roachpb.ReplicationTarget,
) []mmaprototype.ChangeID {
	// TODO(sumeer): implement this, since it is needed for the old store
	// rebalancer to work.
	panic("unimplemented")
}

// MMAPreApply is called before mma generated changes are applied to the
// cluster.
func (as *AllocatorSync) MMAPreApply(
	ctx context.Context,
	usage allocator.RangeUsageInfo,
	pendingChange mmaprototype.PendingRangeChange,
) SyncChangeID {
	var trackedChange trackedAllocatorChange
	trackedChange.author = MMA
	trackedChange.changeIDs = pendingChange.ChangeIDs()
	if pendingChange.IsTransferLease() {
		trackedChange.leaseTransferOp = &leaseTransferOp{
			transferFrom: pendingChange.LeaseTransferFrom(),
			transferTo:   pendingChange.LeaseTransferTarget(),
			usage:        usage,
		}
		as.mmAllocator.Metrics().MMARegisterLeaseSuccess.Inc(1)
	} else if pendingChange.IsChangeReplicas() {
		trackedChange.changeReplicasOp = &changeReplicasOp{
			chgs:  pendingChange.ReplicationChanges(),
			usage: usage,
		}
		as.mmAllocator.Metrics().MMARegisterRebalanceSuccess.Inc(1)
	} else {
		panic("unexpected change type")
	}
	as.mu.Lock()
	defer as.mu.Unlock()
	syncChangeID := as.newSyncChangeIDLocked()
	as.mu.trackedChanges[syncChangeID] = trackedChange
	return syncChangeID
}

// PostApply is called after changes have been applied to the cluster, by both
// the old allocator components (lease queue, replicate queue and store
// rebalancer), as well as the new mmaprototype.Allocator.
func (as *AllocatorSync) PostApply(ctx context.Context, syncChangeID SyncChangeID, success bool) {
	if as == nil {
		return
	}
	var tracked trackedAllocatorChange
	func() {
		as.mu.Lock()
		defer as.mu.Unlock()
		var ok bool
		tracked, ok = as.mu.trackedChanges[syncChangeID]
		if !ok {
			panic("PostApply called with unknown SyncChangeID")
		}
		delete(as.mu.trackedChanges, syncChangeID)
	}()
	if kvserverbase.LoadBasedRebalancingMode.Get(&as.st.SV) == kvserverbase.LBRebalancingMultiMetric {
		if changeIDs := tracked.changeIDs; changeIDs != nil {
			log.Infof(ctx, "PostApply: tracked=%v change_ids=%v success: %v", tracked, changeIDs, success)
			as.mmAllocator.AdjustPendingChangesDisposition(changeIDs, success)
		} else {
			log.Infof(ctx, "PostApply: tracked=%v no change_ids success: %v", tracked, success)
		}
	}
	if !success {
		return
	}
	switch {
	case tracked.leaseTransferOp != nil:
		as.sp.UpdateLocalStoresAfterLeaseTransfer(tracked.leaseTransferOp.transferFrom,
			tracked.leaseTransferOp.transferTo, tracked.usage)
	case tracked.changeReplicasOp != nil:
		for _, chg := range tracked.changeReplicasOp.chgs {
			as.sp.UpdateLocalStoreAfterRebalance(
				chg.Target.StoreID, tracked.usage, chg.ChangeType)
		}
	default:
		// TODO(kvoli): We don't need to implement this until later, as only one
		// store rebalancer will run at a time and only the old store rebalancer
		// issues relocate range commands.
		//
		// TODO(sumeer): We should implement it, and make all changes flow through
		// AllocatorSync, even when the mma.Allocator is not used, since that
		// simplifies the code.
		panic("unimplemented")
	}
}
