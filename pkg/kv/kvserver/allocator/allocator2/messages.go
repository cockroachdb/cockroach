// Copyright 2023 The Cockroach Authors.
//
// Use of this software is governed by the Business Source License
// included in the file licenses/BSL.txt.
//
// As of the Change Date specified in that file, in accordance with
// the Business Source License, use of this software will be governed
// by the Apache License, Version 2.0, included in the file
// licenses/APL.txt.

package allocator2

import "github.com/cockroachdb/cockroach/pkg/roachpb"

// Incoming messages for updating cluster state.
//
// This is a stop-gap and we will substitute these with protos.
//
// TODO: add corresponding protos.

type storeLoadMsg struct {
	roachpb.StoreID

	load loadVector
	// storeRanges are only used for adjusting the accounting for load
	// adjustments for pending changes.
	storeRanges []storeRange

	capacity      loadVector
	secondaryLoad secondaryLoadVector
	topKRanges    []struct {
		roachpb.RangeID
		rangeLoad
	}
	meanNonTopKRangeLoad rangeLoad
}

type storeRange struct {
	// We don't bother with ReplicaID since only used for load adjustments.
	roachpb.RangeID
	// Only valid ReplicaTypes are used here.
	replicaType
}

type storeLeaseholderMsg struct {
	roachpb.StoreID

	// NB: storeRanges and ranges do not need to be consistent. The ranges is
	// providing authoritative information from the leaseholder. storeRange can
	// lag in that we may not include a range or the fact that this store is the
	// leaseholder, if the effect of that range on the load is not yet properly
	// accounted for.
	ranges []rangeMsg
}

// rangeMsg is generated by the leaseholder store. If there is any change for
// that range, the full information for that range is provided. This will also
// be the case for a new leaseholder since it does not know whether something
// has changed since the last leaseholder informed the allocator.
//
// Also used in a best-effort manner to tell the allocator of ranges that no
// longer exist.
type rangeMsg struct {
	roachpb.RangeID
	start    roachpb.Key
	end      roachpb.Key
	replicas []storeIDAndReplicaState
	conf     roachpb.SpanConfig
}

func (rm *rangeMsg) isDeletedRange() bool {
	return len(rm.replicas) == 0
}

// Sent periodically in response to polling by the allocator.
type nodeLoadResponse struct {
	// -1 if this nodeLoadMsg is not a diff. Responder can unilaterally send a
	// complete load even if the sender asked for a diff.
	lastLoadSeqNum int64
	curLoadSeqNum  int64

	nodeLoad
	stores            []storeLoadMsg
	leaseholderStores []storeLeaseholderMsg
}

// The request corresponding to nodeLoadResponse.
type nodeLoadRequest struct {
	// Set to -1 if desire a complete load.
	lastReceivedLoadSeqNum int64
}
