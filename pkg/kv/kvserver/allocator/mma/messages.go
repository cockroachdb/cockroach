// Copyright 2023 The Cockroach Authors.
//
// Use of this software is governed by the CockroachDB Software License
// included in the /LICENSE file.

package mma

import (
	"time"

	"github.com/cockroachdb/cockroach/pkg/roachpb"
	"github.com/cockroachdb/redact"
)

// Incoming messages for updating cluster state.

// StoreLoadMsg is periodically sent by each store.
type StoreLoadMsg struct {
	roachpb.NodeID
	roachpb.StoreID

	Load LoadVector
	// Capacity[CPURate] is derived based on considering the aggregate usage
	// across all stores, and using the utilization observed at the node, to
	// derive a node level capacity, and then dividing that by the number of
	// stores.
	Capacity      LoadVector
	SecondaryLoad SecondaryLoadVector

	LoadTime time.Time
}

func (slm *StoreLoadMsg) String() string {
	return redact.StringWithoutMarkers(slm)
}

func (slm *StoreLoadMsg) SafeFormat(w redact.SafePrinter, _ rune) {
	w.Printf("StoreLoadMsg{NodeID: %d, StoreID: %d, Load: %v, Capacity: %v, SecondaryLoad: %v, LoadTime: %v}",
		slm.NodeID, slm.StoreID, slm.Load, slm.Capacity, slm.SecondaryLoad, slm.LoadTime)
}

// StoreLeaseholderMsg is sent by a local store and includes information about
// all ranges for which this store is the leaseholder. The range information
// includes other replica stores. This is a local message and will be sent
// before every allocator pass, so that the allocator has the latest state to
// make decisions.
type StoreLeaseholderMsg struct {
	roachpb.StoreID

	// Ranges provides authoritative information from the leaseholder.
	Ranges []RangeMsg
}

func (slm *StoreLeaseholderMsg) SafeFormat(w redact.SafePrinter, _ rune) {
	w.Printf("StoreLeaseholderMsg{storeID: %d, Ranges: %v}", slm.StoreID, slm.Ranges)
}

func (slm *StoreLeaseholderMsg) String() string {
	return redact.StringWithoutMarkers(slm)
}

// RangeMsg is generated by the leaseholder store (and part of
// StoreLeaseholderMsg). If there is any change for that range, the full
// information for that range is provided (and Populated is set to true). This
// is also the case for a new leaseholder since it does not know whether
// something has changed since the last leaseholder informed the allocator. A
// tiny change to the RangeLoad (decided by the caller) will not cause the
// fields to be populated.
//
// To ensure that the allocator does not lose synchronization with the current
// set of replicas, due to spurious changes (we had one undiagnosed example
// where the allocator was spuriously told that a lease was transferred away),
// the Replicas field is always populated).
type RangeMsg struct {
	roachpb.RangeID
	Replicas  []StoreIDAndReplicaState
	Populated bool
	Conf      roachpb.SpanConfig
	RangeLoad RangeLoad
}

func (rm RangeMsg) String() string {
	return redact.StringWithoutMarkers(rm)
}

func (rm RangeMsg) SafeFormat(w redact.SafePrinter, _ rune) {
	w.Printf("RangeMsg{RangeID: %d, Replicas: %v, Populated: %v, Conf: %v, RangeLoad: %v}",
		rm.RangeID, rm.Replicas, rm.Populated, rm.Conf, rm.RangeLoad)
}

func (rm *RangeMsg) isDeletedRange() bool {
	return len(rm.Replicas) == 0
}

// Avoid unused lint errors.

var _ = (&RangeMsg{}).isDeletedRange
var _ = StoreLoadMsg{}.StoreID
var _ = StoreLoadMsg{}.Load
var _ = StoreLoadMsg{}.Capacity
var _ = StoreLoadMsg{}.SecondaryLoad
var _ = StoreLeaseholderMsg{}.StoreID
var _ = StoreLeaseholderMsg{}.Ranges
var _ = RangeMsg{}.RangeID
var _ = RangeMsg{}.Replicas
var _ = RangeMsg{}.Conf
var _ = RangeMsg{}.RangeLoad
