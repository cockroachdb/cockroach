// Copyright 2022 The Cockroach Authors.
//
// Use of this software is governed by the Business Source License
// included in the file licenses/BSL.txt.
//
// As of the Change Date specified in that file, in accordance with
// the Business Source License, use of this software will be governed
// by the Apache License, Version 2.0, included in the file
// licenses/APL.txt.

package kvstreamer

import (
	"fmt"
	"unsafe"

	"github.com/cockroachdb/cockroach/pkg/kv/kvpb"
	"github.com/cockroachdb/cockroach/pkg/roachpb"
)

const (
	intSliceOverhead          = int64(unsafe.Sizeof([]int{}))
	intSize                   = int64(unsafe.Sizeof(int(0)))
	int32SliceOverhead        = int64(unsafe.Sizeof([]int32{}))
	int32Size                 = int64(unsafe.Sizeof(int32(0)))
	requestUnionSliceOverhead = int64(unsafe.Sizeof([]kvpb.RequestUnion{}))
	requestUnionOverhead      = int64(unsafe.Sizeof(kvpb.RequestUnion{}))
	requestOverhead           = int64(unsafe.Sizeof(kvpb.RequestUnion_Get{}) +
		unsafe.Sizeof(kvpb.GetRequest{}))
	responseUnionOverhead = int64(unsafe.Sizeof(kvpb.ResponseUnion_Get{}))
	getResponseOverhead   = int64(unsafe.Sizeof(kvpb.GetResponse{}))
	scanResponseOverhead  = int64(unsafe.Sizeof(kvpb.ScanResponse{}))
)

var zeroInt32Slice []int32

func init() {
	scanRequestOverhead := int64(unsafe.Sizeof(kvpb.RequestUnion_Scan{}) +
		unsafe.Sizeof(kvpb.ScanRequest{}))
	// TODO(XXX): understand this.
	if requestOverhead+8 != scanRequestOverhead {
		panic(fmt.Sprintf("GetRequest and ScanRequest have different overheads %d and scan req %d", requestOverhead, scanRequestOverhead))
	}
	scanResponseUnionOverhead := int64(unsafe.Sizeof(kvpb.ResponseUnion_Scan{}))
	if responseUnionOverhead != scanResponseUnionOverhead {
		panic("ResponseUnion_Get and ResponseUnion_Scan have different overheads")
	}
	zeroInt32Slice = make([]int32, 1<<10)
}

// Note that we cannot use Size() methods that are automatically generated by
// the protobuf library because
// - they calculate the size of the serialized message whereas we're interested
// in the deserialized in-memory footprint.
// - they account for things differently from how the memory usage is accounted
// for by the KV layer for the purposes of tracking TargetBytes limit.

// requestSize calculates the footprint of a request including the overhead. key
// and endKey are the keys from the span of the request header (we choose to
// avoid taking in a roachpb.Span in order to reduce allocations).
func requestSize(key, endKey roachpb.Key) int64 {
	return requestOverhead + int64(cap(key)) + int64(cap(endKey))
}

func requestsMemUsage(reqs []kvpb.RequestUnion) (memUsage int64) {
	for _, r := range reqs {
		h := r.GetInner().Header()
		memUsage += requestSize(h.Key, h.EndKey)
	}
	return memUsage
}

// getResponseSize calculates the size of the GetResponse similar to how it is
// accounted for TargetBytes parameter by the KV layer.
func getResponseSize(get *kvpb.GetResponse) int64 {
	if get.Value == nil {
		return 0
	}
	return int64(len(get.Value.RawBytes))
}

// scanResponseSize calculates the size of the ScanResponse similar to how it is
// accounted for TargetBytes parameter by the KV layer.
func scanResponseSize(scan *kvpb.ScanResponse) int64 {
	return scan.NumBytes
}
