// GENERATED FILE DO NOT EDIT
/*eslint-disable block-scoped-var, no-redeclare, no-control-regex, no-prototype-builtins*/
import * as $protobuf from "protobufjs";

// Common aliases
const $Reader = $protobuf.Reader, $Writer = $protobuf.Writer, $util = $protobuf.util;

// Exported root namespace
const $root = $protobuf.roots["default"] || ($protobuf.roots["default"] = {});

export const cockroach = $root.cockroach = (() => {

    /**
     * Namespace cockroach.
     * @exports cockroach
     * @namespace
     */
    const cockroach = {};

    cockroach.server = (function() {

        /**
         * Namespace server.
         * @exports cockroach.server
         * @namespace
         */
        const server = {};

        server.serverpb = (function() {

            /**
             * Namespace serverpb.
             * @exports cockroach.server.serverpb
             * @namespace
             */
            const serverpb = {};

            /**
             * ZoneConfigurationLevel enum.
             * @name ZoneConfigurationLevel
             * @memberof cockroach.server.serverpb
             * @enum {number}
             * @property {number} UNKNOWN=0 UNKNOWN value
             * @property {number} CLUSTER=1 CLUSTER value
             * @property {number} DATABASE=2 DATABASE value
             * @property {number} TABLE=3 TABLE value
             */
            serverpb.ZoneConfigurationLevel = (function() {
                const valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "UNKNOWN"] = 0;
                values[valuesById[1] = "CLUSTER"] = 1;
                values[valuesById[2] = "DATABASE"] = 2;
                values[valuesById[3] = "TABLE"] = 3;
                return values;
            })();

            serverpb.DatabasesRequest = (function() {

                /**
                 * Properties of a DatabasesRequest.
                 * @typedef cockroach.server.serverpb.DatabasesRequest$Properties
                 * @type {Object}
                 */

                /**
                 * Constructs a new DatabasesRequest.
                 * @exports cockroach.server.serverpb.DatabasesRequest
                 * @constructor
                 * @param {cockroach.server.serverpb.DatabasesRequest$Properties=} [properties] Properties to set
                 */
                function DatabasesRequest(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Creates a new DatabasesRequest instance using the specified properties.
                 * @param {cockroach.server.serverpb.DatabasesRequest$Properties=} [properties] Properties to set
                 * @returns {cockroach.server.serverpb.DatabasesRequest} DatabasesRequest instance
                 */
                DatabasesRequest.create = function create(properties) {
                    return new DatabasesRequest(properties);
                };

                /**
                 * Encodes the specified DatabasesRequest message. Does not implicitly {@link cockroach.server.serverpb.DatabasesRequest.verify|verify} messages.
                 * @param {cockroach.server.serverpb.DatabasesRequest$Properties} message DatabasesRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                DatabasesRequest.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    return writer;
                };

                /**
                 * Encodes the specified DatabasesRequest message, length delimited. Does not implicitly {@link cockroach.server.serverpb.DatabasesRequest.verify|verify} messages.
                 * @param {cockroach.server.serverpb.DatabasesRequest$Properties} message DatabasesRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                DatabasesRequest.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a DatabasesRequest message from the specified reader or buffer.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {cockroach.server.serverpb.DatabasesRequest} DatabasesRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                DatabasesRequest.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.cockroach.server.serverpb.DatabasesRequest();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a DatabasesRequest message from the specified reader or buffer, length delimited.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {cockroach.server.serverpb.DatabasesRequest} DatabasesRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                DatabasesRequest.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a DatabasesRequest message.
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {?string} `null` if valid, otherwise the reason why it is not
                 */
                DatabasesRequest.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    return null;
                };

                /**
                 * Creates a DatabasesRequest message from a plain object. Also converts values to their respective internal types.
                 * @param {Object.<string,*>} object Plain object
                 * @returns {cockroach.server.serverpb.DatabasesRequest} DatabasesRequest
                 */
                DatabasesRequest.fromObject = function fromObject(object) {
                    if (object instanceof $root.cockroach.server.serverpb.DatabasesRequest)
                        return object;
                    return new $root.cockroach.server.serverpb.DatabasesRequest();
                };

                /**
                 * Creates a DatabasesRequest message from a plain object. Also converts values to their respective internal types.
                 * This is an alias of {@link cockroach.server.serverpb.DatabasesRequest.fromObject}.
                 * @function
                 * @param {Object.<string,*>} object Plain object
                 * @returns {cockroach.server.serverpb.DatabasesRequest} DatabasesRequest
                 */
                DatabasesRequest.from = DatabasesRequest.fromObject;

                /**
                 * Creates a plain object from a DatabasesRequest message. Also converts values to other types if specified.
                 * @param {cockroach.server.serverpb.DatabasesRequest} message DatabasesRequest
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                DatabasesRequest.toObject = function toObject() {
                    return {};
                };

                /**
                 * Creates a plain object from this DatabasesRequest message. Also converts values to other types if specified.
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                DatabasesRequest.prototype.toObject = function toObject(options) {
                    return this.constructor.toObject(this, options);
                };

                /**
                 * Converts this DatabasesRequest to JSON.
                 * @returns {Object.<string,*>} JSON object
                 */
                DatabasesRequest.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return DatabasesRequest;
            })();

            serverpb.DatabasesResponse = (function() {

                /**
                 * Properties of a DatabasesResponse.
                 * @typedef cockroach.server.serverpb.DatabasesResponse$Properties
                 * @type {Object}
                 * @property {Array.<string>} [databases] DatabasesResponse databases.
                 */

                /**
                 * Constructs a new DatabasesResponse.
                 * @exports cockroach.server.serverpb.DatabasesResponse
                 * @constructor
                 * @param {cockroach.server.serverpb.DatabasesResponse$Properties=} [properties] Properties to set
                 */
                function DatabasesResponse(properties) {
                    this.databases = [];
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * DatabasesResponse databases.
                 * @type {Array.<string>}
                 */
                DatabasesResponse.prototype.databases = $util.emptyArray;

                /**
                 * Creates a new DatabasesResponse instance using the specified properties.
                 * @param {cockroach.server.serverpb.DatabasesResponse$Properties=} [properties] Properties to set
                 * @returns {cockroach.server.serverpb.DatabasesResponse} DatabasesResponse instance
                 */
                DatabasesResponse.create = function create(properties) {
                    return new DatabasesResponse(properties);
                };

                /**
                 * Encodes the specified DatabasesResponse message. Does not implicitly {@link cockroach.server.serverpb.DatabasesResponse.verify|verify} messages.
                 * @param {cockroach.server.serverpb.DatabasesResponse$Properties} message DatabasesResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                DatabasesResponse.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.databases != null && message.databases.length)
                        for (let i = 0; i < message.databases.length; ++i)
                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.databases[i]);
                    return writer;
                };

                /**
                 * Encodes the specified DatabasesResponse message, length delimited. Does not implicitly {@link cockroach.server.serverpb.DatabasesResponse.verify|verify} messages.
                 * @param {cockroach.server.serverpb.DatabasesResponse$Properties} message DatabasesResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                DatabasesResponse.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a DatabasesResponse message from the specified reader or buffer.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {cockroach.server.serverpb.DatabasesResponse} DatabasesResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                DatabasesResponse.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.cockroach.server.serverpb.DatabasesResponse();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (!(message.databases && message.databases.length))
                                message.databases = [];
                            message.databases.push(reader.string());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a DatabasesResponse message from the specified reader or buffer, length delimited.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {cockroach.server.serverpb.DatabasesResponse} DatabasesResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                DatabasesResponse.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a DatabasesResponse message.
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {?string} `null` if valid, otherwise the reason why it is not
                 */
                DatabasesResponse.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.databases != null && message.hasOwnProperty("databases")) {
                        if (!Array.isArray(message.databases))
                            return "databases: array expected";
                        for (let i = 0; i < message.databases.length; ++i)
                            if (!$util.isString(message.databases[i]))
                                return "databases: string[] expected";
                    }
                    return null;
                };

                /**
                 * Creates a DatabasesResponse message from a plain object. Also converts values to their respective internal types.
                 * @param {Object.<string,*>} object Plain object
                 * @returns {cockroach.server.serverpb.DatabasesResponse} DatabasesResponse
                 */
                DatabasesResponse.fromObject = function fromObject(object) {
                    if (object instanceof $root.cockroach.server.serverpb.DatabasesResponse)
                        return object;
                    let message = new $root.cockroach.server.serverpb.DatabasesResponse();
                    if (object.databases) {
                        if (!Array.isArray(object.databases))
                            throw TypeError(".cockroach.server.serverpb.DatabasesResponse.databases: array expected");
                        message.databases = [];
                        for (let i = 0; i < object.databases.length; ++i)
                            message.databases[i] = String(object.databases[i]);
                    }
                    return message;
                };

                /**
                 * Creates a DatabasesResponse message from a plain object. Also converts values to their respective internal types.
                 * This is an alias of {@link cockroach.server.serverpb.DatabasesResponse.fromObject}.
                 * @function
                 * @param {Object.<string,*>} object Plain object
                 * @returns {cockroach.server.serverpb.DatabasesResponse} DatabasesResponse
                 */
                DatabasesResponse.from = DatabasesResponse.fromObject;

                /**
                 * Creates a plain object from a DatabasesResponse message. Also converts values to other types if specified.
                 * @param {cockroach.server.serverpb.DatabasesResponse} message DatabasesResponse
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                DatabasesResponse.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.arrays || options.defaults)
                        object.databases = [];
                    if (message.databases && message.databases.length) {
                        object.databases = [];
                        for (let j = 0; j < message.databases.length; ++j)
                            object.databases[j] = message.databases[j];
                    }
                    return object;
                };

                /**
                 * Creates a plain object from this DatabasesResponse message. Also converts values to other types if specified.
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                DatabasesResponse.prototype.toObject = function toObject(options) {
                    return this.constructor.toObject(this, options);
                };

                /**
                 * Converts this DatabasesResponse to JSON.
                 * @returns {Object.<string,*>} JSON object
                 */
                DatabasesResponse.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return DatabasesResponse;
            })();

            serverpb.DatabaseDetailsRequest = (function() {

                /**
                 * Properties of a DatabaseDetailsRequest.
                 * @typedef cockroach.server.serverpb.DatabaseDetailsRequest$Properties
                 * @type {Object}
                 * @property {string} [database] DatabaseDetailsRequest database.
                 */

                /**
                 * Constructs a new DatabaseDetailsRequest.
                 * @exports cockroach.server.serverpb.DatabaseDetailsRequest
                 * @constructor
                 * @param {cockroach.server.serverpb.DatabaseDetailsRequest$Properties=} [properties] Properties to set
                 */
                function DatabaseDetailsRequest(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * DatabaseDetailsRequest database.
                 * @type {string}
                 */
                DatabaseDetailsRequest.prototype.database = "";

                /**
                 * Creates a new DatabaseDetailsRequest instance using the specified properties.
                 * @param {cockroach.server.serverpb.DatabaseDetailsRequest$Properties=} [properties] Properties to set
                 * @returns {cockroach.server.serverpb.DatabaseDetailsRequest} DatabaseDetailsRequest instance
                 */
                DatabaseDetailsRequest.create = function create(properties) {
                    return new DatabaseDetailsRequest(properties);
                };

                /**
                 * Encodes the specified DatabaseDetailsRequest message. Does not implicitly {@link cockroach.server.serverpb.DatabaseDetailsRequest.verify|verify} messages.
                 * @param {cockroach.server.serverpb.DatabaseDetailsRequest$Properties} message DatabaseDetailsRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                DatabaseDetailsRequest.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.database != null && message.hasOwnProperty("database"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.database);
                    return writer;
                };

                /**
                 * Encodes the specified DatabaseDetailsRequest message, length delimited. Does not implicitly {@link cockroach.server.serverpb.DatabaseDetailsRequest.verify|verify} messages.
                 * @param {cockroach.server.serverpb.DatabaseDetailsRequest$Properties} message DatabaseDetailsRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                DatabaseDetailsRequest.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a DatabaseDetailsRequest message from the specified reader or buffer.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {cockroach.server.serverpb.DatabaseDetailsRequest} DatabaseDetailsRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                DatabaseDetailsRequest.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.cockroach.server.serverpb.DatabaseDetailsRequest();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.database = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a DatabaseDetailsRequest message from the specified reader or buffer, length delimited.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {cockroach.server.serverpb.DatabaseDetailsRequest} DatabaseDetailsRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                DatabaseDetailsRequest.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a DatabaseDetailsRequest message.
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {?string} `null` if valid, otherwise the reason why it is not
                 */
                DatabaseDetailsRequest.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.database != null && message.hasOwnProperty("database"))
                        if (!$util.isString(message.database))
                            return "database: string expected";
                    return null;
                };

                /**
                 * Creates a DatabaseDetailsRequest message from a plain object. Also converts values to their respective internal types.
                 * @param {Object.<string,*>} object Plain object
                 * @returns {cockroach.server.serverpb.DatabaseDetailsRequest} DatabaseDetailsRequest
                 */
                DatabaseDetailsRequest.fromObject = function fromObject(object) {
                    if (object instanceof $root.cockroach.server.serverpb.DatabaseDetailsRequest)
                        return object;
                    let message = new $root.cockroach.server.serverpb.DatabaseDetailsRequest();
                    if (object.database != null)
                        message.database = String(object.database);
                    return message;
                };

                /**
                 * Creates a DatabaseDetailsRequest message from a plain object. Also converts values to their respective internal types.
                 * This is an alias of {@link cockroach.server.serverpb.DatabaseDetailsRequest.fromObject}.
                 * @function
                 * @param {Object.<string,*>} object Plain object
                 * @returns {cockroach.server.serverpb.DatabaseDetailsRequest} DatabaseDetailsRequest
                 */
                DatabaseDetailsRequest.from = DatabaseDetailsRequest.fromObject;

                /**
                 * Creates a plain object from a DatabaseDetailsRequest message. Also converts values to other types if specified.
                 * @param {cockroach.server.serverpb.DatabaseDetailsRequest} message DatabaseDetailsRequest
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                DatabaseDetailsRequest.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults)
                        object.database = "";
                    if (message.database != null && message.hasOwnProperty("database"))
                        object.database = message.database;
                    return object;
                };

                /**
                 * Creates a plain object from this DatabaseDetailsRequest message. Also converts values to other types if specified.
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                DatabaseDetailsRequest.prototype.toObject = function toObject(options) {
                    return this.constructor.toObject(this, options);
                };

                /**
                 * Converts this DatabaseDetailsRequest to JSON.
                 * @returns {Object.<string,*>} JSON object
                 */
                DatabaseDetailsRequest.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return DatabaseDetailsRequest;
            })();

            serverpb.DatabaseDetailsResponse = (function() {

                /**
                 * Properties of a DatabaseDetailsResponse.
                 * @typedef cockroach.server.serverpb.DatabaseDetailsResponse$Properties
                 * @type {Object}
                 * @property {Array.<cockroach.server.serverpb.DatabaseDetailsResponse.Grant$Properties>} [grants] DatabaseDetailsResponse grants.
                 * @property {Array.<string>} [table_names] DatabaseDetailsResponse table_names.
                 * @property {Long} [descriptor_id] DatabaseDetailsResponse descriptor_id.
                 * @property {cockroach.config.ZoneConfig$Properties} [zone_config] DatabaseDetailsResponse zone_config.
                 * @property {cockroach.server.serverpb.ZoneConfigurationLevel} [zone_config_level] DatabaseDetailsResponse zone_config_level.
                 */

                /**
                 * Constructs a new DatabaseDetailsResponse.
                 * @exports cockroach.server.serverpb.DatabaseDetailsResponse
                 * @constructor
                 * @param {cockroach.server.serverpb.DatabaseDetailsResponse$Properties=} [properties] Properties to set
                 */
                function DatabaseDetailsResponse(properties) {
                    this.grants = [];
                    this.table_names = [];
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * DatabaseDetailsResponse grants.
                 * @type {Array.<cockroach.server.serverpb.DatabaseDetailsResponse.Grant$Properties>}
                 */
                DatabaseDetailsResponse.prototype.grants = $util.emptyArray;

                /**
                 * DatabaseDetailsResponse table_names.
                 * @type {Array.<string>}
                 */
                DatabaseDetailsResponse.prototype.table_names = $util.emptyArray;

                /**
                 * DatabaseDetailsResponse descriptor_id.
                 * @type {Long}
                 */
                DatabaseDetailsResponse.prototype.descriptor_id = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

                /**
                 * DatabaseDetailsResponse zone_config.
                 * @type {(cockroach.config.ZoneConfig$Properties|null)}
                 */
                DatabaseDetailsResponse.prototype.zone_config = null;

                /**
                 * DatabaseDetailsResponse zone_config_level.
                 * @type {cockroach.server.serverpb.ZoneConfigurationLevel}
                 */
                DatabaseDetailsResponse.prototype.zone_config_level = 0;

                /**
                 * Creates a new DatabaseDetailsResponse instance using the specified properties.
                 * @param {cockroach.server.serverpb.DatabaseDetailsResponse$Properties=} [properties] Properties to set
                 * @returns {cockroach.server.serverpb.DatabaseDetailsResponse} DatabaseDetailsResponse instance
                 */
                DatabaseDetailsResponse.create = function create(properties) {
                    return new DatabaseDetailsResponse(properties);
                };

                /**
                 * Encodes the specified DatabaseDetailsResponse message. Does not implicitly {@link cockroach.server.serverpb.DatabaseDetailsResponse.verify|verify} messages.
                 * @param {cockroach.server.serverpb.DatabaseDetailsResponse$Properties} message DatabaseDetailsResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                DatabaseDetailsResponse.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.grants != null && message.grants.length)
                        for (let i = 0; i < message.grants.length; ++i)
                            $root.cockroach.server.serverpb.DatabaseDetailsResponse.Grant.encode(message.grants[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.table_names != null && message.table_names.length)
                        for (let i = 0; i < message.table_names.length; ++i)
                            writer.uint32(/* id 2, wireType 2 =*/18).string(message.table_names[i]);
                    if (message.descriptor_id != null && message.hasOwnProperty("descriptor_id"))
                        writer.uint32(/* id 3, wireType 0 =*/24).int64(message.descriptor_id);
                    if (message.zone_config != null && message.hasOwnProperty("zone_config"))
                        $root.cockroach.config.ZoneConfig.encode(message.zone_config, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                    if (message.zone_config_level != null && message.hasOwnProperty("zone_config_level"))
                        writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.zone_config_level);
                    return writer;
                };

                /**
                 * Encodes the specified DatabaseDetailsResponse message, length delimited. Does not implicitly {@link cockroach.server.serverpb.DatabaseDetailsResponse.verify|verify} messages.
                 * @param {cockroach.server.serverpb.DatabaseDetailsResponse$Properties} message DatabaseDetailsResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                DatabaseDetailsResponse.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a DatabaseDetailsResponse message from the specified reader or buffer.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {cockroach.server.serverpb.DatabaseDetailsResponse} DatabaseDetailsResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                DatabaseDetailsResponse.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.cockroach.server.serverpb.DatabaseDetailsResponse();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (!(message.grants && message.grants.length))
                                message.grants = [];
                            message.grants.push($root.cockroach.server.serverpb.DatabaseDetailsResponse.Grant.decode(reader, reader.uint32()));
                            break;
                        case 2:
                            if (!(message.table_names && message.table_names.length))
                                message.table_names = [];
                            message.table_names.push(reader.string());
                            break;
                        case 3:
                            message.descriptor_id = reader.int64();
                            break;
                        case 4:
                            message.zone_config = $root.cockroach.config.ZoneConfig.decode(reader, reader.uint32());
                            break;
                        case 5:
                            message.zone_config_level = reader.uint32();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a DatabaseDetailsResponse message from the specified reader or buffer, length delimited.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {cockroach.server.serverpb.DatabaseDetailsResponse} DatabaseDetailsResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                DatabaseDetailsResponse.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a DatabaseDetailsResponse message.
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {?string} `null` if valid, otherwise the reason why it is not
                 */
                DatabaseDetailsResponse.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.grants != null && message.hasOwnProperty("grants")) {
                        if (!Array.isArray(message.grants))
                            return "grants: array expected";
                        for (let i = 0; i < message.grants.length; ++i) {
                            let error = $root.cockroach.server.serverpb.DatabaseDetailsResponse.Grant.verify(message.grants[i]);
                            if (error)
                                return "grants." + error;
                        }
                    }
                    if (message.table_names != null && message.hasOwnProperty("table_names")) {
                        if (!Array.isArray(message.table_names))
                            return "table_names: array expected";
                        for (let i = 0; i < message.table_names.length; ++i)
                            if (!$util.isString(message.table_names[i]))
                                return "table_names: string[] expected";
                    }
                    if (message.descriptor_id != null && message.hasOwnProperty("descriptor_id"))
                        if (!$util.isInteger(message.descriptor_id) && !(message.descriptor_id && $util.isInteger(message.descriptor_id.low) && $util.isInteger(message.descriptor_id.high)))
                            return "descriptor_id: integer|Long expected";
                    if (message.zone_config != null && message.hasOwnProperty("zone_config")) {
                        let error = $root.cockroach.config.ZoneConfig.verify(message.zone_config);
                        if (error)
                            return "zone_config." + error;
                    }
                    if (message.zone_config_level != null && message.hasOwnProperty("zone_config_level"))
                        switch (message.zone_config_level) {
                        default:
                            return "zone_config_level: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                            break;
                        }
                    return null;
                };

                /**
                 * Creates a DatabaseDetailsResponse message from a plain object. Also converts values to their respective internal types.
                 * @param {Object.<string,*>} object Plain object
                 * @returns {cockroach.server.serverpb.DatabaseDetailsResponse} DatabaseDetailsResponse
                 */
                DatabaseDetailsResponse.fromObject = function fromObject(object) {
                    if (object instanceof $root.cockroach.server.serverpb.DatabaseDetailsResponse)
                        return object;
                    let message = new $root.cockroach.server.serverpb.DatabaseDetailsResponse();
                    if (object.grants) {
                        if (!Array.isArray(object.grants))
                            throw TypeError(".cockroach.server.serverpb.DatabaseDetailsResponse.grants: array expected");
                        message.grants = [];
                        for (let i = 0; i < object.grants.length; ++i) {
                            if (typeof object.grants[i] !== "object")
                                throw TypeError(".cockroach.server.serverpb.DatabaseDetailsResponse.grants: object expected");
                            message.grants[i] = $root.cockroach.server.serverpb.DatabaseDetailsResponse.Grant.fromObject(object.grants[i]);
                        }
                    }
                    if (object.table_names) {
                        if (!Array.isArray(object.table_names))
                            throw TypeError(".cockroach.server.serverpb.DatabaseDetailsResponse.table_names: array expected");
                        message.table_names = [];
                        for (let i = 0; i < object.table_names.length; ++i)
                            message.table_names[i] = String(object.table_names[i]);
                    }
                    if (object.descriptor_id != null)
                        if ($util.Long)
                            (message.descriptor_id = $util.Long.fromValue(object.descriptor_id)).unsigned = false;
                        else if (typeof object.descriptor_id === "string")
                            message.descriptor_id = parseInt(object.descriptor_id, 10);
                        else if (typeof object.descriptor_id === "number")
                            message.descriptor_id = object.descriptor_id;
                        else if (typeof object.descriptor_id === "object")
                            message.descriptor_id = new $util.LongBits(object.descriptor_id.low >>> 0, object.descriptor_id.high >>> 0).toNumber();
                    if (object.zone_config != null) {
                        if (typeof object.zone_config !== "object")
                            throw TypeError(".cockroach.server.serverpb.DatabaseDetailsResponse.zone_config: object expected");
                        message.zone_config = $root.cockroach.config.ZoneConfig.fromObject(object.zone_config);
                    }
                    switch (object.zone_config_level) {
                    case "UNKNOWN":
                    case 0:
                        message.zone_config_level = 0;
                        break;
                    case "CLUSTER":
                    case 1:
                        message.zone_config_level = 1;
                        break;
                    case "DATABASE":
                    case 2:
                        message.zone_config_level = 2;
                        break;
                    case "TABLE":
                    case 3:
                        message.zone_config_level = 3;
                        break;
                    }
                    return message;
                };

                /**
                 * Creates a DatabaseDetailsResponse message from a plain object. Also converts values to their respective internal types.
                 * This is an alias of {@link cockroach.server.serverpb.DatabaseDetailsResponse.fromObject}.
                 * @function
                 * @param {Object.<string,*>} object Plain object
                 * @returns {cockroach.server.serverpb.DatabaseDetailsResponse} DatabaseDetailsResponse
                 */
                DatabaseDetailsResponse.from = DatabaseDetailsResponse.fromObject;

                /**
                 * Creates a plain object from a DatabaseDetailsResponse message. Also converts values to other types if specified.
                 * @param {cockroach.server.serverpb.DatabaseDetailsResponse} message DatabaseDetailsResponse
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                DatabaseDetailsResponse.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.arrays || options.defaults) {
                        object.grants = [];
                        object.table_names = [];
                    }
                    if (options.defaults) {
                        if ($util.Long) {
                            let long = new $util.Long(0, 0, false);
                            object.descriptor_id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.descriptor_id = options.longs === String ? "0" : 0;
                        object.zone_config = null;
                        object.zone_config_level = options.enums === String ? "UNKNOWN" : 0;
                    }
                    if (message.grants && message.grants.length) {
                        object.grants = [];
                        for (let j = 0; j < message.grants.length; ++j)
                            object.grants[j] = $root.cockroach.server.serverpb.DatabaseDetailsResponse.Grant.toObject(message.grants[j], options);
                    }
                    if (message.table_names && message.table_names.length) {
                        object.table_names = [];
                        for (let j = 0; j < message.table_names.length; ++j)
                            object.table_names[j] = message.table_names[j];
                    }
                    if (message.descriptor_id != null && message.hasOwnProperty("descriptor_id"))
                        if (typeof message.descriptor_id === "number")
                            object.descriptor_id = options.longs === String ? String(message.descriptor_id) : message.descriptor_id;
                        else
                            object.descriptor_id = options.longs === String ? $util.Long.prototype.toString.call(message.descriptor_id) : options.longs === Number ? new $util.LongBits(message.descriptor_id.low >>> 0, message.descriptor_id.high >>> 0).toNumber() : message.descriptor_id;
                    if (message.zone_config != null && message.hasOwnProperty("zone_config"))
                        object.zone_config = $root.cockroach.config.ZoneConfig.toObject(message.zone_config, options);
                    if (message.zone_config_level != null && message.hasOwnProperty("zone_config_level"))
                        object.zone_config_level = options.enums === String ? $root.cockroach.server.serverpb.ZoneConfigurationLevel[message.zone_config_level] : message.zone_config_level;
                    return object;
                };

                /**
                 * Creates a plain object from this DatabaseDetailsResponse message. Also converts values to other types if specified.
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                DatabaseDetailsResponse.prototype.toObject = function toObject(options) {
                    return this.constructor.toObject(this, options);
                };

                /**
                 * Converts this DatabaseDetailsResponse to JSON.
                 * @returns {Object.<string,*>} JSON object
                 */
                DatabaseDetailsResponse.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                DatabaseDetailsResponse.Grant = (function() {

                    /**
                     * Properties of a Grant.
                     * @typedef cockroach.server.serverpb.DatabaseDetailsResponse.Grant$Properties
                     * @type {Object}
                     * @property {string} [user] Grant user.
                     * @property {Array.<string>} [privileges] Grant privileges.
                     */

                    /**
                     * Constructs a new Grant.
                     * @exports cockroach.server.serverpb.DatabaseDetailsResponse.Grant
                     * @constructor
                     * @param {cockroach.server.serverpb.DatabaseDetailsResponse.Grant$Properties=} [properties] Properties to set
                     */
                    function Grant(properties) {
                        this.privileges = [];
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * Grant user.
                     * @type {string}
                     */
                    Grant.prototype.user = "";

                    /**
                     * Grant privileges.
                     * @type {Array.<string>}
                     */
                    Grant.prototype.privileges = $util.emptyArray;

                    /**
                     * Creates a new Grant instance using the specified properties.
                     * @param {cockroach.server.serverpb.DatabaseDetailsResponse.Grant$Properties=} [properties] Properties to set
                     * @returns {cockroach.server.serverpb.DatabaseDetailsResponse.Grant} Grant instance
                     */
                    Grant.create = function create(properties) {
                        return new Grant(properties);
                    };

                    /**
                     * Encodes the specified Grant message. Does not implicitly {@link cockroach.server.serverpb.DatabaseDetailsResponse.Grant.verify|verify} messages.
                     * @param {cockroach.server.serverpb.DatabaseDetailsResponse.Grant$Properties} message Grant message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Grant.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.user != null && message.hasOwnProperty("user"))
                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.user);
                        if (message.privileges != null && message.privileges.length)
                            for (let i = 0; i < message.privileges.length; ++i)
                                writer.uint32(/* id 2, wireType 2 =*/18).string(message.privileges[i]);
                        return writer;
                    };

                    /**
                     * Encodes the specified Grant message, length delimited. Does not implicitly {@link cockroach.server.serverpb.DatabaseDetailsResponse.Grant.verify|verify} messages.
                     * @param {cockroach.server.serverpb.DatabaseDetailsResponse.Grant$Properties} message Grant message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Grant.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a Grant message from the specified reader or buffer.
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {cockroach.server.serverpb.DatabaseDetailsResponse.Grant} Grant
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Grant.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.cockroach.server.serverpb.DatabaseDetailsResponse.Grant();
                        while (reader.pos < end) {
                            let tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.user = reader.string();
                                break;
                            case 2:
                                if (!(message.privileges && message.privileges.length))
                                    message.privileges = [];
                                message.privileges.push(reader.string());
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a Grant message from the specified reader or buffer, length delimited.
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {cockroach.server.serverpb.DatabaseDetailsResponse.Grant} Grant
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Grant.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a Grant message.
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {?string} `null` if valid, otherwise the reason why it is not
                     */
                    Grant.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.user != null && message.hasOwnProperty("user"))
                            if (!$util.isString(message.user))
                                return "user: string expected";
                        if (message.privileges != null && message.hasOwnProperty("privileges")) {
                            if (!Array.isArray(message.privileges))
                                return "privileges: array expected";
                            for (let i = 0; i < message.privileges.length; ++i)
                                if (!$util.isString(message.privileges[i]))
                                    return "privileges: string[] expected";
                        }
                        return null;
                    };

                    /**
                     * Creates a Grant message from a plain object. Also converts values to their respective internal types.
                     * @param {Object.<string,*>} object Plain object
                     * @returns {cockroach.server.serverpb.DatabaseDetailsResponse.Grant} Grant
                     */
                    Grant.fromObject = function fromObject(object) {
                        if (object instanceof $root.cockroach.server.serverpb.DatabaseDetailsResponse.Grant)
                            return object;
                        let message = new $root.cockroach.server.serverpb.DatabaseDetailsResponse.Grant();
                        if (object.user != null)
                            message.user = String(object.user);
                        if (object.privileges) {
                            if (!Array.isArray(object.privileges))
                                throw TypeError(".cockroach.server.serverpb.DatabaseDetailsResponse.Grant.privileges: array expected");
                            message.privileges = [];
                            for (let i = 0; i < object.privileges.length; ++i)
                                message.privileges[i] = String(object.privileges[i]);
                        }
                        return message;
                    };

                    /**
                     * Creates a Grant message from a plain object. Also converts values to their respective internal types.
                     * This is an alias of {@link cockroach.server.serverpb.DatabaseDetailsResponse.Grant.fromObject}.
                     * @function
                     * @param {Object.<string,*>} object Plain object
                     * @returns {cockroach.server.serverpb.DatabaseDetailsResponse.Grant} Grant
                     */
                    Grant.from = Grant.fromObject;

                    /**
                     * Creates a plain object from a Grant message. Also converts values to other types if specified.
                     * @param {cockroach.server.serverpb.DatabaseDetailsResponse.Grant} message Grant
                     * @param {$protobuf.ConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Grant.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.arrays || options.defaults)
                            object.privileges = [];
                        if (options.defaults)
                            object.user = "";
                        if (message.user != null && message.hasOwnProperty("user"))
                            object.user = message.user;
                        if (message.privileges && message.privileges.length) {
                            object.privileges = [];
                            for (let j = 0; j < message.privileges.length; ++j)
                                object.privileges[j] = message.privileges[j];
                        }
                        return object;
                    };

                    /**
                     * Creates a plain object from this Grant message. Also converts values to other types if specified.
                     * @param {$protobuf.ConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Grant.prototype.toObject = function toObject(options) {
                        return this.constructor.toObject(this, options);
                    };

                    /**
                     * Converts this Grant to JSON.
                     * @returns {Object.<string,*>} JSON object
                     */
                    Grant.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return Grant;
                })();

                return DatabaseDetailsResponse;
            })();

            serverpb.TableDetailsRequest = (function() {

                /**
                 * Properties of a TableDetailsRequest.
                 * @typedef cockroach.server.serverpb.TableDetailsRequest$Properties
                 * @type {Object}
                 * @property {string} [database] TableDetailsRequest database.
                 * @property {string} [table] TableDetailsRequest table.
                 */

                /**
                 * Constructs a new TableDetailsRequest.
                 * @exports cockroach.server.serverpb.TableDetailsRequest
                 * @constructor
                 * @param {cockroach.server.serverpb.TableDetailsRequest$Properties=} [properties] Properties to set
                 */
                function TableDetailsRequest(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * TableDetailsRequest database.
                 * @type {string}
                 */
                TableDetailsRequest.prototype.database = "";

                /**
                 * TableDetailsRequest table.
                 * @type {string}
                 */
                TableDetailsRequest.prototype.table = "";

                /**
                 * Creates a new TableDetailsRequest instance using the specified properties.
                 * @param {cockroach.server.serverpb.TableDetailsRequest$Properties=} [properties] Properties to set
                 * @returns {cockroach.server.serverpb.TableDetailsRequest} TableDetailsRequest instance
                 */
                TableDetailsRequest.create = function create(properties) {
                    return new TableDetailsRequest(properties);
                };

                /**
                 * Encodes the specified TableDetailsRequest message. Does not implicitly {@link cockroach.server.serverpb.TableDetailsRequest.verify|verify} messages.
                 * @param {cockroach.server.serverpb.TableDetailsRequest$Properties} message TableDetailsRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                TableDetailsRequest.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.database != null && message.hasOwnProperty("database"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.database);
                    if (message.table != null && message.hasOwnProperty("table"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.table);
                    return writer;
                };

                /**
                 * Encodes the specified TableDetailsRequest message, length delimited. Does not implicitly {@link cockroach.server.serverpb.TableDetailsRequest.verify|verify} messages.
                 * @param {cockroach.server.serverpb.TableDetailsRequest$Properties} message TableDetailsRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                TableDetailsRequest.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a TableDetailsRequest message from the specified reader or buffer.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {cockroach.server.serverpb.TableDetailsRequest} TableDetailsRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                TableDetailsRequest.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.cockroach.server.serverpb.TableDetailsRequest();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.database = reader.string();
                            break;
                        case 2:
                            message.table = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a TableDetailsRequest message from the specified reader or buffer, length delimited.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {cockroach.server.serverpb.TableDetailsRequest} TableDetailsRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                TableDetailsRequest.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a TableDetailsRequest message.
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {?string} `null` if valid, otherwise the reason why it is not
                 */
                TableDetailsRequest.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.database != null && message.hasOwnProperty("database"))
                        if (!$util.isString(message.database))
                            return "database: string expected";
                    if (message.table != null && message.hasOwnProperty("table"))
                        if (!$util.isString(message.table))
                            return "table: string expected";
                    return null;
                };

                /**
                 * Creates a TableDetailsRequest message from a plain object. Also converts values to their respective internal types.
                 * @param {Object.<string,*>} object Plain object
                 * @returns {cockroach.server.serverpb.TableDetailsRequest} TableDetailsRequest
                 */
                TableDetailsRequest.fromObject = function fromObject(object) {
                    if (object instanceof $root.cockroach.server.serverpb.TableDetailsRequest)
                        return object;
                    let message = new $root.cockroach.server.serverpb.TableDetailsRequest();
                    if (object.database != null)
                        message.database = String(object.database);
                    if (object.table != null)
                        message.table = String(object.table);
                    return message;
                };

                /**
                 * Creates a TableDetailsRequest message from a plain object. Also converts values to their respective internal types.
                 * This is an alias of {@link cockroach.server.serverpb.TableDetailsRequest.fromObject}.
                 * @function
                 * @param {Object.<string,*>} object Plain object
                 * @returns {cockroach.server.serverpb.TableDetailsRequest} TableDetailsRequest
                 */
                TableDetailsRequest.from = TableDetailsRequest.fromObject;

                /**
                 * Creates a plain object from a TableDetailsRequest message. Also converts values to other types if specified.
                 * @param {cockroach.server.serverpb.TableDetailsRequest} message TableDetailsRequest
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                TableDetailsRequest.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.database = "";
                        object.table = "";
                    }
                    if (message.database != null && message.hasOwnProperty("database"))
                        object.database = message.database;
                    if (message.table != null && message.hasOwnProperty("table"))
                        object.table = message.table;
                    return object;
                };

                /**
                 * Creates a plain object from this TableDetailsRequest message. Also converts values to other types if specified.
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                TableDetailsRequest.prototype.toObject = function toObject(options) {
                    return this.constructor.toObject(this, options);
                };

                /**
                 * Converts this TableDetailsRequest to JSON.
                 * @returns {Object.<string,*>} JSON object
                 */
                TableDetailsRequest.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return TableDetailsRequest;
            })();

            serverpb.TableDetailsResponse = (function() {

                /**
                 * Properties of a TableDetailsResponse.
                 * @typedef cockroach.server.serverpb.TableDetailsResponse$Properties
                 * @type {Object}
                 * @property {Array.<cockroach.server.serverpb.TableDetailsResponse.Grant$Properties>} [grants] TableDetailsResponse grants.
                 * @property {Array.<cockroach.server.serverpb.TableDetailsResponse.Column$Properties>} [columns] TableDetailsResponse columns.
                 * @property {Array.<cockroach.server.serverpb.TableDetailsResponse.Index$Properties>} [indexes] TableDetailsResponse indexes.
                 * @property {Long} [range_count] TableDetailsResponse range_count.
                 * @property {string} [create_table_statement] TableDetailsResponse create_table_statement.
                 * @property {cockroach.config.ZoneConfig$Properties} [zone_config] TableDetailsResponse zone_config.
                 * @property {cockroach.server.serverpb.ZoneConfigurationLevel} [zone_config_level] TableDetailsResponse zone_config_level.
                 * @property {Long} [descriptor_id] TableDetailsResponse descriptor_id.
                 */

                /**
                 * Constructs a new TableDetailsResponse.
                 * @exports cockroach.server.serverpb.TableDetailsResponse
                 * @constructor
                 * @param {cockroach.server.serverpb.TableDetailsResponse$Properties=} [properties] Properties to set
                 */
                function TableDetailsResponse(properties) {
                    this.grants = [];
                    this.columns = [];
                    this.indexes = [];
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * TableDetailsResponse grants.
                 * @type {Array.<cockroach.server.serverpb.TableDetailsResponse.Grant$Properties>}
                 */
                TableDetailsResponse.prototype.grants = $util.emptyArray;

                /**
                 * TableDetailsResponse columns.
                 * @type {Array.<cockroach.server.serverpb.TableDetailsResponse.Column$Properties>}
                 */
                TableDetailsResponse.prototype.columns = $util.emptyArray;

                /**
                 * TableDetailsResponse indexes.
                 * @type {Array.<cockroach.server.serverpb.TableDetailsResponse.Index$Properties>}
                 */
                TableDetailsResponse.prototype.indexes = $util.emptyArray;

                /**
                 * TableDetailsResponse range_count.
                 * @type {Long}
                 */
                TableDetailsResponse.prototype.range_count = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

                /**
                 * TableDetailsResponse create_table_statement.
                 * @type {string}
                 */
                TableDetailsResponse.prototype.create_table_statement = "";

                /**
                 * TableDetailsResponse zone_config.
                 * @type {(cockroach.config.ZoneConfig$Properties|null)}
                 */
                TableDetailsResponse.prototype.zone_config = null;

                /**
                 * TableDetailsResponse zone_config_level.
                 * @type {cockroach.server.serverpb.ZoneConfigurationLevel}
                 */
                TableDetailsResponse.prototype.zone_config_level = 0;

                /**
                 * TableDetailsResponse descriptor_id.
                 * @type {Long}
                 */
                TableDetailsResponse.prototype.descriptor_id = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

                /**
                 * Creates a new TableDetailsResponse instance using the specified properties.
                 * @param {cockroach.server.serverpb.TableDetailsResponse$Properties=} [properties] Properties to set
                 * @returns {cockroach.server.serverpb.TableDetailsResponse} TableDetailsResponse instance
                 */
                TableDetailsResponse.create = function create(properties) {
                    return new TableDetailsResponse(properties);
                };

                /**
                 * Encodes the specified TableDetailsResponse message. Does not implicitly {@link cockroach.server.serverpb.TableDetailsResponse.verify|verify} messages.
                 * @param {cockroach.server.serverpb.TableDetailsResponse$Properties} message TableDetailsResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                TableDetailsResponse.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.grants != null && message.grants.length)
                        for (let i = 0; i < message.grants.length; ++i)
                            $root.cockroach.server.serverpb.TableDetailsResponse.Grant.encode(message.grants[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.columns != null && message.columns.length)
                        for (let i = 0; i < message.columns.length; ++i)
                            $root.cockroach.server.serverpb.TableDetailsResponse.Column.encode(message.columns[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.indexes != null && message.indexes.length)
                        for (let i = 0; i < message.indexes.length; ++i)
                            $root.cockroach.server.serverpb.TableDetailsResponse.Index.encode(message.indexes[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    if (message.range_count != null && message.hasOwnProperty("range_count"))
                        writer.uint32(/* id 4, wireType 0 =*/32).int64(message.range_count);
                    if (message.create_table_statement != null && message.hasOwnProperty("create_table_statement"))
                        writer.uint32(/* id 5, wireType 2 =*/42).string(message.create_table_statement);
                    if (message.zone_config != null && message.hasOwnProperty("zone_config"))
                        $root.cockroach.config.ZoneConfig.encode(message.zone_config, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                    if (message.zone_config_level != null && message.hasOwnProperty("zone_config_level"))
                        writer.uint32(/* id 7, wireType 0 =*/56).uint32(message.zone_config_level);
                    if (message.descriptor_id != null && message.hasOwnProperty("descriptor_id"))
                        writer.uint32(/* id 8, wireType 0 =*/64).int64(message.descriptor_id);
                    return writer;
                };

                /**
                 * Encodes the specified TableDetailsResponse message, length delimited. Does not implicitly {@link cockroach.server.serverpb.TableDetailsResponse.verify|verify} messages.
                 * @param {cockroach.server.serverpb.TableDetailsResponse$Properties} message TableDetailsResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                TableDetailsResponse.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a TableDetailsResponse message from the specified reader or buffer.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {cockroach.server.serverpb.TableDetailsResponse} TableDetailsResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                TableDetailsResponse.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.cockroach.server.serverpb.TableDetailsResponse();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (!(message.grants && message.grants.length))
                                message.grants = [];
                            message.grants.push($root.cockroach.server.serverpb.TableDetailsResponse.Grant.decode(reader, reader.uint32()));
                            break;
                        case 2:
                            if (!(message.columns && message.columns.length))
                                message.columns = [];
                            message.columns.push($root.cockroach.server.serverpb.TableDetailsResponse.Column.decode(reader, reader.uint32()));
                            break;
                        case 3:
                            if (!(message.indexes && message.indexes.length))
                                message.indexes = [];
                            message.indexes.push($root.cockroach.server.serverpb.TableDetailsResponse.Index.decode(reader, reader.uint32()));
                            break;
                        case 4:
                            message.range_count = reader.int64();
                            break;
                        case 5:
                            message.create_table_statement = reader.string();
                            break;
                        case 6:
                            message.zone_config = $root.cockroach.config.ZoneConfig.decode(reader, reader.uint32());
                            break;
                        case 7:
                            message.zone_config_level = reader.uint32();
                            break;
                        case 8:
                            message.descriptor_id = reader.int64();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a TableDetailsResponse message from the specified reader or buffer, length delimited.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {cockroach.server.serverpb.TableDetailsResponse} TableDetailsResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                TableDetailsResponse.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a TableDetailsResponse message.
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {?string} `null` if valid, otherwise the reason why it is not
                 */
                TableDetailsResponse.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.grants != null && message.hasOwnProperty("grants")) {
                        if (!Array.isArray(message.grants))
                            return "grants: array expected";
                        for (let i = 0; i < message.grants.length; ++i) {
                            let error = $root.cockroach.server.serverpb.TableDetailsResponse.Grant.verify(message.grants[i]);
                            if (error)
                                return "grants." + error;
                        }
                    }
                    if (message.columns != null && message.hasOwnProperty("columns")) {
                        if (!Array.isArray(message.columns))
                            return "columns: array expected";
                        for (let i = 0; i < message.columns.length; ++i) {
                            let error = $root.cockroach.server.serverpb.TableDetailsResponse.Column.verify(message.columns[i]);
                            if (error)
                                return "columns." + error;
                        }
                    }
                    if (message.indexes != null && message.hasOwnProperty("indexes")) {
                        if (!Array.isArray(message.indexes))
                            return "indexes: array expected";
                        for (let i = 0; i < message.indexes.length; ++i) {
                            let error = $root.cockroach.server.serverpb.TableDetailsResponse.Index.verify(message.indexes[i]);
                            if (error)
                                return "indexes." + error;
                        }
                    }
                    if (message.range_count != null && message.hasOwnProperty("range_count"))
                        if (!$util.isInteger(message.range_count) && !(message.range_count && $util.isInteger(message.range_count.low) && $util.isInteger(message.range_count.high)))
                            return "range_count: integer|Long expected";
                    if (message.create_table_statement != null && message.hasOwnProperty("create_table_statement"))
                        if (!$util.isString(message.create_table_statement))
                            return "create_table_statement: string expected";
                    if (message.zone_config != null && message.hasOwnProperty("zone_config")) {
                        let error = $root.cockroach.config.ZoneConfig.verify(message.zone_config);
                        if (error)
                            return "zone_config." + error;
                    }
                    if (message.zone_config_level != null && message.hasOwnProperty("zone_config_level"))
                        switch (message.zone_config_level) {
                        default:
                            return "zone_config_level: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                            break;
                        }
                    if (message.descriptor_id != null && message.hasOwnProperty("descriptor_id"))
                        if (!$util.isInteger(message.descriptor_id) && !(message.descriptor_id && $util.isInteger(message.descriptor_id.low) && $util.isInteger(message.descriptor_id.high)))
                            return "descriptor_id: integer|Long expected";
                    return null;
                };

                /**
                 * Creates a TableDetailsResponse message from a plain object. Also converts values to their respective internal types.
                 * @param {Object.<string,*>} object Plain object
                 * @returns {cockroach.server.serverpb.TableDetailsResponse} TableDetailsResponse
                 */
                TableDetailsResponse.fromObject = function fromObject(object) {
                    if (object instanceof $root.cockroach.server.serverpb.TableDetailsResponse)
                        return object;
                    let message = new $root.cockroach.server.serverpb.TableDetailsResponse();
                    if (object.grants) {
                        if (!Array.isArray(object.grants))
                            throw TypeError(".cockroach.server.serverpb.TableDetailsResponse.grants: array expected");
                        message.grants = [];
                        for (let i = 0; i < object.grants.length; ++i) {
                            if (typeof object.grants[i] !== "object")
                                throw TypeError(".cockroach.server.serverpb.TableDetailsResponse.grants: object expected");
                            message.grants[i] = $root.cockroach.server.serverpb.TableDetailsResponse.Grant.fromObject(object.grants[i]);
                        }
                    }
                    if (object.columns) {
                        if (!Array.isArray(object.columns))
                            throw TypeError(".cockroach.server.serverpb.TableDetailsResponse.columns: array expected");
                        message.columns = [];
                        for (let i = 0; i < object.columns.length; ++i) {
                            if (typeof object.columns[i] !== "object")
                                throw TypeError(".cockroach.server.serverpb.TableDetailsResponse.columns: object expected");
                            message.columns[i] = $root.cockroach.server.serverpb.TableDetailsResponse.Column.fromObject(object.columns[i]);
                        }
                    }
                    if (object.indexes) {
                        if (!Array.isArray(object.indexes))
                            throw TypeError(".cockroach.server.serverpb.TableDetailsResponse.indexes: array expected");
                        message.indexes = [];
                        for (let i = 0; i < object.indexes.length; ++i) {
                            if (typeof object.indexes[i] !== "object")
                                throw TypeError(".cockroach.server.serverpb.TableDetailsResponse.indexes: object expected");
                            message.indexes[i] = $root.cockroach.server.serverpb.TableDetailsResponse.Index.fromObject(object.indexes[i]);
                        }
                    }
                    if (object.range_count != null)
                        if ($util.Long)
                            (message.range_count = $util.Long.fromValue(object.range_count)).unsigned = false;
                        else if (typeof object.range_count === "string")
                            message.range_count = parseInt(object.range_count, 10);
                        else if (typeof object.range_count === "number")
                            message.range_count = object.range_count;
                        else if (typeof object.range_count === "object")
                            message.range_count = new $util.LongBits(object.range_count.low >>> 0, object.range_count.high >>> 0).toNumber();
                    if (object.create_table_statement != null)
                        message.create_table_statement = String(object.create_table_statement);
                    if (object.zone_config != null) {
                        if (typeof object.zone_config !== "object")
                            throw TypeError(".cockroach.server.serverpb.TableDetailsResponse.zone_config: object expected");
                        message.zone_config = $root.cockroach.config.ZoneConfig.fromObject(object.zone_config);
                    }
                    switch (object.zone_config_level) {
                    case "UNKNOWN":
                    case 0:
                        message.zone_config_level = 0;
                        break;
                    case "CLUSTER":
                    case 1:
                        message.zone_config_level = 1;
                        break;
                    case "DATABASE":
                    case 2:
                        message.zone_config_level = 2;
                        break;
                    case "TABLE":
                    case 3:
                        message.zone_config_level = 3;
                        break;
                    }
                    if (object.descriptor_id != null)
                        if ($util.Long)
                            (message.descriptor_id = $util.Long.fromValue(object.descriptor_id)).unsigned = false;
                        else if (typeof object.descriptor_id === "string")
                            message.descriptor_id = parseInt(object.descriptor_id, 10);
                        else if (typeof object.descriptor_id === "number")
                            message.descriptor_id = object.descriptor_id;
                        else if (typeof object.descriptor_id === "object")
                            message.descriptor_id = new $util.LongBits(object.descriptor_id.low >>> 0, object.descriptor_id.high >>> 0).toNumber();
                    return message;
                };

                /**
                 * Creates a TableDetailsResponse message from a plain object. Also converts values to their respective internal types.
                 * This is an alias of {@link cockroach.server.serverpb.TableDetailsResponse.fromObject}.
                 * @function
                 * @param {Object.<string,*>} object Plain object
                 * @returns {cockroach.server.serverpb.TableDetailsResponse} TableDetailsResponse
                 */
                TableDetailsResponse.from = TableDetailsResponse.fromObject;

                /**
                 * Creates a plain object from a TableDetailsResponse message. Also converts values to other types if specified.
                 * @param {cockroach.server.serverpb.TableDetailsResponse} message TableDetailsResponse
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                TableDetailsResponse.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.arrays || options.defaults) {
                        object.grants = [];
                        object.columns = [];
                        object.indexes = [];
                    }
                    if (options.defaults) {
                        if ($util.Long) {
                            let long = new $util.Long(0, 0, false);
                            object.range_count = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.range_count = options.longs === String ? "0" : 0;
                        object.create_table_statement = "";
                        object.zone_config = null;
                        object.zone_config_level = options.enums === String ? "UNKNOWN" : 0;
                        if ($util.Long) {
                            let long = new $util.Long(0, 0, false);
                            object.descriptor_id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.descriptor_id = options.longs === String ? "0" : 0;
                    }
                    if (message.grants && message.grants.length) {
                        object.grants = [];
                        for (let j = 0; j < message.grants.length; ++j)
                            object.grants[j] = $root.cockroach.server.serverpb.TableDetailsResponse.Grant.toObject(message.grants[j], options);
                    }
                    if (message.columns && message.columns.length) {
                        object.columns = [];
                        for (let j = 0; j < message.columns.length; ++j)
                            object.columns[j] = $root.cockroach.server.serverpb.TableDetailsResponse.Column.toObject(message.columns[j], options);
                    }
                    if (message.indexes && message.indexes.length) {
                        object.indexes = [];
                        for (let j = 0; j < message.indexes.length; ++j)
                            object.indexes[j] = $root.cockroach.server.serverpb.TableDetailsResponse.Index.toObject(message.indexes[j], options);
                    }
                    if (message.range_count != null && message.hasOwnProperty("range_count"))
                        if (typeof message.range_count === "number")
                            object.range_count = options.longs === String ? String(message.range_count) : message.range_count;
                        else
                            object.range_count = options.longs === String ? $util.Long.prototype.toString.call(message.range_count) : options.longs === Number ? new $util.LongBits(message.range_count.low >>> 0, message.range_count.high >>> 0).toNumber() : message.range_count;
                    if (message.create_table_statement != null && message.hasOwnProperty("create_table_statement"))
                        object.create_table_statement = message.create_table_statement;
                    if (message.zone_config != null && message.hasOwnProperty("zone_config"))
                        object.zone_config = $root.cockroach.config.ZoneConfig.toObject(message.zone_config, options);
                    if (message.zone_config_level != null && message.hasOwnProperty("zone_config_level"))
                        object.zone_config_level = options.enums === String ? $root.cockroach.server.serverpb.ZoneConfigurationLevel[message.zone_config_level] : message.zone_config_level;
                    if (message.descriptor_id != null && message.hasOwnProperty("descriptor_id"))
                        if (typeof message.descriptor_id === "number")
                            object.descriptor_id = options.longs === String ? String(message.descriptor_id) : message.descriptor_id;
                        else
                            object.descriptor_id = options.longs === String ? $util.Long.prototype.toString.call(message.descriptor_id) : options.longs === Number ? new $util.LongBits(message.descriptor_id.low >>> 0, message.descriptor_id.high >>> 0).toNumber() : message.descriptor_id;
                    return object;
                };

                /**
                 * Creates a plain object from this TableDetailsResponse message. Also converts values to other types if specified.
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                TableDetailsResponse.prototype.toObject = function toObject(options) {
                    return this.constructor.toObject(this, options);
                };

                /**
                 * Converts this TableDetailsResponse to JSON.
                 * @returns {Object.<string,*>} JSON object
                 */
                TableDetailsResponse.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                TableDetailsResponse.Grant = (function() {

                    /**
                     * Properties of a Grant.
                     * @typedef cockroach.server.serverpb.TableDetailsResponse.Grant$Properties
                     * @type {Object}
                     * @property {string} [user] Grant user.
                     * @property {Array.<string>} [privileges] Grant privileges.
                     */

                    /**
                     * Constructs a new Grant.
                     * @exports cockroach.server.serverpb.TableDetailsResponse.Grant
                     * @constructor
                     * @param {cockroach.server.serverpb.TableDetailsResponse.Grant$Properties=} [properties] Properties to set
                     */
                    function Grant(properties) {
                        this.privileges = [];
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * Grant user.
                     * @type {string}
                     */
                    Grant.prototype.user = "";

                    /**
                     * Grant privileges.
                     * @type {Array.<string>}
                     */
                    Grant.prototype.privileges = $util.emptyArray;

                    /**
                     * Creates a new Grant instance using the specified properties.
                     * @param {cockroach.server.serverpb.TableDetailsResponse.Grant$Properties=} [properties] Properties to set
                     * @returns {cockroach.server.serverpb.TableDetailsResponse.Grant} Grant instance
                     */
                    Grant.create = function create(properties) {
                        return new Grant(properties);
                    };

                    /**
                     * Encodes the specified Grant message. Does not implicitly {@link cockroach.server.serverpb.TableDetailsResponse.Grant.verify|verify} messages.
                     * @param {cockroach.server.serverpb.TableDetailsResponse.Grant$Properties} message Grant message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Grant.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.user != null && message.hasOwnProperty("user"))
                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.user);
                        if (message.privileges != null && message.privileges.length)
                            for (let i = 0; i < message.privileges.length; ++i)
                                writer.uint32(/* id 2, wireType 2 =*/18).string(message.privileges[i]);
                        return writer;
                    };

                    /**
                     * Encodes the specified Grant message, length delimited. Does not implicitly {@link cockroach.server.serverpb.TableDetailsResponse.Grant.verify|verify} messages.
                     * @param {cockroach.server.serverpb.TableDetailsResponse.Grant$Properties} message Grant message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Grant.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a Grant message from the specified reader or buffer.
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {cockroach.server.serverpb.TableDetailsResponse.Grant} Grant
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Grant.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.cockroach.server.serverpb.TableDetailsResponse.Grant();
                        while (reader.pos < end) {
                            let tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.user = reader.string();
                                break;
                            case 2:
                                if (!(message.privileges && message.privileges.length))
                                    message.privileges = [];
                                message.privileges.push(reader.string());
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a Grant message from the specified reader or buffer, length delimited.
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {cockroach.server.serverpb.TableDetailsResponse.Grant} Grant
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Grant.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a Grant message.
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {?string} `null` if valid, otherwise the reason why it is not
                     */
                    Grant.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.user != null && message.hasOwnProperty("user"))
                            if (!$util.isString(message.user))
                                return "user: string expected";
                        if (message.privileges != null && message.hasOwnProperty("privileges")) {
                            if (!Array.isArray(message.privileges))
                                return "privileges: array expected";
                            for (let i = 0; i < message.privileges.length; ++i)
                                if (!$util.isString(message.privileges[i]))
                                    return "privileges: string[] expected";
                        }
                        return null;
                    };

                    /**
                     * Creates a Grant message from a plain object. Also converts values to their respective internal types.
                     * @param {Object.<string,*>} object Plain object
                     * @returns {cockroach.server.serverpb.TableDetailsResponse.Grant} Grant
                     */
                    Grant.fromObject = function fromObject(object) {
                        if (object instanceof $root.cockroach.server.serverpb.TableDetailsResponse.Grant)
                            return object;
                        let message = new $root.cockroach.server.serverpb.TableDetailsResponse.Grant();
                        if (object.user != null)
                            message.user = String(object.user);
                        if (object.privileges) {
                            if (!Array.isArray(object.privileges))
                                throw TypeError(".cockroach.server.serverpb.TableDetailsResponse.Grant.privileges: array expected");
                            message.privileges = [];
                            for (let i = 0; i < object.privileges.length; ++i)
                                message.privileges[i] = String(object.privileges[i]);
                        }
                        return message;
                    };

                    /**
                     * Creates a Grant message from a plain object. Also converts values to their respective internal types.
                     * This is an alias of {@link cockroach.server.serverpb.TableDetailsResponse.Grant.fromObject}.
                     * @function
                     * @param {Object.<string,*>} object Plain object
                     * @returns {cockroach.server.serverpb.TableDetailsResponse.Grant} Grant
                     */
                    Grant.from = Grant.fromObject;

                    /**
                     * Creates a plain object from a Grant message. Also converts values to other types if specified.
                     * @param {cockroach.server.serverpb.TableDetailsResponse.Grant} message Grant
                     * @param {$protobuf.ConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Grant.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.arrays || options.defaults)
                            object.privileges = [];
                        if (options.defaults)
                            object.user = "";
                        if (message.user != null && message.hasOwnProperty("user"))
                            object.user = message.user;
                        if (message.privileges && message.privileges.length) {
                            object.privileges = [];
                            for (let j = 0; j < message.privileges.length; ++j)
                                object.privileges[j] = message.privileges[j];
                        }
                        return object;
                    };

                    /**
                     * Creates a plain object from this Grant message. Also converts values to other types if specified.
                     * @param {$protobuf.ConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Grant.prototype.toObject = function toObject(options) {
                        return this.constructor.toObject(this, options);
                    };

                    /**
                     * Converts this Grant to JSON.
                     * @returns {Object.<string,*>} JSON object
                     */
                    Grant.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return Grant;
                })();

                TableDetailsResponse.Column = (function() {

                    /**
                     * Properties of a Column.
                     * @typedef cockroach.server.serverpb.TableDetailsResponse.Column$Properties
                     * @type {Object}
                     * @property {string} [name] Column name.
                     * @property {string} [type] Column type.
                     * @property {boolean} [nullable] Column nullable.
                     * @property {string} [default_value] Column default_value.
                     */

                    /**
                     * Constructs a new Column.
                     * @exports cockroach.server.serverpb.TableDetailsResponse.Column
                     * @constructor
                     * @param {cockroach.server.serverpb.TableDetailsResponse.Column$Properties=} [properties] Properties to set
                     */
                    function Column(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * Column name.
                     * @type {string}
                     */
                    Column.prototype.name = "";

                    /**
                     * Column type.
                     * @type {string}
                     */
                    Column.prototype.type = "";

                    /**
                     * Column nullable.
                     * @type {boolean}
                     */
                    Column.prototype.nullable = false;

                    /**
                     * Column default_value.
                     * @type {string}
                     */
                    Column.prototype.default_value = "";

                    /**
                     * Creates a new Column instance using the specified properties.
                     * @param {cockroach.server.serverpb.TableDetailsResponse.Column$Properties=} [properties] Properties to set
                     * @returns {cockroach.server.serverpb.TableDetailsResponse.Column} Column instance
                     */
                    Column.create = function create(properties) {
                        return new Column(properties);
                    };

                    /**
                     * Encodes the specified Column message. Does not implicitly {@link cockroach.server.serverpb.TableDetailsResponse.Column.verify|verify} messages.
                     * @param {cockroach.server.serverpb.TableDetailsResponse.Column$Properties} message Column message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Column.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.name != null && message.hasOwnProperty("name"))
                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                        if (message.type != null && message.hasOwnProperty("type"))
                            writer.uint32(/* id 2, wireType 2 =*/18).string(message.type);
                        if (message.nullable != null && message.hasOwnProperty("nullable"))
                            writer.uint32(/* id 3, wireType 0 =*/24).bool(message.nullable);
                        if (message.default_value != null && message.hasOwnProperty("default_value"))
                            writer.uint32(/* id 4, wireType 2 =*/34).string(message.default_value);
                        return writer;
                    };

                    /**
                     * Encodes the specified Column message, length delimited. Does not implicitly {@link cockroach.server.serverpb.TableDetailsResponse.Column.verify|verify} messages.
                     * @param {cockroach.server.serverpb.TableDetailsResponse.Column$Properties} message Column message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Column.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a Column message from the specified reader or buffer.
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {cockroach.server.serverpb.TableDetailsResponse.Column} Column
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Column.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.cockroach.server.serverpb.TableDetailsResponse.Column();
                        while (reader.pos < end) {
                            let tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.name = reader.string();
                                break;
                            case 2:
                                message.type = reader.string();
                                break;
                            case 3:
                                message.nullable = reader.bool();
                                break;
                            case 4:
                                message.default_value = reader.string();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a Column message from the specified reader or buffer, length delimited.
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {cockroach.server.serverpb.TableDetailsResponse.Column} Column
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Column.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a Column message.
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {?string} `null` if valid, otherwise the reason why it is not
                     */
                    Column.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.name != null && message.hasOwnProperty("name"))
                            if (!$util.isString(message.name))
                                return "name: string expected";
                        if (message.type != null && message.hasOwnProperty("type"))
                            if (!$util.isString(message.type))
                                return "type: string expected";
                        if (message.nullable != null && message.hasOwnProperty("nullable"))
                            if (typeof message.nullable !== "boolean")
                                return "nullable: boolean expected";
                        if (message.default_value != null && message.hasOwnProperty("default_value"))
                            if (!$util.isString(message.default_value))
                                return "default_value: string expected";
                        return null;
                    };

                    /**
                     * Creates a Column message from a plain object. Also converts values to their respective internal types.
                     * @param {Object.<string,*>} object Plain object
                     * @returns {cockroach.server.serverpb.TableDetailsResponse.Column} Column
                     */
                    Column.fromObject = function fromObject(object) {
                        if (object instanceof $root.cockroach.server.serverpb.TableDetailsResponse.Column)
                            return object;
                        let message = new $root.cockroach.server.serverpb.TableDetailsResponse.Column();
                        if (object.name != null)
                            message.name = String(object.name);
                        if (object.type != null)
                            message.type = String(object.type);
                        if (object.nullable != null)
                            message.nullable = Boolean(object.nullable);
                        if (object.default_value != null)
                            message.default_value = String(object.default_value);
                        return message;
                    };

                    /**
                     * Creates a Column message from a plain object. Also converts values to their respective internal types.
                     * This is an alias of {@link cockroach.server.serverpb.TableDetailsResponse.Column.fromObject}.
                     * @function
                     * @param {Object.<string,*>} object Plain object
                     * @returns {cockroach.server.serverpb.TableDetailsResponse.Column} Column
                     */
                    Column.from = Column.fromObject;

                    /**
                     * Creates a plain object from a Column message. Also converts values to other types if specified.
                     * @param {cockroach.server.serverpb.TableDetailsResponse.Column} message Column
                     * @param {$protobuf.ConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Column.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.defaults) {
                            object.name = "";
                            object.type = "";
                            object.nullable = false;
                            object.default_value = "";
                        }
                        if (message.name != null && message.hasOwnProperty("name"))
                            object.name = message.name;
                        if (message.type != null && message.hasOwnProperty("type"))
                            object.type = message.type;
                        if (message.nullable != null && message.hasOwnProperty("nullable"))
                            object.nullable = message.nullable;
                        if (message.default_value != null && message.hasOwnProperty("default_value"))
                            object.default_value = message.default_value;
                        return object;
                    };

                    /**
                     * Creates a plain object from this Column message. Also converts values to other types if specified.
                     * @param {$protobuf.ConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Column.prototype.toObject = function toObject(options) {
                        return this.constructor.toObject(this, options);
                    };

                    /**
                     * Converts this Column to JSON.
                     * @returns {Object.<string,*>} JSON object
                     */
                    Column.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return Column;
                })();

                TableDetailsResponse.Index = (function() {

                    /**
                     * Properties of an Index.
                     * @typedef cockroach.server.serverpb.TableDetailsResponse.Index$Properties
                     * @type {Object}
                     * @property {string} [name] Index name.
                     * @property {boolean} [unique] Index unique.
                     * @property {Long} [seq] Index seq.
                     * @property {string} [column] Index column.
                     * @property {string} [direction] Index direction.
                     * @property {boolean} [storing] Index storing.
                     * @property {boolean} [implicit] Index implicit.
                     */

                    /**
                     * Constructs a new Index.
                     * @exports cockroach.server.serverpb.TableDetailsResponse.Index
                     * @constructor
                     * @param {cockroach.server.serverpb.TableDetailsResponse.Index$Properties=} [properties] Properties to set
                     */
                    function Index(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * Index name.
                     * @type {string}
                     */
                    Index.prototype.name = "";

                    /**
                     * Index unique.
                     * @type {boolean}
                     */
                    Index.prototype.unique = false;

                    /**
                     * Index seq.
                     * @type {Long}
                     */
                    Index.prototype.seq = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

                    /**
                     * Index column.
                     * @type {string}
                     */
                    Index.prototype.column = "";

                    /**
                     * Index direction.
                     * @type {string}
                     */
                    Index.prototype.direction = "";

                    /**
                     * Index storing.
                     * @type {boolean}
                     */
                    Index.prototype.storing = false;

                    /**
                     * Index implicit.
                     * @type {boolean}
                     */
                    Index.prototype.implicit = false;

                    /**
                     * Creates a new Index instance using the specified properties.
                     * @param {cockroach.server.serverpb.TableDetailsResponse.Index$Properties=} [properties] Properties to set
                     * @returns {cockroach.server.serverpb.TableDetailsResponse.Index} Index instance
                     */
                    Index.create = function create(properties) {
                        return new Index(properties);
                    };

                    /**
                     * Encodes the specified Index message. Does not implicitly {@link cockroach.server.serverpb.TableDetailsResponse.Index.verify|verify} messages.
                     * @param {cockroach.server.serverpb.TableDetailsResponse.Index$Properties} message Index message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Index.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.name != null && message.hasOwnProperty("name"))
                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                        if (message.unique != null && message.hasOwnProperty("unique"))
                            writer.uint32(/* id 2, wireType 0 =*/16).bool(message.unique);
                        if (message.seq != null && message.hasOwnProperty("seq"))
                            writer.uint32(/* id 3, wireType 0 =*/24).int64(message.seq);
                        if (message.column != null && message.hasOwnProperty("column"))
                            writer.uint32(/* id 4, wireType 2 =*/34).string(message.column);
                        if (message.direction != null && message.hasOwnProperty("direction"))
                            writer.uint32(/* id 5, wireType 2 =*/42).string(message.direction);
                        if (message.storing != null && message.hasOwnProperty("storing"))
                            writer.uint32(/* id 6, wireType 0 =*/48).bool(message.storing);
                        if (message.implicit != null && message.hasOwnProperty("implicit"))
                            writer.uint32(/* id 7, wireType 0 =*/56).bool(message.implicit);
                        return writer;
                    };

                    /**
                     * Encodes the specified Index message, length delimited. Does not implicitly {@link cockroach.server.serverpb.TableDetailsResponse.Index.verify|verify} messages.
                     * @param {cockroach.server.serverpb.TableDetailsResponse.Index$Properties} message Index message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Index.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes an Index message from the specified reader or buffer.
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {cockroach.server.serverpb.TableDetailsResponse.Index} Index
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Index.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.cockroach.server.serverpb.TableDetailsResponse.Index();
                        while (reader.pos < end) {
                            let tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.name = reader.string();
                                break;
                            case 2:
                                message.unique = reader.bool();
                                break;
                            case 3:
                                message.seq = reader.int64();
                                break;
                            case 4:
                                message.column = reader.string();
                                break;
                            case 5:
                                message.direction = reader.string();
                                break;
                            case 6:
                                message.storing = reader.bool();
                                break;
                            case 7:
                                message.implicit = reader.bool();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes an Index message from the specified reader or buffer, length delimited.
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {cockroach.server.serverpb.TableDetailsResponse.Index} Index
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Index.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies an Index message.
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {?string} `null` if valid, otherwise the reason why it is not
                     */
                    Index.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.name != null && message.hasOwnProperty("name"))
                            if (!$util.isString(message.name))
                                return "name: string expected";
                        if (message.unique != null && message.hasOwnProperty("unique"))
                            if (typeof message.unique !== "boolean")
                                return "unique: boolean expected";
                        if (message.seq != null && message.hasOwnProperty("seq"))
                            if (!$util.isInteger(message.seq) && !(message.seq && $util.isInteger(message.seq.low) && $util.isInteger(message.seq.high)))
                                return "seq: integer|Long expected";
                        if (message.column != null && message.hasOwnProperty("column"))
                            if (!$util.isString(message.column))
                                return "column: string expected";
                        if (message.direction != null && message.hasOwnProperty("direction"))
                            if (!$util.isString(message.direction))
                                return "direction: string expected";
                        if (message.storing != null && message.hasOwnProperty("storing"))
                            if (typeof message.storing !== "boolean")
                                return "storing: boolean expected";
                        if (message.implicit != null && message.hasOwnProperty("implicit"))
                            if (typeof message.implicit !== "boolean")
                                return "implicit: boolean expected";
                        return null;
                    };

                    /**
                     * Creates an Index message from a plain object. Also converts values to their respective internal types.
                     * @param {Object.<string,*>} object Plain object
                     * @returns {cockroach.server.serverpb.TableDetailsResponse.Index} Index
                     */
                    Index.fromObject = function fromObject(object) {
                        if (object instanceof $root.cockroach.server.serverpb.TableDetailsResponse.Index)
                            return object;
                        let message = new $root.cockroach.server.serverpb.TableDetailsResponse.Index();
                        if (object.name != null)
                            message.name = String(object.name);
                        if (object.unique != null)
                            message.unique = Boolean(object.unique);
                        if (object.seq != null)
                            if ($util.Long)
                                (message.seq = $util.Long.fromValue(object.seq)).unsigned = false;
                            else if (typeof object.seq === "string")
                                message.seq = parseInt(object.seq, 10);
                            else if (typeof object.seq === "number")
                                message.seq = object.seq;
                            else if (typeof object.seq === "object")
                                message.seq = new $util.LongBits(object.seq.low >>> 0, object.seq.high >>> 0).toNumber();
                        if (object.column != null)
                            message.column = String(object.column);
                        if (object.direction != null)
                            message.direction = String(object.direction);
                        if (object.storing != null)
                            message.storing = Boolean(object.storing);
                        if (object.implicit != null)
                            message.implicit = Boolean(object.implicit);
                        return message;
                    };

                    /**
                     * Creates an Index message from a plain object. Also converts values to their respective internal types.
                     * This is an alias of {@link cockroach.server.serverpb.TableDetailsResponse.Index.fromObject}.
                     * @function
                     * @param {Object.<string,*>} object Plain object
                     * @returns {cockroach.server.serverpb.TableDetailsResponse.Index} Index
                     */
                    Index.from = Index.fromObject;

                    /**
                     * Creates a plain object from an Index message. Also converts values to other types if specified.
                     * @param {cockroach.server.serverpb.TableDetailsResponse.Index} message Index
                     * @param {$protobuf.ConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Index.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.defaults) {
                            object.name = "";
                            object.unique = false;
                            if ($util.Long) {
                                let long = new $util.Long(0, 0, false);
                                object.seq = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.seq = options.longs === String ? "0" : 0;
                            object.column = "";
                            object.direction = "";
                            object.storing = false;
                            object.implicit = false;
                        }
                        if (message.name != null && message.hasOwnProperty("name"))
                            object.name = message.name;
                        if (message.unique != null && message.hasOwnProperty("unique"))
                            object.unique = message.unique;
                        if (message.seq != null && message.hasOwnProperty("seq"))
                            if (typeof message.seq === "number")
                                object.seq = options.longs === String ? String(message.seq) : message.seq;
                            else
                                object.seq = options.longs === String ? $util.Long.prototype.toString.call(message.seq) : options.longs === Number ? new $util.LongBits(message.seq.low >>> 0, message.seq.high >>> 0).toNumber() : message.seq;
                        if (message.column != null && message.hasOwnProperty("column"))
                            object.column = message.column;
                        if (message.direction != null && message.hasOwnProperty("direction"))
                            object.direction = message.direction;
                        if (message.storing != null && message.hasOwnProperty("storing"))
                            object.storing = message.storing;
                        if (message.implicit != null && message.hasOwnProperty("implicit"))
                            object.implicit = message.implicit;
                        return object;
                    };

                    /**
                     * Creates a plain object from this Index message. Also converts values to other types if specified.
                     * @param {$protobuf.ConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Index.prototype.toObject = function toObject(options) {
                        return this.constructor.toObject(this, options);
                    };

                    /**
                     * Converts this Index to JSON.
                     * @returns {Object.<string,*>} JSON object
                     */
                    Index.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return Index;
                })();

                return TableDetailsResponse;
            })();

            serverpb.TableStatsRequest = (function() {

                /**
                 * Properties of a TableStatsRequest.
                 * @typedef cockroach.server.serverpb.TableStatsRequest$Properties
                 * @type {Object}
                 * @property {string} [database] TableStatsRequest database.
                 * @property {string} [table] TableStatsRequest table.
                 */

                /**
                 * Constructs a new TableStatsRequest.
                 * @exports cockroach.server.serverpb.TableStatsRequest
                 * @constructor
                 * @param {cockroach.server.serverpb.TableStatsRequest$Properties=} [properties] Properties to set
                 */
                function TableStatsRequest(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * TableStatsRequest database.
                 * @type {string}
                 */
                TableStatsRequest.prototype.database = "";

                /**
                 * TableStatsRequest table.
                 * @type {string}
                 */
                TableStatsRequest.prototype.table = "";

                /**
                 * Creates a new TableStatsRequest instance using the specified properties.
                 * @param {cockroach.server.serverpb.TableStatsRequest$Properties=} [properties] Properties to set
                 * @returns {cockroach.server.serverpb.TableStatsRequest} TableStatsRequest instance
                 */
                TableStatsRequest.create = function create(properties) {
                    return new TableStatsRequest(properties);
                };

                /**
                 * Encodes the specified TableStatsRequest message. Does not implicitly {@link cockroach.server.serverpb.TableStatsRequest.verify|verify} messages.
                 * @param {cockroach.server.serverpb.TableStatsRequest$Properties} message TableStatsRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                TableStatsRequest.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.database != null && message.hasOwnProperty("database"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.database);
                    if (message.table != null && message.hasOwnProperty("table"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.table);
                    return writer;
                };

                /**
                 * Encodes the specified TableStatsRequest message, length delimited. Does not implicitly {@link cockroach.server.serverpb.TableStatsRequest.verify|verify} messages.
                 * @param {cockroach.server.serverpb.TableStatsRequest$Properties} message TableStatsRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                TableStatsRequest.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a TableStatsRequest message from the specified reader or buffer.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {cockroach.server.serverpb.TableStatsRequest} TableStatsRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                TableStatsRequest.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.cockroach.server.serverpb.TableStatsRequest();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.database = reader.string();
                            break;
                        case 2:
                            message.table = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a TableStatsRequest message from the specified reader or buffer, length delimited.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {cockroach.server.serverpb.TableStatsRequest} TableStatsRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                TableStatsRequest.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a TableStatsRequest message.
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {?string} `null` if valid, otherwise the reason why it is not
                 */
                TableStatsRequest.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.database != null && message.hasOwnProperty("database"))
                        if (!$util.isString(message.database))
                            return "database: string expected";
                    if (message.table != null && message.hasOwnProperty("table"))
                        if (!$util.isString(message.table))
                            return "table: string expected";
                    return null;
                };

                /**
                 * Creates a TableStatsRequest message from a plain object. Also converts values to their respective internal types.
                 * @param {Object.<string,*>} object Plain object
                 * @returns {cockroach.server.serverpb.TableStatsRequest} TableStatsRequest
                 */
                TableStatsRequest.fromObject = function fromObject(object) {
                    if (object instanceof $root.cockroach.server.serverpb.TableStatsRequest)
                        return object;
                    let message = new $root.cockroach.server.serverpb.TableStatsRequest();
                    if (object.database != null)
                        message.database = String(object.database);
                    if (object.table != null)
                        message.table = String(object.table);
                    return message;
                };

                /**
                 * Creates a TableStatsRequest message from a plain object. Also converts values to their respective internal types.
                 * This is an alias of {@link cockroach.server.serverpb.TableStatsRequest.fromObject}.
                 * @function
                 * @param {Object.<string,*>} object Plain object
                 * @returns {cockroach.server.serverpb.TableStatsRequest} TableStatsRequest
                 */
                TableStatsRequest.from = TableStatsRequest.fromObject;

                /**
                 * Creates a plain object from a TableStatsRequest message. Also converts values to other types if specified.
                 * @param {cockroach.server.serverpb.TableStatsRequest} message TableStatsRequest
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                TableStatsRequest.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.database = "";
                        object.table = "";
                    }
                    if (message.database != null && message.hasOwnProperty("database"))
                        object.database = message.database;
                    if (message.table != null && message.hasOwnProperty("table"))
                        object.table = message.table;
                    return object;
                };

                /**
                 * Creates a plain object from this TableStatsRequest message. Also converts values to other types if specified.
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                TableStatsRequest.prototype.toObject = function toObject(options) {
                    return this.constructor.toObject(this, options);
                };

                /**
                 * Converts this TableStatsRequest to JSON.
                 * @returns {Object.<string,*>} JSON object
                 */
                TableStatsRequest.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return TableStatsRequest;
            })();

            serverpb.TableStatsResponse = (function() {

                /**
                 * Properties of a TableStatsResponse.
                 * @typedef cockroach.server.serverpb.TableStatsResponse$Properties
                 * @type {Object}
                 * @property {Long} [range_count] TableStatsResponse range_count.
                 * @property {Long} [replica_count] TableStatsResponse replica_count.
                 * @property {Long} [node_count] TableStatsResponse node_count.
                 * @property {cockroach.storage.engine.enginepb.MVCCStats$Properties} [stats] TableStatsResponse stats.
                 * @property {Array.<cockroach.server.serverpb.TableStatsResponse.MissingNode$Properties>} [missing_nodes] TableStatsResponse missing_nodes.
                 */

                /**
                 * Constructs a new TableStatsResponse.
                 * @exports cockroach.server.serverpb.TableStatsResponse
                 * @constructor
                 * @param {cockroach.server.serverpb.TableStatsResponse$Properties=} [properties] Properties to set
                 */
                function TableStatsResponse(properties) {
                    this.missing_nodes = [];
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * TableStatsResponse range_count.
                 * @type {Long}
                 */
                TableStatsResponse.prototype.range_count = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

                /**
                 * TableStatsResponse replica_count.
                 * @type {Long}
                 */
                TableStatsResponse.prototype.replica_count = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

                /**
                 * TableStatsResponse node_count.
                 * @type {Long}
                 */
                TableStatsResponse.prototype.node_count = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

                /**
                 * TableStatsResponse stats.
                 * @type {(cockroach.storage.engine.enginepb.MVCCStats$Properties|null)}
                 */
                TableStatsResponse.prototype.stats = null;

                /**
                 * TableStatsResponse missing_nodes.
                 * @type {Array.<cockroach.server.serverpb.TableStatsResponse.MissingNode$Properties>}
                 */
                TableStatsResponse.prototype.missing_nodes = $util.emptyArray;

                /**
                 * Creates a new TableStatsResponse instance using the specified properties.
                 * @param {cockroach.server.serverpb.TableStatsResponse$Properties=} [properties] Properties to set
                 * @returns {cockroach.server.serverpb.TableStatsResponse} TableStatsResponse instance
                 */
                TableStatsResponse.create = function create(properties) {
                    return new TableStatsResponse(properties);
                };

                /**
                 * Encodes the specified TableStatsResponse message. Does not implicitly {@link cockroach.server.serverpb.TableStatsResponse.verify|verify} messages.
                 * @param {cockroach.server.serverpb.TableStatsResponse$Properties} message TableStatsResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                TableStatsResponse.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.range_count != null && message.hasOwnProperty("range_count"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int64(message.range_count);
                    if (message.replica_count != null && message.hasOwnProperty("replica_count"))
                        writer.uint32(/* id 2, wireType 0 =*/16).int64(message.replica_count);
                    if (message.node_count != null && message.hasOwnProperty("node_count"))
                        writer.uint32(/* id 3, wireType 0 =*/24).int64(message.node_count);
                    if (message.stats != null && message.hasOwnProperty("stats"))
                        $root.cockroach.storage.engine.enginepb.MVCCStats.encode(message.stats, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                    if (message.missing_nodes != null && message.missing_nodes.length)
                        for (let i = 0; i < message.missing_nodes.length; ++i)
                            $root.cockroach.server.serverpb.TableStatsResponse.MissingNode.encode(message.missing_nodes[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified TableStatsResponse message, length delimited. Does not implicitly {@link cockroach.server.serverpb.TableStatsResponse.verify|verify} messages.
                 * @param {cockroach.server.serverpb.TableStatsResponse$Properties} message TableStatsResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                TableStatsResponse.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a TableStatsResponse message from the specified reader or buffer.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {cockroach.server.serverpb.TableStatsResponse} TableStatsResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                TableStatsResponse.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.cockroach.server.serverpb.TableStatsResponse();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.range_count = reader.int64();
                            break;
                        case 2:
                            message.replica_count = reader.int64();
                            break;
                        case 3:
                            message.node_count = reader.int64();
                            break;
                        case 4:
                            message.stats = $root.cockroach.storage.engine.enginepb.MVCCStats.decode(reader, reader.uint32());
                            break;
                        case 5:
                            if (!(message.missing_nodes && message.missing_nodes.length))
                                message.missing_nodes = [];
                            message.missing_nodes.push($root.cockroach.server.serverpb.TableStatsResponse.MissingNode.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a TableStatsResponse message from the specified reader or buffer, length delimited.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {cockroach.server.serverpb.TableStatsResponse} TableStatsResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                TableStatsResponse.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a TableStatsResponse message.
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {?string} `null` if valid, otherwise the reason why it is not
                 */
                TableStatsResponse.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.range_count != null && message.hasOwnProperty("range_count"))
                        if (!$util.isInteger(message.range_count) && !(message.range_count && $util.isInteger(message.range_count.low) && $util.isInteger(message.range_count.high)))
                            return "range_count: integer|Long expected";
                    if (message.replica_count != null && message.hasOwnProperty("replica_count"))
                        if (!$util.isInteger(message.replica_count) && !(message.replica_count && $util.isInteger(message.replica_count.low) && $util.isInteger(message.replica_count.high)))
                            return "replica_count: integer|Long expected";
                    if (message.node_count != null && message.hasOwnProperty("node_count"))
                        if (!$util.isInteger(message.node_count) && !(message.node_count && $util.isInteger(message.node_count.low) && $util.isInteger(message.node_count.high)))
                            return "node_count: integer|Long expected";
                    if (message.stats != null && message.hasOwnProperty("stats")) {
                        let error = $root.cockroach.storage.engine.enginepb.MVCCStats.verify(message.stats);
                        if (error)
                            return "stats." + error;
                    }
                    if (message.missing_nodes != null && message.hasOwnProperty("missing_nodes")) {
                        if (!Array.isArray(message.missing_nodes))
                            return "missing_nodes: array expected";
                        for (let i = 0; i < message.missing_nodes.length; ++i) {
                            let error = $root.cockroach.server.serverpb.TableStatsResponse.MissingNode.verify(message.missing_nodes[i]);
                            if (error)
                                return "missing_nodes." + error;
                        }
                    }
                    return null;
                };

                /**
                 * Creates a TableStatsResponse message from a plain object. Also converts values to their respective internal types.
                 * @param {Object.<string,*>} object Plain object
                 * @returns {cockroach.server.serverpb.TableStatsResponse} TableStatsResponse
                 */
                TableStatsResponse.fromObject = function fromObject(object) {
                    if (object instanceof $root.cockroach.server.serverpb.TableStatsResponse)
                        return object;
                    let message = new $root.cockroach.server.serverpb.TableStatsResponse();
                    if (object.range_count != null)
                        if ($util.Long)
                            (message.range_count = $util.Long.fromValue(object.range_count)).unsigned = false;
                        else if (typeof object.range_count === "string")
                            message.range_count = parseInt(object.range_count, 10);
                        else if (typeof object.range_count === "number")
                            message.range_count = object.range_count;
                        else if (typeof object.range_count === "object")
                            message.range_count = new $util.LongBits(object.range_count.low >>> 0, object.range_count.high >>> 0).toNumber();
                    if (object.replica_count != null)
                        if ($util.Long)
                            (message.replica_count = $util.Long.fromValue(object.replica_count)).unsigned = false;
                        else if (typeof object.replica_count === "string")
                            message.replica_count = parseInt(object.replica_count, 10);
                        else if (typeof object.replica_count === "number")
                            message.replica_count = object.replica_count;
                        else if (typeof object.replica_count === "object")
                            message.replica_count = new $util.LongBits(object.replica_count.low >>> 0, object.replica_count.high >>> 0).toNumber();
                    if (object.node_count != null)
                        if ($util.Long)
                            (message.node_count = $util.Long.fromValue(object.node_count)).unsigned = false;
                        else if (typeof object.node_count === "string")
                            message.node_count = parseInt(object.node_count, 10);
                        else if (typeof object.node_count === "number")
                            message.node_count = object.node_count;
                        else if (typeof object.node_count === "object")
                            message.node_count = new $util.LongBits(object.node_count.low >>> 0, object.node_count.high >>> 0).toNumber();
                    if (object.stats != null) {
                        if (typeof object.stats !== "object")
                            throw TypeError(".cockroach.server.serverpb.TableStatsResponse.stats: object expected");
                        message.stats = $root.cockroach.storage.engine.enginepb.MVCCStats.fromObject(object.stats);
                    }
                    if (object.missing_nodes) {
                        if (!Array.isArray(object.missing_nodes))
                            throw TypeError(".cockroach.server.serverpb.TableStatsResponse.missing_nodes: array expected");
                        message.missing_nodes = [];
                        for (let i = 0; i < object.missing_nodes.length; ++i) {
                            if (typeof object.missing_nodes[i] !== "object")
                                throw TypeError(".cockroach.server.serverpb.TableStatsResponse.missing_nodes: object expected");
                            message.missing_nodes[i] = $root.cockroach.server.serverpb.TableStatsResponse.MissingNode.fromObject(object.missing_nodes[i]);
                        }
                    }
                    return message;
                };

                /**
                 * Creates a TableStatsResponse message from a plain object. Also converts values to their respective internal types.
                 * This is an alias of {@link cockroach.server.serverpb.TableStatsResponse.fromObject}.
                 * @function
                 * @param {Object.<string,*>} object Plain object
                 * @returns {cockroach.server.serverpb.TableStatsResponse} TableStatsResponse
                 */
                TableStatsResponse.from = TableStatsResponse.fromObject;

                /**
                 * Creates a plain object from a TableStatsResponse message. Also converts values to other types if specified.
                 * @param {cockroach.server.serverpb.TableStatsResponse} message TableStatsResponse
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                TableStatsResponse.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.arrays || options.defaults)
                        object.missing_nodes = [];
                    if (options.defaults) {
                        if ($util.Long) {
                            let long = new $util.Long(0, 0, false);
                            object.range_count = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.range_count = options.longs === String ? "0" : 0;
                        if ($util.Long) {
                            let long = new $util.Long(0, 0, false);
                            object.replica_count = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.replica_count = options.longs === String ? "0" : 0;
                        if ($util.Long) {
                            let long = new $util.Long(0, 0, false);
                            object.node_count = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.node_count = options.longs === String ? "0" : 0;
                        object.stats = null;
                    }
                    if (message.range_count != null && message.hasOwnProperty("range_count"))
                        if (typeof message.range_count === "number")
                            object.range_count = options.longs === String ? String(message.range_count) : message.range_count;
                        else
                            object.range_count = options.longs === String ? $util.Long.prototype.toString.call(message.range_count) : options.longs === Number ? new $util.LongBits(message.range_count.low >>> 0, message.range_count.high >>> 0).toNumber() : message.range_count;
                    if (message.replica_count != null && message.hasOwnProperty("replica_count"))
                        if (typeof message.replica_count === "number")
                            object.replica_count = options.longs === String ? String(message.replica_count) : message.replica_count;
                        else
                            object.replica_count = options.longs === String ? $util.Long.prototype.toString.call(message.replica_count) : options.longs === Number ? new $util.LongBits(message.replica_count.low >>> 0, message.replica_count.high >>> 0).toNumber() : message.replica_count;
                    if (message.node_count != null && message.hasOwnProperty("node_count"))
                        if (typeof message.node_count === "number")
                            object.node_count = options.longs === String ? String(message.node_count) : message.node_count;
                        else
                            object.node_count = options.longs === String ? $util.Long.prototype.toString.call(message.node_count) : options.longs === Number ? new $util.LongBits(message.node_count.low >>> 0, message.node_count.high >>> 0).toNumber() : message.node_count;
                    if (message.stats != null && message.hasOwnProperty("stats"))
                        object.stats = $root.cockroach.storage.engine.enginepb.MVCCStats.toObject(message.stats, options);
                    if (message.missing_nodes && message.missing_nodes.length) {
                        object.missing_nodes = [];
                        for (let j = 0; j < message.missing_nodes.length; ++j)
                            object.missing_nodes[j] = $root.cockroach.server.serverpb.TableStatsResponse.MissingNode.toObject(message.missing_nodes[j], options);
                    }
                    return object;
                };

                /**
                 * Creates a plain object from this TableStatsResponse message. Also converts values to other types if specified.
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                TableStatsResponse.prototype.toObject = function toObject(options) {
                    return this.constructor.toObject(this, options);
                };

                /**
                 * Converts this TableStatsResponse to JSON.
                 * @returns {Object.<string,*>} JSON object
                 */
                TableStatsResponse.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                TableStatsResponse.MissingNode = (function() {

                    /**
                     * Properties of a MissingNode.
                     * @typedef cockroach.server.serverpb.TableStatsResponse.MissingNode$Properties
                     * @type {Object}
                     * @property {string} [node_id] MissingNode node_id.
                     * @property {string} [error_message] MissingNode error_message.
                     */

                    /**
                     * Constructs a new MissingNode.
                     * @exports cockroach.server.serverpb.TableStatsResponse.MissingNode
                     * @constructor
                     * @param {cockroach.server.serverpb.TableStatsResponse.MissingNode$Properties=} [properties] Properties to set
                     */
                    function MissingNode(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * MissingNode node_id.
                     * @type {string}
                     */
                    MissingNode.prototype.node_id = "";

                    /**
                     * MissingNode error_message.
                     * @type {string}
                     */
                    MissingNode.prototype.error_message = "";

                    /**
                     * Creates a new MissingNode instance using the specified properties.
                     * @param {cockroach.server.serverpb.TableStatsResponse.MissingNode$Properties=} [properties] Properties to set
                     * @returns {cockroach.server.serverpb.TableStatsResponse.MissingNode} MissingNode instance
                     */
                    MissingNode.create = function create(properties) {
                        return new MissingNode(properties);
                    };

                    /**
                     * Encodes the specified MissingNode message. Does not implicitly {@link cockroach.server.serverpb.TableStatsResponse.MissingNode.verify|verify} messages.
                     * @param {cockroach.server.serverpb.TableStatsResponse.MissingNode$Properties} message MissingNode message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    MissingNode.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.node_id != null && message.hasOwnProperty("node_id"))
                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.node_id);
                        if (message.error_message != null && message.hasOwnProperty("error_message"))
                            writer.uint32(/* id 2, wireType 2 =*/18).string(message.error_message);
                        return writer;
                    };

                    /**
                     * Encodes the specified MissingNode message, length delimited. Does not implicitly {@link cockroach.server.serverpb.TableStatsResponse.MissingNode.verify|verify} messages.
                     * @param {cockroach.server.serverpb.TableStatsResponse.MissingNode$Properties} message MissingNode message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    MissingNode.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a MissingNode message from the specified reader or buffer.
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {cockroach.server.serverpb.TableStatsResponse.MissingNode} MissingNode
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    MissingNode.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.cockroach.server.serverpb.TableStatsResponse.MissingNode();
                        while (reader.pos < end) {
                            let tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.node_id = reader.string();
                                break;
                            case 2:
                                message.error_message = reader.string();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a MissingNode message from the specified reader or buffer, length delimited.
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {cockroach.server.serverpb.TableStatsResponse.MissingNode} MissingNode
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    MissingNode.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a MissingNode message.
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {?string} `null` if valid, otherwise the reason why it is not
                     */
                    MissingNode.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.node_id != null && message.hasOwnProperty("node_id"))
                            if (!$util.isString(message.node_id))
                                return "node_id: string expected";
                        if (message.error_message != null && message.hasOwnProperty("error_message"))
                            if (!$util.isString(message.error_message))
                                return "error_message: string expected";
                        return null;
                    };

                    /**
                     * Creates a MissingNode message from a plain object. Also converts values to their respective internal types.
                     * @param {Object.<string,*>} object Plain object
                     * @returns {cockroach.server.serverpb.TableStatsResponse.MissingNode} MissingNode
                     */
                    MissingNode.fromObject = function fromObject(object) {
                        if (object instanceof $root.cockroach.server.serverpb.TableStatsResponse.MissingNode)
                            return object;
                        let message = new $root.cockroach.server.serverpb.TableStatsResponse.MissingNode();
                        if (object.node_id != null)
                            message.node_id = String(object.node_id);
                        if (object.error_message != null)
                            message.error_message = String(object.error_message);
                        return message;
                    };

                    /**
                     * Creates a MissingNode message from a plain object. Also converts values to their respective internal types.
                     * This is an alias of {@link cockroach.server.serverpb.TableStatsResponse.MissingNode.fromObject}.
                     * @function
                     * @param {Object.<string,*>} object Plain object
                     * @returns {cockroach.server.serverpb.TableStatsResponse.MissingNode} MissingNode
                     */
                    MissingNode.from = MissingNode.fromObject;

                    /**
                     * Creates a plain object from a MissingNode message. Also converts values to other types if specified.
                     * @param {cockroach.server.serverpb.TableStatsResponse.MissingNode} message MissingNode
                     * @param {$protobuf.ConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    MissingNode.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.defaults) {
                            object.node_id = "";
                            object.error_message = "";
                        }
                        if (message.node_id != null && message.hasOwnProperty("node_id"))
                            object.node_id = message.node_id;
                        if (message.error_message != null && message.hasOwnProperty("error_message"))
                            object.error_message = message.error_message;
                        return object;
                    };

                    /**
                     * Creates a plain object from this MissingNode message. Also converts values to other types if specified.
                     * @param {$protobuf.ConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    MissingNode.prototype.toObject = function toObject(options) {
                        return this.constructor.toObject(this, options);
                    };

                    /**
                     * Converts this MissingNode to JSON.
                     * @returns {Object.<string,*>} JSON object
                     */
                    MissingNode.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return MissingNode;
                })();

                return TableStatsResponse;
            })();

            serverpb.UsersRequest = (function() {

                /**
                 * Properties of a UsersRequest.
                 * @typedef cockroach.server.serverpb.UsersRequest$Properties
                 * @type {Object}
                 */

                /**
                 * Constructs a new UsersRequest.
                 * @exports cockroach.server.serverpb.UsersRequest
                 * @constructor
                 * @param {cockroach.server.serverpb.UsersRequest$Properties=} [properties] Properties to set
                 */
                function UsersRequest(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Creates a new UsersRequest instance using the specified properties.
                 * @param {cockroach.server.serverpb.UsersRequest$Properties=} [properties] Properties to set
                 * @returns {cockroach.server.serverpb.UsersRequest} UsersRequest instance
                 */
                UsersRequest.create = function create(properties) {
                    return new UsersRequest(properties);
                };

                /**
                 * Encodes the specified UsersRequest message. Does not implicitly {@link cockroach.server.serverpb.UsersRequest.verify|verify} messages.
                 * @param {cockroach.server.serverpb.UsersRequest$Properties} message UsersRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                UsersRequest.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    return writer;
                };

                /**
                 * Encodes the specified UsersRequest message, length delimited. Does not implicitly {@link cockroach.server.serverpb.UsersRequest.verify|verify} messages.
                 * @param {cockroach.server.serverpb.UsersRequest$Properties} message UsersRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                UsersRequest.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a UsersRequest message from the specified reader or buffer.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {cockroach.server.serverpb.UsersRequest} UsersRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                UsersRequest.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.cockroach.server.serverpb.UsersRequest();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a UsersRequest message from the specified reader or buffer, length delimited.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {cockroach.server.serverpb.UsersRequest} UsersRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                UsersRequest.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a UsersRequest message.
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {?string} `null` if valid, otherwise the reason why it is not
                 */
                UsersRequest.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    return null;
                };

                /**
                 * Creates a UsersRequest message from a plain object. Also converts values to their respective internal types.
                 * @param {Object.<string,*>} object Plain object
                 * @returns {cockroach.server.serverpb.UsersRequest} UsersRequest
                 */
                UsersRequest.fromObject = function fromObject(object) {
                    if (object instanceof $root.cockroach.server.serverpb.UsersRequest)
                        return object;
                    return new $root.cockroach.server.serverpb.UsersRequest();
                };

                /**
                 * Creates a UsersRequest message from a plain object. Also converts values to their respective internal types.
                 * This is an alias of {@link cockroach.server.serverpb.UsersRequest.fromObject}.
                 * @function
                 * @param {Object.<string,*>} object Plain object
                 * @returns {cockroach.server.serverpb.UsersRequest} UsersRequest
                 */
                UsersRequest.from = UsersRequest.fromObject;

                /**
                 * Creates a plain object from a UsersRequest message. Also converts values to other types if specified.
                 * @param {cockroach.server.serverpb.UsersRequest} message UsersRequest
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                UsersRequest.toObject = function toObject() {
                    return {};
                };

                /**
                 * Creates a plain object from this UsersRequest message. Also converts values to other types if specified.
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                UsersRequest.prototype.toObject = function toObject(options) {
                    return this.constructor.toObject(this, options);
                };

                /**
                 * Converts this UsersRequest to JSON.
                 * @returns {Object.<string,*>} JSON object
                 */
                UsersRequest.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return UsersRequest;
            })();

            serverpb.UsersResponse = (function() {

                /**
                 * Properties of a UsersResponse.
                 * @typedef cockroach.server.serverpb.UsersResponse$Properties
                 * @type {Object}
                 * @property {Array.<cockroach.server.serverpb.UsersResponse.User$Properties>} [users] UsersResponse users.
                 */

                /**
                 * Constructs a new UsersResponse.
                 * @exports cockroach.server.serverpb.UsersResponse
                 * @constructor
                 * @param {cockroach.server.serverpb.UsersResponse$Properties=} [properties] Properties to set
                 */
                function UsersResponse(properties) {
                    this.users = [];
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * UsersResponse users.
                 * @type {Array.<cockroach.server.serverpb.UsersResponse.User$Properties>}
                 */
                UsersResponse.prototype.users = $util.emptyArray;

                /**
                 * Creates a new UsersResponse instance using the specified properties.
                 * @param {cockroach.server.serverpb.UsersResponse$Properties=} [properties] Properties to set
                 * @returns {cockroach.server.serverpb.UsersResponse} UsersResponse instance
                 */
                UsersResponse.create = function create(properties) {
                    return new UsersResponse(properties);
                };

                /**
                 * Encodes the specified UsersResponse message. Does not implicitly {@link cockroach.server.serverpb.UsersResponse.verify|verify} messages.
                 * @param {cockroach.server.serverpb.UsersResponse$Properties} message UsersResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                UsersResponse.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.users != null && message.users.length)
                        for (let i = 0; i < message.users.length; ++i)
                            $root.cockroach.server.serverpb.UsersResponse.User.encode(message.users[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified UsersResponse message, length delimited. Does not implicitly {@link cockroach.server.serverpb.UsersResponse.verify|verify} messages.
                 * @param {cockroach.server.serverpb.UsersResponse$Properties} message UsersResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                UsersResponse.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a UsersResponse message from the specified reader or buffer.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {cockroach.server.serverpb.UsersResponse} UsersResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                UsersResponse.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.cockroach.server.serverpb.UsersResponse();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (!(message.users && message.users.length))
                                message.users = [];
                            message.users.push($root.cockroach.server.serverpb.UsersResponse.User.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a UsersResponse message from the specified reader or buffer, length delimited.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {cockroach.server.serverpb.UsersResponse} UsersResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                UsersResponse.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a UsersResponse message.
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {?string} `null` if valid, otherwise the reason why it is not
                 */
                UsersResponse.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.users != null && message.hasOwnProperty("users")) {
                        if (!Array.isArray(message.users))
                            return "users: array expected";
                        for (let i = 0; i < message.users.length; ++i) {
                            let error = $root.cockroach.server.serverpb.UsersResponse.User.verify(message.users[i]);
                            if (error)
                                return "users." + error;
                        }
                    }
                    return null;
                };

                /**
                 * Creates a UsersResponse message from a plain object. Also converts values to their respective internal types.
                 * @param {Object.<string,*>} object Plain object
                 * @returns {cockroach.server.serverpb.UsersResponse} UsersResponse
                 */
                UsersResponse.fromObject = function fromObject(object) {
                    if (object instanceof $root.cockroach.server.serverpb.UsersResponse)
                        return object;
                    let message = new $root.cockroach.server.serverpb.UsersResponse();
                    if (object.users) {
                        if (!Array.isArray(object.users))
                            throw TypeError(".cockroach.server.serverpb.UsersResponse.users: array expected");
                        message.users = [];
                        for (let i = 0; i < object.users.length; ++i) {
                            if (typeof object.users[i] !== "object")
                                throw TypeError(".cockroach.server.serverpb.UsersResponse.users: object expected");
                            message.users[i] = $root.cockroach.server.serverpb.UsersResponse.User.fromObject(object.users[i]);
                        }
                    }
                    return message;
                };

                /**
                 * Creates a UsersResponse message from a plain object. Also converts values to their respective internal types.
                 * This is an alias of {@link cockroach.server.serverpb.UsersResponse.fromObject}.
                 * @function
                 * @param {Object.<string,*>} object Plain object
                 * @returns {cockroach.server.serverpb.UsersResponse} UsersResponse
                 */
                UsersResponse.from = UsersResponse.fromObject;

                /**
                 * Creates a plain object from a UsersResponse message. Also converts values to other types if specified.
                 * @param {cockroach.server.serverpb.UsersResponse} message UsersResponse
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                UsersResponse.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.arrays || options.defaults)
                        object.users = [];
                    if (message.users && message.users.length) {
                        object.users = [];
                        for (let j = 0; j < message.users.length; ++j)
                            object.users[j] = $root.cockroach.server.serverpb.UsersResponse.User.toObject(message.users[j], options);
                    }
                    return object;
                };

                /**
                 * Creates a plain object from this UsersResponse message. Also converts values to other types if specified.
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                UsersResponse.prototype.toObject = function toObject(options) {
                    return this.constructor.toObject(this, options);
                };

                /**
                 * Converts this UsersResponse to JSON.
                 * @returns {Object.<string,*>} JSON object
                 */
                UsersResponse.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                UsersResponse.User = (function() {

                    /**
                     * Properties of a User.
                     * @typedef cockroach.server.serverpb.UsersResponse.User$Properties
                     * @type {Object}
                     * @property {string} [username] User username.
                     */

                    /**
                     * Constructs a new User.
                     * @exports cockroach.server.serverpb.UsersResponse.User
                     * @constructor
                     * @param {cockroach.server.serverpb.UsersResponse.User$Properties=} [properties] Properties to set
                     */
                    function User(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * User username.
                     * @type {string}
                     */
                    User.prototype.username = "";

                    /**
                     * Creates a new User instance using the specified properties.
                     * @param {cockroach.server.serverpb.UsersResponse.User$Properties=} [properties] Properties to set
                     * @returns {cockroach.server.serverpb.UsersResponse.User} User instance
                     */
                    User.create = function create(properties) {
                        return new User(properties);
                    };

                    /**
                     * Encodes the specified User message. Does not implicitly {@link cockroach.server.serverpb.UsersResponse.User.verify|verify} messages.
                     * @param {cockroach.server.serverpb.UsersResponse.User$Properties} message User message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    User.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.username != null && message.hasOwnProperty("username"))
                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.username);
                        return writer;
                    };

                    /**
                     * Encodes the specified User message, length delimited. Does not implicitly {@link cockroach.server.serverpb.UsersResponse.User.verify|verify} messages.
                     * @param {cockroach.server.serverpb.UsersResponse.User$Properties} message User message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    User.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a User message from the specified reader or buffer.
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {cockroach.server.serverpb.UsersResponse.User} User
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    User.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.cockroach.server.serverpb.UsersResponse.User();
                        while (reader.pos < end) {
                            let tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.username = reader.string();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a User message from the specified reader or buffer, length delimited.
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {cockroach.server.serverpb.UsersResponse.User} User
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    User.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a User message.
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {?string} `null` if valid, otherwise the reason why it is not
                     */
                    User.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.username != null && message.hasOwnProperty("username"))
                            if (!$util.isString(message.username))
                                return "username: string expected";
                        return null;
                    };

                    /**
                     * Creates a User message from a plain object. Also converts values to their respective internal types.
                     * @param {Object.<string,*>} object Plain object
                     * @returns {cockroach.server.serverpb.UsersResponse.User} User
                     */
                    User.fromObject = function fromObject(object) {
                        if (object instanceof $root.cockroach.server.serverpb.UsersResponse.User)
                            return object;
                        let message = new $root.cockroach.server.serverpb.UsersResponse.User();
                        if (object.username != null)
                            message.username = String(object.username);
                        return message;
                    };

                    /**
                     * Creates a User message from a plain object. Also converts values to their respective internal types.
                     * This is an alias of {@link cockroach.server.serverpb.UsersResponse.User.fromObject}.
                     * @function
                     * @param {Object.<string,*>} object Plain object
                     * @returns {cockroach.server.serverpb.UsersResponse.User} User
                     */
                    User.from = User.fromObject;

                    /**
                     * Creates a plain object from a User message. Also converts values to other types if specified.
                     * @param {cockroach.server.serverpb.UsersResponse.User} message User
                     * @param {$protobuf.ConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    User.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.defaults)
                            object.username = "";
                        if (message.username != null && message.hasOwnProperty("username"))
                            object.username = message.username;
                        return object;
                    };

                    /**
                     * Creates a plain object from this User message. Also converts values to other types if specified.
                     * @param {$protobuf.ConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    User.prototype.toObject = function toObject(options) {
                        return this.constructor.toObject(this, options);
                    };

                    /**
                     * Converts this User to JSON.
                     * @returns {Object.<string,*>} JSON object
                     */
                    User.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return User;
                })();

                return UsersResponse;
            })();

            serverpb.EventsRequest = (function() {

                /**
                 * Properties of an EventsRequest.
                 * @typedef cockroach.server.serverpb.EventsRequest$Properties
                 * @type {Object}
                 * @property {string} [type] EventsRequest type.
                 * @property {Long} [target_id] EventsRequest target_id.
                 */

                /**
                 * Constructs a new EventsRequest.
                 * @exports cockroach.server.serverpb.EventsRequest
                 * @constructor
                 * @param {cockroach.server.serverpb.EventsRequest$Properties=} [properties] Properties to set
                 */
                function EventsRequest(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * EventsRequest type.
                 * @type {string}
                 */
                EventsRequest.prototype.type = "";

                /**
                 * EventsRequest target_id.
                 * @type {Long}
                 */
                EventsRequest.prototype.target_id = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

                /**
                 * Creates a new EventsRequest instance using the specified properties.
                 * @param {cockroach.server.serverpb.EventsRequest$Properties=} [properties] Properties to set
                 * @returns {cockroach.server.serverpb.EventsRequest} EventsRequest instance
                 */
                EventsRequest.create = function create(properties) {
                    return new EventsRequest(properties);
                };

                /**
                 * Encodes the specified EventsRequest message. Does not implicitly {@link cockroach.server.serverpb.EventsRequest.verify|verify} messages.
                 * @param {cockroach.server.serverpb.EventsRequest$Properties} message EventsRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                EventsRequest.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.type != null && message.hasOwnProperty("type"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.type);
                    if (message.target_id != null && message.hasOwnProperty("target_id"))
                        writer.uint32(/* id 2, wireType 0 =*/16).int64(message.target_id);
                    return writer;
                };

                /**
                 * Encodes the specified EventsRequest message, length delimited. Does not implicitly {@link cockroach.server.serverpb.EventsRequest.verify|verify} messages.
                 * @param {cockroach.server.serverpb.EventsRequest$Properties} message EventsRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                EventsRequest.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes an EventsRequest message from the specified reader or buffer.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {cockroach.server.serverpb.EventsRequest} EventsRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                EventsRequest.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.cockroach.server.serverpb.EventsRequest();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.type = reader.string();
                            break;
                        case 2:
                            message.target_id = reader.int64();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes an EventsRequest message from the specified reader or buffer, length delimited.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {cockroach.server.serverpb.EventsRequest} EventsRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                EventsRequest.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies an EventsRequest message.
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {?string} `null` if valid, otherwise the reason why it is not
                 */
                EventsRequest.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.type != null && message.hasOwnProperty("type"))
                        if (!$util.isString(message.type))
                            return "type: string expected";
                    if (message.target_id != null && message.hasOwnProperty("target_id"))
                        if (!$util.isInteger(message.target_id) && !(message.target_id && $util.isInteger(message.target_id.low) && $util.isInteger(message.target_id.high)))
                            return "target_id: integer|Long expected";
                    return null;
                };

                /**
                 * Creates an EventsRequest message from a plain object. Also converts values to their respective internal types.
                 * @param {Object.<string,*>} object Plain object
                 * @returns {cockroach.server.serverpb.EventsRequest} EventsRequest
                 */
                EventsRequest.fromObject = function fromObject(object) {
                    if (object instanceof $root.cockroach.server.serverpb.EventsRequest)
                        return object;
                    let message = new $root.cockroach.server.serverpb.EventsRequest();
                    if (object.type != null)
                        message.type = String(object.type);
                    if (object.target_id != null)
                        if ($util.Long)
                            (message.target_id = $util.Long.fromValue(object.target_id)).unsigned = false;
                        else if (typeof object.target_id === "string")
                            message.target_id = parseInt(object.target_id, 10);
                        else if (typeof object.target_id === "number")
                            message.target_id = object.target_id;
                        else if (typeof object.target_id === "object")
                            message.target_id = new $util.LongBits(object.target_id.low >>> 0, object.target_id.high >>> 0).toNumber();
                    return message;
                };

                /**
                 * Creates an EventsRequest message from a plain object. Also converts values to their respective internal types.
                 * This is an alias of {@link cockroach.server.serverpb.EventsRequest.fromObject}.
                 * @function
                 * @param {Object.<string,*>} object Plain object
                 * @returns {cockroach.server.serverpb.EventsRequest} EventsRequest
                 */
                EventsRequest.from = EventsRequest.fromObject;

                /**
                 * Creates a plain object from an EventsRequest message. Also converts values to other types if specified.
                 * @param {cockroach.server.serverpb.EventsRequest} message EventsRequest
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                EventsRequest.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.type = "";
                        if ($util.Long) {
                            let long = new $util.Long(0, 0, false);
                            object.target_id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.target_id = options.longs === String ? "0" : 0;
                    }
                    if (message.type != null && message.hasOwnProperty("type"))
                        object.type = message.type;
                    if (message.target_id != null && message.hasOwnProperty("target_id"))
                        if (typeof message.target_id === "number")
                            object.target_id = options.longs === String ? String(message.target_id) : message.target_id;
                        else
                            object.target_id = options.longs === String ? $util.Long.prototype.toString.call(message.target_id) : options.longs === Number ? new $util.LongBits(message.target_id.low >>> 0, message.target_id.high >>> 0).toNumber() : message.target_id;
                    return object;
                };

                /**
                 * Creates a plain object from this EventsRequest message. Also converts values to other types if specified.
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                EventsRequest.prototype.toObject = function toObject(options) {
                    return this.constructor.toObject(this, options);
                };

                /**
                 * Converts this EventsRequest to JSON.
                 * @returns {Object.<string,*>} JSON object
                 */
                EventsRequest.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return EventsRequest;
            })();

            serverpb.EventsResponse = (function() {

                /**
                 * Properties of an EventsResponse.
                 * @typedef cockroach.server.serverpb.EventsResponse$Properties
                 * @type {Object}
                 * @property {Array.<cockroach.server.serverpb.EventsResponse.Event$Properties>} [events] EventsResponse events.
                 */

                /**
                 * Constructs a new EventsResponse.
                 * @exports cockroach.server.serverpb.EventsResponse
                 * @constructor
                 * @param {cockroach.server.serverpb.EventsResponse$Properties=} [properties] Properties to set
                 */
                function EventsResponse(properties) {
                    this.events = [];
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * EventsResponse events.
                 * @type {Array.<cockroach.server.serverpb.EventsResponse.Event$Properties>}
                 */
                EventsResponse.prototype.events = $util.emptyArray;

                /**
                 * Creates a new EventsResponse instance using the specified properties.
                 * @param {cockroach.server.serverpb.EventsResponse$Properties=} [properties] Properties to set
                 * @returns {cockroach.server.serverpb.EventsResponse} EventsResponse instance
                 */
                EventsResponse.create = function create(properties) {
                    return new EventsResponse(properties);
                };

                /**
                 * Encodes the specified EventsResponse message. Does not implicitly {@link cockroach.server.serverpb.EventsResponse.verify|verify} messages.
                 * @param {cockroach.server.serverpb.EventsResponse$Properties} message EventsResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                EventsResponse.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.events != null && message.events.length)
                        for (let i = 0; i < message.events.length; ++i)
                            $root.cockroach.server.serverpb.EventsResponse.Event.encode(message.events[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified EventsResponse message, length delimited. Does not implicitly {@link cockroach.server.serverpb.EventsResponse.verify|verify} messages.
                 * @param {cockroach.server.serverpb.EventsResponse$Properties} message EventsResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                EventsResponse.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes an EventsResponse message from the specified reader or buffer.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {cockroach.server.serverpb.EventsResponse} EventsResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                EventsResponse.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.cockroach.server.serverpb.EventsResponse();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (!(message.events && message.events.length))
                                message.events = [];
                            message.events.push($root.cockroach.server.serverpb.EventsResponse.Event.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes an EventsResponse message from the specified reader or buffer, length delimited.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {cockroach.server.serverpb.EventsResponse} EventsResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                EventsResponse.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies an EventsResponse message.
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {?string} `null` if valid, otherwise the reason why it is not
                 */
                EventsResponse.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.events != null && message.hasOwnProperty("events")) {
                        if (!Array.isArray(message.events))
                            return "events: array expected";
                        for (let i = 0; i < message.events.length; ++i) {
                            let error = $root.cockroach.server.serverpb.EventsResponse.Event.verify(message.events[i]);
                            if (error)
                                return "events." + error;
                        }
                    }
                    return null;
                };

                /**
                 * Creates an EventsResponse message from a plain object. Also converts values to their respective internal types.
                 * @param {Object.<string,*>} object Plain object
                 * @returns {cockroach.server.serverpb.EventsResponse} EventsResponse
                 */
                EventsResponse.fromObject = function fromObject(object) {
                    if (object instanceof $root.cockroach.server.serverpb.EventsResponse)
                        return object;
                    let message = new $root.cockroach.server.serverpb.EventsResponse();
                    if (object.events) {
                        if (!Array.isArray(object.events))
                            throw TypeError(".cockroach.server.serverpb.EventsResponse.events: array expected");
                        message.events = [];
                        for (let i = 0; i < object.events.length; ++i) {
                            if (typeof object.events[i] !== "object")
                                throw TypeError(".cockroach.server.serverpb.EventsResponse.events: object expected");
                            message.events[i] = $root.cockroach.server.serverpb.EventsResponse.Event.fromObject(object.events[i]);
                        }
                    }
                    return message;
                };

                /**
                 * Creates an EventsResponse message from a plain object. Also converts values to their respective internal types.
                 * This is an alias of {@link cockroach.server.serverpb.EventsResponse.fromObject}.
                 * @function
                 * @param {Object.<string,*>} object Plain object
                 * @returns {cockroach.server.serverpb.EventsResponse} EventsResponse
                 */
                EventsResponse.from = EventsResponse.fromObject;

                /**
                 * Creates a plain object from an EventsResponse message. Also converts values to other types if specified.
                 * @param {cockroach.server.serverpb.EventsResponse} message EventsResponse
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                EventsResponse.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.arrays || options.defaults)
                        object.events = [];
                    if (message.events && message.events.length) {
                        object.events = [];
                        for (let j = 0; j < message.events.length; ++j)
                            object.events[j] = $root.cockroach.server.serverpb.EventsResponse.Event.toObject(message.events[j], options);
                    }
                    return object;
                };

                /**
                 * Creates a plain object from this EventsResponse message. Also converts values to other types if specified.
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                EventsResponse.prototype.toObject = function toObject(options) {
                    return this.constructor.toObject(this, options);
                };

                /**
                 * Converts this EventsResponse to JSON.
                 * @returns {Object.<string,*>} JSON object
                 */
                EventsResponse.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                EventsResponse.Event = (function() {

                    /**
                     * Properties of an Event.
                     * @typedef cockroach.server.serverpb.EventsResponse.Event$Properties
                     * @type {Object}
                     * @property {google.protobuf.Timestamp$Properties} [timestamp] Event timestamp.
                     * @property {string} [event_type] Event event_type.
                     * @property {Long} [target_id] Event target_id.
                     * @property {Long} [reporting_id] Event reporting_id.
                     * @property {string} [info] Event info.
                     * @property {Uint8Array} [unique_id] Event unique_id.
                     */

                    /**
                     * Constructs a new Event.
                     * @exports cockroach.server.serverpb.EventsResponse.Event
                     * @constructor
                     * @param {cockroach.server.serverpb.EventsResponse.Event$Properties=} [properties] Properties to set
                     */
                    function Event(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * Event timestamp.
                     * @type {(google.protobuf.Timestamp$Properties|null)}
                     */
                    Event.prototype.timestamp = null;

                    /**
                     * Event event_type.
                     * @type {string}
                     */
                    Event.prototype.event_type = "";

                    /**
                     * Event target_id.
                     * @type {Long}
                     */
                    Event.prototype.target_id = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

                    /**
                     * Event reporting_id.
                     * @type {Long}
                     */
                    Event.prototype.reporting_id = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

                    /**
                     * Event info.
                     * @type {string}
                     */
                    Event.prototype.info = "";

                    /**
                     * Event unique_id.
                     * @type {Uint8Array}
                     */
                    Event.prototype.unique_id = $util.newBuffer([]);

                    /**
                     * Creates a new Event instance using the specified properties.
                     * @param {cockroach.server.serverpb.EventsResponse.Event$Properties=} [properties] Properties to set
                     * @returns {cockroach.server.serverpb.EventsResponse.Event} Event instance
                     */
                    Event.create = function create(properties) {
                        return new Event(properties);
                    };

                    /**
                     * Encodes the specified Event message. Does not implicitly {@link cockroach.server.serverpb.EventsResponse.Event.verify|verify} messages.
                     * @param {cockroach.server.serverpb.EventsResponse.Event$Properties} message Event message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Event.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                            $root.google.protobuf.Timestamp.encode(message.timestamp, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                        if (message.event_type != null && message.hasOwnProperty("event_type"))
                            writer.uint32(/* id 2, wireType 2 =*/18).string(message.event_type);
                        if (message.target_id != null && message.hasOwnProperty("target_id"))
                            writer.uint32(/* id 3, wireType 0 =*/24).int64(message.target_id);
                        if (message.reporting_id != null && message.hasOwnProperty("reporting_id"))
                            writer.uint32(/* id 4, wireType 0 =*/32).int64(message.reporting_id);
                        if (message.info != null && message.hasOwnProperty("info"))
                            writer.uint32(/* id 5, wireType 2 =*/42).string(message.info);
                        if (message.unique_id != null && message.hasOwnProperty("unique_id"))
                            writer.uint32(/* id 6, wireType 2 =*/50).bytes(message.unique_id);
                        return writer;
                    };

                    /**
                     * Encodes the specified Event message, length delimited. Does not implicitly {@link cockroach.server.serverpb.EventsResponse.Event.verify|verify} messages.
                     * @param {cockroach.server.serverpb.EventsResponse.Event$Properties} message Event message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Event.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes an Event message from the specified reader or buffer.
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {cockroach.server.serverpb.EventsResponse.Event} Event
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Event.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.cockroach.server.serverpb.EventsResponse.Event();
                        while (reader.pos < end) {
                            let tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.timestamp = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
                                break;
                            case 2:
                                message.event_type = reader.string();
                                break;
                            case 3:
                                message.target_id = reader.int64();
                                break;
                            case 4:
                                message.reporting_id = reader.int64();
                                break;
                            case 5:
                                message.info = reader.string();
                                break;
                            case 6:
                                message.unique_id = reader.bytes();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes an Event message from the specified reader or buffer, length delimited.
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {cockroach.server.serverpb.EventsResponse.Event} Event
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Event.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies an Event message.
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {?string} `null` if valid, otherwise the reason why it is not
                     */
                    Event.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.timestamp != null && message.hasOwnProperty("timestamp")) {
                            let error = $root.google.protobuf.Timestamp.verify(message.timestamp);
                            if (error)
                                return "timestamp." + error;
                        }
                        if (message.event_type != null && message.hasOwnProperty("event_type"))
                            if (!$util.isString(message.event_type))
                                return "event_type: string expected";
                        if (message.target_id != null && message.hasOwnProperty("target_id"))
                            if (!$util.isInteger(message.target_id) && !(message.target_id && $util.isInteger(message.target_id.low) && $util.isInteger(message.target_id.high)))
                                return "target_id: integer|Long expected";
                        if (message.reporting_id != null && message.hasOwnProperty("reporting_id"))
                            if (!$util.isInteger(message.reporting_id) && !(message.reporting_id && $util.isInteger(message.reporting_id.low) && $util.isInteger(message.reporting_id.high)))
                                return "reporting_id: integer|Long expected";
                        if (message.info != null && message.hasOwnProperty("info"))
                            if (!$util.isString(message.info))
                                return "info: string expected";
                        if (message.unique_id != null && message.hasOwnProperty("unique_id"))
                            if (!(message.unique_id && typeof message.unique_id.length === "number" || $util.isString(message.unique_id)))
                                return "unique_id: buffer expected";
                        return null;
                    };

                    /**
                     * Creates an Event message from a plain object. Also converts values to their respective internal types.
                     * @param {Object.<string,*>} object Plain object
                     * @returns {cockroach.server.serverpb.EventsResponse.Event} Event
                     */
                    Event.fromObject = function fromObject(object) {
                        if (object instanceof $root.cockroach.server.serverpb.EventsResponse.Event)
                            return object;
                        let message = new $root.cockroach.server.serverpb.EventsResponse.Event();
                        if (object.timestamp != null) {
                            if (typeof object.timestamp !== "object")
                                throw TypeError(".cockroach.server.serverpb.EventsResponse.Event.timestamp: object expected");
                            message.timestamp = $root.google.protobuf.Timestamp.fromObject(object.timestamp);
                        }
                        if (object.event_type != null)
                            message.event_type = String(object.event_type);
                        if (object.target_id != null)
                            if ($util.Long)
                                (message.target_id = $util.Long.fromValue(object.target_id)).unsigned = false;
                            else if (typeof object.target_id === "string")
                                message.target_id = parseInt(object.target_id, 10);
                            else if (typeof object.target_id === "number")
                                message.target_id = object.target_id;
                            else if (typeof object.target_id === "object")
                                message.target_id = new $util.LongBits(object.target_id.low >>> 0, object.target_id.high >>> 0).toNumber();
                        if (object.reporting_id != null)
                            if ($util.Long)
                                (message.reporting_id = $util.Long.fromValue(object.reporting_id)).unsigned = false;
                            else if (typeof object.reporting_id === "string")
                                message.reporting_id = parseInt(object.reporting_id, 10);
                            else if (typeof object.reporting_id === "number")
                                message.reporting_id = object.reporting_id;
                            else if (typeof object.reporting_id === "object")
                                message.reporting_id = new $util.LongBits(object.reporting_id.low >>> 0, object.reporting_id.high >>> 0).toNumber();
                        if (object.info != null)
                            message.info = String(object.info);
                        if (object.unique_id != null)
                            if (typeof object.unique_id === "string")
                                $util.base64.decode(object.unique_id, message.unique_id = $util.newBuffer($util.base64.length(object.unique_id)), 0);
                            else if (object.unique_id.length)
                                message.unique_id = object.unique_id;
                        return message;
                    };

                    /**
                     * Creates an Event message from a plain object. Also converts values to their respective internal types.
                     * This is an alias of {@link cockroach.server.serverpb.EventsResponse.Event.fromObject}.
                     * @function
                     * @param {Object.<string,*>} object Plain object
                     * @returns {cockroach.server.serverpb.EventsResponse.Event} Event
                     */
                    Event.from = Event.fromObject;

                    /**
                     * Creates a plain object from an Event message. Also converts values to other types if specified.
                     * @param {cockroach.server.serverpb.EventsResponse.Event} message Event
                     * @param {$protobuf.ConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Event.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.defaults) {
                            object.timestamp = null;
                            object.event_type = "";
                            if ($util.Long) {
                                let long = new $util.Long(0, 0, false);
                                object.target_id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.target_id = options.longs === String ? "0" : 0;
                            if ($util.Long) {
                                let long = new $util.Long(0, 0, false);
                                object.reporting_id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.reporting_id = options.longs === String ? "0" : 0;
                            object.info = "";
                            object.unique_id = options.bytes === String ? "" : [];
                        }
                        if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                            object.timestamp = $root.google.protobuf.Timestamp.toObject(message.timestamp, options);
                        if (message.event_type != null && message.hasOwnProperty("event_type"))
                            object.event_type = message.event_type;
                        if (message.target_id != null && message.hasOwnProperty("target_id"))
                            if (typeof message.target_id === "number")
                                object.target_id = options.longs === String ? String(message.target_id) : message.target_id;
                            else
                                object.target_id = options.longs === String ? $util.Long.prototype.toString.call(message.target_id) : options.longs === Number ? new $util.LongBits(message.target_id.low >>> 0, message.target_id.high >>> 0).toNumber() : message.target_id;
                        if (message.reporting_id != null && message.hasOwnProperty("reporting_id"))
                            if (typeof message.reporting_id === "number")
                                object.reporting_id = options.longs === String ? String(message.reporting_id) : message.reporting_id;
                            else
                                object.reporting_id = options.longs === String ? $util.Long.prototype.toString.call(message.reporting_id) : options.longs === Number ? new $util.LongBits(message.reporting_id.low >>> 0, message.reporting_id.high >>> 0).toNumber() : message.reporting_id;
                        if (message.info != null && message.hasOwnProperty("info"))
                            object.info = message.info;
                        if (message.unique_id != null && message.hasOwnProperty("unique_id"))
                            object.unique_id = options.bytes === String ? $util.base64.encode(message.unique_id, 0, message.unique_id.length) : options.bytes === Array ? Array.prototype.slice.call(message.unique_id) : message.unique_id;
                        return object;
                    };

                    /**
                     * Creates a plain object from this Event message. Also converts values to other types if specified.
                     * @param {$protobuf.ConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Event.prototype.toObject = function toObject(options) {
                        return this.constructor.toObject(this, options);
                    };

                    /**
                     * Converts this Event to JSON.
                     * @returns {Object.<string,*>} JSON object
                     */
                    Event.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return Event;
                })();

                return EventsResponse;
            })();

            serverpb.SetUIDataRequest = (function() {

                /**
                 * Properties of a SetUIDataRequest.
                 * @typedef cockroach.server.serverpb.SetUIDataRequest$Properties
                 * @type {Object}
                 * @property {Object.<string,Uint8Array>} [key_values] SetUIDataRequest key_values.
                 */

                /**
                 * Constructs a new SetUIDataRequest.
                 * @exports cockroach.server.serverpb.SetUIDataRequest
                 * @constructor
                 * @param {cockroach.server.serverpb.SetUIDataRequest$Properties=} [properties] Properties to set
                 */
                function SetUIDataRequest(properties) {
                    this.key_values = {};
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * SetUIDataRequest key_values.
                 * @type {Object.<string,Uint8Array>}
                 */
                SetUIDataRequest.prototype.key_values = $util.emptyObject;

                /**
                 * Creates a new SetUIDataRequest instance using the specified properties.
                 * @param {cockroach.server.serverpb.SetUIDataRequest$Properties=} [properties] Properties to set
                 * @returns {cockroach.server.serverpb.SetUIDataRequest} SetUIDataRequest instance
                 */
                SetUIDataRequest.create = function create(properties) {
                    return new SetUIDataRequest(properties);
                };

                /**
                 * Encodes the specified SetUIDataRequest message. Does not implicitly {@link cockroach.server.serverpb.SetUIDataRequest.verify|verify} messages.
                 * @param {cockroach.server.serverpb.SetUIDataRequest$Properties} message SetUIDataRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                SetUIDataRequest.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.key_values != null && message.hasOwnProperty("key_values"))
                        for (let keys = Object.keys(message.key_values), i = 0; i < keys.length; ++i)
                            writer.uint32(/* id 1, wireType 2 =*/10).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]).uint32(/* id 2, wireType 2 =*/18).bytes(message.key_values[keys[i]]).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified SetUIDataRequest message, length delimited. Does not implicitly {@link cockroach.server.serverpb.SetUIDataRequest.verify|verify} messages.
                 * @param {cockroach.server.serverpb.SetUIDataRequest$Properties} message SetUIDataRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                SetUIDataRequest.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a SetUIDataRequest message from the specified reader or buffer.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {cockroach.server.serverpb.SetUIDataRequest} SetUIDataRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                SetUIDataRequest.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.cockroach.server.serverpb.SetUIDataRequest(), key;
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            reader.skip().pos++;
                            if (message.key_values === $util.emptyObject)
                                message.key_values = {};
                            key = reader.string();
                            reader.pos++;
                            message.key_values[key] = reader.bytes();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a SetUIDataRequest message from the specified reader or buffer, length delimited.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {cockroach.server.serverpb.SetUIDataRequest} SetUIDataRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                SetUIDataRequest.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a SetUIDataRequest message.
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {?string} `null` if valid, otherwise the reason why it is not
                 */
                SetUIDataRequest.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.key_values != null && message.hasOwnProperty("key_values")) {
                        if (!$util.isObject(message.key_values))
                            return "key_values: object expected";
                        let key = Object.keys(message.key_values);
                        for (let i = 0; i < key.length; ++i)
                            if (!(message.key_values[key[i]] && typeof message.key_values[key[i]].length === "number" || $util.isString(message.key_values[key[i]])))
                                return "key_values: buffer{k:string} expected";
                    }
                    return null;
                };

                /**
                 * Creates a SetUIDataRequest message from a plain object. Also converts values to their respective internal types.
                 * @param {Object.<string,*>} object Plain object
                 * @returns {cockroach.server.serverpb.SetUIDataRequest} SetUIDataRequest
                 */
                SetUIDataRequest.fromObject = function fromObject(object) {
                    if (object instanceof $root.cockroach.server.serverpb.SetUIDataRequest)
                        return object;
                    let message = new $root.cockroach.server.serverpb.SetUIDataRequest();
                    if (object.key_values) {
                        if (typeof object.key_values !== "object")
                            throw TypeError(".cockroach.server.serverpb.SetUIDataRequest.key_values: object expected");
                        message.key_values = {};
                        for (let keys = Object.keys(object.key_values), i = 0; i < keys.length; ++i)
                            if (typeof object.key_values[keys[i]] === "string")
                                $util.base64.decode(object.key_values[keys[i]], message.key_values[keys[i]] = $util.newBuffer($util.base64.length(object.key_values[keys[i]])), 0);
                            else if (object.key_values[keys[i]].length)
                                message.key_values[keys[i]] = object.key_values[keys[i]];
                    }
                    return message;
                };

                /**
                 * Creates a SetUIDataRequest message from a plain object. Also converts values to their respective internal types.
                 * This is an alias of {@link cockroach.server.serverpb.SetUIDataRequest.fromObject}.
                 * @function
                 * @param {Object.<string,*>} object Plain object
                 * @returns {cockroach.server.serverpb.SetUIDataRequest} SetUIDataRequest
                 */
                SetUIDataRequest.from = SetUIDataRequest.fromObject;

                /**
                 * Creates a plain object from a SetUIDataRequest message. Also converts values to other types if specified.
                 * @param {cockroach.server.serverpb.SetUIDataRequest} message SetUIDataRequest
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                SetUIDataRequest.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.objects || options.defaults)
                        object.key_values = {};
                    let keys2;
                    if (message.key_values && (keys2 = Object.keys(message.key_values)).length) {
                        object.key_values = {};
                        for (let j = 0; j < keys2.length; ++j)
                            object.key_values[keys2[j]] = options.bytes === String ? $util.base64.encode(message.key_values[keys2[j]], 0, message.key_values[keys2[j]].length) : options.bytes === Array ? Array.prototype.slice.call(message.key_values[keys2[j]]) : message.key_values[keys2[j]];
                    }
                    return object;
                };

                /**
                 * Creates a plain object from this SetUIDataRequest message. Also converts values to other types if specified.
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                SetUIDataRequest.prototype.toObject = function toObject(options) {
                    return this.constructor.toObject(this, options);
                };

                /**
                 * Converts this SetUIDataRequest to JSON.
                 * @returns {Object.<string,*>} JSON object
                 */
                SetUIDataRequest.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return SetUIDataRequest;
            })();

            serverpb.SetUIDataResponse = (function() {

                /**
                 * Properties of a SetUIDataResponse.
                 * @typedef cockroach.server.serverpb.SetUIDataResponse$Properties
                 * @type {Object}
                 */

                /**
                 * Constructs a new SetUIDataResponse.
                 * @exports cockroach.server.serverpb.SetUIDataResponse
                 * @constructor
                 * @param {cockroach.server.serverpb.SetUIDataResponse$Properties=} [properties] Properties to set
                 */
                function SetUIDataResponse(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Creates a new SetUIDataResponse instance using the specified properties.
                 * @param {cockroach.server.serverpb.SetUIDataResponse$Properties=} [properties] Properties to set
                 * @returns {cockroach.server.serverpb.SetUIDataResponse} SetUIDataResponse instance
                 */
                SetUIDataResponse.create = function create(properties) {
                    return new SetUIDataResponse(properties);
                };

                /**
                 * Encodes the specified SetUIDataResponse message. Does not implicitly {@link cockroach.server.serverpb.SetUIDataResponse.verify|verify} messages.
                 * @param {cockroach.server.serverpb.SetUIDataResponse$Properties} message SetUIDataResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                SetUIDataResponse.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    return writer;
                };

                /**
                 * Encodes the specified SetUIDataResponse message, length delimited. Does not implicitly {@link cockroach.server.serverpb.SetUIDataResponse.verify|verify} messages.
                 * @param {cockroach.server.serverpb.SetUIDataResponse$Properties} message SetUIDataResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                SetUIDataResponse.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a SetUIDataResponse message from the specified reader or buffer.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {cockroach.server.serverpb.SetUIDataResponse} SetUIDataResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                SetUIDataResponse.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.cockroach.server.serverpb.SetUIDataResponse();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a SetUIDataResponse message from the specified reader or buffer, length delimited.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {cockroach.server.serverpb.SetUIDataResponse} SetUIDataResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                SetUIDataResponse.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a SetUIDataResponse message.
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {?string} `null` if valid, otherwise the reason why it is not
                 */
                SetUIDataResponse.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    return null;
                };

                /**
                 * Creates a SetUIDataResponse message from a plain object. Also converts values to their respective internal types.
                 * @param {Object.<string,*>} object Plain object
                 * @returns {cockroach.server.serverpb.SetUIDataResponse} SetUIDataResponse
                 */
                SetUIDataResponse.fromObject = function fromObject(object) {
                    if (object instanceof $root.cockroach.server.serverpb.SetUIDataResponse)
                        return object;
                    return new $root.cockroach.server.serverpb.SetUIDataResponse();
                };

                /**
                 * Creates a SetUIDataResponse message from a plain object. Also converts values to their respective internal types.
                 * This is an alias of {@link cockroach.server.serverpb.SetUIDataResponse.fromObject}.
                 * @function
                 * @param {Object.<string,*>} object Plain object
                 * @returns {cockroach.server.serverpb.SetUIDataResponse} SetUIDataResponse
                 */
                SetUIDataResponse.from = SetUIDataResponse.fromObject;

                /**
                 * Creates a plain object from a SetUIDataResponse message. Also converts values to other types if specified.
                 * @param {cockroach.server.serverpb.SetUIDataResponse} message SetUIDataResponse
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                SetUIDataResponse.toObject = function toObject() {
                    return {};
                };

                /**
                 * Creates a plain object from this SetUIDataResponse message. Also converts values to other types if specified.
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                SetUIDataResponse.prototype.toObject = function toObject(options) {
                    return this.constructor.toObject(this, options);
                };

                /**
                 * Converts this SetUIDataResponse to JSON.
                 * @returns {Object.<string,*>} JSON object
                 */
                SetUIDataResponse.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return SetUIDataResponse;
            })();

            serverpb.GetUIDataRequest = (function() {

                /**
                 * Properties of a GetUIDataRequest.
                 * @typedef cockroach.server.serverpb.GetUIDataRequest$Properties
                 * @type {Object}
                 * @property {Array.<string>} [keys] GetUIDataRequest keys.
                 */

                /**
                 * Constructs a new GetUIDataRequest.
                 * @exports cockroach.server.serverpb.GetUIDataRequest
                 * @constructor
                 * @param {cockroach.server.serverpb.GetUIDataRequest$Properties=} [properties] Properties to set
                 */
                function GetUIDataRequest(properties) {
                    this.keys = [];
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * GetUIDataRequest keys.
                 * @type {Array.<string>}
                 */
                GetUIDataRequest.prototype.keys = $util.emptyArray;

                /**
                 * Creates a new GetUIDataRequest instance using the specified properties.
                 * @param {cockroach.server.serverpb.GetUIDataRequest$Properties=} [properties] Properties to set
                 * @returns {cockroach.server.serverpb.GetUIDataRequest} GetUIDataRequest instance
                 */
                GetUIDataRequest.create = function create(properties) {
                    return new GetUIDataRequest(properties);
                };

                /**
                 * Encodes the specified GetUIDataRequest message. Does not implicitly {@link cockroach.server.serverpb.GetUIDataRequest.verify|verify} messages.
                 * @param {cockroach.server.serverpb.GetUIDataRequest$Properties} message GetUIDataRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                GetUIDataRequest.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.keys != null && message.keys.length)
                        for (let i = 0; i < message.keys.length; ++i)
                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.keys[i]);
                    return writer;
                };

                /**
                 * Encodes the specified GetUIDataRequest message, length delimited. Does not implicitly {@link cockroach.server.serverpb.GetUIDataRequest.verify|verify} messages.
                 * @param {cockroach.server.serverpb.GetUIDataRequest$Properties} message GetUIDataRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                GetUIDataRequest.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a GetUIDataRequest message from the specified reader or buffer.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {cockroach.server.serverpb.GetUIDataRequest} GetUIDataRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                GetUIDataRequest.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.cockroach.server.serverpb.GetUIDataRequest();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (!(message.keys && message.keys.length))
                                message.keys = [];
                            message.keys.push(reader.string());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a GetUIDataRequest message from the specified reader or buffer, length delimited.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {cockroach.server.serverpb.GetUIDataRequest} GetUIDataRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                GetUIDataRequest.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a GetUIDataRequest message.
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {?string} `null` if valid, otherwise the reason why it is not
                 */
                GetUIDataRequest.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.keys != null && message.hasOwnProperty("keys")) {
                        if (!Array.isArray(message.keys))
                            return "keys: array expected";
                        for (let i = 0; i < message.keys.length; ++i)
                            if (!$util.isString(message.keys[i]))
                                return "keys: string[] expected";
                    }
                    return null;
                };

                /**
                 * Creates a GetUIDataRequest message from a plain object. Also converts values to their respective internal types.
                 * @param {Object.<string,*>} object Plain object
                 * @returns {cockroach.server.serverpb.GetUIDataRequest} GetUIDataRequest
                 */
                GetUIDataRequest.fromObject = function fromObject(object) {
                    if (object instanceof $root.cockroach.server.serverpb.GetUIDataRequest)
                        return object;
                    let message = new $root.cockroach.server.serverpb.GetUIDataRequest();
                    if (object.keys) {
                        if (!Array.isArray(object.keys))
                            throw TypeError(".cockroach.server.serverpb.GetUIDataRequest.keys: array expected");
                        message.keys = [];
                        for (let i = 0; i < object.keys.length; ++i)
                            message.keys[i] = String(object.keys[i]);
                    }
                    return message;
                };

                /**
                 * Creates a GetUIDataRequest message from a plain object. Also converts values to their respective internal types.
                 * This is an alias of {@link cockroach.server.serverpb.GetUIDataRequest.fromObject}.
                 * @function
                 * @param {Object.<string,*>} object Plain object
                 * @returns {cockroach.server.serverpb.GetUIDataRequest} GetUIDataRequest
                 */
                GetUIDataRequest.from = GetUIDataRequest.fromObject;

                /**
                 * Creates a plain object from a GetUIDataRequest message. Also converts values to other types if specified.
                 * @param {cockroach.server.serverpb.GetUIDataRequest} message GetUIDataRequest
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                GetUIDataRequest.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.arrays || options.defaults)
                        object.keys = [];
                    if (message.keys && message.keys.length) {
                        object.keys = [];
                        for (let j = 0; j < message.keys.length; ++j)
                            object.keys[j] = message.keys[j];
                    }
                    return object;
                };

                /**
                 * Creates a plain object from this GetUIDataRequest message. Also converts values to other types if specified.
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                GetUIDataRequest.prototype.toObject = function toObject(options) {
                    return this.constructor.toObject(this, options);
                };

                /**
                 * Converts this GetUIDataRequest to JSON.
                 * @returns {Object.<string,*>} JSON object
                 */
                GetUIDataRequest.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return GetUIDataRequest;
            })();

            serverpb.GetUIDataResponse = (function() {

                /**
                 * Properties of a GetUIDataResponse.
                 * @typedef cockroach.server.serverpb.GetUIDataResponse$Properties
                 * @type {Object}
                 * @property {Object.<string,cockroach.server.serverpb.GetUIDataResponse.Value$Properties>} [key_values] GetUIDataResponse key_values.
                 */

                /**
                 * Constructs a new GetUIDataResponse.
                 * @exports cockroach.server.serverpb.GetUIDataResponse
                 * @constructor
                 * @param {cockroach.server.serverpb.GetUIDataResponse$Properties=} [properties] Properties to set
                 */
                function GetUIDataResponse(properties) {
                    this.key_values = {};
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * GetUIDataResponse key_values.
                 * @type {Object.<string,cockroach.server.serverpb.GetUIDataResponse.Value$Properties>}
                 */
                GetUIDataResponse.prototype.key_values = $util.emptyObject;

                /**
                 * Creates a new GetUIDataResponse instance using the specified properties.
                 * @param {cockroach.server.serverpb.GetUIDataResponse$Properties=} [properties] Properties to set
                 * @returns {cockroach.server.serverpb.GetUIDataResponse} GetUIDataResponse instance
                 */
                GetUIDataResponse.create = function create(properties) {
                    return new GetUIDataResponse(properties);
                };

                /**
                 * Encodes the specified GetUIDataResponse message. Does not implicitly {@link cockroach.server.serverpb.GetUIDataResponse.verify|verify} messages.
                 * @param {cockroach.server.serverpb.GetUIDataResponse$Properties} message GetUIDataResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                GetUIDataResponse.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.key_values != null && message.hasOwnProperty("key_values"))
                        for (let keys = Object.keys(message.key_values), i = 0; i < keys.length; ++i) {
                            writer.uint32(/* id 1, wireType 2 =*/10).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]);
                            $root.cockroach.server.serverpb.GetUIDataResponse.Value.encode(message.key_values[keys[i]], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim().ldelim();
                        }
                    return writer;
                };

                /**
                 * Encodes the specified GetUIDataResponse message, length delimited. Does not implicitly {@link cockroach.server.serverpb.GetUIDataResponse.verify|verify} messages.
                 * @param {cockroach.server.serverpb.GetUIDataResponse$Properties} message GetUIDataResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                GetUIDataResponse.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a GetUIDataResponse message from the specified reader or buffer.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {cockroach.server.serverpb.GetUIDataResponse} GetUIDataResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                GetUIDataResponse.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.cockroach.server.serverpb.GetUIDataResponse(), key;
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            reader.skip().pos++;
                            if (message.key_values === $util.emptyObject)
                                message.key_values = {};
                            key = reader.string();
                            reader.pos++;
                            message.key_values[key] = $root.cockroach.server.serverpb.GetUIDataResponse.Value.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a GetUIDataResponse message from the specified reader or buffer, length delimited.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {cockroach.server.serverpb.GetUIDataResponse} GetUIDataResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                GetUIDataResponse.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a GetUIDataResponse message.
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {?string} `null` if valid, otherwise the reason why it is not
                 */
                GetUIDataResponse.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.key_values != null && message.hasOwnProperty("key_values")) {
                        if (!$util.isObject(message.key_values))
                            return "key_values: object expected";
                        let key = Object.keys(message.key_values);
                        for (let i = 0; i < key.length; ++i) {
                            let error = $root.cockroach.server.serverpb.GetUIDataResponse.Value.verify(message.key_values[key[i]]);
                            if (error)
                                return "key_values." + error;
                        }
                    }
                    return null;
                };

                /**
                 * Creates a GetUIDataResponse message from a plain object. Also converts values to their respective internal types.
                 * @param {Object.<string,*>} object Plain object
                 * @returns {cockroach.server.serverpb.GetUIDataResponse} GetUIDataResponse
                 */
                GetUIDataResponse.fromObject = function fromObject(object) {
                    if (object instanceof $root.cockroach.server.serverpb.GetUIDataResponse)
                        return object;
                    let message = new $root.cockroach.server.serverpb.GetUIDataResponse();
                    if (object.key_values) {
                        if (typeof object.key_values !== "object")
                            throw TypeError(".cockroach.server.serverpb.GetUIDataResponse.key_values: object expected");
                        message.key_values = {};
                        for (let keys = Object.keys(object.key_values), i = 0; i < keys.length; ++i) {
                            if (typeof object.key_values[keys[i]] !== "object")
                                throw TypeError(".cockroach.server.serverpb.GetUIDataResponse.key_values: object expected");
                            message.key_values[keys[i]] = $root.cockroach.server.serverpb.GetUIDataResponse.Value.fromObject(object.key_values[keys[i]]);
                        }
                    }
                    return message;
                };

                /**
                 * Creates a GetUIDataResponse message from a plain object. Also converts values to their respective internal types.
                 * This is an alias of {@link cockroach.server.serverpb.GetUIDataResponse.fromObject}.
                 * @function
                 * @param {Object.<string,*>} object Plain object
                 * @returns {cockroach.server.serverpb.GetUIDataResponse} GetUIDataResponse
                 */
                GetUIDataResponse.from = GetUIDataResponse.fromObject;

                /**
                 * Creates a plain object from a GetUIDataResponse message. Also converts values to other types if specified.
                 * @param {cockroach.server.serverpb.GetUIDataResponse} message GetUIDataResponse
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                GetUIDataResponse.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.objects || options.defaults)
                        object.key_values = {};
                    let keys2;
                    if (message.key_values && (keys2 = Object.keys(message.key_values)).length) {
                        object.key_values = {};
                        for (let j = 0; j < keys2.length; ++j)
                            object.key_values[keys2[j]] = $root.cockroach.server.serverpb.GetUIDataResponse.Value.toObject(message.key_values[keys2[j]], options);
                    }
                    return object;
                };

                /**
                 * Creates a plain object from this GetUIDataResponse message. Also converts values to other types if specified.
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                GetUIDataResponse.prototype.toObject = function toObject(options) {
                    return this.constructor.toObject(this, options);
                };

                /**
                 * Converts this GetUIDataResponse to JSON.
                 * @returns {Object.<string,*>} JSON object
                 */
                GetUIDataResponse.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                GetUIDataResponse.Value = (function() {

                    /**
                     * Properties of a Value.
                     * @typedef cockroach.server.serverpb.GetUIDataResponse.Value$Properties
                     * @type {Object}
                     * @property {Uint8Array} [value] Value value.
                     * @property {google.protobuf.Timestamp$Properties} [last_updated] Value last_updated.
                     */

                    /**
                     * Constructs a new Value.
                     * @exports cockroach.server.serverpb.GetUIDataResponse.Value
                     * @constructor
                     * @param {cockroach.server.serverpb.GetUIDataResponse.Value$Properties=} [properties] Properties to set
                     */
                    function Value(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * Value value.
                     * @type {Uint8Array}
                     */
                    Value.prototype.value = $util.newBuffer([]);

                    /**
                     * Value last_updated.
                     * @type {(google.protobuf.Timestamp$Properties|null)}
                     */
                    Value.prototype.last_updated = null;

                    /**
                     * Creates a new Value instance using the specified properties.
                     * @param {cockroach.server.serverpb.GetUIDataResponse.Value$Properties=} [properties] Properties to set
                     * @returns {cockroach.server.serverpb.GetUIDataResponse.Value} Value instance
                     */
                    Value.create = function create(properties) {
                        return new Value(properties);
                    };

                    /**
                     * Encodes the specified Value message. Does not implicitly {@link cockroach.server.serverpb.GetUIDataResponse.Value.verify|verify} messages.
                     * @param {cockroach.server.serverpb.GetUIDataResponse.Value$Properties} message Value message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Value.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.value != null && message.hasOwnProperty("value"))
                            writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.value);
                        if (message.last_updated != null && message.hasOwnProperty("last_updated"))
                            $root.google.protobuf.Timestamp.encode(message.last_updated, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                        return writer;
                    };

                    /**
                     * Encodes the specified Value message, length delimited. Does not implicitly {@link cockroach.server.serverpb.GetUIDataResponse.Value.verify|verify} messages.
                     * @param {cockroach.server.serverpb.GetUIDataResponse.Value$Properties} message Value message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Value.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a Value message from the specified reader or buffer.
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {cockroach.server.serverpb.GetUIDataResponse.Value} Value
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Value.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.cockroach.server.serverpb.GetUIDataResponse.Value();
                        while (reader.pos < end) {
                            let tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.value = reader.bytes();
                                break;
                            case 2:
                                message.last_updated = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a Value message from the specified reader or buffer, length delimited.
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {cockroach.server.serverpb.GetUIDataResponse.Value} Value
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Value.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a Value message.
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {?string} `null` if valid, otherwise the reason why it is not
                     */
                    Value.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.value != null && message.hasOwnProperty("value"))
                            if (!(message.value && typeof message.value.length === "number" || $util.isString(message.value)))
                                return "value: buffer expected";
                        if (message.last_updated != null && message.hasOwnProperty("last_updated")) {
                            let error = $root.google.protobuf.Timestamp.verify(message.last_updated);
                            if (error)
                                return "last_updated." + error;
                        }
                        return null;
                    };

                    /**
                     * Creates a Value message from a plain object. Also converts values to their respective internal types.
                     * @param {Object.<string,*>} object Plain object
                     * @returns {cockroach.server.serverpb.GetUIDataResponse.Value} Value
                     */
                    Value.fromObject = function fromObject(object) {
                        if (object instanceof $root.cockroach.server.serverpb.GetUIDataResponse.Value)
                            return object;
                        let message = new $root.cockroach.server.serverpb.GetUIDataResponse.Value();
                        if (object.value != null)
                            if (typeof object.value === "string")
                                $util.base64.decode(object.value, message.value = $util.newBuffer($util.base64.length(object.value)), 0);
                            else if (object.value.length)
                                message.value = object.value;
                        if (object.last_updated != null) {
                            if (typeof object.last_updated !== "object")
                                throw TypeError(".cockroach.server.serverpb.GetUIDataResponse.Value.last_updated: object expected");
                            message.last_updated = $root.google.protobuf.Timestamp.fromObject(object.last_updated);
                        }
                        return message;
                    };

                    /**
                     * Creates a Value message from a plain object. Also converts values to their respective internal types.
                     * This is an alias of {@link cockroach.server.serverpb.GetUIDataResponse.Value.fromObject}.
                     * @function
                     * @param {Object.<string,*>} object Plain object
                     * @returns {cockroach.server.serverpb.GetUIDataResponse.Value} Value
                     */
                    Value.from = Value.fromObject;

                    /**
                     * Creates a plain object from a Value message. Also converts values to other types if specified.
                     * @param {cockroach.server.serverpb.GetUIDataResponse.Value} message Value
                     * @param {$protobuf.ConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Value.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.defaults) {
                            object.value = options.bytes === String ? "" : [];
                            object.last_updated = null;
                        }
                        if (message.value != null && message.hasOwnProperty("value"))
                            object.value = options.bytes === String ? $util.base64.encode(message.value, 0, message.value.length) : options.bytes === Array ? Array.prototype.slice.call(message.value) : message.value;
                        if (message.last_updated != null && message.hasOwnProperty("last_updated"))
                            object.last_updated = $root.google.protobuf.Timestamp.toObject(message.last_updated, options);
                        return object;
                    };

                    /**
                     * Creates a plain object from this Value message. Also converts values to other types if specified.
                     * @param {$protobuf.ConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Value.prototype.toObject = function toObject(options) {
                        return this.constructor.toObject(this, options);
                    };

                    /**
                     * Converts this Value to JSON.
                     * @returns {Object.<string,*>} JSON object
                     */
                    Value.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return Value;
                })();

                return GetUIDataResponse;
            })();

            serverpb.ClusterRequest = (function() {

                /**
                 * Properties of a ClusterRequest.
                 * @typedef cockroach.server.serverpb.ClusterRequest$Properties
                 * @type {Object}
                 */

                /**
                 * Constructs a new ClusterRequest.
                 * @exports cockroach.server.serverpb.ClusterRequest
                 * @constructor
                 * @param {cockroach.server.serverpb.ClusterRequest$Properties=} [properties] Properties to set
                 */
                function ClusterRequest(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Creates a new ClusterRequest instance using the specified properties.
                 * @param {cockroach.server.serverpb.ClusterRequest$Properties=} [properties] Properties to set
                 * @returns {cockroach.server.serverpb.ClusterRequest} ClusterRequest instance
                 */
                ClusterRequest.create = function create(properties) {
                    return new ClusterRequest(properties);
                };

                /**
                 * Encodes the specified ClusterRequest message. Does not implicitly {@link cockroach.server.serverpb.ClusterRequest.verify|verify} messages.
                 * @param {cockroach.server.serverpb.ClusterRequest$Properties} message ClusterRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ClusterRequest.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    return writer;
                };

                /**
                 * Encodes the specified ClusterRequest message, length delimited. Does not implicitly {@link cockroach.server.serverpb.ClusterRequest.verify|verify} messages.
                 * @param {cockroach.server.serverpb.ClusterRequest$Properties} message ClusterRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ClusterRequest.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a ClusterRequest message from the specified reader or buffer.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {cockroach.server.serverpb.ClusterRequest} ClusterRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ClusterRequest.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.cockroach.server.serverpb.ClusterRequest();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a ClusterRequest message from the specified reader or buffer, length delimited.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {cockroach.server.serverpb.ClusterRequest} ClusterRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ClusterRequest.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a ClusterRequest message.
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {?string} `null` if valid, otherwise the reason why it is not
                 */
                ClusterRequest.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    return null;
                };

                /**
                 * Creates a ClusterRequest message from a plain object. Also converts values to their respective internal types.
                 * @param {Object.<string,*>} object Plain object
                 * @returns {cockroach.server.serverpb.ClusterRequest} ClusterRequest
                 */
                ClusterRequest.fromObject = function fromObject(object) {
                    if (object instanceof $root.cockroach.server.serverpb.ClusterRequest)
                        return object;
                    return new $root.cockroach.server.serverpb.ClusterRequest();
                };

                /**
                 * Creates a ClusterRequest message from a plain object. Also converts values to their respective internal types.
                 * This is an alias of {@link cockroach.server.serverpb.ClusterRequest.fromObject}.
                 * @function
                 * @param {Object.<string,*>} object Plain object
                 * @returns {cockroach.server.serverpb.ClusterRequest} ClusterRequest
                 */
                ClusterRequest.from = ClusterRequest.fromObject;

                /**
                 * Creates a plain object from a ClusterRequest message. Also converts values to other types if specified.
                 * @param {cockroach.server.serverpb.ClusterRequest} message ClusterRequest
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ClusterRequest.toObject = function toObject() {
                    return {};
                };

                /**
                 * Creates a plain object from this ClusterRequest message. Also converts values to other types if specified.
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ClusterRequest.prototype.toObject = function toObject(options) {
                    return this.constructor.toObject(this, options);
                };

                /**
                 * Converts this ClusterRequest to JSON.
                 * @returns {Object.<string,*>} JSON object
                 */
                ClusterRequest.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return ClusterRequest;
            })();

            serverpb.ClusterResponse = (function() {

                /**
                 * Properties of a ClusterResponse.
                 * @typedef cockroach.server.serverpb.ClusterResponse$Properties
                 * @type {Object}
                 * @property {string} [cluster_id] ClusterResponse cluster_id.
                 */

                /**
                 * Constructs a new ClusterResponse.
                 * @exports cockroach.server.serverpb.ClusterResponse
                 * @constructor
                 * @param {cockroach.server.serverpb.ClusterResponse$Properties=} [properties] Properties to set
                 */
                function ClusterResponse(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * ClusterResponse cluster_id.
                 * @type {string}
                 */
                ClusterResponse.prototype.cluster_id = "";

                /**
                 * Creates a new ClusterResponse instance using the specified properties.
                 * @param {cockroach.server.serverpb.ClusterResponse$Properties=} [properties] Properties to set
                 * @returns {cockroach.server.serverpb.ClusterResponse} ClusterResponse instance
                 */
                ClusterResponse.create = function create(properties) {
                    return new ClusterResponse(properties);
                };

                /**
                 * Encodes the specified ClusterResponse message. Does not implicitly {@link cockroach.server.serverpb.ClusterResponse.verify|verify} messages.
                 * @param {cockroach.server.serverpb.ClusterResponse$Properties} message ClusterResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ClusterResponse.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.cluster_id != null && message.hasOwnProperty("cluster_id"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.cluster_id);
                    return writer;
                };

                /**
                 * Encodes the specified ClusterResponse message, length delimited. Does not implicitly {@link cockroach.server.serverpb.ClusterResponse.verify|verify} messages.
                 * @param {cockroach.server.serverpb.ClusterResponse$Properties} message ClusterResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ClusterResponse.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a ClusterResponse message from the specified reader or buffer.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {cockroach.server.serverpb.ClusterResponse} ClusterResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ClusterResponse.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.cockroach.server.serverpb.ClusterResponse();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.cluster_id = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a ClusterResponse message from the specified reader or buffer, length delimited.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {cockroach.server.serverpb.ClusterResponse} ClusterResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ClusterResponse.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a ClusterResponse message.
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {?string} `null` if valid, otherwise the reason why it is not
                 */
                ClusterResponse.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.cluster_id != null && message.hasOwnProperty("cluster_id"))
                        if (!$util.isString(message.cluster_id))
                            return "cluster_id: string expected";
                    return null;
                };

                /**
                 * Creates a ClusterResponse message from a plain object. Also converts values to their respective internal types.
                 * @param {Object.<string,*>} object Plain object
                 * @returns {cockroach.server.serverpb.ClusterResponse} ClusterResponse
                 */
                ClusterResponse.fromObject = function fromObject(object) {
                    if (object instanceof $root.cockroach.server.serverpb.ClusterResponse)
                        return object;
                    let message = new $root.cockroach.server.serverpb.ClusterResponse();
                    if (object.cluster_id != null)
                        message.cluster_id = String(object.cluster_id);
                    return message;
                };

                /**
                 * Creates a ClusterResponse message from a plain object. Also converts values to their respective internal types.
                 * This is an alias of {@link cockroach.server.serverpb.ClusterResponse.fromObject}.
                 * @function
                 * @param {Object.<string,*>} object Plain object
                 * @returns {cockroach.server.serverpb.ClusterResponse} ClusterResponse
                 */
                ClusterResponse.from = ClusterResponse.fromObject;

                /**
                 * Creates a plain object from a ClusterResponse message. Also converts values to other types if specified.
                 * @param {cockroach.server.serverpb.ClusterResponse} message ClusterResponse
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ClusterResponse.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults)
                        object.cluster_id = "";
                    if (message.cluster_id != null && message.hasOwnProperty("cluster_id"))
                        object.cluster_id = message.cluster_id;
                    return object;
                };

                /**
                 * Creates a plain object from this ClusterResponse message. Also converts values to other types if specified.
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ClusterResponse.prototype.toObject = function toObject(options) {
                    return this.constructor.toObject(this, options);
                };

                /**
                 * Converts this ClusterResponse to JSON.
                 * @returns {Object.<string,*>} JSON object
                 */
                ClusterResponse.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return ClusterResponse;
            })();

            /**
             * DrainMode enum.
             * @name DrainMode
             * @memberof cockroach.server.serverpb
             * @enum {number}
             * @property {number} CLIENT=0 CLIENT value
             * @property {number} LEASES=1 LEASES value
             */
            serverpb.DrainMode = (function() {
                const valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "CLIENT"] = 0;
                values[valuesById[1] = "LEASES"] = 1;
                return values;
            })();

            serverpb.DrainRequest = (function() {

                /**
                 * Properties of a DrainRequest.
                 * @typedef cockroach.server.serverpb.DrainRequest$Properties
                 * @type {Object}
                 * @property {Array.<number>} [on] DrainRequest on.
                 * @property {Array.<number>} [off] DrainRequest off.
                 * @property {boolean} [shutdown] DrainRequest shutdown.
                 */

                /**
                 * Constructs a new DrainRequest.
                 * @exports cockroach.server.serverpb.DrainRequest
                 * @constructor
                 * @param {cockroach.server.serverpb.DrainRequest$Properties=} [properties] Properties to set
                 */
                function DrainRequest(properties) {
                    this.on = [];
                    this.off = [];
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * DrainRequest on.
                 * @type {Array.<number>}
                 */
                DrainRequest.prototype.on = $util.emptyArray;

                /**
                 * DrainRequest off.
                 * @type {Array.<number>}
                 */
                DrainRequest.prototype.off = $util.emptyArray;

                /**
                 * DrainRequest shutdown.
                 * @type {boolean}
                 */
                DrainRequest.prototype.shutdown = false;

                /**
                 * Creates a new DrainRequest instance using the specified properties.
                 * @param {cockroach.server.serverpb.DrainRequest$Properties=} [properties] Properties to set
                 * @returns {cockroach.server.serverpb.DrainRequest} DrainRequest instance
                 */
                DrainRequest.create = function create(properties) {
                    return new DrainRequest(properties);
                };

                /**
                 * Encodes the specified DrainRequest message. Does not implicitly {@link cockroach.server.serverpb.DrainRequest.verify|verify} messages.
                 * @param {cockroach.server.serverpb.DrainRequest$Properties} message DrainRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                DrainRequest.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.on != null && message.on.length) {
                        writer.uint32(/* id 1, wireType 2 =*/10).fork();
                        for (let i = 0; i < message.on.length; ++i)
                            writer.int32(message.on[i]);
                        writer.ldelim();
                    }
                    if (message.off != null && message.off.length) {
                        writer.uint32(/* id 2, wireType 2 =*/18).fork();
                        for (let i = 0; i < message.off.length; ++i)
                            writer.int32(message.off[i]);
                        writer.ldelim();
                    }
                    if (message.shutdown != null && message.hasOwnProperty("shutdown"))
                        writer.uint32(/* id 3, wireType 0 =*/24).bool(message.shutdown);
                    return writer;
                };

                /**
                 * Encodes the specified DrainRequest message, length delimited. Does not implicitly {@link cockroach.server.serverpb.DrainRequest.verify|verify} messages.
                 * @param {cockroach.server.serverpb.DrainRequest$Properties} message DrainRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                DrainRequest.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a DrainRequest message from the specified reader or buffer.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {cockroach.server.serverpb.DrainRequest} DrainRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                DrainRequest.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.cockroach.server.serverpb.DrainRequest();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (!(message.on && message.on.length))
                                message.on = [];
                            if ((tag & 7) === 2) {
                                let end2 = reader.uint32() + reader.pos;
                                while (reader.pos < end2)
                                    message.on.push(reader.int32());
                            } else
                                message.on.push(reader.int32());
                            break;
                        case 2:
                            if (!(message.off && message.off.length))
                                message.off = [];
                            if ((tag & 7) === 2) {
                                let end2 = reader.uint32() + reader.pos;
                                while (reader.pos < end2)
                                    message.off.push(reader.int32());
                            } else
                                message.off.push(reader.int32());
                            break;
                        case 3:
                            message.shutdown = reader.bool();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a DrainRequest message from the specified reader or buffer, length delimited.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {cockroach.server.serverpb.DrainRequest} DrainRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                DrainRequest.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a DrainRequest message.
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {?string} `null` if valid, otherwise the reason why it is not
                 */
                DrainRequest.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.on != null && message.hasOwnProperty("on")) {
                        if (!Array.isArray(message.on))
                            return "on: array expected";
                        for (let i = 0; i < message.on.length; ++i)
                            if (!$util.isInteger(message.on[i]))
                                return "on: integer[] expected";
                    }
                    if (message.off != null && message.hasOwnProperty("off")) {
                        if (!Array.isArray(message.off))
                            return "off: array expected";
                        for (let i = 0; i < message.off.length; ++i)
                            if (!$util.isInteger(message.off[i]))
                                return "off: integer[] expected";
                    }
                    if (message.shutdown != null && message.hasOwnProperty("shutdown"))
                        if (typeof message.shutdown !== "boolean")
                            return "shutdown: boolean expected";
                    return null;
                };

                /**
                 * Creates a DrainRequest message from a plain object. Also converts values to their respective internal types.
                 * @param {Object.<string,*>} object Plain object
                 * @returns {cockroach.server.serverpb.DrainRequest} DrainRequest
                 */
                DrainRequest.fromObject = function fromObject(object) {
                    if (object instanceof $root.cockroach.server.serverpb.DrainRequest)
                        return object;
                    let message = new $root.cockroach.server.serverpb.DrainRequest();
                    if (object.on) {
                        if (!Array.isArray(object.on))
                            throw TypeError(".cockroach.server.serverpb.DrainRequest.on: array expected");
                        message.on = [];
                        for (let i = 0; i < object.on.length; ++i)
                            message.on[i] = object.on[i] | 0;
                    }
                    if (object.off) {
                        if (!Array.isArray(object.off))
                            throw TypeError(".cockroach.server.serverpb.DrainRequest.off: array expected");
                        message.off = [];
                        for (let i = 0; i < object.off.length; ++i)
                            message.off[i] = object.off[i] | 0;
                    }
                    if (object.shutdown != null)
                        message.shutdown = Boolean(object.shutdown);
                    return message;
                };

                /**
                 * Creates a DrainRequest message from a plain object. Also converts values to their respective internal types.
                 * This is an alias of {@link cockroach.server.serverpb.DrainRequest.fromObject}.
                 * @function
                 * @param {Object.<string,*>} object Plain object
                 * @returns {cockroach.server.serverpb.DrainRequest} DrainRequest
                 */
                DrainRequest.from = DrainRequest.fromObject;

                /**
                 * Creates a plain object from a DrainRequest message. Also converts values to other types if specified.
                 * @param {cockroach.server.serverpb.DrainRequest} message DrainRequest
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                DrainRequest.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.arrays || options.defaults) {
                        object.on = [];
                        object.off = [];
                    }
                    if (options.defaults)
                        object.shutdown = false;
                    if (message.on && message.on.length) {
                        object.on = [];
                        for (let j = 0; j < message.on.length; ++j)
                            object.on[j] = message.on[j];
                    }
                    if (message.off && message.off.length) {
                        object.off = [];
                        for (let j = 0; j < message.off.length; ++j)
                            object.off[j] = message.off[j];
                    }
                    if (message.shutdown != null && message.hasOwnProperty("shutdown"))
                        object.shutdown = message.shutdown;
                    return object;
                };

                /**
                 * Creates a plain object from this DrainRequest message. Also converts values to other types if specified.
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                DrainRequest.prototype.toObject = function toObject(options) {
                    return this.constructor.toObject(this, options);
                };

                /**
                 * Converts this DrainRequest to JSON.
                 * @returns {Object.<string,*>} JSON object
                 */
                DrainRequest.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return DrainRequest;
            })();

            serverpb.DrainResponse = (function() {

                /**
                 * Properties of a DrainResponse.
                 * @typedef cockroach.server.serverpb.DrainResponse$Properties
                 * @type {Object}
                 * @property {Array.<number>} [on] DrainResponse on.
                 */

                /**
                 * Constructs a new DrainResponse.
                 * @exports cockroach.server.serverpb.DrainResponse
                 * @constructor
                 * @param {cockroach.server.serverpb.DrainResponse$Properties=} [properties] Properties to set
                 */
                function DrainResponse(properties) {
                    this.on = [];
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * DrainResponse on.
                 * @type {Array.<number>}
                 */
                DrainResponse.prototype.on = $util.emptyArray;

                /**
                 * Creates a new DrainResponse instance using the specified properties.
                 * @param {cockroach.server.serverpb.DrainResponse$Properties=} [properties] Properties to set
                 * @returns {cockroach.server.serverpb.DrainResponse} DrainResponse instance
                 */
                DrainResponse.create = function create(properties) {
                    return new DrainResponse(properties);
                };

                /**
                 * Encodes the specified DrainResponse message. Does not implicitly {@link cockroach.server.serverpb.DrainResponse.verify|verify} messages.
                 * @param {cockroach.server.serverpb.DrainResponse$Properties} message DrainResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                DrainResponse.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.on != null && message.on.length) {
                        writer.uint32(/* id 1, wireType 2 =*/10).fork();
                        for (let i = 0; i < message.on.length; ++i)
                            writer.int32(message.on[i]);
                        writer.ldelim();
                    }
                    return writer;
                };

                /**
                 * Encodes the specified DrainResponse message, length delimited. Does not implicitly {@link cockroach.server.serverpb.DrainResponse.verify|verify} messages.
                 * @param {cockroach.server.serverpb.DrainResponse$Properties} message DrainResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                DrainResponse.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a DrainResponse message from the specified reader or buffer.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {cockroach.server.serverpb.DrainResponse} DrainResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                DrainResponse.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.cockroach.server.serverpb.DrainResponse();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (!(message.on && message.on.length))
                                message.on = [];
                            if ((tag & 7) === 2) {
                                let end2 = reader.uint32() + reader.pos;
                                while (reader.pos < end2)
                                    message.on.push(reader.int32());
                            } else
                                message.on.push(reader.int32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a DrainResponse message from the specified reader or buffer, length delimited.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {cockroach.server.serverpb.DrainResponse} DrainResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                DrainResponse.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a DrainResponse message.
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {?string} `null` if valid, otherwise the reason why it is not
                 */
                DrainResponse.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.on != null && message.hasOwnProperty("on")) {
                        if (!Array.isArray(message.on))
                            return "on: array expected";
                        for (let i = 0; i < message.on.length; ++i)
                            if (!$util.isInteger(message.on[i]))
                                return "on: integer[] expected";
                    }
                    return null;
                };

                /**
                 * Creates a DrainResponse message from a plain object. Also converts values to their respective internal types.
                 * @param {Object.<string,*>} object Plain object
                 * @returns {cockroach.server.serverpb.DrainResponse} DrainResponse
                 */
                DrainResponse.fromObject = function fromObject(object) {
                    if (object instanceof $root.cockroach.server.serverpb.DrainResponse)
                        return object;
                    let message = new $root.cockroach.server.serverpb.DrainResponse();
                    if (object.on) {
                        if (!Array.isArray(object.on))
                            throw TypeError(".cockroach.server.serverpb.DrainResponse.on: array expected");
                        message.on = [];
                        for (let i = 0; i < object.on.length; ++i)
                            message.on[i] = object.on[i] | 0;
                    }
                    return message;
                };

                /**
                 * Creates a DrainResponse message from a plain object. Also converts values to their respective internal types.
                 * This is an alias of {@link cockroach.server.serverpb.DrainResponse.fromObject}.
                 * @function
                 * @param {Object.<string,*>} object Plain object
                 * @returns {cockroach.server.serverpb.DrainResponse} DrainResponse
                 */
                DrainResponse.from = DrainResponse.fromObject;

                /**
                 * Creates a plain object from a DrainResponse message. Also converts values to other types if specified.
                 * @param {cockroach.server.serverpb.DrainResponse} message DrainResponse
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                DrainResponse.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.arrays || options.defaults)
                        object.on = [];
                    if (message.on && message.on.length) {
                        object.on = [];
                        for (let j = 0; j < message.on.length; ++j)
                            object.on[j] = message.on[j];
                    }
                    return object;
                };

                /**
                 * Creates a plain object from this DrainResponse message. Also converts values to other types if specified.
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                DrainResponse.prototype.toObject = function toObject(options) {
                    return this.constructor.toObject(this, options);
                };

                /**
                 * Converts this DrainResponse to JSON.
                 * @returns {Object.<string,*>} JSON object
                 */
                DrainResponse.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return DrainResponse;
            })();

            serverpb.SettingsRequest = (function() {

                /**
                 * Properties of a SettingsRequest.
                 * @typedef cockroach.server.serverpb.SettingsRequest$Properties
                 * @type {Object}
                 * @property {Array.<string>} [keys] SettingsRequest keys.
                 */

                /**
                 * Constructs a new SettingsRequest.
                 * @exports cockroach.server.serverpb.SettingsRequest
                 * @constructor
                 * @param {cockroach.server.serverpb.SettingsRequest$Properties=} [properties] Properties to set
                 */
                function SettingsRequest(properties) {
                    this.keys = [];
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * SettingsRequest keys.
                 * @type {Array.<string>}
                 */
                SettingsRequest.prototype.keys = $util.emptyArray;

                /**
                 * Creates a new SettingsRequest instance using the specified properties.
                 * @param {cockroach.server.serverpb.SettingsRequest$Properties=} [properties] Properties to set
                 * @returns {cockroach.server.serverpb.SettingsRequest} SettingsRequest instance
                 */
                SettingsRequest.create = function create(properties) {
                    return new SettingsRequest(properties);
                };

                /**
                 * Encodes the specified SettingsRequest message. Does not implicitly {@link cockroach.server.serverpb.SettingsRequest.verify|verify} messages.
                 * @param {cockroach.server.serverpb.SettingsRequest$Properties} message SettingsRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                SettingsRequest.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.keys != null && message.keys.length)
                        for (let i = 0; i < message.keys.length; ++i)
                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.keys[i]);
                    return writer;
                };

                /**
                 * Encodes the specified SettingsRequest message, length delimited. Does not implicitly {@link cockroach.server.serverpb.SettingsRequest.verify|verify} messages.
                 * @param {cockroach.server.serverpb.SettingsRequest$Properties} message SettingsRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                SettingsRequest.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a SettingsRequest message from the specified reader or buffer.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {cockroach.server.serverpb.SettingsRequest} SettingsRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                SettingsRequest.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.cockroach.server.serverpb.SettingsRequest();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (!(message.keys && message.keys.length))
                                message.keys = [];
                            message.keys.push(reader.string());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a SettingsRequest message from the specified reader or buffer, length delimited.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {cockroach.server.serverpb.SettingsRequest} SettingsRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                SettingsRequest.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a SettingsRequest message.
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {?string} `null` if valid, otherwise the reason why it is not
                 */
                SettingsRequest.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.keys != null && message.hasOwnProperty("keys")) {
                        if (!Array.isArray(message.keys))
                            return "keys: array expected";
                        for (let i = 0; i < message.keys.length; ++i)
                            if (!$util.isString(message.keys[i]))
                                return "keys: string[] expected";
                    }
                    return null;
                };

                /**
                 * Creates a SettingsRequest message from a plain object. Also converts values to their respective internal types.
                 * @param {Object.<string,*>} object Plain object
                 * @returns {cockroach.server.serverpb.SettingsRequest} SettingsRequest
                 */
                SettingsRequest.fromObject = function fromObject(object) {
                    if (object instanceof $root.cockroach.server.serverpb.SettingsRequest)
                        return object;
                    let message = new $root.cockroach.server.serverpb.SettingsRequest();
                    if (object.keys) {
                        if (!Array.isArray(object.keys))
                            throw TypeError(".cockroach.server.serverpb.SettingsRequest.keys: array expected");
                        message.keys = [];
                        for (let i = 0; i < object.keys.length; ++i)
                            message.keys[i] = String(object.keys[i]);
                    }
                    return message;
                };

                /**
                 * Creates a SettingsRequest message from a plain object. Also converts values to their respective internal types.
                 * This is an alias of {@link cockroach.server.serverpb.SettingsRequest.fromObject}.
                 * @function
                 * @param {Object.<string,*>} object Plain object
                 * @returns {cockroach.server.serverpb.SettingsRequest} SettingsRequest
                 */
                SettingsRequest.from = SettingsRequest.fromObject;

                /**
                 * Creates a plain object from a SettingsRequest message. Also converts values to other types if specified.
                 * @param {cockroach.server.serverpb.SettingsRequest} message SettingsRequest
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                SettingsRequest.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.arrays || options.defaults)
                        object.keys = [];
                    if (message.keys && message.keys.length) {
                        object.keys = [];
                        for (let j = 0; j < message.keys.length; ++j)
                            object.keys[j] = message.keys[j];
                    }
                    return object;
                };

                /**
                 * Creates a plain object from this SettingsRequest message. Also converts values to other types if specified.
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                SettingsRequest.prototype.toObject = function toObject(options) {
                    return this.constructor.toObject(this, options);
                };

                /**
                 * Converts this SettingsRequest to JSON.
                 * @returns {Object.<string,*>} JSON object
                 */
                SettingsRequest.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return SettingsRequest;
            })();

            serverpb.SettingsResponse = (function() {

                /**
                 * Properties of a SettingsResponse.
                 * @typedef cockroach.server.serverpb.SettingsResponse$Properties
                 * @type {Object}
                 * @property {Object.<string,cockroach.server.serverpb.SettingsResponse.Value$Properties>} [key_values] SettingsResponse key_values.
                 */

                /**
                 * Constructs a new SettingsResponse.
                 * @exports cockroach.server.serverpb.SettingsResponse
                 * @constructor
                 * @param {cockroach.server.serverpb.SettingsResponse$Properties=} [properties] Properties to set
                 */
                function SettingsResponse(properties) {
                    this.key_values = {};
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * SettingsResponse key_values.
                 * @type {Object.<string,cockroach.server.serverpb.SettingsResponse.Value$Properties>}
                 */
                SettingsResponse.prototype.key_values = $util.emptyObject;

                /**
                 * Creates a new SettingsResponse instance using the specified properties.
                 * @param {cockroach.server.serverpb.SettingsResponse$Properties=} [properties] Properties to set
                 * @returns {cockroach.server.serverpb.SettingsResponse} SettingsResponse instance
                 */
                SettingsResponse.create = function create(properties) {
                    return new SettingsResponse(properties);
                };

                /**
                 * Encodes the specified SettingsResponse message. Does not implicitly {@link cockroach.server.serverpb.SettingsResponse.verify|verify} messages.
                 * @param {cockroach.server.serverpb.SettingsResponse$Properties} message SettingsResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                SettingsResponse.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.key_values != null && message.hasOwnProperty("key_values"))
                        for (let keys = Object.keys(message.key_values), i = 0; i < keys.length; ++i) {
                            writer.uint32(/* id 1, wireType 2 =*/10).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]);
                            $root.cockroach.server.serverpb.SettingsResponse.Value.encode(message.key_values[keys[i]], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim().ldelim();
                        }
                    return writer;
                };

                /**
                 * Encodes the specified SettingsResponse message, length delimited. Does not implicitly {@link cockroach.server.serverpb.SettingsResponse.verify|verify} messages.
                 * @param {cockroach.server.serverpb.SettingsResponse$Properties} message SettingsResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                SettingsResponse.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a SettingsResponse message from the specified reader or buffer.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {cockroach.server.serverpb.SettingsResponse} SettingsResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                SettingsResponse.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.cockroach.server.serverpb.SettingsResponse(), key;
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            reader.skip().pos++;
                            if (message.key_values === $util.emptyObject)
                                message.key_values = {};
                            key = reader.string();
                            reader.pos++;
                            message.key_values[key] = $root.cockroach.server.serverpb.SettingsResponse.Value.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a SettingsResponse message from the specified reader or buffer, length delimited.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {cockroach.server.serverpb.SettingsResponse} SettingsResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                SettingsResponse.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a SettingsResponse message.
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {?string} `null` if valid, otherwise the reason why it is not
                 */
                SettingsResponse.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.key_values != null && message.hasOwnProperty("key_values")) {
                        if (!$util.isObject(message.key_values))
                            return "key_values: object expected";
                        let key = Object.keys(message.key_values);
                        for (let i = 0; i < key.length; ++i) {
                            let error = $root.cockroach.server.serverpb.SettingsResponse.Value.verify(message.key_values[key[i]]);
                            if (error)
                                return "key_values." + error;
                        }
                    }
                    return null;
                };

                /**
                 * Creates a SettingsResponse message from a plain object. Also converts values to their respective internal types.
                 * @param {Object.<string,*>} object Plain object
                 * @returns {cockroach.server.serverpb.SettingsResponse} SettingsResponse
                 */
                SettingsResponse.fromObject = function fromObject(object) {
                    if (object instanceof $root.cockroach.server.serverpb.SettingsResponse)
                        return object;
                    let message = new $root.cockroach.server.serverpb.SettingsResponse();
                    if (object.key_values) {
                        if (typeof object.key_values !== "object")
                            throw TypeError(".cockroach.server.serverpb.SettingsResponse.key_values: object expected");
                        message.key_values = {};
                        for (let keys = Object.keys(object.key_values), i = 0; i < keys.length; ++i) {
                            if (typeof object.key_values[keys[i]] !== "object")
                                throw TypeError(".cockroach.server.serverpb.SettingsResponse.key_values: object expected");
                            message.key_values[keys[i]] = $root.cockroach.server.serverpb.SettingsResponse.Value.fromObject(object.key_values[keys[i]]);
                        }
                    }
                    return message;
                };

                /**
                 * Creates a SettingsResponse message from a plain object. Also converts values to their respective internal types.
                 * This is an alias of {@link cockroach.server.serverpb.SettingsResponse.fromObject}.
                 * @function
                 * @param {Object.<string,*>} object Plain object
                 * @returns {cockroach.server.serverpb.SettingsResponse} SettingsResponse
                 */
                SettingsResponse.from = SettingsResponse.fromObject;

                /**
                 * Creates a plain object from a SettingsResponse message. Also converts values to other types if specified.
                 * @param {cockroach.server.serverpb.SettingsResponse} message SettingsResponse
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                SettingsResponse.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.objects || options.defaults)
                        object.key_values = {};
                    let keys2;
                    if (message.key_values && (keys2 = Object.keys(message.key_values)).length) {
                        object.key_values = {};
                        for (let j = 0; j < keys2.length; ++j)
                            object.key_values[keys2[j]] = $root.cockroach.server.serverpb.SettingsResponse.Value.toObject(message.key_values[keys2[j]], options);
                    }
                    return object;
                };

                /**
                 * Creates a plain object from this SettingsResponse message. Also converts values to other types if specified.
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                SettingsResponse.prototype.toObject = function toObject(options) {
                    return this.constructor.toObject(this, options);
                };

                /**
                 * Converts this SettingsResponse to JSON.
                 * @returns {Object.<string,*>} JSON object
                 */
                SettingsResponse.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                SettingsResponse.Value = (function() {

                    /**
                     * Properties of a Value.
                     * @typedef cockroach.server.serverpb.SettingsResponse.Value$Properties
                     * @type {Object}
                     * @property {string} [value] Value value.
                     * @property {string} [type] Value type.
                     * @property {string} [description] Value description.
                     */

                    /**
                     * Constructs a new Value.
                     * @exports cockroach.server.serverpb.SettingsResponse.Value
                     * @constructor
                     * @param {cockroach.server.serverpb.SettingsResponse.Value$Properties=} [properties] Properties to set
                     */
                    function Value(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * Value value.
                     * @type {string}
                     */
                    Value.prototype.value = "";

                    /**
                     * Value type.
                     * @type {string}
                     */
                    Value.prototype.type = "";

                    /**
                     * Value description.
                     * @type {string}
                     */
                    Value.prototype.description = "";

                    /**
                     * Creates a new Value instance using the specified properties.
                     * @param {cockroach.server.serverpb.SettingsResponse.Value$Properties=} [properties] Properties to set
                     * @returns {cockroach.server.serverpb.SettingsResponse.Value} Value instance
                     */
                    Value.create = function create(properties) {
                        return new Value(properties);
                    };

                    /**
                     * Encodes the specified Value message. Does not implicitly {@link cockroach.server.serverpb.SettingsResponse.Value.verify|verify} messages.
                     * @param {cockroach.server.serverpb.SettingsResponse.Value$Properties} message Value message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Value.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.value != null && message.hasOwnProperty("value"))
                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.value);
                        if (message.type != null && message.hasOwnProperty("type"))
                            writer.uint32(/* id 2, wireType 2 =*/18).string(message.type);
                        if (message.description != null && message.hasOwnProperty("description"))
                            writer.uint32(/* id 3, wireType 2 =*/26).string(message.description);
                        return writer;
                    };

                    /**
                     * Encodes the specified Value message, length delimited. Does not implicitly {@link cockroach.server.serverpb.SettingsResponse.Value.verify|verify} messages.
                     * @param {cockroach.server.serverpb.SettingsResponse.Value$Properties} message Value message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Value.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a Value message from the specified reader or buffer.
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {cockroach.server.serverpb.SettingsResponse.Value} Value
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Value.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.cockroach.server.serverpb.SettingsResponse.Value();
                        while (reader.pos < end) {
                            let tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.value = reader.string();
                                break;
                            case 2:
                                message.type = reader.string();
                                break;
                            case 3:
                                message.description = reader.string();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a Value message from the specified reader or buffer, length delimited.
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {cockroach.server.serverpb.SettingsResponse.Value} Value
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Value.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a Value message.
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {?string} `null` if valid, otherwise the reason why it is not
                     */
                    Value.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.value != null && message.hasOwnProperty("value"))
                            if (!$util.isString(message.value))
                                return "value: string expected";
                        if (message.type != null && message.hasOwnProperty("type"))
                            if (!$util.isString(message.type))
                                return "type: string expected";
                        if (message.description != null && message.hasOwnProperty("description"))
                            if (!$util.isString(message.description))
                                return "description: string expected";
                        return null;
                    };

                    /**
                     * Creates a Value message from a plain object. Also converts values to their respective internal types.
                     * @param {Object.<string,*>} object Plain object
                     * @returns {cockroach.server.serverpb.SettingsResponse.Value} Value
                     */
                    Value.fromObject = function fromObject(object) {
                        if (object instanceof $root.cockroach.server.serverpb.SettingsResponse.Value)
                            return object;
                        let message = new $root.cockroach.server.serverpb.SettingsResponse.Value();
                        if (object.value != null)
                            message.value = String(object.value);
                        if (object.type != null)
                            message.type = String(object.type);
                        if (object.description != null)
                            message.description = String(object.description);
                        return message;
                    };

                    /**
                     * Creates a Value message from a plain object. Also converts values to their respective internal types.
                     * This is an alias of {@link cockroach.server.serverpb.SettingsResponse.Value.fromObject}.
                     * @function
                     * @param {Object.<string,*>} object Plain object
                     * @returns {cockroach.server.serverpb.SettingsResponse.Value} Value
                     */
                    Value.from = Value.fromObject;

                    /**
                     * Creates a plain object from a Value message. Also converts values to other types if specified.
                     * @param {cockroach.server.serverpb.SettingsResponse.Value} message Value
                     * @param {$protobuf.ConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Value.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.defaults) {
                            object.value = "";
                            object.type = "";
                            object.description = "";
                        }
                        if (message.value != null && message.hasOwnProperty("value"))
                            object.value = message.value;
                        if (message.type != null && message.hasOwnProperty("type"))
                            object.type = message.type;
                        if (message.description != null && message.hasOwnProperty("description"))
                            object.description = message.description;
                        return object;
                    };

                    /**
                     * Creates a plain object from this Value message. Also converts values to other types if specified.
                     * @param {$protobuf.ConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Value.prototype.toObject = function toObject(options) {
                        return this.constructor.toObject(this, options);
                    };

                    /**
                     * Converts this Value to JSON.
                     * @returns {Object.<string,*>} JSON object
                     */
                    Value.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return Value;
                })();

                return SettingsResponse;
            })();

            serverpb.HealthRequest = (function() {

                /**
                 * Properties of a HealthRequest.
                 * @typedef cockroach.server.serverpb.HealthRequest$Properties
                 * @type {Object}
                 */

                /**
                 * Constructs a new HealthRequest.
                 * @exports cockroach.server.serverpb.HealthRequest
                 * @constructor
                 * @param {cockroach.server.serverpb.HealthRequest$Properties=} [properties] Properties to set
                 */
                function HealthRequest(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Creates a new HealthRequest instance using the specified properties.
                 * @param {cockroach.server.serverpb.HealthRequest$Properties=} [properties] Properties to set
                 * @returns {cockroach.server.serverpb.HealthRequest} HealthRequest instance
                 */
                HealthRequest.create = function create(properties) {
                    return new HealthRequest(properties);
                };

                /**
                 * Encodes the specified HealthRequest message. Does not implicitly {@link cockroach.server.serverpb.HealthRequest.verify|verify} messages.
                 * @param {cockroach.server.serverpb.HealthRequest$Properties} message HealthRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                HealthRequest.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    return writer;
                };

                /**
                 * Encodes the specified HealthRequest message, length delimited. Does not implicitly {@link cockroach.server.serverpb.HealthRequest.verify|verify} messages.
                 * @param {cockroach.server.serverpb.HealthRequest$Properties} message HealthRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                HealthRequest.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a HealthRequest message from the specified reader or buffer.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {cockroach.server.serverpb.HealthRequest} HealthRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                HealthRequest.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.cockroach.server.serverpb.HealthRequest();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a HealthRequest message from the specified reader or buffer, length delimited.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {cockroach.server.serverpb.HealthRequest} HealthRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                HealthRequest.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a HealthRequest message.
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {?string} `null` if valid, otherwise the reason why it is not
                 */
                HealthRequest.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    return null;
                };

                /**
                 * Creates a HealthRequest message from a plain object. Also converts values to their respective internal types.
                 * @param {Object.<string,*>} object Plain object
                 * @returns {cockroach.server.serverpb.HealthRequest} HealthRequest
                 */
                HealthRequest.fromObject = function fromObject(object) {
                    if (object instanceof $root.cockroach.server.serverpb.HealthRequest)
                        return object;
                    return new $root.cockroach.server.serverpb.HealthRequest();
                };

                /**
                 * Creates a HealthRequest message from a plain object. Also converts values to their respective internal types.
                 * This is an alias of {@link cockroach.server.serverpb.HealthRequest.fromObject}.
                 * @function
                 * @param {Object.<string,*>} object Plain object
                 * @returns {cockroach.server.serverpb.HealthRequest} HealthRequest
                 */
                HealthRequest.from = HealthRequest.fromObject;

                /**
                 * Creates a plain object from a HealthRequest message. Also converts values to other types if specified.
                 * @param {cockroach.server.serverpb.HealthRequest} message HealthRequest
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                HealthRequest.toObject = function toObject() {
                    return {};
                };

                /**
                 * Creates a plain object from this HealthRequest message. Also converts values to other types if specified.
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                HealthRequest.prototype.toObject = function toObject(options) {
                    return this.constructor.toObject(this, options);
                };

                /**
                 * Converts this HealthRequest to JSON.
                 * @returns {Object.<string,*>} JSON object
                 */
                HealthRequest.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return HealthRequest;
            })();

            serverpb.HealthResponse = (function() {

                /**
                 * Properties of a HealthResponse.
                 * @typedef cockroach.server.serverpb.HealthResponse$Properties
                 * @type {Object}
                 */

                /**
                 * Constructs a new HealthResponse.
                 * @exports cockroach.server.serverpb.HealthResponse
                 * @constructor
                 * @param {cockroach.server.serverpb.HealthResponse$Properties=} [properties] Properties to set
                 */
                function HealthResponse(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Creates a new HealthResponse instance using the specified properties.
                 * @param {cockroach.server.serverpb.HealthResponse$Properties=} [properties] Properties to set
                 * @returns {cockroach.server.serverpb.HealthResponse} HealthResponse instance
                 */
                HealthResponse.create = function create(properties) {
                    return new HealthResponse(properties);
                };

                /**
                 * Encodes the specified HealthResponse message. Does not implicitly {@link cockroach.server.serverpb.HealthResponse.verify|verify} messages.
                 * @param {cockroach.server.serverpb.HealthResponse$Properties} message HealthResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                HealthResponse.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    return writer;
                };

                /**
                 * Encodes the specified HealthResponse message, length delimited. Does not implicitly {@link cockroach.server.serverpb.HealthResponse.verify|verify} messages.
                 * @param {cockroach.server.serverpb.HealthResponse$Properties} message HealthResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                HealthResponse.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a HealthResponse message from the specified reader or buffer.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {cockroach.server.serverpb.HealthResponse} HealthResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                HealthResponse.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.cockroach.server.serverpb.HealthResponse();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a HealthResponse message from the specified reader or buffer, length delimited.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {cockroach.server.serverpb.HealthResponse} HealthResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                HealthResponse.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a HealthResponse message.
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {?string} `null` if valid, otherwise the reason why it is not
                 */
                HealthResponse.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    return null;
                };

                /**
                 * Creates a HealthResponse message from a plain object. Also converts values to their respective internal types.
                 * @param {Object.<string,*>} object Plain object
                 * @returns {cockroach.server.serverpb.HealthResponse} HealthResponse
                 */
                HealthResponse.fromObject = function fromObject(object) {
                    if (object instanceof $root.cockroach.server.serverpb.HealthResponse)
                        return object;
                    return new $root.cockroach.server.serverpb.HealthResponse();
                };

                /**
                 * Creates a HealthResponse message from a plain object. Also converts values to their respective internal types.
                 * This is an alias of {@link cockroach.server.serverpb.HealthResponse.fromObject}.
                 * @function
                 * @param {Object.<string,*>} object Plain object
                 * @returns {cockroach.server.serverpb.HealthResponse} HealthResponse
                 */
                HealthResponse.from = HealthResponse.fromObject;

                /**
                 * Creates a plain object from a HealthResponse message. Also converts values to other types if specified.
                 * @param {cockroach.server.serverpb.HealthResponse} message HealthResponse
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                HealthResponse.toObject = function toObject() {
                    return {};
                };

                /**
                 * Creates a plain object from this HealthResponse message. Also converts values to other types if specified.
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                HealthResponse.prototype.toObject = function toObject(options) {
                    return this.constructor.toObject(this, options);
                };

                /**
                 * Converts this HealthResponse to JSON.
                 * @returns {Object.<string,*>} JSON object
                 */
                HealthResponse.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return HealthResponse;
            })();

            serverpb.LivenessRequest = (function() {

                /**
                 * Properties of a LivenessRequest.
                 * @typedef cockroach.server.serverpb.LivenessRequest$Properties
                 * @type {Object}
                 */

                /**
                 * Constructs a new LivenessRequest.
                 * @exports cockroach.server.serverpb.LivenessRequest
                 * @constructor
                 * @param {cockroach.server.serverpb.LivenessRequest$Properties=} [properties] Properties to set
                 */
                function LivenessRequest(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Creates a new LivenessRequest instance using the specified properties.
                 * @param {cockroach.server.serverpb.LivenessRequest$Properties=} [properties] Properties to set
                 * @returns {cockroach.server.serverpb.LivenessRequest} LivenessRequest instance
                 */
                LivenessRequest.create = function create(properties) {
                    return new LivenessRequest(properties);
                };

                /**
                 * Encodes the specified LivenessRequest message. Does not implicitly {@link cockroach.server.serverpb.LivenessRequest.verify|verify} messages.
                 * @param {cockroach.server.serverpb.LivenessRequest$Properties} message LivenessRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                LivenessRequest.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    return writer;
                };

                /**
                 * Encodes the specified LivenessRequest message, length delimited. Does not implicitly {@link cockroach.server.serverpb.LivenessRequest.verify|verify} messages.
                 * @param {cockroach.server.serverpb.LivenessRequest$Properties} message LivenessRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                LivenessRequest.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a LivenessRequest message from the specified reader or buffer.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {cockroach.server.serverpb.LivenessRequest} LivenessRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                LivenessRequest.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.cockroach.server.serverpb.LivenessRequest();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a LivenessRequest message from the specified reader or buffer, length delimited.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {cockroach.server.serverpb.LivenessRequest} LivenessRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                LivenessRequest.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a LivenessRequest message.
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {?string} `null` if valid, otherwise the reason why it is not
                 */
                LivenessRequest.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    return null;
                };

                /**
                 * Creates a LivenessRequest message from a plain object. Also converts values to their respective internal types.
                 * @param {Object.<string,*>} object Plain object
                 * @returns {cockroach.server.serverpb.LivenessRequest} LivenessRequest
                 */
                LivenessRequest.fromObject = function fromObject(object) {
                    if (object instanceof $root.cockroach.server.serverpb.LivenessRequest)
                        return object;
                    return new $root.cockroach.server.serverpb.LivenessRequest();
                };

                /**
                 * Creates a LivenessRequest message from a plain object. Also converts values to their respective internal types.
                 * This is an alias of {@link cockroach.server.serverpb.LivenessRequest.fromObject}.
                 * @function
                 * @param {Object.<string,*>} object Plain object
                 * @returns {cockroach.server.serverpb.LivenessRequest} LivenessRequest
                 */
                LivenessRequest.from = LivenessRequest.fromObject;

                /**
                 * Creates a plain object from a LivenessRequest message. Also converts values to other types if specified.
                 * @param {cockroach.server.serverpb.LivenessRequest} message LivenessRequest
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                LivenessRequest.toObject = function toObject() {
                    return {};
                };

                /**
                 * Creates a plain object from this LivenessRequest message. Also converts values to other types if specified.
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                LivenessRequest.prototype.toObject = function toObject(options) {
                    return this.constructor.toObject(this, options);
                };

                /**
                 * Converts this LivenessRequest to JSON.
                 * @returns {Object.<string,*>} JSON object
                 */
                LivenessRequest.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return LivenessRequest;
            })();

            serverpb.LivenessResponse = (function() {

                /**
                 * Properties of a LivenessResponse.
                 * @typedef cockroach.server.serverpb.LivenessResponse$Properties
                 * @type {Object}
                 * @property {Array.<cockroach.storage.Liveness$Properties>} [livenesses] LivenessResponse livenesses.
                 */

                /**
                 * Constructs a new LivenessResponse.
                 * @exports cockroach.server.serverpb.LivenessResponse
                 * @constructor
                 * @param {cockroach.server.serverpb.LivenessResponse$Properties=} [properties] Properties to set
                 */
                function LivenessResponse(properties) {
                    this.livenesses = [];
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * LivenessResponse livenesses.
                 * @type {Array.<cockroach.storage.Liveness$Properties>}
                 */
                LivenessResponse.prototype.livenesses = $util.emptyArray;

                /**
                 * Creates a new LivenessResponse instance using the specified properties.
                 * @param {cockroach.server.serverpb.LivenessResponse$Properties=} [properties] Properties to set
                 * @returns {cockroach.server.serverpb.LivenessResponse} LivenessResponse instance
                 */
                LivenessResponse.create = function create(properties) {
                    return new LivenessResponse(properties);
                };

                /**
                 * Encodes the specified LivenessResponse message. Does not implicitly {@link cockroach.server.serverpb.LivenessResponse.verify|verify} messages.
                 * @param {cockroach.server.serverpb.LivenessResponse$Properties} message LivenessResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                LivenessResponse.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.livenesses != null && message.livenesses.length)
                        for (let i = 0; i < message.livenesses.length; ++i)
                            $root.cockroach.storage.Liveness.encode(message.livenesses[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified LivenessResponse message, length delimited. Does not implicitly {@link cockroach.server.serverpb.LivenessResponse.verify|verify} messages.
                 * @param {cockroach.server.serverpb.LivenessResponse$Properties} message LivenessResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                LivenessResponse.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a LivenessResponse message from the specified reader or buffer.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {cockroach.server.serverpb.LivenessResponse} LivenessResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                LivenessResponse.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.cockroach.server.serverpb.LivenessResponse();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (!(message.livenesses && message.livenesses.length))
                                message.livenesses = [];
                            message.livenesses.push($root.cockroach.storage.Liveness.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a LivenessResponse message from the specified reader or buffer, length delimited.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {cockroach.server.serverpb.LivenessResponse} LivenessResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                LivenessResponse.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a LivenessResponse message.
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {?string} `null` if valid, otherwise the reason why it is not
                 */
                LivenessResponse.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.livenesses != null && message.hasOwnProperty("livenesses")) {
                        if (!Array.isArray(message.livenesses))
                            return "livenesses: array expected";
                        for (let i = 0; i < message.livenesses.length; ++i) {
                            let error = $root.cockroach.storage.Liveness.verify(message.livenesses[i]);
                            if (error)
                                return "livenesses." + error;
                        }
                    }
                    return null;
                };

                /**
                 * Creates a LivenessResponse message from a plain object. Also converts values to their respective internal types.
                 * @param {Object.<string,*>} object Plain object
                 * @returns {cockroach.server.serverpb.LivenessResponse} LivenessResponse
                 */
                LivenessResponse.fromObject = function fromObject(object) {
                    if (object instanceof $root.cockroach.server.serverpb.LivenessResponse)
                        return object;
                    let message = new $root.cockroach.server.serverpb.LivenessResponse();
                    if (object.livenesses) {
                        if (!Array.isArray(object.livenesses))
                            throw TypeError(".cockroach.server.serverpb.LivenessResponse.livenesses: array expected");
                        message.livenesses = [];
                        for (let i = 0; i < object.livenesses.length; ++i) {
                            if (typeof object.livenesses[i] !== "object")
                                throw TypeError(".cockroach.server.serverpb.LivenessResponse.livenesses: object expected");
                            message.livenesses[i] = $root.cockroach.storage.Liveness.fromObject(object.livenesses[i]);
                        }
                    }
                    return message;
                };

                /**
                 * Creates a LivenessResponse message from a plain object. Also converts values to their respective internal types.
                 * This is an alias of {@link cockroach.server.serverpb.LivenessResponse.fromObject}.
                 * @function
                 * @param {Object.<string,*>} object Plain object
                 * @returns {cockroach.server.serverpb.LivenessResponse} LivenessResponse
                 */
                LivenessResponse.from = LivenessResponse.fromObject;

                /**
                 * Creates a plain object from a LivenessResponse message. Also converts values to other types if specified.
                 * @param {cockroach.server.serverpb.LivenessResponse} message LivenessResponse
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                LivenessResponse.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.arrays || options.defaults)
                        object.livenesses = [];
                    if (message.livenesses && message.livenesses.length) {
                        object.livenesses = [];
                        for (let j = 0; j < message.livenesses.length; ++j)
                            object.livenesses[j] = $root.cockroach.storage.Liveness.toObject(message.livenesses[j], options);
                    }
                    return object;
                };

                /**
                 * Creates a plain object from this LivenessResponse message. Also converts values to other types if specified.
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                LivenessResponse.prototype.toObject = function toObject(options) {
                    return this.constructor.toObject(this, options);
                };

                /**
                 * Converts this LivenessResponse to JSON.
                 * @returns {Object.<string,*>} JSON object
                 */
                LivenessResponse.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return LivenessResponse;
            })();

            serverpb.Admin = (function() {

                /**
                 * Constructs a new Admin service.
                 * @exports cockroach.server.serverpb.Admin
                 * @extends $protobuf.rpc.Service
                 * @constructor
                 * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
                 * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
                 * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
                 */
                function Admin(rpcImpl, requestDelimited, responseDelimited) {
                    $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
                }

                (Admin.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = Admin;

                /**
                 * Creates new Admin service using the specified rpc implementation.
                 * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
                 * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
                 * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
                 * @returns {Admin} RPC service. Useful where requests and/or responses are streamed.
                 */
                Admin.create = function create(rpcImpl, requestDelimited, responseDelimited) {
                    return new this(rpcImpl, requestDelimited, responseDelimited);
                };

                /**
                 * Callback as used by {@link Admin#users}.
                 * @typedef Admin_users_Callback
                 * @type {function}
                 * @param {?Error} error Error, if any
                 * @param {cockroach.server.serverpb.UsersResponse} [response] UsersResponse
                 */

                /**
                 * Calls Users.
                 * @param {cockroach.server.serverpb.UsersRequest|Object.<string,*>} request UsersRequest message or plain object
                 * @param {Admin_users_Callback} callback Node-style callback called with the error, if any, and UsersResponse
                 * @returns {undefined}
                 */
                Admin.prototype.users = function users(request, callback) {
                    return this.rpcCall(users, $root.cockroach.server.serverpb.UsersRequest, $root.cockroach.server.serverpb.UsersResponse, request, callback);
                };

                /**
                 * Calls Users.
                 * @name Admin#users
                 * @function
                 * @param {cockroach.server.serverpb.UsersRequest|Object.<string,*>} request UsersRequest message or plain object
                 * @returns {Promise<cockroach.server.serverpb.UsersResponse>} Promise
                 * @variation 2
                 */

                /**
                 * Callback as used by {@link Admin#databases}.
                 * @typedef Admin_databases_Callback
                 * @type {function}
                 * @param {?Error} error Error, if any
                 * @param {cockroach.server.serverpb.DatabasesResponse} [response] DatabasesResponse
                 */

                /**
                 * Calls Databases.
                 * @param {cockroach.server.serverpb.DatabasesRequest|Object.<string,*>} request DatabasesRequest message or plain object
                 * @param {Admin_databases_Callback} callback Node-style callback called with the error, if any, and DatabasesResponse
                 * @returns {undefined}
                 */
                Admin.prototype.databases = function databases(request, callback) {
                    return this.rpcCall(databases, $root.cockroach.server.serverpb.DatabasesRequest, $root.cockroach.server.serverpb.DatabasesResponse, request, callback);
                };

                /**
                 * Calls Databases.
                 * @name Admin#databases
                 * @function
                 * @param {cockroach.server.serverpb.DatabasesRequest|Object.<string,*>} request DatabasesRequest message or plain object
                 * @returns {Promise<cockroach.server.serverpb.DatabasesResponse>} Promise
                 * @variation 2
                 */

                /**
                 * Callback as used by {@link Admin#databaseDetails}.
                 * @typedef Admin_databaseDetails_Callback
                 * @type {function}
                 * @param {?Error} error Error, if any
                 * @param {cockroach.server.serverpb.DatabaseDetailsResponse} [response] DatabaseDetailsResponse
                 */

                /**
                 * Calls DatabaseDetails.
                 * @param {cockroach.server.serverpb.DatabaseDetailsRequest|Object.<string,*>} request DatabaseDetailsRequest message or plain object
                 * @param {Admin_databaseDetails_Callback} callback Node-style callback called with the error, if any, and DatabaseDetailsResponse
                 * @returns {undefined}
                 */
                Admin.prototype.databaseDetails = function databaseDetails(request, callback) {
                    return this.rpcCall(databaseDetails, $root.cockroach.server.serverpb.DatabaseDetailsRequest, $root.cockroach.server.serverpb.DatabaseDetailsResponse, request, callback);
                };

                /**
                 * Calls DatabaseDetails.
                 * @name Admin#databaseDetails
                 * @function
                 * @param {cockroach.server.serverpb.DatabaseDetailsRequest|Object.<string,*>} request DatabaseDetailsRequest message or plain object
                 * @returns {Promise<cockroach.server.serverpb.DatabaseDetailsResponse>} Promise
                 * @variation 2
                 */

                /**
                 * Callback as used by {@link Admin#tableDetails}.
                 * @typedef Admin_tableDetails_Callback
                 * @type {function}
                 * @param {?Error} error Error, if any
                 * @param {cockroach.server.serverpb.TableDetailsResponse} [response] TableDetailsResponse
                 */

                /**
                 * Calls TableDetails.
                 * @param {cockroach.server.serverpb.TableDetailsRequest|Object.<string,*>} request TableDetailsRequest message or plain object
                 * @param {Admin_tableDetails_Callback} callback Node-style callback called with the error, if any, and TableDetailsResponse
                 * @returns {undefined}
                 */
                Admin.prototype.tableDetails = function tableDetails(request, callback) {
                    return this.rpcCall(tableDetails, $root.cockroach.server.serverpb.TableDetailsRequest, $root.cockroach.server.serverpb.TableDetailsResponse, request, callback);
                };

                /**
                 * Calls TableDetails.
                 * @name Admin#tableDetails
                 * @function
                 * @param {cockroach.server.serverpb.TableDetailsRequest|Object.<string,*>} request TableDetailsRequest message or plain object
                 * @returns {Promise<cockroach.server.serverpb.TableDetailsResponse>} Promise
                 * @variation 2
                 */

                /**
                 * Callback as used by {@link Admin#tableStats}.
                 * @typedef Admin_tableStats_Callback
                 * @type {function}
                 * @param {?Error} error Error, if any
                 * @param {cockroach.server.serverpb.TableStatsResponse} [response] TableStatsResponse
                 */

                /**
                 * Calls TableStats.
                 * @param {cockroach.server.serverpb.TableStatsRequest|Object.<string,*>} request TableStatsRequest message or plain object
                 * @param {Admin_tableStats_Callback} callback Node-style callback called with the error, if any, and TableStatsResponse
                 * @returns {undefined}
                 */
                Admin.prototype.tableStats = function tableStats(request, callback) {
                    return this.rpcCall(tableStats, $root.cockroach.server.serverpb.TableStatsRequest, $root.cockroach.server.serverpb.TableStatsResponse, request, callback);
                };

                /**
                 * Calls TableStats.
                 * @name Admin#tableStats
                 * @function
                 * @param {cockroach.server.serverpb.TableStatsRequest|Object.<string,*>} request TableStatsRequest message or plain object
                 * @returns {Promise<cockroach.server.serverpb.TableStatsResponse>} Promise
                 * @variation 2
                 */

                /**
                 * Callback as used by {@link Admin#events}.
                 * @typedef Admin_events_Callback
                 * @type {function}
                 * @param {?Error} error Error, if any
                 * @param {cockroach.server.serverpb.EventsResponse} [response] EventsResponse
                 */

                /**
                 * Calls Events.
                 * @param {cockroach.server.serverpb.EventsRequest|Object.<string,*>} request EventsRequest message or plain object
                 * @param {Admin_events_Callback} callback Node-style callback called with the error, if any, and EventsResponse
                 * @returns {undefined}
                 */
                Admin.prototype.events = function events(request, callback) {
                    return this.rpcCall(events, $root.cockroach.server.serverpb.EventsRequest, $root.cockroach.server.serverpb.EventsResponse, request, callback);
                };

                /**
                 * Calls Events.
                 * @name Admin#events
                 * @function
                 * @param {cockroach.server.serverpb.EventsRequest|Object.<string,*>} request EventsRequest message or plain object
                 * @returns {Promise<cockroach.server.serverpb.EventsResponse>} Promise
                 * @variation 2
                 */

                /**
                 * Callback as used by {@link Admin#setUIData}.
                 * @typedef Admin_setUIData_Callback
                 * @type {function}
                 * @param {?Error} error Error, if any
                 * @param {cockroach.server.serverpb.SetUIDataResponse} [response] SetUIDataResponse
                 */

                /**
                 * Calls SetUIData.
                 * @param {cockroach.server.serverpb.SetUIDataRequest|Object.<string,*>} request SetUIDataRequest message or plain object
                 * @param {Admin_setUIData_Callback} callback Node-style callback called with the error, if any, and SetUIDataResponse
                 * @returns {undefined}
                 */
                Admin.prototype.setUIData = function setUIData(request, callback) {
                    return this.rpcCall(setUIData, $root.cockroach.server.serverpb.SetUIDataRequest, $root.cockroach.server.serverpb.SetUIDataResponse, request, callback);
                };

                /**
                 * Calls SetUIData.
                 * @name Admin#setUIData
                 * @function
                 * @param {cockroach.server.serverpb.SetUIDataRequest|Object.<string,*>} request SetUIDataRequest message or plain object
                 * @returns {Promise<cockroach.server.serverpb.SetUIDataResponse>} Promise
                 * @variation 2
                 */

                /**
                 * Callback as used by {@link Admin#getUIData}.
                 * @typedef Admin_getUIData_Callback
                 * @type {function}
                 * @param {?Error} error Error, if any
                 * @param {cockroach.server.serverpb.GetUIDataResponse} [response] GetUIDataResponse
                 */

                /**
                 * Calls GetUIData.
                 * @param {cockroach.server.serverpb.GetUIDataRequest|Object.<string,*>} request GetUIDataRequest message or plain object
                 * @param {Admin_getUIData_Callback} callback Node-style callback called with the error, if any, and GetUIDataResponse
                 * @returns {undefined}
                 */
                Admin.prototype.getUIData = function getUIData(request, callback) {
                    return this.rpcCall(getUIData, $root.cockroach.server.serverpb.GetUIDataRequest, $root.cockroach.server.serverpb.GetUIDataResponse, request, callback);
                };

                /**
                 * Calls GetUIData.
                 * @name Admin#getUIData
                 * @function
                 * @param {cockroach.server.serverpb.GetUIDataRequest|Object.<string,*>} request GetUIDataRequest message or plain object
                 * @returns {Promise<cockroach.server.serverpb.GetUIDataResponse>} Promise
                 * @variation 2
                 */

                /**
                 * Callback as used by {@link Admin#cluster}.
                 * @typedef Admin_cluster_Callback
                 * @type {function}
                 * @param {?Error} error Error, if any
                 * @param {cockroach.server.serverpb.ClusterResponse} [response] ClusterResponse
                 */

                /**
                 * Calls Cluster.
                 * @param {cockroach.server.serverpb.ClusterRequest|Object.<string,*>} request ClusterRequest message or plain object
                 * @param {Admin_cluster_Callback} callback Node-style callback called with the error, if any, and ClusterResponse
                 * @returns {undefined}
                 */
                Admin.prototype.cluster = function cluster(request, callback) {
                    return this.rpcCall(cluster, $root.cockroach.server.serverpb.ClusterRequest, $root.cockroach.server.serverpb.ClusterResponse, request, callback);
                };

                /**
                 * Calls Cluster.
                 * @name Admin#cluster
                 * @function
                 * @param {cockroach.server.serverpb.ClusterRequest|Object.<string,*>} request ClusterRequest message or plain object
                 * @returns {Promise<cockroach.server.serverpb.ClusterResponse>} Promise
                 * @variation 2
                 */

                /**
                 * Callback as used by {@link Admin#settings}.
                 * @typedef Admin_settings_Callback
                 * @type {function}
                 * @param {?Error} error Error, if any
                 * @param {cockroach.server.serverpb.SettingsResponse} [response] SettingsResponse
                 */

                /**
                 * Calls Settings.
                 * @param {cockroach.server.serverpb.SettingsRequest|Object.<string,*>} request SettingsRequest message or plain object
                 * @param {Admin_settings_Callback} callback Node-style callback called with the error, if any, and SettingsResponse
                 * @returns {undefined}
                 */
                Admin.prototype.settings = function settings(request, callback) {
                    return this.rpcCall(settings, $root.cockroach.server.serverpb.SettingsRequest, $root.cockroach.server.serverpb.SettingsResponse, request, callback);
                };

                /**
                 * Calls Settings.
                 * @name Admin#settings
                 * @function
                 * @param {cockroach.server.serverpb.SettingsRequest|Object.<string,*>} request SettingsRequest message or plain object
                 * @returns {Promise<cockroach.server.serverpb.SettingsResponse>} Promise
                 * @variation 2
                 */

                /**
                 * Callback as used by {@link Admin#health}.
                 * @typedef Admin_health_Callback
                 * @type {function}
                 * @param {?Error} error Error, if any
                 * @param {cockroach.server.serverpb.HealthResponse} [response] HealthResponse
                 */

                /**
                 * Calls Health.
                 * @param {cockroach.server.serverpb.HealthRequest|Object.<string,*>} request HealthRequest message or plain object
                 * @param {Admin_health_Callback} callback Node-style callback called with the error, if any, and HealthResponse
                 * @returns {undefined}
                 */
                Admin.prototype.health = function health(request, callback) {
                    return this.rpcCall(health, $root.cockroach.server.serverpb.HealthRequest, $root.cockroach.server.serverpb.HealthResponse, request, callback);
                };

                /**
                 * Calls Health.
                 * @name Admin#health
                 * @function
                 * @param {cockroach.server.serverpb.HealthRequest|Object.<string,*>} request HealthRequest message or plain object
                 * @returns {Promise<cockroach.server.serverpb.HealthResponse>} Promise
                 * @variation 2
                 */

                /**
                 * Callback as used by {@link Admin#liveness}.
                 * @typedef Admin_liveness_Callback
                 * @type {function}
                 * @param {?Error} error Error, if any
                 * @param {cockroach.server.serverpb.LivenessResponse} [response] LivenessResponse
                 */

                /**
                 * Calls Liveness.
                 * @param {cockroach.server.serverpb.LivenessRequest|Object.<string,*>} request LivenessRequest message or plain object
                 * @param {Admin_liveness_Callback} callback Node-style callback called with the error, if any, and LivenessResponse
                 * @returns {undefined}
                 */
                Admin.prototype.liveness = function liveness(request, callback) {
                    return this.rpcCall(liveness, $root.cockroach.server.serverpb.LivenessRequest, $root.cockroach.server.serverpb.LivenessResponse, request, callback);
                };

                /**
                 * Calls Liveness.
                 * @name Admin#liveness
                 * @function
                 * @param {cockroach.server.serverpb.LivenessRequest|Object.<string,*>} request LivenessRequest message or plain object
                 * @returns {Promise<cockroach.server.serverpb.LivenessResponse>} Promise
                 * @variation 2
                 */

                /**
                 * Callback as used by {@link Admin#drain}.
                 * @typedef Admin_drain_Callback
                 * @type {function}
                 * @param {?Error} error Error, if any
                 * @param {cockroach.server.serverpb.DrainResponse} [response] DrainResponse
                 */

                /**
                 * Calls Drain.
                 * @param {cockroach.server.serverpb.DrainRequest|Object.<string,*>} request DrainRequest message or plain object
                 * @param {Admin_drain_Callback} callback Node-style callback called with the error, if any, and DrainResponse
                 * @returns {undefined}
                 */
                Admin.prototype.drain = function drain(request, callback) {
                    return this.rpcCall(drain, $root.cockroach.server.serverpb.DrainRequest, $root.cockroach.server.serverpb.DrainResponse, request, callback);
                };

                /**
                 * Calls Drain.
                 * @name Admin#drain
                 * @function
                 * @param {cockroach.server.serverpb.DrainRequest|Object.<string,*>} request DrainRequest message or plain object
                 * @returns {Promise<cockroach.server.serverpb.DrainResponse>} Promise
                 * @variation 2
                 */

                return Admin;
            })();

            serverpb.DetailsRequest = (function() {

                /**
                 * Properties of a DetailsRequest.
                 * @typedef cockroach.server.serverpb.DetailsRequest$Properties
                 * @type {Object}
                 * @property {string} [node_id] DetailsRequest node_id.
                 */

                /**
                 * Constructs a new DetailsRequest.
                 * @exports cockroach.server.serverpb.DetailsRequest
                 * @constructor
                 * @param {cockroach.server.serverpb.DetailsRequest$Properties=} [properties] Properties to set
                 */
                function DetailsRequest(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * DetailsRequest node_id.
                 * @type {string}
                 */
                DetailsRequest.prototype.node_id = "";

                /**
                 * Creates a new DetailsRequest instance using the specified properties.
                 * @param {cockroach.server.serverpb.DetailsRequest$Properties=} [properties] Properties to set
                 * @returns {cockroach.server.serverpb.DetailsRequest} DetailsRequest instance
                 */
                DetailsRequest.create = function create(properties) {
                    return new DetailsRequest(properties);
                };

                /**
                 * Encodes the specified DetailsRequest message. Does not implicitly {@link cockroach.server.serverpb.DetailsRequest.verify|verify} messages.
                 * @param {cockroach.server.serverpb.DetailsRequest$Properties} message DetailsRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                DetailsRequest.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.node_id != null && message.hasOwnProperty("node_id"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.node_id);
                    return writer;
                };

                /**
                 * Encodes the specified DetailsRequest message, length delimited. Does not implicitly {@link cockroach.server.serverpb.DetailsRequest.verify|verify} messages.
                 * @param {cockroach.server.serverpb.DetailsRequest$Properties} message DetailsRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                DetailsRequest.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a DetailsRequest message from the specified reader or buffer.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {cockroach.server.serverpb.DetailsRequest} DetailsRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                DetailsRequest.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.cockroach.server.serverpb.DetailsRequest();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.node_id = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a DetailsRequest message from the specified reader or buffer, length delimited.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {cockroach.server.serverpb.DetailsRequest} DetailsRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                DetailsRequest.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a DetailsRequest message.
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {?string} `null` if valid, otherwise the reason why it is not
                 */
                DetailsRequest.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.node_id != null && message.hasOwnProperty("node_id"))
                        if (!$util.isString(message.node_id))
                            return "node_id: string expected";
                    return null;
                };

                /**
                 * Creates a DetailsRequest message from a plain object. Also converts values to their respective internal types.
                 * @param {Object.<string,*>} object Plain object
                 * @returns {cockroach.server.serverpb.DetailsRequest} DetailsRequest
                 */
                DetailsRequest.fromObject = function fromObject(object) {
                    if (object instanceof $root.cockroach.server.serverpb.DetailsRequest)
                        return object;
                    let message = new $root.cockroach.server.serverpb.DetailsRequest();
                    if (object.node_id != null)
                        message.node_id = String(object.node_id);
                    return message;
                };

                /**
                 * Creates a DetailsRequest message from a plain object. Also converts values to their respective internal types.
                 * This is an alias of {@link cockroach.server.serverpb.DetailsRequest.fromObject}.
                 * @function
                 * @param {Object.<string,*>} object Plain object
                 * @returns {cockroach.server.serverpb.DetailsRequest} DetailsRequest
                 */
                DetailsRequest.from = DetailsRequest.fromObject;

                /**
                 * Creates a plain object from a DetailsRequest message. Also converts values to other types if specified.
                 * @param {cockroach.server.serverpb.DetailsRequest} message DetailsRequest
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                DetailsRequest.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults)
                        object.node_id = "";
                    if (message.node_id != null && message.hasOwnProperty("node_id"))
                        object.node_id = message.node_id;
                    return object;
                };

                /**
                 * Creates a plain object from this DetailsRequest message. Also converts values to other types if specified.
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                DetailsRequest.prototype.toObject = function toObject(options) {
                    return this.constructor.toObject(this, options);
                };

                /**
                 * Converts this DetailsRequest to JSON.
                 * @returns {Object.<string,*>} JSON object
                 */
                DetailsRequest.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return DetailsRequest;
            })();

            serverpb.DetailsResponse = (function() {

                /**
                 * Properties of a DetailsResponse.
                 * @typedef cockroach.server.serverpb.DetailsResponse$Properties
                 * @type {Object}
                 * @property {number} [node_id] DetailsResponse node_id.
                 * @property {cockroach.util.UnresolvedAddr$Properties} [address] DetailsResponse address.
                 * @property {cockroach.build.Info$Properties} [build_info] DetailsResponse build_info.
                 */

                /**
                 * Constructs a new DetailsResponse.
                 * @exports cockroach.server.serverpb.DetailsResponse
                 * @constructor
                 * @param {cockroach.server.serverpb.DetailsResponse$Properties=} [properties] Properties to set
                 */
                function DetailsResponse(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * DetailsResponse node_id.
                 * @type {number}
                 */
                DetailsResponse.prototype.node_id = 0;

                /**
                 * DetailsResponse address.
                 * @type {(cockroach.util.UnresolvedAddr$Properties|null)}
                 */
                DetailsResponse.prototype.address = null;

                /**
                 * DetailsResponse build_info.
                 * @type {(cockroach.build.Info$Properties|null)}
                 */
                DetailsResponse.prototype.build_info = null;

                /**
                 * Creates a new DetailsResponse instance using the specified properties.
                 * @param {cockroach.server.serverpb.DetailsResponse$Properties=} [properties] Properties to set
                 * @returns {cockroach.server.serverpb.DetailsResponse} DetailsResponse instance
                 */
                DetailsResponse.create = function create(properties) {
                    return new DetailsResponse(properties);
                };

                /**
                 * Encodes the specified DetailsResponse message. Does not implicitly {@link cockroach.server.serverpb.DetailsResponse.verify|verify} messages.
                 * @param {cockroach.server.serverpb.DetailsResponse$Properties} message DetailsResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                DetailsResponse.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.node_id != null && message.hasOwnProperty("node_id"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.node_id);
                    if (message.address != null && message.hasOwnProperty("address"))
                        $root.cockroach.util.UnresolvedAddr.encode(message.address, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.build_info != null && message.hasOwnProperty("build_info"))
                        $root.cockroach.build.Info.encode(message.build_info, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified DetailsResponse message, length delimited. Does not implicitly {@link cockroach.server.serverpb.DetailsResponse.verify|verify} messages.
                 * @param {cockroach.server.serverpb.DetailsResponse$Properties} message DetailsResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                DetailsResponse.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a DetailsResponse message from the specified reader or buffer.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {cockroach.server.serverpb.DetailsResponse} DetailsResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                DetailsResponse.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.cockroach.server.serverpb.DetailsResponse();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.node_id = reader.int32();
                            break;
                        case 2:
                            message.address = $root.cockroach.util.UnresolvedAddr.decode(reader, reader.uint32());
                            break;
                        case 3:
                            message.build_info = $root.cockroach.build.Info.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a DetailsResponse message from the specified reader or buffer, length delimited.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {cockroach.server.serverpb.DetailsResponse} DetailsResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                DetailsResponse.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a DetailsResponse message.
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {?string} `null` if valid, otherwise the reason why it is not
                 */
                DetailsResponse.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.node_id != null && message.hasOwnProperty("node_id"))
                        if (!$util.isInteger(message.node_id))
                            return "node_id: integer expected";
                    if (message.address != null && message.hasOwnProperty("address")) {
                        let error = $root.cockroach.util.UnresolvedAddr.verify(message.address);
                        if (error)
                            return "address." + error;
                    }
                    if (message.build_info != null && message.hasOwnProperty("build_info")) {
                        let error = $root.cockroach.build.Info.verify(message.build_info);
                        if (error)
                            return "build_info." + error;
                    }
                    return null;
                };

                /**
                 * Creates a DetailsResponse message from a plain object. Also converts values to their respective internal types.
                 * @param {Object.<string,*>} object Plain object
                 * @returns {cockroach.server.serverpb.DetailsResponse} DetailsResponse
                 */
                DetailsResponse.fromObject = function fromObject(object) {
                    if (object instanceof $root.cockroach.server.serverpb.DetailsResponse)
                        return object;
                    let message = new $root.cockroach.server.serverpb.DetailsResponse();
                    if (object.node_id != null)
                        message.node_id = object.node_id | 0;
                    if (object.address != null) {
                        if (typeof object.address !== "object")
                            throw TypeError(".cockroach.server.serverpb.DetailsResponse.address: object expected");
                        message.address = $root.cockroach.util.UnresolvedAddr.fromObject(object.address);
                    }
                    if (object.build_info != null) {
                        if (typeof object.build_info !== "object")
                            throw TypeError(".cockroach.server.serverpb.DetailsResponse.build_info: object expected");
                        message.build_info = $root.cockroach.build.Info.fromObject(object.build_info);
                    }
                    return message;
                };

                /**
                 * Creates a DetailsResponse message from a plain object. Also converts values to their respective internal types.
                 * This is an alias of {@link cockroach.server.serverpb.DetailsResponse.fromObject}.
                 * @function
                 * @param {Object.<string,*>} object Plain object
                 * @returns {cockroach.server.serverpb.DetailsResponse} DetailsResponse
                 */
                DetailsResponse.from = DetailsResponse.fromObject;

                /**
                 * Creates a plain object from a DetailsResponse message. Also converts values to other types if specified.
                 * @param {cockroach.server.serverpb.DetailsResponse} message DetailsResponse
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                DetailsResponse.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.node_id = 0;
                        object.address = null;
                        object.build_info = null;
                    }
                    if (message.node_id != null && message.hasOwnProperty("node_id"))
                        object.node_id = message.node_id;
                    if (message.address != null && message.hasOwnProperty("address"))
                        object.address = $root.cockroach.util.UnresolvedAddr.toObject(message.address, options);
                    if (message.build_info != null && message.hasOwnProperty("build_info"))
                        object.build_info = $root.cockroach.build.Info.toObject(message.build_info, options);
                    return object;
                };

                /**
                 * Creates a plain object from this DetailsResponse message. Also converts values to other types if specified.
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                DetailsResponse.prototype.toObject = function toObject(options) {
                    return this.constructor.toObject(this, options);
                };

                /**
                 * Converts this DetailsResponse to JSON.
                 * @returns {Object.<string,*>} JSON object
                 */
                DetailsResponse.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return DetailsResponse;
            })();

            serverpb.NodesRequest = (function() {

                /**
                 * Properties of a NodesRequest.
                 * @typedef cockroach.server.serverpb.NodesRequest$Properties
                 * @type {Object}
                 */

                /**
                 * Constructs a new NodesRequest.
                 * @exports cockroach.server.serverpb.NodesRequest
                 * @constructor
                 * @param {cockroach.server.serverpb.NodesRequest$Properties=} [properties] Properties to set
                 */
                function NodesRequest(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Creates a new NodesRequest instance using the specified properties.
                 * @param {cockroach.server.serverpb.NodesRequest$Properties=} [properties] Properties to set
                 * @returns {cockroach.server.serverpb.NodesRequest} NodesRequest instance
                 */
                NodesRequest.create = function create(properties) {
                    return new NodesRequest(properties);
                };

                /**
                 * Encodes the specified NodesRequest message. Does not implicitly {@link cockroach.server.serverpb.NodesRequest.verify|verify} messages.
                 * @param {cockroach.server.serverpb.NodesRequest$Properties} message NodesRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                NodesRequest.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    return writer;
                };

                /**
                 * Encodes the specified NodesRequest message, length delimited. Does not implicitly {@link cockroach.server.serverpb.NodesRequest.verify|verify} messages.
                 * @param {cockroach.server.serverpb.NodesRequest$Properties} message NodesRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                NodesRequest.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a NodesRequest message from the specified reader or buffer.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {cockroach.server.serverpb.NodesRequest} NodesRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                NodesRequest.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.cockroach.server.serverpb.NodesRequest();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a NodesRequest message from the specified reader or buffer, length delimited.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {cockroach.server.serverpb.NodesRequest} NodesRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                NodesRequest.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a NodesRequest message.
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {?string} `null` if valid, otherwise the reason why it is not
                 */
                NodesRequest.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    return null;
                };

                /**
                 * Creates a NodesRequest message from a plain object. Also converts values to their respective internal types.
                 * @param {Object.<string,*>} object Plain object
                 * @returns {cockroach.server.serverpb.NodesRequest} NodesRequest
                 */
                NodesRequest.fromObject = function fromObject(object) {
                    if (object instanceof $root.cockroach.server.serverpb.NodesRequest)
                        return object;
                    return new $root.cockroach.server.serverpb.NodesRequest();
                };

                /**
                 * Creates a NodesRequest message from a plain object. Also converts values to their respective internal types.
                 * This is an alias of {@link cockroach.server.serverpb.NodesRequest.fromObject}.
                 * @function
                 * @param {Object.<string,*>} object Plain object
                 * @returns {cockroach.server.serverpb.NodesRequest} NodesRequest
                 */
                NodesRequest.from = NodesRequest.fromObject;

                /**
                 * Creates a plain object from a NodesRequest message. Also converts values to other types if specified.
                 * @param {cockroach.server.serverpb.NodesRequest} message NodesRequest
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                NodesRequest.toObject = function toObject() {
                    return {};
                };

                /**
                 * Creates a plain object from this NodesRequest message. Also converts values to other types if specified.
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                NodesRequest.prototype.toObject = function toObject(options) {
                    return this.constructor.toObject(this, options);
                };

                /**
                 * Converts this NodesRequest to JSON.
                 * @returns {Object.<string,*>} JSON object
                 */
                NodesRequest.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return NodesRequest;
            })();

            serverpb.NodesResponse = (function() {

                /**
                 * Properties of a NodesResponse.
                 * @typedef cockroach.server.serverpb.NodesResponse$Properties
                 * @type {Object}
                 * @property {Array.<cockroach.server.status.NodeStatus$Properties>} [nodes] NodesResponse nodes.
                 */

                /**
                 * Constructs a new NodesResponse.
                 * @exports cockroach.server.serverpb.NodesResponse
                 * @constructor
                 * @param {cockroach.server.serverpb.NodesResponse$Properties=} [properties] Properties to set
                 */
                function NodesResponse(properties) {
                    this.nodes = [];
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * NodesResponse nodes.
                 * @type {Array.<cockroach.server.status.NodeStatus$Properties>}
                 */
                NodesResponse.prototype.nodes = $util.emptyArray;

                /**
                 * Creates a new NodesResponse instance using the specified properties.
                 * @param {cockroach.server.serverpb.NodesResponse$Properties=} [properties] Properties to set
                 * @returns {cockroach.server.serverpb.NodesResponse} NodesResponse instance
                 */
                NodesResponse.create = function create(properties) {
                    return new NodesResponse(properties);
                };

                /**
                 * Encodes the specified NodesResponse message. Does not implicitly {@link cockroach.server.serverpb.NodesResponse.verify|verify} messages.
                 * @param {cockroach.server.serverpb.NodesResponse$Properties} message NodesResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                NodesResponse.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.nodes != null && message.nodes.length)
                        for (let i = 0; i < message.nodes.length; ++i)
                            $root.cockroach.server.status.NodeStatus.encode(message.nodes[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified NodesResponse message, length delimited. Does not implicitly {@link cockroach.server.serverpb.NodesResponse.verify|verify} messages.
                 * @param {cockroach.server.serverpb.NodesResponse$Properties} message NodesResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                NodesResponse.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a NodesResponse message from the specified reader or buffer.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {cockroach.server.serverpb.NodesResponse} NodesResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                NodesResponse.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.cockroach.server.serverpb.NodesResponse();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (!(message.nodes && message.nodes.length))
                                message.nodes = [];
                            message.nodes.push($root.cockroach.server.status.NodeStatus.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a NodesResponse message from the specified reader or buffer, length delimited.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {cockroach.server.serverpb.NodesResponse} NodesResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                NodesResponse.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a NodesResponse message.
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {?string} `null` if valid, otherwise the reason why it is not
                 */
                NodesResponse.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.nodes != null && message.hasOwnProperty("nodes")) {
                        if (!Array.isArray(message.nodes))
                            return "nodes: array expected";
                        for (let i = 0; i < message.nodes.length; ++i) {
                            let error = $root.cockroach.server.status.NodeStatus.verify(message.nodes[i]);
                            if (error)
                                return "nodes." + error;
                        }
                    }
                    return null;
                };

                /**
                 * Creates a NodesResponse message from a plain object. Also converts values to their respective internal types.
                 * @param {Object.<string,*>} object Plain object
                 * @returns {cockroach.server.serverpb.NodesResponse} NodesResponse
                 */
                NodesResponse.fromObject = function fromObject(object) {
                    if (object instanceof $root.cockroach.server.serverpb.NodesResponse)
                        return object;
                    let message = new $root.cockroach.server.serverpb.NodesResponse();
                    if (object.nodes) {
                        if (!Array.isArray(object.nodes))
                            throw TypeError(".cockroach.server.serverpb.NodesResponse.nodes: array expected");
                        message.nodes = [];
                        for (let i = 0; i < object.nodes.length; ++i) {
                            if (typeof object.nodes[i] !== "object")
                                throw TypeError(".cockroach.server.serverpb.NodesResponse.nodes: object expected");
                            message.nodes[i] = $root.cockroach.server.status.NodeStatus.fromObject(object.nodes[i]);
                        }
                    }
                    return message;
                };

                /**
                 * Creates a NodesResponse message from a plain object. Also converts values to their respective internal types.
                 * This is an alias of {@link cockroach.server.serverpb.NodesResponse.fromObject}.
                 * @function
                 * @param {Object.<string,*>} object Plain object
                 * @returns {cockroach.server.serverpb.NodesResponse} NodesResponse
                 */
                NodesResponse.from = NodesResponse.fromObject;

                /**
                 * Creates a plain object from a NodesResponse message. Also converts values to other types if specified.
                 * @param {cockroach.server.serverpb.NodesResponse} message NodesResponse
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                NodesResponse.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.arrays || options.defaults)
                        object.nodes = [];
                    if (message.nodes && message.nodes.length) {
                        object.nodes = [];
                        for (let j = 0; j < message.nodes.length; ++j)
                            object.nodes[j] = $root.cockroach.server.status.NodeStatus.toObject(message.nodes[j], options);
                    }
                    return object;
                };

                /**
                 * Creates a plain object from this NodesResponse message. Also converts values to other types if specified.
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                NodesResponse.prototype.toObject = function toObject(options) {
                    return this.constructor.toObject(this, options);
                };

                /**
                 * Converts this NodesResponse to JSON.
                 * @returns {Object.<string,*>} JSON object
                 */
                NodesResponse.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return NodesResponse;
            })();

            serverpb.NodeRequest = (function() {

                /**
                 * Properties of a NodeRequest.
                 * @typedef cockroach.server.serverpb.NodeRequest$Properties
                 * @type {Object}
                 * @property {string} [node_id] NodeRequest node_id.
                 */

                /**
                 * Constructs a new NodeRequest.
                 * @exports cockroach.server.serverpb.NodeRequest
                 * @constructor
                 * @param {cockroach.server.serverpb.NodeRequest$Properties=} [properties] Properties to set
                 */
                function NodeRequest(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * NodeRequest node_id.
                 * @type {string}
                 */
                NodeRequest.prototype.node_id = "";

                /**
                 * Creates a new NodeRequest instance using the specified properties.
                 * @param {cockroach.server.serverpb.NodeRequest$Properties=} [properties] Properties to set
                 * @returns {cockroach.server.serverpb.NodeRequest} NodeRequest instance
                 */
                NodeRequest.create = function create(properties) {
                    return new NodeRequest(properties);
                };

                /**
                 * Encodes the specified NodeRequest message. Does not implicitly {@link cockroach.server.serverpb.NodeRequest.verify|verify} messages.
                 * @param {cockroach.server.serverpb.NodeRequest$Properties} message NodeRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                NodeRequest.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.node_id != null && message.hasOwnProperty("node_id"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.node_id);
                    return writer;
                };

                /**
                 * Encodes the specified NodeRequest message, length delimited. Does not implicitly {@link cockroach.server.serverpb.NodeRequest.verify|verify} messages.
                 * @param {cockroach.server.serverpb.NodeRequest$Properties} message NodeRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                NodeRequest.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a NodeRequest message from the specified reader or buffer.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {cockroach.server.serverpb.NodeRequest} NodeRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                NodeRequest.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.cockroach.server.serverpb.NodeRequest();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.node_id = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a NodeRequest message from the specified reader or buffer, length delimited.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {cockroach.server.serverpb.NodeRequest} NodeRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                NodeRequest.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a NodeRequest message.
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {?string} `null` if valid, otherwise the reason why it is not
                 */
                NodeRequest.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.node_id != null && message.hasOwnProperty("node_id"))
                        if (!$util.isString(message.node_id))
                            return "node_id: string expected";
                    return null;
                };

                /**
                 * Creates a NodeRequest message from a plain object. Also converts values to their respective internal types.
                 * @param {Object.<string,*>} object Plain object
                 * @returns {cockroach.server.serverpb.NodeRequest} NodeRequest
                 */
                NodeRequest.fromObject = function fromObject(object) {
                    if (object instanceof $root.cockroach.server.serverpb.NodeRequest)
                        return object;
                    let message = new $root.cockroach.server.serverpb.NodeRequest();
                    if (object.node_id != null)
                        message.node_id = String(object.node_id);
                    return message;
                };

                /**
                 * Creates a NodeRequest message from a plain object. Also converts values to their respective internal types.
                 * This is an alias of {@link cockroach.server.serverpb.NodeRequest.fromObject}.
                 * @function
                 * @param {Object.<string,*>} object Plain object
                 * @returns {cockroach.server.serverpb.NodeRequest} NodeRequest
                 */
                NodeRequest.from = NodeRequest.fromObject;

                /**
                 * Creates a plain object from a NodeRequest message. Also converts values to other types if specified.
                 * @param {cockroach.server.serverpb.NodeRequest} message NodeRequest
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                NodeRequest.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults)
                        object.node_id = "";
                    if (message.node_id != null && message.hasOwnProperty("node_id"))
                        object.node_id = message.node_id;
                    return object;
                };

                /**
                 * Creates a plain object from this NodeRequest message. Also converts values to other types if specified.
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                NodeRequest.prototype.toObject = function toObject(options) {
                    return this.constructor.toObject(this, options);
                };

                /**
                 * Converts this NodeRequest to JSON.
                 * @returns {Object.<string,*>} JSON object
                 */
                NodeRequest.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return NodeRequest;
            })();

            serverpb.RaftState = (function() {

                /**
                 * Properties of a RaftState.
                 * @typedef cockroach.server.serverpb.RaftState$Properties
                 * @type {Object}
                 * @property {Long} [replica_id] RaftState replica_id.
                 * @property {raftpb.HardState$Properties} [hard_state] RaftState hard_state.
                 * @property {Long} [lead] RaftState lead.
                 * @property {string} [state] RaftState state.
                 * @property {Long} [applied] RaftState applied.
                 * @property {Object.<string,cockroach.server.serverpb.RaftState.Progress$Properties>} [progress] RaftState progress.
                 */

                /**
                 * Constructs a new RaftState.
                 * @exports cockroach.server.serverpb.RaftState
                 * @constructor
                 * @param {cockroach.server.serverpb.RaftState$Properties=} [properties] Properties to set
                 */
                function RaftState(properties) {
                    this.progress = {};
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * RaftState replica_id.
                 * @type {Long}
                 */
                RaftState.prototype.replica_id = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

                /**
                 * RaftState hard_state.
                 * @type {(raftpb.HardState$Properties|null)}
                 */
                RaftState.prototype.hard_state = null;

                /**
                 * RaftState lead.
                 * @type {Long}
                 */
                RaftState.prototype.lead = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

                /**
                 * RaftState state.
                 * @type {string}
                 */
                RaftState.prototype.state = "";

                /**
                 * RaftState applied.
                 * @type {Long}
                 */
                RaftState.prototype.applied = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

                /**
                 * RaftState progress.
                 * @type {Object.<string,cockroach.server.serverpb.RaftState.Progress$Properties>}
                 */
                RaftState.prototype.progress = $util.emptyObject;

                /**
                 * Creates a new RaftState instance using the specified properties.
                 * @param {cockroach.server.serverpb.RaftState$Properties=} [properties] Properties to set
                 * @returns {cockroach.server.serverpb.RaftState} RaftState instance
                 */
                RaftState.create = function create(properties) {
                    return new RaftState(properties);
                };

                /**
                 * Encodes the specified RaftState message. Does not implicitly {@link cockroach.server.serverpb.RaftState.verify|verify} messages.
                 * @param {cockroach.server.serverpb.RaftState$Properties} message RaftState message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                RaftState.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.replica_id != null && message.hasOwnProperty("replica_id"))
                        writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.replica_id);
                    if (message.hard_state != null && message.hasOwnProperty("hard_state"))
                        $root.raftpb.HardState.encode(message.hard_state, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.lead != null && message.hasOwnProperty("lead"))
                        writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.lead);
                    if (message.state != null && message.hasOwnProperty("state"))
                        writer.uint32(/* id 4, wireType 2 =*/34).string(message.state);
                    if (message.applied != null && message.hasOwnProperty("applied"))
                        writer.uint32(/* id 5, wireType 0 =*/40).uint64(message.applied);
                    if (message.progress != null && message.hasOwnProperty("progress"))
                        for (let keys = Object.keys(message.progress), i = 0; i < keys.length; ++i) {
                            writer.uint32(/* id 6, wireType 2 =*/50).fork().uint32(/* id 1, wireType 0 =*/8).uint64(keys[i]);
                            $root.cockroach.server.serverpb.RaftState.Progress.encode(message.progress[keys[i]], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim().ldelim();
                        }
                    return writer;
                };

                /**
                 * Encodes the specified RaftState message, length delimited. Does not implicitly {@link cockroach.server.serverpb.RaftState.verify|verify} messages.
                 * @param {cockroach.server.serverpb.RaftState$Properties} message RaftState message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                RaftState.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a RaftState message from the specified reader or buffer.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {cockroach.server.serverpb.RaftState} RaftState
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                RaftState.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.cockroach.server.serverpb.RaftState(), key;
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.replica_id = reader.uint64();
                            break;
                        case 2:
                            message.hard_state = $root.raftpb.HardState.decode(reader, reader.uint32());
                            break;
                        case 3:
                            message.lead = reader.uint64();
                            break;
                        case 4:
                            message.state = reader.string();
                            break;
                        case 5:
                            message.applied = reader.uint64();
                            break;
                        case 6:
                            reader.skip().pos++;
                            if (message.progress === $util.emptyObject)
                                message.progress = {};
                            key = reader.uint64();
                            reader.pos++;
                            message.progress[typeof key === "object" ? $util.longToHash(key) : key] = $root.cockroach.server.serverpb.RaftState.Progress.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a RaftState message from the specified reader or buffer, length delimited.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {cockroach.server.serverpb.RaftState} RaftState
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                RaftState.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a RaftState message.
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {?string} `null` if valid, otherwise the reason why it is not
                 */
                RaftState.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.replica_id != null && message.hasOwnProperty("replica_id"))
                        if (!$util.isInteger(message.replica_id) && !(message.replica_id && $util.isInteger(message.replica_id.low) && $util.isInteger(message.replica_id.high)))
                            return "replica_id: integer|Long expected";
                    if (message.hard_state != null && message.hasOwnProperty("hard_state")) {
                        let error = $root.raftpb.HardState.verify(message.hard_state);
                        if (error)
                            return "hard_state." + error;
                    }
                    if (message.lead != null && message.hasOwnProperty("lead"))
                        if (!$util.isInteger(message.lead) && !(message.lead && $util.isInteger(message.lead.low) && $util.isInteger(message.lead.high)))
                            return "lead: integer|Long expected";
                    if (message.state != null && message.hasOwnProperty("state"))
                        if (!$util.isString(message.state))
                            return "state: string expected";
                    if (message.applied != null && message.hasOwnProperty("applied"))
                        if (!$util.isInteger(message.applied) && !(message.applied && $util.isInteger(message.applied.low) && $util.isInteger(message.applied.high)))
                            return "applied: integer|Long expected";
                    if (message.progress != null && message.hasOwnProperty("progress")) {
                        if (!$util.isObject(message.progress))
                            return "progress: object expected";
                        let key = Object.keys(message.progress);
                        for (let i = 0; i < key.length; ++i) {
                            if (!$util.key64Re.test(key[i]))
                                return "progress: integer|Long key{k:uint64} expected";
                            let error = $root.cockroach.server.serverpb.RaftState.Progress.verify(message.progress[key[i]]);
                            if (error)
                                return "progress." + error;
                        }
                    }
                    return null;
                };

                /**
                 * Creates a RaftState message from a plain object. Also converts values to their respective internal types.
                 * @param {Object.<string,*>} object Plain object
                 * @returns {cockroach.server.serverpb.RaftState} RaftState
                 */
                RaftState.fromObject = function fromObject(object) {
                    if (object instanceof $root.cockroach.server.serverpb.RaftState)
                        return object;
                    let message = new $root.cockroach.server.serverpb.RaftState();
                    if (object.replica_id != null)
                        if ($util.Long)
                            (message.replica_id = $util.Long.fromValue(object.replica_id)).unsigned = true;
                        else if (typeof object.replica_id === "string")
                            message.replica_id = parseInt(object.replica_id, 10);
                        else if (typeof object.replica_id === "number")
                            message.replica_id = object.replica_id;
                        else if (typeof object.replica_id === "object")
                            message.replica_id = new $util.LongBits(object.replica_id.low >>> 0, object.replica_id.high >>> 0).toNumber(true);
                    if (object.hard_state != null) {
                        if (typeof object.hard_state !== "object")
                            throw TypeError(".cockroach.server.serverpb.RaftState.hard_state: object expected");
                        message.hard_state = $root.raftpb.HardState.fromObject(object.hard_state);
                    }
                    if (object.lead != null)
                        if ($util.Long)
                            (message.lead = $util.Long.fromValue(object.lead)).unsigned = true;
                        else if (typeof object.lead === "string")
                            message.lead = parseInt(object.lead, 10);
                        else if (typeof object.lead === "number")
                            message.lead = object.lead;
                        else if (typeof object.lead === "object")
                            message.lead = new $util.LongBits(object.lead.low >>> 0, object.lead.high >>> 0).toNumber(true);
                    if (object.state != null)
                        message.state = String(object.state);
                    if (object.applied != null)
                        if ($util.Long)
                            (message.applied = $util.Long.fromValue(object.applied)).unsigned = true;
                        else if (typeof object.applied === "string")
                            message.applied = parseInt(object.applied, 10);
                        else if (typeof object.applied === "number")
                            message.applied = object.applied;
                        else if (typeof object.applied === "object")
                            message.applied = new $util.LongBits(object.applied.low >>> 0, object.applied.high >>> 0).toNumber(true);
                    if (object.progress) {
                        if (typeof object.progress !== "object")
                            throw TypeError(".cockroach.server.serverpb.RaftState.progress: object expected");
                        message.progress = {};
                        for (let keys = Object.keys(object.progress), i = 0; i < keys.length; ++i) {
                            if (typeof object.progress[keys[i]] !== "object")
                                throw TypeError(".cockroach.server.serverpb.RaftState.progress: object expected");
                            message.progress[keys[i]] = $root.cockroach.server.serverpb.RaftState.Progress.fromObject(object.progress[keys[i]]);
                        }
                    }
                    return message;
                };

                /**
                 * Creates a RaftState message from a plain object. Also converts values to their respective internal types.
                 * This is an alias of {@link cockroach.server.serverpb.RaftState.fromObject}.
                 * @function
                 * @param {Object.<string,*>} object Plain object
                 * @returns {cockroach.server.serverpb.RaftState} RaftState
                 */
                RaftState.from = RaftState.fromObject;

                /**
                 * Creates a plain object from a RaftState message. Also converts values to other types if specified.
                 * @param {cockroach.server.serverpb.RaftState} message RaftState
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                RaftState.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.objects || options.defaults)
                        object.progress = {};
                    if (options.defaults) {
                        if ($util.Long) {
                            let long = new $util.Long(0, 0, true);
                            object.replica_id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.replica_id = options.longs === String ? "0" : 0;
                        object.hard_state = null;
                        if ($util.Long) {
                            let long = new $util.Long(0, 0, true);
                            object.lead = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.lead = options.longs === String ? "0" : 0;
                        object.state = "";
                        if ($util.Long) {
                            let long = new $util.Long(0, 0, true);
                            object.applied = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.applied = options.longs === String ? "0" : 0;
                    }
                    if (message.replica_id != null && message.hasOwnProperty("replica_id"))
                        if (typeof message.replica_id === "number")
                            object.replica_id = options.longs === String ? String(message.replica_id) : message.replica_id;
                        else
                            object.replica_id = options.longs === String ? $util.Long.prototype.toString.call(message.replica_id) : options.longs === Number ? new $util.LongBits(message.replica_id.low >>> 0, message.replica_id.high >>> 0).toNumber(true) : message.replica_id;
                    if (message.hard_state != null && message.hasOwnProperty("hard_state"))
                        object.hard_state = $root.raftpb.HardState.toObject(message.hard_state, options);
                    if (message.lead != null && message.hasOwnProperty("lead"))
                        if (typeof message.lead === "number")
                            object.lead = options.longs === String ? String(message.lead) : message.lead;
                        else
                            object.lead = options.longs === String ? $util.Long.prototype.toString.call(message.lead) : options.longs === Number ? new $util.LongBits(message.lead.low >>> 0, message.lead.high >>> 0).toNumber(true) : message.lead;
                    if (message.state != null && message.hasOwnProperty("state"))
                        object.state = message.state;
                    if (message.applied != null && message.hasOwnProperty("applied"))
                        if (typeof message.applied === "number")
                            object.applied = options.longs === String ? String(message.applied) : message.applied;
                        else
                            object.applied = options.longs === String ? $util.Long.prototype.toString.call(message.applied) : options.longs === Number ? new $util.LongBits(message.applied.low >>> 0, message.applied.high >>> 0).toNumber(true) : message.applied;
                    let keys2;
                    if (message.progress && (keys2 = Object.keys(message.progress)).length) {
                        object.progress = {};
                        for (let j = 0; j < keys2.length; ++j)
                            object.progress[keys2[j]] = $root.cockroach.server.serverpb.RaftState.Progress.toObject(message.progress[keys2[j]], options);
                    }
                    return object;
                };

                /**
                 * Creates a plain object from this RaftState message. Also converts values to other types if specified.
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                RaftState.prototype.toObject = function toObject(options) {
                    return this.constructor.toObject(this, options);
                };

                /**
                 * Converts this RaftState to JSON.
                 * @returns {Object.<string,*>} JSON object
                 */
                RaftState.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                RaftState.Progress = (function() {

                    /**
                     * Properties of a Progress.
                     * @typedef cockroach.server.serverpb.RaftState.Progress$Properties
                     * @type {Object}
                     * @property {Long} [match] Progress match.
                     * @property {Long} [next] Progress next.
                     * @property {string} [state] Progress state.
                     * @property {boolean} [paused] Progress paused.
                     * @property {Long} [pending_snapshot] Progress pending_snapshot.
                     */

                    /**
                     * Constructs a new Progress.
                     * @exports cockroach.server.serverpb.RaftState.Progress
                     * @constructor
                     * @param {cockroach.server.serverpb.RaftState.Progress$Properties=} [properties] Properties to set
                     */
                    function Progress(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * Progress match.
                     * @type {Long}
                     */
                    Progress.prototype.match = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

                    /**
                     * Progress next.
                     * @type {Long}
                     */
                    Progress.prototype.next = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

                    /**
                     * Progress state.
                     * @type {string}
                     */
                    Progress.prototype.state = "";

                    /**
                     * Progress paused.
                     * @type {boolean}
                     */
                    Progress.prototype.paused = false;

                    /**
                     * Progress pending_snapshot.
                     * @type {Long}
                     */
                    Progress.prototype.pending_snapshot = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

                    /**
                     * Creates a new Progress instance using the specified properties.
                     * @param {cockroach.server.serverpb.RaftState.Progress$Properties=} [properties] Properties to set
                     * @returns {cockroach.server.serverpb.RaftState.Progress} Progress instance
                     */
                    Progress.create = function create(properties) {
                        return new Progress(properties);
                    };

                    /**
                     * Encodes the specified Progress message. Does not implicitly {@link cockroach.server.serverpb.RaftState.Progress.verify|verify} messages.
                     * @param {cockroach.server.serverpb.RaftState.Progress$Properties} message Progress message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Progress.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.match != null && message.hasOwnProperty("match"))
                            writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.match);
                        if (message.next != null && message.hasOwnProperty("next"))
                            writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.next);
                        if (message.state != null && message.hasOwnProperty("state"))
                            writer.uint32(/* id 3, wireType 2 =*/26).string(message.state);
                        if (message.paused != null && message.hasOwnProperty("paused"))
                            writer.uint32(/* id 4, wireType 0 =*/32).bool(message.paused);
                        if (message.pending_snapshot != null && message.hasOwnProperty("pending_snapshot"))
                            writer.uint32(/* id 5, wireType 0 =*/40).uint64(message.pending_snapshot);
                        return writer;
                    };

                    /**
                     * Encodes the specified Progress message, length delimited. Does not implicitly {@link cockroach.server.serverpb.RaftState.Progress.verify|verify} messages.
                     * @param {cockroach.server.serverpb.RaftState.Progress$Properties} message Progress message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Progress.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a Progress message from the specified reader or buffer.
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {cockroach.server.serverpb.RaftState.Progress} Progress
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Progress.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.cockroach.server.serverpb.RaftState.Progress();
                        while (reader.pos < end) {
                            let tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.match = reader.uint64();
                                break;
                            case 2:
                                message.next = reader.uint64();
                                break;
                            case 3:
                                message.state = reader.string();
                                break;
                            case 4:
                                message.paused = reader.bool();
                                break;
                            case 5:
                                message.pending_snapshot = reader.uint64();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a Progress message from the specified reader or buffer, length delimited.
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {cockroach.server.serverpb.RaftState.Progress} Progress
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Progress.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a Progress message.
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {?string} `null` if valid, otherwise the reason why it is not
                     */
                    Progress.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.match != null && message.hasOwnProperty("match"))
                            if (!$util.isInteger(message.match) && !(message.match && $util.isInteger(message.match.low) && $util.isInteger(message.match.high)))
                                return "match: integer|Long expected";
                        if (message.next != null && message.hasOwnProperty("next"))
                            if (!$util.isInteger(message.next) && !(message.next && $util.isInteger(message.next.low) && $util.isInteger(message.next.high)))
                                return "next: integer|Long expected";
                        if (message.state != null && message.hasOwnProperty("state"))
                            if (!$util.isString(message.state))
                                return "state: string expected";
                        if (message.paused != null && message.hasOwnProperty("paused"))
                            if (typeof message.paused !== "boolean")
                                return "paused: boolean expected";
                        if (message.pending_snapshot != null && message.hasOwnProperty("pending_snapshot"))
                            if (!$util.isInteger(message.pending_snapshot) && !(message.pending_snapshot && $util.isInteger(message.pending_snapshot.low) && $util.isInteger(message.pending_snapshot.high)))
                                return "pending_snapshot: integer|Long expected";
                        return null;
                    };

                    /**
                     * Creates a Progress message from a plain object. Also converts values to their respective internal types.
                     * @param {Object.<string,*>} object Plain object
                     * @returns {cockroach.server.serverpb.RaftState.Progress} Progress
                     */
                    Progress.fromObject = function fromObject(object) {
                        if (object instanceof $root.cockroach.server.serverpb.RaftState.Progress)
                            return object;
                        let message = new $root.cockroach.server.serverpb.RaftState.Progress();
                        if (object.match != null)
                            if ($util.Long)
                                (message.match = $util.Long.fromValue(object.match)).unsigned = true;
                            else if (typeof object.match === "string")
                                message.match = parseInt(object.match, 10);
                            else if (typeof object.match === "number")
                                message.match = object.match;
                            else if (typeof object.match === "object")
                                message.match = new $util.LongBits(object.match.low >>> 0, object.match.high >>> 0).toNumber(true);
                        if (object.next != null)
                            if ($util.Long)
                                (message.next = $util.Long.fromValue(object.next)).unsigned = true;
                            else if (typeof object.next === "string")
                                message.next = parseInt(object.next, 10);
                            else if (typeof object.next === "number")
                                message.next = object.next;
                            else if (typeof object.next === "object")
                                message.next = new $util.LongBits(object.next.low >>> 0, object.next.high >>> 0).toNumber(true);
                        if (object.state != null)
                            message.state = String(object.state);
                        if (object.paused != null)
                            message.paused = Boolean(object.paused);
                        if (object.pending_snapshot != null)
                            if ($util.Long)
                                (message.pending_snapshot = $util.Long.fromValue(object.pending_snapshot)).unsigned = true;
                            else if (typeof object.pending_snapshot === "string")
                                message.pending_snapshot = parseInt(object.pending_snapshot, 10);
                            else if (typeof object.pending_snapshot === "number")
                                message.pending_snapshot = object.pending_snapshot;
                            else if (typeof object.pending_snapshot === "object")
                                message.pending_snapshot = new $util.LongBits(object.pending_snapshot.low >>> 0, object.pending_snapshot.high >>> 0).toNumber(true);
                        return message;
                    };

                    /**
                     * Creates a Progress message from a plain object. Also converts values to their respective internal types.
                     * This is an alias of {@link cockroach.server.serverpb.RaftState.Progress.fromObject}.
                     * @function
                     * @param {Object.<string,*>} object Plain object
                     * @returns {cockroach.server.serverpb.RaftState.Progress} Progress
                     */
                    Progress.from = Progress.fromObject;

                    /**
                     * Creates a plain object from a Progress message. Also converts values to other types if specified.
                     * @param {cockroach.server.serverpb.RaftState.Progress} message Progress
                     * @param {$protobuf.ConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Progress.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.defaults) {
                            if ($util.Long) {
                                let long = new $util.Long(0, 0, true);
                                object.match = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.match = options.longs === String ? "0" : 0;
                            if ($util.Long) {
                                let long = new $util.Long(0, 0, true);
                                object.next = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.next = options.longs === String ? "0" : 0;
                            object.state = "";
                            object.paused = false;
                            if ($util.Long) {
                                let long = new $util.Long(0, 0, true);
                                object.pending_snapshot = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.pending_snapshot = options.longs === String ? "0" : 0;
                        }
                        if (message.match != null && message.hasOwnProperty("match"))
                            if (typeof message.match === "number")
                                object.match = options.longs === String ? String(message.match) : message.match;
                            else
                                object.match = options.longs === String ? $util.Long.prototype.toString.call(message.match) : options.longs === Number ? new $util.LongBits(message.match.low >>> 0, message.match.high >>> 0).toNumber(true) : message.match;
                        if (message.next != null && message.hasOwnProperty("next"))
                            if (typeof message.next === "number")
                                object.next = options.longs === String ? String(message.next) : message.next;
                            else
                                object.next = options.longs === String ? $util.Long.prototype.toString.call(message.next) : options.longs === Number ? new $util.LongBits(message.next.low >>> 0, message.next.high >>> 0).toNumber(true) : message.next;
                        if (message.state != null && message.hasOwnProperty("state"))
                            object.state = message.state;
                        if (message.paused != null && message.hasOwnProperty("paused"))
                            object.paused = message.paused;
                        if (message.pending_snapshot != null && message.hasOwnProperty("pending_snapshot"))
                            if (typeof message.pending_snapshot === "number")
                                object.pending_snapshot = options.longs === String ? String(message.pending_snapshot) : message.pending_snapshot;
                            else
                                object.pending_snapshot = options.longs === String ? $util.Long.prototype.toString.call(message.pending_snapshot) : options.longs === Number ? new $util.LongBits(message.pending_snapshot.low >>> 0, message.pending_snapshot.high >>> 0).toNumber(true) : message.pending_snapshot;
                        return object;
                    };

                    /**
                     * Creates a plain object from this Progress message. Also converts values to other types if specified.
                     * @param {$protobuf.ConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Progress.prototype.toObject = function toObject(options) {
                        return this.constructor.toObject(this, options);
                    };

                    /**
                     * Converts this Progress to JSON.
                     * @returns {Object.<string,*>} JSON object
                     */
                    Progress.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return Progress;
                })();

                return RaftState;
            })();

            serverpb.RangeProblems = (function() {

                /**
                 * Properties of a RangeProblems.
                 * @typedef cockroach.server.serverpb.RangeProblems$Properties
                 * @type {Object}
                 * @property {boolean} [unavailable] RangeProblems unavailable.
                 * @property {boolean} [leader_not_lease_holder] RangeProblems leader_not_lease_holder.
                 */

                /**
                 * Constructs a new RangeProblems.
                 * @exports cockroach.server.serverpb.RangeProblems
                 * @constructor
                 * @param {cockroach.server.serverpb.RangeProblems$Properties=} [properties] Properties to set
                 */
                function RangeProblems(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * RangeProblems unavailable.
                 * @type {boolean}
                 */
                RangeProblems.prototype.unavailable = false;

                /**
                 * RangeProblems leader_not_lease_holder.
                 * @type {boolean}
                 */
                RangeProblems.prototype.leader_not_lease_holder = false;

                /**
                 * Creates a new RangeProblems instance using the specified properties.
                 * @param {cockroach.server.serverpb.RangeProblems$Properties=} [properties] Properties to set
                 * @returns {cockroach.server.serverpb.RangeProblems} RangeProblems instance
                 */
                RangeProblems.create = function create(properties) {
                    return new RangeProblems(properties);
                };

                /**
                 * Encodes the specified RangeProblems message. Does not implicitly {@link cockroach.server.serverpb.RangeProblems.verify|verify} messages.
                 * @param {cockroach.server.serverpb.RangeProblems$Properties} message RangeProblems message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                RangeProblems.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.unavailable != null && message.hasOwnProperty("unavailable"))
                        writer.uint32(/* id 1, wireType 0 =*/8).bool(message.unavailable);
                    if (message.leader_not_lease_holder != null && message.hasOwnProperty("leader_not_lease_holder"))
                        writer.uint32(/* id 2, wireType 0 =*/16).bool(message.leader_not_lease_holder);
                    return writer;
                };

                /**
                 * Encodes the specified RangeProblems message, length delimited. Does not implicitly {@link cockroach.server.serverpb.RangeProblems.verify|verify} messages.
                 * @param {cockroach.server.serverpb.RangeProblems$Properties} message RangeProblems message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                RangeProblems.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a RangeProblems message from the specified reader or buffer.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {cockroach.server.serverpb.RangeProblems} RangeProblems
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                RangeProblems.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.cockroach.server.serverpb.RangeProblems();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.unavailable = reader.bool();
                            break;
                        case 2:
                            message.leader_not_lease_holder = reader.bool();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a RangeProblems message from the specified reader or buffer, length delimited.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {cockroach.server.serverpb.RangeProblems} RangeProblems
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                RangeProblems.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a RangeProblems message.
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {?string} `null` if valid, otherwise the reason why it is not
                 */
                RangeProblems.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.unavailable != null && message.hasOwnProperty("unavailable"))
                        if (typeof message.unavailable !== "boolean")
                            return "unavailable: boolean expected";
                    if (message.leader_not_lease_holder != null && message.hasOwnProperty("leader_not_lease_holder"))
                        if (typeof message.leader_not_lease_holder !== "boolean")
                            return "leader_not_lease_holder: boolean expected";
                    return null;
                };

                /**
                 * Creates a RangeProblems message from a plain object. Also converts values to their respective internal types.
                 * @param {Object.<string,*>} object Plain object
                 * @returns {cockroach.server.serverpb.RangeProblems} RangeProblems
                 */
                RangeProblems.fromObject = function fromObject(object) {
                    if (object instanceof $root.cockroach.server.serverpb.RangeProblems)
                        return object;
                    let message = new $root.cockroach.server.serverpb.RangeProblems();
                    if (object.unavailable != null)
                        message.unavailable = Boolean(object.unavailable);
                    if (object.leader_not_lease_holder != null)
                        message.leader_not_lease_holder = Boolean(object.leader_not_lease_holder);
                    return message;
                };

                /**
                 * Creates a RangeProblems message from a plain object. Also converts values to their respective internal types.
                 * This is an alias of {@link cockroach.server.serverpb.RangeProblems.fromObject}.
                 * @function
                 * @param {Object.<string,*>} object Plain object
                 * @returns {cockroach.server.serverpb.RangeProblems} RangeProblems
                 */
                RangeProblems.from = RangeProblems.fromObject;

                /**
                 * Creates a plain object from a RangeProblems message. Also converts values to other types if specified.
                 * @param {cockroach.server.serverpb.RangeProblems} message RangeProblems
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                RangeProblems.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.unavailable = false;
                        object.leader_not_lease_holder = false;
                    }
                    if (message.unavailable != null && message.hasOwnProperty("unavailable"))
                        object.unavailable = message.unavailable;
                    if (message.leader_not_lease_holder != null && message.hasOwnProperty("leader_not_lease_holder"))
                        object.leader_not_lease_holder = message.leader_not_lease_holder;
                    return object;
                };

                /**
                 * Creates a plain object from this RangeProblems message. Also converts values to other types if specified.
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                RangeProblems.prototype.toObject = function toObject(options) {
                    return this.constructor.toObject(this, options);
                };

                /**
                 * Converts this RangeProblems to JSON.
                 * @returns {Object.<string,*>} JSON object
                 */
                RangeProblems.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return RangeProblems;
            })();

            serverpb.RangeInfo = (function() {

                /**
                 * Properties of a RangeInfo.
                 * @typedef cockroach.server.serverpb.RangeInfo$Properties
                 * @type {Object}
                 * @property {cockroach.server.serverpb.PrettySpan$Properties} [span] RangeInfo span.
                 * @property {cockroach.server.serverpb.RaftState$Properties} [raft_state] RangeInfo raft_state.
                 * @property {cockroach.storage.storagebase.RangeInfo$Properties} [state] RangeInfo state.
                 * @property {number} [source_node_id] RangeInfo source_node_id.
                 * @property {number} [source_store_id] RangeInfo source_store_id.
                 * @property {string} [error_message] RangeInfo error_message.
                 * @property {Array.<cockroach.roachpb.Lease$Properties>} [lease_history] RangeInfo lease_history.
                 * @property {cockroach.server.serverpb.RangeProblems$Properties} [problems] RangeInfo problems.
                 */

                /**
                 * Constructs a new RangeInfo.
                 * @exports cockroach.server.serverpb.RangeInfo
                 * @constructor
                 * @param {cockroach.server.serverpb.RangeInfo$Properties=} [properties] Properties to set
                 */
                function RangeInfo(properties) {
                    this.lease_history = [];
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * RangeInfo span.
                 * @type {(cockroach.server.serverpb.PrettySpan$Properties|null)}
                 */
                RangeInfo.prototype.span = null;

                /**
                 * RangeInfo raft_state.
                 * @type {(cockroach.server.serverpb.RaftState$Properties|null)}
                 */
                RangeInfo.prototype.raft_state = null;

                /**
                 * RangeInfo state.
                 * @type {(cockroach.storage.storagebase.RangeInfo$Properties|null)}
                 */
                RangeInfo.prototype.state = null;

                /**
                 * RangeInfo source_node_id.
                 * @type {number}
                 */
                RangeInfo.prototype.source_node_id = 0;

                /**
                 * RangeInfo source_store_id.
                 * @type {number}
                 */
                RangeInfo.prototype.source_store_id = 0;

                /**
                 * RangeInfo error_message.
                 * @type {string}
                 */
                RangeInfo.prototype.error_message = "";

                /**
                 * RangeInfo lease_history.
                 * @type {Array.<cockroach.roachpb.Lease$Properties>}
                 */
                RangeInfo.prototype.lease_history = $util.emptyArray;

                /**
                 * RangeInfo problems.
                 * @type {(cockroach.server.serverpb.RangeProblems$Properties|null)}
                 */
                RangeInfo.prototype.problems = null;

                /**
                 * Creates a new RangeInfo instance using the specified properties.
                 * @param {cockroach.server.serverpb.RangeInfo$Properties=} [properties] Properties to set
                 * @returns {cockroach.server.serverpb.RangeInfo} RangeInfo instance
                 */
                RangeInfo.create = function create(properties) {
                    return new RangeInfo(properties);
                };

                /**
                 * Encodes the specified RangeInfo message. Does not implicitly {@link cockroach.server.serverpb.RangeInfo.verify|verify} messages.
                 * @param {cockroach.server.serverpb.RangeInfo$Properties} message RangeInfo message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                RangeInfo.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.span != null && message.hasOwnProperty("span"))
                        $root.cockroach.server.serverpb.PrettySpan.encode(message.span, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.raft_state != null && message.hasOwnProperty("raft_state"))
                        $root.cockroach.server.serverpb.RaftState.encode(message.raft_state, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.state != null && message.hasOwnProperty("state"))
                        $root.cockroach.storage.storagebase.RangeInfo.encode(message.state, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                    if (message.source_node_id != null && message.hasOwnProperty("source_node_id"))
                        writer.uint32(/* id 5, wireType 0 =*/40).int32(message.source_node_id);
                    if (message.source_store_id != null && message.hasOwnProperty("source_store_id"))
                        writer.uint32(/* id 6, wireType 0 =*/48).int32(message.source_store_id);
                    if (message.error_message != null && message.hasOwnProperty("error_message"))
                        writer.uint32(/* id 7, wireType 2 =*/58).string(message.error_message);
                    if (message.lease_history != null && message.lease_history.length)
                        for (let i = 0; i < message.lease_history.length; ++i)
                            $root.cockroach.roachpb.Lease.encode(message.lease_history[i], writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                    if (message.problems != null && message.hasOwnProperty("problems"))
                        $root.cockroach.server.serverpb.RangeProblems.encode(message.problems, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified RangeInfo message, length delimited. Does not implicitly {@link cockroach.server.serverpb.RangeInfo.verify|verify} messages.
                 * @param {cockroach.server.serverpb.RangeInfo$Properties} message RangeInfo message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                RangeInfo.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a RangeInfo message from the specified reader or buffer.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {cockroach.server.serverpb.RangeInfo} RangeInfo
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                RangeInfo.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.cockroach.server.serverpb.RangeInfo();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.span = $root.cockroach.server.serverpb.PrettySpan.decode(reader, reader.uint32());
                            break;
                        case 2:
                            message.raft_state = $root.cockroach.server.serverpb.RaftState.decode(reader, reader.uint32());
                            break;
                        case 4:
                            message.state = $root.cockroach.storage.storagebase.RangeInfo.decode(reader, reader.uint32());
                            break;
                        case 5:
                            message.source_node_id = reader.int32();
                            break;
                        case 6:
                            message.source_store_id = reader.int32();
                            break;
                        case 7:
                            message.error_message = reader.string();
                            break;
                        case 8:
                            if (!(message.lease_history && message.lease_history.length))
                                message.lease_history = [];
                            message.lease_history.push($root.cockroach.roachpb.Lease.decode(reader, reader.uint32()));
                            break;
                        case 9:
                            message.problems = $root.cockroach.server.serverpb.RangeProblems.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a RangeInfo message from the specified reader or buffer, length delimited.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {cockroach.server.serverpb.RangeInfo} RangeInfo
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                RangeInfo.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a RangeInfo message.
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {?string} `null` if valid, otherwise the reason why it is not
                 */
                RangeInfo.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.span != null && message.hasOwnProperty("span")) {
                        let error = $root.cockroach.server.serverpb.PrettySpan.verify(message.span);
                        if (error)
                            return "span." + error;
                    }
                    if (message.raft_state != null && message.hasOwnProperty("raft_state")) {
                        let error = $root.cockroach.server.serverpb.RaftState.verify(message.raft_state);
                        if (error)
                            return "raft_state." + error;
                    }
                    if (message.state != null && message.hasOwnProperty("state")) {
                        let error = $root.cockroach.storage.storagebase.RangeInfo.verify(message.state);
                        if (error)
                            return "state." + error;
                    }
                    if (message.source_node_id != null && message.hasOwnProperty("source_node_id"))
                        if (!$util.isInteger(message.source_node_id))
                            return "source_node_id: integer expected";
                    if (message.source_store_id != null && message.hasOwnProperty("source_store_id"))
                        if (!$util.isInteger(message.source_store_id))
                            return "source_store_id: integer expected";
                    if (message.error_message != null && message.hasOwnProperty("error_message"))
                        if (!$util.isString(message.error_message))
                            return "error_message: string expected";
                    if (message.lease_history != null && message.hasOwnProperty("lease_history")) {
                        if (!Array.isArray(message.lease_history))
                            return "lease_history: array expected";
                        for (let i = 0; i < message.lease_history.length; ++i) {
                            let error = $root.cockroach.roachpb.Lease.verify(message.lease_history[i]);
                            if (error)
                                return "lease_history." + error;
                        }
                    }
                    if (message.problems != null && message.hasOwnProperty("problems")) {
                        let error = $root.cockroach.server.serverpb.RangeProblems.verify(message.problems);
                        if (error)
                            return "problems." + error;
                    }
                    return null;
                };

                /**
                 * Creates a RangeInfo message from a plain object. Also converts values to their respective internal types.
                 * @param {Object.<string,*>} object Plain object
                 * @returns {cockroach.server.serverpb.RangeInfo} RangeInfo
                 */
                RangeInfo.fromObject = function fromObject(object) {
                    if (object instanceof $root.cockroach.server.serverpb.RangeInfo)
                        return object;
                    let message = new $root.cockroach.server.serverpb.RangeInfo();
                    if (object.span != null) {
                        if (typeof object.span !== "object")
                            throw TypeError(".cockroach.server.serverpb.RangeInfo.span: object expected");
                        message.span = $root.cockroach.server.serverpb.PrettySpan.fromObject(object.span);
                    }
                    if (object.raft_state != null) {
                        if (typeof object.raft_state !== "object")
                            throw TypeError(".cockroach.server.serverpb.RangeInfo.raft_state: object expected");
                        message.raft_state = $root.cockroach.server.serverpb.RaftState.fromObject(object.raft_state);
                    }
                    if (object.state != null) {
                        if (typeof object.state !== "object")
                            throw TypeError(".cockroach.server.serverpb.RangeInfo.state: object expected");
                        message.state = $root.cockroach.storage.storagebase.RangeInfo.fromObject(object.state);
                    }
                    if (object.source_node_id != null)
                        message.source_node_id = object.source_node_id | 0;
                    if (object.source_store_id != null)
                        message.source_store_id = object.source_store_id | 0;
                    if (object.error_message != null)
                        message.error_message = String(object.error_message);
                    if (object.lease_history) {
                        if (!Array.isArray(object.lease_history))
                            throw TypeError(".cockroach.server.serverpb.RangeInfo.lease_history: array expected");
                        message.lease_history = [];
                        for (let i = 0; i < object.lease_history.length; ++i) {
                            if (typeof object.lease_history[i] !== "object")
                                throw TypeError(".cockroach.server.serverpb.RangeInfo.lease_history: object expected");
                            message.lease_history[i] = $root.cockroach.roachpb.Lease.fromObject(object.lease_history[i]);
                        }
                    }
                    if (object.problems != null) {
                        if (typeof object.problems !== "object")
                            throw TypeError(".cockroach.server.serverpb.RangeInfo.problems: object expected");
                        message.problems = $root.cockroach.server.serverpb.RangeProblems.fromObject(object.problems);
                    }
                    return message;
                };

                /**
                 * Creates a RangeInfo message from a plain object. Also converts values to their respective internal types.
                 * This is an alias of {@link cockroach.server.serverpb.RangeInfo.fromObject}.
                 * @function
                 * @param {Object.<string,*>} object Plain object
                 * @returns {cockroach.server.serverpb.RangeInfo} RangeInfo
                 */
                RangeInfo.from = RangeInfo.fromObject;

                /**
                 * Creates a plain object from a RangeInfo message. Also converts values to other types if specified.
                 * @param {cockroach.server.serverpb.RangeInfo} message RangeInfo
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                RangeInfo.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.arrays || options.defaults)
                        object.lease_history = [];
                    if (options.defaults) {
                        object.span = null;
                        object.raft_state = null;
                        object.state = null;
                        object.source_node_id = 0;
                        object.source_store_id = 0;
                        object.error_message = "";
                        object.problems = null;
                    }
                    if (message.span != null && message.hasOwnProperty("span"))
                        object.span = $root.cockroach.server.serverpb.PrettySpan.toObject(message.span, options);
                    if (message.raft_state != null && message.hasOwnProperty("raft_state"))
                        object.raft_state = $root.cockroach.server.serverpb.RaftState.toObject(message.raft_state, options);
                    if (message.state != null && message.hasOwnProperty("state"))
                        object.state = $root.cockroach.storage.storagebase.RangeInfo.toObject(message.state, options);
                    if (message.source_node_id != null && message.hasOwnProperty("source_node_id"))
                        object.source_node_id = message.source_node_id;
                    if (message.source_store_id != null && message.hasOwnProperty("source_store_id"))
                        object.source_store_id = message.source_store_id;
                    if (message.error_message != null && message.hasOwnProperty("error_message"))
                        object.error_message = message.error_message;
                    if (message.lease_history && message.lease_history.length) {
                        object.lease_history = [];
                        for (let j = 0; j < message.lease_history.length; ++j)
                            object.lease_history[j] = $root.cockroach.roachpb.Lease.toObject(message.lease_history[j], options);
                    }
                    if (message.problems != null && message.hasOwnProperty("problems"))
                        object.problems = $root.cockroach.server.serverpb.RangeProblems.toObject(message.problems, options);
                    return object;
                };

                /**
                 * Creates a plain object from this RangeInfo message. Also converts values to other types if specified.
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                RangeInfo.prototype.toObject = function toObject(options) {
                    return this.constructor.toObject(this, options);
                };

                /**
                 * Converts this RangeInfo to JSON.
                 * @returns {Object.<string,*>} JSON object
                 */
                RangeInfo.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return RangeInfo;
            })();

            serverpb.RangesRequest = (function() {

                /**
                 * Properties of a RangesRequest.
                 * @typedef cockroach.server.serverpb.RangesRequest$Properties
                 * @type {Object}
                 * @property {string} [node_id] RangesRequest node_id.
                 * @property {Array.<Long>} [range_ids] RangesRequest range_ids.
                 */

                /**
                 * Constructs a new RangesRequest.
                 * @exports cockroach.server.serverpb.RangesRequest
                 * @constructor
                 * @param {cockroach.server.serverpb.RangesRequest$Properties=} [properties] Properties to set
                 */
                function RangesRequest(properties) {
                    this.range_ids = [];
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * RangesRequest node_id.
                 * @type {string}
                 */
                RangesRequest.prototype.node_id = "";

                /**
                 * RangesRequest range_ids.
                 * @type {Array.<Long>}
                 */
                RangesRequest.prototype.range_ids = $util.emptyArray;

                /**
                 * Creates a new RangesRequest instance using the specified properties.
                 * @param {cockroach.server.serverpb.RangesRequest$Properties=} [properties] Properties to set
                 * @returns {cockroach.server.serverpb.RangesRequest} RangesRequest instance
                 */
                RangesRequest.create = function create(properties) {
                    return new RangesRequest(properties);
                };

                /**
                 * Encodes the specified RangesRequest message. Does not implicitly {@link cockroach.server.serverpb.RangesRequest.verify|verify} messages.
                 * @param {cockroach.server.serverpb.RangesRequest$Properties} message RangesRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                RangesRequest.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.node_id != null && message.hasOwnProperty("node_id"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.node_id);
                    if (message.range_ids != null && message.range_ids.length) {
                        writer.uint32(/* id 2, wireType 2 =*/18).fork();
                        for (let i = 0; i < message.range_ids.length; ++i)
                            writer.int64(message.range_ids[i]);
                        writer.ldelim();
                    }
                    return writer;
                };

                /**
                 * Encodes the specified RangesRequest message, length delimited. Does not implicitly {@link cockroach.server.serverpb.RangesRequest.verify|verify} messages.
                 * @param {cockroach.server.serverpb.RangesRequest$Properties} message RangesRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                RangesRequest.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a RangesRequest message from the specified reader or buffer.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {cockroach.server.serverpb.RangesRequest} RangesRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                RangesRequest.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.cockroach.server.serverpb.RangesRequest();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.node_id = reader.string();
                            break;
                        case 2:
                            if (!(message.range_ids && message.range_ids.length))
                                message.range_ids = [];
                            if ((tag & 7) === 2) {
                                let end2 = reader.uint32() + reader.pos;
                                while (reader.pos < end2)
                                    message.range_ids.push(reader.int64());
                            } else
                                message.range_ids.push(reader.int64());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a RangesRequest message from the specified reader or buffer, length delimited.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {cockroach.server.serverpb.RangesRequest} RangesRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                RangesRequest.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a RangesRequest message.
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {?string} `null` if valid, otherwise the reason why it is not
                 */
                RangesRequest.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.node_id != null && message.hasOwnProperty("node_id"))
                        if (!$util.isString(message.node_id))
                            return "node_id: string expected";
                    if (message.range_ids != null && message.hasOwnProperty("range_ids")) {
                        if (!Array.isArray(message.range_ids))
                            return "range_ids: array expected";
                        for (let i = 0; i < message.range_ids.length; ++i)
                            if (!$util.isInteger(message.range_ids[i]) && !(message.range_ids[i] && $util.isInteger(message.range_ids[i].low) && $util.isInteger(message.range_ids[i].high)))
                                return "range_ids: integer|Long[] expected";
                    }
                    return null;
                };

                /**
                 * Creates a RangesRequest message from a plain object. Also converts values to their respective internal types.
                 * @param {Object.<string,*>} object Plain object
                 * @returns {cockroach.server.serverpb.RangesRequest} RangesRequest
                 */
                RangesRequest.fromObject = function fromObject(object) {
                    if (object instanceof $root.cockroach.server.serverpb.RangesRequest)
                        return object;
                    let message = new $root.cockroach.server.serverpb.RangesRequest();
                    if (object.node_id != null)
                        message.node_id = String(object.node_id);
                    if (object.range_ids) {
                        if (!Array.isArray(object.range_ids))
                            throw TypeError(".cockroach.server.serverpb.RangesRequest.range_ids: array expected");
                        message.range_ids = [];
                        for (let i = 0; i < object.range_ids.length; ++i)
                            if ($util.Long)
                                (message.range_ids[i] = $util.Long.fromValue(object.range_ids[i])).unsigned = false;
                            else if (typeof object.range_ids[i] === "string")
                                message.range_ids[i] = parseInt(object.range_ids[i], 10);
                            else if (typeof object.range_ids[i] === "number")
                                message.range_ids[i] = object.range_ids[i];
                            else if (typeof object.range_ids[i] === "object")
                                message.range_ids[i] = new $util.LongBits(object.range_ids[i].low >>> 0, object.range_ids[i].high >>> 0).toNumber();
                    }
                    return message;
                };

                /**
                 * Creates a RangesRequest message from a plain object. Also converts values to their respective internal types.
                 * This is an alias of {@link cockroach.server.serverpb.RangesRequest.fromObject}.
                 * @function
                 * @param {Object.<string,*>} object Plain object
                 * @returns {cockroach.server.serverpb.RangesRequest} RangesRequest
                 */
                RangesRequest.from = RangesRequest.fromObject;

                /**
                 * Creates a plain object from a RangesRequest message. Also converts values to other types if specified.
                 * @param {cockroach.server.serverpb.RangesRequest} message RangesRequest
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                RangesRequest.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.arrays || options.defaults)
                        object.range_ids = [];
                    if (options.defaults)
                        object.node_id = "";
                    if (message.node_id != null && message.hasOwnProperty("node_id"))
                        object.node_id = message.node_id;
                    if (message.range_ids && message.range_ids.length) {
                        object.range_ids = [];
                        for (let j = 0; j < message.range_ids.length; ++j)
                            if (typeof message.range_ids[j] === "number")
                                object.range_ids[j] = options.longs === String ? String(message.range_ids[j]) : message.range_ids[j];
                            else
                                object.range_ids[j] = options.longs === String ? $util.Long.prototype.toString.call(message.range_ids[j]) : options.longs === Number ? new $util.LongBits(message.range_ids[j].low >>> 0, message.range_ids[j].high >>> 0).toNumber() : message.range_ids[j];
                    }
                    return object;
                };

                /**
                 * Creates a plain object from this RangesRequest message. Also converts values to other types if specified.
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                RangesRequest.prototype.toObject = function toObject(options) {
                    return this.constructor.toObject(this, options);
                };

                /**
                 * Converts this RangesRequest to JSON.
                 * @returns {Object.<string,*>} JSON object
                 */
                RangesRequest.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return RangesRequest;
            })();

            serverpb.RangesResponse = (function() {

                /**
                 * Properties of a RangesResponse.
                 * @typedef cockroach.server.serverpb.RangesResponse$Properties
                 * @type {Object}
                 * @property {Array.<cockroach.server.serverpb.RangeInfo$Properties>} [ranges] RangesResponse ranges.
                 */

                /**
                 * Constructs a new RangesResponse.
                 * @exports cockroach.server.serverpb.RangesResponse
                 * @constructor
                 * @param {cockroach.server.serverpb.RangesResponse$Properties=} [properties] Properties to set
                 */
                function RangesResponse(properties) {
                    this.ranges = [];
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * RangesResponse ranges.
                 * @type {Array.<cockroach.server.serverpb.RangeInfo$Properties>}
                 */
                RangesResponse.prototype.ranges = $util.emptyArray;

                /**
                 * Creates a new RangesResponse instance using the specified properties.
                 * @param {cockroach.server.serverpb.RangesResponse$Properties=} [properties] Properties to set
                 * @returns {cockroach.server.serverpb.RangesResponse} RangesResponse instance
                 */
                RangesResponse.create = function create(properties) {
                    return new RangesResponse(properties);
                };

                /**
                 * Encodes the specified RangesResponse message. Does not implicitly {@link cockroach.server.serverpb.RangesResponse.verify|verify} messages.
                 * @param {cockroach.server.serverpb.RangesResponse$Properties} message RangesResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                RangesResponse.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.ranges != null && message.ranges.length)
                        for (let i = 0; i < message.ranges.length; ++i)
                            $root.cockroach.server.serverpb.RangeInfo.encode(message.ranges[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified RangesResponse message, length delimited. Does not implicitly {@link cockroach.server.serverpb.RangesResponse.verify|verify} messages.
                 * @param {cockroach.server.serverpb.RangesResponse$Properties} message RangesResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                RangesResponse.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a RangesResponse message from the specified reader or buffer.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {cockroach.server.serverpb.RangesResponse} RangesResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                RangesResponse.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.cockroach.server.serverpb.RangesResponse();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (!(message.ranges && message.ranges.length))
                                message.ranges = [];
                            message.ranges.push($root.cockroach.server.serverpb.RangeInfo.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a RangesResponse message from the specified reader or buffer, length delimited.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {cockroach.server.serverpb.RangesResponse} RangesResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                RangesResponse.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a RangesResponse message.
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {?string} `null` if valid, otherwise the reason why it is not
                 */
                RangesResponse.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.ranges != null && message.hasOwnProperty("ranges")) {
                        if (!Array.isArray(message.ranges))
                            return "ranges: array expected";
                        for (let i = 0; i < message.ranges.length; ++i) {
                            let error = $root.cockroach.server.serverpb.RangeInfo.verify(message.ranges[i]);
                            if (error)
                                return "ranges." + error;
                        }
                    }
                    return null;
                };

                /**
                 * Creates a RangesResponse message from a plain object. Also converts values to their respective internal types.
                 * @param {Object.<string,*>} object Plain object
                 * @returns {cockroach.server.serverpb.RangesResponse} RangesResponse
                 */
                RangesResponse.fromObject = function fromObject(object) {
                    if (object instanceof $root.cockroach.server.serverpb.RangesResponse)
                        return object;
                    let message = new $root.cockroach.server.serverpb.RangesResponse();
                    if (object.ranges) {
                        if (!Array.isArray(object.ranges))
                            throw TypeError(".cockroach.server.serverpb.RangesResponse.ranges: array expected");
                        message.ranges = [];
                        for (let i = 0; i < object.ranges.length; ++i) {
                            if (typeof object.ranges[i] !== "object")
                                throw TypeError(".cockroach.server.serverpb.RangesResponse.ranges: object expected");
                            message.ranges[i] = $root.cockroach.server.serverpb.RangeInfo.fromObject(object.ranges[i]);
                        }
                    }
                    return message;
                };

                /**
                 * Creates a RangesResponse message from a plain object. Also converts values to their respective internal types.
                 * This is an alias of {@link cockroach.server.serverpb.RangesResponse.fromObject}.
                 * @function
                 * @param {Object.<string,*>} object Plain object
                 * @returns {cockroach.server.serverpb.RangesResponse} RangesResponse
                 */
                RangesResponse.from = RangesResponse.fromObject;

                /**
                 * Creates a plain object from a RangesResponse message. Also converts values to other types if specified.
                 * @param {cockroach.server.serverpb.RangesResponse} message RangesResponse
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                RangesResponse.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.arrays || options.defaults)
                        object.ranges = [];
                    if (message.ranges && message.ranges.length) {
                        object.ranges = [];
                        for (let j = 0; j < message.ranges.length; ++j)
                            object.ranges[j] = $root.cockroach.server.serverpb.RangeInfo.toObject(message.ranges[j], options);
                    }
                    return object;
                };

                /**
                 * Creates a plain object from this RangesResponse message. Also converts values to other types if specified.
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                RangesResponse.prototype.toObject = function toObject(options) {
                    return this.constructor.toObject(this, options);
                };

                /**
                 * Converts this RangesResponse to JSON.
                 * @returns {Object.<string,*>} JSON object
                 */
                RangesResponse.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return RangesResponse;
            })();

            serverpb.GossipRequest = (function() {

                /**
                 * Properties of a GossipRequest.
                 * @typedef cockroach.server.serverpb.GossipRequest$Properties
                 * @type {Object}
                 * @property {string} [node_id] GossipRequest node_id.
                 */

                /**
                 * Constructs a new GossipRequest.
                 * @exports cockroach.server.serverpb.GossipRequest
                 * @constructor
                 * @param {cockroach.server.serverpb.GossipRequest$Properties=} [properties] Properties to set
                 */
                function GossipRequest(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * GossipRequest node_id.
                 * @type {string}
                 */
                GossipRequest.prototype.node_id = "";

                /**
                 * Creates a new GossipRequest instance using the specified properties.
                 * @param {cockroach.server.serverpb.GossipRequest$Properties=} [properties] Properties to set
                 * @returns {cockroach.server.serverpb.GossipRequest} GossipRequest instance
                 */
                GossipRequest.create = function create(properties) {
                    return new GossipRequest(properties);
                };

                /**
                 * Encodes the specified GossipRequest message. Does not implicitly {@link cockroach.server.serverpb.GossipRequest.verify|verify} messages.
                 * @param {cockroach.server.serverpb.GossipRequest$Properties} message GossipRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                GossipRequest.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.node_id != null && message.hasOwnProperty("node_id"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.node_id);
                    return writer;
                };

                /**
                 * Encodes the specified GossipRequest message, length delimited. Does not implicitly {@link cockroach.server.serverpb.GossipRequest.verify|verify} messages.
                 * @param {cockroach.server.serverpb.GossipRequest$Properties} message GossipRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                GossipRequest.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a GossipRequest message from the specified reader or buffer.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {cockroach.server.serverpb.GossipRequest} GossipRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                GossipRequest.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.cockroach.server.serverpb.GossipRequest();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.node_id = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a GossipRequest message from the specified reader or buffer, length delimited.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {cockroach.server.serverpb.GossipRequest} GossipRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                GossipRequest.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a GossipRequest message.
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {?string} `null` if valid, otherwise the reason why it is not
                 */
                GossipRequest.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.node_id != null && message.hasOwnProperty("node_id"))
                        if (!$util.isString(message.node_id))
                            return "node_id: string expected";
                    return null;
                };

                /**
                 * Creates a GossipRequest message from a plain object. Also converts values to their respective internal types.
                 * @param {Object.<string,*>} object Plain object
                 * @returns {cockroach.server.serverpb.GossipRequest} GossipRequest
                 */
                GossipRequest.fromObject = function fromObject(object) {
                    if (object instanceof $root.cockroach.server.serverpb.GossipRequest)
                        return object;
                    let message = new $root.cockroach.server.serverpb.GossipRequest();
                    if (object.node_id != null)
                        message.node_id = String(object.node_id);
                    return message;
                };

                /**
                 * Creates a GossipRequest message from a plain object. Also converts values to their respective internal types.
                 * This is an alias of {@link cockroach.server.serverpb.GossipRequest.fromObject}.
                 * @function
                 * @param {Object.<string,*>} object Plain object
                 * @returns {cockroach.server.serverpb.GossipRequest} GossipRequest
                 */
                GossipRequest.from = GossipRequest.fromObject;

                /**
                 * Creates a plain object from a GossipRequest message. Also converts values to other types if specified.
                 * @param {cockroach.server.serverpb.GossipRequest} message GossipRequest
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                GossipRequest.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults)
                        object.node_id = "";
                    if (message.node_id != null && message.hasOwnProperty("node_id"))
                        object.node_id = message.node_id;
                    return object;
                };

                /**
                 * Creates a plain object from this GossipRequest message. Also converts values to other types if specified.
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                GossipRequest.prototype.toObject = function toObject(options) {
                    return this.constructor.toObject(this, options);
                };

                /**
                 * Converts this GossipRequest to JSON.
                 * @returns {Object.<string,*>} JSON object
                 */
                GossipRequest.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return GossipRequest;
            })();

            serverpb.JSONResponse = (function() {

                /**
                 * Properties of a JSONResponse.
                 * @typedef cockroach.server.serverpb.JSONResponse$Properties
                 * @type {Object}
                 * @property {Uint8Array} [data] JSONResponse data.
                 */

                /**
                 * Constructs a new JSONResponse.
                 * @exports cockroach.server.serverpb.JSONResponse
                 * @constructor
                 * @param {cockroach.server.serverpb.JSONResponse$Properties=} [properties] Properties to set
                 */
                function JSONResponse(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * JSONResponse data.
                 * @type {Uint8Array}
                 */
                JSONResponse.prototype.data = $util.newBuffer([]);

                /**
                 * Creates a new JSONResponse instance using the specified properties.
                 * @param {cockroach.server.serverpb.JSONResponse$Properties=} [properties] Properties to set
                 * @returns {cockroach.server.serverpb.JSONResponse} JSONResponse instance
                 */
                JSONResponse.create = function create(properties) {
                    return new JSONResponse(properties);
                };

                /**
                 * Encodes the specified JSONResponse message. Does not implicitly {@link cockroach.server.serverpb.JSONResponse.verify|verify} messages.
                 * @param {cockroach.server.serverpb.JSONResponse$Properties} message JSONResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                JSONResponse.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.data != null && message.hasOwnProperty("data"))
                        writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.data);
                    return writer;
                };

                /**
                 * Encodes the specified JSONResponse message, length delimited. Does not implicitly {@link cockroach.server.serverpb.JSONResponse.verify|verify} messages.
                 * @param {cockroach.server.serverpb.JSONResponse$Properties} message JSONResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                JSONResponse.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a JSONResponse message from the specified reader or buffer.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {cockroach.server.serverpb.JSONResponse} JSONResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                JSONResponse.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.cockroach.server.serverpb.JSONResponse();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.data = reader.bytes();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a JSONResponse message from the specified reader or buffer, length delimited.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {cockroach.server.serverpb.JSONResponse} JSONResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                JSONResponse.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a JSONResponse message.
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {?string} `null` if valid, otherwise the reason why it is not
                 */
                JSONResponse.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.data != null && message.hasOwnProperty("data"))
                        if (!(message.data && typeof message.data.length === "number" || $util.isString(message.data)))
                            return "data: buffer expected";
                    return null;
                };

                /**
                 * Creates a JSONResponse message from a plain object. Also converts values to their respective internal types.
                 * @param {Object.<string,*>} object Plain object
                 * @returns {cockroach.server.serverpb.JSONResponse} JSONResponse
                 */
                JSONResponse.fromObject = function fromObject(object) {
                    if (object instanceof $root.cockroach.server.serverpb.JSONResponse)
                        return object;
                    let message = new $root.cockroach.server.serverpb.JSONResponse();
                    if (object.data != null)
                        if (typeof object.data === "string")
                            $util.base64.decode(object.data, message.data = $util.newBuffer($util.base64.length(object.data)), 0);
                        else if (object.data.length)
                            message.data = object.data;
                    return message;
                };

                /**
                 * Creates a JSONResponse message from a plain object. Also converts values to their respective internal types.
                 * This is an alias of {@link cockroach.server.serverpb.JSONResponse.fromObject}.
                 * @function
                 * @param {Object.<string,*>} object Plain object
                 * @returns {cockroach.server.serverpb.JSONResponse} JSONResponse
                 */
                JSONResponse.from = JSONResponse.fromObject;

                /**
                 * Creates a plain object from a JSONResponse message. Also converts values to other types if specified.
                 * @param {cockroach.server.serverpb.JSONResponse} message JSONResponse
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                JSONResponse.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults)
                        object.data = options.bytes === String ? "" : [];
                    if (message.data != null && message.hasOwnProperty("data"))
                        object.data = options.bytes === String ? $util.base64.encode(message.data, 0, message.data.length) : options.bytes === Array ? Array.prototype.slice.call(message.data) : message.data;
                    return object;
                };

                /**
                 * Creates a plain object from this JSONResponse message. Also converts values to other types if specified.
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                JSONResponse.prototype.toObject = function toObject(options) {
                    return this.constructor.toObject(this, options);
                };

                /**
                 * Converts this JSONResponse to JSON.
                 * @returns {Object.<string,*>} JSON object
                 */
                JSONResponse.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return JSONResponse;
            })();

            serverpb.LogsRequest = (function() {

                /**
                 * Properties of a LogsRequest.
                 * @typedef cockroach.server.serverpb.LogsRequest$Properties
                 * @type {Object}
                 * @property {string} [node_id] LogsRequest node_id.
                 * @property {string} [level] LogsRequest level.
                 * @property {string} [start_time] LogsRequest start_time.
                 * @property {string} [end_time] LogsRequest end_time.
                 * @property {string} [max] LogsRequest max.
                 * @property {string} [pattern] LogsRequest pattern.
                 */

                /**
                 * Constructs a new LogsRequest.
                 * @exports cockroach.server.serverpb.LogsRequest
                 * @constructor
                 * @param {cockroach.server.serverpb.LogsRequest$Properties=} [properties] Properties to set
                 */
                function LogsRequest(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * LogsRequest node_id.
                 * @type {string}
                 */
                LogsRequest.prototype.node_id = "";

                /**
                 * LogsRequest level.
                 * @type {string}
                 */
                LogsRequest.prototype.level = "";

                /**
                 * LogsRequest start_time.
                 * @type {string}
                 */
                LogsRequest.prototype.start_time = "";

                /**
                 * LogsRequest end_time.
                 * @type {string}
                 */
                LogsRequest.prototype.end_time = "";

                /**
                 * LogsRequest max.
                 * @type {string}
                 */
                LogsRequest.prototype.max = "";

                /**
                 * LogsRequest pattern.
                 * @type {string}
                 */
                LogsRequest.prototype.pattern = "";

                /**
                 * Creates a new LogsRequest instance using the specified properties.
                 * @param {cockroach.server.serverpb.LogsRequest$Properties=} [properties] Properties to set
                 * @returns {cockroach.server.serverpb.LogsRequest} LogsRequest instance
                 */
                LogsRequest.create = function create(properties) {
                    return new LogsRequest(properties);
                };

                /**
                 * Encodes the specified LogsRequest message. Does not implicitly {@link cockroach.server.serverpb.LogsRequest.verify|verify} messages.
                 * @param {cockroach.server.serverpb.LogsRequest$Properties} message LogsRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                LogsRequest.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.node_id != null && message.hasOwnProperty("node_id"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.node_id);
                    if (message.level != null && message.hasOwnProperty("level"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.level);
                    if (message.start_time != null && message.hasOwnProperty("start_time"))
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.start_time);
                    if (message.end_time != null && message.hasOwnProperty("end_time"))
                        writer.uint32(/* id 4, wireType 2 =*/34).string(message.end_time);
                    if (message.max != null && message.hasOwnProperty("max"))
                        writer.uint32(/* id 5, wireType 2 =*/42).string(message.max);
                    if (message.pattern != null && message.hasOwnProperty("pattern"))
                        writer.uint32(/* id 6, wireType 2 =*/50).string(message.pattern);
                    return writer;
                };

                /**
                 * Encodes the specified LogsRequest message, length delimited. Does not implicitly {@link cockroach.server.serverpb.LogsRequest.verify|verify} messages.
                 * @param {cockroach.server.serverpb.LogsRequest$Properties} message LogsRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                LogsRequest.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a LogsRequest message from the specified reader or buffer.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {cockroach.server.serverpb.LogsRequest} LogsRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                LogsRequest.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.cockroach.server.serverpb.LogsRequest();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.node_id = reader.string();
                            break;
                        case 2:
                            message.level = reader.string();
                            break;
                        case 3:
                            message.start_time = reader.string();
                            break;
                        case 4:
                            message.end_time = reader.string();
                            break;
                        case 5:
                            message.max = reader.string();
                            break;
                        case 6:
                            message.pattern = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a LogsRequest message from the specified reader or buffer, length delimited.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {cockroach.server.serverpb.LogsRequest} LogsRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                LogsRequest.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a LogsRequest message.
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {?string} `null` if valid, otherwise the reason why it is not
                 */
                LogsRequest.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.node_id != null && message.hasOwnProperty("node_id"))
                        if (!$util.isString(message.node_id))
                            return "node_id: string expected";
                    if (message.level != null && message.hasOwnProperty("level"))
                        if (!$util.isString(message.level))
                            return "level: string expected";
                    if (message.start_time != null && message.hasOwnProperty("start_time"))
                        if (!$util.isString(message.start_time))
                            return "start_time: string expected";
                    if (message.end_time != null && message.hasOwnProperty("end_time"))
                        if (!$util.isString(message.end_time))
                            return "end_time: string expected";
                    if (message.max != null && message.hasOwnProperty("max"))
                        if (!$util.isString(message.max))
                            return "max: string expected";
                    if (message.pattern != null && message.hasOwnProperty("pattern"))
                        if (!$util.isString(message.pattern))
                            return "pattern: string expected";
                    return null;
                };

                /**
                 * Creates a LogsRequest message from a plain object. Also converts values to their respective internal types.
                 * @param {Object.<string,*>} object Plain object
                 * @returns {cockroach.server.serverpb.LogsRequest} LogsRequest
                 */
                LogsRequest.fromObject = function fromObject(object) {
                    if (object instanceof $root.cockroach.server.serverpb.LogsRequest)
                        return object;
                    let message = new $root.cockroach.server.serverpb.LogsRequest();
                    if (object.node_id != null)
                        message.node_id = String(object.node_id);
                    if (object.level != null)
                        message.level = String(object.level);
                    if (object.start_time != null)
                        message.start_time = String(object.start_time);
                    if (object.end_time != null)
                        message.end_time = String(object.end_time);
                    if (object.max != null)
                        message.max = String(object.max);
                    if (object.pattern != null)
                        message.pattern = String(object.pattern);
                    return message;
                };

                /**
                 * Creates a LogsRequest message from a plain object. Also converts values to their respective internal types.
                 * This is an alias of {@link cockroach.server.serverpb.LogsRequest.fromObject}.
                 * @function
                 * @param {Object.<string,*>} object Plain object
                 * @returns {cockroach.server.serverpb.LogsRequest} LogsRequest
                 */
                LogsRequest.from = LogsRequest.fromObject;

                /**
                 * Creates a plain object from a LogsRequest message. Also converts values to other types if specified.
                 * @param {cockroach.server.serverpb.LogsRequest} message LogsRequest
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                LogsRequest.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.node_id = "";
                        object.level = "";
                        object.start_time = "";
                        object.end_time = "";
                        object.max = "";
                        object.pattern = "";
                    }
                    if (message.node_id != null && message.hasOwnProperty("node_id"))
                        object.node_id = message.node_id;
                    if (message.level != null && message.hasOwnProperty("level"))
                        object.level = message.level;
                    if (message.start_time != null && message.hasOwnProperty("start_time"))
                        object.start_time = message.start_time;
                    if (message.end_time != null && message.hasOwnProperty("end_time"))
                        object.end_time = message.end_time;
                    if (message.max != null && message.hasOwnProperty("max"))
                        object.max = message.max;
                    if (message.pattern != null && message.hasOwnProperty("pattern"))
                        object.pattern = message.pattern;
                    return object;
                };

                /**
                 * Creates a plain object from this LogsRequest message. Also converts values to other types if specified.
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                LogsRequest.prototype.toObject = function toObject(options) {
                    return this.constructor.toObject(this, options);
                };

                /**
                 * Converts this LogsRequest to JSON.
                 * @returns {Object.<string,*>} JSON object
                 */
                LogsRequest.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return LogsRequest;
            })();

            serverpb.LogEntriesResponse = (function() {

                /**
                 * Properties of a LogEntriesResponse.
                 * @typedef cockroach.server.serverpb.LogEntriesResponse$Properties
                 * @type {Object}
                 * @property {Array.<cockroach.util.log.Entry$Properties>} [entries] LogEntriesResponse entries.
                 */

                /**
                 * Constructs a new LogEntriesResponse.
                 * @exports cockroach.server.serverpb.LogEntriesResponse
                 * @constructor
                 * @param {cockroach.server.serverpb.LogEntriesResponse$Properties=} [properties] Properties to set
                 */
                function LogEntriesResponse(properties) {
                    this.entries = [];
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * LogEntriesResponse entries.
                 * @type {Array.<cockroach.util.log.Entry$Properties>}
                 */
                LogEntriesResponse.prototype.entries = $util.emptyArray;

                /**
                 * Creates a new LogEntriesResponse instance using the specified properties.
                 * @param {cockroach.server.serverpb.LogEntriesResponse$Properties=} [properties] Properties to set
                 * @returns {cockroach.server.serverpb.LogEntriesResponse} LogEntriesResponse instance
                 */
                LogEntriesResponse.create = function create(properties) {
                    return new LogEntriesResponse(properties);
                };

                /**
                 * Encodes the specified LogEntriesResponse message. Does not implicitly {@link cockroach.server.serverpb.LogEntriesResponse.verify|verify} messages.
                 * @param {cockroach.server.serverpb.LogEntriesResponse$Properties} message LogEntriesResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                LogEntriesResponse.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.entries != null && message.entries.length)
                        for (let i = 0; i < message.entries.length; ++i)
                            $root.cockroach.util.log.Entry.encode(message.entries[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified LogEntriesResponse message, length delimited. Does not implicitly {@link cockroach.server.serverpb.LogEntriesResponse.verify|verify} messages.
                 * @param {cockroach.server.serverpb.LogEntriesResponse$Properties} message LogEntriesResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                LogEntriesResponse.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a LogEntriesResponse message from the specified reader or buffer.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {cockroach.server.serverpb.LogEntriesResponse} LogEntriesResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                LogEntriesResponse.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.cockroach.server.serverpb.LogEntriesResponse();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (!(message.entries && message.entries.length))
                                message.entries = [];
                            message.entries.push($root.cockroach.util.log.Entry.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a LogEntriesResponse message from the specified reader or buffer, length delimited.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {cockroach.server.serverpb.LogEntriesResponse} LogEntriesResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                LogEntriesResponse.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a LogEntriesResponse message.
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {?string} `null` if valid, otherwise the reason why it is not
                 */
                LogEntriesResponse.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.entries != null && message.hasOwnProperty("entries")) {
                        if (!Array.isArray(message.entries))
                            return "entries: array expected";
                        for (let i = 0; i < message.entries.length; ++i) {
                            let error = $root.cockroach.util.log.Entry.verify(message.entries[i]);
                            if (error)
                                return "entries." + error;
                        }
                    }
                    return null;
                };

                /**
                 * Creates a LogEntriesResponse message from a plain object. Also converts values to their respective internal types.
                 * @param {Object.<string,*>} object Plain object
                 * @returns {cockroach.server.serverpb.LogEntriesResponse} LogEntriesResponse
                 */
                LogEntriesResponse.fromObject = function fromObject(object) {
                    if (object instanceof $root.cockroach.server.serverpb.LogEntriesResponse)
                        return object;
                    let message = new $root.cockroach.server.serverpb.LogEntriesResponse();
                    if (object.entries) {
                        if (!Array.isArray(object.entries))
                            throw TypeError(".cockroach.server.serverpb.LogEntriesResponse.entries: array expected");
                        message.entries = [];
                        for (let i = 0; i < object.entries.length; ++i) {
                            if (typeof object.entries[i] !== "object")
                                throw TypeError(".cockroach.server.serverpb.LogEntriesResponse.entries: object expected");
                            message.entries[i] = $root.cockroach.util.log.Entry.fromObject(object.entries[i]);
                        }
                    }
                    return message;
                };

                /**
                 * Creates a LogEntriesResponse message from a plain object. Also converts values to their respective internal types.
                 * This is an alias of {@link cockroach.server.serverpb.LogEntriesResponse.fromObject}.
                 * @function
                 * @param {Object.<string,*>} object Plain object
                 * @returns {cockroach.server.serverpb.LogEntriesResponse} LogEntriesResponse
                 */
                LogEntriesResponse.from = LogEntriesResponse.fromObject;

                /**
                 * Creates a plain object from a LogEntriesResponse message. Also converts values to other types if specified.
                 * @param {cockroach.server.serverpb.LogEntriesResponse} message LogEntriesResponse
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                LogEntriesResponse.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.arrays || options.defaults)
                        object.entries = [];
                    if (message.entries && message.entries.length) {
                        object.entries = [];
                        for (let j = 0; j < message.entries.length; ++j)
                            object.entries[j] = $root.cockroach.util.log.Entry.toObject(message.entries[j], options);
                    }
                    return object;
                };

                /**
                 * Creates a plain object from this LogEntriesResponse message. Also converts values to other types if specified.
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                LogEntriesResponse.prototype.toObject = function toObject(options) {
                    return this.constructor.toObject(this, options);
                };

                /**
                 * Converts this LogEntriesResponse to JSON.
                 * @returns {Object.<string,*>} JSON object
                 */
                LogEntriesResponse.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return LogEntriesResponse;
            })();

            serverpb.LogFilesListRequest = (function() {

                /**
                 * Properties of a LogFilesListRequest.
                 * @typedef cockroach.server.serverpb.LogFilesListRequest$Properties
                 * @type {Object}
                 * @property {string} [node_id] LogFilesListRequest node_id.
                 */

                /**
                 * Constructs a new LogFilesListRequest.
                 * @exports cockroach.server.serverpb.LogFilesListRequest
                 * @constructor
                 * @param {cockroach.server.serverpb.LogFilesListRequest$Properties=} [properties] Properties to set
                 */
                function LogFilesListRequest(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * LogFilesListRequest node_id.
                 * @type {string}
                 */
                LogFilesListRequest.prototype.node_id = "";

                /**
                 * Creates a new LogFilesListRequest instance using the specified properties.
                 * @param {cockroach.server.serverpb.LogFilesListRequest$Properties=} [properties] Properties to set
                 * @returns {cockroach.server.serverpb.LogFilesListRequest} LogFilesListRequest instance
                 */
                LogFilesListRequest.create = function create(properties) {
                    return new LogFilesListRequest(properties);
                };

                /**
                 * Encodes the specified LogFilesListRequest message. Does not implicitly {@link cockroach.server.serverpb.LogFilesListRequest.verify|verify} messages.
                 * @param {cockroach.server.serverpb.LogFilesListRequest$Properties} message LogFilesListRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                LogFilesListRequest.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.node_id != null && message.hasOwnProperty("node_id"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.node_id);
                    return writer;
                };

                /**
                 * Encodes the specified LogFilesListRequest message, length delimited. Does not implicitly {@link cockroach.server.serverpb.LogFilesListRequest.verify|verify} messages.
                 * @param {cockroach.server.serverpb.LogFilesListRequest$Properties} message LogFilesListRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                LogFilesListRequest.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a LogFilesListRequest message from the specified reader or buffer.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {cockroach.server.serverpb.LogFilesListRequest} LogFilesListRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                LogFilesListRequest.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.cockroach.server.serverpb.LogFilesListRequest();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.node_id = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a LogFilesListRequest message from the specified reader or buffer, length delimited.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {cockroach.server.serverpb.LogFilesListRequest} LogFilesListRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                LogFilesListRequest.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a LogFilesListRequest message.
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {?string} `null` if valid, otherwise the reason why it is not
                 */
                LogFilesListRequest.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.node_id != null && message.hasOwnProperty("node_id"))
                        if (!$util.isString(message.node_id))
                            return "node_id: string expected";
                    return null;
                };

                /**
                 * Creates a LogFilesListRequest message from a plain object. Also converts values to their respective internal types.
                 * @param {Object.<string,*>} object Plain object
                 * @returns {cockroach.server.serverpb.LogFilesListRequest} LogFilesListRequest
                 */
                LogFilesListRequest.fromObject = function fromObject(object) {
                    if (object instanceof $root.cockroach.server.serverpb.LogFilesListRequest)
                        return object;
                    let message = new $root.cockroach.server.serverpb.LogFilesListRequest();
                    if (object.node_id != null)
                        message.node_id = String(object.node_id);
                    return message;
                };

                /**
                 * Creates a LogFilesListRequest message from a plain object. Also converts values to their respective internal types.
                 * This is an alias of {@link cockroach.server.serverpb.LogFilesListRequest.fromObject}.
                 * @function
                 * @param {Object.<string,*>} object Plain object
                 * @returns {cockroach.server.serverpb.LogFilesListRequest} LogFilesListRequest
                 */
                LogFilesListRequest.from = LogFilesListRequest.fromObject;

                /**
                 * Creates a plain object from a LogFilesListRequest message. Also converts values to other types if specified.
                 * @param {cockroach.server.serverpb.LogFilesListRequest} message LogFilesListRequest
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                LogFilesListRequest.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults)
                        object.node_id = "";
                    if (message.node_id != null && message.hasOwnProperty("node_id"))
                        object.node_id = message.node_id;
                    return object;
                };

                /**
                 * Creates a plain object from this LogFilesListRequest message. Also converts values to other types if specified.
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                LogFilesListRequest.prototype.toObject = function toObject(options) {
                    return this.constructor.toObject(this, options);
                };

                /**
                 * Converts this LogFilesListRequest to JSON.
                 * @returns {Object.<string,*>} JSON object
                 */
                LogFilesListRequest.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return LogFilesListRequest;
            })();

            serverpb.LogFilesListResponse = (function() {

                /**
                 * Properties of a LogFilesListResponse.
                 * @typedef cockroach.server.serverpb.LogFilesListResponse$Properties
                 * @type {Object}
                 * @property {Array.<cockroach.util.log.FileInfo$Properties>} [files] LogFilesListResponse files.
                 */

                /**
                 * Constructs a new LogFilesListResponse.
                 * @exports cockroach.server.serverpb.LogFilesListResponse
                 * @constructor
                 * @param {cockroach.server.serverpb.LogFilesListResponse$Properties=} [properties] Properties to set
                 */
                function LogFilesListResponse(properties) {
                    this.files = [];
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * LogFilesListResponse files.
                 * @type {Array.<cockroach.util.log.FileInfo$Properties>}
                 */
                LogFilesListResponse.prototype.files = $util.emptyArray;

                /**
                 * Creates a new LogFilesListResponse instance using the specified properties.
                 * @param {cockroach.server.serverpb.LogFilesListResponse$Properties=} [properties] Properties to set
                 * @returns {cockroach.server.serverpb.LogFilesListResponse} LogFilesListResponse instance
                 */
                LogFilesListResponse.create = function create(properties) {
                    return new LogFilesListResponse(properties);
                };

                /**
                 * Encodes the specified LogFilesListResponse message. Does not implicitly {@link cockroach.server.serverpb.LogFilesListResponse.verify|verify} messages.
                 * @param {cockroach.server.serverpb.LogFilesListResponse$Properties} message LogFilesListResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                LogFilesListResponse.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.files != null && message.files.length)
                        for (let i = 0; i < message.files.length; ++i)
                            $root.cockroach.util.log.FileInfo.encode(message.files[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified LogFilesListResponse message, length delimited. Does not implicitly {@link cockroach.server.serverpb.LogFilesListResponse.verify|verify} messages.
                 * @param {cockroach.server.serverpb.LogFilesListResponse$Properties} message LogFilesListResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                LogFilesListResponse.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a LogFilesListResponse message from the specified reader or buffer.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {cockroach.server.serverpb.LogFilesListResponse} LogFilesListResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                LogFilesListResponse.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.cockroach.server.serverpb.LogFilesListResponse();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (!(message.files && message.files.length))
                                message.files = [];
                            message.files.push($root.cockroach.util.log.FileInfo.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a LogFilesListResponse message from the specified reader or buffer, length delimited.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {cockroach.server.serverpb.LogFilesListResponse} LogFilesListResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                LogFilesListResponse.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a LogFilesListResponse message.
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {?string} `null` if valid, otherwise the reason why it is not
                 */
                LogFilesListResponse.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.files != null && message.hasOwnProperty("files")) {
                        if (!Array.isArray(message.files))
                            return "files: array expected";
                        for (let i = 0; i < message.files.length; ++i) {
                            let error = $root.cockroach.util.log.FileInfo.verify(message.files[i]);
                            if (error)
                                return "files." + error;
                        }
                    }
                    return null;
                };

                /**
                 * Creates a LogFilesListResponse message from a plain object. Also converts values to their respective internal types.
                 * @param {Object.<string,*>} object Plain object
                 * @returns {cockroach.server.serverpb.LogFilesListResponse} LogFilesListResponse
                 */
                LogFilesListResponse.fromObject = function fromObject(object) {
                    if (object instanceof $root.cockroach.server.serverpb.LogFilesListResponse)
                        return object;
                    let message = new $root.cockroach.server.serverpb.LogFilesListResponse();
                    if (object.files) {
                        if (!Array.isArray(object.files))
                            throw TypeError(".cockroach.server.serverpb.LogFilesListResponse.files: array expected");
                        message.files = [];
                        for (let i = 0; i < object.files.length; ++i) {
                            if (typeof object.files[i] !== "object")
                                throw TypeError(".cockroach.server.serverpb.LogFilesListResponse.files: object expected");
                            message.files[i] = $root.cockroach.util.log.FileInfo.fromObject(object.files[i]);
                        }
                    }
                    return message;
                };

                /**
                 * Creates a LogFilesListResponse message from a plain object. Also converts values to their respective internal types.
                 * This is an alias of {@link cockroach.server.serverpb.LogFilesListResponse.fromObject}.
                 * @function
                 * @param {Object.<string,*>} object Plain object
                 * @returns {cockroach.server.serverpb.LogFilesListResponse} LogFilesListResponse
                 */
                LogFilesListResponse.from = LogFilesListResponse.fromObject;

                /**
                 * Creates a plain object from a LogFilesListResponse message. Also converts values to other types if specified.
                 * @param {cockroach.server.serverpb.LogFilesListResponse} message LogFilesListResponse
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                LogFilesListResponse.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.arrays || options.defaults)
                        object.files = [];
                    if (message.files && message.files.length) {
                        object.files = [];
                        for (let j = 0; j < message.files.length; ++j)
                            object.files[j] = $root.cockroach.util.log.FileInfo.toObject(message.files[j], options);
                    }
                    return object;
                };

                /**
                 * Creates a plain object from this LogFilesListResponse message. Also converts values to other types if specified.
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                LogFilesListResponse.prototype.toObject = function toObject(options) {
                    return this.constructor.toObject(this, options);
                };

                /**
                 * Converts this LogFilesListResponse to JSON.
                 * @returns {Object.<string,*>} JSON object
                 */
                LogFilesListResponse.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return LogFilesListResponse;
            })();

            serverpb.LogFileRequest = (function() {

                /**
                 * Properties of a LogFileRequest.
                 * @typedef cockroach.server.serverpb.LogFileRequest$Properties
                 * @type {Object}
                 * @property {string} [node_id] LogFileRequest node_id.
                 * @property {string} [file] LogFileRequest file.
                 */

                /**
                 * Constructs a new LogFileRequest.
                 * @exports cockroach.server.serverpb.LogFileRequest
                 * @constructor
                 * @param {cockroach.server.serverpb.LogFileRequest$Properties=} [properties] Properties to set
                 */
                function LogFileRequest(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * LogFileRequest node_id.
                 * @type {string}
                 */
                LogFileRequest.prototype.node_id = "";

                /**
                 * LogFileRequest file.
                 * @type {string}
                 */
                LogFileRequest.prototype.file = "";

                /**
                 * Creates a new LogFileRequest instance using the specified properties.
                 * @param {cockroach.server.serverpb.LogFileRequest$Properties=} [properties] Properties to set
                 * @returns {cockroach.server.serverpb.LogFileRequest} LogFileRequest instance
                 */
                LogFileRequest.create = function create(properties) {
                    return new LogFileRequest(properties);
                };

                /**
                 * Encodes the specified LogFileRequest message. Does not implicitly {@link cockroach.server.serverpb.LogFileRequest.verify|verify} messages.
                 * @param {cockroach.server.serverpb.LogFileRequest$Properties} message LogFileRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                LogFileRequest.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.node_id != null && message.hasOwnProperty("node_id"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.node_id);
                    if (message.file != null && message.hasOwnProperty("file"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.file);
                    return writer;
                };

                /**
                 * Encodes the specified LogFileRequest message, length delimited. Does not implicitly {@link cockroach.server.serverpb.LogFileRequest.verify|verify} messages.
                 * @param {cockroach.server.serverpb.LogFileRequest$Properties} message LogFileRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                LogFileRequest.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a LogFileRequest message from the specified reader or buffer.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {cockroach.server.serverpb.LogFileRequest} LogFileRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                LogFileRequest.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.cockroach.server.serverpb.LogFileRequest();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.node_id = reader.string();
                            break;
                        case 2:
                            message.file = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a LogFileRequest message from the specified reader or buffer, length delimited.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {cockroach.server.serverpb.LogFileRequest} LogFileRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                LogFileRequest.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a LogFileRequest message.
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {?string} `null` if valid, otherwise the reason why it is not
                 */
                LogFileRequest.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.node_id != null && message.hasOwnProperty("node_id"))
                        if (!$util.isString(message.node_id))
                            return "node_id: string expected";
                    if (message.file != null && message.hasOwnProperty("file"))
                        if (!$util.isString(message.file))
                            return "file: string expected";
                    return null;
                };

                /**
                 * Creates a LogFileRequest message from a plain object. Also converts values to their respective internal types.
                 * @param {Object.<string,*>} object Plain object
                 * @returns {cockroach.server.serverpb.LogFileRequest} LogFileRequest
                 */
                LogFileRequest.fromObject = function fromObject(object) {
                    if (object instanceof $root.cockroach.server.serverpb.LogFileRequest)
                        return object;
                    let message = new $root.cockroach.server.serverpb.LogFileRequest();
                    if (object.node_id != null)
                        message.node_id = String(object.node_id);
                    if (object.file != null)
                        message.file = String(object.file);
                    return message;
                };

                /**
                 * Creates a LogFileRequest message from a plain object. Also converts values to their respective internal types.
                 * This is an alias of {@link cockroach.server.serverpb.LogFileRequest.fromObject}.
                 * @function
                 * @param {Object.<string,*>} object Plain object
                 * @returns {cockroach.server.serverpb.LogFileRequest} LogFileRequest
                 */
                LogFileRequest.from = LogFileRequest.fromObject;

                /**
                 * Creates a plain object from a LogFileRequest message. Also converts values to other types if specified.
                 * @param {cockroach.server.serverpb.LogFileRequest} message LogFileRequest
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                LogFileRequest.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.node_id = "";
                        object.file = "";
                    }
                    if (message.node_id != null && message.hasOwnProperty("node_id"))
                        object.node_id = message.node_id;
                    if (message.file != null && message.hasOwnProperty("file"))
                        object.file = message.file;
                    return object;
                };

                /**
                 * Creates a plain object from this LogFileRequest message. Also converts values to other types if specified.
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                LogFileRequest.prototype.toObject = function toObject(options) {
                    return this.constructor.toObject(this, options);
                };

                /**
                 * Converts this LogFileRequest to JSON.
                 * @returns {Object.<string,*>} JSON object
                 */
                LogFileRequest.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return LogFileRequest;
            })();

            serverpb.StacksRequest = (function() {

                /**
                 * Properties of a StacksRequest.
                 * @typedef cockroach.server.serverpb.StacksRequest$Properties
                 * @type {Object}
                 * @property {string} [node_id] StacksRequest node_id.
                 */

                /**
                 * Constructs a new StacksRequest.
                 * @exports cockroach.server.serverpb.StacksRequest
                 * @constructor
                 * @param {cockroach.server.serverpb.StacksRequest$Properties=} [properties] Properties to set
                 */
                function StacksRequest(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * StacksRequest node_id.
                 * @type {string}
                 */
                StacksRequest.prototype.node_id = "";

                /**
                 * Creates a new StacksRequest instance using the specified properties.
                 * @param {cockroach.server.serverpb.StacksRequest$Properties=} [properties] Properties to set
                 * @returns {cockroach.server.serverpb.StacksRequest} StacksRequest instance
                 */
                StacksRequest.create = function create(properties) {
                    return new StacksRequest(properties);
                };

                /**
                 * Encodes the specified StacksRequest message. Does not implicitly {@link cockroach.server.serverpb.StacksRequest.verify|verify} messages.
                 * @param {cockroach.server.serverpb.StacksRequest$Properties} message StacksRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                StacksRequest.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.node_id != null && message.hasOwnProperty("node_id"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.node_id);
                    return writer;
                };

                /**
                 * Encodes the specified StacksRequest message, length delimited. Does not implicitly {@link cockroach.server.serverpb.StacksRequest.verify|verify} messages.
                 * @param {cockroach.server.serverpb.StacksRequest$Properties} message StacksRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                StacksRequest.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a StacksRequest message from the specified reader or buffer.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {cockroach.server.serverpb.StacksRequest} StacksRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                StacksRequest.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.cockroach.server.serverpb.StacksRequest();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.node_id = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a StacksRequest message from the specified reader or buffer, length delimited.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {cockroach.server.serverpb.StacksRequest} StacksRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                StacksRequest.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a StacksRequest message.
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {?string} `null` if valid, otherwise the reason why it is not
                 */
                StacksRequest.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.node_id != null && message.hasOwnProperty("node_id"))
                        if (!$util.isString(message.node_id))
                            return "node_id: string expected";
                    return null;
                };

                /**
                 * Creates a StacksRequest message from a plain object. Also converts values to their respective internal types.
                 * @param {Object.<string,*>} object Plain object
                 * @returns {cockroach.server.serverpb.StacksRequest} StacksRequest
                 */
                StacksRequest.fromObject = function fromObject(object) {
                    if (object instanceof $root.cockroach.server.serverpb.StacksRequest)
                        return object;
                    let message = new $root.cockroach.server.serverpb.StacksRequest();
                    if (object.node_id != null)
                        message.node_id = String(object.node_id);
                    return message;
                };

                /**
                 * Creates a StacksRequest message from a plain object. Also converts values to their respective internal types.
                 * This is an alias of {@link cockroach.server.serverpb.StacksRequest.fromObject}.
                 * @function
                 * @param {Object.<string,*>} object Plain object
                 * @returns {cockroach.server.serverpb.StacksRequest} StacksRequest
                 */
                StacksRequest.from = StacksRequest.fromObject;

                /**
                 * Creates a plain object from a StacksRequest message. Also converts values to other types if specified.
                 * @param {cockroach.server.serverpb.StacksRequest} message StacksRequest
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                StacksRequest.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults)
                        object.node_id = "";
                    if (message.node_id != null && message.hasOwnProperty("node_id"))
                        object.node_id = message.node_id;
                    return object;
                };

                /**
                 * Creates a plain object from this StacksRequest message. Also converts values to other types if specified.
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                StacksRequest.prototype.toObject = function toObject(options) {
                    return this.constructor.toObject(this, options);
                };

                /**
                 * Converts this StacksRequest to JSON.
                 * @returns {Object.<string,*>} JSON object
                 */
                StacksRequest.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return StacksRequest;
            })();

            serverpb.MetricsRequest = (function() {

                /**
                 * Properties of a MetricsRequest.
                 * @typedef cockroach.server.serverpb.MetricsRequest$Properties
                 * @type {Object}
                 * @property {string} [node_id] MetricsRequest node_id.
                 */

                /**
                 * Constructs a new MetricsRequest.
                 * @exports cockroach.server.serverpb.MetricsRequest
                 * @constructor
                 * @param {cockroach.server.serverpb.MetricsRequest$Properties=} [properties] Properties to set
                 */
                function MetricsRequest(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * MetricsRequest node_id.
                 * @type {string}
                 */
                MetricsRequest.prototype.node_id = "";

                /**
                 * Creates a new MetricsRequest instance using the specified properties.
                 * @param {cockroach.server.serverpb.MetricsRequest$Properties=} [properties] Properties to set
                 * @returns {cockroach.server.serverpb.MetricsRequest} MetricsRequest instance
                 */
                MetricsRequest.create = function create(properties) {
                    return new MetricsRequest(properties);
                };

                /**
                 * Encodes the specified MetricsRequest message. Does not implicitly {@link cockroach.server.serverpb.MetricsRequest.verify|verify} messages.
                 * @param {cockroach.server.serverpb.MetricsRequest$Properties} message MetricsRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MetricsRequest.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.node_id != null && message.hasOwnProperty("node_id"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.node_id);
                    return writer;
                };

                /**
                 * Encodes the specified MetricsRequest message, length delimited. Does not implicitly {@link cockroach.server.serverpb.MetricsRequest.verify|verify} messages.
                 * @param {cockroach.server.serverpb.MetricsRequest$Properties} message MetricsRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MetricsRequest.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a MetricsRequest message from the specified reader or buffer.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {cockroach.server.serverpb.MetricsRequest} MetricsRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MetricsRequest.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.cockroach.server.serverpb.MetricsRequest();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.node_id = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a MetricsRequest message from the specified reader or buffer, length delimited.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {cockroach.server.serverpb.MetricsRequest} MetricsRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MetricsRequest.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a MetricsRequest message.
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {?string} `null` if valid, otherwise the reason why it is not
                 */
                MetricsRequest.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.node_id != null && message.hasOwnProperty("node_id"))
                        if (!$util.isString(message.node_id))
                            return "node_id: string expected";
                    return null;
                };

                /**
                 * Creates a MetricsRequest message from a plain object. Also converts values to their respective internal types.
                 * @param {Object.<string,*>} object Plain object
                 * @returns {cockroach.server.serverpb.MetricsRequest} MetricsRequest
                 */
                MetricsRequest.fromObject = function fromObject(object) {
                    if (object instanceof $root.cockroach.server.serverpb.MetricsRequest)
                        return object;
                    let message = new $root.cockroach.server.serverpb.MetricsRequest();
                    if (object.node_id != null)
                        message.node_id = String(object.node_id);
                    return message;
                };

                /**
                 * Creates a MetricsRequest message from a plain object. Also converts values to their respective internal types.
                 * This is an alias of {@link cockroach.server.serverpb.MetricsRequest.fromObject}.
                 * @function
                 * @param {Object.<string,*>} object Plain object
                 * @returns {cockroach.server.serverpb.MetricsRequest} MetricsRequest
                 */
                MetricsRequest.from = MetricsRequest.fromObject;

                /**
                 * Creates a plain object from a MetricsRequest message. Also converts values to other types if specified.
                 * @param {cockroach.server.serverpb.MetricsRequest} message MetricsRequest
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                MetricsRequest.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults)
                        object.node_id = "";
                    if (message.node_id != null && message.hasOwnProperty("node_id"))
                        object.node_id = message.node_id;
                    return object;
                };

                /**
                 * Creates a plain object from this MetricsRequest message. Also converts values to other types if specified.
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                MetricsRequest.prototype.toObject = function toObject(options) {
                    return this.constructor.toObject(this, options);
                };

                /**
                 * Converts this MetricsRequest to JSON.
                 * @returns {Object.<string,*>} JSON object
                 */
                MetricsRequest.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return MetricsRequest;
            })();

            serverpb.RaftRangeNode = (function() {

                /**
                 * Properties of a RaftRangeNode.
                 * @typedef cockroach.server.serverpb.RaftRangeNode$Properties
                 * @type {Object}
                 * @property {number} [node_id] RaftRangeNode node_id.
                 * @property {cockroach.server.serverpb.RangeInfo$Properties} [range] RaftRangeNode range.
                 */

                /**
                 * Constructs a new RaftRangeNode.
                 * @exports cockroach.server.serverpb.RaftRangeNode
                 * @constructor
                 * @param {cockroach.server.serverpb.RaftRangeNode$Properties=} [properties] Properties to set
                 */
                function RaftRangeNode(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * RaftRangeNode node_id.
                 * @type {number}
                 */
                RaftRangeNode.prototype.node_id = 0;

                /**
                 * RaftRangeNode range.
                 * @type {(cockroach.server.serverpb.RangeInfo$Properties|null)}
                 */
                RaftRangeNode.prototype.range = null;

                /**
                 * Creates a new RaftRangeNode instance using the specified properties.
                 * @param {cockroach.server.serverpb.RaftRangeNode$Properties=} [properties] Properties to set
                 * @returns {cockroach.server.serverpb.RaftRangeNode} RaftRangeNode instance
                 */
                RaftRangeNode.create = function create(properties) {
                    return new RaftRangeNode(properties);
                };

                /**
                 * Encodes the specified RaftRangeNode message. Does not implicitly {@link cockroach.server.serverpb.RaftRangeNode.verify|verify} messages.
                 * @param {cockroach.server.serverpb.RaftRangeNode$Properties} message RaftRangeNode message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                RaftRangeNode.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.node_id != null && message.hasOwnProperty("node_id"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.node_id);
                    if (message.range != null && message.hasOwnProperty("range"))
                        $root.cockroach.server.serverpb.RangeInfo.encode(message.range, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified RaftRangeNode message, length delimited. Does not implicitly {@link cockroach.server.serverpb.RaftRangeNode.verify|verify} messages.
                 * @param {cockroach.server.serverpb.RaftRangeNode$Properties} message RaftRangeNode message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                RaftRangeNode.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a RaftRangeNode message from the specified reader or buffer.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {cockroach.server.serverpb.RaftRangeNode} RaftRangeNode
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                RaftRangeNode.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.cockroach.server.serverpb.RaftRangeNode();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.node_id = reader.int32();
                            break;
                        case 2:
                            message.range = $root.cockroach.server.serverpb.RangeInfo.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a RaftRangeNode message from the specified reader or buffer, length delimited.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {cockroach.server.serverpb.RaftRangeNode} RaftRangeNode
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                RaftRangeNode.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a RaftRangeNode message.
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {?string} `null` if valid, otherwise the reason why it is not
                 */
                RaftRangeNode.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.node_id != null && message.hasOwnProperty("node_id"))
                        if (!$util.isInteger(message.node_id))
                            return "node_id: integer expected";
                    if (message.range != null && message.hasOwnProperty("range")) {
                        let error = $root.cockroach.server.serverpb.RangeInfo.verify(message.range);
                        if (error)
                            return "range." + error;
                    }
                    return null;
                };

                /**
                 * Creates a RaftRangeNode message from a plain object. Also converts values to their respective internal types.
                 * @param {Object.<string,*>} object Plain object
                 * @returns {cockroach.server.serverpb.RaftRangeNode} RaftRangeNode
                 */
                RaftRangeNode.fromObject = function fromObject(object) {
                    if (object instanceof $root.cockroach.server.serverpb.RaftRangeNode)
                        return object;
                    let message = new $root.cockroach.server.serverpb.RaftRangeNode();
                    if (object.node_id != null)
                        message.node_id = object.node_id | 0;
                    if (object.range != null) {
                        if (typeof object.range !== "object")
                            throw TypeError(".cockroach.server.serverpb.RaftRangeNode.range: object expected");
                        message.range = $root.cockroach.server.serverpb.RangeInfo.fromObject(object.range);
                    }
                    return message;
                };

                /**
                 * Creates a RaftRangeNode message from a plain object. Also converts values to their respective internal types.
                 * This is an alias of {@link cockroach.server.serverpb.RaftRangeNode.fromObject}.
                 * @function
                 * @param {Object.<string,*>} object Plain object
                 * @returns {cockroach.server.serverpb.RaftRangeNode} RaftRangeNode
                 */
                RaftRangeNode.from = RaftRangeNode.fromObject;

                /**
                 * Creates a plain object from a RaftRangeNode message. Also converts values to other types if specified.
                 * @param {cockroach.server.serverpb.RaftRangeNode} message RaftRangeNode
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                RaftRangeNode.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.node_id = 0;
                        object.range = null;
                    }
                    if (message.node_id != null && message.hasOwnProperty("node_id"))
                        object.node_id = message.node_id;
                    if (message.range != null && message.hasOwnProperty("range"))
                        object.range = $root.cockroach.server.serverpb.RangeInfo.toObject(message.range, options);
                    return object;
                };

                /**
                 * Creates a plain object from this RaftRangeNode message. Also converts values to other types if specified.
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                RaftRangeNode.prototype.toObject = function toObject(options) {
                    return this.constructor.toObject(this, options);
                };

                /**
                 * Converts this RaftRangeNode to JSON.
                 * @returns {Object.<string,*>} JSON object
                 */
                RaftRangeNode.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return RaftRangeNode;
            })();

            serverpb.RaftRangeError = (function() {

                /**
                 * Properties of a RaftRangeError.
                 * @typedef cockroach.server.serverpb.RaftRangeError$Properties
                 * @type {Object}
                 * @property {string} [message] RaftRangeError message.
                 */

                /**
                 * Constructs a new RaftRangeError.
                 * @exports cockroach.server.serverpb.RaftRangeError
                 * @constructor
                 * @param {cockroach.server.serverpb.RaftRangeError$Properties=} [properties] Properties to set
                 */
                function RaftRangeError(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * RaftRangeError message.
                 * @type {string}
                 */
                RaftRangeError.prototype.message = "";

                /**
                 * Creates a new RaftRangeError instance using the specified properties.
                 * @param {cockroach.server.serverpb.RaftRangeError$Properties=} [properties] Properties to set
                 * @returns {cockroach.server.serverpb.RaftRangeError} RaftRangeError instance
                 */
                RaftRangeError.create = function create(properties) {
                    return new RaftRangeError(properties);
                };

                /**
                 * Encodes the specified RaftRangeError message. Does not implicitly {@link cockroach.server.serverpb.RaftRangeError.verify|verify} messages.
                 * @param {cockroach.server.serverpb.RaftRangeError$Properties} message RaftRangeError message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                RaftRangeError.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.message != null && message.hasOwnProperty("message"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.message);
                    return writer;
                };

                /**
                 * Encodes the specified RaftRangeError message, length delimited. Does not implicitly {@link cockroach.server.serverpb.RaftRangeError.verify|verify} messages.
                 * @param {cockroach.server.serverpb.RaftRangeError$Properties} message RaftRangeError message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                RaftRangeError.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a RaftRangeError message from the specified reader or buffer.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {cockroach.server.serverpb.RaftRangeError} RaftRangeError
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                RaftRangeError.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.cockroach.server.serverpb.RaftRangeError();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.message = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a RaftRangeError message from the specified reader or buffer, length delimited.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {cockroach.server.serverpb.RaftRangeError} RaftRangeError
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                RaftRangeError.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a RaftRangeError message.
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {?string} `null` if valid, otherwise the reason why it is not
                 */
                RaftRangeError.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.message != null && message.hasOwnProperty("message"))
                        if (!$util.isString(message.message))
                            return "message: string expected";
                    return null;
                };

                /**
                 * Creates a RaftRangeError message from a plain object. Also converts values to their respective internal types.
                 * @param {Object.<string,*>} object Plain object
                 * @returns {cockroach.server.serverpb.RaftRangeError} RaftRangeError
                 */
                RaftRangeError.fromObject = function fromObject(object) {
                    if (object instanceof $root.cockroach.server.serverpb.RaftRangeError)
                        return object;
                    let message = new $root.cockroach.server.serverpb.RaftRangeError();
                    if (object.message != null)
                        message.message = String(object.message);
                    return message;
                };

                /**
                 * Creates a RaftRangeError message from a plain object. Also converts values to their respective internal types.
                 * This is an alias of {@link cockroach.server.serverpb.RaftRangeError.fromObject}.
                 * @function
                 * @param {Object.<string,*>} object Plain object
                 * @returns {cockroach.server.serverpb.RaftRangeError} RaftRangeError
                 */
                RaftRangeError.from = RaftRangeError.fromObject;

                /**
                 * Creates a plain object from a RaftRangeError message. Also converts values to other types if specified.
                 * @param {cockroach.server.serverpb.RaftRangeError} message RaftRangeError
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                RaftRangeError.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults)
                        object.message = "";
                    if (message.message != null && message.hasOwnProperty("message"))
                        object.message = message.message;
                    return object;
                };

                /**
                 * Creates a plain object from this RaftRangeError message. Also converts values to other types if specified.
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                RaftRangeError.prototype.toObject = function toObject(options) {
                    return this.constructor.toObject(this, options);
                };

                /**
                 * Converts this RaftRangeError to JSON.
                 * @returns {Object.<string,*>} JSON object
                 */
                RaftRangeError.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return RaftRangeError;
            })();

            serverpb.RaftRangeStatus = (function() {

                /**
                 * Properties of a RaftRangeStatus.
                 * @typedef cockroach.server.serverpb.RaftRangeStatus$Properties
                 * @type {Object}
                 * @property {Long} [range_id] RaftRangeStatus range_id.
                 * @property {Array.<cockroach.server.serverpb.RaftRangeError$Properties>} [errors] RaftRangeStatus errors.
                 * @property {Array.<cockroach.server.serverpb.RaftRangeNode$Properties>} [nodes] RaftRangeStatus nodes.
                 */

                /**
                 * Constructs a new RaftRangeStatus.
                 * @exports cockroach.server.serverpb.RaftRangeStatus
                 * @constructor
                 * @param {cockroach.server.serverpb.RaftRangeStatus$Properties=} [properties] Properties to set
                 */
                function RaftRangeStatus(properties) {
                    this.errors = [];
                    this.nodes = [];
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * RaftRangeStatus range_id.
                 * @type {Long}
                 */
                RaftRangeStatus.prototype.range_id = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

                /**
                 * RaftRangeStatus errors.
                 * @type {Array.<cockroach.server.serverpb.RaftRangeError$Properties>}
                 */
                RaftRangeStatus.prototype.errors = $util.emptyArray;

                /**
                 * RaftRangeStatus nodes.
                 * @type {Array.<cockroach.server.serverpb.RaftRangeNode$Properties>}
                 */
                RaftRangeStatus.prototype.nodes = $util.emptyArray;

                /**
                 * Creates a new RaftRangeStatus instance using the specified properties.
                 * @param {cockroach.server.serverpb.RaftRangeStatus$Properties=} [properties] Properties to set
                 * @returns {cockroach.server.serverpb.RaftRangeStatus} RaftRangeStatus instance
                 */
                RaftRangeStatus.create = function create(properties) {
                    return new RaftRangeStatus(properties);
                };

                /**
                 * Encodes the specified RaftRangeStatus message. Does not implicitly {@link cockroach.server.serverpb.RaftRangeStatus.verify|verify} messages.
                 * @param {cockroach.server.serverpb.RaftRangeStatus$Properties} message RaftRangeStatus message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                RaftRangeStatus.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.range_id != null && message.hasOwnProperty("range_id"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int64(message.range_id);
                    if (message.errors != null && message.errors.length)
                        for (let i = 0; i < message.errors.length; ++i)
                            $root.cockroach.server.serverpb.RaftRangeError.encode(message.errors[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.nodes != null && message.nodes.length)
                        for (let i = 0; i < message.nodes.length; ++i)
                            $root.cockroach.server.serverpb.RaftRangeNode.encode(message.nodes[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified RaftRangeStatus message, length delimited. Does not implicitly {@link cockroach.server.serverpb.RaftRangeStatus.verify|verify} messages.
                 * @param {cockroach.server.serverpb.RaftRangeStatus$Properties} message RaftRangeStatus message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                RaftRangeStatus.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a RaftRangeStatus message from the specified reader or buffer.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {cockroach.server.serverpb.RaftRangeStatus} RaftRangeStatus
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                RaftRangeStatus.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.cockroach.server.serverpb.RaftRangeStatus();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.range_id = reader.int64();
                            break;
                        case 2:
                            if (!(message.errors && message.errors.length))
                                message.errors = [];
                            message.errors.push($root.cockroach.server.serverpb.RaftRangeError.decode(reader, reader.uint32()));
                            break;
                        case 3:
                            if (!(message.nodes && message.nodes.length))
                                message.nodes = [];
                            message.nodes.push($root.cockroach.server.serverpb.RaftRangeNode.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a RaftRangeStatus message from the specified reader or buffer, length delimited.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {cockroach.server.serverpb.RaftRangeStatus} RaftRangeStatus
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                RaftRangeStatus.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a RaftRangeStatus message.
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {?string} `null` if valid, otherwise the reason why it is not
                 */
                RaftRangeStatus.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.range_id != null && message.hasOwnProperty("range_id"))
                        if (!$util.isInteger(message.range_id) && !(message.range_id && $util.isInteger(message.range_id.low) && $util.isInteger(message.range_id.high)))
                            return "range_id: integer|Long expected";
                    if (message.errors != null && message.hasOwnProperty("errors")) {
                        if (!Array.isArray(message.errors))
                            return "errors: array expected";
                        for (let i = 0; i < message.errors.length; ++i) {
                            let error = $root.cockroach.server.serverpb.RaftRangeError.verify(message.errors[i]);
                            if (error)
                                return "errors." + error;
                        }
                    }
                    if (message.nodes != null && message.hasOwnProperty("nodes")) {
                        if (!Array.isArray(message.nodes))
                            return "nodes: array expected";
                        for (let i = 0; i < message.nodes.length; ++i) {
                            let error = $root.cockroach.server.serverpb.RaftRangeNode.verify(message.nodes[i]);
                            if (error)
                                return "nodes." + error;
                        }
                    }
                    return null;
                };

                /**
                 * Creates a RaftRangeStatus message from a plain object. Also converts values to their respective internal types.
                 * @param {Object.<string,*>} object Plain object
                 * @returns {cockroach.server.serverpb.RaftRangeStatus} RaftRangeStatus
                 */
                RaftRangeStatus.fromObject = function fromObject(object) {
                    if (object instanceof $root.cockroach.server.serverpb.RaftRangeStatus)
                        return object;
                    let message = new $root.cockroach.server.serverpb.RaftRangeStatus();
                    if (object.range_id != null)
                        if ($util.Long)
                            (message.range_id = $util.Long.fromValue(object.range_id)).unsigned = false;
                        else if (typeof object.range_id === "string")
                            message.range_id = parseInt(object.range_id, 10);
                        else if (typeof object.range_id === "number")
                            message.range_id = object.range_id;
                        else if (typeof object.range_id === "object")
                            message.range_id = new $util.LongBits(object.range_id.low >>> 0, object.range_id.high >>> 0).toNumber();
                    if (object.errors) {
                        if (!Array.isArray(object.errors))
                            throw TypeError(".cockroach.server.serverpb.RaftRangeStatus.errors: array expected");
                        message.errors = [];
                        for (let i = 0; i < object.errors.length; ++i) {
                            if (typeof object.errors[i] !== "object")
                                throw TypeError(".cockroach.server.serverpb.RaftRangeStatus.errors: object expected");
                            message.errors[i] = $root.cockroach.server.serverpb.RaftRangeError.fromObject(object.errors[i]);
                        }
                    }
                    if (object.nodes) {
                        if (!Array.isArray(object.nodes))
                            throw TypeError(".cockroach.server.serverpb.RaftRangeStatus.nodes: array expected");
                        message.nodes = [];
                        for (let i = 0; i < object.nodes.length; ++i) {
                            if (typeof object.nodes[i] !== "object")
                                throw TypeError(".cockroach.server.serverpb.RaftRangeStatus.nodes: object expected");
                            message.nodes[i] = $root.cockroach.server.serverpb.RaftRangeNode.fromObject(object.nodes[i]);
                        }
                    }
                    return message;
                };

                /**
                 * Creates a RaftRangeStatus message from a plain object. Also converts values to their respective internal types.
                 * This is an alias of {@link cockroach.server.serverpb.RaftRangeStatus.fromObject}.
                 * @function
                 * @param {Object.<string,*>} object Plain object
                 * @returns {cockroach.server.serverpb.RaftRangeStatus} RaftRangeStatus
                 */
                RaftRangeStatus.from = RaftRangeStatus.fromObject;

                /**
                 * Creates a plain object from a RaftRangeStatus message. Also converts values to other types if specified.
                 * @param {cockroach.server.serverpb.RaftRangeStatus} message RaftRangeStatus
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                RaftRangeStatus.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.arrays || options.defaults) {
                        object.errors = [];
                        object.nodes = [];
                    }
                    if (options.defaults)
                        if ($util.Long) {
                            let long = new $util.Long(0, 0, false);
                            object.range_id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.range_id = options.longs === String ? "0" : 0;
                    if (message.range_id != null && message.hasOwnProperty("range_id"))
                        if (typeof message.range_id === "number")
                            object.range_id = options.longs === String ? String(message.range_id) : message.range_id;
                        else
                            object.range_id = options.longs === String ? $util.Long.prototype.toString.call(message.range_id) : options.longs === Number ? new $util.LongBits(message.range_id.low >>> 0, message.range_id.high >>> 0).toNumber() : message.range_id;
                    if (message.errors && message.errors.length) {
                        object.errors = [];
                        for (let j = 0; j < message.errors.length; ++j)
                            object.errors[j] = $root.cockroach.server.serverpb.RaftRangeError.toObject(message.errors[j], options);
                    }
                    if (message.nodes && message.nodes.length) {
                        object.nodes = [];
                        for (let j = 0; j < message.nodes.length; ++j)
                            object.nodes[j] = $root.cockroach.server.serverpb.RaftRangeNode.toObject(message.nodes[j], options);
                    }
                    return object;
                };

                /**
                 * Creates a plain object from this RaftRangeStatus message. Also converts values to other types if specified.
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                RaftRangeStatus.prototype.toObject = function toObject(options) {
                    return this.constructor.toObject(this, options);
                };

                /**
                 * Converts this RaftRangeStatus to JSON.
                 * @returns {Object.<string,*>} JSON object
                 */
                RaftRangeStatus.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return RaftRangeStatus;
            })();

            serverpb.RaftDebugRequest = (function() {

                /**
                 * Properties of a RaftDebugRequest.
                 * @typedef cockroach.server.serverpb.RaftDebugRequest$Properties
                 * @type {Object}
                 * @property {Array.<Long>} [range_ids] RaftDebugRequest range_ids.
                 */

                /**
                 * Constructs a new RaftDebugRequest.
                 * @exports cockroach.server.serverpb.RaftDebugRequest
                 * @constructor
                 * @param {cockroach.server.serverpb.RaftDebugRequest$Properties=} [properties] Properties to set
                 */
                function RaftDebugRequest(properties) {
                    this.range_ids = [];
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * RaftDebugRequest range_ids.
                 * @type {Array.<Long>}
                 */
                RaftDebugRequest.prototype.range_ids = $util.emptyArray;

                /**
                 * Creates a new RaftDebugRequest instance using the specified properties.
                 * @param {cockroach.server.serverpb.RaftDebugRequest$Properties=} [properties] Properties to set
                 * @returns {cockroach.server.serverpb.RaftDebugRequest} RaftDebugRequest instance
                 */
                RaftDebugRequest.create = function create(properties) {
                    return new RaftDebugRequest(properties);
                };

                /**
                 * Encodes the specified RaftDebugRequest message. Does not implicitly {@link cockroach.server.serverpb.RaftDebugRequest.verify|verify} messages.
                 * @param {cockroach.server.serverpb.RaftDebugRequest$Properties} message RaftDebugRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                RaftDebugRequest.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.range_ids != null && message.range_ids.length) {
                        writer.uint32(/* id 1, wireType 2 =*/10).fork();
                        for (let i = 0; i < message.range_ids.length; ++i)
                            writer.int64(message.range_ids[i]);
                        writer.ldelim();
                    }
                    return writer;
                };

                /**
                 * Encodes the specified RaftDebugRequest message, length delimited. Does not implicitly {@link cockroach.server.serverpb.RaftDebugRequest.verify|verify} messages.
                 * @param {cockroach.server.serverpb.RaftDebugRequest$Properties} message RaftDebugRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                RaftDebugRequest.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a RaftDebugRequest message from the specified reader or buffer.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {cockroach.server.serverpb.RaftDebugRequest} RaftDebugRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                RaftDebugRequest.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.cockroach.server.serverpb.RaftDebugRequest();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (!(message.range_ids && message.range_ids.length))
                                message.range_ids = [];
                            if ((tag & 7) === 2) {
                                let end2 = reader.uint32() + reader.pos;
                                while (reader.pos < end2)
                                    message.range_ids.push(reader.int64());
                            } else
                                message.range_ids.push(reader.int64());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a RaftDebugRequest message from the specified reader or buffer, length delimited.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {cockroach.server.serverpb.RaftDebugRequest} RaftDebugRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                RaftDebugRequest.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a RaftDebugRequest message.
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {?string} `null` if valid, otherwise the reason why it is not
                 */
                RaftDebugRequest.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.range_ids != null && message.hasOwnProperty("range_ids")) {
                        if (!Array.isArray(message.range_ids))
                            return "range_ids: array expected";
                        for (let i = 0; i < message.range_ids.length; ++i)
                            if (!$util.isInteger(message.range_ids[i]) && !(message.range_ids[i] && $util.isInteger(message.range_ids[i].low) && $util.isInteger(message.range_ids[i].high)))
                                return "range_ids: integer|Long[] expected";
                    }
                    return null;
                };

                /**
                 * Creates a RaftDebugRequest message from a plain object. Also converts values to their respective internal types.
                 * @param {Object.<string,*>} object Plain object
                 * @returns {cockroach.server.serverpb.RaftDebugRequest} RaftDebugRequest
                 */
                RaftDebugRequest.fromObject = function fromObject(object) {
                    if (object instanceof $root.cockroach.server.serverpb.RaftDebugRequest)
                        return object;
                    let message = new $root.cockroach.server.serverpb.RaftDebugRequest();
                    if (object.range_ids) {
                        if (!Array.isArray(object.range_ids))
                            throw TypeError(".cockroach.server.serverpb.RaftDebugRequest.range_ids: array expected");
                        message.range_ids = [];
                        for (let i = 0; i < object.range_ids.length; ++i)
                            if ($util.Long)
                                (message.range_ids[i] = $util.Long.fromValue(object.range_ids[i])).unsigned = false;
                            else if (typeof object.range_ids[i] === "string")
                                message.range_ids[i] = parseInt(object.range_ids[i], 10);
                            else if (typeof object.range_ids[i] === "number")
                                message.range_ids[i] = object.range_ids[i];
                            else if (typeof object.range_ids[i] === "object")
                                message.range_ids[i] = new $util.LongBits(object.range_ids[i].low >>> 0, object.range_ids[i].high >>> 0).toNumber();
                    }
                    return message;
                };

                /**
                 * Creates a RaftDebugRequest message from a plain object. Also converts values to their respective internal types.
                 * This is an alias of {@link cockroach.server.serverpb.RaftDebugRequest.fromObject}.
                 * @function
                 * @param {Object.<string,*>} object Plain object
                 * @returns {cockroach.server.serverpb.RaftDebugRequest} RaftDebugRequest
                 */
                RaftDebugRequest.from = RaftDebugRequest.fromObject;

                /**
                 * Creates a plain object from a RaftDebugRequest message. Also converts values to other types if specified.
                 * @param {cockroach.server.serverpb.RaftDebugRequest} message RaftDebugRequest
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                RaftDebugRequest.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.arrays || options.defaults)
                        object.range_ids = [];
                    if (message.range_ids && message.range_ids.length) {
                        object.range_ids = [];
                        for (let j = 0; j < message.range_ids.length; ++j)
                            if (typeof message.range_ids[j] === "number")
                                object.range_ids[j] = options.longs === String ? String(message.range_ids[j]) : message.range_ids[j];
                            else
                                object.range_ids[j] = options.longs === String ? $util.Long.prototype.toString.call(message.range_ids[j]) : options.longs === Number ? new $util.LongBits(message.range_ids[j].low >>> 0, message.range_ids[j].high >>> 0).toNumber() : message.range_ids[j];
                    }
                    return object;
                };

                /**
                 * Creates a plain object from this RaftDebugRequest message. Also converts values to other types if specified.
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                RaftDebugRequest.prototype.toObject = function toObject(options) {
                    return this.constructor.toObject(this, options);
                };

                /**
                 * Converts this RaftDebugRequest to JSON.
                 * @returns {Object.<string,*>} JSON object
                 */
                RaftDebugRequest.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return RaftDebugRequest;
            })();

            serverpb.RaftDebugResponse = (function() {

                /**
                 * Properties of a RaftDebugResponse.
                 * @typedef cockroach.server.serverpb.RaftDebugResponse$Properties
                 * @type {Object}
                 * @property {Object.<string,cockroach.server.serverpb.RaftRangeStatus$Properties>} [ranges] RaftDebugResponse ranges.
                 * @property {Array.<cockroach.server.serverpb.RaftRangeError$Properties>} [errors] RaftDebugResponse errors.
                 */

                /**
                 * Constructs a new RaftDebugResponse.
                 * @exports cockroach.server.serverpb.RaftDebugResponse
                 * @constructor
                 * @param {cockroach.server.serverpb.RaftDebugResponse$Properties=} [properties] Properties to set
                 */
                function RaftDebugResponse(properties) {
                    this.ranges = {};
                    this.errors = [];
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * RaftDebugResponse ranges.
                 * @type {Object.<string,cockroach.server.serverpb.RaftRangeStatus$Properties>}
                 */
                RaftDebugResponse.prototype.ranges = $util.emptyObject;

                /**
                 * RaftDebugResponse errors.
                 * @type {Array.<cockroach.server.serverpb.RaftRangeError$Properties>}
                 */
                RaftDebugResponse.prototype.errors = $util.emptyArray;

                /**
                 * Creates a new RaftDebugResponse instance using the specified properties.
                 * @param {cockroach.server.serverpb.RaftDebugResponse$Properties=} [properties] Properties to set
                 * @returns {cockroach.server.serverpb.RaftDebugResponse} RaftDebugResponse instance
                 */
                RaftDebugResponse.create = function create(properties) {
                    return new RaftDebugResponse(properties);
                };

                /**
                 * Encodes the specified RaftDebugResponse message. Does not implicitly {@link cockroach.server.serverpb.RaftDebugResponse.verify|verify} messages.
                 * @param {cockroach.server.serverpb.RaftDebugResponse$Properties} message RaftDebugResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                RaftDebugResponse.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.ranges != null && message.hasOwnProperty("ranges"))
                        for (let keys = Object.keys(message.ranges), i = 0; i < keys.length; ++i) {
                            writer.uint32(/* id 1, wireType 2 =*/10).fork().uint32(/* id 1, wireType 0 =*/8).int64(keys[i]);
                            $root.cockroach.server.serverpb.RaftRangeStatus.encode(message.ranges[keys[i]], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim().ldelim();
                        }
                    if (message.errors != null && message.errors.length)
                        for (let i = 0; i < message.errors.length; ++i)
                            $root.cockroach.server.serverpb.RaftRangeError.encode(message.errors[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified RaftDebugResponse message, length delimited. Does not implicitly {@link cockroach.server.serverpb.RaftDebugResponse.verify|verify} messages.
                 * @param {cockroach.server.serverpb.RaftDebugResponse$Properties} message RaftDebugResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                RaftDebugResponse.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a RaftDebugResponse message from the specified reader or buffer.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {cockroach.server.serverpb.RaftDebugResponse} RaftDebugResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                RaftDebugResponse.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.cockroach.server.serverpb.RaftDebugResponse(), key;
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            reader.skip().pos++;
                            if (message.ranges === $util.emptyObject)
                                message.ranges = {};
                            key = reader.int64();
                            reader.pos++;
                            message.ranges[typeof key === "object" ? $util.longToHash(key) : key] = $root.cockroach.server.serverpb.RaftRangeStatus.decode(reader, reader.uint32());
                            break;
                        case 2:
                            if (!(message.errors && message.errors.length))
                                message.errors = [];
                            message.errors.push($root.cockroach.server.serverpb.RaftRangeError.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a RaftDebugResponse message from the specified reader or buffer, length delimited.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {cockroach.server.serverpb.RaftDebugResponse} RaftDebugResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                RaftDebugResponse.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a RaftDebugResponse message.
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {?string} `null` if valid, otherwise the reason why it is not
                 */
                RaftDebugResponse.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.ranges != null && message.hasOwnProperty("ranges")) {
                        if (!$util.isObject(message.ranges))
                            return "ranges: object expected";
                        let key = Object.keys(message.ranges);
                        for (let i = 0; i < key.length; ++i) {
                            if (!$util.key64Re.test(key[i]))
                                return "ranges: integer|Long key{k:int64} expected";
                            let error = $root.cockroach.server.serverpb.RaftRangeStatus.verify(message.ranges[key[i]]);
                            if (error)
                                return "ranges." + error;
                        }
                    }
                    if (message.errors != null && message.hasOwnProperty("errors")) {
                        if (!Array.isArray(message.errors))
                            return "errors: array expected";
                        for (let i = 0; i < message.errors.length; ++i) {
                            let error = $root.cockroach.server.serverpb.RaftRangeError.verify(message.errors[i]);
                            if (error)
                                return "errors." + error;
                        }
                    }
                    return null;
                };

                /**
                 * Creates a RaftDebugResponse message from a plain object. Also converts values to their respective internal types.
                 * @param {Object.<string,*>} object Plain object
                 * @returns {cockroach.server.serverpb.RaftDebugResponse} RaftDebugResponse
                 */
                RaftDebugResponse.fromObject = function fromObject(object) {
                    if (object instanceof $root.cockroach.server.serverpb.RaftDebugResponse)
                        return object;
                    let message = new $root.cockroach.server.serverpb.RaftDebugResponse();
                    if (object.ranges) {
                        if (typeof object.ranges !== "object")
                            throw TypeError(".cockroach.server.serverpb.RaftDebugResponse.ranges: object expected");
                        message.ranges = {};
                        for (let keys = Object.keys(object.ranges), i = 0; i < keys.length; ++i) {
                            if (typeof object.ranges[keys[i]] !== "object")
                                throw TypeError(".cockroach.server.serverpb.RaftDebugResponse.ranges: object expected");
                            message.ranges[keys[i]] = $root.cockroach.server.serverpb.RaftRangeStatus.fromObject(object.ranges[keys[i]]);
                        }
                    }
                    if (object.errors) {
                        if (!Array.isArray(object.errors))
                            throw TypeError(".cockroach.server.serverpb.RaftDebugResponse.errors: array expected");
                        message.errors = [];
                        for (let i = 0; i < object.errors.length; ++i) {
                            if (typeof object.errors[i] !== "object")
                                throw TypeError(".cockroach.server.serverpb.RaftDebugResponse.errors: object expected");
                            message.errors[i] = $root.cockroach.server.serverpb.RaftRangeError.fromObject(object.errors[i]);
                        }
                    }
                    return message;
                };

                /**
                 * Creates a RaftDebugResponse message from a plain object. Also converts values to their respective internal types.
                 * This is an alias of {@link cockroach.server.serverpb.RaftDebugResponse.fromObject}.
                 * @function
                 * @param {Object.<string,*>} object Plain object
                 * @returns {cockroach.server.serverpb.RaftDebugResponse} RaftDebugResponse
                 */
                RaftDebugResponse.from = RaftDebugResponse.fromObject;

                /**
                 * Creates a plain object from a RaftDebugResponse message. Also converts values to other types if specified.
                 * @param {cockroach.server.serverpb.RaftDebugResponse} message RaftDebugResponse
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                RaftDebugResponse.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.arrays || options.defaults)
                        object.errors = [];
                    if (options.objects || options.defaults)
                        object.ranges = {};
                    let keys2;
                    if (message.ranges && (keys2 = Object.keys(message.ranges)).length) {
                        object.ranges = {};
                        for (let j = 0; j < keys2.length; ++j)
                            object.ranges[keys2[j]] = $root.cockroach.server.serverpb.RaftRangeStatus.toObject(message.ranges[keys2[j]], options);
                    }
                    if (message.errors && message.errors.length) {
                        object.errors = [];
                        for (let j = 0; j < message.errors.length; ++j)
                            object.errors[j] = $root.cockroach.server.serverpb.RaftRangeError.toObject(message.errors[j], options);
                    }
                    return object;
                };

                /**
                 * Creates a plain object from this RaftDebugResponse message. Also converts values to other types if specified.
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                RaftDebugResponse.prototype.toObject = function toObject(options) {
                    return this.constructor.toObject(this, options);
                };

                /**
                 * Converts this RaftDebugResponse to JSON.
                 * @returns {Object.<string,*>} JSON object
                 */
                RaftDebugResponse.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return RaftDebugResponse;
            })();

            serverpb.SpanStatsRequest = (function() {

                /**
                 * Properties of a SpanStatsRequest.
                 * @typedef cockroach.server.serverpb.SpanStatsRequest$Properties
                 * @type {Object}
                 * @property {string} [node_id] SpanStatsRequest node_id.
                 * @property {Uint8Array} [start_key] SpanStatsRequest start_key.
                 * @property {Uint8Array} [end_key] SpanStatsRequest end_key.
                 */

                /**
                 * Constructs a new SpanStatsRequest.
                 * @exports cockroach.server.serverpb.SpanStatsRequest
                 * @constructor
                 * @param {cockroach.server.serverpb.SpanStatsRequest$Properties=} [properties] Properties to set
                 */
                function SpanStatsRequest(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * SpanStatsRequest node_id.
                 * @type {string}
                 */
                SpanStatsRequest.prototype.node_id = "";

                /**
                 * SpanStatsRequest start_key.
                 * @type {Uint8Array}
                 */
                SpanStatsRequest.prototype.start_key = $util.newBuffer([]);

                /**
                 * SpanStatsRequest end_key.
                 * @type {Uint8Array}
                 */
                SpanStatsRequest.prototype.end_key = $util.newBuffer([]);

                /**
                 * Creates a new SpanStatsRequest instance using the specified properties.
                 * @param {cockroach.server.serverpb.SpanStatsRequest$Properties=} [properties] Properties to set
                 * @returns {cockroach.server.serverpb.SpanStatsRequest} SpanStatsRequest instance
                 */
                SpanStatsRequest.create = function create(properties) {
                    return new SpanStatsRequest(properties);
                };

                /**
                 * Encodes the specified SpanStatsRequest message. Does not implicitly {@link cockroach.server.serverpb.SpanStatsRequest.verify|verify} messages.
                 * @param {cockroach.server.serverpb.SpanStatsRequest$Properties} message SpanStatsRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                SpanStatsRequest.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.node_id != null && message.hasOwnProperty("node_id"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.node_id);
                    if (message.start_key != null && message.hasOwnProperty("start_key"))
                        writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.start_key);
                    if (message.end_key != null && message.hasOwnProperty("end_key"))
                        writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.end_key);
                    return writer;
                };

                /**
                 * Encodes the specified SpanStatsRequest message, length delimited. Does not implicitly {@link cockroach.server.serverpb.SpanStatsRequest.verify|verify} messages.
                 * @param {cockroach.server.serverpb.SpanStatsRequest$Properties} message SpanStatsRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                SpanStatsRequest.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a SpanStatsRequest message from the specified reader or buffer.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {cockroach.server.serverpb.SpanStatsRequest} SpanStatsRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                SpanStatsRequest.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.cockroach.server.serverpb.SpanStatsRequest();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.node_id = reader.string();
                            break;
                        case 2:
                            message.start_key = reader.bytes();
                            break;
                        case 3:
                            message.end_key = reader.bytes();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a SpanStatsRequest message from the specified reader or buffer, length delimited.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {cockroach.server.serverpb.SpanStatsRequest} SpanStatsRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                SpanStatsRequest.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a SpanStatsRequest message.
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {?string} `null` if valid, otherwise the reason why it is not
                 */
                SpanStatsRequest.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.node_id != null && message.hasOwnProperty("node_id"))
                        if (!$util.isString(message.node_id))
                            return "node_id: string expected";
                    if (message.start_key != null && message.hasOwnProperty("start_key"))
                        if (!(message.start_key && typeof message.start_key.length === "number" || $util.isString(message.start_key)))
                            return "start_key: buffer expected";
                    if (message.end_key != null && message.hasOwnProperty("end_key"))
                        if (!(message.end_key && typeof message.end_key.length === "number" || $util.isString(message.end_key)))
                            return "end_key: buffer expected";
                    return null;
                };

                /**
                 * Creates a SpanStatsRequest message from a plain object. Also converts values to their respective internal types.
                 * @param {Object.<string,*>} object Plain object
                 * @returns {cockroach.server.serverpb.SpanStatsRequest} SpanStatsRequest
                 */
                SpanStatsRequest.fromObject = function fromObject(object) {
                    if (object instanceof $root.cockroach.server.serverpb.SpanStatsRequest)
                        return object;
                    let message = new $root.cockroach.server.serverpb.SpanStatsRequest();
                    if (object.node_id != null)
                        message.node_id = String(object.node_id);
                    if (object.start_key != null)
                        if (typeof object.start_key === "string")
                            $util.base64.decode(object.start_key, message.start_key = $util.newBuffer($util.base64.length(object.start_key)), 0);
                        else if (object.start_key.length)
                            message.start_key = object.start_key;
                    if (object.end_key != null)
                        if (typeof object.end_key === "string")
                            $util.base64.decode(object.end_key, message.end_key = $util.newBuffer($util.base64.length(object.end_key)), 0);
                        else if (object.end_key.length)
                            message.end_key = object.end_key;
                    return message;
                };

                /**
                 * Creates a SpanStatsRequest message from a plain object. Also converts values to their respective internal types.
                 * This is an alias of {@link cockroach.server.serverpb.SpanStatsRequest.fromObject}.
                 * @function
                 * @param {Object.<string,*>} object Plain object
                 * @returns {cockroach.server.serverpb.SpanStatsRequest} SpanStatsRequest
                 */
                SpanStatsRequest.from = SpanStatsRequest.fromObject;

                /**
                 * Creates a plain object from a SpanStatsRequest message. Also converts values to other types if specified.
                 * @param {cockroach.server.serverpb.SpanStatsRequest} message SpanStatsRequest
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                SpanStatsRequest.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.node_id = "";
                        object.start_key = options.bytes === String ? "" : [];
                        object.end_key = options.bytes === String ? "" : [];
                    }
                    if (message.node_id != null && message.hasOwnProperty("node_id"))
                        object.node_id = message.node_id;
                    if (message.start_key != null && message.hasOwnProperty("start_key"))
                        object.start_key = options.bytes === String ? $util.base64.encode(message.start_key, 0, message.start_key.length) : options.bytes === Array ? Array.prototype.slice.call(message.start_key) : message.start_key;
                    if (message.end_key != null && message.hasOwnProperty("end_key"))
                        object.end_key = options.bytes === String ? $util.base64.encode(message.end_key, 0, message.end_key.length) : options.bytes === Array ? Array.prototype.slice.call(message.end_key) : message.end_key;
                    return object;
                };

                /**
                 * Creates a plain object from this SpanStatsRequest message. Also converts values to other types if specified.
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                SpanStatsRequest.prototype.toObject = function toObject(options) {
                    return this.constructor.toObject(this, options);
                };

                /**
                 * Converts this SpanStatsRequest to JSON.
                 * @returns {Object.<string,*>} JSON object
                 */
                SpanStatsRequest.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return SpanStatsRequest;
            })();

            serverpb.SpanStatsResponse = (function() {

                /**
                 * Properties of a SpanStatsResponse.
                 * @typedef cockroach.server.serverpb.SpanStatsResponse$Properties
                 * @type {Object}
                 * @property {number} [range_count] SpanStatsResponse range_count.
                 * @property {cockroach.storage.engine.enginepb.MVCCStats$Properties} [total_stats] SpanStatsResponse total_stats.
                 */

                /**
                 * Constructs a new SpanStatsResponse.
                 * @exports cockroach.server.serverpb.SpanStatsResponse
                 * @constructor
                 * @param {cockroach.server.serverpb.SpanStatsResponse$Properties=} [properties] Properties to set
                 */
                function SpanStatsResponse(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * SpanStatsResponse range_count.
                 * @type {number}
                 */
                SpanStatsResponse.prototype.range_count = 0;

                /**
                 * SpanStatsResponse total_stats.
                 * @type {(cockroach.storage.engine.enginepb.MVCCStats$Properties|null)}
                 */
                SpanStatsResponse.prototype.total_stats = null;

                /**
                 * Creates a new SpanStatsResponse instance using the specified properties.
                 * @param {cockroach.server.serverpb.SpanStatsResponse$Properties=} [properties] Properties to set
                 * @returns {cockroach.server.serverpb.SpanStatsResponse} SpanStatsResponse instance
                 */
                SpanStatsResponse.create = function create(properties) {
                    return new SpanStatsResponse(properties);
                };

                /**
                 * Encodes the specified SpanStatsResponse message. Does not implicitly {@link cockroach.server.serverpb.SpanStatsResponse.verify|verify} messages.
                 * @param {cockroach.server.serverpb.SpanStatsResponse$Properties} message SpanStatsResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                SpanStatsResponse.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.total_stats != null && message.hasOwnProperty("total_stats"))
                        $root.cockroach.storage.engine.enginepb.MVCCStats.encode(message.total_stats, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.range_count != null && message.hasOwnProperty("range_count"))
                        writer.uint32(/* id 2, wireType 0 =*/16).int32(message.range_count);
                    return writer;
                };

                /**
                 * Encodes the specified SpanStatsResponse message, length delimited. Does not implicitly {@link cockroach.server.serverpb.SpanStatsResponse.verify|verify} messages.
                 * @param {cockroach.server.serverpb.SpanStatsResponse$Properties} message SpanStatsResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                SpanStatsResponse.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a SpanStatsResponse message from the specified reader or buffer.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {cockroach.server.serverpb.SpanStatsResponse} SpanStatsResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                SpanStatsResponse.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.cockroach.server.serverpb.SpanStatsResponse();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 2:
                            message.range_count = reader.int32();
                            break;
                        case 1:
                            message.total_stats = $root.cockroach.storage.engine.enginepb.MVCCStats.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a SpanStatsResponse message from the specified reader or buffer, length delimited.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {cockroach.server.serverpb.SpanStatsResponse} SpanStatsResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                SpanStatsResponse.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a SpanStatsResponse message.
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {?string} `null` if valid, otherwise the reason why it is not
                 */
                SpanStatsResponse.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.range_count != null && message.hasOwnProperty("range_count"))
                        if (!$util.isInteger(message.range_count))
                            return "range_count: integer expected";
                    if (message.total_stats != null && message.hasOwnProperty("total_stats")) {
                        let error = $root.cockroach.storage.engine.enginepb.MVCCStats.verify(message.total_stats);
                        if (error)
                            return "total_stats." + error;
                    }
                    return null;
                };

                /**
                 * Creates a SpanStatsResponse message from a plain object. Also converts values to their respective internal types.
                 * @param {Object.<string,*>} object Plain object
                 * @returns {cockroach.server.serverpb.SpanStatsResponse} SpanStatsResponse
                 */
                SpanStatsResponse.fromObject = function fromObject(object) {
                    if (object instanceof $root.cockroach.server.serverpb.SpanStatsResponse)
                        return object;
                    let message = new $root.cockroach.server.serverpb.SpanStatsResponse();
                    if (object.range_count != null)
                        message.range_count = object.range_count | 0;
                    if (object.total_stats != null) {
                        if (typeof object.total_stats !== "object")
                            throw TypeError(".cockroach.server.serverpb.SpanStatsResponse.total_stats: object expected");
                        message.total_stats = $root.cockroach.storage.engine.enginepb.MVCCStats.fromObject(object.total_stats);
                    }
                    return message;
                };

                /**
                 * Creates a SpanStatsResponse message from a plain object. Also converts values to their respective internal types.
                 * This is an alias of {@link cockroach.server.serverpb.SpanStatsResponse.fromObject}.
                 * @function
                 * @param {Object.<string,*>} object Plain object
                 * @returns {cockroach.server.serverpb.SpanStatsResponse} SpanStatsResponse
                 */
                SpanStatsResponse.from = SpanStatsResponse.fromObject;

                /**
                 * Creates a plain object from a SpanStatsResponse message. Also converts values to other types if specified.
                 * @param {cockroach.server.serverpb.SpanStatsResponse} message SpanStatsResponse
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                SpanStatsResponse.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.total_stats = null;
                        object.range_count = 0;
                    }
                    if (message.total_stats != null && message.hasOwnProperty("total_stats"))
                        object.total_stats = $root.cockroach.storage.engine.enginepb.MVCCStats.toObject(message.total_stats, options);
                    if (message.range_count != null && message.hasOwnProperty("range_count"))
                        object.range_count = message.range_count;
                    return object;
                };

                /**
                 * Creates a plain object from this SpanStatsResponse message. Also converts values to other types if specified.
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                SpanStatsResponse.prototype.toObject = function toObject(options) {
                    return this.constructor.toObject(this, options);
                };

                /**
                 * Converts this SpanStatsResponse to JSON.
                 * @returns {Object.<string,*>} JSON object
                 */
                SpanStatsResponse.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return SpanStatsResponse;
            })();

            serverpb.Status = (function() {

                /**
                 * Constructs a new Status service.
                 * @exports cockroach.server.serverpb.Status
                 * @extends $protobuf.rpc.Service
                 * @constructor
                 * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
                 * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
                 * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
                 */
                function Status(rpcImpl, requestDelimited, responseDelimited) {
                    $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
                }

                (Status.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = Status;

                /**
                 * Creates new Status service using the specified rpc implementation.
                 * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
                 * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
                 * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
                 * @returns {Status} RPC service. Useful where requests and/or responses are streamed.
                 */
                Status.create = function create(rpcImpl, requestDelimited, responseDelimited) {
                    return new this(rpcImpl, requestDelimited, responseDelimited);
                };

                /**
                 * Callback as used by {@link Status#details}.
                 * @typedef Status_details_Callback
                 * @type {function}
                 * @param {?Error} error Error, if any
                 * @param {cockroach.server.serverpb.DetailsResponse} [response] DetailsResponse
                 */

                /**
                 * Calls Details.
                 * @param {cockroach.server.serverpb.DetailsRequest|Object.<string,*>} request DetailsRequest message or plain object
                 * @param {Status_details_Callback} callback Node-style callback called with the error, if any, and DetailsResponse
                 * @returns {undefined}
                 */
                Status.prototype.details = function details(request, callback) {
                    return this.rpcCall(details, $root.cockroach.server.serverpb.DetailsRequest, $root.cockroach.server.serverpb.DetailsResponse, request, callback);
                };

                /**
                 * Calls Details.
                 * @name Status#details
                 * @function
                 * @param {cockroach.server.serverpb.DetailsRequest|Object.<string,*>} request DetailsRequest message or plain object
                 * @returns {Promise<cockroach.server.serverpb.DetailsResponse>} Promise
                 * @variation 2
                 */

                /**
                 * Callback as used by {@link Status#nodes}.
                 * @typedef Status_nodes_Callback
                 * @type {function}
                 * @param {?Error} error Error, if any
                 * @param {cockroach.server.serverpb.NodesResponse} [response] NodesResponse
                 */

                /**
                 * Calls Nodes.
                 * @param {cockroach.server.serverpb.NodesRequest|Object.<string,*>} request NodesRequest message or plain object
                 * @param {Status_nodes_Callback} callback Node-style callback called with the error, if any, and NodesResponse
                 * @returns {undefined}
                 */
                Status.prototype.nodes = function nodes(request, callback) {
                    return this.rpcCall(nodes, $root.cockroach.server.serverpb.NodesRequest, $root.cockroach.server.serverpb.NodesResponse, request, callback);
                };

                /**
                 * Calls Nodes.
                 * @name Status#nodes
                 * @function
                 * @param {cockroach.server.serverpb.NodesRequest|Object.<string,*>} request NodesRequest message or plain object
                 * @returns {Promise<cockroach.server.serverpb.NodesResponse>} Promise
                 * @variation 2
                 */

                /**
                 * Callback as used by {@link Status#node}.
                 * @typedef Status_node_Callback
                 * @type {function}
                 * @param {?Error} error Error, if any
                 * @param {cockroach.server.status.NodeStatus} [response] NodeStatus
                 */

                /**
                 * Calls Node.
                 * @param {cockroach.server.serverpb.NodeRequest|Object.<string,*>} request NodeRequest message or plain object
                 * @param {Status_node_Callback} callback Node-style callback called with the error, if any, and NodeStatus
                 * @returns {undefined}
                 */
                Status.prototype.node = function node(request, callback) {
                    return this.rpcCall(node, $root.cockroach.server.serverpb.NodeRequest, $root.cockroach.server.status.NodeStatus, request, callback);
                };

                /**
                 * Calls Node.
                 * @name Status#node
                 * @function
                 * @param {cockroach.server.serverpb.NodeRequest|Object.<string,*>} request NodeRequest message or plain object
                 * @returns {Promise<cockroach.server.status.NodeStatus>} Promise
                 * @variation 2
                 */

                /**
                 * Callback as used by {@link Status#raftDebug}.
                 * @typedef Status_raftDebug_Callback
                 * @type {function}
                 * @param {?Error} error Error, if any
                 * @param {cockroach.server.serverpb.RaftDebugResponse} [response] RaftDebugResponse
                 */

                /**
                 * Calls RaftDebug.
                 * @param {cockroach.server.serverpb.RaftDebugRequest|Object.<string,*>} request RaftDebugRequest message or plain object
                 * @param {Status_raftDebug_Callback} callback Node-style callback called with the error, if any, and RaftDebugResponse
                 * @returns {undefined}
                 */
                Status.prototype.raftDebug = function raftDebug(request, callback) {
                    return this.rpcCall(raftDebug, $root.cockroach.server.serverpb.RaftDebugRequest, $root.cockroach.server.serverpb.RaftDebugResponse, request, callback);
                };

                /**
                 * Calls RaftDebug.
                 * @name Status#raftDebug
                 * @function
                 * @param {cockroach.server.serverpb.RaftDebugRequest|Object.<string,*>} request RaftDebugRequest message or plain object
                 * @returns {Promise<cockroach.server.serverpb.RaftDebugResponse>} Promise
                 * @variation 2
                 */

                /**
                 * Callback as used by {@link Status#ranges}.
                 * @typedef Status_ranges_Callback
                 * @type {function}
                 * @param {?Error} error Error, if any
                 * @param {cockroach.server.serverpb.RangesResponse} [response] RangesResponse
                 */

                /**
                 * Calls Ranges.
                 * @param {cockroach.server.serverpb.RangesRequest|Object.<string,*>} request RangesRequest message or plain object
                 * @param {Status_ranges_Callback} callback Node-style callback called with the error, if any, and RangesResponse
                 * @returns {undefined}
                 */
                Status.prototype.ranges = function ranges(request, callback) {
                    return this.rpcCall(ranges, $root.cockroach.server.serverpb.RangesRequest, $root.cockroach.server.serverpb.RangesResponse, request, callback);
                };

                /**
                 * Calls Ranges.
                 * @name Status#ranges
                 * @function
                 * @param {cockroach.server.serverpb.RangesRequest|Object.<string,*>} request RangesRequest message or plain object
                 * @returns {Promise<cockroach.server.serverpb.RangesResponse>} Promise
                 * @variation 2
                 */

                /**
                 * Callback as used by {@link Status#gossip}.
                 * @typedef Status_gossip_Callback
                 * @type {function}
                 * @param {?Error} error Error, if any
                 * @param {cockroach.gossip.InfoStatus} [response] InfoStatus
                 */

                /**
                 * Calls Gossip.
                 * @param {cockroach.server.serverpb.GossipRequest|Object.<string,*>} request GossipRequest message or plain object
                 * @param {Status_gossip_Callback} callback Node-style callback called with the error, if any, and InfoStatus
                 * @returns {undefined}
                 */
                Status.prototype.gossip = function gossip(request, callback) {
                    return this.rpcCall(gossip, $root.cockroach.server.serverpb.GossipRequest, $root.cockroach.gossip.InfoStatus, request, callback);
                };

                /**
                 * Calls Gossip.
                 * @name Status#gossip
                 * @function
                 * @param {cockroach.server.serverpb.GossipRequest|Object.<string,*>} request GossipRequest message or plain object
                 * @returns {Promise<cockroach.gossip.InfoStatus>} Promise
                 * @variation 2
                 */

                /**
                 * Callback as used by {@link Status#spanStats}.
                 * @typedef Status_spanStats_Callback
                 * @type {function}
                 * @param {?Error} error Error, if any
                 * @param {cockroach.server.serverpb.SpanStatsResponse} [response] SpanStatsResponse
                 */

                /**
                 * Calls SpanStats.
                 * @param {cockroach.server.serverpb.SpanStatsRequest|Object.<string,*>} request SpanStatsRequest message or plain object
                 * @param {Status_spanStats_Callback} callback Node-style callback called with the error, if any, and SpanStatsResponse
                 * @returns {undefined}
                 */
                Status.prototype.spanStats = function spanStats(request, callback) {
                    return this.rpcCall(spanStats, $root.cockroach.server.serverpb.SpanStatsRequest, $root.cockroach.server.serverpb.SpanStatsResponse, request, callback);
                };

                /**
                 * Calls SpanStats.
                 * @name Status#spanStats
                 * @function
                 * @param {cockroach.server.serverpb.SpanStatsRequest|Object.<string,*>} request SpanStatsRequest message or plain object
                 * @returns {Promise<cockroach.server.serverpb.SpanStatsResponse>} Promise
                 * @variation 2
                 */

                /**
                 * Callback as used by {@link Status#stacks}.
                 * @typedef Status_stacks_Callback
                 * @type {function}
                 * @param {?Error} error Error, if any
                 * @param {cockroach.server.serverpb.JSONResponse} [response] JSONResponse
                 */

                /**
                 * Calls Stacks.
                 * @param {cockroach.server.serverpb.StacksRequest|Object.<string,*>} request StacksRequest message or plain object
                 * @param {Status_stacks_Callback} callback Node-style callback called with the error, if any, and JSONResponse
                 * @returns {undefined}
                 */
                Status.prototype.stacks = function stacks(request, callback) {
                    return this.rpcCall(stacks, $root.cockroach.server.serverpb.StacksRequest, $root.cockroach.server.serverpb.JSONResponse, request, callback);
                };

                /**
                 * Calls Stacks.
                 * @name Status#stacks
                 * @function
                 * @param {cockroach.server.serverpb.StacksRequest|Object.<string,*>} request StacksRequest message or plain object
                 * @returns {Promise<cockroach.server.serverpb.JSONResponse>} Promise
                 * @variation 2
                 */

                /**
                 * Callback as used by {@link Status#metrics}.
                 * @typedef Status_metrics_Callback
                 * @type {function}
                 * @param {?Error} error Error, if any
                 * @param {cockroach.server.serverpb.JSONResponse} [response] JSONResponse
                 */

                /**
                 * Calls Metrics.
                 * @param {cockroach.server.serverpb.MetricsRequest|Object.<string,*>} request MetricsRequest message or plain object
                 * @param {Status_metrics_Callback} callback Node-style callback called with the error, if any, and JSONResponse
                 * @returns {undefined}
                 */
                Status.prototype.metrics = function metrics(request, callback) {
                    return this.rpcCall(metrics, $root.cockroach.server.serverpb.MetricsRequest, $root.cockroach.server.serverpb.JSONResponse, request, callback);
                };

                /**
                 * Calls Metrics.
                 * @name Status#metrics
                 * @function
                 * @param {cockroach.server.serverpb.MetricsRequest|Object.<string,*>} request MetricsRequest message or plain object
                 * @returns {Promise<cockroach.server.serverpb.JSONResponse>} Promise
                 * @variation 2
                 */

                /**
                 * Callback as used by {@link Status#logFilesList}.
                 * @typedef Status_logFilesList_Callback
                 * @type {function}
                 * @param {?Error} error Error, if any
                 * @param {cockroach.server.serverpb.LogFilesListResponse} [response] LogFilesListResponse
                 */

                /**
                 * Calls LogFilesList.
                 * @param {cockroach.server.serverpb.LogFilesListRequest|Object.<string,*>} request LogFilesListRequest message or plain object
                 * @param {Status_logFilesList_Callback} callback Node-style callback called with the error, if any, and LogFilesListResponse
                 * @returns {undefined}
                 */
                Status.prototype.logFilesList = function logFilesList(request, callback) {
                    return this.rpcCall(logFilesList, $root.cockroach.server.serverpb.LogFilesListRequest, $root.cockroach.server.serverpb.LogFilesListResponse, request, callback);
                };

                /**
                 * Calls LogFilesList.
                 * @name Status#logFilesList
                 * @function
                 * @param {cockroach.server.serverpb.LogFilesListRequest|Object.<string,*>} request LogFilesListRequest message or plain object
                 * @returns {Promise<cockroach.server.serverpb.LogFilesListResponse>} Promise
                 * @variation 2
                 */

                /**
                 * Callback as used by {@link Status#logFile}.
                 * @typedef Status_logFile_Callback
                 * @type {function}
                 * @param {?Error} error Error, if any
                 * @param {cockroach.server.serverpb.LogEntriesResponse} [response] LogEntriesResponse
                 */

                /**
                 * Calls LogFile.
                 * @param {cockroach.server.serverpb.LogFileRequest|Object.<string,*>} request LogFileRequest message or plain object
                 * @param {Status_logFile_Callback} callback Node-style callback called with the error, if any, and LogEntriesResponse
                 * @returns {undefined}
                 */
                Status.prototype.logFile = function logFile(request, callback) {
                    return this.rpcCall(logFile, $root.cockroach.server.serverpb.LogFileRequest, $root.cockroach.server.serverpb.LogEntriesResponse, request, callback);
                };

                /**
                 * Calls LogFile.
                 * @name Status#logFile
                 * @function
                 * @param {cockroach.server.serverpb.LogFileRequest|Object.<string,*>} request LogFileRequest message or plain object
                 * @returns {Promise<cockroach.server.serverpb.LogEntriesResponse>} Promise
                 * @variation 2
                 */

                /**
                 * Callback as used by {@link Status#logs}.
                 * @typedef Status_logs_Callback
                 * @type {function}
                 * @param {?Error} error Error, if any
                 * @param {cockroach.server.serverpb.LogEntriesResponse} [response] LogEntriesResponse
                 */

                /**
                 * Calls Logs.
                 * @param {cockroach.server.serverpb.LogsRequest|Object.<string,*>} request LogsRequest message or plain object
                 * @param {Status_logs_Callback} callback Node-style callback called with the error, if any, and LogEntriesResponse
                 * @returns {undefined}
                 */
                Status.prototype.logs = function logs(request, callback) {
                    return this.rpcCall(logs, $root.cockroach.server.serverpb.LogsRequest, $root.cockroach.server.serverpb.LogEntriesResponse, request, callback);
                };

                /**
                 * Calls Logs.
                 * @name Status#logs
                 * @function
                 * @param {cockroach.server.serverpb.LogsRequest|Object.<string,*>} request LogsRequest message or plain object
                 * @returns {Promise<cockroach.server.serverpb.LogEntriesResponse>} Promise
                 * @variation 2
                 */

                return Status;
            })();

            serverpb.PrettySpan = (function() {

                /**
                 * Properties of a PrettySpan.
                 * @typedef cockroach.server.serverpb.PrettySpan$Properties
                 * @type {Object}
                 * @property {string} [start_key] PrettySpan start_key.
                 * @property {string} [end_key] PrettySpan end_key.
                 */

                /**
                 * Constructs a new PrettySpan.
                 * @exports cockroach.server.serverpb.PrettySpan
                 * @constructor
                 * @param {cockroach.server.serverpb.PrettySpan$Properties=} [properties] Properties to set
                 */
                function PrettySpan(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * PrettySpan start_key.
                 * @type {string}
                 */
                PrettySpan.prototype.start_key = "";

                /**
                 * PrettySpan end_key.
                 * @type {string}
                 */
                PrettySpan.prototype.end_key = "";

                /**
                 * Creates a new PrettySpan instance using the specified properties.
                 * @param {cockroach.server.serverpb.PrettySpan$Properties=} [properties] Properties to set
                 * @returns {cockroach.server.serverpb.PrettySpan} PrettySpan instance
                 */
                PrettySpan.create = function create(properties) {
                    return new PrettySpan(properties);
                };

                /**
                 * Encodes the specified PrettySpan message. Does not implicitly {@link cockroach.server.serverpb.PrettySpan.verify|verify} messages.
                 * @param {cockroach.server.serverpb.PrettySpan$Properties} message PrettySpan message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                PrettySpan.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.start_key != null && message.hasOwnProperty("start_key"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.start_key);
                    if (message.end_key != null && message.hasOwnProperty("end_key"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.end_key);
                    return writer;
                };

                /**
                 * Encodes the specified PrettySpan message, length delimited. Does not implicitly {@link cockroach.server.serverpb.PrettySpan.verify|verify} messages.
                 * @param {cockroach.server.serverpb.PrettySpan$Properties} message PrettySpan message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                PrettySpan.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a PrettySpan message from the specified reader or buffer.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {cockroach.server.serverpb.PrettySpan} PrettySpan
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                PrettySpan.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.cockroach.server.serverpb.PrettySpan();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.start_key = reader.string();
                            break;
                        case 2:
                            message.end_key = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a PrettySpan message from the specified reader or buffer, length delimited.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {cockroach.server.serverpb.PrettySpan} PrettySpan
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                PrettySpan.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a PrettySpan message.
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {?string} `null` if valid, otherwise the reason why it is not
                 */
                PrettySpan.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.start_key != null && message.hasOwnProperty("start_key"))
                        if (!$util.isString(message.start_key))
                            return "start_key: string expected";
                    if (message.end_key != null && message.hasOwnProperty("end_key"))
                        if (!$util.isString(message.end_key))
                            return "end_key: string expected";
                    return null;
                };

                /**
                 * Creates a PrettySpan message from a plain object. Also converts values to their respective internal types.
                 * @param {Object.<string,*>} object Plain object
                 * @returns {cockroach.server.serverpb.PrettySpan} PrettySpan
                 */
                PrettySpan.fromObject = function fromObject(object) {
                    if (object instanceof $root.cockroach.server.serverpb.PrettySpan)
                        return object;
                    let message = new $root.cockroach.server.serverpb.PrettySpan();
                    if (object.start_key != null)
                        message.start_key = String(object.start_key);
                    if (object.end_key != null)
                        message.end_key = String(object.end_key);
                    return message;
                };

                /**
                 * Creates a PrettySpan message from a plain object. Also converts values to their respective internal types.
                 * This is an alias of {@link cockroach.server.serverpb.PrettySpan.fromObject}.
                 * @function
                 * @param {Object.<string,*>} object Plain object
                 * @returns {cockroach.server.serverpb.PrettySpan} PrettySpan
                 */
                PrettySpan.from = PrettySpan.fromObject;

                /**
                 * Creates a plain object from a PrettySpan message. Also converts values to other types if specified.
                 * @param {cockroach.server.serverpb.PrettySpan} message PrettySpan
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                PrettySpan.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.start_key = "";
                        object.end_key = "";
                    }
                    if (message.start_key != null && message.hasOwnProperty("start_key"))
                        object.start_key = message.start_key;
                    if (message.end_key != null && message.hasOwnProperty("end_key"))
                        object.end_key = message.end_key;
                    return object;
                };

                /**
                 * Creates a plain object from this PrettySpan message. Also converts values to other types if specified.
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                PrettySpan.prototype.toObject = function toObject(options) {
                    return this.constructor.toObject(this, options);
                };

                /**
                 * Converts this PrettySpan to JSON.
                 * @returns {Object.<string,*>} JSON object
                 */
                PrettySpan.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return PrettySpan;
            })();

            return serverpb;
        })();

        server.status = (function() {

            /**
             * Namespace status.
             * @exports cockroach.server.status
             * @namespace
             */
            const status = {};

            status.StoreStatus = (function() {

                /**
                 * Properties of a StoreStatus.
                 * @typedef cockroach.server.status.StoreStatus$Properties
                 * @type {Object}
                 * @property {cockroach.roachpb.StoreDescriptor$Properties} [desc] StoreStatus desc.
                 * @property {Object.<string,number>} [metrics] StoreStatus metrics.
                 */

                /**
                 * Constructs a new StoreStatus.
                 * @exports cockroach.server.status.StoreStatus
                 * @constructor
                 * @param {cockroach.server.status.StoreStatus$Properties=} [properties] Properties to set
                 */
                function StoreStatus(properties) {
                    this.metrics = {};
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * StoreStatus desc.
                 * @type {(cockroach.roachpb.StoreDescriptor$Properties|null)}
                 */
                StoreStatus.prototype.desc = null;

                /**
                 * StoreStatus metrics.
                 * @type {Object.<string,number>}
                 */
                StoreStatus.prototype.metrics = $util.emptyObject;

                /**
                 * Creates a new StoreStatus instance using the specified properties.
                 * @param {cockroach.server.status.StoreStatus$Properties=} [properties] Properties to set
                 * @returns {cockroach.server.status.StoreStatus} StoreStatus instance
                 */
                StoreStatus.create = function create(properties) {
                    return new StoreStatus(properties);
                };

                /**
                 * Encodes the specified StoreStatus message. Does not implicitly {@link cockroach.server.status.StoreStatus.verify|verify} messages.
                 * @param {cockroach.server.status.StoreStatus$Properties} message StoreStatus message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                StoreStatus.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.desc != null && message.hasOwnProperty("desc"))
                        $root.cockroach.roachpb.StoreDescriptor.encode(message.desc, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.metrics != null && message.hasOwnProperty("metrics"))
                        for (let keys = Object.keys(message.metrics), i = 0; i < keys.length; ++i)
                            writer.uint32(/* id 2, wireType 2 =*/18).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]).uint32(/* id 2, wireType 1 =*/17).double(message.metrics[keys[i]]).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified StoreStatus message, length delimited. Does not implicitly {@link cockroach.server.status.StoreStatus.verify|verify} messages.
                 * @param {cockroach.server.status.StoreStatus$Properties} message StoreStatus message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                StoreStatus.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a StoreStatus message from the specified reader or buffer.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {cockroach.server.status.StoreStatus} StoreStatus
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                StoreStatus.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.cockroach.server.status.StoreStatus(), key;
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.desc = $root.cockroach.roachpb.StoreDescriptor.decode(reader, reader.uint32());
                            break;
                        case 2:
                            reader.skip().pos++;
                            if (message.metrics === $util.emptyObject)
                                message.metrics = {};
                            key = reader.string();
                            reader.pos++;
                            message.metrics[key] = reader.double();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a StoreStatus message from the specified reader or buffer, length delimited.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {cockroach.server.status.StoreStatus} StoreStatus
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                StoreStatus.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a StoreStatus message.
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {?string} `null` if valid, otherwise the reason why it is not
                 */
                StoreStatus.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.desc != null && message.hasOwnProperty("desc")) {
                        let error = $root.cockroach.roachpb.StoreDescriptor.verify(message.desc);
                        if (error)
                            return "desc." + error;
                    }
                    if (message.metrics != null && message.hasOwnProperty("metrics")) {
                        if (!$util.isObject(message.metrics))
                            return "metrics: object expected";
                        let key = Object.keys(message.metrics);
                        for (let i = 0; i < key.length; ++i)
                            if (typeof message.metrics[key[i]] !== "number")
                                return "metrics: number{k:string} expected";
                    }
                    return null;
                };

                /**
                 * Creates a StoreStatus message from a plain object. Also converts values to their respective internal types.
                 * @param {Object.<string,*>} object Plain object
                 * @returns {cockroach.server.status.StoreStatus} StoreStatus
                 */
                StoreStatus.fromObject = function fromObject(object) {
                    if (object instanceof $root.cockroach.server.status.StoreStatus)
                        return object;
                    let message = new $root.cockroach.server.status.StoreStatus();
                    if (object.desc != null) {
                        if (typeof object.desc !== "object")
                            throw TypeError(".cockroach.server.status.StoreStatus.desc: object expected");
                        message.desc = $root.cockroach.roachpb.StoreDescriptor.fromObject(object.desc);
                    }
                    if (object.metrics) {
                        if (typeof object.metrics !== "object")
                            throw TypeError(".cockroach.server.status.StoreStatus.metrics: object expected");
                        message.metrics = {};
                        for (let keys = Object.keys(object.metrics), i = 0; i < keys.length; ++i)
                            message.metrics[keys[i]] = Number(object.metrics[keys[i]]);
                    }
                    return message;
                };

                /**
                 * Creates a StoreStatus message from a plain object. Also converts values to their respective internal types.
                 * This is an alias of {@link cockroach.server.status.StoreStatus.fromObject}.
                 * @function
                 * @param {Object.<string,*>} object Plain object
                 * @returns {cockroach.server.status.StoreStatus} StoreStatus
                 */
                StoreStatus.from = StoreStatus.fromObject;

                /**
                 * Creates a plain object from a StoreStatus message. Also converts values to other types if specified.
                 * @param {cockroach.server.status.StoreStatus} message StoreStatus
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                StoreStatus.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.objects || options.defaults)
                        object.metrics = {};
                    if (options.defaults)
                        object.desc = null;
                    if (message.desc != null && message.hasOwnProperty("desc"))
                        object.desc = $root.cockroach.roachpb.StoreDescriptor.toObject(message.desc, options);
                    let keys2;
                    if (message.metrics && (keys2 = Object.keys(message.metrics)).length) {
                        object.metrics = {};
                        for (let j = 0; j < keys2.length; ++j)
                            object.metrics[keys2[j]] = message.metrics[keys2[j]];
                    }
                    return object;
                };

                /**
                 * Creates a plain object from this StoreStatus message. Also converts values to other types if specified.
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                StoreStatus.prototype.toObject = function toObject(options) {
                    return this.constructor.toObject(this, options);
                };

                /**
                 * Converts this StoreStatus to JSON.
                 * @returns {Object.<string,*>} JSON object
                 */
                StoreStatus.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return StoreStatus;
            })();

            status.NodeStatus = (function() {

                /**
                 * Properties of a NodeStatus.
                 * @typedef cockroach.server.status.NodeStatus$Properties
                 * @type {Object}
                 * @property {cockroach.roachpb.NodeDescriptor$Properties} [desc] NodeStatus desc.
                 * @property {cockroach.build.Info$Properties} [build_info] NodeStatus build_info.
                 * @property {Long} [started_at] NodeStatus started_at.
                 * @property {Long} [updated_at] NodeStatus updated_at.
                 * @property {Object.<string,number>} [metrics] NodeStatus metrics.
                 * @property {Array.<cockroach.server.status.StoreStatus$Properties>} [store_statuses] NodeStatus store_statuses.
                 * @property {Array.<string>} [args] NodeStatus args.
                 * @property {Array.<string>} [env] NodeStatus env.
                 */

                /**
                 * Constructs a new NodeStatus.
                 * @exports cockroach.server.status.NodeStatus
                 * @constructor
                 * @param {cockroach.server.status.NodeStatus$Properties=} [properties] Properties to set
                 */
                function NodeStatus(properties) {
                    this.metrics = {};
                    this.store_statuses = [];
                    this.args = [];
                    this.env = [];
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * NodeStatus desc.
                 * @type {(cockroach.roachpb.NodeDescriptor$Properties|null)}
                 */
                NodeStatus.prototype.desc = null;

                /**
                 * NodeStatus build_info.
                 * @type {(cockroach.build.Info$Properties|null)}
                 */
                NodeStatus.prototype.build_info = null;

                /**
                 * NodeStatus started_at.
                 * @type {Long}
                 */
                NodeStatus.prototype.started_at = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

                /**
                 * NodeStatus updated_at.
                 * @type {Long}
                 */
                NodeStatus.prototype.updated_at = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

                /**
                 * NodeStatus metrics.
                 * @type {Object.<string,number>}
                 */
                NodeStatus.prototype.metrics = $util.emptyObject;

                /**
                 * NodeStatus store_statuses.
                 * @type {Array.<cockroach.server.status.StoreStatus$Properties>}
                 */
                NodeStatus.prototype.store_statuses = $util.emptyArray;

                /**
                 * NodeStatus args.
                 * @type {Array.<string>}
                 */
                NodeStatus.prototype.args = $util.emptyArray;

                /**
                 * NodeStatus env.
                 * @type {Array.<string>}
                 */
                NodeStatus.prototype.env = $util.emptyArray;

                /**
                 * Creates a new NodeStatus instance using the specified properties.
                 * @param {cockroach.server.status.NodeStatus$Properties=} [properties] Properties to set
                 * @returns {cockroach.server.status.NodeStatus} NodeStatus instance
                 */
                NodeStatus.create = function create(properties) {
                    return new NodeStatus(properties);
                };

                /**
                 * Encodes the specified NodeStatus message. Does not implicitly {@link cockroach.server.status.NodeStatus.verify|verify} messages.
                 * @param {cockroach.server.status.NodeStatus$Properties} message NodeStatus message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                NodeStatus.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.desc != null && message.hasOwnProperty("desc"))
                        $root.cockroach.roachpb.NodeDescriptor.encode(message.desc, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.build_info != null && message.hasOwnProperty("build_info"))
                        $root.cockroach.build.Info.encode(message.build_info, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.started_at != null && message.hasOwnProperty("started_at"))
                        writer.uint32(/* id 3, wireType 0 =*/24).int64(message.started_at);
                    if (message.updated_at != null && message.hasOwnProperty("updated_at"))
                        writer.uint32(/* id 4, wireType 0 =*/32).int64(message.updated_at);
                    if (message.metrics != null && message.hasOwnProperty("metrics"))
                        for (let keys = Object.keys(message.metrics), i = 0; i < keys.length; ++i)
                            writer.uint32(/* id 5, wireType 2 =*/42).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]).uint32(/* id 2, wireType 1 =*/17).double(message.metrics[keys[i]]).ldelim();
                    if (message.store_statuses != null && message.store_statuses.length)
                        for (let i = 0; i < message.store_statuses.length; ++i)
                            $root.cockroach.server.status.StoreStatus.encode(message.store_statuses[i], writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                    if (message.args != null && message.args.length)
                        for (let i = 0; i < message.args.length; ++i)
                            writer.uint32(/* id 7, wireType 2 =*/58).string(message.args[i]);
                    if (message.env != null && message.env.length)
                        for (let i = 0; i < message.env.length; ++i)
                            writer.uint32(/* id 8, wireType 2 =*/66).string(message.env[i]);
                    return writer;
                };

                /**
                 * Encodes the specified NodeStatus message, length delimited. Does not implicitly {@link cockroach.server.status.NodeStatus.verify|verify} messages.
                 * @param {cockroach.server.status.NodeStatus$Properties} message NodeStatus message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                NodeStatus.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a NodeStatus message from the specified reader or buffer.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {cockroach.server.status.NodeStatus} NodeStatus
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                NodeStatus.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.cockroach.server.status.NodeStatus(), key;
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.desc = $root.cockroach.roachpb.NodeDescriptor.decode(reader, reader.uint32());
                            break;
                        case 2:
                            message.build_info = $root.cockroach.build.Info.decode(reader, reader.uint32());
                            break;
                        case 3:
                            message.started_at = reader.int64();
                            break;
                        case 4:
                            message.updated_at = reader.int64();
                            break;
                        case 5:
                            reader.skip().pos++;
                            if (message.metrics === $util.emptyObject)
                                message.metrics = {};
                            key = reader.string();
                            reader.pos++;
                            message.metrics[key] = reader.double();
                            break;
                        case 6:
                            if (!(message.store_statuses && message.store_statuses.length))
                                message.store_statuses = [];
                            message.store_statuses.push($root.cockroach.server.status.StoreStatus.decode(reader, reader.uint32()));
                            break;
                        case 7:
                            if (!(message.args && message.args.length))
                                message.args = [];
                            message.args.push(reader.string());
                            break;
                        case 8:
                            if (!(message.env && message.env.length))
                                message.env = [];
                            message.env.push(reader.string());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a NodeStatus message from the specified reader or buffer, length delimited.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {cockroach.server.status.NodeStatus} NodeStatus
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                NodeStatus.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a NodeStatus message.
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {?string} `null` if valid, otherwise the reason why it is not
                 */
                NodeStatus.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.desc != null && message.hasOwnProperty("desc")) {
                        let error = $root.cockroach.roachpb.NodeDescriptor.verify(message.desc);
                        if (error)
                            return "desc." + error;
                    }
                    if (message.build_info != null && message.hasOwnProperty("build_info")) {
                        let error = $root.cockroach.build.Info.verify(message.build_info);
                        if (error)
                            return "build_info." + error;
                    }
                    if (message.started_at != null && message.hasOwnProperty("started_at"))
                        if (!$util.isInteger(message.started_at) && !(message.started_at && $util.isInteger(message.started_at.low) && $util.isInteger(message.started_at.high)))
                            return "started_at: integer|Long expected";
                    if (message.updated_at != null && message.hasOwnProperty("updated_at"))
                        if (!$util.isInteger(message.updated_at) && !(message.updated_at && $util.isInteger(message.updated_at.low) && $util.isInteger(message.updated_at.high)))
                            return "updated_at: integer|Long expected";
                    if (message.metrics != null && message.hasOwnProperty("metrics")) {
                        if (!$util.isObject(message.metrics))
                            return "metrics: object expected";
                        let key = Object.keys(message.metrics);
                        for (let i = 0; i < key.length; ++i)
                            if (typeof message.metrics[key[i]] !== "number")
                                return "metrics: number{k:string} expected";
                    }
                    if (message.store_statuses != null && message.hasOwnProperty("store_statuses")) {
                        if (!Array.isArray(message.store_statuses))
                            return "store_statuses: array expected";
                        for (let i = 0; i < message.store_statuses.length; ++i) {
                            let error = $root.cockroach.server.status.StoreStatus.verify(message.store_statuses[i]);
                            if (error)
                                return "store_statuses." + error;
                        }
                    }
                    if (message.args != null && message.hasOwnProperty("args")) {
                        if (!Array.isArray(message.args))
                            return "args: array expected";
                        for (let i = 0; i < message.args.length; ++i)
                            if (!$util.isString(message.args[i]))
                                return "args: string[] expected";
                    }
                    if (message.env != null && message.hasOwnProperty("env")) {
                        if (!Array.isArray(message.env))
                            return "env: array expected";
                        for (let i = 0; i < message.env.length; ++i)
                            if (!$util.isString(message.env[i]))
                                return "env: string[] expected";
                    }
                    return null;
                };

                /**
                 * Creates a NodeStatus message from a plain object. Also converts values to their respective internal types.
                 * @param {Object.<string,*>} object Plain object
                 * @returns {cockroach.server.status.NodeStatus} NodeStatus
                 */
                NodeStatus.fromObject = function fromObject(object) {
                    if (object instanceof $root.cockroach.server.status.NodeStatus)
                        return object;
                    let message = new $root.cockroach.server.status.NodeStatus();
                    if (object.desc != null) {
                        if (typeof object.desc !== "object")
                            throw TypeError(".cockroach.server.status.NodeStatus.desc: object expected");
                        message.desc = $root.cockroach.roachpb.NodeDescriptor.fromObject(object.desc);
                    }
                    if (object.build_info != null) {
                        if (typeof object.build_info !== "object")
                            throw TypeError(".cockroach.server.status.NodeStatus.build_info: object expected");
                        message.build_info = $root.cockroach.build.Info.fromObject(object.build_info);
                    }
                    if (object.started_at != null)
                        if ($util.Long)
                            (message.started_at = $util.Long.fromValue(object.started_at)).unsigned = false;
                        else if (typeof object.started_at === "string")
                            message.started_at = parseInt(object.started_at, 10);
                        else if (typeof object.started_at === "number")
                            message.started_at = object.started_at;
                        else if (typeof object.started_at === "object")
                            message.started_at = new $util.LongBits(object.started_at.low >>> 0, object.started_at.high >>> 0).toNumber();
                    if (object.updated_at != null)
                        if ($util.Long)
                            (message.updated_at = $util.Long.fromValue(object.updated_at)).unsigned = false;
                        else if (typeof object.updated_at === "string")
                            message.updated_at = parseInt(object.updated_at, 10);
                        else if (typeof object.updated_at === "number")
                            message.updated_at = object.updated_at;
                        else if (typeof object.updated_at === "object")
                            message.updated_at = new $util.LongBits(object.updated_at.low >>> 0, object.updated_at.high >>> 0).toNumber();
                    if (object.metrics) {
                        if (typeof object.metrics !== "object")
                            throw TypeError(".cockroach.server.status.NodeStatus.metrics: object expected");
                        message.metrics = {};
                        for (let keys = Object.keys(object.metrics), i = 0; i < keys.length; ++i)
                            message.metrics[keys[i]] = Number(object.metrics[keys[i]]);
                    }
                    if (object.store_statuses) {
                        if (!Array.isArray(object.store_statuses))
                            throw TypeError(".cockroach.server.status.NodeStatus.store_statuses: array expected");
                        message.store_statuses = [];
                        for (let i = 0; i < object.store_statuses.length; ++i) {
                            if (typeof object.store_statuses[i] !== "object")
                                throw TypeError(".cockroach.server.status.NodeStatus.store_statuses: object expected");
                            message.store_statuses[i] = $root.cockroach.server.status.StoreStatus.fromObject(object.store_statuses[i]);
                        }
                    }
                    if (object.args) {
                        if (!Array.isArray(object.args))
                            throw TypeError(".cockroach.server.status.NodeStatus.args: array expected");
                        message.args = [];
                        for (let i = 0; i < object.args.length; ++i)
                            message.args[i] = String(object.args[i]);
                    }
                    if (object.env) {
                        if (!Array.isArray(object.env))
                            throw TypeError(".cockroach.server.status.NodeStatus.env: array expected");
                        message.env = [];
                        for (let i = 0; i < object.env.length; ++i)
                            message.env[i] = String(object.env[i]);
                    }
                    return message;
                };

                /**
                 * Creates a NodeStatus message from a plain object. Also converts values to their respective internal types.
                 * This is an alias of {@link cockroach.server.status.NodeStatus.fromObject}.
                 * @function
                 * @param {Object.<string,*>} object Plain object
                 * @returns {cockroach.server.status.NodeStatus} NodeStatus
                 */
                NodeStatus.from = NodeStatus.fromObject;

                /**
                 * Creates a plain object from a NodeStatus message. Also converts values to other types if specified.
                 * @param {cockroach.server.status.NodeStatus} message NodeStatus
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                NodeStatus.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.arrays || options.defaults) {
                        object.store_statuses = [];
                        object.args = [];
                        object.env = [];
                    }
                    if (options.objects || options.defaults)
                        object.metrics = {};
                    if (options.defaults) {
                        object.desc = null;
                        object.build_info = null;
                        if ($util.Long) {
                            let long = new $util.Long(0, 0, false);
                            object.started_at = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.started_at = options.longs === String ? "0" : 0;
                        if ($util.Long) {
                            let long = new $util.Long(0, 0, false);
                            object.updated_at = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.updated_at = options.longs === String ? "0" : 0;
                    }
                    if (message.desc != null && message.hasOwnProperty("desc"))
                        object.desc = $root.cockroach.roachpb.NodeDescriptor.toObject(message.desc, options);
                    if (message.build_info != null && message.hasOwnProperty("build_info"))
                        object.build_info = $root.cockroach.build.Info.toObject(message.build_info, options);
                    if (message.started_at != null && message.hasOwnProperty("started_at"))
                        if (typeof message.started_at === "number")
                            object.started_at = options.longs === String ? String(message.started_at) : message.started_at;
                        else
                            object.started_at = options.longs === String ? $util.Long.prototype.toString.call(message.started_at) : options.longs === Number ? new $util.LongBits(message.started_at.low >>> 0, message.started_at.high >>> 0).toNumber() : message.started_at;
                    if (message.updated_at != null && message.hasOwnProperty("updated_at"))
                        if (typeof message.updated_at === "number")
                            object.updated_at = options.longs === String ? String(message.updated_at) : message.updated_at;
                        else
                            object.updated_at = options.longs === String ? $util.Long.prototype.toString.call(message.updated_at) : options.longs === Number ? new $util.LongBits(message.updated_at.low >>> 0, message.updated_at.high >>> 0).toNumber() : message.updated_at;
                    let keys2;
                    if (message.metrics && (keys2 = Object.keys(message.metrics)).length) {
                        object.metrics = {};
                        for (let j = 0; j < keys2.length; ++j)
                            object.metrics[keys2[j]] = message.metrics[keys2[j]];
                    }
                    if (message.store_statuses && message.store_statuses.length) {
                        object.store_statuses = [];
                        for (let j = 0; j < message.store_statuses.length; ++j)
                            object.store_statuses[j] = $root.cockroach.server.status.StoreStatus.toObject(message.store_statuses[j], options);
                    }
                    if (message.args && message.args.length) {
                        object.args = [];
                        for (let j = 0; j < message.args.length; ++j)
                            object.args[j] = message.args[j];
                    }
                    if (message.env && message.env.length) {
                        object.env = [];
                        for (let j = 0; j < message.env.length; ++j)
                            object.env[j] = message.env[j];
                    }
                    return object;
                };

                /**
                 * Creates a plain object from this NodeStatus message. Also converts values to other types if specified.
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                NodeStatus.prototype.toObject = function toObject(options) {
                    return this.constructor.toObject(this, options);
                };

                /**
                 * Converts this NodeStatus to JSON.
                 * @returns {Object.<string,*>} JSON object
                 */
                NodeStatus.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return NodeStatus;
            })();

            return status;
        })();

        return server;
    })();

    cockroach.config = (function() {

        /**
         * Namespace config.
         * @exports cockroach.config
         * @namespace
         */
        const config = {};

        config.GCPolicy = (function() {

            /**
             * Properties of a GCPolicy.
             * @typedef cockroach.config.GCPolicy$Properties
             * @type {Object}
             * @property {number} [ttl_seconds] GCPolicy ttl_seconds.
             */

            /**
             * Constructs a new GCPolicy.
             * @exports cockroach.config.GCPolicy
             * @constructor
             * @param {cockroach.config.GCPolicy$Properties=} [properties] Properties to set
             */
            function GCPolicy(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GCPolicy ttl_seconds.
             * @type {number}
             */
            GCPolicy.prototype.ttl_seconds = 0;

            /**
             * Creates a new GCPolicy instance using the specified properties.
             * @param {cockroach.config.GCPolicy$Properties=} [properties] Properties to set
             * @returns {cockroach.config.GCPolicy} GCPolicy instance
             */
            GCPolicy.create = function create(properties) {
                return new GCPolicy(properties);
            };

            /**
             * Encodes the specified GCPolicy message. Does not implicitly {@link cockroach.config.GCPolicy.verify|verify} messages.
             * @param {cockroach.config.GCPolicy$Properties} message GCPolicy message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GCPolicy.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.ttl_seconds != null && message.hasOwnProperty("ttl_seconds"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.ttl_seconds);
                return writer;
            };

            /**
             * Encodes the specified GCPolicy message, length delimited. Does not implicitly {@link cockroach.config.GCPolicy.verify|verify} messages.
             * @param {cockroach.config.GCPolicy$Properties} message GCPolicy message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GCPolicy.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GCPolicy message from the specified reader or buffer.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {cockroach.config.GCPolicy} GCPolicy
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GCPolicy.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.cockroach.config.GCPolicy();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.ttl_seconds = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GCPolicy message from the specified reader or buffer, length delimited.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {cockroach.config.GCPolicy} GCPolicy
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GCPolicy.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GCPolicy message.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            GCPolicy.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.ttl_seconds != null && message.hasOwnProperty("ttl_seconds"))
                    if (!$util.isInteger(message.ttl_seconds))
                        return "ttl_seconds: integer expected";
                return null;
            };

            /**
             * Creates a GCPolicy message from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {cockroach.config.GCPolicy} GCPolicy
             */
            GCPolicy.fromObject = function fromObject(object) {
                if (object instanceof $root.cockroach.config.GCPolicy)
                    return object;
                let message = new $root.cockroach.config.GCPolicy();
                if (object.ttl_seconds != null)
                    message.ttl_seconds = object.ttl_seconds | 0;
                return message;
            };

            /**
             * Creates a GCPolicy message from a plain object. Also converts values to their respective internal types.
             * This is an alias of {@link cockroach.config.GCPolicy.fromObject}.
             * @function
             * @param {Object.<string,*>} object Plain object
             * @returns {cockroach.config.GCPolicy} GCPolicy
             */
            GCPolicy.from = GCPolicy.fromObject;

            /**
             * Creates a plain object from a GCPolicy message. Also converts values to other types if specified.
             * @param {cockroach.config.GCPolicy} message GCPolicy
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GCPolicy.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    object.ttl_seconds = 0;
                if (message.ttl_seconds != null && message.hasOwnProperty("ttl_seconds"))
                    object.ttl_seconds = message.ttl_seconds;
                return object;
            };

            /**
             * Creates a plain object from this GCPolicy message. Also converts values to other types if specified.
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GCPolicy.prototype.toObject = function toObject(options) {
                return this.constructor.toObject(this, options);
            };

            /**
             * Converts this GCPolicy to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            GCPolicy.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return GCPolicy;
        })();

        config.Constraint = (function() {

            /**
             * Properties of a Constraint.
             * @typedef cockroach.config.Constraint$Properties
             * @type {Object}
             * @property {cockroach.config.Constraint.Type} [type] Constraint type.
             * @property {string} [key] Constraint key.
             * @property {string} [value] Constraint value.
             */

            /**
             * Constructs a new Constraint.
             * @exports cockroach.config.Constraint
             * @constructor
             * @param {cockroach.config.Constraint$Properties=} [properties] Properties to set
             */
            function Constraint(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Constraint type.
             * @type {cockroach.config.Constraint.Type}
             */
            Constraint.prototype.type = 0;

            /**
             * Constraint key.
             * @type {string}
             */
            Constraint.prototype.key = "";

            /**
             * Constraint value.
             * @type {string}
             */
            Constraint.prototype.value = "";

            /**
             * Creates a new Constraint instance using the specified properties.
             * @param {cockroach.config.Constraint$Properties=} [properties] Properties to set
             * @returns {cockroach.config.Constraint} Constraint instance
             */
            Constraint.create = function create(properties) {
                return new Constraint(properties);
            };

            /**
             * Encodes the specified Constraint message. Does not implicitly {@link cockroach.config.Constraint.verify|verify} messages.
             * @param {cockroach.config.Constraint$Properties} message Constraint message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Constraint.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.type != null && message.hasOwnProperty("type"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.type);
                if (message.key != null && message.hasOwnProperty("key"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.key);
                if (message.value != null && message.hasOwnProperty("value"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.value);
                return writer;
            };

            /**
             * Encodes the specified Constraint message, length delimited. Does not implicitly {@link cockroach.config.Constraint.verify|verify} messages.
             * @param {cockroach.config.Constraint$Properties} message Constraint message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Constraint.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Constraint message from the specified reader or buffer.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {cockroach.config.Constraint} Constraint
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Constraint.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.cockroach.config.Constraint();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.type = reader.uint32();
                        break;
                    case 2:
                        message.key = reader.string();
                        break;
                    case 3:
                        message.value = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Constraint message from the specified reader or buffer, length delimited.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {cockroach.config.Constraint} Constraint
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Constraint.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Constraint message.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            Constraint.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.type != null && message.hasOwnProperty("type"))
                    switch (message.type) {
                    default:
                        return "type: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                        break;
                    }
                if (message.key != null && message.hasOwnProperty("key"))
                    if (!$util.isString(message.key))
                        return "key: string expected";
                if (message.value != null && message.hasOwnProperty("value"))
                    if (!$util.isString(message.value))
                        return "value: string expected";
                return null;
            };

            /**
             * Creates a Constraint message from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {cockroach.config.Constraint} Constraint
             */
            Constraint.fromObject = function fromObject(object) {
                if (object instanceof $root.cockroach.config.Constraint)
                    return object;
                let message = new $root.cockroach.config.Constraint();
                switch (object.type) {
                case "POSITIVE":
                case 0:
                    message.type = 0;
                    break;
                case "REQUIRED":
                case 1:
                    message.type = 1;
                    break;
                case "PROHIBITED":
                case 2:
                    message.type = 2;
                    break;
                }
                if (object.key != null)
                    message.key = String(object.key);
                if (object.value != null)
                    message.value = String(object.value);
                return message;
            };

            /**
             * Creates a Constraint message from a plain object. Also converts values to their respective internal types.
             * This is an alias of {@link cockroach.config.Constraint.fromObject}.
             * @function
             * @param {Object.<string,*>} object Plain object
             * @returns {cockroach.config.Constraint} Constraint
             */
            Constraint.from = Constraint.fromObject;

            /**
             * Creates a plain object from a Constraint message. Also converts values to other types if specified.
             * @param {cockroach.config.Constraint} message Constraint
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Constraint.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.type = options.enums === String ? "POSITIVE" : 0;
                    object.key = "";
                    object.value = "";
                }
                if (message.type != null && message.hasOwnProperty("type"))
                    object.type = options.enums === String ? $root.cockroach.config.Constraint.Type[message.type] : message.type;
                if (message.key != null && message.hasOwnProperty("key"))
                    object.key = message.key;
                if (message.value != null && message.hasOwnProperty("value"))
                    object.value = message.value;
                return object;
            };

            /**
             * Creates a plain object from this Constraint message. Also converts values to other types if specified.
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Constraint.prototype.toObject = function toObject(options) {
                return this.constructor.toObject(this, options);
            };

            /**
             * Converts this Constraint to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            Constraint.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Type enum.
             * @name Type
             * @memberof cockroach.config.Constraint
             * @enum {number}
             * @property {number} POSITIVE=0 POSITIVE value
             * @property {number} REQUIRED=1 REQUIRED value
             * @property {number} PROHIBITED=2 PROHIBITED value
             */
            Constraint.Type = (function() {
                const valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "POSITIVE"] = 0;
                values[valuesById[1] = "REQUIRED"] = 1;
                values[valuesById[2] = "PROHIBITED"] = 2;
                return values;
            })();

            return Constraint;
        })();

        config.Constraints = (function() {

            /**
             * Properties of a Constraints.
             * @typedef cockroach.config.Constraints$Properties
             * @type {Object}
             * @property {Array.<cockroach.config.Constraint$Properties>} [constraints] Constraints constraints.
             */

            /**
             * Constructs a new Constraints.
             * @exports cockroach.config.Constraints
             * @constructor
             * @param {cockroach.config.Constraints$Properties=} [properties] Properties to set
             */
            function Constraints(properties) {
                this.constraints = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Constraints constraints.
             * @type {Array.<cockroach.config.Constraint$Properties>}
             */
            Constraints.prototype.constraints = $util.emptyArray;

            /**
             * Creates a new Constraints instance using the specified properties.
             * @param {cockroach.config.Constraints$Properties=} [properties] Properties to set
             * @returns {cockroach.config.Constraints} Constraints instance
             */
            Constraints.create = function create(properties) {
                return new Constraints(properties);
            };

            /**
             * Encodes the specified Constraints message. Does not implicitly {@link cockroach.config.Constraints.verify|verify} messages.
             * @param {cockroach.config.Constraints$Properties} message Constraints message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Constraints.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.constraints != null && message.constraints.length)
                    for (let i = 0; i < message.constraints.length; ++i)
                        $root.cockroach.config.Constraint.encode(message.constraints[i], writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified Constraints message, length delimited. Does not implicitly {@link cockroach.config.Constraints.verify|verify} messages.
             * @param {cockroach.config.Constraints$Properties} message Constraints message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Constraints.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Constraints message from the specified reader or buffer.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {cockroach.config.Constraints} Constraints
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Constraints.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.cockroach.config.Constraints();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 6:
                        if (!(message.constraints && message.constraints.length))
                            message.constraints = [];
                        message.constraints.push($root.cockroach.config.Constraint.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Constraints message from the specified reader or buffer, length delimited.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {cockroach.config.Constraints} Constraints
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Constraints.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Constraints message.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            Constraints.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.constraints != null && message.hasOwnProperty("constraints")) {
                    if (!Array.isArray(message.constraints))
                        return "constraints: array expected";
                    for (let i = 0; i < message.constraints.length; ++i) {
                        let error = $root.cockroach.config.Constraint.verify(message.constraints[i]);
                        if (error)
                            return "constraints." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a Constraints message from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {cockroach.config.Constraints} Constraints
             */
            Constraints.fromObject = function fromObject(object) {
                if (object instanceof $root.cockroach.config.Constraints)
                    return object;
                let message = new $root.cockroach.config.Constraints();
                if (object.constraints) {
                    if (!Array.isArray(object.constraints))
                        throw TypeError(".cockroach.config.Constraints.constraints: array expected");
                    message.constraints = [];
                    for (let i = 0; i < object.constraints.length; ++i) {
                        if (typeof object.constraints[i] !== "object")
                            throw TypeError(".cockroach.config.Constraints.constraints: object expected");
                        message.constraints[i] = $root.cockroach.config.Constraint.fromObject(object.constraints[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a Constraints message from a plain object. Also converts values to their respective internal types.
             * This is an alias of {@link cockroach.config.Constraints.fromObject}.
             * @function
             * @param {Object.<string,*>} object Plain object
             * @returns {cockroach.config.Constraints} Constraints
             */
            Constraints.from = Constraints.fromObject;

            /**
             * Creates a plain object from a Constraints message. Also converts values to other types if specified.
             * @param {cockroach.config.Constraints} message Constraints
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Constraints.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.constraints = [];
                if (message.constraints && message.constraints.length) {
                    object.constraints = [];
                    for (let j = 0; j < message.constraints.length; ++j)
                        object.constraints[j] = $root.cockroach.config.Constraint.toObject(message.constraints[j], options);
                }
                return object;
            };

            /**
             * Creates a plain object from this Constraints message. Also converts values to other types if specified.
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Constraints.prototype.toObject = function toObject(options) {
                return this.constructor.toObject(this, options);
            };

            /**
             * Converts this Constraints to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            Constraints.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return Constraints;
        })();

        config.ZoneConfig = (function() {

            /**
             * Properties of a ZoneConfig.
             * @typedef cockroach.config.ZoneConfig$Properties
             * @type {Object}
             * @property {Array.<cockroach.roachpb.Attributes$Properties>} [replica_attrs] ZoneConfig replica_attrs.
             * @property {Long} [range_min_bytes] ZoneConfig range_min_bytes.
             * @property {Long} [range_max_bytes] ZoneConfig range_max_bytes.
             * @property {cockroach.config.GCPolicy$Properties} [gc] ZoneConfig gc.
             * @property {number} [num_replicas] ZoneConfig num_replicas.
             * @property {cockroach.config.Constraints$Properties} [constraints] ZoneConfig constraints.
             */

            /**
             * Constructs a new ZoneConfig.
             * @exports cockroach.config.ZoneConfig
             * @constructor
             * @param {cockroach.config.ZoneConfig$Properties=} [properties] Properties to set
             */
            function ZoneConfig(properties) {
                this.replica_attrs = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ZoneConfig replica_attrs.
             * @type {Array.<cockroach.roachpb.Attributes$Properties>}
             */
            ZoneConfig.prototype.replica_attrs = $util.emptyArray;

            /**
             * ZoneConfig range_min_bytes.
             * @type {Long}
             */
            ZoneConfig.prototype.range_min_bytes = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * ZoneConfig range_max_bytes.
             * @type {Long}
             */
            ZoneConfig.prototype.range_max_bytes = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * ZoneConfig gc.
             * @type {(cockroach.config.GCPolicy$Properties|null)}
             */
            ZoneConfig.prototype.gc = null;

            /**
             * ZoneConfig num_replicas.
             * @type {number}
             */
            ZoneConfig.prototype.num_replicas = 0;

            /**
             * ZoneConfig constraints.
             * @type {(cockroach.config.Constraints$Properties|null)}
             */
            ZoneConfig.prototype.constraints = null;

            /**
             * Creates a new ZoneConfig instance using the specified properties.
             * @param {cockroach.config.ZoneConfig$Properties=} [properties] Properties to set
             * @returns {cockroach.config.ZoneConfig} ZoneConfig instance
             */
            ZoneConfig.create = function create(properties) {
                return new ZoneConfig(properties);
            };

            /**
             * Encodes the specified ZoneConfig message. Does not implicitly {@link cockroach.config.ZoneConfig.verify|verify} messages.
             * @param {cockroach.config.ZoneConfig$Properties} message ZoneConfig message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ZoneConfig.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.replica_attrs != null && message.replica_attrs.length)
                    for (let i = 0; i < message.replica_attrs.length; ++i)
                        $root.cockroach.roachpb.Attributes.encode(message.replica_attrs[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.range_min_bytes != null && message.hasOwnProperty("range_min_bytes"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int64(message.range_min_bytes);
                if (message.range_max_bytes != null && message.hasOwnProperty("range_max_bytes"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int64(message.range_max_bytes);
                if (message.gc != null && message.hasOwnProperty("gc"))
                    $root.cockroach.config.GCPolicy.encode(message.gc, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.num_replicas != null && message.hasOwnProperty("num_replicas"))
                    writer.uint32(/* id 5, wireType 0 =*/40).int32(message.num_replicas);
                if (message.constraints != null && message.hasOwnProperty("constraints"))
                    $root.cockroach.config.Constraints.encode(message.constraints, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified ZoneConfig message, length delimited. Does not implicitly {@link cockroach.config.ZoneConfig.verify|verify} messages.
             * @param {cockroach.config.ZoneConfig$Properties} message ZoneConfig message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ZoneConfig.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ZoneConfig message from the specified reader or buffer.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {cockroach.config.ZoneConfig} ZoneConfig
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ZoneConfig.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.cockroach.config.ZoneConfig();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.replica_attrs && message.replica_attrs.length))
                            message.replica_attrs = [];
                        message.replica_attrs.push($root.cockroach.roachpb.Attributes.decode(reader, reader.uint32()));
                        break;
                    case 2:
                        message.range_min_bytes = reader.int64();
                        break;
                    case 3:
                        message.range_max_bytes = reader.int64();
                        break;
                    case 4:
                        message.gc = $root.cockroach.config.GCPolicy.decode(reader, reader.uint32());
                        break;
                    case 5:
                        message.num_replicas = reader.int32();
                        break;
                    case 6:
                        message.constraints = $root.cockroach.config.Constraints.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ZoneConfig message from the specified reader or buffer, length delimited.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {cockroach.config.ZoneConfig} ZoneConfig
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ZoneConfig.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ZoneConfig message.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            ZoneConfig.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.replica_attrs != null && message.hasOwnProperty("replica_attrs")) {
                    if (!Array.isArray(message.replica_attrs))
                        return "replica_attrs: array expected";
                    for (let i = 0; i < message.replica_attrs.length; ++i) {
                        let error = $root.cockroach.roachpb.Attributes.verify(message.replica_attrs[i]);
                        if (error)
                            return "replica_attrs." + error;
                    }
                }
                if (message.range_min_bytes != null && message.hasOwnProperty("range_min_bytes"))
                    if (!$util.isInteger(message.range_min_bytes) && !(message.range_min_bytes && $util.isInteger(message.range_min_bytes.low) && $util.isInteger(message.range_min_bytes.high)))
                        return "range_min_bytes: integer|Long expected";
                if (message.range_max_bytes != null && message.hasOwnProperty("range_max_bytes"))
                    if (!$util.isInteger(message.range_max_bytes) && !(message.range_max_bytes && $util.isInteger(message.range_max_bytes.low) && $util.isInteger(message.range_max_bytes.high)))
                        return "range_max_bytes: integer|Long expected";
                if (message.gc != null && message.hasOwnProperty("gc")) {
                    let error = $root.cockroach.config.GCPolicy.verify(message.gc);
                    if (error)
                        return "gc." + error;
                }
                if (message.num_replicas != null && message.hasOwnProperty("num_replicas"))
                    if (!$util.isInteger(message.num_replicas))
                        return "num_replicas: integer expected";
                if (message.constraints != null && message.hasOwnProperty("constraints")) {
                    let error = $root.cockroach.config.Constraints.verify(message.constraints);
                    if (error)
                        return "constraints." + error;
                }
                return null;
            };

            /**
             * Creates a ZoneConfig message from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {cockroach.config.ZoneConfig} ZoneConfig
             */
            ZoneConfig.fromObject = function fromObject(object) {
                if (object instanceof $root.cockroach.config.ZoneConfig)
                    return object;
                let message = new $root.cockroach.config.ZoneConfig();
                if (object.replica_attrs) {
                    if (!Array.isArray(object.replica_attrs))
                        throw TypeError(".cockroach.config.ZoneConfig.replica_attrs: array expected");
                    message.replica_attrs = [];
                    for (let i = 0; i < object.replica_attrs.length; ++i) {
                        if (typeof object.replica_attrs[i] !== "object")
                            throw TypeError(".cockroach.config.ZoneConfig.replica_attrs: object expected");
                        message.replica_attrs[i] = $root.cockroach.roachpb.Attributes.fromObject(object.replica_attrs[i]);
                    }
                }
                if (object.range_min_bytes != null)
                    if ($util.Long)
                        (message.range_min_bytes = $util.Long.fromValue(object.range_min_bytes)).unsigned = false;
                    else if (typeof object.range_min_bytes === "string")
                        message.range_min_bytes = parseInt(object.range_min_bytes, 10);
                    else if (typeof object.range_min_bytes === "number")
                        message.range_min_bytes = object.range_min_bytes;
                    else if (typeof object.range_min_bytes === "object")
                        message.range_min_bytes = new $util.LongBits(object.range_min_bytes.low >>> 0, object.range_min_bytes.high >>> 0).toNumber();
                if (object.range_max_bytes != null)
                    if ($util.Long)
                        (message.range_max_bytes = $util.Long.fromValue(object.range_max_bytes)).unsigned = false;
                    else if (typeof object.range_max_bytes === "string")
                        message.range_max_bytes = parseInt(object.range_max_bytes, 10);
                    else if (typeof object.range_max_bytes === "number")
                        message.range_max_bytes = object.range_max_bytes;
                    else if (typeof object.range_max_bytes === "object")
                        message.range_max_bytes = new $util.LongBits(object.range_max_bytes.low >>> 0, object.range_max_bytes.high >>> 0).toNumber();
                if (object.gc != null) {
                    if (typeof object.gc !== "object")
                        throw TypeError(".cockroach.config.ZoneConfig.gc: object expected");
                    message.gc = $root.cockroach.config.GCPolicy.fromObject(object.gc);
                }
                if (object.num_replicas != null)
                    message.num_replicas = object.num_replicas | 0;
                if (object.constraints != null) {
                    if (typeof object.constraints !== "object")
                        throw TypeError(".cockroach.config.ZoneConfig.constraints: object expected");
                    message.constraints = $root.cockroach.config.Constraints.fromObject(object.constraints);
                }
                return message;
            };

            /**
             * Creates a ZoneConfig message from a plain object. Also converts values to their respective internal types.
             * This is an alias of {@link cockroach.config.ZoneConfig.fromObject}.
             * @function
             * @param {Object.<string,*>} object Plain object
             * @returns {cockroach.config.ZoneConfig} ZoneConfig
             */
            ZoneConfig.from = ZoneConfig.fromObject;

            /**
             * Creates a plain object from a ZoneConfig message. Also converts values to other types if specified.
             * @param {cockroach.config.ZoneConfig} message ZoneConfig
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ZoneConfig.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.replica_attrs = [];
                if (options.defaults) {
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, false);
                        object.range_min_bytes = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.range_min_bytes = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, false);
                        object.range_max_bytes = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.range_max_bytes = options.longs === String ? "0" : 0;
                    object.gc = null;
                    object.num_replicas = 0;
                    object.constraints = null;
                }
                if (message.replica_attrs && message.replica_attrs.length) {
                    object.replica_attrs = [];
                    for (let j = 0; j < message.replica_attrs.length; ++j)
                        object.replica_attrs[j] = $root.cockroach.roachpb.Attributes.toObject(message.replica_attrs[j], options);
                }
                if (message.range_min_bytes != null && message.hasOwnProperty("range_min_bytes"))
                    if (typeof message.range_min_bytes === "number")
                        object.range_min_bytes = options.longs === String ? String(message.range_min_bytes) : message.range_min_bytes;
                    else
                        object.range_min_bytes = options.longs === String ? $util.Long.prototype.toString.call(message.range_min_bytes) : options.longs === Number ? new $util.LongBits(message.range_min_bytes.low >>> 0, message.range_min_bytes.high >>> 0).toNumber() : message.range_min_bytes;
                if (message.range_max_bytes != null && message.hasOwnProperty("range_max_bytes"))
                    if (typeof message.range_max_bytes === "number")
                        object.range_max_bytes = options.longs === String ? String(message.range_max_bytes) : message.range_max_bytes;
                    else
                        object.range_max_bytes = options.longs === String ? $util.Long.prototype.toString.call(message.range_max_bytes) : options.longs === Number ? new $util.LongBits(message.range_max_bytes.low >>> 0, message.range_max_bytes.high >>> 0).toNumber() : message.range_max_bytes;
                if (message.gc != null && message.hasOwnProperty("gc"))
                    object.gc = $root.cockroach.config.GCPolicy.toObject(message.gc, options);
                if (message.num_replicas != null && message.hasOwnProperty("num_replicas"))
                    object.num_replicas = message.num_replicas;
                if (message.constraints != null && message.hasOwnProperty("constraints"))
                    object.constraints = $root.cockroach.config.Constraints.toObject(message.constraints, options);
                return object;
            };

            /**
             * Creates a plain object from this ZoneConfig message. Also converts values to other types if specified.
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ZoneConfig.prototype.toObject = function toObject(options) {
                return this.constructor.toObject(this, options);
            };

            /**
             * Converts this ZoneConfig to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            ZoneConfig.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ZoneConfig;
        })();

        config.SystemConfig = (function() {

            /**
             * Properties of a SystemConfig.
             * @typedef cockroach.config.SystemConfig$Properties
             * @type {Object}
             * @property {Array.<cockroach.roachpb.KeyValue$Properties>} [values] SystemConfig values.
             */

            /**
             * Constructs a new SystemConfig.
             * @exports cockroach.config.SystemConfig
             * @constructor
             * @param {cockroach.config.SystemConfig$Properties=} [properties] Properties to set
             */
            function SystemConfig(properties) {
                this.values = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * SystemConfig values.
             * @type {Array.<cockroach.roachpb.KeyValue$Properties>}
             */
            SystemConfig.prototype.values = $util.emptyArray;

            /**
             * Creates a new SystemConfig instance using the specified properties.
             * @param {cockroach.config.SystemConfig$Properties=} [properties] Properties to set
             * @returns {cockroach.config.SystemConfig} SystemConfig instance
             */
            SystemConfig.create = function create(properties) {
                return new SystemConfig(properties);
            };

            /**
             * Encodes the specified SystemConfig message. Does not implicitly {@link cockroach.config.SystemConfig.verify|verify} messages.
             * @param {cockroach.config.SystemConfig$Properties} message SystemConfig message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SystemConfig.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.values != null && message.values.length)
                    for (let i = 0; i < message.values.length; ++i)
                        $root.cockroach.roachpb.KeyValue.encode(message.values[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified SystemConfig message, length delimited. Does not implicitly {@link cockroach.config.SystemConfig.verify|verify} messages.
             * @param {cockroach.config.SystemConfig$Properties} message SystemConfig message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SystemConfig.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a SystemConfig message from the specified reader or buffer.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {cockroach.config.SystemConfig} SystemConfig
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SystemConfig.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.cockroach.config.SystemConfig();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.values && message.values.length))
                            message.values = [];
                        message.values.push($root.cockroach.roachpb.KeyValue.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a SystemConfig message from the specified reader or buffer, length delimited.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {cockroach.config.SystemConfig} SystemConfig
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SystemConfig.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a SystemConfig message.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            SystemConfig.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.values != null && message.hasOwnProperty("values")) {
                    if (!Array.isArray(message.values))
                        return "values: array expected";
                    for (let i = 0; i < message.values.length; ++i) {
                        let error = $root.cockroach.roachpb.KeyValue.verify(message.values[i]);
                        if (error)
                            return "values." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a SystemConfig message from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {cockroach.config.SystemConfig} SystemConfig
             */
            SystemConfig.fromObject = function fromObject(object) {
                if (object instanceof $root.cockroach.config.SystemConfig)
                    return object;
                let message = new $root.cockroach.config.SystemConfig();
                if (object.values) {
                    if (!Array.isArray(object.values))
                        throw TypeError(".cockroach.config.SystemConfig.values: array expected");
                    message.values = [];
                    for (let i = 0; i < object.values.length; ++i) {
                        if (typeof object.values[i] !== "object")
                            throw TypeError(".cockroach.config.SystemConfig.values: object expected");
                        message.values[i] = $root.cockroach.roachpb.KeyValue.fromObject(object.values[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a SystemConfig message from a plain object. Also converts values to their respective internal types.
             * This is an alias of {@link cockroach.config.SystemConfig.fromObject}.
             * @function
             * @param {Object.<string,*>} object Plain object
             * @returns {cockroach.config.SystemConfig} SystemConfig
             */
            SystemConfig.from = SystemConfig.fromObject;

            /**
             * Creates a plain object from a SystemConfig message. Also converts values to other types if specified.
             * @param {cockroach.config.SystemConfig} message SystemConfig
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SystemConfig.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.values = [];
                if (message.values && message.values.length) {
                    object.values = [];
                    for (let j = 0; j < message.values.length; ++j)
                        object.values[j] = $root.cockroach.roachpb.KeyValue.toObject(message.values[j], options);
                }
                return object;
            };

            /**
             * Creates a plain object from this SystemConfig message. Also converts values to other types if specified.
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SystemConfig.prototype.toObject = function toObject(options) {
                return this.constructor.toObject(this, options);
            };

            /**
             * Converts this SystemConfig to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            SystemConfig.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return SystemConfig;
        })();

        return config;
    })();

    cockroach.roachpb = (function() {

        /**
         * Namespace roachpb.
         * @exports cockroach.roachpb
         * @namespace
         */
        const roachpb = {};

        roachpb.Span = (function() {

            /**
             * Properties of a Span.
             * @typedef cockroach.roachpb.Span$Properties
             * @type {Object}
             * @property {Uint8Array} [key] Span key.
             * @property {Uint8Array} [end_key] Span end_key.
             */

            /**
             * Constructs a new Span.
             * @exports cockroach.roachpb.Span
             * @constructor
             * @param {cockroach.roachpb.Span$Properties=} [properties] Properties to set
             */
            function Span(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Span key.
             * @type {Uint8Array}
             */
            Span.prototype.key = $util.newBuffer([]);

            /**
             * Span end_key.
             * @type {Uint8Array}
             */
            Span.prototype.end_key = $util.newBuffer([]);

            /**
             * Creates a new Span instance using the specified properties.
             * @param {cockroach.roachpb.Span$Properties=} [properties] Properties to set
             * @returns {cockroach.roachpb.Span} Span instance
             */
            Span.create = function create(properties) {
                return new Span(properties);
            };

            /**
             * Encodes the specified Span message. Does not implicitly {@link cockroach.roachpb.Span.verify|verify} messages.
             * @param {cockroach.roachpb.Span$Properties} message Span message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Span.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.key != null && message.hasOwnProperty("key"))
                    writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.key);
                if (message.end_key != null && message.hasOwnProperty("end_key"))
                    writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.end_key);
                return writer;
            };

            /**
             * Encodes the specified Span message, length delimited. Does not implicitly {@link cockroach.roachpb.Span.verify|verify} messages.
             * @param {cockroach.roachpb.Span$Properties} message Span message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Span.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Span message from the specified reader or buffer.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {cockroach.roachpb.Span} Span
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Span.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.cockroach.roachpb.Span();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 3:
                        message.key = reader.bytes();
                        break;
                    case 4:
                        message.end_key = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Span message from the specified reader or buffer, length delimited.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {cockroach.roachpb.Span} Span
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Span.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Span message.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            Span.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.key != null && message.hasOwnProperty("key"))
                    if (!(message.key && typeof message.key.length === "number" || $util.isString(message.key)))
                        return "key: buffer expected";
                if (message.end_key != null && message.hasOwnProperty("end_key"))
                    if (!(message.end_key && typeof message.end_key.length === "number" || $util.isString(message.end_key)))
                        return "end_key: buffer expected";
                return null;
            };

            /**
             * Creates a Span message from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {cockroach.roachpb.Span} Span
             */
            Span.fromObject = function fromObject(object) {
                if (object instanceof $root.cockroach.roachpb.Span)
                    return object;
                let message = new $root.cockroach.roachpb.Span();
                if (object.key != null)
                    if (typeof object.key === "string")
                        $util.base64.decode(object.key, message.key = $util.newBuffer($util.base64.length(object.key)), 0);
                    else if (object.key.length)
                        message.key = object.key;
                if (object.end_key != null)
                    if (typeof object.end_key === "string")
                        $util.base64.decode(object.end_key, message.end_key = $util.newBuffer($util.base64.length(object.end_key)), 0);
                    else if (object.end_key.length)
                        message.end_key = object.end_key;
                return message;
            };

            /**
             * Creates a Span message from a plain object. Also converts values to their respective internal types.
             * This is an alias of {@link cockroach.roachpb.Span.fromObject}.
             * @function
             * @param {Object.<string,*>} object Plain object
             * @returns {cockroach.roachpb.Span} Span
             */
            Span.from = Span.fromObject;

            /**
             * Creates a plain object from a Span message. Also converts values to other types if specified.
             * @param {cockroach.roachpb.Span} message Span
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Span.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.key = options.bytes === String ? "" : [];
                    object.end_key = options.bytes === String ? "" : [];
                }
                if (message.key != null && message.hasOwnProperty("key"))
                    object.key = options.bytes === String ? $util.base64.encode(message.key, 0, message.key.length) : options.bytes === Array ? Array.prototype.slice.call(message.key) : message.key;
                if (message.end_key != null && message.hasOwnProperty("end_key"))
                    object.end_key = options.bytes === String ? $util.base64.encode(message.end_key, 0, message.end_key.length) : options.bytes === Array ? Array.prototype.slice.call(message.end_key) : message.end_key;
                return object;
            };

            /**
             * Creates a plain object from this Span message. Also converts values to other types if specified.
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Span.prototype.toObject = function toObject(options) {
                return this.constructor.toObject(this, options);
            };

            /**
             * Converts this Span to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            Span.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return Span;
        })();

        /**
         * ValueType enum.
         * @name ValueType
         * @memberof cockroach.roachpb
         * @enum {number}
         * @property {number} UNKNOWN=0 UNKNOWN value
         * @property {number} NULL=7 NULL value
         * @property {number} INT=1 INT value
         * @property {number} FLOAT=2 FLOAT value
         * @property {number} BYTES=3 BYTES value
         * @property {number} DELIMITED_BYTES=8 DELIMITED_BYTES value
         * @property {number} TIME=4 TIME value
         * @property {number} DECIMAL=5 DECIMAL value
         * @property {number} DELIMITED_DECIMAL=9 DELIMITED_DECIMAL value
         * @property {number} DURATION=6 DURATION value
         * @property {number} TUPLE=10 TUPLE value
         * @property {number} TIMESERIES=100 TIMESERIES value
         */
        roachpb.ValueType = (function() {
            const valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "UNKNOWN"] = 0;
            values[valuesById[7] = "NULL"] = 7;
            values[valuesById[1] = "INT"] = 1;
            values[valuesById[2] = "FLOAT"] = 2;
            values[valuesById[3] = "BYTES"] = 3;
            values[valuesById[8] = "DELIMITED_BYTES"] = 8;
            values[valuesById[4] = "TIME"] = 4;
            values[valuesById[5] = "DECIMAL"] = 5;
            values[valuesById[9] = "DELIMITED_DECIMAL"] = 9;
            values[valuesById[6] = "DURATION"] = 6;
            values[valuesById[10] = "TUPLE"] = 10;
            values[valuesById[100] = "TIMESERIES"] = 100;
            return values;
        })();

        roachpb.Value = (function() {

            /**
             * Properties of a Value.
             * @typedef cockroach.roachpb.Value$Properties
             * @type {Object}
             * @property {Uint8Array} [raw_bytes] Value raw_bytes.
             * @property {cockroach.util.hlc.Timestamp$Properties} [timestamp] Value timestamp.
             */

            /**
             * Constructs a new Value.
             * @exports cockroach.roachpb.Value
             * @constructor
             * @param {cockroach.roachpb.Value$Properties=} [properties] Properties to set
             */
            function Value(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Value raw_bytes.
             * @type {Uint8Array}
             */
            Value.prototype.raw_bytes = $util.newBuffer([]);

            /**
             * Value timestamp.
             * @type {(cockroach.util.hlc.Timestamp$Properties|null)}
             */
            Value.prototype.timestamp = null;

            /**
             * Creates a new Value instance using the specified properties.
             * @param {cockroach.roachpb.Value$Properties=} [properties] Properties to set
             * @returns {cockroach.roachpb.Value} Value instance
             */
            Value.create = function create(properties) {
                return new Value(properties);
            };

            /**
             * Encodes the specified Value message. Does not implicitly {@link cockroach.roachpb.Value.verify|verify} messages.
             * @param {cockroach.roachpb.Value$Properties} message Value message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Value.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.raw_bytes != null && message.hasOwnProperty("raw_bytes"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.raw_bytes);
                if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                    $root.cockroach.util.hlc.Timestamp.encode(message.timestamp, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified Value message, length delimited. Does not implicitly {@link cockroach.roachpb.Value.verify|verify} messages.
             * @param {cockroach.roachpb.Value$Properties} message Value message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Value.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Value message from the specified reader or buffer.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {cockroach.roachpb.Value} Value
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Value.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.cockroach.roachpb.Value();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.raw_bytes = reader.bytes();
                        break;
                    case 2:
                        message.timestamp = $root.cockroach.util.hlc.Timestamp.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Value message from the specified reader or buffer, length delimited.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {cockroach.roachpb.Value} Value
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Value.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Value message.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            Value.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.raw_bytes != null && message.hasOwnProperty("raw_bytes"))
                    if (!(message.raw_bytes && typeof message.raw_bytes.length === "number" || $util.isString(message.raw_bytes)))
                        return "raw_bytes: buffer expected";
                if (message.timestamp != null && message.hasOwnProperty("timestamp")) {
                    let error = $root.cockroach.util.hlc.Timestamp.verify(message.timestamp);
                    if (error)
                        return "timestamp." + error;
                }
                return null;
            };

            /**
             * Creates a Value message from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {cockroach.roachpb.Value} Value
             */
            Value.fromObject = function fromObject(object) {
                if (object instanceof $root.cockroach.roachpb.Value)
                    return object;
                let message = new $root.cockroach.roachpb.Value();
                if (object.raw_bytes != null)
                    if (typeof object.raw_bytes === "string")
                        $util.base64.decode(object.raw_bytes, message.raw_bytes = $util.newBuffer($util.base64.length(object.raw_bytes)), 0);
                    else if (object.raw_bytes.length)
                        message.raw_bytes = object.raw_bytes;
                if (object.timestamp != null) {
                    if (typeof object.timestamp !== "object")
                        throw TypeError(".cockroach.roachpb.Value.timestamp: object expected");
                    message.timestamp = $root.cockroach.util.hlc.Timestamp.fromObject(object.timestamp);
                }
                return message;
            };

            /**
             * Creates a Value message from a plain object. Also converts values to their respective internal types.
             * This is an alias of {@link cockroach.roachpb.Value.fromObject}.
             * @function
             * @param {Object.<string,*>} object Plain object
             * @returns {cockroach.roachpb.Value} Value
             */
            Value.from = Value.fromObject;

            /**
             * Creates a plain object from a Value message. Also converts values to other types if specified.
             * @param {cockroach.roachpb.Value} message Value
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Value.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.raw_bytes = options.bytes === String ? "" : [];
                    object.timestamp = null;
                }
                if (message.raw_bytes != null && message.hasOwnProperty("raw_bytes"))
                    object.raw_bytes = options.bytes === String ? $util.base64.encode(message.raw_bytes, 0, message.raw_bytes.length) : options.bytes === Array ? Array.prototype.slice.call(message.raw_bytes) : message.raw_bytes;
                if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                    object.timestamp = $root.cockroach.util.hlc.Timestamp.toObject(message.timestamp, options);
                return object;
            };

            /**
             * Creates a plain object from this Value message. Also converts values to other types if specified.
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Value.prototype.toObject = function toObject(options) {
                return this.constructor.toObject(this, options);
            };

            /**
             * Converts this Value to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            Value.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return Value;
        })();

        roachpb.KeyValue = (function() {

            /**
             * Properties of a KeyValue.
             * @typedef cockroach.roachpb.KeyValue$Properties
             * @type {Object}
             * @property {Uint8Array} [key] KeyValue key.
             * @property {cockroach.roachpb.Value$Properties} [value] KeyValue value.
             */

            /**
             * Constructs a new KeyValue.
             * @exports cockroach.roachpb.KeyValue
             * @constructor
             * @param {cockroach.roachpb.KeyValue$Properties=} [properties] Properties to set
             */
            function KeyValue(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * KeyValue key.
             * @type {Uint8Array}
             */
            KeyValue.prototype.key = $util.newBuffer([]);

            /**
             * KeyValue value.
             * @type {(cockroach.roachpb.Value$Properties|null)}
             */
            KeyValue.prototype.value = null;

            /**
             * Creates a new KeyValue instance using the specified properties.
             * @param {cockroach.roachpb.KeyValue$Properties=} [properties] Properties to set
             * @returns {cockroach.roachpb.KeyValue} KeyValue instance
             */
            KeyValue.create = function create(properties) {
                return new KeyValue(properties);
            };

            /**
             * Encodes the specified KeyValue message. Does not implicitly {@link cockroach.roachpb.KeyValue.verify|verify} messages.
             * @param {cockroach.roachpb.KeyValue$Properties} message KeyValue message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            KeyValue.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.key != null && message.hasOwnProperty("key"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.key);
                if (message.value != null && message.hasOwnProperty("value"))
                    $root.cockroach.roachpb.Value.encode(message.value, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified KeyValue message, length delimited. Does not implicitly {@link cockroach.roachpb.KeyValue.verify|verify} messages.
             * @param {cockroach.roachpb.KeyValue$Properties} message KeyValue message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            KeyValue.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a KeyValue message from the specified reader or buffer.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {cockroach.roachpb.KeyValue} KeyValue
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            KeyValue.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.cockroach.roachpb.KeyValue();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.key = reader.bytes();
                        break;
                    case 2:
                        message.value = $root.cockroach.roachpb.Value.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a KeyValue message from the specified reader or buffer, length delimited.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {cockroach.roachpb.KeyValue} KeyValue
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            KeyValue.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a KeyValue message.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            KeyValue.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.key != null && message.hasOwnProperty("key"))
                    if (!(message.key && typeof message.key.length === "number" || $util.isString(message.key)))
                        return "key: buffer expected";
                if (message.value != null && message.hasOwnProperty("value")) {
                    let error = $root.cockroach.roachpb.Value.verify(message.value);
                    if (error)
                        return "value." + error;
                }
                return null;
            };

            /**
             * Creates a KeyValue message from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {cockroach.roachpb.KeyValue} KeyValue
             */
            KeyValue.fromObject = function fromObject(object) {
                if (object instanceof $root.cockroach.roachpb.KeyValue)
                    return object;
                let message = new $root.cockroach.roachpb.KeyValue();
                if (object.key != null)
                    if (typeof object.key === "string")
                        $util.base64.decode(object.key, message.key = $util.newBuffer($util.base64.length(object.key)), 0);
                    else if (object.key.length)
                        message.key = object.key;
                if (object.value != null) {
                    if (typeof object.value !== "object")
                        throw TypeError(".cockroach.roachpb.KeyValue.value: object expected");
                    message.value = $root.cockroach.roachpb.Value.fromObject(object.value);
                }
                return message;
            };

            /**
             * Creates a KeyValue message from a plain object. Also converts values to their respective internal types.
             * This is an alias of {@link cockroach.roachpb.KeyValue.fromObject}.
             * @function
             * @param {Object.<string,*>} object Plain object
             * @returns {cockroach.roachpb.KeyValue} KeyValue
             */
            KeyValue.from = KeyValue.fromObject;

            /**
             * Creates a plain object from a KeyValue message. Also converts values to other types if specified.
             * @param {cockroach.roachpb.KeyValue} message KeyValue
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            KeyValue.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.key = options.bytes === String ? "" : [];
                    object.value = null;
                }
                if (message.key != null && message.hasOwnProperty("key"))
                    object.key = options.bytes === String ? $util.base64.encode(message.key, 0, message.key.length) : options.bytes === Array ? Array.prototype.slice.call(message.key) : message.key;
                if (message.value != null && message.hasOwnProperty("value"))
                    object.value = $root.cockroach.roachpb.Value.toObject(message.value, options);
                return object;
            };

            /**
             * Creates a plain object from this KeyValue message. Also converts values to other types if specified.
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            KeyValue.prototype.toObject = function toObject(options) {
                return this.constructor.toObject(this, options);
            };

            /**
             * Converts this KeyValue to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            KeyValue.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return KeyValue;
        })();

        roachpb.StoreIdent = (function() {

            /**
             * Properties of a StoreIdent.
             * @typedef cockroach.roachpb.StoreIdent$Properties
             * @type {Object}
             * @property {Uint8Array} [cluster_id] StoreIdent cluster_id.
             * @property {number} [node_id] StoreIdent node_id.
             * @property {number} [store_id] StoreIdent store_id.
             */

            /**
             * Constructs a new StoreIdent.
             * @exports cockroach.roachpb.StoreIdent
             * @constructor
             * @param {cockroach.roachpb.StoreIdent$Properties=} [properties] Properties to set
             */
            function StoreIdent(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * StoreIdent cluster_id.
             * @type {Uint8Array}
             */
            StoreIdent.prototype.cluster_id = $util.newBuffer([]);

            /**
             * StoreIdent node_id.
             * @type {number}
             */
            StoreIdent.prototype.node_id = 0;

            /**
             * StoreIdent store_id.
             * @type {number}
             */
            StoreIdent.prototype.store_id = 0;

            /**
             * Creates a new StoreIdent instance using the specified properties.
             * @param {cockroach.roachpb.StoreIdent$Properties=} [properties] Properties to set
             * @returns {cockroach.roachpb.StoreIdent} StoreIdent instance
             */
            StoreIdent.create = function create(properties) {
                return new StoreIdent(properties);
            };

            /**
             * Encodes the specified StoreIdent message. Does not implicitly {@link cockroach.roachpb.StoreIdent.verify|verify} messages.
             * @param {cockroach.roachpb.StoreIdent$Properties} message StoreIdent message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            StoreIdent.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.cluster_id != null && message.hasOwnProperty("cluster_id"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.cluster_id);
                if (message.node_id != null && message.hasOwnProperty("node_id"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.node_id);
                if (message.store_id != null && message.hasOwnProperty("store_id"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.store_id);
                return writer;
            };

            /**
             * Encodes the specified StoreIdent message, length delimited. Does not implicitly {@link cockroach.roachpb.StoreIdent.verify|verify} messages.
             * @param {cockroach.roachpb.StoreIdent$Properties} message StoreIdent message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            StoreIdent.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a StoreIdent message from the specified reader or buffer.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {cockroach.roachpb.StoreIdent} StoreIdent
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            StoreIdent.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.cockroach.roachpb.StoreIdent();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.cluster_id = reader.bytes();
                        break;
                    case 2:
                        message.node_id = reader.int32();
                        break;
                    case 3:
                        message.store_id = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a StoreIdent message from the specified reader or buffer, length delimited.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {cockroach.roachpb.StoreIdent} StoreIdent
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            StoreIdent.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a StoreIdent message.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            StoreIdent.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.cluster_id != null && message.hasOwnProperty("cluster_id"))
                    if (!(message.cluster_id && typeof message.cluster_id.length === "number" || $util.isString(message.cluster_id)))
                        return "cluster_id: buffer expected";
                if (message.node_id != null && message.hasOwnProperty("node_id"))
                    if (!$util.isInteger(message.node_id))
                        return "node_id: integer expected";
                if (message.store_id != null && message.hasOwnProperty("store_id"))
                    if (!$util.isInteger(message.store_id))
                        return "store_id: integer expected";
                return null;
            };

            /**
             * Creates a StoreIdent message from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {cockroach.roachpb.StoreIdent} StoreIdent
             */
            StoreIdent.fromObject = function fromObject(object) {
                if (object instanceof $root.cockroach.roachpb.StoreIdent)
                    return object;
                let message = new $root.cockroach.roachpb.StoreIdent();
                if (object.cluster_id != null)
                    if (typeof object.cluster_id === "string")
                        $util.base64.decode(object.cluster_id, message.cluster_id = $util.newBuffer($util.base64.length(object.cluster_id)), 0);
                    else if (object.cluster_id.length)
                        message.cluster_id = object.cluster_id;
                if (object.node_id != null)
                    message.node_id = object.node_id | 0;
                if (object.store_id != null)
                    message.store_id = object.store_id | 0;
                return message;
            };

            /**
             * Creates a StoreIdent message from a plain object. Also converts values to their respective internal types.
             * This is an alias of {@link cockroach.roachpb.StoreIdent.fromObject}.
             * @function
             * @param {Object.<string,*>} object Plain object
             * @returns {cockroach.roachpb.StoreIdent} StoreIdent
             */
            StoreIdent.from = StoreIdent.fromObject;

            /**
             * Creates a plain object from a StoreIdent message. Also converts values to other types if specified.
             * @param {cockroach.roachpb.StoreIdent} message StoreIdent
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            StoreIdent.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.cluster_id = options.bytes === String ? "" : [];
                    object.node_id = 0;
                    object.store_id = 0;
                }
                if (message.cluster_id != null && message.hasOwnProperty("cluster_id"))
                    object.cluster_id = options.bytes === String ? $util.base64.encode(message.cluster_id, 0, message.cluster_id.length) : options.bytes === Array ? Array.prototype.slice.call(message.cluster_id) : message.cluster_id;
                if (message.node_id != null && message.hasOwnProperty("node_id"))
                    object.node_id = message.node_id;
                if (message.store_id != null && message.hasOwnProperty("store_id"))
                    object.store_id = message.store_id;
                return object;
            };

            /**
             * Creates a plain object from this StoreIdent message. Also converts values to other types if specified.
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            StoreIdent.prototype.toObject = function toObject(options) {
                return this.constructor.toObject(this, options);
            };

            /**
             * Converts this StoreIdent to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            StoreIdent.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return StoreIdent;
        })();

        roachpb.SplitTrigger = (function() {

            /**
             * Properties of a SplitTrigger.
             * @typedef cockroach.roachpb.SplitTrigger$Properties
             * @type {Object}
             * @property {cockroach.roachpb.RangeDescriptor$Properties} [left_desc] SplitTrigger left_desc.
             * @property {cockroach.roachpb.RangeDescriptor$Properties} [right_desc] SplitTrigger right_desc.
             */

            /**
             * Constructs a new SplitTrigger.
             * @exports cockroach.roachpb.SplitTrigger
             * @constructor
             * @param {cockroach.roachpb.SplitTrigger$Properties=} [properties] Properties to set
             */
            function SplitTrigger(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * SplitTrigger left_desc.
             * @type {(cockroach.roachpb.RangeDescriptor$Properties|null)}
             */
            SplitTrigger.prototype.left_desc = null;

            /**
             * SplitTrigger right_desc.
             * @type {(cockroach.roachpb.RangeDescriptor$Properties|null)}
             */
            SplitTrigger.prototype.right_desc = null;

            /**
             * Creates a new SplitTrigger instance using the specified properties.
             * @param {cockroach.roachpb.SplitTrigger$Properties=} [properties] Properties to set
             * @returns {cockroach.roachpb.SplitTrigger} SplitTrigger instance
             */
            SplitTrigger.create = function create(properties) {
                return new SplitTrigger(properties);
            };

            /**
             * Encodes the specified SplitTrigger message. Does not implicitly {@link cockroach.roachpb.SplitTrigger.verify|verify} messages.
             * @param {cockroach.roachpb.SplitTrigger$Properties} message SplitTrigger message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SplitTrigger.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.left_desc != null && message.hasOwnProperty("left_desc"))
                    $root.cockroach.roachpb.RangeDescriptor.encode(message.left_desc, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.right_desc != null && message.hasOwnProperty("right_desc"))
                    $root.cockroach.roachpb.RangeDescriptor.encode(message.right_desc, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified SplitTrigger message, length delimited. Does not implicitly {@link cockroach.roachpb.SplitTrigger.verify|verify} messages.
             * @param {cockroach.roachpb.SplitTrigger$Properties} message SplitTrigger message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SplitTrigger.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a SplitTrigger message from the specified reader or buffer.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {cockroach.roachpb.SplitTrigger} SplitTrigger
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SplitTrigger.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.cockroach.roachpb.SplitTrigger();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.left_desc = $root.cockroach.roachpb.RangeDescriptor.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.right_desc = $root.cockroach.roachpb.RangeDescriptor.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a SplitTrigger message from the specified reader or buffer, length delimited.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {cockroach.roachpb.SplitTrigger} SplitTrigger
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SplitTrigger.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a SplitTrigger message.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            SplitTrigger.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.left_desc != null && message.hasOwnProperty("left_desc")) {
                    let error = $root.cockroach.roachpb.RangeDescriptor.verify(message.left_desc);
                    if (error)
                        return "left_desc." + error;
                }
                if (message.right_desc != null && message.hasOwnProperty("right_desc")) {
                    let error = $root.cockroach.roachpb.RangeDescriptor.verify(message.right_desc);
                    if (error)
                        return "right_desc." + error;
                }
                return null;
            };

            /**
             * Creates a SplitTrigger message from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {cockroach.roachpb.SplitTrigger} SplitTrigger
             */
            SplitTrigger.fromObject = function fromObject(object) {
                if (object instanceof $root.cockroach.roachpb.SplitTrigger)
                    return object;
                let message = new $root.cockroach.roachpb.SplitTrigger();
                if (object.left_desc != null) {
                    if (typeof object.left_desc !== "object")
                        throw TypeError(".cockroach.roachpb.SplitTrigger.left_desc: object expected");
                    message.left_desc = $root.cockroach.roachpb.RangeDescriptor.fromObject(object.left_desc);
                }
                if (object.right_desc != null) {
                    if (typeof object.right_desc !== "object")
                        throw TypeError(".cockroach.roachpb.SplitTrigger.right_desc: object expected");
                    message.right_desc = $root.cockroach.roachpb.RangeDescriptor.fromObject(object.right_desc);
                }
                return message;
            };

            /**
             * Creates a SplitTrigger message from a plain object. Also converts values to their respective internal types.
             * This is an alias of {@link cockroach.roachpb.SplitTrigger.fromObject}.
             * @function
             * @param {Object.<string,*>} object Plain object
             * @returns {cockroach.roachpb.SplitTrigger} SplitTrigger
             */
            SplitTrigger.from = SplitTrigger.fromObject;

            /**
             * Creates a plain object from a SplitTrigger message. Also converts values to other types if specified.
             * @param {cockroach.roachpb.SplitTrigger} message SplitTrigger
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SplitTrigger.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.left_desc = null;
                    object.right_desc = null;
                }
                if (message.left_desc != null && message.hasOwnProperty("left_desc"))
                    object.left_desc = $root.cockroach.roachpb.RangeDescriptor.toObject(message.left_desc, options);
                if (message.right_desc != null && message.hasOwnProperty("right_desc"))
                    object.right_desc = $root.cockroach.roachpb.RangeDescriptor.toObject(message.right_desc, options);
                return object;
            };

            /**
             * Creates a plain object from this SplitTrigger message. Also converts values to other types if specified.
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SplitTrigger.prototype.toObject = function toObject(options) {
                return this.constructor.toObject(this, options);
            };

            /**
             * Converts this SplitTrigger to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            SplitTrigger.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return SplitTrigger;
        })();

        roachpb.MergeTrigger = (function() {

            /**
             * Properties of a MergeTrigger.
             * @typedef cockroach.roachpb.MergeTrigger$Properties
             * @type {Object}
             * @property {cockroach.roachpb.RangeDescriptor$Properties} [left_desc] MergeTrigger left_desc.
             * @property {cockroach.roachpb.RangeDescriptor$Properties} [right_desc] MergeTrigger right_desc.
             */

            /**
             * Constructs a new MergeTrigger.
             * @exports cockroach.roachpb.MergeTrigger
             * @constructor
             * @param {cockroach.roachpb.MergeTrigger$Properties=} [properties] Properties to set
             */
            function MergeTrigger(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * MergeTrigger left_desc.
             * @type {(cockroach.roachpb.RangeDescriptor$Properties|null)}
             */
            MergeTrigger.prototype.left_desc = null;

            /**
             * MergeTrigger right_desc.
             * @type {(cockroach.roachpb.RangeDescriptor$Properties|null)}
             */
            MergeTrigger.prototype.right_desc = null;

            /**
             * Creates a new MergeTrigger instance using the specified properties.
             * @param {cockroach.roachpb.MergeTrigger$Properties=} [properties] Properties to set
             * @returns {cockroach.roachpb.MergeTrigger} MergeTrigger instance
             */
            MergeTrigger.create = function create(properties) {
                return new MergeTrigger(properties);
            };

            /**
             * Encodes the specified MergeTrigger message. Does not implicitly {@link cockroach.roachpb.MergeTrigger.verify|verify} messages.
             * @param {cockroach.roachpb.MergeTrigger$Properties} message MergeTrigger message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MergeTrigger.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.left_desc != null && message.hasOwnProperty("left_desc"))
                    $root.cockroach.roachpb.RangeDescriptor.encode(message.left_desc, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.right_desc != null && message.hasOwnProperty("right_desc"))
                    $root.cockroach.roachpb.RangeDescriptor.encode(message.right_desc, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified MergeTrigger message, length delimited. Does not implicitly {@link cockroach.roachpb.MergeTrigger.verify|verify} messages.
             * @param {cockroach.roachpb.MergeTrigger$Properties} message MergeTrigger message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MergeTrigger.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a MergeTrigger message from the specified reader or buffer.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {cockroach.roachpb.MergeTrigger} MergeTrigger
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MergeTrigger.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.cockroach.roachpb.MergeTrigger();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.left_desc = $root.cockroach.roachpb.RangeDescriptor.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.right_desc = $root.cockroach.roachpb.RangeDescriptor.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a MergeTrigger message from the specified reader or buffer, length delimited.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {cockroach.roachpb.MergeTrigger} MergeTrigger
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MergeTrigger.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a MergeTrigger message.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            MergeTrigger.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.left_desc != null && message.hasOwnProperty("left_desc")) {
                    let error = $root.cockroach.roachpb.RangeDescriptor.verify(message.left_desc);
                    if (error)
                        return "left_desc." + error;
                }
                if (message.right_desc != null && message.hasOwnProperty("right_desc")) {
                    let error = $root.cockroach.roachpb.RangeDescriptor.verify(message.right_desc);
                    if (error)
                        return "right_desc." + error;
                }
                return null;
            };

            /**
             * Creates a MergeTrigger message from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {cockroach.roachpb.MergeTrigger} MergeTrigger
             */
            MergeTrigger.fromObject = function fromObject(object) {
                if (object instanceof $root.cockroach.roachpb.MergeTrigger)
                    return object;
                let message = new $root.cockroach.roachpb.MergeTrigger();
                if (object.left_desc != null) {
                    if (typeof object.left_desc !== "object")
                        throw TypeError(".cockroach.roachpb.MergeTrigger.left_desc: object expected");
                    message.left_desc = $root.cockroach.roachpb.RangeDescriptor.fromObject(object.left_desc);
                }
                if (object.right_desc != null) {
                    if (typeof object.right_desc !== "object")
                        throw TypeError(".cockroach.roachpb.MergeTrigger.right_desc: object expected");
                    message.right_desc = $root.cockroach.roachpb.RangeDescriptor.fromObject(object.right_desc);
                }
                return message;
            };

            /**
             * Creates a MergeTrigger message from a plain object. Also converts values to their respective internal types.
             * This is an alias of {@link cockroach.roachpb.MergeTrigger.fromObject}.
             * @function
             * @param {Object.<string,*>} object Plain object
             * @returns {cockroach.roachpb.MergeTrigger} MergeTrigger
             */
            MergeTrigger.from = MergeTrigger.fromObject;

            /**
             * Creates a plain object from a MergeTrigger message. Also converts values to other types if specified.
             * @param {cockroach.roachpb.MergeTrigger} message MergeTrigger
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            MergeTrigger.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.left_desc = null;
                    object.right_desc = null;
                }
                if (message.left_desc != null && message.hasOwnProperty("left_desc"))
                    object.left_desc = $root.cockroach.roachpb.RangeDescriptor.toObject(message.left_desc, options);
                if (message.right_desc != null && message.hasOwnProperty("right_desc"))
                    object.right_desc = $root.cockroach.roachpb.RangeDescriptor.toObject(message.right_desc, options);
                return object;
            };

            /**
             * Creates a plain object from this MergeTrigger message. Also converts values to other types if specified.
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            MergeTrigger.prototype.toObject = function toObject(options) {
                return this.constructor.toObject(this, options);
            };

            /**
             * Converts this MergeTrigger to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            MergeTrigger.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return MergeTrigger;
        })();

        /**
         * ReplicaChangeType enum.
         * @name ReplicaChangeType
         * @memberof cockroach.roachpb
         * @enum {number}
         * @property {number} ADD_REPLICA=0 ADD_REPLICA value
         * @property {number} REMOVE_REPLICA=1 REMOVE_REPLICA value
         */
        roachpb.ReplicaChangeType = (function() {
            const valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "ADD_REPLICA"] = 0;
            values[valuesById[1] = "REMOVE_REPLICA"] = 1;
            return values;
        })();

        roachpb.ChangeReplicasTrigger = (function() {

            /**
             * Properties of a ChangeReplicasTrigger.
             * @typedef cockroach.roachpb.ChangeReplicasTrigger$Properties
             * @type {Object}
             * @property {cockroach.roachpb.ReplicaChangeType} [change_type] ChangeReplicasTrigger change_type.
             * @property {cockroach.roachpb.ReplicaDescriptor$Properties} [replica] ChangeReplicasTrigger replica.
             * @property {Array.<cockroach.roachpb.ReplicaDescriptor$Properties>} [updated_replicas] ChangeReplicasTrigger updated_replicas.
             * @property {number} [next_replica_id] ChangeReplicasTrigger next_replica_id.
             */

            /**
             * Constructs a new ChangeReplicasTrigger.
             * @exports cockroach.roachpb.ChangeReplicasTrigger
             * @constructor
             * @param {cockroach.roachpb.ChangeReplicasTrigger$Properties=} [properties] Properties to set
             */
            function ChangeReplicasTrigger(properties) {
                this.updated_replicas = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ChangeReplicasTrigger change_type.
             * @type {cockroach.roachpb.ReplicaChangeType}
             */
            ChangeReplicasTrigger.prototype.change_type = 0;

            /**
             * ChangeReplicasTrigger replica.
             * @type {(cockroach.roachpb.ReplicaDescriptor$Properties|null)}
             */
            ChangeReplicasTrigger.prototype.replica = null;

            /**
             * ChangeReplicasTrigger updated_replicas.
             * @type {Array.<cockroach.roachpb.ReplicaDescriptor$Properties>}
             */
            ChangeReplicasTrigger.prototype.updated_replicas = $util.emptyArray;

            /**
             * ChangeReplicasTrigger next_replica_id.
             * @type {number}
             */
            ChangeReplicasTrigger.prototype.next_replica_id = 0;

            /**
             * Creates a new ChangeReplicasTrigger instance using the specified properties.
             * @param {cockroach.roachpb.ChangeReplicasTrigger$Properties=} [properties] Properties to set
             * @returns {cockroach.roachpb.ChangeReplicasTrigger} ChangeReplicasTrigger instance
             */
            ChangeReplicasTrigger.create = function create(properties) {
                return new ChangeReplicasTrigger(properties);
            };

            /**
             * Encodes the specified ChangeReplicasTrigger message. Does not implicitly {@link cockroach.roachpb.ChangeReplicasTrigger.verify|verify} messages.
             * @param {cockroach.roachpb.ChangeReplicasTrigger$Properties} message ChangeReplicasTrigger message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ChangeReplicasTrigger.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.change_type != null && message.hasOwnProperty("change_type"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.change_type);
                if (message.replica != null && message.hasOwnProperty("replica"))
                    $root.cockroach.roachpb.ReplicaDescriptor.encode(message.replica, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.updated_replicas != null && message.updated_replicas.length)
                    for (let i = 0; i < message.updated_replicas.length; ++i)
                        $root.cockroach.roachpb.ReplicaDescriptor.encode(message.updated_replicas[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.next_replica_id != null && message.hasOwnProperty("next_replica_id"))
                    writer.uint32(/* id 4, wireType 0 =*/32).int32(message.next_replica_id);
                return writer;
            };

            /**
             * Encodes the specified ChangeReplicasTrigger message, length delimited. Does not implicitly {@link cockroach.roachpb.ChangeReplicasTrigger.verify|verify} messages.
             * @param {cockroach.roachpb.ChangeReplicasTrigger$Properties} message ChangeReplicasTrigger message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ChangeReplicasTrigger.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ChangeReplicasTrigger message from the specified reader or buffer.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {cockroach.roachpb.ChangeReplicasTrigger} ChangeReplicasTrigger
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ChangeReplicasTrigger.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.cockroach.roachpb.ChangeReplicasTrigger();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.change_type = reader.uint32();
                        break;
                    case 2:
                        message.replica = $root.cockroach.roachpb.ReplicaDescriptor.decode(reader, reader.uint32());
                        break;
                    case 3:
                        if (!(message.updated_replicas && message.updated_replicas.length))
                            message.updated_replicas = [];
                        message.updated_replicas.push($root.cockroach.roachpb.ReplicaDescriptor.decode(reader, reader.uint32()));
                        break;
                    case 4:
                        message.next_replica_id = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ChangeReplicasTrigger message from the specified reader or buffer, length delimited.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {cockroach.roachpb.ChangeReplicasTrigger} ChangeReplicasTrigger
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ChangeReplicasTrigger.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ChangeReplicasTrigger message.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            ChangeReplicasTrigger.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.change_type != null && message.hasOwnProperty("change_type"))
                    switch (message.change_type) {
                    default:
                        return "change_type: enum value expected";
                    case 0:
                    case 1:
                        break;
                    }
                if (message.replica != null && message.hasOwnProperty("replica")) {
                    let error = $root.cockroach.roachpb.ReplicaDescriptor.verify(message.replica);
                    if (error)
                        return "replica." + error;
                }
                if (message.updated_replicas != null && message.hasOwnProperty("updated_replicas")) {
                    if (!Array.isArray(message.updated_replicas))
                        return "updated_replicas: array expected";
                    for (let i = 0; i < message.updated_replicas.length; ++i) {
                        let error = $root.cockroach.roachpb.ReplicaDescriptor.verify(message.updated_replicas[i]);
                        if (error)
                            return "updated_replicas." + error;
                    }
                }
                if (message.next_replica_id != null && message.hasOwnProperty("next_replica_id"))
                    if (!$util.isInteger(message.next_replica_id))
                        return "next_replica_id: integer expected";
                return null;
            };

            /**
             * Creates a ChangeReplicasTrigger message from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {cockroach.roachpb.ChangeReplicasTrigger} ChangeReplicasTrigger
             */
            ChangeReplicasTrigger.fromObject = function fromObject(object) {
                if (object instanceof $root.cockroach.roachpb.ChangeReplicasTrigger)
                    return object;
                let message = new $root.cockroach.roachpb.ChangeReplicasTrigger();
                switch (object.change_type) {
                case "ADD_REPLICA":
                case 0:
                    message.change_type = 0;
                    break;
                case "REMOVE_REPLICA":
                case 1:
                    message.change_type = 1;
                    break;
                }
                if (object.replica != null) {
                    if (typeof object.replica !== "object")
                        throw TypeError(".cockroach.roachpb.ChangeReplicasTrigger.replica: object expected");
                    message.replica = $root.cockroach.roachpb.ReplicaDescriptor.fromObject(object.replica);
                }
                if (object.updated_replicas) {
                    if (!Array.isArray(object.updated_replicas))
                        throw TypeError(".cockroach.roachpb.ChangeReplicasTrigger.updated_replicas: array expected");
                    message.updated_replicas = [];
                    for (let i = 0; i < object.updated_replicas.length; ++i) {
                        if (typeof object.updated_replicas[i] !== "object")
                            throw TypeError(".cockroach.roachpb.ChangeReplicasTrigger.updated_replicas: object expected");
                        message.updated_replicas[i] = $root.cockroach.roachpb.ReplicaDescriptor.fromObject(object.updated_replicas[i]);
                    }
                }
                if (object.next_replica_id != null)
                    message.next_replica_id = object.next_replica_id | 0;
                return message;
            };

            /**
             * Creates a ChangeReplicasTrigger message from a plain object. Also converts values to their respective internal types.
             * This is an alias of {@link cockroach.roachpb.ChangeReplicasTrigger.fromObject}.
             * @function
             * @param {Object.<string,*>} object Plain object
             * @returns {cockroach.roachpb.ChangeReplicasTrigger} ChangeReplicasTrigger
             */
            ChangeReplicasTrigger.from = ChangeReplicasTrigger.fromObject;

            /**
             * Creates a plain object from a ChangeReplicasTrigger message. Also converts values to other types if specified.
             * @param {cockroach.roachpb.ChangeReplicasTrigger} message ChangeReplicasTrigger
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ChangeReplicasTrigger.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.updated_replicas = [];
                if (options.defaults) {
                    object.change_type = options.enums === String ? "ADD_REPLICA" : 0;
                    object.replica = null;
                    object.next_replica_id = 0;
                }
                if (message.change_type != null && message.hasOwnProperty("change_type"))
                    object.change_type = options.enums === String ? $root.cockroach.roachpb.ReplicaChangeType[message.change_type] : message.change_type;
                if (message.replica != null && message.hasOwnProperty("replica"))
                    object.replica = $root.cockroach.roachpb.ReplicaDescriptor.toObject(message.replica, options);
                if (message.updated_replicas && message.updated_replicas.length) {
                    object.updated_replicas = [];
                    for (let j = 0; j < message.updated_replicas.length; ++j)
                        object.updated_replicas[j] = $root.cockroach.roachpb.ReplicaDescriptor.toObject(message.updated_replicas[j], options);
                }
                if (message.next_replica_id != null && message.hasOwnProperty("next_replica_id"))
                    object.next_replica_id = message.next_replica_id;
                return object;
            };

            /**
             * Creates a plain object from this ChangeReplicasTrigger message. Also converts values to other types if specified.
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ChangeReplicasTrigger.prototype.toObject = function toObject(options) {
                return this.constructor.toObject(this, options);
            };

            /**
             * Converts this ChangeReplicasTrigger to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            ChangeReplicasTrigger.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ChangeReplicasTrigger;
        })();

        roachpb.ModifiedSpanTrigger = (function() {

            /**
             * Properties of a ModifiedSpanTrigger.
             * @typedef cockroach.roachpb.ModifiedSpanTrigger$Properties
             * @type {Object}
             * @property {boolean} [system_config_span] ModifiedSpanTrigger system_config_span.
             * @property {cockroach.roachpb.Span$Properties} [node_liveness_span] ModifiedSpanTrigger node_liveness_span.
             */

            /**
             * Constructs a new ModifiedSpanTrigger.
             * @exports cockroach.roachpb.ModifiedSpanTrigger
             * @constructor
             * @param {cockroach.roachpb.ModifiedSpanTrigger$Properties=} [properties] Properties to set
             */
            function ModifiedSpanTrigger(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ModifiedSpanTrigger system_config_span.
             * @type {boolean}
             */
            ModifiedSpanTrigger.prototype.system_config_span = false;

            /**
             * ModifiedSpanTrigger node_liveness_span.
             * @type {(cockroach.roachpb.Span$Properties|null)}
             */
            ModifiedSpanTrigger.prototype.node_liveness_span = null;

            /**
             * Creates a new ModifiedSpanTrigger instance using the specified properties.
             * @param {cockroach.roachpb.ModifiedSpanTrigger$Properties=} [properties] Properties to set
             * @returns {cockroach.roachpb.ModifiedSpanTrigger} ModifiedSpanTrigger instance
             */
            ModifiedSpanTrigger.create = function create(properties) {
                return new ModifiedSpanTrigger(properties);
            };

            /**
             * Encodes the specified ModifiedSpanTrigger message. Does not implicitly {@link cockroach.roachpb.ModifiedSpanTrigger.verify|verify} messages.
             * @param {cockroach.roachpb.ModifiedSpanTrigger$Properties} message ModifiedSpanTrigger message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ModifiedSpanTrigger.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.system_config_span != null && message.hasOwnProperty("system_config_span"))
                    writer.uint32(/* id 1, wireType 0 =*/8).bool(message.system_config_span);
                if (message.node_liveness_span != null && message.hasOwnProperty("node_liveness_span"))
                    $root.cockroach.roachpb.Span.encode(message.node_liveness_span, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified ModifiedSpanTrigger message, length delimited. Does not implicitly {@link cockroach.roachpb.ModifiedSpanTrigger.verify|verify} messages.
             * @param {cockroach.roachpb.ModifiedSpanTrigger$Properties} message ModifiedSpanTrigger message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ModifiedSpanTrigger.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ModifiedSpanTrigger message from the specified reader or buffer.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {cockroach.roachpb.ModifiedSpanTrigger} ModifiedSpanTrigger
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ModifiedSpanTrigger.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.cockroach.roachpb.ModifiedSpanTrigger();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.system_config_span = reader.bool();
                        break;
                    case 2:
                        message.node_liveness_span = $root.cockroach.roachpb.Span.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ModifiedSpanTrigger message from the specified reader or buffer, length delimited.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {cockroach.roachpb.ModifiedSpanTrigger} ModifiedSpanTrigger
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ModifiedSpanTrigger.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ModifiedSpanTrigger message.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            ModifiedSpanTrigger.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.system_config_span != null && message.hasOwnProperty("system_config_span"))
                    if (typeof message.system_config_span !== "boolean")
                        return "system_config_span: boolean expected";
                if (message.node_liveness_span != null && message.hasOwnProperty("node_liveness_span")) {
                    let error = $root.cockroach.roachpb.Span.verify(message.node_liveness_span);
                    if (error)
                        return "node_liveness_span." + error;
                }
                return null;
            };

            /**
             * Creates a ModifiedSpanTrigger message from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {cockroach.roachpb.ModifiedSpanTrigger} ModifiedSpanTrigger
             */
            ModifiedSpanTrigger.fromObject = function fromObject(object) {
                if (object instanceof $root.cockroach.roachpb.ModifiedSpanTrigger)
                    return object;
                let message = new $root.cockroach.roachpb.ModifiedSpanTrigger();
                if (object.system_config_span != null)
                    message.system_config_span = Boolean(object.system_config_span);
                if (object.node_liveness_span != null) {
                    if (typeof object.node_liveness_span !== "object")
                        throw TypeError(".cockroach.roachpb.ModifiedSpanTrigger.node_liveness_span: object expected");
                    message.node_liveness_span = $root.cockroach.roachpb.Span.fromObject(object.node_liveness_span);
                }
                return message;
            };

            /**
             * Creates a ModifiedSpanTrigger message from a plain object. Also converts values to their respective internal types.
             * This is an alias of {@link cockroach.roachpb.ModifiedSpanTrigger.fromObject}.
             * @function
             * @param {Object.<string,*>} object Plain object
             * @returns {cockroach.roachpb.ModifiedSpanTrigger} ModifiedSpanTrigger
             */
            ModifiedSpanTrigger.from = ModifiedSpanTrigger.fromObject;

            /**
             * Creates a plain object from a ModifiedSpanTrigger message. Also converts values to other types if specified.
             * @param {cockroach.roachpb.ModifiedSpanTrigger} message ModifiedSpanTrigger
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ModifiedSpanTrigger.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.system_config_span = false;
                    object.node_liveness_span = null;
                }
                if (message.system_config_span != null && message.hasOwnProperty("system_config_span"))
                    object.system_config_span = message.system_config_span;
                if (message.node_liveness_span != null && message.hasOwnProperty("node_liveness_span"))
                    object.node_liveness_span = $root.cockroach.roachpb.Span.toObject(message.node_liveness_span, options);
                return object;
            };

            /**
             * Creates a plain object from this ModifiedSpanTrigger message. Also converts values to other types if specified.
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ModifiedSpanTrigger.prototype.toObject = function toObject(options) {
                return this.constructor.toObject(this, options);
            };

            /**
             * Converts this ModifiedSpanTrigger to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            ModifiedSpanTrigger.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ModifiedSpanTrigger;
        })();

        roachpb.InternalCommitTrigger = (function() {

            /**
             * Properties of an InternalCommitTrigger.
             * @typedef cockroach.roachpb.InternalCommitTrigger$Properties
             * @type {Object}
             * @property {cockroach.roachpb.SplitTrigger$Properties} [split_trigger] InternalCommitTrigger split_trigger.
             * @property {cockroach.roachpb.MergeTrigger$Properties} [merge_trigger] InternalCommitTrigger merge_trigger.
             * @property {cockroach.roachpb.ChangeReplicasTrigger$Properties} [change_replicas_trigger] InternalCommitTrigger change_replicas_trigger.
             * @property {cockroach.roachpb.ModifiedSpanTrigger$Properties} [modified_span_trigger] InternalCommitTrigger modified_span_trigger.
             */

            /**
             * Constructs a new InternalCommitTrigger.
             * @exports cockroach.roachpb.InternalCommitTrigger
             * @constructor
             * @param {cockroach.roachpb.InternalCommitTrigger$Properties=} [properties] Properties to set
             */
            function InternalCommitTrigger(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * InternalCommitTrigger split_trigger.
             * @type {(cockroach.roachpb.SplitTrigger$Properties|null)}
             */
            InternalCommitTrigger.prototype.split_trigger = null;

            /**
             * InternalCommitTrigger merge_trigger.
             * @type {(cockroach.roachpb.MergeTrigger$Properties|null)}
             */
            InternalCommitTrigger.prototype.merge_trigger = null;

            /**
             * InternalCommitTrigger change_replicas_trigger.
             * @type {(cockroach.roachpb.ChangeReplicasTrigger$Properties|null)}
             */
            InternalCommitTrigger.prototype.change_replicas_trigger = null;

            /**
             * InternalCommitTrigger modified_span_trigger.
             * @type {(cockroach.roachpb.ModifiedSpanTrigger$Properties|null)}
             */
            InternalCommitTrigger.prototype.modified_span_trigger = null;

            /**
             * Creates a new InternalCommitTrigger instance using the specified properties.
             * @param {cockroach.roachpb.InternalCommitTrigger$Properties=} [properties] Properties to set
             * @returns {cockroach.roachpb.InternalCommitTrigger} InternalCommitTrigger instance
             */
            InternalCommitTrigger.create = function create(properties) {
                return new InternalCommitTrigger(properties);
            };

            /**
             * Encodes the specified InternalCommitTrigger message. Does not implicitly {@link cockroach.roachpb.InternalCommitTrigger.verify|verify} messages.
             * @param {cockroach.roachpb.InternalCommitTrigger$Properties} message InternalCommitTrigger message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            InternalCommitTrigger.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.split_trigger != null && message.hasOwnProperty("split_trigger"))
                    $root.cockroach.roachpb.SplitTrigger.encode(message.split_trigger, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.merge_trigger != null && message.hasOwnProperty("merge_trigger"))
                    $root.cockroach.roachpb.MergeTrigger.encode(message.merge_trigger, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.change_replicas_trigger != null && message.hasOwnProperty("change_replicas_trigger"))
                    $root.cockroach.roachpb.ChangeReplicasTrigger.encode(message.change_replicas_trigger, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.modified_span_trigger != null && message.hasOwnProperty("modified_span_trigger"))
                    $root.cockroach.roachpb.ModifiedSpanTrigger.encode(message.modified_span_trigger, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified InternalCommitTrigger message, length delimited. Does not implicitly {@link cockroach.roachpb.InternalCommitTrigger.verify|verify} messages.
             * @param {cockroach.roachpb.InternalCommitTrigger$Properties} message InternalCommitTrigger message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            InternalCommitTrigger.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an InternalCommitTrigger message from the specified reader or buffer.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {cockroach.roachpb.InternalCommitTrigger} InternalCommitTrigger
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            InternalCommitTrigger.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.cockroach.roachpb.InternalCommitTrigger();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.split_trigger = $root.cockroach.roachpb.SplitTrigger.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.merge_trigger = $root.cockroach.roachpb.MergeTrigger.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.change_replicas_trigger = $root.cockroach.roachpb.ChangeReplicasTrigger.decode(reader, reader.uint32());
                        break;
                    case 4:
                        message.modified_span_trigger = $root.cockroach.roachpb.ModifiedSpanTrigger.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an InternalCommitTrigger message from the specified reader or buffer, length delimited.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {cockroach.roachpb.InternalCommitTrigger} InternalCommitTrigger
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            InternalCommitTrigger.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an InternalCommitTrigger message.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            InternalCommitTrigger.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.split_trigger != null && message.hasOwnProperty("split_trigger")) {
                    let error = $root.cockroach.roachpb.SplitTrigger.verify(message.split_trigger);
                    if (error)
                        return "split_trigger." + error;
                }
                if (message.merge_trigger != null && message.hasOwnProperty("merge_trigger")) {
                    let error = $root.cockroach.roachpb.MergeTrigger.verify(message.merge_trigger);
                    if (error)
                        return "merge_trigger." + error;
                }
                if (message.change_replicas_trigger != null && message.hasOwnProperty("change_replicas_trigger")) {
                    let error = $root.cockroach.roachpb.ChangeReplicasTrigger.verify(message.change_replicas_trigger);
                    if (error)
                        return "change_replicas_trigger." + error;
                }
                if (message.modified_span_trigger != null && message.hasOwnProperty("modified_span_trigger")) {
                    let error = $root.cockroach.roachpb.ModifiedSpanTrigger.verify(message.modified_span_trigger);
                    if (error)
                        return "modified_span_trigger." + error;
                }
                return null;
            };

            /**
             * Creates an InternalCommitTrigger message from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {cockroach.roachpb.InternalCommitTrigger} InternalCommitTrigger
             */
            InternalCommitTrigger.fromObject = function fromObject(object) {
                if (object instanceof $root.cockroach.roachpb.InternalCommitTrigger)
                    return object;
                let message = new $root.cockroach.roachpb.InternalCommitTrigger();
                if (object.split_trigger != null) {
                    if (typeof object.split_trigger !== "object")
                        throw TypeError(".cockroach.roachpb.InternalCommitTrigger.split_trigger: object expected");
                    message.split_trigger = $root.cockroach.roachpb.SplitTrigger.fromObject(object.split_trigger);
                }
                if (object.merge_trigger != null) {
                    if (typeof object.merge_trigger !== "object")
                        throw TypeError(".cockroach.roachpb.InternalCommitTrigger.merge_trigger: object expected");
                    message.merge_trigger = $root.cockroach.roachpb.MergeTrigger.fromObject(object.merge_trigger);
                }
                if (object.change_replicas_trigger != null) {
                    if (typeof object.change_replicas_trigger !== "object")
                        throw TypeError(".cockroach.roachpb.InternalCommitTrigger.change_replicas_trigger: object expected");
                    message.change_replicas_trigger = $root.cockroach.roachpb.ChangeReplicasTrigger.fromObject(object.change_replicas_trigger);
                }
                if (object.modified_span_trigger != null) {
                    if (typeof object.modified_span_trigger !== "object")
                        throw TypeError(".cockroach.roachpb.InternalCommitTrigger.modified_span_trigger: object expected");
                    message.modified_span_trigger = $root.cockroach.roachpb.ModifiedSpanTrigger.fromObject(object.modified_span_trigger);
                }
                return message;
            };

            /**
             * Creates an InternalCommitTrigger message from a plain object. Also converts values to their respective internal types.
             * This is an alias of {@link cockroach.roachpb.InternalCommitTrigger.fromObject}.
             * @function
             * @param {Object.<string,*>} object Plain object
             * @returns {cockroach.roachpb.InternalCommitTrigger} InternalCommitTrigger
             */
            InternalCommitTrigger.from = InternalCommitTrigger.fromObject;

            /**
             * Creates a plain object from an InternalCommitTrigger message. Also converts values to other types if specified.
             * @param {cockroach.roachpb.InternalCommitTrigger} message InternalCommitTrigger
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            InternalCommitTrigger.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.split_trigger = null;
                    object.merge_trigger = null;
                    object.change_replicas_trigger = null;
                    object.modified_span_trigger = null;
                }
                if (message.split_trigger != null && message.hasOwnProperty("split_trigger"))
                    object.split_trigger = $root.cockroach.roachpb.SplitTrigger.toObject(message.split_trigger, options);
                if (message.merge_trigger != null && message.hasOwnProperty("merge_trigger"))
                    object.merge_trigger = $root.cockroach.roachpb.MergeTrigger.toObject(message.merge_trigger, options);
                if (message.change_replicas_trigger != null && message.hasOwnProperty("change_replicas_trigger"))
                    object.change_replicas_trigger = $root.cockroach.roachpb.ChangeReplicasTrigger.toObject(message.change_replicas_trigger, options);
                if (message.modified_span_trigger != null && message.hasOwnProperty("modified_span_trigger"))
                    object.modified_span_trigger = $root.cockroach.roachpb.ModifiedSpanTrigger.toObject(message.modified_span_trigger, options);
                return object;
            };

            /**
             * Creates a plain object from this InternalCommitTrigger message. Also converts values to other types if specified.
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            InternalCommitTrigger.prototype.toObject = function toObject(options) {
                return this.constructor.toObject(this, options);
            };

            /**
             * Converts this InternalCommitTrigger to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            InternalCommitTrigger.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return InternalCommitTrigger;
        })();

        /**
         * TransactionStatus enum.
         * @name TransactionStatus
         * @memberof cockroach.roachpb
         * @enum {number}
         * @property {number} PENDING=0 PENDING value
         * @property {number} COMMITTED=1 COMMITTED value
         * @property {number} ABORTED=2 ABORTED value
         */
        roachpb.TransactionStatus = (function() {
            const valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "PENDING"] = 0;
            values[valuesById[1] = "COMMITTED"] = 1;
            values[valuesById[2] = "ABORTED"] = 2;
            return values;
        })();

        roachpb.ObservedTimestamp = (function() {

            /**
             * Properties of an ObservedTimestamp.
             * @typedef cockroach.roachpb.ObservedTimestamp$Properties
             * @type {Object}
             * @property {number} [node_id] ObservedTimestamp node_id.
             * @property {cockroach.util.hlc.Timestamp$Properties} [timestamp] ObservedTimestamp timestamp.
             */

            /**
             * Constructs a new ObservedTimestamp.
             * @exports cockroach.roachpb.ObservedTimestamp
             * @constructor
             * @param {cockroach.roachpb.ObservedTimestamp$Properties=} [properties] Properties to set
             */
            function ObservedTimestamp(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ObservedTimestamp node_id.
             * @type {number}
             */
            ObservedTimestamp.prototype.node_id = 0;

            /**
             * ObservedTimestamp timestamp.
             * @type {(cockroach.util.hlc.Timestamp$Properties|null)}
             */
            ObservedTimestamp.prototype.timestamp = null;

            /**
             * Creates a new ObservedTimestamp instance using the specified properties.
             * @param {cockroach.roachpb.ObservedTimestamp$Properties=} [properties] Properties to set
             * @returns {cockroach.roachpb.ObservedTimestamp} ObservedTimestamp instance
             */
            ObservedTimestamp.create = function create(properties) {
                return new ObservedTimestamp(properties);
            };

            /**
             * Encodes the specified ObservedTimestamp message. Does not implicitly {@link cockroach.roachpb.ObservedTimestamp.verify|verify} messages.
             * @param {cockroach.roachpb.ObservedTimestamp$Properties} message ObservedTimestamp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ObservedTimestamp.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.node_id != null && message.hasOwnProperty("node_id"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.node_id);
                if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                    $root.cockroach.util.hlc.Timestamp.encode(message.timestamp, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified ObservedTimestamp message, length delimited. Does not implicitly {@link cockroach.roachpb.ObservedTimestamp.verify|verify} messages.
             * @param {cockroach.roachpb.ObservedTimestamp$Properties} message ObservedTimestamp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ObservedTimestamp.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an ObservedTimestamp message from the specified reader or buffer.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {cockroach.roachpb.ObservedTimestamp} ObservedTimestamp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ObservedTimestamp.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.cockroach.roachpb.ObservedTimestamp();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.node_id = reader.int32();
                        break;
                    case 2:
                        message.timestamp = $root.cockroach.util.hlc.Timestamp.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an ObservedTimestamp message from the specified reader or buffer, length delimited.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {cockroach.roachpb.ObservedTimestamp} ObservedTimestamp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ObservedTimestamp.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an ObservedTimestamp message.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            ObservedTimestamp.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.node_id != null && message.hasOwnProperty("node_id"))
                    if (!$util.isInteger(message.node_id))
                        return "node_id: integer expected";
                if (message.timestamp != null && message.hasOwnProperty("timestamp")) {
                    let error = $root.cockroach.util.hlc.Timestamp.verify(message.timestamp);
                    if (error)
                        return "timestamp." + error;
                }
                return null;
            };

            /**
             * Creates an ObservedTimestamp message from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {cockroach.roachpb.ObservedTimestamp} ObservedTimestamp
             */
            ObservedTimestamp.fromObject = function fromObject(object) {
                if (object instanceof $root.cockroach.roachpb.ObservedTimestamp)
                    return object;
                let message = new $root.cockroach.roachpb.ObservedTimestamp();
                if (object.node_id != null)
                    message.node_id = object.node_id | 0;
                if (object.timestamp != null) {
                    if (typeof object.timestamp !== "object")
                        throw TypeError(".cockroach.roachpb.ObservedTimestamp.timestamp: object expected");
                    message.timestamp = $root.cockroach.util.hlc.Timestamp.fromObject(object.timestamp);
                }
                return message;
            };

            /**
             * Creates an ObservedTimestamp message from a plain object. Also converts values to their respective internal types.
             * This is an alias of {@link cockroach.roachpb.ObservedTimestamp.fromObject}.
             * @function
             * @param {Object.<string,*>} object Plain object
             * @returns {cockroach.roachpb.ObservedTimestamp} ObservedTimestamp
             */
            ObservedTimestamp.from = ObservedTimestamp.fromObject;

            /**
             * Creates a plain object from an ObservedTimestamp message. Also converts values to other types if specified.
             * @param {cockroach.roachpb.ObservedTimestamp} message ObservedTimestamp
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ObservedTimestamp.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.node_id = 0;
                    object.timestamp = null;
                }
                if (message.node_id != null && message.hasOwnProperty("node_id"))
                    object.node_id = message.node_id;
                if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                    object.timestamp = $root.cockroach.util.hlc.Timestamp.toObject(message.timestamp, options);
                return object;
            };

            /**
             * Creates a plain object from this ObservedTimestamp message. Also converts values to other types if specified.
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ObservedTimestamp.prototype.toObject = function toObject(options) {
                return this.constructor.toObject(this, options);
            };

            /**
             * Converts this ObservedTimestamp to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            ObservedTimestamp.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ObservedTimestamp;
        })();

        roachpb.Transaction = (function() {

            /**
             * Properties of a Transaction.
             * @typedef cockroach.roachpb.Transaction$Properties
             * @type {Object}
             * @property {cockroach.storage.engine.enginepb.TxnMeta$Properties} [meta] Transaction meta.
             * @property {string} [name] Transaction name.
             * @property {cockroach.roachpb.TransactionStatus} [status] Transaction status.
             * @property {cockroach.util.hlc.Timestamp$Properties} [last_heartbeat] Transaction last_heartbeat.
             * @property {cockroach.util.hlc.Timestamp$Properties} [orig_timestamp] Transaction orig_timestamp.
             * @property {cockroach.util.hlc.Timestamp$Properties} [max_timestamp] Transaction max_timestamp.
             * @property {Array.<cockroach.roachpb.ObservedTimestamp$Properties>} [observed_timestamps] Transaction observed_timestamps.
             * @property {boolean} [writing] Transaction writing.
             * @property {boolean} [write_too_old] Transaction write_too_old.
             * @property {boolean} [retry_on_push] Transaction retry_on_push.
             * @property {Array.<cockroach.roachpb.Span$Properties>} [intents] Transaction intents.
             */

            /**
             * Constructs a new Transaction.
             * @exports cockroach.roachpb.Transaction
             * @constructor
             * @param {cockroach.roachpb.Transaction$Properties=} [properties] Properties to set
             */
            function Transaction(properties) {
                this.observed_timestamps = [];
                this.intents = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Transaction meta.
             * @type {(cockroach.storage.engine.enginepb.TxnMeta$Properties|null)}
             */
            Transaction.prototype.meta = null;

            /**
             * Transaction name.
             * @type {string}
             */
            Transaction.prototype.name = "";

            /**
             * Transaction status.
             * @type {cockroach.roachpb.TransactionStatus}
             */
            Transaction.prototype.status = 0;

            /**
             * Transaction last_heartbeat.
             * @type {(cockroach.util.hlc.Timestamp$Properties|null)}
             */
            Transaction.prototype.last_heartbeat = null;

            /**
             * Transaction orig_timestamp.
             * @type {(cockroach.util.hlc.Timestamp$Properties|null)}
             */
            Transaction.prototype.orig_timestamp = null;

            /**
             * Transaction max_timestamp.
             * @type {(cockroach.util.hlc.Timestamp$Properties|null)}
             */
            Transaction.prototype.max_timestamp = null;

            /**
             * Transaction observed_timestamps.
             * @type {Array.<cockroach.roachpb.ObservedTimestamp$Properties>}
             */
            Transaction.prototype.observed_timestamps = $util.emptyArray;

            /**
             * Transaction writing.
             * @type {boolean}
             */
            Transaction.prototype.writing = false;

            /**
             * Transaction write_too_old.
             * @type {boolean}
             */
            Transaction.prototype.write_too_old = false;

            /**
             * Transaction retry_on_push.
             * @type {boolean}
             */
            Transaction.prototype.retry_on_push = false;

            /**
             * Transaction intents.
             * @type {Array.<cockroach.roachpb.Span$Properties>}
             */
            Transaction.prototype.intents = $util.emptyArray;

            /**
             * Creates a new Transaction instance using the specified properties.
             * @param {cockroach.roachpb.Transaction$Properties=} [properties] Properties to set
             * @returns {cockroach.roachpb.Transaction} Transaction instance
             */
            Transaction.create = function create(properties) {
                return new Transaction(properties);
            };

            /**
             * Encodes the specified Transaction message. Does not implicitly {@link cockroach.roachpb.Transaction.verify|verify} messages.
             * @param {cockroach.roachpb.Transaction$Properties} message Transaction message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Transaction.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.meta != null && message.hasOwnProperty("meta"))
                    $root.cockroach.storage.engine.enginepb.TxnMeta.encode(message.meta, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.name != null && message.hasOwnProperty("name"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.name);
                if (message.status != null && message.hasOwnProperty("status"))
                    writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.status);
                if (message.last_heartbeat != null && message.hasOwnProperty("last_heartbeat"))
                    $root.cockroach.util.hlc.Timestamp.encode(message.last_heartbeat, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                if (message.orig_timestamp != null && message.hasOwnProperty("orig_timestamp"))
                    $root.cockroach.util.hlc.Timestamp.encode(message.orig_timestamp, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                if (message.max_timestamp != null && message.hasOwnProperty("max_timestamp"))
                    $root.cockroach.util.hlc.Timestamp.encode(message.max_timestamp, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                if (message.observed_timestamps != null && message.observed_timestamps.length)
                    for (let i = 0; i < message.observed_timestamps.length; ++i)
                        $root.cockroach.roachpb.ObservedTimestamp.encode(message.observed_timestamps[i], writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                if (message.writing != null && message.hasOwnProperty("writing"))
                    writer.uint32(/* id 9, wireType 0 =*/72).bool(message.writing);
                if (message.intents != null && message.intents.length)
                    for (let i = 0; i < message.intents.length; ++i)
                        $root.cockroach.roachpb.Span.encode(message.intents[i], writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
                if (message.write_too_old != null && message.hasOwnProperty("write_too_old"))
                    writer.uint32(/* id 12, wireType 0 =*/96).bool(message.write_too_old);
                if (message.retry_on_push != null && message.hasOwnProperty("retry_on_push"))
                    writer.uint32(/* id 13, wireType 0 =*/104).bool(message.retry_on_push);
                return writer;
            };

            /**
             * Encodes the specified Transaction message, length delimited. Does not implicitly {@link cockroach.roachpb.Transaction.verify|verify} messages.
             * @param {cockroach.roachpb.Transaction$Properties} message Transaction message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Transaction.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Transaction message from the specified reader or buffer.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {cockroach.roachpb.Transaction} Transaction
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Transaction.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.cockroach.roachpb.Transaction();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.meta = $root.cockroach.storage.engine.enginepb.TxnMeta.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.name = reader.string();
                        break;
                    case 4:
                        message.status = reader.uint32();
                        break;
                    case 5:
                        message.last_heartbeat = $root.cockroach.util.hlc.Timestamp.decode(reader, reader.uint32());
                        break;
                    case 6:
                        message.orig_timestamp = $root.cockroach.util.hlc.Timestamp.decode(reader, reader.uint32());
                        break;
                    case 7:
                        message.max_timestamp = $root.cockroach.util.hlc.Timestamp.decode(reader, reader.uint32());
                        break;
                    case 8:
                        if (!(message.observed_timestamps && message.observed_timestamps.length))
                            message.observed_timestamps = [];
                        message.observed_timestamps.push($root.cockroach.roachpb.ObservedTimestamp.decode(reader, reader.uint32()));
                        break;
                    case 9:
                        message.writing = reader.bool();
                        break;
                    case 12:
                        message.write_too_old = reader.bool();
                        break;
                    case 13:
                        message.retry_on_push = reader.bool();
                        break;
                    case 11:
                        if (!(message.intents && message.intents.length))
                            message.intents = [];
                        message.intents.push($root.cockroach.roachpb.Span.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Transaction message from the specified reader or buffer, length delimited.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {cockroach.roachpb.Transaction} Transaction
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Transaction.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Transaction message.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            Transaction.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.meta != null && message.hasOwnProperty("meta")) {
                    let error = $root.cockroach.storage.engine.enginepb.TxnMeta.verify(message.meta);
                    if (error)
                        return "meta." + error;
                }
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.status != null && message.hasOwnProperty("status"))
                    switch (message.status) {
                    default:
                        return "status: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                        break;
                    }
                if (message.last_heartbeat != null && message.hasOwnProperty("last_heartbeat")) {
                    let error = $root.cockroach.util.hlc.Timestamp.verify(message.last_heartbeat);
                    if (error)
                        return "last_heartbeat." + error;
                }
                if (message.orig_timestamp != null && message.hasOwnProperty("orig_timestamp")) {
                    let error = $root.cockroach.util.hlc.Timestamp.verify(message.orig_timestamp);
                    if (error)
                        return "orig_timestamp." + error;
                }
                if (message.max_timestamp != null && message.hasOwnProperty("max_timestamp")) {
                    let error = $root.cockroach.util.hlc.Timestamp.verify(message.max_timestamp);
                    if (error)
                        return "max_timestamp." + error;
                }
                if (message.observed_timestamps != null && message.hasOwnProperty("observed_timestamps")) {
                    if (!Array.isArray(message.observed_timestamps))
                        return "observed_timestamps: array expected";
                    for (let i = 0; i < message.observed_timestamps.length; ++i) {
                        let error = $root.cockroach.roachpb.ObservedTimestamp.verify(message.observed_timestamps[i]);
                        if (error)
                            return "observed_timestamps." + error;
                    }
                }
                if (message.writing != null && message.hasOwnProperty("writing"))
                    if (typeof message.writing !== "boolean")
                        return "writing: boolean expected";
                if (message.write_too_old != null && message.hasOwnProperty("write_too_old"))
                    if (typeof message.write_too_old !== "boolean")
                        return "write_too_old: boolean expected";
                if (message.retry_on_push != null && message.hasOwnProperty("retry_on_push"))
                    if (typeof message.retry_on_push !== "boolean")
                        return "retry_on_push: boolean expected";
                if (message.intents != null && message.hasOwnProperty("intents")) {
                    if (!Array.isArray(message.intents))
                        return "intents: array expected";
                    for (let i = 0; i < message.intents.length; ++i) {
                        let error = $root.cockroach.roachpb.Span.verify(message.intents[i]);
                        if (error)
                            return "intents." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a Transaction message from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {cockroach.roachpb.Transaction} Transaction
             */
            Transaction.fromObject = function fromObject(object) {
                if (object instanceof $root.cockroach.roachpb.Transaction)
                    return object;
                let message = new $root.cockroach.roachpb.Transaction();
                if (object.meta != null) {
                    if (typeof object.meta !== "object")
                        throw TypeError(".cockroach.roachpb.Transaction.meta: object expected");
                    message.meta = $root.cockroach.storage.engine.enginepb.TxnMeta.fromObject(object.meta);
                }
                if (object.name != null)
                    message.name = String(object.name);
                switch (object.status) {
                case "PENDING":
                case 0:
                    message.status = 0;
                    break;
                case "COMMITTED":
                case 1:
                    message.status = 1;
                    break;
                case "ABORTED":
                case 2:
                    message.status = 2;
                    break;
                }
                if (object.last_heartbeat != null) {
                    if (typeof object.last_heartbeat !== "object")
                        throw TypeError(".cockroach.roachpb.Transaction.last_heartbeat: object expected");
                    message.last_heartbeat = $root.cockroach.util.hlc.Timestamp.fromObject(object.last_heartbeat);
                }
                if (object.orig_timestamp != null) {
                    if (typeof object.orig_timestamp !== "object")
                        throw TypeError(".cockroach.roachpb.Transaction.orig_timestamp: object expected");
                    message.orig_timestamp = $root.cockroach.util.hlc.Timestamp.fromObject(object.orig_timestamp);
                }
                if (object.max_timestamp != null) {
                    if (typeof object.max_timestamp !== "object")
                        throw TypeError(".cockroach.roachpb.Transaction.max_timestamp: object expected");
                    message.max_timestamp = $root.cockroach.util.hlc.Timestamp.fromObject(object.max_timestamp);
                }
                if (object.observed_timestamps) {
                    if (!Array.isArray(object.observed_timestamps))
                        throw TypeError(".cockroach.roachpb.Transaction.observed_timestamps: array expected");
                    message.observed_timestamps = [];
                    for (let i = 0; i < object.observed_timestamps.length; ++i) {
                        if (typeof object.observed_timestamps[i] !== "object")
                            throw TypeError(".cockroach.roachpb.Transaction.observed_timestamps: object expected");
                        message.observed_timestamps[i] = $root.cockroach.roachpb.ObservedTimestamp.fromObject(object.observed_timestamps[i]);
                    }
                }
                if (object.writing != null)
                    message.writing = Boolean(object.writing);
                if (object.write_too_old != null)
                    message.write_too_old = Boolean(object.write_too_old);
                if (object.retry_on_push != null)
                    message.retry_on_push = Boolean(object.retry_on_push);
                if (object.intents) {
                    if (!Array.isArray(object.intents))
                        throw TypeError(".cockroach.roachpb.Transaction.intents: array expected");
                    message.intents = [];
                    for (let i = 0; i < object.intents.length; ++i) {
                        if (typeof object.intents[i] !== "object")
                            throw TypeError(".cockroach.roachpb.Transaction.intents: object expected");
                        message.intents[i] = $root.cockroach.roachpb.Span.fromObject(object.intents[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a Transaction message from a plain object. Also converts values to their respective internal types.
             * This is an alias of {@link cockroach.roachpb.Transaction.fromObject}.
             * @function
             * @param {Object.<string,*>} object Plain object
             * @returns {cockroach.roachpb.Transaction} Transaction
             */
            Transaction.from = Transaction.fromObject;

            /**
             * Creates a plain object from a Transaction message. Also converts values to other types if specified.
             * @param {cockroach.roachpb.Transaction} message Transaction
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Transaction.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults) {
                    object.observed_timestamps = [];
                    object.intents = [];
                }
                if (options.defaults) {
                    object.meta = null;
                    object.name = "";
                    object.status = options.enums === String ? "PENDING" : 0;
                    object.last_heartbeat = null;
                    object.orig_timestamp = null;
                    object.max_timestamp = null;
                    object.writing = false;
                    object.write_too_old = false;
                    object.retry_on_push = false;
                }
                if (message.meta != null && message.hasOwnProperty("meta"))
                    object.meta = $root.cockroach.storage.engine.enginepb.TxnMeta.toObject(message.meta, options);
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.status != null && message.hasOwnProperty("status"))
                    object.status = options.enums === String ? $root.cockroach.roachpb.TransactionStatus[message.status] : message.status;
                if (message.last_heartbeat != null && message.hasOwnProperty("last_heartbeat"))
                    object.last_heartbeat = $root.cockroach.util.hlc.Timestamp.toObject(message.last_heartbeat, options);
                if (message.orig_timestamp != null && message.hasOwnProperty("orig_timestamp"))
                    object.orig_timestamp = $root.cockroach.util.hlc.Timestamp.toObject(message.orig_timestamp, options);
                if (message.max_timestamp != null && message.hasOwnProperty("max_timestamp"))
                    object.max_timestamp = $root.cockroach.util.hlc.Timestamp.toObject(message.max_timestamp, options);
                if (message.observed_timestamps && message.observed_timestamps.length) {
                    object.observed_timestamps = [];
                    for (let j = 0; j < message.observed_timestamps.length; ++j)
                        object.observed_timestamps[j] = $root.cockroach.roachpb.ObservedTimestamp.toObject(message.observed_timestamps[j], options);
                }
                if (message.writing != null && message.hasOwnProperty("writing"))
                    object.writing = message.writing;
                if (message.intents && message.intents.length) {
                    object.intents = [];
                    for (let j = 0; j < message.intents.length; ++j)
                        object.intents[j] = $root.cockroach.roachpb.Span.toObject(message.intents[j], options);
                }
                if (message.write_too_old != null && message.hasOwnProperty("write_too_old"))
                    object.write_too_old = message.write_too_old;
                if (message.retry_on_push != null && message.hasOwnProperty("retry_on_push"))
                    object.retry_on_push = message.retry_on_push;
                return object;
            };

            /**
             * Creates a plain object from this Transaction message. Also converts values to other types if specified.
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Transaction.prototype.toObject = function toObject(options) {
                return this.constructor.toObject(this, options);
            };

            /**
             * Converts this Transaction to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            Transaction.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return Transaction;
        })();

        roachpb.Intent = (function() {

            /**
             * Properties of an Intent.
             * @typedef cockroach.roachpb.Intent$Properties
             * @type {Object}
             * @property {cockroach.roachpb.Span$Properties} [span] Intent span.
             * @property {cockroach.storage.engine.enginepb.TxnMeta$Properties} [txn] Intent txn.
             * @property {cockroach.roachpb.TransactionStatus} [status] Intent status.
             */

            /**
             * Constructs a new Intent.
             * @exports cockroach.roachpb.Intent
             * @constructor
             * @param {cockroach.roachpb.Intent$Properties=} [properties] Properties to set
             */
            function Intent(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Intent span.
             * @type {(cockroach.roachpb.Span$Properties|null)}
             */
            Intent.prototype.span = null;

            /**
             * Intent txn.
             * @type {(cockroach.storage.engine.enginepb.TxnMeta$Properties|null)}
             */
            Intent.prototype.txn = null;

            /**
             * Intent status.
             * @type {cockroach.roachpb.TransactionStatus}
             */
            Intent.prototype.status = 0;

            /**
             * Creates a new Intent instance using the specified properties.
             * @param {cockroach.roachpb.Intent$Properties=} [properties] Properties to set
             * @returns {cockroach.roachpb.Intent} Intent instance
             */
            Intent.create = function create(properties) {
                return new Intent(properties);
            };

            /**
             * Encodes the specified Intent message. Does not implicitly {@link cockroach.roachpb.Intent.verify|verify} messages.
             * @param {cockroach.roachpb.Intent$Properties} message Intent message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Intent.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.span != null && message.hasOwnProperty("span"))
                    $root.cockroach.roachpb.Span.encode(message.span, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.txn != null && message.hasOwnProperty("txn"))
                    $root.cockroach.storage.engine.enginepb.TxnMeta.encode(message.txn, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.status != null && message.hasOwnProperty("status"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.status);
                return writer;
            };

            /**
             * Encodes the specified Intent message, length delimited. Does not implicitly {@link cockroach.roachpb.Intent.verify|verify} messages.
             * @param {cockroach.roachpb.Intent$Properties} message Intent message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Intent.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an Intent message from the specified reader or buffer.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {cockroach.roachpb.Intent} Intent
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Intent.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.cockroach.roachpb.Intent();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.span = $root.cockroach.roachpb.Span.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.txn = $root.cockroach.storage.engine.enginepb.TxnMeta.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.status = reader.uint32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an Intent message from the specified reader or buffer, length delimited.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {cockroach.roachpb.Intent} Intent
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Intent.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an Intent message.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            Intent.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.span != null && message.hasOwnProperty("span")) {
                    let error = $root.cockroach.roachpb.Span.verify(message.span);
                    if (error)
                        return "span." + error;
                }
                if (message.txn != null && message.hasOwnProperty("txn")) {
                    let error = $root.cockroach.storage.engine.enginepb.TxnMeta.verify(message.txn);
                    if (error)
                        return "txn." + error;
                }
                if (message.status != null && message.hasOwnProperty("status"))
                    switch (message.status) {
                    default:
                        return "status: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                        break;
                    }
                return null;
            };

            /**
             * Creates an Intent message from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {cockroach.roachpb.Intent} Intent
             */
            Intent.fromObject = function fromObject(object) {
                if (object instanceof $root.cockroach.roachpb.Intent)
                    return object;
                let message = new $root.cockroach.roachpb.Intent();
                if (object.span != null) {
                    if (typeof object.span !== "object")
                        throw TypeError(".cockroach.roachpb.Intent.span: object expected");
                    message.span = $root.cockroach.roachpb.Span.fromObject(object.span);
                }
                if (object.txn != null) {
                    if (typeof object.txn !== "object")
                        throw TypeError(".cockroach.roachpb.Intent.txn: object expected");
                    message.txn = $root.cockroach.storage.engine.enginepb.TxnMeta.fromObject(object.txn);
                }
                switch (object.status) {
                case "PENDING":
                case 0:
                    message.status = 0;
                    break;
                case "COMMITTED":
                case 1:
                    message.status = 1;
                    break;
                case "ABORTED":
                case 2:
                    message.status = 2;
                    break;
                }
                return message;
            };

            /**
             * Creates an Intent message from a plain object. Also converts values to their respective internal types.
             * This is an alias of {@link cockroach.roachpb.Intent.fromObject}.
             * @function
             * @param {Object.<string,*>} object Plain object
             * @returns {cockroach.roachpb.Intent} Intent
             */
            Intent.from = Intent.fromObject;

            /**
             * Creates a plain object from an Intent message. Also converts values to other types if specified.
             * @param {cockroach.roachpb.Intent} message Intent
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Intent.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.span = null;
                    object.txn = null;
                    object.status = options.enums === String ? "PENDING" : 0;
                }
                if (message.span != null && message.hasOwnProperty("span"))
                    object.span = $root.cockroach.roachpb.Span.toObject(message.span, options);
                if (message.txn != null && message.hasOwnProperty("txn"))
                    object.txn = $root.cockroach.storage.engine.enginepb.TxnMeta.toObject(message.txn, options);
                if (message.status != null && message.hasOwnProperty("status"))
                    object.status = options.enums === String ? $root.cockroach.roachpb.TransactionStatus[message.status] : message.status;
                return object;
            };

            /**
             * Creates a plain object from this Intent message. Also converts values to other types if specified.
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Intent.prototype.toObject = function toObject(options) {
                return this.constructor.toObject(this, options);
            };

            /**
             * Converts this Intent to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            Intent.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return Intent;
        })();

        roachpb.Lease = (function() {

            /**
             * Properties of a Lease.
             * @typedef cockroach.roachpb.Lease$Properties
             * @type {Object}
             * @property {cockroach.util.hlc.Timestamp$Properties} [start] Lease start.
             * @property {cockroach.util.hlc.Timestamp$Properties} [expiration] Lease expiration.
             * @property {cockroach.roachpb.ReplicaDescriptor$Properties} [replica] Lease replica.
             * @property {cockroach.util.hlc.Timestamp$Properties} [deprecated_start_stasis] Lease deprecated_start_stasis.
             * @property {cockroach.util.hlc.Timestamp$Properties} [proposed_ts] Lease proposed_ts.
             * @property {Long} [epoch] Lease epoch.
             */

            /**
             * Constructs a new Lease.
             * @exports cockroach.roachpb.Lease
             * @constructor
             * @param {cockroach.roachpb.Lease$Properties=} [properties] Properties to set
             */
            function Lease(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Lease start.
             * @type {(cockroach.util.hlc.Timestamp$Properties|null)}
             */
            Lease.prototype.start = null;

            /**
             * Lease expiration.
             * @type {(cockroach.util.hlc.Timestamp$Properties|null)}
             */
            Lease.prototype.expiration = null;

            /**
             * Lease replica.
             * @type {(cockroach.roachpb.ReplicaDescriptor$Properties|null)}
             */
            Lease.prototype.replica = null;

            /**
             * Lease deprecated_start_stasis.
             * @type {(cockroach.util.hlc.Timestamp$Properties|null)}
             */
            Lease.prototype.deprecated_start_stasis = null;

            /**
             * Lease proposed_ts.
             * @type {(cockroach.util.hlc.Timestamp$Properties|null)}
             */
            Lease.prototype.proposed_ts = null;

            /**
             * Lease epoch.
             * @type {Long}
             */
            Lease.prototype.epoch = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Creates a new Lease instance using the specified properties.
             * @param {cockroach.roachpb.Lease$Properties=} [properties] Properties to set
             * @returns {cockroach.roachpb.Lease} Lease instance
             */
            Lease.create = function create(properties) {
                return new Lease(properties);
            };

            /**
             * Encodes the specified Lease message. Does not implicitly {@link cockroach.roachpb.Lease.verify|verify} messages.
             * @param {cockroach.roachpb.Lease$Properties} message Lease message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Lease.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.start != null && message.hasOwnProperty("start"))
                    $root.cockroach.util.hlc.Timestamp.encode(message.start, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.expiration != null && message.hasOwnProperty("expiration"))
                    $root.cockroach.util.hlc.Timestamp.encode(message.expiration, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.replica != null && message.hasOwnProperty("replica"))
                    $root.cockroach.roachpb.ReplicaDescriptor.encode(message.replica, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.deprecated_start_stasis != null && message.hasOwnProperty("deprecated_start_stasis"))
                    $root.cockroach.util.hlc.Timestamp.encode(message.deprecated_start_stasis, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.proposed_ts != null && message.hasOwnProperty("proposed_ts"))
                    $root.cockroach.util.hlc.Timestamp.encode(message.proposed_ts, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                if (message.epoch != null && message.hasOwnProperty("epoch"))
                    writer.uint32(/* id 6, wireType 0 =*/48).int64(message.epoch);
                return writer;
            };

            /**
             * Encodes the specified Lease message, length delimited. Does not implicitly {@link cockroach.roachpb.Lease.verify|verify} messages.
             * @param {cockroach.roachpb.Lease$Properties} message Lease message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Lease.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Lease message from the specified reader or buffer.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {cockroach.roachpb.Lease} Lease
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Lease.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.cockroach.roachpb.Lease();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.start = $root.cockroach.util.hlc.Timestamp.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.expiration = $root.cockroach.util.hlc.Timestamp.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.replica = $root.cockroach.roachpb.ReplicaDescriptor.decode(reader, reader.uint32());
                        break;
                    case 4:
                        message.deprecated_start_stasis = $root.cockroach.util.hlc.Timestamp.decode(reader, reader.uint32());
                        break;
                    case 5:
                        message.proposed_ts = $root.cockroach.util.hlc.Timestamp.decode(reader, reader.uint32());
                        break;
                    case 6:
                        message.epoch = reader.int64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Lease message from the specified reader or buffer, length delimited.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {cockroach.roachpb.Lease} Lease
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Lease.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Lease message.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            Lease.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.start != null && message.hasOwnProperty("start")) {
                    let error = $root.cockroach.util.hlc.Timestamp.verify(message.start);
                    if (error)
                        return "start." + error;
                }
                if (message.expiration != null && message.hasOwnProperty("expiration")) {
                    let error = $root.cockroach.util.hlc.Timestamp.verify(message.expiration);
                    if (error)
                        return "expiration." + error;
                }
                if (message.replica != null && message.hasOwnProperty("replica")) {
                    let error = $root.cockroach.roachpb.ReplicaDescriptor.verify(message.replica);
                    if (error)
                        return "replica." + error;
                }
                if (message.deprecated_start_stasis != null && message.hasOwnProperty("deprecated_start_stasis")) {
                    let error = $root.cockroach.util.hlc.Timestamp.verify(message.deprecated_start_stasis);
                    if (error)
                        return "deprecated_start_stasis." + error;
                }
                if (message.proposed_ts != null && message.hasOwnProperty("proposed_ts")) {
                    let error = $root.cockroach.util.hlc.Timestamp.verify(message.proposed_ts);
                    if (error)
                        return "proposed_ts." + error;
                }
                if (message.epoch != null && message.hasOwnProperty("epoch"))
                    if (!$util.isInteger(message.epoch) && !(message.epoch && $util.isInteger(message.epoch.low) && $util.isInteger(message.epoch.high)))
                        return "epoch: integer|Long expected";
                return null;
            };

            /**
             * Creates a Lease message from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {cockroach.roachpb.Lease} Lease
             */
            Lease.fromObject = function fromObject(object) {
                if (object instanceof $root.cockroach.roachpb.Lease)
                    return object;
                let message = new $root.cockroach.roachpb.Lease();
                if (object.start != null) {
                    if (typeof object.start !== "object")
                        throw TypeError(".cockroach.roachpb.Lease.start: object expected");
                    message.start = $root.cockroach.util.hlc.Timestamp.fromObject(object.start);
                }
                if (object.expiration != null) {
                    if (typeof object.expiration !== "object")
                        throw TypeError(".cockroach.roachpb.Lease.expiration: object expected");
                    message.expiration = $root.cockroach.util.hlc.Timestamp.fromObject(object.expiration);
                }
                if (object.replica != null) {
                    if (typeof object.replica !== "object")
                        throw TypeError(".cockroach.roachpb.Lease.replica: object expected");
                    message.replica = $root.cockroach.roachpb.ReplicaDescriptor.fromObject(object.replica);
                }
                if (object.deprecated_start_stasis != null) {
                    if (typeof object.deprecated_start_stasis !== "object")
                        throw TypeError(".cockroach.roachpb.Lease.deprecated_start_stasis: object expected");
                    message.deprecated_start_stasis = $root.cockroach.util.hlc.Timestamp.fromObject(object.deprecated_start_stasis);
                }
                if (object.proposed_ts != null) {
                    if (typeof object.proposed_ts !== "object")
                        throw TypeError(".cockroach.roachpb.Lease.proposed_ts: object expected");
                    message.proposed_ts = $root.cockroach.util.hlc.Timestamp.fromObject(object.proposed_ts);
                }
                if (object.epoch != null)
                    if ($util.Long)
                        (message.epoch = $util.Long.fromValue(object.epoch)).unsigned = false;
                    else if (typeof object.epoch === "string")
                        message.epoch = parseInt(object.epoch, 10);
                    else if (typeof object.epoch === "number")
                        message.epoch = object.epoch;
                    else if (typeof object.epoch === "object")
                        message.epoch = new $util.LongBits(object.epoch.low >>> 0, object.epoch.high >>> 0).toNumber();
                return message;
            };

            /**
             * Creates a Lease message from a plain object. Also converts values to their respective internal types.
             * This is an alias of {@link cockroach.roachpb.Lease.fromObject}.
             * @function
             * @param {Object.<string,*>} object Plain object
             * @returns {cockroach.roachpb.Lease} Lease
             */
            Lease.from = Lease.fromObject;

            /**
             * Creates a plain object from a Lease message. Also converts values to other types if specified.
             * @param {cockroach.roachpb.Lease} message Lease
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Lease.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.start = null;
                    object.expiration = null;
                    object.replica = null;
                    object.deprecated_start_stasis = null;
                    object.proposed_ts = null;
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, false);
                        object.epoch = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.epoch = options.longs === String ? "0" : 0;
                }
                if (message.start != null && message.hasOwnProperty("start"))
                    object.start = $root.cockroach.util.hlc.Timestamp.toObject(message.start, options);
                if (message.expiration != null && message.hasOwnProperty("expiration"))
                    object.expiration = $root.cockroach.util.hlc.Timestamp.toObject(message.expiration, options);
                if (message.replica != null && message.hasOwnProperty("replica"))
                    object.replica = $root.cockroach.roachpb.ReplicaDescriptor.toObject(message.replica, options);
                if (message.deprecated_start_stasis != null && message.hasOwnProperty("deprecated_start_stasis"))
                    object.deprecated_start_stasis = $root.cockroach.util.hlc.Timestamp.toObject(message.deprecated_start_stasis, options);
                if (message.proposed_ts != null && message.hasOwnProperty("proposed_ts"))
                    object.proposed_ts = $root.cockroach.util.hlc.Timestamp.toObject(message.proposed_ts, options);
                if (message.epoch != null && message.hasOwnProperty("epoch"))
                    if (typeof message.epoch === "number")
                        object.epoch = options.longs === String ? String(message.epoch) : message.epoch;
                    else
                        object.epoch = options.longs === String ? $util.Long.prototype.toString.call(message.epoch) : options.longs === Number ? new $util.LongBits(message.epoch.low >>> 0, message.epoch.high >>> 0).toNumber() : message.epoch;
                return object;
            };

            /**
             * Creates a plain object from this Lease message. Also converts values to other types if specified.
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Lease.prototype.toObject = function toObject(options) {
                return this.constructor.toObject(this, options);
            };

            /**
             * Converts this Lease to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            Lease.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return Lease;
        })();

        roachpb.AbortCacheEntry = (function() {

            /**
             * Properties of an AbortCacheEntry.
             * @typedef cockroach.roachpb.AbortCacheEntry$Properties
             * @type {Object}
             * @property {Uint8Array} [key] AbortCacheEntry key.
             * @property {cockroach.util.hlc.Timestamp$Properties} [timestamp] AbortCacheEntry timestamp.
             * @property {number} [priority] AbortCacheEntry priority.
             */

            /**
             * Constructs a new AbortCacheEntry.
             * @exports cockroach.roachpb.AbortCacheEntry
             * @constructor
             * @param {cockroach.roachpb.AbortCacheEntry$Properties=} [properties] Properties to set
             */
            function AbortCacheEntry(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * AbortCacheEntry key.
             * @type {Uint8Array}
             */
            AbortCacheEntry.prototype.key = $util.newBuffer([]);

            /**
             * AbortCacheEntry timestamp.
             * @type {(cockroach.util.hlc.Timestamp$Properties|null)}
             */
            AbortCacheEntry.prototype.timestamp = null;

            /**
             * AbortCacheEntry priority.
             * @type {number}
             */
            AbortCacheEntry.prototype.priority = 0;

            /**
             * Creates a new AbortCacheEntry instance using the specified properties.
             * @param {cockroach.roachpb.AbortCacheEntry$Properties=} [properties] Properties to set
             * @returns {cockroach.roachpb.AbortCacheEntry} AbortCacheEntry instance
             */
            AbortCacheEntry.create = function create(properties) {
                return new AbortCacheEntry(properties);
            };

            /**
             * Encodes the specified AbortCacheEntry message. Does not implicitly {@link cockroach.roachpb.AbortCacheEntry.verify|verify} messages.
             * @param {cockroach.roachpb.AbortCacheEntry$Properties} message AbortCacheEntry message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AbortCacheEntry.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.key != null && message.hasOwnProperty("key"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.key);
                if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                    $root.cockroach.util.hlc.Timestamp.encode(message.timestamp, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.priority != null && message.hasOwnProperty("priority"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.priority);
                return writer;
            };

            /**
             * Encodes the specified AbortCacheEntry message, length delimited. Does not implicitly {@link cockroach.roachpb.AbortCacheEntry.verify|verify} messages.
             * @param {cockroach.roachpb.AbortCacheEntry$Properties} message AbortCacheEntry message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AbortCacheEntry.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an AbortCacheEntry message from the specified reader or buffer.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {cockroach.roachpb.AbortCacheEntry} AbortCacheEntry
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AbortCacheEntry.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.cockroach.roachpb.AbortCacheEntry();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.key = reader.bytes();
                        break;
                    case 2:
                        message.timestamp = $root.cockroach.util.hlc.Timestamp.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.priority = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an AbortCacheEntry message from the specified reader or buffer, length delimited.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {cockroach.roachpb.AbortCacheEntry} AbortCacheEntry
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AbortCacheEntry.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an AbortCacheEntry message.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            AbortCacheEntry.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.key != null && message.hasOwnProperty("key"))
                    if (!(message.key && typeof message.key.length === "number" || $util.isString(message.key)))
                        return "key: buffer expected";
                if (message.timestamp != null && message.hasOwnProperty("timestamp")) {
                    let error = $root.cockroach.util.hlc.Timestamp.verify(message.timestamp);
                    if (error)
                        return "timestamp." + error;
                }
                if (message.priority != null && message.hasOwnProperty("priority"))
                    if (!$util.isInteger(message.priority))
                        return "priority: integer expected";
                return null;
            };

            /**
             * Creates an AbortCacheEntry message from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {cockroach.roachpb.AbortCacheEntry} AbortCacheEntry
             */
            AbortCacheEntry.fromObject = function fromObject(object) {
                if (object instanceof $root.cockroach.roachpb.AbortCacheEntry)
                    return object;
                let message = new $root.cockroach.roachpb.AbortCacheEntry();
                if (object.key != null)
                    if (typeof object.key === "string")
                        $util.base64.decode(object.key, message.key = $util.newBuffer($util.base64.length(object.key)), 0);
                    else if (object.key.length)
                        message.key = object.key;
                if (object.timestamp != null) {
                    if (typeof object.timestamp !== "object")
                        throw TypeError(".cockroach.roachpb.AbortCacheEntry.timestamp: object expected");
                    message.timestamp = $root.cockroach.util.hlc.Timestamp.fromObject(object.timestamp);
                }
                if (object.priority != null)
                    message.priority = object.priority | 0;
                return message;
            };

            /**
             * Creates an AbortCacheEntry message from a plain object. Also converts values to their respective internal types.
             * This is an alias of {@link cockroach.roachpb.AbortCacheEntry.fromObject}.
             * @function
             * @param {Object.<string,*>} object Plain object
             * @returns {cockroach.roachpb.AbortCacheEntry} AbortCacheEntry
             */
            AbortCacheEntry.from = AbortCacheEntry.fromObject;

            /**
             * Creates a plain object from an AbortCacheEntry message. Also converts values to other types if specified.
             * @param {cockroach.roachpb.AbortCacheEntry} message AbortCacheEntry
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            AbortCacheEntry.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.key = options.bytes === String ? "" : [];
                    object.timestamp = null;
                    object.priority = 0;
                }
                if (message.key != null && message.hasOwnProperty("key"))
                    object.key = options.bytes === String ? $util.base64.encode(message.key, 0, message.key.length) : options.bytes === Array ? Array.prototype.slice.call(message.key) : message.key;
                if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                    object.timestamp = $root.cockroach.util.hlc.Timestamp.toObject(message.timestamp, options);
                if (message.priority != null && message.hasOwnProperty("priority"))
                    object.priority = message.priority;
                return object;
            };

            /**
             * Creates a plain object from this AbortCacheEntry message. Also converts values to other types if specified.
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            AbortCacheEntry.prototype.toObject = function toObject(options) {
                return this.constructor.toObject(this, options);
            };

            /**
             * Converts this AbortCacheEntry to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            AbortCacheEntry.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return AbortCacheEntry;
        })();

        roachpb.Attributes = (function() {

            /**
             * Properties of an Attributes.
             * @typedef cockroach.roachpb.Attributes$Properties
             * @type {Object}
             * @property {Array.<string>} [attrs] Attributes attrs.
             */

            /**
             * Constructs a new Attributes.
             * @exports cockroach.roachpb.Attributes
             * @constructor
             * @param {cockroach.roachpb.Attributes$Properties=} [properties] Properties to set
             */
            function Attributes(properties) {
                this.attrs = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Attributes attrs.
             * @type {Array.<string>}
             */
            Attributes.prototype.attrs = $util.emptyArray;

            /**
             * Creates a new Attributes instance using the specified properties.
             * @param {cockroach.roachpb.Attributes$Properties=} [properties] Properties to set
             * @returns {cockroach.roachpb.Attributes} Attributes instance
             */
            Attributes.create = function create(properties) {
                return new Attributes(properties);
            };

            /**
             * Encodes the specified Attributes message. Does not implicitly {@link cockroach.roachpb.Attributes.verify|verify} messages.
             * @param {cockroach.roachpb.Attributes$Properties} message Attributes message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Attributes.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.attrs != null && message.attrs.length)
                    for (let i = 0; i < message.attrs.length; ++i)
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.attrs[i]);
                return writer;
            };

            /**
             * Encodes the specified Attributes message, length delimited. Does not implicitly {@link cockroach.roachpb.Attributes.verify|verify} messages.
             * @param {cockroach.roachpb.Attributes$Properties} message Attributes message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Attributes.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an Attributes message from the specified reader or buffer.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {cockroach.roachpb.Attributes} Attributes
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Attributes.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.cockroach.roachpb.Attributes();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.attrs && message.attrs.length))
                            message.attrs = [];
                        message.attrs.push(reader.string());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an Attributes message from the specified reader or buffer, length delimited.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {cockroach.roachpb.Attributes} Attributes
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Attributes.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an Attributes message.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            Attributes.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.attrs != null && message.hasOwnProperty("attrs")) {
                    if (!Array.isArray(message.attrs))
                        return "attrs: array expected";
                    for (let i = 0; i < message.attrs.length; ++i)
                        if (!$util.isString(message.attrs[i]))
                            return "attrs: string[] expected";
                }
                return null;
            };

            /**
             * Creates an Attributes message from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {cockroach.roachpb.Attributes} Attributes
             */
            Attributes.fromObject = function fromObject(object) {
                if (object instanceof $root.cockroach.roachpb.Attributes)
                    return object;
                let message = new $root.cockroach.roachpb.Attributes();
                if (object.attrs) {
                    if (!Array.isArray(object.attrs))
                        throw TypeError(".cockroach.roachpb.Attributes.attrs: array expected");
                    message.attrs = [];
                    for (let i = 0; i < object.attrs.length; ++i)
                        message.attrs[i] = String(object.attrs[i]);
                }
                return message;
            };

            /**
             * Creates an Attributes message from a plain object. Also converts values to their respective internal types.
             * This is an alias of {@link cockroach.roachpb.Attributes.fromObject}.
             * @function
             * @param {Object.<string,*>} object Plain object
             * @returns {cockroach.roachpb.Attributes} Attributes
             */
            Attributes.from = Attributes.fromObject;

            /**
             * Creates a plain object from an Attributes message. Also converts values to other types if specified.
             * @param {cockroach.roachpb.Attributes} message Attributes
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Attributes.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.attrs = [];
                if (message.attrs && message.attrs.length) {
                    object.attrs = [];
                    for (let j = 0; j < message.attrs.length; ++j)
                        object.attrs[j] = message.attrs[j];
                }
                return object;
            };

            /**
             * Creates a plain object from this Attributes message. Also converts values to other types if specified.
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Attributes.prototype.toObject = function toObject(options) {
                return this.constructor.toObject(this, options);
            };

            /**
             * Converts this Attributes to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            Attributes.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return Attributes;
        })();

        roachpb.ReplicationTarget = (function() {

            /**
             * Properties of a ReplicationTarget.
             * @typedef cockroach.roachpb.ReplicationTarget$Properties
             * @type {Object}
             * @property {number} [node_id] ReplicationTarget node_id.
             * @property {number} [store_id] ReplicationTarget store_id.
             */

            /**
             * Constructs a new ReplicationTarget.
             * @exports cockroach.roachpb.ReplicationTarget
             * @constructor
             * @param {cockroach.roachpb.ReplicationTarget$Properties=} [properties] Properties to set
             */
            function ReplicationTarget(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ReplicationTarget node_id.
             * @type {number}
             */
            ReplicationTarget.prototype.node_id = 0;

            /**
             * ReplicationTarget store_id.
             * @type {number}
             */
            ReplicationTarget.prototype.store_id = 0;

            /**
             * Creates a new ReplicationTarget instance using the specified properties.
             * @param {cockroach.roachpb.ReplicationTarget$Properties=} [properties] Properties to set
             * @returns {cockroach.roachpb.ReplicationTarget} ReplicationTarget instance
             */
            ReplicationTarget.create = function create(properties) {
                return new ReplicationTarget(properties);
            };

            /**
             * Encodes the specified ReplicationTarget message. Does not implicitly {@link cockroach.roachpb.ReplicationTarget.verify|verify} messages.
             * @param {cockroach.roachpb.ReplicationTarget$Properties} message ReplicationTarget message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReplicationTarget.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.node_id != null && message.hasOwnProperty("node_id"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.node_id);
                if (message.store_id != null && message.hasOwnProperty("store_id"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.store_id);
                return writer;
            };

            /**
             * Encodes the specified ReplicationTarget message, length delimited. Does not implicitly {@link cockroach.roachpb.ReplicationTarget.verify|verify} messages.
             * @param {cockroach.roachpb.ReplicationTarget$Properties} message ReplicationTarget message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReplicationTarget.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ReplicationTarget message from the specified reader or buffer.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {cockroach.roachpb.ReplicationTarget} ReplicationTarget
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReplicationTarget.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.cockroach.roachpb.ReplicationTarget();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.node_id = reader.int32();
                        break;
                    case 2:
                        message.store_id = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ReplicationTarget message from the specified reader or buffer, length delimited.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {cockroach.roachpb.ReplicationTarget} ReplicationTarget
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReplicationTarget.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ReplicationTarget message.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            ReplicationTarget.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.node_id != null && message.hasOwnProperty("node_id"))
                    if (!$util.isInteger(message.node_id))
                        return "node_id: integer expected";
                if (message.store_id != null && message.hasOwnProperty("store_id"))
                    if (!$util.isInteger(message.store_id))
                        return "store_id: integer expected";
                return null;
            };

            /**
             * Creates a ReplicationTarget message from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {cockroach.roachpb.ReplicationTarget} ReplicationTarget
             */
            ReplicationTarget.fromObject = function fromObject(object) {
                if (object instanceof $root.cockroach.roachpb.ReplicationTarget)
                    return object;
                let message = new $root.cockroach.roachpb.ReplicationTarget();
                if (object.node_id != null)
                    message.node_id = object.node_id | 0;
                if (object.store_id != null)
                    message.store_id = object.store_id | 0;
                return message;
            };

            /**
             * Creates a ReplicationTarget message from a plain object. Also converts values to their respective internal types.
             * This is an alias of {@link cockroach.roachpb.ReplicationTarget.fromObject}.
             * @function
             * @param {Object.<string,*>} object Plain object
             * @returns {cockroach.roachpb.ReplicationTarget} ReplicationTarget
             */
            ReplicationTarget.from = ReplicationTarget.fromObject;

            /**
             * Creates a plain object from a ReplicationTarget message. Also converts values to other types if specified.
             * @param {cockroach.roachpb.ReplicationTarget} message ReplicationTarget
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ReplicationTarget.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.node_id = 0;
                    object.store_id = 0;
                }
                if (message.node_id != null && message.hasOwnProperty("node_id"))
                    object.node_id = message.node_id;
                if (message.store_id != null && message.hasOwnProperty("store_id"))
                    object.store_id = message.store_id;
                return object;
            };

            /**
             * Creates a plain object from this ReplicationTarget message. Also converts values to other types if specified.
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ReplicationTarget.prototype.toObject = function toObject(options) {
                return this.constructor.toObject(this, options);
            };

            /**
             * Converts this ReplicationTarget to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            ReplicationTarget.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ReplicationTarget;
        })();

        roachpb.ReplicaDescriptor = (function() {

            /**
             * Properties of a ReplicaDescriptor.
             * @typedef cockroach.roachpb.ReplicaDescriptor$Properties
             * @type {Object}
             * @property {number} [node_id] ReplicaDescriptor node_id.
             * @property {number} [store_id] ReplicaDescriptor store_id.
             * @property {number} [replica_id] ReplicaDescriptor replica_id.
             */

            /**
             * Constructs a new ReplicaDescriptor.
             * @exports cockroach.roachpb.ReplicaDescriptor
             * @constructor
             * @param {cockroach.roachpb.ReplicaDescriptor$Properties=} [properties] Properties to set
             */
            function ReplicaDescriptor(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ReplicaDescriptor node_id.
             * @type {number}
             */
            ReplicaDescriptor.prototype.node_id = 0;

            /**
             * ReplicaDescriptor store_id.
             * @type {number}
             */
            ReplicaDescriptor.prototype.store_id = 0;

            /**
             * ReplicaDescriptor replica_id.
             * @type {number}
             */
            ReplicaDescriptor.prototype.replica_id = 0;

            /**
             * Creates a new ReplicaDescriptor instance using the specified properties.
             * @param {cockroach.roachpb.ReplicaDescriptor$Properties=} [properties] Properties to set
             * @returns {cockroach.roachpb.ReplicaDescriptor} ReplicaDescriptor instance
             */
            ReplicaDescriptor.create = function create(properties) {
                return new ReplicaDescriptor(properties);
            };

            /**
             * Encodes the specified ReplicaDescriptor message. Does not implicitly {@link cockroach.roachpb.ReplicaDescriptor.verify|verify} messages.
             * @param {cockroach.roachpb.ReplicaDescriptor$Properties} message ReplicaDescriptor message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReplicaDescriptor.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.node_id != null && message.hasOwnProperty("node_id"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.node_id);
                if (message.store_id != null && message.hasOwnProperty("store_id"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.store_id);
                if (message.replica_id != null && message.hasOwnProperty("replica_id"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.replica_id);
                return writer;
            };

            /**
             * Encodes the specified ReplicaDescriptor message, length delimited. Does not implicitly {@link cockroach.roachpb.ReplicaDescriptor.verify|verify} messages.
             * @param {cockroach.roachpb.ReplicaDescriptor$Properties} message ReplicaDescriptor message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReplicaDescriptor.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ReplicaDescriptor message from the specified reader or buffer.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {cockroach.roachpb.ReplicaDescriptor} ReplicaDescriptor
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReplicaDescriptor.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.cockroach.roachpb.ReplicaDescriptor();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.node_id = reader.int32();
                        break;
                    case 2:
                        message.store_id = reader.int32();
                        break;
                    case 3:
                        message.replica_id = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ReplicaDescriptor message from the specified reader or buffer, length delimited.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {cockroach.roachpb.ReplicaDescriptor} ReplicaDescriptor
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReplicaDescriptor.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ReplicaDescriptor message.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            ReplicaDescriptor.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.node_id != null && message.hasOwnProperty("node_id"))
                    if (!$util.isInteger(message.node_id))
                        return "node_id: integer expected";
                if (message.store_id != null && message.hasOwnProperty("store_id"))
                    if (!$util.isInteger(message.store_id))
                        return "store_id: integer expected";
                if (message.replica_id != null && message.hasOwnProperty("replica_id"))
                    if (!$util.isInteger(message.replica_id))
                        return "replica_id: integer expected";
                return null;
            };

            /**
             * Creates a ReplicaDescriptor message from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {cockroach.roachpb.ReplicaDescriptor} ReplicaDescriptor
             */
            ReplicaDescriptor.fromObject = function fromObject(object) {
                if (object instanceof $root.cockroach.roachpb.ReplicaDescriptor)
                    return object;
                let message = new $root.cockroach.roachpb.ReplicaDescriptor();
                if (object.node_id != null)
                    message.node_id = object.node_id | 0;
                if (object.store_id != null)
                    message.store_id = object.store_id | 0;
                if (object.replica_id != null)
                    message.replica_id = object.replica_id | 0;
                return message;
            };

            /**
             * Creates a ReplicaDescriptor message from a plain object. Also converts values to their respective internal types.
             * This is an alias of {@link cockroach.roachpb.ReplicaDescriptor.fromObject}.
             * @function
             * @param {Object.<string,*>} object Plain object
             * @returns {cockroach.roachpb.ReplicaDescriptor} ReplicaDescriptor
             */
            ReplicaDescriptor.from = ReplicaDescriptor.fromObject;

            /**
             * Creates a plain object from a ReplicaDescriptor message. Also converts values to other types if specified.
             * @param {cockroach.roachpb.ReplicaDescriptor} message ReplicaDescriptor
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ReplicaDescriptor.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.node_id = 0;
                    object.store_id = 0;
                    object.replica_id = 0;
                }
                if (message.node_id != null && message.hasOwnProperty("node_id"))
                    object.node_id = message.node_id;
                if (message.store_id != null && message.hasOwnProperty("store_id"))
                    object.store_id = message.store_id;
                if (message.replica_id != null && message.hasOwnProperty("replica_id"))
                    object.replica_id = message.replica_id;
                return object;
            };

            /**
             * Creates a plain object from this ReplicaDescriptor message. Also converts values to other types if specified.
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ReplicaDescriptor.prototype.toObject = function toObject(options) {
                return this.constructor.toObject(this, options);
            };

            /**
             * Converts this ReplicaDescriptor to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            ReplicaDescriptor.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ReplicaDescriptor;
        })();

        roachpb.ReplicaIdent = (function() {

            /**
             * Properties of a ReplicaIdent.
             * @typedef cockroach.roachpb.ReplicaIdent$Properties
             * @type {Object}
             * @property {Long} [range_id] ReplicaIdent range_id.
             * @property {cockroach.roachpb.ReplicaDescriptor$Properties} [replica] ReplicaIdent replica.
             */

            /**
             * Constructs a new ReplicaIdent.
             * @exports cockroach.roachpb.ReplicaIdent
             * @constructor
             * @param {cockroach.roachpb.ReplicaIdent$Properties=} [properties] Properties to set
             */
            function ReplicaIdent(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ReplicaIdent range_id.
             * @type {Long}
             */
            ReplicaIdent.prototype.range_id = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * ReplicaIdent replica.
             * @type {(cockroach.roachpb.ReplicaDescriptor$Properties|null)}
             */
            ReplicaIdent.prototype.replica = null;

            /**
             * Creates a new ReplicaIdent instance using the specified properties.
             * @param {cockroach.roachpb.ReplicaIdent$Properties=} [properties] Properties to set
             * @returns {cockroach.roachpb.ReplicaIdent} ReplicaIdent instance
             */
            ReplicaIdent.create = function create(properties) {
                return new ReplicaIdent(properties);
            };

            /**
             * Encodes the specified ReplicaIdent message. Does not implicitly {@link cockroach.roachpb.ReplicaIdent.verify|verify} messages.
             * @param {cockroach.roachpb.ReplicaIdent$Properties} message ReplicaIdent message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReplicaIdent.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.range_id != null && message.hasOwnProperty("range_id"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int64(message.range_id);
                if (message.replica != null && message.hasOwnProperty("replica"))
                    $root.cockroach.roachpb.ReplicaDescriptor.encode(message.replica, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified ReplicaIdent message, length delimited. Does not implicitly {@link cockroach.roachpb.ReplicaIdent.verify|verify} messages.
             * @param {cockroach.roachpb.ReplicaIdent$Properties} message ReplicaIdent message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReplicaIdent.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ReplicaIdent message from the specified reader or buffer.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {cockroach.roachpb.ReplicaIdent} ReplicaIdent
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReplicaIdent.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.cockroach.roachpb.ReplicaIdent();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.range_id = reader.int64();
                        break;
                    case 2:
                        message.replica = $root.cockroach.roachpb.ReplicaDescriptor.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ReplicaIdent message from the specified reader or buffer, length delimited.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {cockroach.roachpb.ReplicaIdent} ReplicaIdent
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReplicaIdent.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ReplicaIdent message.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            ReplicaIdent.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.range_id != null && message.hasOwnProperty("range_id"))
                    if (!$util.isInteger(message.range_id) && !(message.range_id && $util.isInteger(message.range_id.low) && $util.isInteger(message.range_id.high)))
                        return "range_id: integer|Long expected";
                if (message.replica != null && message.hasOwnProperty("replica")) {
                    let error = $root.cockroach.roachpb.ReplicaDescriptor.verify(message.replica);
                    if (error)
                        return "replica." + error;
                }
                return null;
            };

            /**
             * Creates a ReplicaIdent message from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {cockroach.roachpb.ReplicaIdent} ReplicaIdent
             */
            ReplicaIdent.fromObject = function fromObject(object) {
                if (object instanceof $root.cockroach.roachpb.ReplicaIdent)
                    return object;
                let message = new $root.cockroach.roachpb.ReplicaIdent();
                if (object.range_id != null)
                    if ($util.Long)
                        (message.range_id = $util.Long.fromValue(object.range_id)).unsigned = false;
                    else if (typeof object.range_id === "string")
                        message.range_id = parseInt(object.range_id, 10);
                    else if (typeof object.range_id === "number")
                        message.range_id = object.range_id;
                    else if (typeof object.range_id === "object")
                        message.range_id = new $util.LongBits(object.range_id.low >>> 0, object.range_id.high >>> 0).toNumber();
                if (object.replica != null) {
                    if (typeof object.replica !== "object")
                        throw TypeError(".cockroach.roachpb.ReplicaIdent.replica: object expected");
                    message.replica = $root.cockroach.roachpb.ReplicaDescriptor.fromObject(object.replica);
                }
                return message;
            };

            /**
             * Creates a ReplicaIdent message from a plain object. Also converts values to their respective internal types.
             * This is an alias of {@link cockroach.roachpb.ReplicaIdent.fromObject}.
             * @function
             * @param {Object.<string,*>} object Plain object
             * @returns {cockroach.roachpb.ReplicaIdent} ReplicaIdent
             */
            ReplicaIdent.from = ReplicaIdent.fromObject;

            /**
             * Creates a plain object from a ReplicaIdent message. Also converts values to other types if specified.
             * @param {cockroach.roachpb.ReplicaIdent} message ReplicaIdent
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ReplicaIdent.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, false);
                        object.range_id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.range_id = options.longs === String ? "0" : 0;
                    object.replica = null;
                }
                if (message.range_id != null && message.hasOwnProperty("range_id"))
                    if (typeof message.range_id === "number")
                        object.range_id = options.longs === String ? String(message.range_id) : message.range_id;
                    else
                        object.range_id = options.longs === String ? $util.Long.prototype.toString.call(message.range_id) : options.longs === Number ? new $util.LongBits(message.range_id.low >>> 0, message.range_id.high >>> 0).toNumber() : message.range_id;
                if (message.replica != null && message.hasOwnProperty("replica"))
                    object.replica = $root.cockroach.roachpb.ReplicaDescriptor.toObject(message.replica, options);
                return object;
            };

            /**
             * Creates a plain object from this ReplicaIdent message. Also converts values to other types if specified.
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ReplicaIdent.prototype.toObject = function toObject(options) {
                return this.constructor.toObject(this, options);
            };

            /**
             * Converts this ReplicaIdent to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            ReplicaIdent.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ReplicaIdent;
        })();

        roachpb.RangeDescriptor = (function() {

            /**
             * Properties of a RangeDescriptor.
             * @typedef cockroach.roachpb.RangeDescriptor$Properties
             * @type {Object}
             * @property {Long} [range_id] RangeDescriptor range_id.
             * @property {Uint8Array} [start_key] RangeDescriptor start_key.
             * @property {Uint8Array} [end_key] RangeDescriptor end_key.
             * @property {Array.<cockroach.roachpb.ReplicaDescriptor$Properties>} [replicas] RangeDescriptor replicas.
             * @property {number} [next_replica_id] RangeDescriptor next_replica_id.
             */

            /**
             * Constructs a new RangeDescriptor.
             * @exports cockroach.roachpb.RangeDescriptor
             * @constructor
             * @param {cockroach.roachpb.RangeDescriptor$Properties=} [properties] Properties to set
             */
            function RangeDescriptor(properties) {
                this.replicas = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * RangeDescriptor range_id.
             * @type {Long}
             */
            RangeDescriptor.prototype.range_id = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * RangeDescriptor start_key.
             * @type {Uint8Array}
             */
            RangeDescriptor.prototype.start_key = $util.newBuffer([]);

            /**
             * RangeDescriptor end_key.
             * @type {Uint8Array}
             */
            RangeDescriptor.prototype.end_key = $util.newBuffer([]);

            /**
             * RangeDescriptor replicas.
             * @type {Array.<cockroach.roachpb.ReplicaDescriptor$Properties>}
             */
            RangeDescriptor.prototype.replicas = $util.emptyArray;

            /**
             * RangeDescriptor next_replica_id.
             * @type {number}
             */
            RangeDescriptor.prototype.next_replica_id = 0;

            /**
             * Creates a new RangeDescriptor instance using the specified properties.
             * @param {cockroach.roachpb.RangeDescriptor$Properties=} [properties] Properties to set
             * @returns {cockroach.roachpb.RangeDescriptor} RangeDescriptor instance
             */
            RangeDescriptor.create = function create(properties) {
                return new RangeDescriptor(properties);
            };

            /**
             * Encodes the specified RangeDescriptor message. Does not implicitly {@link cockroach.roachpb.RangeDescriptor.verify|verify} messages.
             * @param {cockroach.roachpb.RangeDescriptor$Properties} message RangeDescriptor message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RangeDescriptor.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.range_id != null && message.hasOwnProperty("range_id"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int64(message.range_id);
                if (message.start_key != null && message.hasOwnProperty("start_key"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.start_key);
                if (message.end_key != null && message.hasOwnProperty("end_key"))
                    writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.end_key);
                if (message.replicas != null && message.replicas.length)
                    for (let i = 0; i < message.replicas.length; ++i)
                        $root.cockroach.roachpb.ReplicaDescriptor.encode(message.replicas[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.next_replica_id != null && message.hasOwnProperty("next_replica_id"))
                    writer.uint32(/* id 5, wireType 0 =*/40).int32(message.next_replica_id);
                return writer;
            };

            /**
             * Encodes the specified RangeDescriptor message, length delimited. Does not implicitly {@link cockroach.roachpb.RangeDescriptor.verify|verify} messages.
             * @param {cockroach.roachpb.RangeDescriptor$Properties} message RangeDescriptor message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RangeDescriptor.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a RangeDescriptor message from the specified reader or buffer.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {cockroach.roachpb.RangeDescriptor} RangeDescriptor
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RangeDescriptor.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.cockroach.roachpb.RangeDescriptor();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.range_id = reader.int64();
                        break;
                    case 2:
                        message.start_key = reader.bytes();
                        break;
                    case 3:
                        message.end_key = reader.bytes();
                        break;
                    case 4:
                        if (!(message.replicas && message.replicas.length))
                            message.replicas = [];
                        message.replicas.push($root.cockroach.roachpb.ReplicaDescriptor.decode(reader, reader.uint32()));
                        break;
                    case 5:
                        message.next_replica_id = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a RangeDescriptor message from the specified reader or buffer, length delimited.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {cockroach.roachpb.RangeDescriptor} RangeDescriptor
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RangeDescriptor.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a RangeDescriptor message.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            RangeDescriptor.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.range_id != null && message.hasOwnProperty("range_id"))
                    if (!$util.isInteger(message.range_id) && !(message.range_id && $util.isInteger(message.range_id.low) && $util.isInteger(message.range_id.high)))
                        return "range_id: integer|Long expected";
                if (message.start_key != null && message.hasOwnProperty("start_key"))
                    if (!(message.start_key && typeof message.start_key.length === "number" || $util.isString(message.start_key)))
                        return "start_key: buffer expected";
                if (message.end_key != null && message.hasOwnProperty("end_key"))
                    if (!(message.end_key && typeof message.end_key.length === "number" || $util.isString(message.end_key)))
                        return "end_key: buffer expected";
                if (message.replicas != null && message.hasOwnProperty("replicas")) {
                    if (!Array.isArray(message.replicas))
                        return "replicas: array expected";
                    for (let i = 0; i < message.replicas.length; ++i) {
                        let error = $root.cockroach.roachpb.ReplicaDescriptor.verify(message.replicas[i]);
                        if (error)
                            return "replicas." + error;
                    }
                }
                if (message.next_replica_id != null && message.hasOwnProperty("next_replica_id"))
                    if (!$util.isInteger(message.next_replica_id))
                        return "next_replica_id: integer expected";
                return null;
            };

            /**
             * Creates a RangeDescriptor message from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {cockroach.roachpb.RangeDescriptor} RangeDescriptor
             */
            RangeDescriptor.fromObject = function fromObject(object) {
                if (object instanceof $root.cockroach.roachpb.RangeDescriptor)
                    return object;
                let message = new $root.cockroach.roachpb.RangeDescriptor();
                if (object.range_id != null)
                    if ($util.Long)
                        (message.range_id = $util.Long.fromValue(object.range_id)).unsigned = false;
                    else if (typeof object.range_id === "string")
                        message.range_id = parseInt(object.range_id, 10);
                    else if (typeof object.range_id === "number")
                        message.range_id = object.range_id;
                    else if (typeof object.range_id === "object")
                        message.range_id = new $util.LongBits(object.range_id.low >>> 0, object.range_id.high >>> 0).toNumber();
                if (object.start_key != null)
                    if (typeof object.start_key === "string")
                        $util.base64.decode(object.start_key, message.start_key = $util.newBuffer($util.base64.length(object.start_key)), 0);
                    else if (object.start_key.length)
                        message.start_key = object.start_key;
                if (object.end_key != null)
                    if (typeof object.end_key === "string")
                        $util.base64.decode(object.end_key, message.end_key = $util.newBuffer($util.base64.length(object.end_key)), 0);
                    else if (object.end_key.length)
                        message.end_key = object.end_key;
                if (object.replicas) {
                    if (!Array.isArray(object.replicas))
                        throw TypeError(".cockroach.roachpb.RangeDescriptor.replicas: array expected");
                    message.replicas = [];
                    for (let i = 0; i < object.replicas.length; ++i) {
                        if (typeof object.replicas[i] !== "object")
                            throw TypeError(".cockroach.roachpb.RangeDescriptor.replicas: object expected");
                        message.replicas[i] = $root.cockroach.roachpb.ReplicaDescriptor.fromObject(object.replicas[i]);
                    }
                }
                if (object.next_replica_id != null)
                    message.next_replica_id = object.next_replica_id | 0;
                return message;
            };

            /**
             * Creates a RangeDescriptor message from a plain object. Also converts values to their respective internal types.
             * This is an alias of {@link cockroach.roachpb.RangeDescriptor.fromObject}.
             * @function
             * @param {Object.<string,*>} object Plain object
             * @returns {cockroach.roachpb.RangeDescriptor} RangeDescriptor
             */
            RangeDescriptor.from = RangeDescriptor.fromObject;

            /**
             * Creates a plain object from a RangeDescriptor message. Also converts values to other types if specified.
             * @param {cockroach.roachpb.RangeDescriptor} message RangeDescriptor
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            RangeDescriptor.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.replicas = [];
                if (options.defaults) {
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, false);
                        object.range_id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.range_id = options.longs === String ? "0" : 0;
                    object.start_key = options.bytes === String ? "" : [];
                    object.end_key = options.bytes === String ? "" : [];
                    object.next_replica_id = 0;
                }
                if (message.range_id != null && message.hasOwnProperty("range_id"))
                    if (typeof message.range_id === "number")
                        object.range_id = options.longs === String ? String(message.range_id) : message.range_id;
                    else
                        object.range_id = options.longs === String ? $util.Long.prototype.toString.call(message.range_id) : options.longs === Number ? new $util.LongBits(message.range_id.low >>> 0, message.range_id.high >>> 0).toNumber() : message.range_id;
                if (message.start_key != null && message.hasOwnProperty("start_key"))
                    object.start_key = options.bytes === String ? $util.base64.encode(message.start_key, 0, message.start_key.length) : options.bytes === Array ? Array.prototype.slice.call(message.start_key) : message.start_key;
                if (message.end_key != null && message.hasOwnProperty("end_key"))
                    object.end_key = options.bytes === String ? $util.base64.encode(message.end_key, 0, message.end_key.length) : options.bytes === Array ? Array.prototype.slice.call(message.end_key) : message.end_key;
                if (message.replicas && message.replicas.length) {
                    object.replicas = [];
                    for (let j = 0; j < message.replicas.length; ++j)
                        object.replicas[j] = $root.cockroach.roachpb.ReplicaDescriptor.toObject(message.replicas[j], options);
                }
                if (message.next_replica_id != null && message.hasOwnProperty("next_replica_id"))
                    object.next_replica_id = message.next_replica_id;
                return object;
            };

            /**
             * Creates a plain object from this RangeDescriptor message. Also converts values to other types if specified.
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            RangeDescriptor.prototype.toObject = function toObject(options) {
                return this.constructor.toObject(this, options);
            };

            /**
             * Converts this RangeDescriptor to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            RangeDescriptor.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return RangeDescriptor;
        })();

        roachpb.StoreCapacity = (function() {

            /**
             * Properties of a StoreCapacity.
             * @typedef cockroach.roachpb.StoreCapacity$Properties
             * @type {Object}
             * @property {Long} [capacity] StoreCapacity capacity.
             * @property {Long} [available] StoreCapacity available.
             * @property {number} [range_count] StoreCapacity range_count.
             * @property {number} [lease_count] StoreCapacity lease_count.
             */

            /**
             * Constructs a new StoreCapacity.
             * @exports cockroach.roachpb.StoreCapacity
             * @constructor
             * @param {cockroach.roachpb.StoreCapacity$Properties=} [properties] Properties to set
             */
            function StoreCapacity(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * StoreCapacity capacity.
             * @type {Long}
             */
            StoreCapacity.prototype.capacity = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * StoreCapacity available.
             * @type {Long}
             */
            StoreCapacity.prototype.available = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * StoreCapacity range_count.
             * @type {number}
             */
            StoreCapacity.prototype.range_count = 0;

            /**
             * StoreCapacity lease_count.
             * @type {number}
             */
            StoreCapacity.prototype.lease_count = 0;

            /**
             * Creates a new StoreCapacity instance using the specified properties.
             * @param {cockroach.roachpb.StoreCapacity$Properties=} [properties] Properties to set
             * @returns {cockroach.roachpb.StoreCapacity} StoreCapacity instance
             */
            StoreCapacity.create = function create(properties) {
                return new StoreCapacity(properties);
            };

            /**
             * Encodes the specified StoreCapacity message. Does not implicitly {@link cockroach.roachpb.StoreCapacity.verify|verify} messages.
             * @param {cockroach.roachpb.StoreCapacity$Properties} message StoreCapacity message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            StoreCapacity.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.capacity != null && message.hasOwnProperty("capacity"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int64(message.capacity);
                if (message.available != null && message.hasOwnProperty("available"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int64(message.available);
                if (message.range_count != null && message.hasOwnProperty("range_count"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.range_count);
                if (message.lease_count != null && message.hasOwnProperty("lease_count"))
                    writer.uint32(/* id 4, wireType 0 =*/32).int32(message.lease_count);
                return writer;
            };

            /**
             * Encodes the specified StoreCapacity message, length delimited. Does not implicitly {@link cockroach.roachpb.StoreCapacity.verify|verify} messages.
             * @param {cockroach.roachpb.StoreCapacity$Properties} message StoreCapacity message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            StoreCapacity.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a StoreCapacity message from the specified reader or buffer.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {cockroach.roachpb.StoreCapacity} StoreCapacity
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            StoreCapacity.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.cockroach.roachpb.StoreCapacity();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.capacity = reader.int64();
                        break;
                    case 2:
                        message.available = reader.int64();
                        break;
                    case 3:
                        message.range_count = reader.int32();
                        break;
                    case 4:
                        message.lease_count = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a StoreCapacity message from the specified reader or buffer, length delimited.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {cockroach.roachpb.StoreCapacity} StoreCapacity
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            StoreCapacity.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a StoreCapacity message.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            StoreCapacity.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.capacity != null && message.hasOwnProperty("capacity"))
                    if (!$util.isInteger(message.capacity) && !(message.capacity && $util.isInteger(message.capacity.low) && $util.isInteger(message.capacity.high)))
                        return "capacity: integer|Long expected";
                if (message.available != null && message.hasOwnProperty("available"))
                    if (!$util.isInteger(message.available) && !(message.available && $util.isInteger(message.available.low) && $util.isInteger(message.available.high)))
                        return "available: integer|Long expected";
                if (message.range_count != null && message.hasOwnProperty("range_count"))
                    if (!$util.isInteger(message.range_count))
                        return "range_count: integer expected";
                if (message.lease_count != null && message.hasOwnProperty("lease_count"))
                    if (!$util.isInteger(message.lease_count))
                        return "lease_count: integer expected";
                return null;
            };

            /**
             * Creates a StoreCapacity message from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {cockroach.roachpb.StoreCapacity} StoreCapacity
             */
            StoreCapacity.fromObject = function fromObject(object) {
                if (object instanceof $root.cockroach.roachpb.StoreCapacity)
                    return object;
                let message = new $root.cockroach.roachpb.StoreCapacity();
                if (object.capacity != null)
                    if ($util.Long)
                        (message.capacity = $util.Long.fromValue(object.capacity)).unsigned = false;
                    else if (typeof object.capacity === "string")
                        message.capacity = parseInt(object.capacity, 10);
                    else if (typeof object.capacity === "number")
                        message.capacity = object.capacity;
                    else if (typeof object.capacity === "object")
                        message.capacity = new $util.LongBits(object.capacity.low >>> 0, object.capacity.high >>> 0).toNumber();
                if (object.available != null)
                    if ($util.Long)
                        (message.available = $util.Long.fromValue(object.available)).unsigned = false;
                    else if (typeof object.available === "string")
                        message.available = parseInt(object.available, 10);
                    else if (typeof object.available === "number")
                        message.available = object.available;
                    else if (typeof object.available === "object")
                        message.available = new $util.LongBits(object.available.low >>> 0, object.available.high >>> 0).toNumber();
                if (object.range_count != null)
                    message.range_count = object.range_count | 0;
                if (object.lease_count != null)
                    message.lease_count = object.lease_count | 0;
                return message;
            };

            /**
             * Creates a StoreCapacity message from a plain object. Also converts values to their respective internal types.
             * This is an alias of {@link cockroach.roachpb.StoreCapacity.fromObject}.
             * @function
             * @param {Object.<string,*>} object Plain object
             * @returns {cockroach.roachpb.StoreCapacity} StoreCapacity
             */
            StoreCapacity.from = StoreCapacity.fromObject;

            /**
             * Creates a plain object from a StoreCapacity message. Also converts values to other types if specified.
             * @param {cockroach.roachpb.StoreCapacity} message StoreCapacity
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            StoreCapacity.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, false);
                        object.capacity = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.capacity = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, false);
                        object.available = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.available = options.longs === String ? "0" : 0;
                    object.range_count = 0;
                    object.lease_count = 0;
                }
                if (message.capacity != null && message.hasOwnProperty("capacity"))
                    if (typeof message.capacity === "number")
                        object.capacity = options.longs === String ? String(message.capacity) : message.capacity;
                    else
                        object.capacity = options.longs === String ? $util.Long.prototype.toString.call(message.capacity) : options.longs === Number ? new $util.LongBits(message.capacity.low >>> 0, message.capacity.high >>> 0).toNumber() : message.capacity;
                if (message.available != null && message.hasOwnProperty("available"))
                    if (typeof message.available === "number")
                        object.available = options.longs === String ? String(message.available) : message.available;
                    else
                        object.available = options.longs === String ? $util.Long.prototype.toString.call(message.available) : options.longs === Number ? new $util.LongBits(message.available.low >>> 0, message.available.high >>> 0).toNumber() : message.available;
                if (message.range_count != null && message.hasOwnProperty("range_count"))
                    object.range_count = message.range_count;
                if (message.lease_count != null && message.hasOwnProperty("lease_count"))
                    object.lease_count = message.lease_count;
                return object;
            };

            /**
             * Creates a plain object from this StoreCapacity message. Also converts values to other types if specified.
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            StoreCapacity.prototype.toObject = function toObject(options) {
                return this.constructor.toObject(this, options);
            };

            /**
             * Converts this StoreCapacity to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            StoreCapacity.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return StoreCapacity;
        })();

        roachpb.NodeDescriptor = (function() {

            /**
             * Properties of a NodeDescriptor.
             * @typedef cockroach.roachpb.NodeDescriptor$Properties
             * @type {Object}
             * @property {number} [node_id] NodeDescriptor node_id.
             * @property {cockroach.util.UnresolvedAddr$Properties} [address] NodeDescriptor address.
             * @property {cockroach.roachpb.Attributes$Properties} [attrs] NodeDescriptor attrs.
             * @property {cockroach.roachpb.Locality$Properties} [locality] NodeDescriptor locality.
             */

            /**
             * Constructs a new NodeDescriptor.
             * @exports cockroach.roachpb.NodeDescriptor
             * @constructor
             * @param {cockroach.roachpb.NodeDescriptor$Properties=} [properties] Properties to set
             */
            function NodeDescriptor(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * NodeDescriptor node_id.
             * @type {number}
             */
            NodeDescriptor.prototype.node_id = 0;

            /**
             * NodeDescriptor address.
             * @type {(cockroach.util.UnresolvedAddr$Properties|null)}
             */
            NodeDescriptor.prototype.address = null;

            /**
             * NodeDescriptor attrs.
             * @type {(cockroach.roachpb.Attributes$Properties|null)}
             */
            NodeDescriptor.prototype.attrs = null;

            /**
             * NodeDescriptor locality.
             * @type {(cockroach.roachpb.Locality$Properties|null)}
             */
            NodeDescriptor.prototype.locality = null;

            /**
             * Creates a new NodeDescriptor instance using the specified properties.
             * @param {cockroach.roachpb.NodeDescriptor$Properties=} [properties] Properties to set
             * @returns {cockroach.roachpb.NodeDescriptor} NodeDescriptor instance
             */
            NodeDescriptor.create = function create(properties) {
                return new NodeDescriptor(properties);
            };

            /**
             * Encodes the specified NodeDescriptor message. Does not implicitly {@link cockroach.roachpb.NodeDescriptor.verify|verify} messages.
             * @param {cockroach.roachpb.NodeDescriptor$Properties} message NodeDescriptor message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            NodeDescriptor.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.node_id != null && message.hasOwnProperty("node_id"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.node_id);
                if (message.address != null && message.hasOwnProperty("address"))
                    $root.cockroach.util.UnresolvedAddr.encode(message.address, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.attrs != null && message.hasOwnProperty("attrs"))
                    $root.cockroach.roachpb.Attributes.encode(message.attrs, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.locality != null && message.hasOwnProperty("locality"))
                    $root.cockroach.roachpb.Locality.encode(message.locality, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified NodeDescriptor message, length delimited. Does not implicitly {@link cockroach.roachpb.NodeDescriptor.verify|verify} messages.
             * @param {cockroach.roachpb.NodeDescriptor$Properties} message NodeDescriptor message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            NodeDescriptor.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a NodeDescriptor message from the specified reader or buffer.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {cockroach.roachpb.NodeDescriptor} NodeDescriptor
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            NodeDescriptor.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.cockroach.roachpb.NodeDescriptor();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.node_id = reader.int32();
                        break;
                    case 2:
                        message.address = $root.cockroach.util.UnresolvedAddr.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.attrs = $root.cockroach.roachpb.Attributes.decode(reader, reader.uint32());
                        break;
                    case 4:
                        message.locality = $root.cockroach.roachpb.Locality.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a NodeDescriptor message from the specified reader or buffer, length delimited.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {cockroach.roachpb.NodeDescriptor} NodeDescriptor
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            NodeDescriptor.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a NodeDescriptor message.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            NodeDescriptor.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.node_id != null && message.hasOwnProperty("node_id"))
                    if (!$util.isInteger(message.node_id))
                        return "node_id: integer expected";
                if (message.address != null && message.hasOwnProperty("address")) {
                    let error = $root.cockroach.util.UnresolvedAddr.verify(message.address);
                    if (error)
                        return "address." + error;
                }
                if (message.attrs != null && message.hasOwnProperty("attrs")) {
                    let error = $root.cockroach.roachpb.Attributes.verify(message.attrs);
                    if (error)
                        return "attrs." + error;
                }
                if (message.locality != null && message.hasOwnProperty("locality")) {
                    let error = $root.cockroach.roachpb.Locality.verify(message.locality);
                    if (error)
                        return "locality." + error;
                }
                return null;
            };

            /**
             * Creates a NodeDescriptor message from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {cockroach.roachpb.NodeDescriptor} NodeDescriptor
             */
            NodeDescriptor.fromObject = function fromObject(object) {
                if (object instanceof $root.cockroach.roachpb.NodeDescriptor)
                    return object;
                let message = new $root.cockroach.roachpb.NodeDescriptor();
                if (object.node_id != null)
                    message.node_id = object.node_id | 0;
                if (object.address != null) {
                    if (typeof object.address !== "object")
                        throw TypeError(".cockroach.roachpb.NodeDescriptor.address: object expected");
                    message.address = $root.cockroach.util.UnresolvedAddr.fromObject(object.address);
                }
                if (object.attrs != null) {
                    if (typeof object.attrs !== "object")
                        throw TypeError(".cockroach.roachpb.NodeDescriptor.attrs: object expected");
                    message.attrs = $root.cockroach.roachpb.Attributes.fromObject(object.attrs);
                }
                if (object.locality != null) {
                    if (typeof object.locality !== "object")
                        throw TypeError(".cockroach.roachpb.NodeDescriptor.locality: object expected");
                    message.locality = $root.cockroach.roachpb.Locality.fromObject(object.locality);
                }
                return message;
            };

            /**
             * Creates a NodeDescriptor message from a plain object. Also converts values to their respective internal types.
             * This is an alias of {@link cockroach.roachpb.NodeDescriptor.fromObject}.
             * @function
             * @param {Object.<string,*>} object Plain object
             * @returns {cockroach.roachpb.NodeDescriptor} NodeDescriptor
             */
            NodeDescriptor.from = NodeDescriptor.fromObject;

            /**
             * Creates a plain object from a NodeDescriptor message. Also converts values to other types if specified.
             * @param {cockroach.roachpb.NodeDescriptor} message NodeDescriptor
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            NodeDescriptor.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.node_id = 0;
                    object.address = null;
                    object.attrs = null;
                    object.locality = null;
                }
                if (message.node_id != null && message.hasOwnProperty("node_id"))
                    object.node_id = message.node_id;
                if (message.address != null && message.hasOwnProperty("address"))
                    object.address = $root.cockroach.util.UnresolvedAddr.toObject(message.address, options);
                if (message.attrs != null && message.hasOwnProperty("attrs"))
                    object.attrs = $root.cockroach.roachpb.Attributes.toObject(message.attrs, options);
                if (message.locality != null && message.hasOwnProperty("locality"))
                    object.locality = $root.cockroach.roachpb.Locality.toObject(message.locality, options);
                return object;
            };

            /**
             * Creates a plain object from this NodeDescriptor message. Also converts values to other types if specified.
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            NodeDescriptor.prototype.toObject = function toObject(options) {
                return this.constructor.toObject(this, options);
            };

            /**
             * Converts this NodeDescriptor to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            NodeDescriptor.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return NodeDescriptor;
        })();

        roachpb.StoreDescriptor = (function() {

            /**
             * Properties of a StoreDescriptor.
             * @typedef cockroach.roachpb.StoreDescriptor$Properties
             * @type {Object}
             * @property {number} [store_id] StoreDescriptor store_id.
             * @property {cockroach.roachpb.Attributes$Properties} [attrs] StoreDescriptor attrs.
             * @property {cockroach.roachpb.NodeDescriptor$Properties} [node] StoreDescriptor node.
             * @property {cockroach.roachpb.StoreCapacity$Properties} [capacity] StoreDescriptor capacity.
             */

            /**
             * Constructs a new StoreDescriptor.
             * @exports cockroach.roachpb.StoreDescriptor
             * @constructor
             * @param {cockroach.roachpb.StoreDescriptor$Properties=} [properties] Properties to set
             */
            function StoreDescriptor(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * StoreDescriptor store_id.
             * @type {number}
             */
            StoreDescriptor.prototype.store_id = 0;

            /**
             * StoreDescriptor attrs.
             * @type {(cockroach.roachpb.Attributes$Properties|null)}
             */
            StoreDescriptor.prototype.attrs = null;

            /**
             * StoreDescriptor node.
             * @type {(cockroach.roachpb.NodeDescriptor$Properties|null)}
             */
            StoreDescriptor.prototype.node = null;

            /**
             * StoreDescriptor capacity.
             * @type {(cockroach.roachpb.StoreCapacity$Properties|null)}
             */
            StoreDescriptor.prototype.capacity = null;

            /**
             * Creates a new StoreDescriptor instance using the specified properties.
             * @param {cockroach.roachpb.StoreDescriptor$Properties=} [properties] Properties to set
             * @returns {cockroach.roachpb.StoreDescriptor} StoreDescriptor instance
             */
            StoreDescriptor.create = function create(properties) {
                return new StoreDescriptor(properties);
            };

            /**
             * Encodes the specified StoreDescriptor message. Does not implicitly {@link cockroach.roachpb.StoreDescriptor.verify|verify} messages.
             * @param {cockroach.roachpb.StoreDescriptor$Properties} message StoreDescriptor message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            StoreDescriptor.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.store_id != null && message.hasOwnProperty("store_id"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.store_id);
                if (message.attrs != null && message.hasOwnProperty("attrs"))
                    $root.cockroach.roachpb.Attributes.encode(message.attrs, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.node != null && message.hasOwnProperty("node"))
                    $root.cockroach.roachpb.NodeDescriptor.encode(message.node, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.capacity != null && message.hasOwnProperty("capacity"))
                    $root.cockroach.roachpb.StoreCapacity.encode(message.capacity, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified StoreDescriptor message, length delimited. Does not implicitly {@link cockroach.roachpb.StoreDescriptor.verify|verify} messages.
             * @param {cockroach.roachpb.StoreDescriptor$Properties} message StoreDescriptor message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            StoreDescriptor.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a StoreDescriptor message from the specified reader or buffer.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {cockroach.roachpb.StoreDescriptor} StoreDescriptor
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            StoreDescriptor.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.cockroach.roachpb.StoreDescriptor();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.store_id = reader.int32();
                        break;
                    case 2:
                        message.attrs = $root.cockroach.roachpb.Attributes.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.node = $root.cockroach.roachpb.NodeDescriptor.decode(reader, reader.uint32());
                        break;
                    case 4:
                        message.capacity = $root.cockroach.roachpb.StoreCapacity.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a StoreDescriptor message from the specified reader or buffer, length delimited.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {cockroach.roachpb.StoreDescriptor} StoreDescriptor
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            StoreDescriptor.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a StoreDescriptor message.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            StoreDescriptor.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.store_id != null && message.hasOwnProperty("store_id"))
                    if (!$util.isInteger(message.store_id))
                        return "store_id: integer expected";
                if (message.attrs != null && message.hasOwnProperty("attrs")) {
                    let error = $root.cockroach.roachpb.Attributes.verify(message.attrs);
                    if (error)
                        return "attrs." + error;
                }
                if (message.node != null && message.hasOwnProperty("node")) {
                    let error = $root.cockroach.roachpb.NodeDescriptor.verify(message.node);
                    if (error)
                        return "node." + error;
                }
                if (message.capacity != null && message.hasOwnProperty("capacity")) {
                    let error = $root.cockroach.roachpb.StoreCapacity.verify(message.capacity);
                    if (error)
                        return "capacity." + error;
                }
                return null;
            };

            /**
             * Creates a StoreDescriptor message from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {cockroach.roachpb.StoreDescriptor} StoreDescriptor
             */
            StoreDescriptor.fromObject = function fromObject(object) {
                if (object instanceof $root.cockroach.roachpb.StoreDescriptor)
                    return object;
                let message = new $root.cockroach.roachpb.StoreDescriptor();
                if (object.store_id != null)
                    message.store_id = object.store_id | 0;
                if (object.attrs != null) {
                    if (typeof object.attrs !== "object")
                        throw TypeError(".cockroach.roachpb.StoreDescriptor.attrs: object expected");
                    message.attrs = $root.cockroach.roachpb.Attributes.fromObject(object.attrs);
                }
                if (object.node != null) {
                    if (typeof object.node !== "object")
                        throw TypeError(".cockroach.roachpb.StoreDescriptor.node: object expected");
                    message.node = $root.cockroach.roachpb.NodeDescriptor.fromObject(object.node);
                }
                if (object.capacity != null) {
                    if (typeof object.capacity !== "object")
                        throw TypeError(".cockroach.roachpb.StoreDescriptor.capacity: object expected");
                    message.capacity = $root.cockroach.roachpb.StoreCapacity.fromObject(object.capacity);
                }
                return message;
            };

            /**
             * Creates a StoreDescriptor message from a plain object. Also converts values to their respective internal types.
             * This is an alias of {@link cockroach.roachpb.StoreDescriptor.fromObject}.
             * @function
             * @param {Object.<string,*>} object Plain object
             * @returns {cockroach.roachpb.StoreDescriptor} StoreDescriptor
             */
            StoreDescriptor.from = StoreDescriptor.fromObject;

            /**
             * Creates a plain object from a StoreDescriptor message. Also converts values to other types if specified.
             * @param {cockroach.roachpb.StoreDescriptor} message StoreDescriptor
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            StoreDescriptor.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.store_id = 0;
                    object.attrs = null;
                    object.node = null;
                    object.capacity = null;
                }
                if (message.store_id != null && message.hasOwnProperty("store_id"))
                    object.store_id = message.store_id;
                if (message.attrs != null && message.hasOwnProperty("attrs"))
                    object.attrs = $root.cockroach.roachpb.Attributes.toObject(message.attrs, options);
                if (message.node != null && message.hasOwnProperty("node"))
                    object.node = $root.cockroach.roachpb.NodeDescriptor.toObject(message.node, options);
                if (message.capacity != null && message.hasOwnProperty("capacity"))
                    object.capacity = $root.cockroach.roachpb.StoreCapacity.toObject(message.capacity, options);
                return object;
            };

            /**
             * Creates a plain object from this StoreDescriptor message. Also converts values to other types if specified.
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            StoreDescriptor.prototype.toObject = function toObject(options) {
                return this.constructor.toObject(this, options);
            };

            /**
             * Converts this StoreDescriptor to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            StoreDescriptor.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return StoreDescriptor;
        })();

        roachpb.StoreDeadReplicas = (function() {

            /**
             * Properties of a StoreDeadReplicas.
             * @typedef cockroach.roachpb.StoreDeadReplicas$Properties
             * @type {Object}
             * @property {number} [store_id] StoreDeadReplicas store_id.
             * @property {Array.<cockroach.roachpb.ReplicaIdent$Properties>} [replicas] StoreDeadReplicas replicas.
             */

            /**
             * Constructs a new StoreDeadReplicas.
             * @exports cockroach.roachpb.StoreDeadReplicas
             * @constructor
             * @param {cockroach.roachpb.StoreDeadReplicas$Properties=} [properties] Properties to set
             */
            function StoreDeadReplicas(properties) {
                this.replicas = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * StoreDeadReplicas store_id.
             * @type {number}
             */
            StoreDeadReplicas.prototype.store_id = 0;

            /**
             * StoreDeadReplicas replicas.
             * @type {Array.<cockroach.roachpb.ReplicaIdent$Properties>}
             */
            StoreDeadReplicas.prototype.replicas = $util.emptyArray;

            /**
             * Creates a new StoreDeadReplicas instance using the specified properties.
             * @param {cockroach.roachpb.StoreDeadReplicas$Properties=} [properties] Properties to set
             * @returns {cockroach.roachpb.StoreDeadReplicas} StoreDeadReplicas instance
             */
            StoreDeadReplicas.create = function create(properties) {
                return new StoreDeadReplicas(properties);
            };

            /**
             * Encodes the specified StoreDeadReplicas message. Does not implicitly {@link cockroach.roachpb.StoreDeadReplicas.verify|verify} messages.
             * @param {cockroach.roachpb.StoreDeadReplicas$Properties} message StoreDeadReplicas message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            StoreDeadReplicas.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.store_id != null && message.hasOwnProperty("store_id"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.store_id);
                if (message.replicas != null && message.replicas.length)
                    for (let i = 0; i < message.replicas.length; ++i)
                        $root.cockroach.roachpb.ReplicaIdent.encode(message.replicas[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified StoreDeadReplicas message, length delimited. Does not implicitly {@link cockroach.roachpb.StoreDeadReplicas.verify|verify} messages.
             * @param {cockroach.roachpb.StoreDeadReplicas$Properties} message StoreDeadReplicas message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            StoreDeadReplicas.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a StoreDeadReplicas message from the specified reader or buffer.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {cockroach.roachpb.StoreDeadReplicas} StoreDeadReplicas
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            StoreDeadReplicas.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.cockroach.roachpb.StoreDeadReplicas();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.store_id = reader.int32();
                        break;
                    case 2:
                        if (!(message.replicas && message.replicas.length))
                            message.replicas = [];
                        message.replicas.push($root.cockroach.roachpb.ReplicaIdent.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a StoreDeadReplicas message from the specified reader or buffer, length delimited.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {cockroach.roachpb.StoreDeadReplicas} StoreDeadReplicas
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            StoreDeadReplicas.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a StoreDeadReplicas message.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            StoreDeadReplicas.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.store_id != null && message.hasOwnProperty("store_id"))
                    if (!$util.isInteger(message.store_id))
                        return "store_id: integer expected";
                if (message.replicas != null && message.hasOwnProperty("replicas")) {
                    if (!Array.isArray(message.replicas))
                        return "replicas: array expected";
                    for (let i = 0; i < message.replicas.length; ++i) {
                        let error = $root.cockroach.roachpb.ReplicaIdent.verify(message.replicas[i]);
                        if (error)
                            return "replicas." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a StoreDeadReplicas message from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {cockroach.roachpb.StoreDeadReplicas} StoreDeadReplicas
             */
            StoreDeadReplicas.fromObject = function fromObject(object) {
                if (object instanceof $root.cockroach.roachpb.StoreDeadReplicas)
                    return object;
                let message = new $root.cockroach.roachpb.StoreDeadReplicas();
                if (object.store_id != null)
                    message.store_id = object.store_id | 0;
                if (object.replicas) {
                    if (!Array.isArray(object.replicas))
                        throw TypeError(".cockroach.roachpb.StoreDeadReplicas.replicas: array expected");
                    message.replicas = [];
                    for (let i = 0; i < object.replicas.length; ++i) {
                        if (typeof object.replicas[i] !== "object")
                            throw TypeError(".cockroach.roachpb.StoreDeadReplicas.replicas: object expected");
                        message.replicas[i] = $root.cockroach.roachpb.ReplicaIdent.fromObject(object.replicas[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a StoreDeadReplicas message from a plain object. Also converts values to their respective internal types.
             * This is an alias of {@link cockroach.roachpb.StoreDeadReplicas.fromObject}.
             * @function
             * @param {Object.<string,*>} object Plain object
             * @returns {cockroach.roachpb.StoreDeadReplicas} StoreDeadReplicas
             */
            StoreDeadReplicas.from = StoreDeadReplicas.fromObject;

            /**
             * Creates a plain object from a StoreDeadReplicas message. Also converts values to other types if specified.
             * @param {cockroach.roachpb.StoreDeadReplicas} message StoreDeadReplicas
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            StoreDeadReplicas.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.replicas = [];
                if (options.defaults)
                    object.store_id = 0;
                if (message.store_id != null && message.hasOwnProperty("store_id"))
                    object.store_id = message.store_id;
                if (message.replicas && message.replicas.length) {
                    object.replicas = [];
                    for (let j = 0; j < message.replicas.length; ++j)
                        object.replicas[j] = $root.cockroach.roachpb.ReplicaIdent.toObject(message.replicas[j], options);
                }
                return object;
            };

            /**
             * Creates a plain object from this StoreDeadReplicas message. Also converts values to other types if specified.
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            StoreDeadReplicas.prototype.toObject = function toObject(options) {
                return this.constructor.toObject(this, options);
            };

            /**
             * Converts this StoreDeadReplicas to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            StoreDeadReplicas.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return StoreDeadReplicas;
        })();

        roachpb.Locality = (function() {

            /**
             * Properties of a Locality.
             * @typedef cockroach.roachpb.Locality$Properties
             * @type {Object}
             * @property {Array.<cockroach.roachpb.Tier$Properties>} [tiers] Locality tiers.
             */

            /**
             * Constructs a new Locality.
             * @exports cockroach.roachpb.Locality
             * @constructor
             * @param {cockroach.roachpb.Locality$Properties=} [properties] Properties to set
             */
            function Locality(properties) {
                this.tiers = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Locality tiers.
             * @type {Array.<cockroach.roachpb.Tier$Properties>}
             */
            Locality.prototype.tiers = $util.emptyArray;

            /**
             * Creates a new Locality instance using the specified properties.
             * @param {cockroach.roachpb.Locality$Properties=} [properties] Properties to set
             * @returns {cockroach.roachpb.Locality} Locality instance
             */
            Locality.create = function create(properties) {
                return new Locality(properties);
            };

            /**
             * Encodes the specified Locality message. Does not implicitly {@link cockroach.roachpb.Locality.verify|verify} messages.
             * @param {cockroach.roachpb.Locality$Properties} message Locality message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Locality.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.tiers != null && message.tiers.length)
                    for (let i = 0; i < message.tiers.length; ++i)
                        $root.cockroach.roachpb.Tier.encode(message.tiers[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified Locality message, length delimited. Does not implicitly {@link cockroach.roachpb.Locality.verify|verify} messages.
             * @param {cockroach.roachpb.Locality$Properties} message Locality message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Locality.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Locality message from the specified reader or buffer.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {cockroach.roachpb.Locality} Locality
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Locality.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.cockroach.roachpb.Locality();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.tiers && message.tiers.length))
                            message.tiers = [];
                        message.tiers.push($root.cockroach.roachpb.Tier.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Locality message from the specified reader or buffer, length delimited.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {cockroach.roachpb.Locality} Locality
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Locality.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Locality message.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            Locality.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.tiers != null && message.hasOwnProperty("tiers")) {
                    if (!Array.isArray(message.tiers))
                        return "tiers: array expected";
                    for (let i = 0; i < message.tiers.length; ++i) {
                        let error = $root.cockroach.roachpb.Tier.verify(message.tiers[i]);
                        if (error)
                            return "tiers." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a Locality message from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {cockroach.roachpb.Locality} Locality
             */
            Locality.fromObject = function fromObject(object) {
                if (object instanceof $root.cockroach.roachpb.Locality)
                    return object;
                let message = new $root.cockroach.roachpb.Locality();
                if (object.tiers) {
                    if (!Array.isArray(object.tiers))
                        throw TypeError(".cockroach.roachpb.Locality.tiers: array expected");
                    message.tiers = [];
                    for (let i = 0; i < object.tiers.length; ++i) {
                        if (typeof object.tiers[i] !== "object")
                            throw TypeError(".cockroach.roachpb.Locality.tiers: object expected");
                        message.tiers[i] = $root.cockroach.roachpb.Tier.fromObject(object.tiers[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a Locality message from a plain object. Also converts values to their respective internal types.
             * This is an alias of {@link cockroach.roachpb.Locality.fromObject}.
             * @function
             * @param {Object.<string,*>} object Plain object
             * @returns {cockroach.roachpb.Locality} Locality
             */
            Locality.from = Locality.fromObject;

            /**
             * Creates a plain object from a Locality message. Also converts values to other types if specified.
             * @param {cockroach.roachpb.Locality} message Locality
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Locality.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.tiers = [];
                if (message.tiers && message.tiers.length) {
                    object.tiers = [];
                    for (let j = 0; j < message.tiers.length; ++j)
                        object.tiers[j] = $root.cockroach.roachpb.Tier.toObject(message.tiers[j], options);
                }
                return object;
            };

            /**
             * Creates a plain object from this Locality message. Also converts values to other types if specified.
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Locality.prototype.toObject = function toObject(options) {
                return this.constructor.toObject(this, options);
            };

            /**
             * Converts this Locality to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            Locality.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return Locality;
        })();

        roachpb.Tier = (function() {

            /**
             * Properties of a Tier.
             * @typedef cockroach.roachpb.Tier$Properties
             * @type {Object}
             * @property {string} [key] Tier key.
             * @property {string} [value] Tier value.
             */

            /**
             * Constructs a new Tier.
             * @exports cockroach.roachpb.Tier
             * @constructor
             * @param {cockroach.roachpb.Tier$Properties=} [properties] Properties to set
             */
            function Tier(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Tier key.
             * @type {string}
             */
            Tier.prototype.key = "";

            /**
             * Tier value.
             * @type {string}
             */
            Tier.prototype.value = "";

            /**
             * Creates a new Tier instance using the specified properties.
             * @param {cockroach.roachpb.Tier$Properties=} [properties] Properties to set
             * @returns {cockroach.roachpb.Tier} Tier instance
             */
            Tier.create = function create(properties) {
                return new Tier(properties);
            };

            /**
             * Encodes the specified Tier message. Does not implicitly {@link cockroach.roachpb.Tier.verify|verify} messages.
             * @param {cockroach.roachpb.Tier$Properties} message Tier message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Tier.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.key != null && message.hasOwnProperty("key"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.key);
                if (message.value != null && message.hasOwnProperty("value"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.value);
                return writer;
            };

            /**
             * Encodes the specified Tier message, length delimited. Does not implicitly {@link cockroach.roachpb.Tier.verify|verify} messages.
             * @param {cockroach.roachpb.Tier$Properties} message Tier message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Tier.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Tier message from the specified reader or buffer.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {cockroach.roachpb.Tier} Tier
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Tier.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.cockroach.roachpb.Tier();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.key = reader.string();
                        break;
                    case 2:
                        message.value = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Tier message from the specified reader or buffer, length delimited.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {cockroach.roachpb.Tier} Tier
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Tier.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Tier message.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            Tier.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.key != null && message.hasOwnProperty("key"))
                    if (!$util.isString(message.key))
                        return "key: string expected";
                if (message.value != null && message.hasOwnProperty("value"))
                    if (!$util.isString(message.value))
                        return "value: string expected";
                return null;
            };

            /**
             * Creates a Tier message from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {cockroach.roachpb.Tier} Tier
             */
            Tier.fromObject = function fromObject(object) {
                if (object instanceof $root.cockroach.roachpb.Tier)
                    return object;
                let message = new $root.cockroach.roachpb.Tier();
                if (object.key != null)
                    message.key = String(object.key);
                if (object.value != null)
                    message.value = String(object.value);
                return message;
            };

            /**
             * Creates a Tier message from a plain object. Also converts values to their respective internal types.
             * This is an alias of {@link cockroach.roachpb.Tier.fromObject}.
             * @function
             * @param {Object.<string,*>} object Plain object
             * @returns {cockroach.roachpb.Tier} Tier
             */
            Tier.from = Tier.fromObject;

            /**
             * Creates a plain object from a Tier message. Also converts values to other types if specified.
             * @param {cockroach.roachpb.Tier} message Tier
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Tier.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.key = "";
                    object.value = "";
                }
                if (message.key != null && message.hasOwnProperty("key"))
                    object.key = message.key;
                if (message.value != null && message.hasOwnProperty("value"))
                    object.value = message.value;
                return object;
            };

            /**
             * Creates a plain object from this Tier message. Also converts values to other types if specified.
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Tier.prototype.toObject = function toObject(options) {
                return this.constructor.toObject(this, options);
            };

            /**
             * Converts this Tier to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            Tier.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return Tier;
        })();

        roachpb.RaftTruncatedState = (function() {

            /**
             * Properties of a RaftTruncatedState.
             * @typedef cockroach.roachpb.RaftTruncatedState$Properties
             * @type {Object}
             * @property {Long} [index] RaftTruncatedState index.
             * @property {Long} [term] RaftTruncatedState term.
             */

            /**
             * Constructs a new RaftTruncatedState.
             * @exports cockroach.roachpb.RaftTruncatedState
             * @constructor
             * @param {cockroach.roachpb.RaftTruncatedState$Properties=} [properties] Properties to set
             */
            function RaftTruncatedState(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * RaftTruncatedState index.
             * @type {Long}
             */
            RaftTruncatedState.prototype.index = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * RaftTruncatedState term.
             * @type {Long}
             */
            RaftTruncatedState.prototype.term = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * Creates a new RaftTruncatedState instance using the specified properties.
             * @param {cockroach.roachpb.RaftTruncatedState$Properties=} [properties] Properties to set
             * @returns {cockroach.roachpb.RaftTruncatedState} RaftTruncatedState instance
             */
            RaftTruncatedState.create = function create(properties) {
                return new RaftTruncatedState(properties);
            };

            /**
             * Encodes the specified RaftTruncatedState message. Does not implicitly {@link cockroach.roachpb.RaftTruncatedState.verify|verify} messages.
             * @param {cockroach.roachpb.RaftTruncatedState$Properties} message RaftTruncatedState message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RaftTruncatedState.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.index != null && message.hasOwnProperty("index"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.index);
                if (message.term != null && message.hasOwnProperty("term"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.term);
                return writer;
            };

            /**
             * Encodes the specified RaftTruncatedState message, length delimited. Does not implicitly {@link cockroach.roachpb.RaftTruncatedState.verify|verify} messages.
             * @param {cockroach.roachpb.RaftTruncatedState$Properties} message RaftTruncatedState message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RaftTruncatedState.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a RaftTruncatedState message from the specified reader or buffer.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {cockroach.roachpb.RaftTruncatedState} RaftTruncatedState
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RaftTruncatedState.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.cockroach.roachpb.RaftTruncatedState();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.index = reader.uint64();
                        break;
                    case 2:
                        message.term = reader.uint64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a RaftTruncatedState message from the specified reader or buffer, length delimited.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {cockroach.roachpb.RaftTruncatedState} RaftTruncatedState
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RaftTruncatedState.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a RaftTruncatedState message.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            RaftTruncatedState.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.index != null && message.hasOwnProperty("index"))
                    if (!$util.isInteger(message.index) && !(message.index && $util.isInteger(message.index.low) && $util.isInteger(message.index.high)))
                        return "index: integer|Long expected";
                if (message.term != null && message.hasOwnProperty("term"))
                    if (!$util.isInteger(message.term) && !(message.term && $util.isInteger(message.term.low) && $util.isInteger(message.term.high)))
                        return "term: integer|Long expected";
                return null;
            };

            /**
             * Creates a RaftTruncatedState message from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {cockroach.roachpb.RaftTruncatedState} RaftTruncatedState
             */
            RaftTruncatedState.fromObject = function fromObject(object) {
                if (object instanceof $root.cockroach.roachpb.RaftTruncatedState)
                    return object;
                let message = new $root.cockroach.roachpb.RaftTruncatedState();
                if (object.index != null)
                    if ($util.Long)
                        (message.index = $util.Long.fromValue(object.index)).unsigned = true;
                    else if (typeof object.index === "string")
                        message.index = parseInt(object.index, 10);
                    else if (typeof object.index === "number")
                        message.index = object.index;
                    else if (typeof object.index === "object")
                        message.index = new $util.LongBits(object.index.low >>> 0, object.index.high >>> 0).toNumber(true);
                if (object.term != null)
                    if ($util.Long)
                        (message.term = $util.Long.fromValue(object.term)).unsigned = true;
                    else if (typeof object.term === "string")
                        message.term = parseInt(object.term, 10);
                    else if (typeof object.term === "number")
                        message.term = object.term;
                    else if (typeof object.term === "object")
                        message.term = new $util.LongBits(object.term.low >>> 0, object.term.high >>> 0).toNumber(true);
                return message;
            };

            /**
             * Creates a RaftTruncatedState message from a plain object. Also converts values to their respective internal types.
             * This is an alias of {@link cockroach.roachpb.RaftTruncatedState.fromObject}.
             * @function
             * @param {Object.<string,*>} object Plain object
             * @returns {cockroach.roachpb.RaftTruncatedState} RaftTruncatedState
             */
            RaftTruncatedState.from = RaftTruncatedState.fromObject;

            /**
             * Creates a plain object from a RaftTruncatedState message. Also converts values to other types if specified.
             * @param {cockroach.roachpb.RaftTruncatedState} message RaftTruncatedState
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            RaftTruncatedState.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.index = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.index = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.term = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.term = options.longs === String ? "0" : 0;
                }
                if (message.index != null && message.hasOwnProperty("index"))
                    if (typeof message.index === "number")
                        object.index = options.longs === String ? String(message.index) : message.index;
                    else
                        object.index = options.longs === String ? $util.Long.prototype.toString.call(message.index) : options.longs === Number ? new $util.LongBits(message.index.low >>> 0, message.index.high >>> 0).toNumber(true) : message.index;
                if (message.term != null && message.hasOwnProperty("term"))
                    if (typeof message.term === "number")
                        object.term = options.longs === String ? String(message.term) : message.term;
                    else
                        object.term = options.longs === String ? $util.Long.prototype.toString.call(message.term) : options.longs === Number ? new $util.LongBits(message.term.low >>> 0, message.term.high >>> 0).toNumber(true) : message.term;
                return object;
            };

            /**
             * Creates a plain object from this RaftTruncatedState message. Also converts values to other types if specified.
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            RaftTruncatedState.prototype.toObject = function toObject(options) {
                return this.constructor.toObject(this, options);
            };

            /**
             * Converts this RaftTruncatedState to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            RaftTruncatedState.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return RaftTruncatedState;
        })();

        roachpb.RaftTombstone = (function() {

            /**
             * Properties of a RaftTombstone.
             * @typedef cockroach.roachpb.RaftTombstone$Properties
             * @type {Object}
             * @property {number} [next_replica_id] RaftTombstone next_replica_id.
             */

            /**
             * Constructs a new RaftTombstone.
             * @exports cockroach.roachpb.RaftTombstone
             * @constructor
             * @param {cockroach.roachpb.RaftTombstone$Properties=} [properties] Properties to set
             */
            function RaftTombstone(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * RaftTombstone next_replica_id.
             * @type {number}
             */
            RaftTombstone.prototype.next_replica_id = 0;

            /**
             * Creates a new RaftTombstone instance using the specified properties.
             * @param {cockroach.roachpb.RaftTombstone$Properties=} [properties] Properties to set
             * @returns {cockroach.roachpb.RaftTombstone} RaftTombstone instance
             */
            RaftTombstone.create = function create(properties) {
                return new RaftTombstone(properties);
            };

            /**
             * Encodes the specified RaftTombstone message. Does not implicitly {@link cockroach.roachpb.RaftTombstone.verify|verify} messages.
             * @param {cockroach.roachpb.RaftTombstone$Properties} message RaftTombstone message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RaftTombstone.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.next_replica_id != null && message.hasOwnProperty("next_replica_id"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.next_replica_id);
                return writer;
            };

            /**
             * Encodes the specified RaftTombstone message, length delimited. Does not implicitly {@link cockroach.roachpb.RaftTombstone.verify|verify} messages.
             * @param {cockroach.roachpb.RaftTombstone$Properties} message RaftTombstone message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RaftTombstone.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a RaftTombstone message from the specified reader or buffer.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {cockroach.roachpb.RaftTombstone} RaftTombstone
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RaftTombstone.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.cockroach.roachpb.RaftTombstone();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.next_replica_id = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a RaftTombstone message from the specified reader or buffer, length delimited.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {cockroach.roachpb.RaftTombstone} RaftTombstone
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RaftTombstone.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a RaftTombstone message.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            RaftTombstone.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.next_replica_id != null && message.hasOwnProperty("next_replica_id"))
                    if (!$util.isInteger(message.next_replica_id))
                        return "next_replica_id: integer expected";
                return null;
            };

            /**
             * Creates a RaftTombstone message from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {cockroach.roachpb.RaftTombstone} RaftTombstone
             */
            RaftTombstone.fromObject = function fromObject(object) {
                if (object instanceof $root.cockroach.roachpb.RaftTombstone)
                    return object;
                let message = new $root.cockroach.roachpb.RaftTombstone();
                if (object.next_replica_id != null)
                    message.next_replica_id = object.next_replica_id | 0;
                return message;
            };

            /**
             * Creates a RaftTombstone message from a plain object. Also converts values to their respective internal types.
             * This is an alias of {@link cockroach.roachpb.RaftTombstone.fromObject}.
             * @function
             * @param {Object.<string,*>} object Plain object
             * @returns {cockroach.roachpb.RaftTombstone} RaftTombstone
             */
            RaftTombstone.from = RaftTombstone.fromObject;

            /**
             * Creates a plain object from a RaftTombstone message. Also converts values to other types if specified.
             * @param {cockroach.roachpb.RaftTombstone} message RaftTombstone
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            RaftTombstone.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    object.next_replica_id = 0;
                if (message.next_replica_id != null && message.hasOwnProperty("next_replica_id"))
                    object.next_replica_id = message.next_replica_id;
                return object;
            };

            /**
             * Creates a plain object from this RaftTombstone message. Also converts values to other types if specified.
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            RaftTombstone.prototype.toObject = function toObject(options) {
                return this.constructor.toObject(this, options);
            };

            /**
             * Converts this RaftTombstone to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            RaftTombstone.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return RaftTombstone;
        })();

        roachpb.RaftSnapshotData = (function() {

            /**
             * Properties of a RaftSnapshotData.
             * @typedef cockroach.roachpb.RaftSnapshotData$Properties
             * @type {Object}
             * @property {cockroach.roachpb.RangeDescriptor$Properties} [range_descriptor] RaftSnapshotData range_descriptor.
             * @property {Array.<cockroach.roachpb.RaftSnapshotData.KeyValue$Properties>} [KV] RaftSnapshotData KV.
             * @property {Array.<Uint8Array>} [log_entries] RaftSnapshotData log_entries.
             */

            /**
             * Constructs a new RaftSnapshotData.
             * @exports cockroach.roachpb.RaftSnapshotData
             * @constructor
             * @param {cockroach.roachpb.RaftSnapshotData$Properties=} [properties] Properties to set
             */
            function RaftSnapshotData(properties) {
                this.KV = [];
                this.log_entries = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * RaftSnapshotData range_descriptor.
             * @type {(cockroach.roachpb.RangeDescriptor$Properties|null)}
             */
            RaftSnapshotData.prototype.range_descriptor = null;

            /**
             * RaftSnapshotData KV.
             * @type {Array.<cockroach.roachpb.RaftSnapshotData.KeyValue$Properties>}
             */
            RaftSnapshotData.prototype.KV = $util.emptyArray;

            /**
             * RaftSnapshotData log_entries.
             * @type {Array.<Uint8Array>}
             */
            RaftSnapshotData.prototype.log_entries = $util.emptyArray;

            /**
             * Creates a new RaftSnapshotData instance using the specified properties.
             * @param {cockroach.roachpb.RaftSnapshotData$Properties=} [properties] Properties to set
             * @returns {cockroach.roachpb.RaftSnapshotData} RaftSnapshotData instance
             */
            RaftSnapshotData.create = function create(properties) {
                return new RaftSnapshotData(properties);
            };

            /**
             * Encodes the specified RaftSnapshotData message. Does not implicitly {@link cockroach.roachpb.RaftSnapshotData.verify|verify} messages.
             * @param {cockroach.roachpb.RaftSnapshotData$Properties} message RaftSnapshotData message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RaftSnapshotData.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.range_descriptor != null && message.hasOwnProperty("range_descriptor"))
                    $root.cockroach.roachpb.RangeDescriptor.encode(message.range_descriptor, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.KV != null && message.KV.length)
                    for (let i = 0; i < message.KV.length; ++i)
                        $root.cockroach.roachpb.RaftSnapshotData.KeyValue.encode(message.KV[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.log_entries != null && message.log_entries.length)
                    for (let i = 0; i < message.log_entries.length; ++i)
                        writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.log_entries[i]);
                return writer;
            };

            /**
             * Encodes the specified RaftSnapshotData message, length delimited. Does not implicitly {@link cockroach.roachpb.RaftSnapshotData.verify|verify} messages.
             * @param {cockroach.roachpb.RaftSnapshotData$Properties} message RaftSnapshotData message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RaftSnapshotData.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a RaftSnapshotData message from the specified reader or buffer.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {cockroach.roachpb.RaftSnapshotData} RaftSnapshotData
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RaftSnapshotData.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.cockroach.roachpb.RaftSnapshotData();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.range_descriptor = $root.cockroach.roachpb.RangeDescriptor.decode(reader, reader.uint32());
                        break;
                    case 2:
                        if (!(message.KV && message.KV.length))
                            message.KV = [];
                        message.KV.push($root.cockroach.roachpb.RaftSnapshotData.KeyValue.decode(reader, reader.uint32()));
                        break;
                    case 3:
                        if (!(message.log_entries && message.log_entries.length))
                            message.log_entries = [];
                        message.log_entries.push(reader.bytes());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a RaftSnapshotData message from the specified reader or buffer, length delimited.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {cockroach.roachpb.RaftSnapshotData} RaftSnapshotData
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RaftSnapshotData.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a RaftSnapshotData message.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            RaftSnapshotData.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.range_descriptor != null && message.hasOwnProperty("range_descriptor")) {
                    let error = $root.cockroach.roachpb.RangeDescriptor.verify(message.range_descriptor);
                    if (error)
                        return "range_descriptor." + error;
                }
                if (message.KV != null && message.hasOwnProperty("KV")) {
                    if (!Array.isArray(message.KV))
                        return "KV: array expected";
                    for (let i = 0; i < message.KV.length; ++i) {
                        let error = $root.cockroach.roachpb.RaftSnapshotData.KeyValue.verify(message.KV[i]);
                        if (error)
                            return "KV." + error;
                    }
                }
                if (message.log_entries != null && message.hasOwnProperty("log_entries")) {
                    if (!Array.isArray(message.log_entries))
                        return "log_entries: array expected";
                    for (let i = 0; i < message.log_entries.length; ++i)
                        if (!(message.log_entries[i] && typeof message.log_entries[i].length === "number" || $util.isString(message.log_entries[i])))
                            return "log_entries: buffer[] expected";
                }
                return null;
            };

            /**
             * Creates a RaftSnapshotData message from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {cockroach.roachpb.RaftSnapshotData} RaftSnapshotData
             */
            RaftSnapshotData.fromObject = function fromObject(object) {
                if (object instanceof $root.cockroach.roachpb.RaftSnapshotData)
                    return object;
                let message = new $root.cockroach.roachpb.RaftSnapshotData();
                if (object.range_descriptor != null) {
                    if (typeof object.range_descriptor !== "object")
                        throw TypeError(".cockroach.roachpb.RaftSnapshotData.range_descriptor: object expected");
                    message.range_descriptor = $root.cockroach.roachpb.RangeDescriptor.fromObject(object.range_descriptor);
                }
                if (object.KV) {
                    if (!Array.isArray(object.KV))
                        throw TypeError(".cockroach.roachpb.RaftSnapshotData.KV: array expected");
                    message.KV = [];
                    for (let i = 0; i < object.KV.length; ++i) {
                        if (typeof object.KV[i] !== "object")
                            throw TypeError(".cockroach.roachpb.RaftSnapshotData.KV: object expected");
                        message.KV[i] = $root.cockroach.roachpb.RaftSnapshotData.KeyValue.fromObject(object.KV[i]);
                    }
                }
                if (object.log_entries) {
                    if (!Array.isArray(object.log_entries))
                        throw TypeError(".cockroach.roachpb.RaftSnapshotData.log_entries: array expected");
                    message.log_entries = [];
                    for (let i = 0; i < object.log_entries.length; ++i)
                        if (typeof object.log_entries[i] === "string")
                            $util.base64.decode(object.log_entries[i], message.log_entries[i] = $util.newBuffer($util.base64.length(object.log_entries[i])), 0);
                        else if (object.log_entries[i].length)
                            message.log_entries[i] = object.log_entries[i];
                }
                return message;
            };

            /**
             * Creates a RaftSnapshotData message from a plain object. Also converts values to their respective internal types.
             * This is an alias of {@link cockroach.roachpb.RaftSnapshotData.fromObject}.
             * @function
             * @param {Object.<string,*>} object Plain object
             * @returns {cockroach.roachpb.RaftSnapshotData} RaftSnapshotData
             */
            RaftSnapshotData.from = RaftSnapshotData.fromObject;

            /**
             * Creates a plain object from a RaftSnapshotData message. Also converts values to other types if specified.
             * @param {cockroach.roachpb.RaftSnapshotData} message RaftSnapshotData
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            RaftSnapshotData.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults) {
                    object.KV = [];
                    object.log_entries = [];
                }
                if (options.defaults)
                    object.range_descriptor = null;
                if (message.range_descriptor != null && message.hasOwnProperty("range_descriptor"))
                    object.range_descriptor = $root.cockroach.roachpb.RangeDescriptor.toObject(message.range_descriptor, options);
                if (message.KV && message.KV.length) {
                    object.KV = [];
                    for (let j = 0; j < message.KV.length; ++j)
                        object.KV[j] = $root.cockroach.roachpb.RaftSnapshotData.KeyValue.toObject(message.KV[j], options);
                }
                if (message.log_entries && message.log_entries.length) {
                    object.log_entries = [];
                    for (let j = 0; j < message.log_entries.length; ++j)
                        object.log_entries[j] = options.bytes === String ? $util.base64.encode(message.log_entries[j], 0, message.log_entries[j].length) : options.bytes === Array ? Array.prototype.slice.call(message.log_entries[j]) : message.log_entries[j];
                }
                return object;
            };

            /**
             * Creates a plain object from this RaftSnapshotData message. Also converts values to other types if specified.
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            RaftSnapshotData.prototype.toObject = function toObject(options) {
                return this.constructor.toObject(this, options);
            };

            /**
             * Converts this RaftSnapshotData to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            RaftSnapshotData.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            RaftSnapshotData.KeyValue = (function() {

                /**
                 * Properties of a KeyValue.
                 * @typedef cockroach.roachpb.RaftSnapshotData.KeyValue$Properties
                 * @type {Object}
                 * @property {Uint8Array} [key] KeyValue key.
                 * @property {Uint8Array} [value] KeyValue value.
                 * @property {cockroach.util.hlc.Timestamp$Properties} [timestamp] KeyValue timestamp.
                 */

                /**
                 * Constructs a new KeyValue.
                 * @exports cockroach.roachpb.RaftSnapshotData.KeyValue
                 * @constructor
                 * @param {cockroach.roachpb.RaftSnapshotData.KeyValue$Properties=} [properties] Properties to set
                 */
                function KeyValue(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * KeyValue key.
                 * @type {Uint8Array}
                 */
                KeyValue.prototype.key = $util.newBuffer([]);

                /**
                 * KeyValue value.
                 * @type {Uint8Array}
                 */
                KeyValue.prototype.value = $util.newBuffer([]);

                /**
                 * KeyValue timestamp.
                 * @type {(cockroach.util.hlc.Timestamp$Properties|null)}
                 */
                KeyValue.prototype.timestamp = null;

                /**
                 * Creates a new KeyValue instance using the specified properties.
                 * @param {cockroach.roachpb.RaftSnapshotData.KeyValue$Properties=} [properties] Properties to set
                 * @returns {cockroach.roachpb.RaftSnapshotData.KeyValue} KeyValue instance
                 */
                KeyValue.create = function create(properties) {
                    return new KeyValue(properties);
                };

                /**
                 * Encodes the specified KeyValue message. Does not implicitly {@link cockroach.roachpb.RaftSnapshotData.KeyValue.verify|verify} messages.
                 * @param {cockroach.roachpb.RaftSnapshotData.KeyValue$Properties} message KeyValue message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                KeyValue.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.key != null && message.hasOwnProperty("key"))
                        writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.key);
                    if (message.value != null && message.hasOwnProperty("value"))
                        writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.value);
                    if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                        $root.cockroach.util.hlc.Timestamp.encode(message.timestamp, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified KeyValue message, length delimited. Does not implicitly {@link cockroach.roachpb.RaftSnapshotData.KeyValue.verify|verify} messages.
                 * @param {cockroach.roachpb.RaftSnapshotData.KeyValue$Properties} message KeyValue message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                KeyValue.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a KeyValue message from the specified reader or buffer.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {cockroach.roachpb.RaftSnapshotData.KeyValue} KeyValue
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                KeyValue.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.cockroach.roachpb.RaftSnapshotData.KeyValue();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.key = reader.bytes();
                            break;
                        case 2:
                            message.value = reader.bytes();
                            break;
                        case 3:
                            message.timestamp = $root.cockroach.util.hlc.Timestamp.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a KeyValue message from the specified reader or buffer, length delimited.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {cockroach.roachpb.RaftSnapshotData.KeyValue} KeyValue
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                KeyValue.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a KeyValue message.
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {?string} `null` if valid, otherwise the reason why it is not
                 */
                KeyValue.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.key != null && message.hasOwnProperty("key"))
                        if (!(message.key && typeof message.key.length === "number" || $util.isString(message.key)))
                            return "key: buffer expected";
                    if (message.value != null && message.hasOwnProperty("value"))
                        if (!(message.value && typeof message.value.length === "number" || $util.isString(message.value)))
                            return "value: buffer expected";
                    if (message.timestamp != null && message.hasOwnProperty("timestamp")) {
                        let error = $root.cockroach.util.hlc.Timestamp.verify(message.timestamp);
                        if (error)
                            return "timestamp." + error;
                    }
                    return null;
                };

                /**
                 * Creates a KeyValue message from a plain object. Also converts values to their respective internal types.
                 * @param {Object.<string,*>} object Plain object
                 * @returns {cockroach.roachpb.RaftSnapshotData.KeyValue} KeyValue
                 */
                KeyValue.fromObject = function fromObject(object) {
                    if (object instanceof $root.cockroach.roachpb.RaftSnapshotData.KeyValue)
                        return object;
                    let message = new $root.cockroach.roachpb.RaftSnapshotData.KeyValue();
                    if (object.key != null)
                        if (typeof object.key === "string")
                            $util.base64.decode(object.key, message.key = $util.newBuffer($util.base64.length(object.key)), 0);
                        else if (object.key.length)
                            message.key = object.key;
                    if (object.value != null)
                        if (typeof object.value === "string")
                            $util.base64.decode(object.value, message.value = $util.newBuffer($util.base64.length(object.value)), 0);
                        else if (object.value.length)
                            message.value = object.value;
                    if (object.timestamp != null) {
                        if (typeof object.timestamp !== "object")
                            throw TypeError(".cockroach.roachpb.RaftSnapshotData.KeyValue.timestamp: object expected");
                        message.timestamp = $root.cockroach.util.hlc.Timestamp.fromObject(object.timestamp);
                    }
                    return message;
                };

                /**
                 * Creates a KeyValue message from a plain object. Also converts values to their respective internal types.
                 * This is an alias of {@link cockroach.roachpb.RaftSnapshotData.KeyValue.fromObject}.
                 * @function
                 * @param {Object.<string,*>} object Plain object
                 * @returns {cockroach.roachpb.RaftSnapshotData.KeyValue} KeyValue
                 */
                KeyValue.from = KeyValue.fromObject;

                /**
                 * Creates a plain object from a KeyValue message. Also converts values to other types if specified.
                 * @param {cockroach.roachpb.RaftSnapshotData.KeyValue} message KeyValue
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                KeyValue.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.key = options.bytes === String ? "" : [];
                        object.value = options.bytes === String ? "" : [];
                        object.timestamp = null;
                    }
                    if (message.key != null && message.hasOwnProperty("key"))
                        object.key = options.bytes === String ? $util.base64.encode(message.key, 0, message.key.length) : options.bytes === Array ? Array.prototype.slice.call(message.key) : message.key;
                    if (message.value != null && message.hasOwnProperty("value"))
                        object.value = options.bytes === String ? $util.base64.encode(message.value, 0, message.value.length) : options.bytes === Array ? Array.prototype.slice.call(message.value) : message.value;
                    if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                        object.timestamp = $root.cockroach.util.hlc.Timestamp.toObject(message.timestamp, options);
                    return object;
                };

                /**
                 * Creates a plain object from this KeyValue message. Also converts values to other types if specified.
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                KeyValue.prototype.toObject = function toObject(options) {
                    return this.constructor.toObject(this, options);
                };

                /**
                 * Converts this KeyValue to JSON.
                 * @returns {Object.<string,*>} JSON object
                 */
                KeyValue.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return KeyValue;
            })();

            return RaftSnapshotData;
        })();

        return roachpb;
    })();

    cockroach.util = (function() {

        /**
         * Namespace util.
         * @exports cockroach.util
         * @namespace
         */
        const util = {};

        util.UnresolvedAddr = (function() {

            /**
             * Properties of an UnresolvedAddr.
             * @typedef cockroach.util.UnresolvedAddr$Properties
             * @type {Object}
             * @property {string} [network_field] UnresolvedAddr network_field.
             * @property {string} [address_field] UnresolvedAddr address_field.
             */

            /**
             * Constructs a new UnresolvedAddr.
             * @exports cockroach.util.UnresolvedAddr
             * @constructor
             * @param {cockroach.util.UnresolvedAddr$Properties=} [properties] Properties to set
             */
            function UnresolvedAddr(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * UnresolvedAddr network_field.
             * @type {string}
             */
            UnresolvedAddr.prototype.network_field = "";

            /**
             * UnresolvedAddr address_field.
             * @type {string}
             */
            UnresolvedAddr.prototype.address_field = "";

            /**
             * Creates a new UnresolvedAddr instance using the specified properties.
             * @param {cockroach.util.UnresolvedAddr$Properties=} [properties] Properties to set
             * @returns {cockroach.util.UnresolvedAddr} UnresolvedAddr instance
             */
            UnresolvedAddr.create = function create(properties) {
                return new UnresolvedAddr(properties);
            };

            /**
             * Encodes the specified UnresolvedAddr message. Does not implicitly {@link cockroach.util.UnresolvedAddr.verify|verify} messages.
             * @param {cockroach.util.UnresolvedAddr$Properties} message UnresolvedAddr message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            UnresolvedAddr.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.network_field != null && message.hasOwnProperty("network_field"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.network_field);
                if (message.address_field != null && message.hasOwnProperty("address_field"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.address_field);
                return writer;
            };

            /**
             * Encodes the specified UnresolvedAddr message, length delimited. Does not implicitly {@link cockroach.util.UnresolvedAddr.verify|verify} messages.
             * @param {cockroach.util.UnresolvedAddr$Properties} message UnresolvedAddr message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            UnresolvedAddr.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an UnresolvedAddr message from the specified reader or buffer.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {cockroach.util.UnresolvedAddr} UnresolvedAddr
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            UnresolvedAddr.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.cockroach.util.UnresolvedAddr();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.network_field = reader.string();
                        break;
                    case 2:
                        message.address_field = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an UnresolvedAddr message from the specified reader or buffer, length delimited.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {cockroach.util.UnresolvedAddr} UnresolvedAddr
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            UnresolvedAddr.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an UnresolvedAddr message.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            UnresolvedAddr.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.network_field != null && message.hasOwnProperty("network_field"))
                    if (!$util.isString(message.network_field))
                        return "network_field: string expected";
                if (message.address_field != null && message.hasOwnProperty("address_field"))
                    if (!$util.isString(message.address_field))
                        return "address_field: string expected";
                return null;
            };

            /**
             * Creates an UnresolvedAddr message from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {cockroach.util.UnresolvedAddr} UnresolvedAddr
             */
            UnresolvedAddr.fromObject = function fromObject(object) {
                if (object instanceof $root.cockroach.util.UnresolvedAddr)
                    return object;
                let message = new $root.cockroach.util.UnresolvedAddr();
                if (object.network_field != null)
                    message.network_field = String(object.network_field);
                if (object.address_field != null)
                    message.address_field = String(object.address_field);
                return message;
            };

            /**
             * Creates an UnresolvedAddr message from a plain object. Also converts values to their respective internal types.
             * This is an alias of {@link cockroach.util.UnresolvedAddr.fromObject}.
             * @function
             * @param {Object.<string,*>} object Plain object
             * @returns {cockroach.util.UnresolvedAddr} UnresolvedAddr
             */
            UnresolvedAddr.from = UnresolvedAddr.fromObject;

            /**
             * Creates a plain object from an UnresolvedAddr message. Also converts values to other types if specified.
             * @param {cockroach.util.UnresolvedAddr} message UnresolvedAddr
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            UnresolvedAddr.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.network_field = "";
                    object.address_field = "";
                }
                if (message.network_field != null && message.hasOwnProperty("network_field"))
                    object.network_field = message.network_field;
                if (message.address_field != null && message.hasOwnProperty("address_field"))
                    object.address_field = message.address_field;
                return object;
            };

            /**
             * Creates a plain object from this UnresolvedAddr message. Also converts values to other types if specified.
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            UnresolvedAddr.prototype.toObject = function toObject(options) {
                return this.constructor.toObject(this, options);
            };

            /**
             * Converts this UnresolvedAddr to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            UnresolvedAddr.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return UnresolvedAddr;
        })();

        util.hlc = (function() {

            /**
             * Namespace hlc.
             * @exports cockroach.util.hlc
             * @namespace
             */
            const hlc = {};

            hlc.Timestamp = (function() {

                /**
                 * Properties of a Timestamp.
                 * @typedef cockroach.util.hlc.Timestamp$Properties
                 * @type {Object}
                 * @property {Long} [wall_time] Timestamp wall_time.
                 * @property {number} [logical] Timestamp logical.
                 */

                /**
                 * Constructs a new Timestamp.
                 * @exports cockroach.util.hlc.Timestamp
                 * @constructor
                 * @param {cockroach.util.hlc.Timestamp$Properties=} [properties] Properties to set
                 */
                function Timestamp(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Timestamp wall_time.
                 * @type {Long}
                 */
                Timestamp.prototype.wall_time = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

                /**
                 * Timestamp logical.
                 * @type {number}
                 */
                Timestamp.prototype.logical = 0;

                /**
                 * Creates a new Timestamp instance using the specified properties.
                 * @param {cockroach.util.hlc.Timestamp$Properties=} [properties] Properties to set
                 * @returns {cockroach.util.hlc.Timestamp} Timestamp instance
                 */
                Timestamp.create = function create(properties) {
                    return new Timestamp(properties);
                };

                /**
                 * Encodes the specified Timestamp message. Does not implicitly {@link cockroach.util.hlc.Timestamp.verify|verify} messages.
                 * @param {cockroach.util.hlc.Timestamp$Properties} message Timestamp message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Timestamp.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.wall_time != null && message.hasOwnProperty("wall_time"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int64(message.wall_time);
                    if (message.logical != null && message.hasOwnProperty("logical"))
                        writer.uint32(/* id 2, wireType 0 =*/16).int32(message.logical);
                    return writer;
                };

                /**
                 * Encodes the specified Timestamp message, length delimited. Does not implicitly {@link cockroach.util.hlc.Timestamp.verify|verify} messages.
                 * @param {cockroach.util.hlc.Timestamp$Properties} message Timestamp message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Timestamp.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a Timestamp message from the specified reader or buffer.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {cockroach.util.hlc.Timestamp} Timestamp
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Timestamp.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.cockroach.util.hlc.Timestamp();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.wall_time = reader.int64();
                            break;
                        case 2:
                            message.logical = reader.int32();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a Timestamp message from the specified reader or buffer, length delimited.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {cockroach.util.hlc.Timestamp} Timestamp
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Timestamp.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a Timestamp message.
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {?string} `null` if valid, otherwise the reason why it is not
                 */
                Timestamp.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.wall_time != null && message.hasOwnProperty("wall_time"))
                        if (!$util.isInteger(message.wall_time) && !(message.wall_time && $util.isInteger(message.wall_time.low) && $util.isInteger(message.wall_time.high)))
                            return "wall_time: integer|Long expected";
                    if (message.logical != null && message.hasOwnProperty("logical"))
                        if (!$util.isInteger(message.logical))
                            return "logical: integer expected";
                    return null;
                };

                /**
                 * Creates a Timestamp message from a plain object. Also converts values to their respective internal types.
                 * @param {Object.<string,*>} object Plain object
                 * @returns {cockroach.util.hlc.Timestamp} Timestamp
                 */
                Timestamp.fromObject = function fromObject(object) {
                    if (object instanceof $root.cockroach.util.hlc.Timestamp)
                        return object;
                    let message = new $root.cockroach.util.hlc.Timestamp();
                    if (object.wall_time != null)
                        if ($util.Long)
                            (message.wall_time = $util.Long.fromValue(object.wall_time)).unsigned = false;
                        else if (typeof object.wall_time === "string")
                            message.wall_time = parseInt(object.wall_time, 10);
                        else if (typeof object.wall_time === "number")
                            message.wall_time = object.wall_time;
                        else if (typeof object.wall_time === "object")
                            message.wall_time = new $util.LongBits(object.wall_time.low >>> 0, object.wall_time.high >>> 0).toNumber();
                    if (object.logical != null)
                        message.logical = object.logical | 0;
                    return message;
                };

                /**
                 * Creates a Timestamp message from a plain object. Also converts values to their respective internal types.
                 * This is an alias of {@link cockroach.util.hlc.Timestamp.fromObject}.
                 * @function
                 * @param {Object.<string,*>} object Plain object
                 * @returns {cockroach.util.hlc.Timestamp} Timestamp
                 */
                Timestamp.from = Timestamp.fromObject;

                /**
                 * Creates a plain object from a Timestamp message. Also converts values to other types if specified.
                 * @param {cockroach.util.hlc.Timestamp} message Timestamp
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Timestamp.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        if ($util.Long) {
                            let long = new $util.Long(0, 0, false);
                            object.wall_time = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.wall_time = options.longs === String ? "0" : 0;
                        object.logical = 0;
                    }
                    if (message.wall_time != null && message.hasOwnProperty("wall_time"))
                        if (typeof message.wall_time === "number")
                            object.wall_time = options.longs === String ? String(message.wall_time) : message.wall_time;
                        else
                            object.wall_time = options.longs === String ? $util.Long.prototype.toString.call(message.wall_time) : options.longs === Number ? new $util.LongBits(message.wall_time.low >>> 0, message.wall_time.high >>> 0).toNumber() : message.wall_time;
                    if (message.logical != null && message.hasOwnProperty("logical"))
                        object.logical = message.logical;
                    return object;
                };

                /**
                 * Creates a plain object from this Timestamp message. Also converts values to other types if specified.
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Timestamp.prototype.toObject = function toObject(options) {
                    return this.constructor.toObject(this, options);
                };

                /**
                 * Converts this Timestamp to JSON.
                 * @returns {Object.<string,*>} JSON object
                 */
                Timestamp.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return Timestamp;
            })();

            return hlc;
        })();

        util.log = (function() {

            /**
             * Namespace log.
             * @exports cockroach.util.log
             * @namespace
             */
            const log = {};

            /**
             * Severity enum.
             * @name Severity
             * @memberof cockroach.util.log
             * @enum {number}
             * @property {number} UNKNOWN=0 UNKNOWN value
             * @property {number} INFO=1 INFO value
             * @property {number} WARNING=2 WARNING value
             * @property {number} ERROR=3 ERROR value
             * @property {number} FATAL=4 FATAL value
             * @property {number} NONE=5 NONE value
             * @property {number} DEFAULT=6 DEFAULT value
             */
            log.Severity = (function() {
                const valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "UNKNOWN"] = 0;
                values[valuesById[1] = "INFO"] = 1;
                values[valuesById[2] = "WARNING"] = 2;
                values[valuesById[3] = "ERROR"] = 3;
                values[valuesById[4] = "FATAL"] = 4;
                values[valuesById[5] = "NONE"] = 5;
                values[valuesById[6] = "DEFAULT"] = 6;
                return values;
            })();

            log.Entry = (function() {

                /**
                 * Properties of an Entry.
                 * @typedef cockroach.util.log.Entry$Properties
                 * @type {Object}
                 * @property {cockroach.util.log.Severity} [severity] Entry severity.
                 * @property {Long} [time] Entry time.
                 * @property {Long} [goroutine] Entry goroutine.
                 * @property {string} [file] Entry file.
                 * @property {Long} [line] Entry line.
                 * @property {string} [message] Entry message.
                 */

                /**
                 * Constructs a new Entry.
                 * @exports cockroach.util.log.Entry
                 * @constructor
                 * @param {cockroach.util.log.Entry$Properties=} [properties] Properties to set
                 */
                function Entry(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Entry severity.
                 * @type {cockroach.util.log.Severity}
                 */
                Entry.prototype.severity = 0;

                /**
                 * Entry time.
                 * @type {Long}
                 */
                Entry.prototype.time = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

                /**
                 * Entry goroutine.
                 * @type {Long}
                 */
                Entry.prototype.goroutine = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

                /**
                 * Entry file.
                 * @type {string}
                 */
                Entry.prototype.file = "";

                /**
                 * Entry line.
                 * @type {Long}
                 */
                Entry.prototype.line = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

                /**
                 * Entry message.
                 * @type {string}
                 */
                Entry.prototype.message = "";

                /**
                 * Creates a new Entry instance using the specified properties.
                 * @param {cockroach.util.log.Entry$Properties=} [properties] Properties to set
                 * @returns {cockroach.util.log.Entry} Entry instance
                 */
                Entry.create = function create(properties) {
                    return new Entry(properties);
                };

                /**
                 * Encodes the specified Entry message. Does not implicitly {@link cockroach.util.log.Entry.verify|verify} messages.
                 * @param {cockroach.util.log.Entry$Properties} message Entry message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Entry.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.severity != null && message.hasOwnProperty("severity"))
                        writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.severity);
                    if (message.time != null && message.hasOwnProperty("time"))
                        writer.uint32(/* id 2, wireType 0 =*/16).int64(message.time);
                    if (message.file != null && message.hasOwnProperty("file"))
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.file);
                    if (message.line != null && message.hasOwnProperty("line"))
                        writer.uint32(/* id 4, wireType 0 =*/32).int64(message.line);
                    if (message.message != null && message.hasOwnProperty("message"))
                        writer.uint32(/* id 5, wireType 2 =*/42).string(message.message);
                    if (message.goroutine != null && message.hasOwnProperty("goroutine"))
                        writer.uint32(/* id 6, wireType 0 =*/48).int64(message.goroutine);
                    return writer;
                };

                /**
                 * Encodes the specified Entry message, length delimited. Does not implicitly {@link cockroach.util.log.Entry.verify|verify} messages.
                 * @param {cockroach.util.log.Entry$Properties} message Entry message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Entry.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes an Entry message from the specified reader or buffer.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {cockroach.util.log.Entry} Entry
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Entry.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.cockroach.util.log.Entry();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.severity = reader.uint32();
                            break;
                        case 2:
                            message.time = reader.int64();
                            break;
                        case 6:
                            message.goroutine = reader.int64();
                            break;
                        case 3:
                            message.file = reader.string();
                            break;
                        case 4:
                            message.line = reader.int64();
                            break;
                        case 5:
                            message.message = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes an Entry message from the specified reader or buffer, length delimited.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {cockroach.util.log.Entry} Entry
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Entry.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies an Entry message.
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {?string} `null` if valid, otherwise the reason why it is not
                 */
                Entry.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.severity != null && message.hasOwnProperty("severity"))
                        switch (message.severity) {
                        default:
                            return "severity: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                        case 4:
                        case 5:
                        case 6:
                            break;
                        }
                    if (message.time != null && message.hasOwnProperty("time"))
                        if (!$util.isInteger(message.time) && !(message.time && $util.isInteger(message.time.low) && $util.isInteger(message.time.high)))
                            return "time: integer|Long expected";
                    if (message.goroutine != null && message.hasOwnProperty("goroutine"))
                        if (!$util.isInteger(message.goroutine) && !(message.goroutine && $util.isInteger(message.goroutine.low) && $util.isInteger(message.goroutine.high)))
                            return "goroutine: integer|Long expected";
                    if (message.file != null && message.hasOwnProperty("file"))
                        if (!$util.isString(message.file))
                            return "file: string expected";
                    if (message.line != null && message.hasOwnProperty("line"))
                        if (!$util.isInteger(message.line) && !(message.line && $util.isInteger(message.line.low) && $util.isInteger(message.line.high)))
                            return "line: integer|Long expected";
                    if (message.message != null && message.hasOwnProperty("message"))
                        if (!$util.isString(message.message))
                            return "message: string expected";
                    return null;
                };

                /**
                 * Creates an Entry message from a plain object. Also converts values to their respective internal types.
                 * @param {Object.<string,*>} object Plain object
                 * @returns {cockroach.util.log.Entry} Entry
                 */
                Entry.fromObject = function fromObject(object) {
                    if (object instanceof $root.cockroach.util.log.Entry)
                        return object;
                    let message = new $root.cockroach.util.log.Entry();
                    switch (object.severity) {
                    case "UNKNOWN":
                    case 0:
                        message.severity = 0;
                        break;
                    case "INFO":
                    case 1:
                        message.severity = 1;
                        break;
                    case "WARNING":
                    case 2:
                        message.severity = 2;
                        break;
                    case "ERROR":
                    case 3:
                        message.severity = 3;
                        break;
                    case "FATAL":
                    case 4:
                        message.severity = 4;
                        break;
                    case "NONE":
                    case 5:
                        message.severity = 5;
                        break;
                    case "DEFAULT":
                    case 6:
                        message.severity = 6;
                        break;
                    }
                    if (object.time != null)
                        if ($util.Long)
                            (message.time = $util.Long.fromValue(object.time)).unsigned = false;
                        else if (typeof object.time === "string")
                            message.time = parseInt(object.time, 10);
                        else if (typeof object.time === "number")
                            message.time = object.time;
                        else if (typeof object.time === "object")
                            message.time = new $util.LongBits(object.time.low >>> 0, object.time.high >>> 0).toNumber();
                    if (object.goroutine != null)
                        if ($util.Long)
                            (message.goroutine = $util.Long.fromValue(object.goroutine)).unsigned = false;
                        else if (typeof object.goroutine === "string")
                            message.goroutine = parseInt(object.goroutine, 10);
                        else if (typeof object.goroutine === "number")
                            message.goroutine = object.goroutine;
                        else if (typeof object.goroutine === "object")
                            message.goroutine = new $util.LongBits(object.goroutine.low >>> 0, object.goroutine.high >>> 0).toNumber();
                    if (object.file != null)
                        message.file = String(object.file);
                    if (object.line != null)
                        if ($util.Long)
                            (message.line = $util.Long.fromValue(object.line)).unsigned = false;
                        else if (typeof object.line === "string")
                            message.line = parseInt(object.line, 10);
                        else if (typeof object.line === "number")
                            message.line = object.line;
                        else if (typeof object.line === "object")
                            message.line = new $util.LongBits(object.line.low >>> 0, object.line.high >>> 0).toNumber();
                    if (object.message != null)
                        message.message = String(object.message);
                    return message;
                };

                /**
                 * Creates an Entry message from a plain object. Also converts values to their respective internal types.
                 * This is an alias of {@link cockroach.util.log.Entry.fromObject}.
                 * @function
                 * @param {Object.<string,*>} object Plain object
                 * @returns {cockroach.util.log.Entry} Entry
                 */
                Entry.from = Entry.fromObject;

                /**
                 * Creates a plain object from an Entry message. Also converts values to other types if specified.
                 * @param {cockroach.util.log.Entry} message Entry
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Entry.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.severity = options.enums === String ? "UNKNOWN" : 0;
                        if ($util.Long) {
                            let long = new $util.Long(0, 0, false);
                            object.time = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.time = options.longs === String ? "0" : 0;
                        object.file = "";
                        if ($util.Long) {
                            let long = new $util.Long(0, 0, false);
                            object.line = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.line = options.longs === String ? "0" : 0;
                        object.message = "";
                        if ($util.Long) {
                            let long = new $util.Long(0, 0, false);
                            object.goroutine = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.goroutine = options.longs === String ? "0" : 0;
                    }
                    if (message.severity != null && message.hasOwnProperty("severity"))
                        object.severity = options.enums === String ? $root.cockroach.util.log.Severity[message.severity] : message.severity;
                    if (message.time != null && message.hasOwnProperty("time"))
                        if (typeof message.time === "number")
                            object.time = options.longs === String ? String(message.time) : message.time;
                        else
                            object.time = options.longs === String ? $util.Long.prototype.toString.call(message.time) : options.longs === Number ? new $util.LongBits(message.time.low >>> 0, message.time.high >>> 0).toNumber() : message.time;
                    if (message.file != null && message.hasOwnProperty("file"))
                        object.file = message.file;
                    if (message.line != null && message.hasOwnProperty("line"))
                        if (typeof message.line === "number")
                            object.line = options.longs === String ? String(message.line) : message.line;
                        else
                            object.line = options.longs === String ? $util.Long.prototype.toString.call(message.line) : options.longs === Number ? new $util.LongBits(message.line.low >>> 0, message.line.high >>> 0).toNumber() : message.line;
                    if (message.message != null && message.hasOwnProperty("message"))
                        object.message = message.message;
                    if (message.goroutine != null && message.hasOwnProperty("goroutine"))
                        if (typeof message.goroutine === "number")
                            object.goroutine = options.longs === String ? String(message.goroutine) : message.goroutine;
                        else
                            object.goroutine = options.longs === String ? $util.Long.prototype.toString.call(message.goroutine) : options.longs === Number ? new $util.LongBits(message.goroutine.low >>> 0, message.goroutine.high >>> 0).toNumber() : message.goroutine;
                    return object;
                };

                /**
                 * Creates a plain object from this Entry message. Also converts values to other types if specified.
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Entry.prototype.toObject = function toObject(options) {
                    return this.constructor.toObject(this, options);
                };

                /**
                 * Converts this Entry to JSON.
                 * @returns {Object.<string,*>} JSON object
                 */
                Entry.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return Entry;
            })();

            log.FileDetails = (function() {

                /**
                 * Properties of a FileDetails.
                 * @typedef cockroach.util.log.FileDetails$Properties
                 * @type {Object}
                 * @property {string} [program] FileDetails program.
                 * @property {string} [host] FileDetails host.
                 * @property {string} [user_name] FileDetails user_name.
                 * @property {cockroach.util.log.Severity} [severity] FileDetails severity.
                 * @property {Long} [time] FileDetails time.
                 * @property {Long} [pid] FileDetails pid.
                 */

                /**
                 * Constructs a new FileDetails.
                 * @exports cockroach.util.log.FileDetails
                 * @constructor
                 * @param {cockroach.util.log.FileDetails$Properties=} [properties] Properties to set
                 */
                function FileDetails(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * FileDetails program.
                 * @type {string}
                 */
                FileDetails.prototype.program = "";

                /**
                 * FileDetails host.
                 * @type {string}
                 */
                FileDetails.prototype.host = "";

                /**
                 * FileDetails user_name.
                 * @type {string}
                 */
                FileDetails.prototype.user_name = "";

                /**
                 * FileDetails severity.
                 * @type {cockroach.util.log.Severity}
                 */
                FileDetails.prototype.severity = 0;

                /**
                 * FileDetails time.
                 * @type {Long}
                 */
                FileDetails.prototype.time = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

                /**
                 * FileDetails pid.
                 * @type {Long}
                 */
                FileDetails.prototype.pid = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

                /**
                 * Creates a new FileDetails instance using the specified properties.
                 * @param {cockroach.util.log.FileDetails$Properties=} [properties] Properties to set
                 * @returns {cockroach.util.log.FileDetails} FileDetails instance
                 */
                FileDetails.create = function create(properties) {
                    return new FileDetails(properties);
                };

                /**
                 * Encodes the specified FileDetails message. Does not implicitly {@link cockroach.util.log.FileDetails.verify|verify} messages.
                 * @param {cockroach.util.log.FileDetails$Properties} message FileDetails message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                FileDetails.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.program != null && message.hasOwnProperty("program"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.program);
                    if (message.host != null && message.hasOwnProperty("host"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.host);
                    if (message.user_name != null && message.hasOwnProperty("user_name"))
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.user_name);
                    if (message.severity != null && message.hasOwnProperty("severity"))
                        writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.severity);
                    if (message.time != null && message.hasOwnProperty("time"))
                        writer.uint32(/* id 5, wireType 0 =*/40).int64(message.time);
                    if (message.pid != null && message.hasOwnProperty("pid"))
                        writer.uint32(/* id 6, wireType 0 =*/48).int64(message.pid);
                    return writer;
                };

                /**
                 * Encodes the specified FileDetails message, length delimited. Does not implicitly {@link cockroach.util.log.FileDetails.verify|verify} messages.
                 * @param {cockroach.util.log.FileDetails$Properties} message FileDetails message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                FileDetails.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a FileDetails message from the specified reader or buffer.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {cockroach.util.log.FileDetails} FileDetails
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                FileDetails.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.cockroach.util.log.FileDetails();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.program = reader.string();
                            break;
                        case 2:
                            message.host = reader.string();
                            break;
                        case 3:
                            message.user_name = reader.string();
                            break;
                        case 4:
                            message.severity = reader.uint32();
                            break;
                        case 5:
                            message.time = reader.int64();
                            break;
                        case 6:
                            message.pid = reader.int64();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a FileDetails message from the specified reader or buffer, length delimited.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {cockroach.util.log.FileDetails} FileDetails
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                FileDetails.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a FileDetails message.
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {?string} `null` if valid, otherwise the reason why it is not
                 */
                FileDetails.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.program != null && message.hasOwnProperty("program"))
                        if (!$util.isString(message.program))
                            return "program: string expected";
                    if (message.host != null && message.hasOwnProperty("host"))
                        if (!$util.isString(message.host))
                            return "host: string expected";
                    if (message.user_name != null && message.hasOwnProperty("user_name"))
                        if (!$util.isString(message.user_name))
                            return "user_name: string expected";
                    if (message.severity != null && message.hasOwnProperty("severity"))
                        switch (message.severity) {
                        default:
                            return "severity: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                        case 4:
                        case 5:
                        case 6:
                            break;
                        }
                    if (message.time != null && message.hasOwnProperty("time"))
                        if (!$util.isInteger(message.time) && !(message.time && $util.isInteger(message.time.low) && $util.isInteger(message.time.high)))
                            return "time: integer|Long expected";
                    if (message.pid != null && message.hasOwnProperty("pid"))
                        if (!$util.isInteger(message.pid) && !(message.pid && $util.isInteger(message.pid.low) && $util.isInteger(message.pid.high)))
                            return "pid: integer|Long expected";
                    return null;
                };

                /**
                 * Creates a FileDetails message from a plain object. Also converts values to their respective internal types.
                 * @param {Object.<string,*>} object Plain object
                 * @returns {cockroach.util.log.FileDetails} FileDetails
                 */
                FileDetails.fromObject = function fromObject(object) {
                    if (object instanceof $root.cockroach.util.log.FileDetails)
                        return object;
                    let message = new $root.cockroach.util.log.FileDetails();
                    if (object.program != null)
                        message.program = String(object.program);
                    if (object.host != null)
                        message.host = String(object.host);
                    if (object.user_name != null)
                        message.user_name = String(object.user_name);
                    switch (object.severity) {
                    case "UNKNOWN":
                    case 0:
                        message.severity = 0;
                        break;
                    case "INFO":
                    case 1:
                        message.severity = 1;
                        break;
                    case "WARNING":
                    case 2:
                        message.severity = 2;
                        break;
                    case "ERROR":
                    case 3:
                        message.severity = 3;
                        break;
                    case "FATAL":
                    case 4:
                        message.severity = 4;
                        break;
                    case "NONE":
                    case 5:
                        message.severity = 5;
                        break;
                    case "DEFAULT":
                    case 6:
                        message.severity = 6;
                        break;
                    }
                    if (object.time != null)
                        if ($util.Long)
                            (message.time = $util.Long.fromValue(object.time)).unsigned = false;
                        else if (typeof object.time === "string")
                            message.time = parseInt(object.time, 10);
                        else if (typeof object.time === "number")
                            message.time = object.time;
                        else if (typeof object.time === "object")
                            message.time = new $util.LongBits(object.time.low >>> 0, object.time.high >>> 0).toNumber();
                    if (object.pid != null)
                        if ($util.Long)
                            (message.pid = $util.Long.fromValue(object.pid)).unsigned = false;
                        else if (typeof object.pid === "string")
                            message.pid = parseInt(object.pid, 10);
                        else if (typeof object.pid === "number")
                            message.pid = object.pid;
                        else if (typeof object.pid === "object")
                            message.pid = new $util.LongBits(object.pid.low >>> 0, object.pid.high >>> 0).toNumber();
                    return message;
                };

                /**
                 * Creates a FileDetails message from a plain object. Also converts values to their respective internal types.
                 * This is an alias of {@link cockroach.util.log.FileDetails.fromObject}.
                 * @function
                 * @param {Object.<string,*>} object Plain object
                 * @returns {cockroach.util.log.FileDetails} FileDetails
                 */
                FileDetails.from = FileDetails.fromObject;

                /**
                 * Creates a plain object from a FileDetails message. Also converts values to other types if specified.
                 * @param {cockroach.util.log.FileDetails} message FileDetails
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                FileDetails.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.program = "";
                        object.host = "";
                        object.user_name = "";
                        object.severity = options.enums === String ? "UNKNOWN" : 0;
                        if ($util.Long) {
                            let long = new $util.Long(0, 0, false);
                            object.time = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.time = options.longs === String ? "0" : 0;
                        if ($util.Long) {
                            let long = new $util.Long(0, 0, false);
                            object.pid = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.pid = options.longs === String ? "0" : 0;
                    }
                    if (message.program != null && message.hasOwnProperty("program"))
                        object.program = message.program;
                    if (message.host != null && message.hasOwnProperty("host"))
                        object.host = message.host;
                    if (message.user_name != null && message.hasOwnProperty("user_name"))
                        object.user_name = message.user_name;
                    if (message.severity != null && message.hasOwnProperty("severity"))
                        object.severity = options.enums === String ? $root.cockroach.util.log.Severity[message.severity] : message.severity;
                    if (message.time != null && message.hasOwnProperty("time"))
                        if (typeof message.time === "number")
                            object.time = options.longs === String ? String(message.time) : message.time;
                        else
                            object.time = options.longs === String ? $util.Long.prototype.toString.call(message.time) : options.longs === Number ? new $util.LongBits(message.time.low >>> 0, message.time.high >>> 0).toNumber() : message.time;
                    if (message.pid != null && message.hasOwnProperty("pid"))
                        if (typeof message.pid === "number")
                            object.pid = options.longs === String ? String(message.pid) : message.pid;
                        else
                            object.pid = options.longs === String ? $util.Long.prototype.toString.call(message.pid) : options.longs === Number ? new $util.LongBits(message.pid.low >>> 0, message.pid.high >>> 0).toNumber() : message.pid;
                    return object;
                };

                /**
                 * Creates a plain object from this FileDetails message. Also converts values to other types if specified.
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                FileDetails.prototype.toObject = function toObject(options) {
                    return this.constructor.toObject(this, options);
                };

                /**
                 * Converts this FileDetails to JSON.
                 * @returns {Object.<string,*>} JSON object
                 */
                FileDetails.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return FileDetails;
            })();

            log.FileInfo = (function() {

                /**
                 * Properties of a FileInfo.
                 * @typedef cockroach.util.log.FileInfo$Properties
                 * @type {Object}
                 * @property {string} [name] FileInfo name.
                 * @property {Long} [size_bytes] FileInfo size_bytes.
                 * @property {Long} [mod_time_nanos] FileInfo mod_time_nanos.
                 * @property {cockroach.util.log.FileDetails$Properties} [details] FileInfo details.
                 */

                /**
                 * Constructs a new FileInfo.
                 * @exports cockroach.util.log.FileInfo
                 * @constructor
                 * @param {cockroach.util.log.FileInfo$Properties=} [properties] Properties to set
                 */
                function FileInfo(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * FileInfo name.
                 * @type {string}
                 */
                FileInfo.prototype.name = "";

                /**
                 * FileInfo size_bytes.
                 * @type {Long}
                 */
                FileInfo.prototype.size_bytes = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

                /**
                 * FileInfo mod_time_nanos.
                 * @type {Long}
                 */
                FileInfo.prototype.mod_time_nanos = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

                /**
                 * FileInfo details.
                 * @type {(cockroach.util.log.FileDetails$Properties|null)}
                 */
                FileInfo.prototype.details = null;

                /**
                 * Creates a new FileInfo instance using the specified properties.
                 * @param {cockroach.util.log.FileInfo$Properties=} [properties] Properties to set
                 * @returns {cockroach.util.log.FileInfo} FileInfo instance
                 */
                FileInfo.create = function create(properties) {
                    return new FileInfo(properties);
                };

                /**
                 * Encodes the specified FileInfo message. Does not implicitly {@link cockroach.util.log.FileInfo.verify|verify} messages.
                 * @param {cockroach.util.log.FileInfo$Properties} message FileInfo message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                FileInfo.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.name != null && message.hasOwnProperty("name"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                    if (message.size_bytes != null && message.hasOwnProperty("size_bytes"))
                        writer.uint32(/* id 2, wireType 0 =*/16).int64(message.size_bytes);
                    if (message.mod_time_nanos != null && message.hasOwnProperty("mod_time_nanos"))
                        writer.uint32(/* id 3, wireType 0 =*/24).int64(message.mod_time_nanos);
                    if (message.details != null && message.hasOwnProperty("details"))
                        $root.cockroach.util.log.FileDetails.encode(message.details, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified FileInfo message, length delimited. Does not implicitly {@link cockroach.util.log.FileInfo.verify|verify} messages.
                 * @param {cockroach.util.log.FileInfo$Properties} message FileInfo message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                FileInfo.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a FileInfo message from the specified reader or buffer.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {cockroach.util.log.FileInfo} FileInfo
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                FileInfo.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.cockroach.util.log.FileInfo();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.name = reader.string();
                            break;
                        case 2:
                            message.size_bytes = reader.int64();
                            break;
                        case 3:
                            message.mod_time_nanos = reader.int64();
                            break;
                        case 4:
                            message.details = $root.cockroach.util.log.FileDetails.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a FileInfo message from the specified reader or buffer, length delimited.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {cockroach.util.log.FileInfo} FileInfo
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                FileInfo.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a FileInfo message.
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {?string} `null` if valid, otherwise the reason why it is not
                 */
                FileInfo.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.name != null && message.hasOwnProperty("name"))
                        if (!$util.isString(message.name))
                            return "name: string expected";
                    if (message.size_bytes != null && message.hasOwnProperty("size_bytes"))
                        if (!$util.isInteger(message.size_bytes) && !(message.size_bytes && $util.isInteger(message.size_bytes.low) && $util.isInteger(message.size_bytes.high)))
                            return "size_bytes: integer|Long expected";
                    if (message.mod_time_nanos != null && message.hasOwnProperty("mod_time_nanos"))
                        if (!$util.isInteger(message.mod_time_nanos) && !(message.mod_time_nanos && $util.isInteger(message.mod_time_nanos.low) && $util.isInteger(message.mod_time_nanos.high)))
                            return "mod_time_nanos: integer|Long expected";
                    if (message.details != null && message.hasOwnProperty("details")) {
                        let error = $root.cockroach.util.log.FileDetails.verify(message.details);
                        if (error)
                            return "details." + error;
                    }
                    return null;
                };

                /**
                 * Creates a FileInfo message from a plain object. Also converts values to their respective internal types.
                 * @param {Object.<string,*>} object Plain object
                 * @returns {cockroach.util.log.FileInfo} FileInfo
                 */
                FileInfo.fromObject = function fromObject(object) {
                    if (object instanceof $root.cockroach.util.log.FileInfo)
                        return object;
                    let message = new $root.cockroach.util.log.FileInfo();
                    if (object.name != null)
                        message.name = String(object.name);
                    if (object.size_bytes != null)
                        if ($util.Long)
                            (message.size_bytes = $util.Long.fromValue(object.size_bytes)).unsigned = false;
                        else if (typeof object.size_bytes === "string")
                            message.size_bytes = parseInt(object.size_bytes, 10);
                        else if (typeof object.size_bytes === "number")
                            message.size_bytes = object.size_bytes;
                        else if (typeof object.size_bytes === "object")
                            message.size_bytes = new $util.LongBits(object.size_bytes.low >>> 0, object.size_bytes.high >>> 0).toNumber();
                    if (object.mod_time_nanos != null)
                        if ($util.Long)
                            (message.mod_time_nanos = $util.Long.fromValue(object.mod_time_nanos)).unsigned = false;
                        else if (typeof object.mod_time_nanos === "string")
                            message.mod_time_nanos = parseInt(object.mod_time_nanos, 10);
                        else if (typeof object.mod_time_nanos === "number")
                            message.mod_time_nanos = object.mod_time_nanos;
                        else if (typeof object.mod_time_nanos === "object")
                            message.mod_time_nanos = new $util.LongBits(object.mod_time_nanos.low >>> 0, object.mod_time_nanos.high >>> 0).toNumber();
                    if (object.details != null) {
                        if (typeof object.details !== "object")
                            throw TypeError(".cockroach.util.log.FileInfo.details: object expected");
                        message.details = $root.cockroach.util.log.FileDetails.fromObject(object.details);
                    }
                    return message;
                };

                /**
                 * Creates a FileInfo message from a plain object. Also converts values to their respective internal types.
                 * This is an alias of {@link cockroach.util.log.FileInfo.fromObject}.
                 * @function
                 * @param {Object.<string,*>} object Plain object
                 * @returns {cockroach.util.log.FileInfo} FileInfo
                 */
                FileInfo.from = FileInfo.fromObject;

                /**
                 * Creates a plain object from a FileInfo message. Also converts values to other types if specified.
                 * @param {cockroach.util.log.FileInfo} message FileInfo
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                FileInfo.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.name = "";
                        if ($util.Long) {
                            let long = new $util.Long(0, 0, false);
                            object.size_bytes = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.size_bytes = options.longs === String ? "0" : 0;
                        if ($util.Long) {
                            let long = new $util.Long(0, 0, false);
                            object.mod_time_nanos = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.mod_time_nanos = options.longs === String ? "0" : 0;
                        object.details = null;
                    }
                    if (message.name != null && message.hasOwnProperty("name"))
                        object.name = message.name;
                    if (message.size_bytes != null && message.hasOwnProperty("size_bytes"))
                        if (typeof message.size_bytes === "number")
                            object.size_bytes = options.longs === String ? String(message.size_bytes) : message.size_bytes;
                        else
                            object.size_bytes = options.longs === String ? $util.Long.prototype.toString.call(message.size_bytes) : options.longs === Number ? new $util.LongBits(message.size_bytes.low >>> 0, message.size_bytes.high >>> 0).toNumber() : message.size_bytes;
                    if (message.mod_time_nanos != null && message.hasOwnProperty("mod_time_nanos"))
                        if (typeof message.mod_time_nanos === "number")
                            object.mod_time_nanos = options.longs === String ? String(message.mod_time_nanos) : message.mod_time_nanos;
                        else
                            object.mod_time_nanos = options.longs === String ? $util.Long.prototype.toString.call(message.mod_time_nanos) : options.longs === Number ? new $util.LongBits(message.mod_time_nanos.low >>> 0, message.mod_time_nanos.high >>> 0).toNumber() : message.mod_time_nanos;
                    if (message.details != null && message.hasOwnProperty("details"))
                        object.details = $root.cockroach.util.log.FileDetails.toObject(message.details, options);
                    return object;
                };

                /**
                 * Creates a plain object from this FileInfo message. Also converts values to other types if specified.
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                FileInfo.prototype.toObject = function toObject(options) {
                    return this.constructor.toObject(this, options);
                };

                /**
                 * Converts this FileInfo to JSON.
                 * @returns {Object.<string,*>} JSON object
                 */
                FileInfo.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return FileInfo;
            })();

            return log;
        })();

        return util;
    })();

    cockroach.storage = (function() {

        /**
         * Namespace storage.
         * @exports cockroach.storage
         * @namespace
         */
        const storage = {};

        storage.engine = (function() {

            /**
             * Namespace engine.
             * @exports cockroach.storage.engine
             * @namespace
             */
            const engine = {};

            engine.enginepb = (function() {

                /**
                 * Namespace enginepb.
                 * @exports cockroach.storage.engine.enginepb
                 * @namespace
                 */
                const enginepb = {};

                /**
                 * IsolationType enum.
                 * @name IsolationType
                 * @memberof cockroach.storage.engine.enginepb
                 * @enum {number}
                 * @property {number} SERIALIZABLE=0 SERIALIZABLE value
                 * @property {number} SNAPSHOT=1 SNAPSHOT value
                 */
                enginepb.IsolationType = (function() {
                    const valuesById = {}, values = Object.create(valuesById);
                    values[valuesById[0] = "SERIALIZABLE"] = 0;
                    values[valuesById[1] = "SNAPSHOT"] = 1;
                    return values;
                })();

                enginepb.TxnMeta = (function() {

                    /**
                     * Properties of a TxnMeta.
                     * @typedef cockroach.storage.engine.enginepb.TxnMeta$Properties
                     * @type {Object}
                     * @property {Uint8Array} [id] TxnMeta id.
                     * @property {cockroach.storage.engine.enginepb.IsolationType} [isolation] TxnMeta isolation.
                     * @property {Uint8Array} [key] TxnMeta key.
                     * @property {number} [epoch] TxnMeta epoch.
                     * @property {cockroach.util.hlc.Timestamp$Properties} [timestamp] TxnMeta timestamp.
                     * @property {number} [priority] TxnMeta priority.
                     * @property {number} [sequence] TxnMeta sequence.
                     * @property {number} [batch_index] TxnMeta batch_index.
                     */

                    /**
                     * Constructs a new TxnMeta.
                     * @exports cockroach.storage.engine.enginepb.TxnMeta
                     * @constructor
                     * @param {cockroach.storage.engine.enginepb.TxnMeta$Properties=} [properties] Properties to set
                     */
                    function TxnMeta(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * TxnMeta id.
                     * @type {Uint8Array}
                     */
                    TxnMeta.prototype.id = $util.newBuffer([]);

                    /**
                     * TxnMeta isolation.
                     * @type {cockroach.storage.engine.enginepb.IsolationType}
                     */
                    TxnMeta.prototype.isolation = 0;

                    /**
                     * TxnMeta key.
                     * @type {Uint8Array}
                     */
                    TxnMeta.prototype.key = $util.newBuffer([]);

                    /**
                     * TxnMeta epoch.
                     * @type {number}
                     */
                    TxnMeta.prototype.epoch = 0;

                    /**
                     * TxnMeta timestamp.
                     * @type {(cockroach.util.hlc.Timestamp$Properties|null)}
                     */
                    TxnMeta.prototype.timestamp = null;

                    /**
                     * TxnMeta priority.
                     * @type {number}
                     */
                    TxnMeta.prototype.priority = 0;

                    /**
                     * TxnMeta sequence.
                     * @type {number}
                     */
                    TxnMeta.prototype.sequence = 0;

                    /**
                     * TxnMeta batch_index.
                     * @type {number}
                     */
                    TxnMeta.prototype.batch_index = 0;

                    /**
                     * Creates a new TxnMeta instance using the specified properties.
                     * @param {cockroach.storage.engine.enginepb.TxnMeta$Properties=} [properties] Properties to set
                     * @returns {cockroach.storage.engine.enginepb.TxnMeta} TxnMeta instance
                     */
                    TxnMeta.create = function create(properties) {
                        return new TxnMeta(properties);
                    };

                    /**
                     * Encodes the specified TxnMeta message. Does not implicitly {@link cockroach.storage.engine.enginepb.TxnMeta.verify|verify} messages.
                     * @param {cockroach.storage.engine.enginepb.TxnMeta$Properties} message TxnMeta message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    TxnMeta.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.id != null && message.hasOwnProperty("id"))
                            writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.id);
                        if (message.isolation != null && message.hasOwnProperty("isolation"))
                            writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.isolation);
                        if (message.key != null && message.hasOwnProperty("key"))
                            writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.key);
                        if (message.epoch != null && message.hasOwnProperty("epoch"))
                            writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.epoch);
                        if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                            $root.cockroach.util.hlc.Timestamp.encode(message.timestamp, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                        if (message.priority != null && message.hasOwnProperty("priority"))
                            writer.uint32(/* id 6, wireType 0 =*/48).int32(message.priority);
                        if (message.sequence != null && message.hasOwnProperty("sequence"))
                            writer.uint32(/* id 7, wireType 0 =*/56).int32(message.sequence);
                        if (message.batch_index != null && message.hasOwnProperty("batch_index"))
                            writer.uint32(/* id 8, wireType 0 =*/64).int32(message.batch_index);
                        return writer;
                    };

                    /**
                     * Encodes the specified TxnMeta message, length delimited. Does not implicitly {@link cockroach.storage.engine.enginepb.TxnMeta.verify|verify} messages.
                     * @param {cockroach.storage.engine.enginepb.TxnMeta$Properties} message TxnMeta message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    TxnMeta.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a TxnMeta message from the specified reader or buffer.
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {cockroach.storage.engine.enginepb.TxnMeta} TxnMeta
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    TxnMeta.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.cockroach.storage.engine.enginepb.TxnMeta();
                        while (reader.pos < end) {
                            let tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.id = reader.bytes();
                                break;
                            case 2:
                                message.isolation = reader.uint32();
                                break;
                            case 3:
                                message.key = reader.bytes();
                                break;
                            case 4:
                                message.epoch = reader.uint32();
                                break;
                            case 5:
                                message.timestamp = $root.cockroach.util.hlc.Timestamp.decode(reader, reader.uint32());
                                break;
                            case 6:
                                message.priority = reader.int32();
                                break;
                            case 7:
                                message.sequence = reader.int32();
                                break;
                            case 8:
                                message.batch_index = reader.int32();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a TxnMeta message from the specified reader or buffer, length delimited.
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {cockroach.storage.engine.enginepb.TxnMeta} TxnMeta
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    TxnMeta.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a TxnMeta message.
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {?string} `null` if valid, otherwise the reason why it is not
                     */
                    TxnMeta.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.id != null && message.hasOwnProperty("id"))
                            if (!(message.id && typeof message.id.length === "number" || $util.isString(message.id)))
                                return "id: buffer expected";
                        if (message.isolation != null && message.hasOwnProperty("isolation"))
                            switch (message.isolation) {
                            default:
                                return "isolation: enum value expected";
                            case 0:
                            case 1:
                                break;
                            }
                        if (message.key != null && message.hasOwnProperty("key"))
                            if (!(message.key && typeof message.key.length === "number" || $util.isString(message.key)))
                                return "key: buffer expected";
                        if (message.epoch != null && message.hasOwnProperty("epoch"))
                            if (!$util.isInteger(message.epoch))
                                return "epoch: integer expected";
                        if (message.timestamp != null && message.hasOwnProperty("timestamp")) {
                            let error = $root.cockroach.util.hlc.Timestamp.verify(message.timestamp);
                            if (error)
                                return "timestamp." + error;
                        }
                        if (message.priority != null && message.hasOwnProperty("priority"))
                            if (!$util.isInteger(message.priority))
                                return "priority: integer expected";
                        if (message.sequence != null && message.hasOwnProperty("sequence"))
                            if (!$util.isInteger(message.sequence))
                                return "sequence: integer expected";
                        if (message.batch_index != null && message.hasOwnProperty("batch_index"))
                            if (!$util.isInteger(message.batch_index))
                                return "batch_index: integer expected";
                        return null;
                    };

                    /**
                     * Creates a TxnMeta message from a plain object. Also converts values to their respective internal types.
                     * @param {Object.<string,*>} object Plain object
                     * @returns {cockroach.storage.engine.enginepb.TxnMeta} TxnMeta
                     */
                    TxnMeta.fromObject = function fromObject(object) {
                        if (object instanceof $root.cockroach.storage.engine.enginepb.TxnMeta)
                            return object;
                        let message = new $root.cockroach.storage.engine.enginepb.TxnMeta();
                        if (object.id != null)
                            if (typeof object.id === "string")
                                $util.base64.decode(object.id, message.id = $util.newBuffer($util.base64.length(object.id)), 0);
                            else if (object.id.length)
                                message.id = object.id;
                        switch (object.isolation) {
                        case "SERIALIZABLE":
                        case 0:
                            message.isolation = 0;
                            break;
                        case "SNAPSHOT":
                        case 1:
                            message.isolation = 1;
                            break;
                        }
                        if (object.key != null)
                            if (typeof object.key === "string")
                                $util.base64.decode(object.key, message.key = $util.newBuffer($util.base64.length(object.key)), 0);
                            else if (object.key.length)
                                message.key = object.key;
                        if (object.epoch != null)
                            message.epoch = object.epoch >>> 0;
                        if (object.timestamp != null) {
                            if (typeof object.timestamp !== "object")
                                throw TypeError(".cockroach.storage.engine.enginepb.TxnMeta.timestamp: object expected");
                            message.timestamp = $root.cockroach.util.hlc.Timestamp.fromObject(object.timestamp);
                        }
                        if (object.priority != null)
                            message.priority = object.priority | 0;
                        if (object.sequence != null)
                            message.sequence = object.sequence | 0;
                        if (object.batch_index != null)
                            message.batch_index = object.batch_index | 0;
                        return message;
                    };

                    /**
                     * Creates a TxnMeta message from a plain object. Also converts values to their respective internal types.
                     * This is an alias of {@link cockroach.storage.engine.enginepb.TxnMeta.fromObject}.
                     * @function
                     * @param {Object.<string,*>} object Plain object
                     * @returns {cockroach.storage.engine.enginepb.TxnMeta} TxnMeta
                     */
                    TxnMeta.from = TxnMeta.fromObject;

                    /**
                     * Creates a plain object from a TxnMeta message. Also converts values to other types if specified.
                     * @param {cockroach.storage.engine.enginepb.TxnMeta} message TxnMeta
                     * @param {$protobuf.ConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    TxnMeta.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.defaults) {
                            object.id = options.bytes === String ? "" : [];
                            object.isolation = options.enums === String ? "SERIALIZABLE" : 0;
                            object.key = options.bytes === String ? "" : [];
                            object.epoch = 0;
                            object.timestamp = null;
                            object.priority = 0;
                            object.sequence = 0;
                            object.batch_index = 0;
                        }
                        if (message.id != null && message.hasOwnProperty("id"))
                            object.id = options.bytes === String ? $util.base64.encode(message.id, 0, message.id.length) : options.bytes === Array ? Array.prototype.slice.call(message.id) : message.id;
                        if (message.isolation != null && message.hasOwnProperty("isolation"))
                            object.isolation = options.enums === String ? $root.cockroach.storage.engine.enginepb.IsolationType[message.isolation] : message.isolation;
                        if (message.key != null && message.hasOwnProperty("key"))
                            object.key = options.bytes === String ? $util.base64.encode(message.key, 0, message.key.length) : options.bytes === Array ? Array.prototype.slice.call(message.key) : message.key;
                        if (message.epoch != null && message.hasOwnProperty("epoch"))
                            object.epoch = message.epoch;
                        if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                            object.timestamp = $root.cockroach.util.hlc.Timestamp.toObject(message.timestamp, options);
                        if (message.priority != null && message.hasOwnProperty("priority"))
                            object.priority = message.priority;
                        if (message.sequence != null && message.hasOwnProperty("sequence"))
                            object.sequence = message.sequence;
                        if (message.batch_index != null && message.hasOwnProperty("batch_index"))
                            object.batch_index = message.batch_index;
                        return object;
                    };

                    /**
                     * Creates a plain object from this TxnMeta message. Also converts values to other types if specified.
                     * @param {$protobuf.ConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    TxnMeta.prototype.toObject = function toObject(options) {
                        return this.constructor.toObject(this, options);
                    };

                    /**
                     * Converts this TxnMeta to JSON.
                     * @returns {Object.<string,*>} JSON object
                     */
                    TxnMeta.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return TxnMeta;
                })();

                enginepb.MVCCMetadata = (function() {

                    /**
                     * Properties of a MVCCMetadata.
                     * @typedef cockroach.storage.engine.enginepb.MVCCMetadata$Properties
                     * @type {Object}
                     * @property {cockroach.storage.engine.enginepb.TxnMeta$Properties} [txn] MVCCMetadata txn.
                     * @property {cockroach.util.hlc.Timestamp$Properties} [timestamp] MVCCMetadata timestamp.
                     * @property {boolean} [deleted] MVCCMetadata deleted.
                     * @property {Long} [key_bytes] MVCCMetadata key_bytes.
                     * @property {Long} [val_bytes] MVCCMetadata val_bytes.
                     * @property {Uint8Array} [raw_bytes] MVCCMetadata raw_bytes.
                     * @property {cockroach.util.hlc.Timestamp$Properties} [merge_timestamp] MVCCMetadata merge_timestamp.
                     */

                    /**
                     * Constructs a new MVCCMetadata.
                     * @exports cockroach.storage.engine.enginepb.MVCCMetadata
                     * @constructor
                     * @param {cockroach.storage.engine.enginepb.MVCCMetadata$Properties=} [properties] Properties to set
                     */
                    function MVCCMetadata(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * MVCCMetadata txn.
                     * @type {(cockroach.storage.engine.enginepb.TxnMeta$Properties|null)}
                     */
                    MVCCMetadata.prototype.txn = null;

                    /**
                     * MVCCMetadata timestamp.
                     * @type {(cockroach.util.hlc.Timestamp$Properties|null)}
                     */
                    MVCCMetadata.prototype.timestamp = null;

                    /**
                     * MVCCMetadata deleted.
                     * @type {boolean}
                     */
                    MVCCMetadata.prototype.deleted = false;

                    /**
                     * MVCCMetadata key_bytes.
                     * @type {Long}
                     */
                    MVCCMetadata.prototype.key_bytes = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

                    /**
                     * MVCCMetadata val_bytes.
                     * @type {Long}
                     */
                    MVCCMetadata.prototype.val_bytes = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

                    /**
                     * MVCCMetadata raw_bytes.
                     * @type {Uint8Array}
                     */
                    MVCCMetadata.prototype.raw_bytes = $util.newBuffer([]);

                    /**
                     * MVCCMetadata merge_timestamp.
                     * @type {(cockroach.util.hlc.Timestamp$Properties|null)}
                     */
                    MVCCMetadata.prototype.merge_timestamp = null;

                    /**
                     * Creates a new MVCCMetadata instance using the specified properties.
                     * @param {cockroach.storage.engine.enginepb.MVCCMetadata$Properties=} [properties] Properties to set
                     * @returns {cockroach.storage.engine.enginepb.MVCCMetadata} MVCCMetadata instance
                     */
                    MVCCMetadata.create = function create(properties) {
                        return new MVCCMetadata(properties);
                    };

                    /**
                     * Encodes the specified MVCCMetadata message. Does not implicitly {@link cockroach.storage.engine.enginepb.MVCCMetadata.verify|verify} messages.
                     * @param {cockroach.storage.engine.enginepb.MVCCMetadata$Properties} message MVCCMetadata message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    MVCCMetadata.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.txn != null && message.hasOwnProperty("txn"))
                            $root.cockroach.storage.engine.enginepb.TxnMeta.encode(message.txn, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                        if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                            $root.cockroach.util.hlc.Timestamp.encode(message.timestamp, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                        if (message.deleted != null && message.hasOwnProperty("deleted"))
                            writer.uint32(/* id 3, wireType 0 =*/24).bool(message.deleted);
                        if (message.key_bytes != null && message.hasOwnProperty("key_bytes"))
                            writer.uint32(/* id 4, wireType 0 =*/32).int64(message.key_bytes);
                        if (message.val_bytes != null && message.hasOwnProperty("val_bytes"))
                            writer.uint32(/* id 5, wireType 0 =*/40).int64(message.val_bytes);
                        if (message.raw_bytes != null && message.hasOwnProperty("raw_bytes"))
                            writer.uint32(/* id 6, wireType 2 =*/50).bytes(message.raw_bytes);
                        if (message.merge_timestamp != null && message.hasOwnProperty("merge_timestamp"))
                            $root.cockroach.util.hlc.Timestamp.encode(message.merge_timestamp, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                        return writer;
                    };

                    /**
                     * Encodes the specified MVCCMetadata message, length delimited. Does not implicitly {@link cockroach.storage.engine.enginepb.MVCCMetadata.verify|verify} messages.
                     * @param {cockroach.storage.engine.enginepb.MVCCMetadata$Properties} message MVCCMetadata message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    MVCCMetadata.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a MVCCMetadata message from the specified reader or buffer.
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {cockroach.storage.engine.enginepb.MVCCMetadata} MVCCMetadata
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    MVCCMetadata.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.cockroach.storage.engine.enginepb.MVCCMetadata();
                        while (reader.pos < end) {
                            let tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.txn = $root.cockroach.storage.engine.enginepb.TxnMeta.decode(reader, reader.uint32());
                                break;
                            case 2:
                                message.timestamp = $root.cockroach.util.hlc.Timestamp.decode(reader, reader.uint32());
                                break;
                            case 3:
                                message.deleted = reader.bool();
                                break;
                            case 4:
                                message.key_bytes = reader.int64();
                                break;
                            case 5:
                                message.val_bytes = reader.int64();
                                break;
                            case 6:
                                message.raw_bytes = reader.bytes();
                                break;
                            case 7:
                                message.merge_timestamp = $root.cockroach.util.hlc.Timestamp.decode(reader, reader.uint32());
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a MVCCMetadata message from the specified reader or buffer, length delimited.
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {cockroach.storage.engine.enginepb.MVCCMetadata} MVCCMetadata
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    MVCCMetadata.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a MVCCMetadata message.
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {?string} `null` if valid, otherwise the reason why it is not
                     */
                    MVCCMetadata.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.txn != null && message.hasOwnProperty("txn")) {
                            let error = $root.cockroach.storage.engine.enginepb.TxnMeta.verify(message.txn);
                            if (error)
                                return "txn." + error;
                        }
                        if (message.timestamp != null && message.hasOwnProperty("timestamp")) {
                            let error = $root.cockroach.util.hlc.Timestamp.verify(message.timestamp);
                            if (error)
                                return "timestamp." + error;
                        }
                        if (message.deleted != null && message.hasOwnProperty("deleted"))
                            if (typeof message.deleted !== "boolean")
                                return "deleted: boolean expected";
                        if (message.key_bytes != null && message.hasOwnProperty("key_bytes"))
                            if (!$util.isInteger(message.key_bytes) && !(message.key_bytes && $util.isInteger(message.key_bytes.low) && $util.isInteger(message.key_bytes.high)))
                                return "key_bytes: integer|Long expected";
                        if (message.val_bytes != null && message.hasOwnProperty("val_bytes"))
                            if (!$util.isInteger(message.val_bytes) && !(message.val_bytes && $util.isInteger(message.val_bytes.low) && $util.isInteger(message.val_bytes.high)))
                                return "val_bytes: integer|Long expected";
                        if (message.raw_bytes != null && message.hasOwnProperty("raw_bytes"))
                            if (!(message.raw_bytes && typeof message.raw_bytes.length === "number" || $util.isString(message.raw_bytes)))
                                return "raw_bytes: buffer expected";
                        if (message.merge_timestamp != null && message.hasOwnProperty("merge_timestamp")) {
                            let error = $root.cockroach.util.hlc.Timestamp.verify(message.merge_timestamp);
                            if (error)
                                return "merge_timestamp." + error;
                        }
                        return null;
                    };

                    /**
                     * Creates a MVCCMetadata message from a plain object. Also converts values to their respective internal types.
                     * @param {Object.<string,*>} object Plain object
                     * @returns {cockroach.storage.engine.enginepb.MVCCMetadata} MVCCMetadata
                     */
                    MVCCMetadata.fromObject = function fromObject(object) {
                        if (object instanceof $root.cockroach.storage.engine.enginepb.MVCCMetadata)
                            return object;
                        let message = new $root.cockroach.storage.engine.enginepb.MVCCMetadata();
                        if (object.txn != null) {
                            if (typeof object.txn !== "object")
                                throw TypeError(".cockroach.storage.engine.enginepb.MVCCMetadata.txn: object expected");
                            message.txn = $root.cockroach.storage.engine.enginepb.TxnMeta.fromObject(object.txn);
                        }
                        if (object.timestamp != null) {
                            if (typeof object.timestamp !== "object")
                                throw TypeError(".cockroach.storage.engine.enginepb.MVCCMetadata.timestamp: object expected");
                            message.timestamp = $root.cockroach.util.hlc.Timestamp.fromObject(object.timestamp);
                        }
                        if (object.deleted != null)
                            message.deleted = Boolean(object.deleted);
                        if (object.key_bytes != null)
                            if ($util.Long)
                                (message.key_bytes = $util.Long.fromValue(object.key_bytes)).unsigned = false;
                            else if (typeof object.key_bytes === "string")
                                message.key_bytes = parseInt(object.key_bytes, 10);
                            else if (typeof object.key_bytes === "number")
                                message.key_bytes = object.key_bytes;
                            else if (typeof object.key_bytes === "object")
                                message.key_bytes = new $util.LongBits(object.key_bytes.low >>> 0, object.key_bytes.high >>> 0).toNumber();
                        if (object.val_bytes != null)
                            if ($util.Long)
                                (message.val_bytes = $util.Long.fromValue(object.val_bytes)).unsigned = false;
                            else if (typeof object.val_bytes === "string")
                                message.val_bytes = parseInt(object.val_bytes, 10);
                            else if (typeof object.val_bytes === "number")
                                message.val_bytes = object.val_bytes;
                            else if (typeof object.val_bytes === "object")
                                message.val_bytes = new $util.LongBits(object.val_bytes.low >>> 0, object.val_bytes.high >>> 0).toNumber();
                        if (object.raw_bytes != null)
                            if (typeof object.raw_bytes === "string")
                                $util.base64.decode(object.raw_bytes, message.raw_bytes = $util.newBuffer($util.base64.length(object.raw_bytes)), 0);
                            else if (object.raw_bytes.length)
                                message.raw_bytes = object.raw_bytes;
                        if (object.merge_timestamp != null) {
                            if (typeof object.merge_timestamp !== "object")
                                throw TypeError(".cockroach.storage.engine.enginepb.MVCCMetadata.merge_timestamp: object expected");
                            message.merge_timestamp = $root.cockroach.util.hlc.Timestamp.fromObject(object.merge_timestamp);
                        }
                        return message;
                    };

                    /**
                     * Creates a MVCCMetadata message from a plain object. Also converts values to their respective internal types.
                     * This is an alias of {@link cockroach.storage.engine.enginepb.MVCCMetadata.fromObject}.
                     * @function
                     * @param {Object.<string,*>} object Plain object
                     * @returns {cockroach.storage.engine.enginepb.MVCCMetadata} MVCCMetadata
                     */
                    MVCCMetadata.from = MVCCMetadata.fromObject;

                    /**
                     * Creates a plain object from a MVCCMetadata message. Also converts values to other types if specified.
                     * @param {cockroach.storage.engine.enginepb.MVCCMetadata} message MVCCMetadata
                     * @param {$protobuf.ConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    MVCCMetadata.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.defaults) {
                            object.txn = null;
                            object.timestamp = null;
                            object.deleted = false;
                            if ($util.Long) {
                                let long = new $util.Long(0, 0, false);
                                object.key_bytes = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.key_bytes = options.longs === String ? "0" : 0;
                            if ($util.Long) {
                                let long = new $util.Long(0, 0, false);
                                object.val_bytes = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.val_bytes = options.longs === String ? "0" : 0;
                            object.raw_bytes = options.bytes === String ? "" : [];
                            object.merge_timestamp = null;
                        }
                        if (message.txn != null && message.hasOwnProperty("txn"))
                            object.txn = $root.cockroach.storage.engine.enginepb.TxnMeta.toObject(message.txn, options);
                        if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                            object.timestamp = $root.cockroach.util.hlc.Timestamp.toObject(message.timestamp, options);
                        if (message.deleted != null && message.hasOwnProperty("deleted"))
                            object.deleted = message.deleted;
                        if (message.key_bytes != null && message.hasOwnProperty("key_bytes"))
                            if (typeof message.key_bytes === "number")
                                object.key_bytes = options.longs === String ? String(message.key_bytes) : message.key_bytes;
                            else
                                object.key_bytes = options.longs === String ? $util.Long.prototype.toString.call(message.key_bytes) : options.longs === Number ? new $util.LongBits(message.key_bytes.low >>> 0, message.key_bytes.high >>> 0).toNumber() : message.key_bytes;
                        if (message.val_bytes != null && message.hasOwnProperty("val_bytes"))
                            if (typeof message.val_bytes === "number")
                                object.val_bytes = options.longs === String ? String(message.val_bytes) : message.val_bytes;
                            else
                                object.val_bytes = options.longs === String ? $util.Long.prototype.toString.call(message.val_bytes) : options.longs === Number ? new $util.LongBits(message.val_bytes.low >>> 0, message.val_bytes.high >>> 0).toNumber() : message.val_bytes;
                        if (message.raw_bytes != null && message.hasOwnProperty("raw_bytes"))
                            object.raw_bytes = options.bytes === String ? $util.base64.encode(message.raw_bytes, 0, message.raw_bytes.length) : options.bytes === Array ? Array.prototype.slice.call(message.raw_bytes) : message.raw_bytes;
                        if (message.merge_timestamp != null && message.hasOwnProperty("merge_timestamp"))
                            object.merge_timestamp = $root.cockroach.util.hlc.Timestamp.toObject(message.merge_timestamp, options);
                        return object;
                    };

                    /**
                     * Creates a plain object from this MVCCMetadata message. Also converts values to other types if specified.
                     * @param {$protobuf.ConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    MVCCMetadata.prototype.toObject = function toObject(options) {
                        return this.constructor.toObject(this, options);
                    };

                    /**
                     * Converts this MVCCMetadata to JSON.
                     * @returns {Object.<string,*>} JSON object
                     */
                    MVCCMetadata.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return MVCCMetadata;
                })();

                enginepb.MVCCStats = (function() {

                    /**
                     * Properties of a MVCCStats.
                     * @typedef cockroach.storage.engine.enginepb.MVCCStats$Properties
                     * @type {Object}
                     * @property {boolean} [contains_estimates] MVCCStats contains_estimates.
                     * @property {Long} [last_update_nanos] MVCCStats last_update_nanos.
                     * @property {Long} [intent_age] MVCCStats intent_age.
                     * @property {Long} [gc_bytes_age] MVCCStats gc_bytes_age.
                     * @property {Long} [live_bytes] MVCCStats live_bytes.
                     * @property {Long} [live_count] MVCCStats live_count.
                     * @property {Long} [key_bytes] MVCCStats key_bytes.
                     * @property {Long} [key_count] MVCCStats key_count.
                     * @property {Long} [val_bytes] MVCCStats val_bytes.
                     * @property {Long} [val_count] MVCCStats val_count.
                     * @property {Long} [intent_bytes] MVCCStats intent_bytes.
                     * @property {Long} [intent_count] MVCCStats intent_count.
                     * @property {Long} [sys_bytes] MVCCStats sys_bytes.
                     * @property {Long} [sys_count] MVCCStats sys_count.
                     */

                    /**
                     * Constructs a new MVCCStats.
                     * @exports cockroach.storage.engine.enginepb.MVCCStats
                     * @constructor
                     * @param {cockroach.storage.engine.enginepb.MVCCStats$Properties=} [properties] Properties to set
                     */
                    function MVCCStats(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * MVCCStats contains_estimates.
                     * @type {boolean}
                     */
                    MVCCStats.prototype.contains_estimates = false;

                    /**
                     * MVCCStats last_update_nanos.
                     * @type {Long}
                     */
                    MVCCStats.prototype.last_update_nanos = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

                    /**
                     * MVCCStats intent_age.
                     * @type {Long}
                     */
                    MVCCStats.prototype.intent_age = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

                    /**
                     * MVCCStats gc_bytes_age.
                     * @type {Long}
                     */
                    MVCCStats.prototype.gc_bytes_age = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

                    /**
                     * MVCCStats live_bytes.
                     * @type {Long}
                     */
                    MVCCStats.prototype.live_bytes = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

                    /**
                     * MVCCStats live_count.
                     * @type {Long}
                     */
                    MVCCStats.prototype.live_count = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

                    /**
                     * MVCCStats key_bytes.
                     * @type {Long}
                     */
                    MVCCStats.prototype.key_bytes = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

                    /**
                     * MVCCStats key_count.
                     * @type {Long}
                     */
                    MVCCStats.prototype.key_count = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

                    /**
                     * MVCCStats val_bytes.
                     * @type {Long}
                     */
                    MVCCStats.prototype.val_bytes = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

                    /**
                     * MVCCStats val_count.
                     * @type {Long}
                     */
                    MVCCStats.prototype.val_count = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

                    /**
                     * MVCCStats intent_bytes.
                     * @type {Long}
                     */
                    MVCCStats.prototype.intent_bytes = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

                    /**
                     * MVCCStats intent_count.
                     * @type {Long}
                     */
                    MVCCStats.prototype.intent_count = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

                    /**
                     * MVCCStats sys_bytes.
                     * @type {Long}
                     */
                    MVCCStats.prototype.sys_bytes = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

                    /**
                     * MVCCStats sys_count.
                     * @type {Long}
                     */
                    MVCCStats.prototype.sys_count = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

                    /**
                     * Creates a new MVCCStats instance using the specified properties.
                     * @param {cockroach.storage.engine.enginepb.MVCCStats$Properties=} [properties] Properties to set
                     * @returns {cockroach.storage.engine.enginepb.MVCCStats} MVCCStats instance
                     */
                    MVCCStats.create = function create(properties) {
                        return new MVCCStats(properties);
                    };

                    /**
                     * Encodes the specified MVCCStats message. Does not implicitly {@link cockroach.storage.engine.enginepb.MVCCStats.verify|verify} messages.
                     * @param {cockroach.storage.engine.enginepb.MVCCStats$Properties} message MVCCStats message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    MVCCStats.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.last_update_nanos != null && message.hasOwnProperty("last_update_nanos"))
                            writer.uint32(/* id 1, wireType 1 =*/9).sfixed64(message.last_update_nanos);
                        if (message.intent_age != null && message.hasOwnProperty("intent_age"))
                            writer.uint32(/* id 2, wireType 1 =*/17).sfixed64(message.intent_age);
                        if (message.gc_bytes_age != null && message.hasOwnProperty("gc_bytes_age"))
                            writer.uint32(/* id 3, wireType 1 =*/25).sfixed64(message.gc_bytes_age);
                        if (message.live_bytes != null && message.hasOwnProperty("live_bytes"))
                            writer.uint32(/* id 4, wireType 1 =*/33).sfixed64(message.live_bytes);
                        if (message.live_count != null && message.hasOwnProperty("live_count"))
                            writer.uint32(/* id 5, wireType 1 =*/41).sfixed64(message.live_count);
                        if (message.key_bytes != null && message.hasOwnProperty("key_bytes"))
                            writer.uint32(/* id 6, wireType 1 =*/49).sfixed64(message.key_bytes);
                        if (message.key_count != null && message.hasOwnProperty("key_count"))
                            writer.uint32(/* id 7, wireType 1 =*/57).sfixed64(message.key_count);
                        if (message.val_bytes != null && message.hasOwnProperty("val_bytes"))
                            writer.uint32(/* id 8, wireType 1 =*/65).sfixed64(message.val_bytes);
                        if (message.val_count != null && message.hasOwnProperty("val_count"))
                            writer.uint32(/* id 9, wireType 1 =*/73).sfixed64(message.val_count);
                        if (message.intent_bytes != null && message.hasOwnProperty("intent_bytes"))
                            writer.uint32(/* id 10, wireType 1 =*/81).sfixed64(message.intent_bytes);
                        if (message.intent_count != null && message.hasOwnProperty("intent_count"))
                            writer.uint32(/* id 11, wireType 1 =*/89).sfixed64(message.intent_count);
                        if (message.sys_bytes != null && message.hasOwnProperty("sys_bytes"))
                            writer.uint32(/* id 12, wireType 1 =*/97).sfixed64(message.sys_bytes);
                        if (message.sys_count != null && message.hasOwnProperty("sys_count"))
                            writer.uint32(/* id 13, wireType 1 =*/105).sfixed64(message.sys_count);
                        if (message.contains_estimates != null && message.hasOwnProperty("contains_estimates"))
                            writer.uint32(/* id 14, wireType 0 =*/112).bool(message.contains_estimates);
                        return writer;
                    };

                    /**
                     * Encodes the specified MVCCStats message, length delimited. Does not implicitly {@link cockroach.storage.engine.enginepb.MVCCStats.verify|verify} messages.
                     * @param {cockroach.storage.engine.enginepb.MVCCStats$Properties} message MVCCStats message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    MVCCStats.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a MVCCStats message from the specified reader or buffer.
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {cockroach.storage.engine.enginepb.MVCCStats} MVCCStats
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    MVCCStats.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.cockroach.storage.engine.enginepb.MVCCStats();
                        while (reader.pos < end) {
                            let tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 14:
                                message.contains_estimates = reader.bool();
                                break;
                            case 1:
                                message.last_update_nanos = reader.sfixed64();
                                break;
                            case 2:
                                message.intent_age = reader.sfixed64();
                                break;
                            case 3:
                                message.gc_bytes_age = reader.sfixed64();
                                break;
                            case 4:
                                message.live_bytes = reader.sfixed64();
                                break;
                            case 5:
                                message.live_count = reader.sfixed64();
                                break;
                            case 6:
                                message.key_bytes = reader.sfixed64();
                                break;
                            case 7:
                                message.key_count = reader.sfixed64();
                                break;
                            case 8:
                                message.val_bytes = reader.sfixed64();
                                break;
                            case 9:
                                message.val_count = reader.sfixed64();
                                break;
                            case 10:
                                message.intent_bytes = reader.sfixed64();
                                break;
                            case 11:
                                message.intent_count = reader.sfixed64();
                                break;
                            case 12:
                                message.sys_bytes = reader.sfixed64();
                                break;
                            case 13:
                                message.sys_count = reader.sfixed64();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a MVCCStats message from the specified reader or buffer, length delimited.
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {cockroach.storage.engine.enginepb.MVCCStats} MVCCStats
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    MVCCStats.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a MVCCStats message.
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {?string} `null` if valid, otherwise the reason why it is not
                     */
                    MVCCStats.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.contains_estimates != null && message.hasOwnProperty("contains_estimates"))
                            if (typeof message.contains_estimates !== "boolean")
                                return "contains_estimates: boolean expected";
                        if (message.last_update_nanos != null && message.hasOwnProperty("last_update_nanos"))
                            if (!$util.isInteger(message.last_update_nanos) && !(message.last_update_nanos && $util.isInteger(message.last_update_nanos.low) && $util.isInteger(message.last_update_nanos.high)))
                                return "last_update_nanos: integer|Long expected";
                        if (message.intent_age != null && message.hasOwnProperty("intent_age"))
                            if (!$util.isInteger(message.intent_age) && !(message.intent_age && $util.isInteger(message.intent_age.low) && $util.isInteger(message.intent_age.high)))
                                return "intent_age: integer|Long expected";
                        if (message.gc_bytes_age != null && message.hasOwnProperty("gc_bytes_age"))
                            if (!$util.isInteger(message.gc_bytes_age) && !(message.gc_bytes_age && $util.isInteger(message.gc_bytes_age.low) && $util.isInteger(message.gc_bytes_age.high)))
                                return "gc_bytes_age: integer|Long expected";
                        if (message.live_bytes != null && message.hasOwnProperty("live_bytes"))
                            if (!$util.isInteger(message.live_bytes) && !(message.live_bytes && $util.isInteger(message.live_bytes.low) && $util.isInteger(message.live_bytes.high)))
                                return "live_bytes: integer|Long expected";
                        if (message.live_count != null && message.hasOwnProperty("live_count"))
                            if (!$util.isInteger(message.live_count) && !(message.live_count && $util.isInteger(message.live_count.low) && $util.isInteger(message.live_count.high)))
                                return "live_count: integer|Long expected";
                        if (message.key_bytes != null && message.hasOwnProperty("key_bytes"))
                            if (!$util.isInteger(message.key_bytes) && !(message.key_bytes && $util.isInteger(message.key_bytes.low) && $util.isInteger(message.key_bytes.high)))
                                return "key_bytes: integer|Long expected";
                        if (message.key_count != null && message.hasOwnProperty("key_count"))
                            if (!$util.isInteger(message.key_count) && !(message.key_count && $util.isInteger(message.key_count.low) && $util.isInteger(message.key_count.high)))
                                return "key_count: integer|Long expected";
                        if (message.val_bytes != null && message.hasOwnProperty("val_bytes"))
                            if (!$util.isInteger(message.val_bytes) && !(message.val_bytes && $util.isInteger(message.val_bytes.low) && $util.isInteger(message.val_bytes.high)))
                                return "val_bytes: integer|Long expected";
                        if (message.val_count != null && message.hasOwnProperty("val_count"))
                            if (!$util.isInteger(message.val_count) && !(message.val_count && $util.isInteger(message.val_count.low) && $util.isInteger(message.val_count.high)))
                                return "val_count: integer|Long expected";
                        if (message.intent_bytes != null && message.hasOwnProperty("intent_bytes"))
                            if (!$util.isInteger(message.intent_bytes) && !(message.intent_bytes && $util.isInteger(message.intent_bytes.low) && $util.isInteger(message.intent_bytes.high)))
                                return "intent_bytes: integer|Long expected";
                        if (message.intent_count != null && message.hasOwnProperty("intent_count"))
                            if (!$util.isInteger(message.intent_count) && !(message.intent_count && $util.isInteger(message.intent_count.low) && $util.isInteger(message.intent_count.high)))
                                return "intent_count: integer|Long expected";
                        if (message.sys_bytes != null && message.hasOwnProperty("sys_bytes"))
                            if (!$util.isInteger(message.sys_bytes) && !(message.sys_bytes && $util.isInteger(message.sys_bytes.low) && $util.isInteger(message.sys_bytes.high)))
                                return "sys_bytes: integer|Long expected";
                        if (message.sys_count != null && message.hasOwnProperty("sys_count"))
                            if (!$util.isInteger(message.sys_count) && !(message.sys_count && $util.isInteger(message.sys_count.low) && $util.isInteger(message.sys_count.high)))
                                return "sys_count: integer|Long expected";
                        return null;
                    };

                    /**
                     * Creates a MVCCStats message from a plain object. Also converts values to their respective internal types.
                     * @param {Object.<string,*>} object Plain object
                     * @returns {cockroach.storage.engine.enginepb.MVCCStats} MVCCStats
                     */
                    MVCCStats.fromObject = function fromObject(object) {
                        if (object instanceof $root.cockroach.storage.engine.enginepb.MVCCStats)
                            return object;
                        let message = new $root.cockroach.storage.engine.enginepb.MVCCStats();
                        if (object.contains_estimates != null)
                            message.contains_estimates = Boolean(object.contains_estimates);
                        if (object.last_update_nanos != null)
                            if ($util.Long)
                                (message.last_update_nanos = $util.Long.fromValue(object.last_update_nanos)).unsigned = false;
                            else if (typeof object.last_update_nanos === "string")
                                message.last_update_nanos = parseInt(object.last_update_nanos, 10);
                            else if (typeof object.last_update_nanos === "number")
                                message.last_update_nanos = object.last_update_nanos;
                            else if (typeof object.last_update_nanos === "object")
                                message.last_update_nanos = new $util.LongBits(object.last_update_nanos.low >>> 0, object.last_update_nanos.high >>> 0).toNumber();
                        if (object.intent_age != null)
                            if ($util.Long)
                                (message.intent_age = $util.Long.fromValue(object.intent_age)).unsigned = false;
                            else if (typeof object.intent_age === "string")
                                message.intent_age = parseInt(object.intent_age, 10);
                            else if (typeof object.intent_age === "number")
                                message.intent_age = object.intent_age;
                            else if (typeof object.intent_age === "object")
                                message.intent_age = new $util.LongBits(object.intent_age.low >>> 0, object.intent_age.high >>> 0).toNumber();
                        if (object.gc_bytes_age != null)
                            if ($util.Long)
                                (message.gc_bytes_age = $util.Long.fromValue(object.gc_bytes_age)).unsigned = false;
                            else if (typeof object.gc_bytes_age === "string")
                                message.gc_bytes_age = parseInt(object.gc_bytes_age, 10);
                            else if (typeof object.gc_bytes_age === "number")
                                message.gc_bytes_age = object.gc_bytes_age;
                            else if (typeof object.gc_bytes_age === "object")
                                message.gc_bytes_age = new $util.LongBits(object.gc_bytes_age.low >>> 0, object.gc_bytes_age.high >>> 0).toNumber();
                        if (object.live_bytes != null)
                            if ($util.Long)
                                (message.live_bytes = $util.Long.fromValue(object.live_bytes)).unsigned = false;
                            else if (typeof object.live_bytes === "string")
                                message.live_bytes = parseInt(object.live_bytes, 10);
                            else if (typeof object.live_bytes === "number")
                                message.live_bytes = object.live_bytes;
                            else if (typeof object.live_bytes === "object")
                                message.live_bytes = new $util.LongBits(object.live_bytes.low >>> 0, object.live_bytes.high >>> 0).toNumber();
                        if (object.live_count != null)
                            if ($util.Long)
                                (message.live_count = $util.Long.fromValue(object.live_count)).unsigned = false;
                            else if (typeof object.live_count === "string")
                                message.live_count = parseInt(object.live_count, 10);
                            else if (typeof object.live_count === "number")
                                message.live_count = object.live_count;
                            else if (typeof object.live_count === "object")
                                message.live_count = new $util.LongBits(object.live_count.low >>> 0, object.live_count.high >>> 0).toNumber();
                        if (object.key_bytes != null)
                            if ($util.Long)
                                (message.key_bytes = $util.Long.fromValue(object.key_bytes)).unsigned = false;
                            else if (typeof object.key_bytes === "string")
                                message.key_bytes = parseInt(object.key_bytes, 10);
                            else if (typeof object.key_bytes === "number")
                                message.key_bytes = object.key_bytes;
                            else if (typeof object.key_bytes === "object")
                                message.key_bytes = new $util.LongBits(object.key_bytes.low >>> 0, object.key_bytes.high >>> 0).toNumber();
                        if (object.key_count != null)
                            if ($util.Long)
                                (message.key_count = $util.Long.fromValue(object.key_count)).unsigned = false;
                            else if (typeof object.key_count === "string")
                                message.key_count = parseInt(object.key_count, 10);
                            else if (typeof object.key_count === "number")
                                message.key_count = object.key_count;
                            else if (typeof object.key_count === "object")
                                message.key_count = new $util.LongBits(object.key_count.low >>> 0, object.key_count.high >>> 0).toNumber();
                        if (object.val_bytes != null)
                            if ($util.Long)
                                (message.val_bytes = $util.Long.fromValue(object.val_bytes)).unsigned = false;
                            else if (typeof object.val_bytes === "string")
                                message.val_bytes = parseInt(object.val_bytes, 10);
                            else if (typeof object.val_bytes === "number")
                                message.val_bytes = object.val_bytes;
                            else if (typeof object.val_bytes === "object")
                                message.val_bytes = new $util.LongBits(object.val_bytes.low >>> 0, object.val_bytes.high >>> 0).toNumber();
                        if (object.val_count != null)
                            if ($util.Long)
                                (message.val_count = $util.Long.fromValue(object.val_count)).unsigned = false;
                            else if (typeof object.val_count === "string")
                                message.val_count = parseInt(object.val_count, 10);
                            else if (typeof object.val_count === "number")
                                message.val_count = object.val_count;
                            else if (typeof object.val_count === "object")
                                message.val_count = new $util.LongBits(object.val_count.low >>> 0, object.val_count.high >>> 0).toNumber();
                        if (object.intent_bytes != null)
                            if ($util.Long)
                                (message.intent_bytes = $util.Long.fromValue(object.intent_bytes)).unsigned = false;
                            else if (typeof object.intent_bytes === "string")
                                message.intent_bytes = parseInt(object.intent_bytes, 10);
                            else if (typeof object.intent_bytes === "number")
                                message.intent_bytes = object.intent_bytes;
                            else if (typeof object.intent_bytes === "object")
                                message.intent_bytes = new $util.LongBits(object.intent_bytes.low >>> 0, object.intent_bytes.high >>> 0).toNumber();
                        if (object.intent_count != null)
                            if ($util.Long)
                                (message.intent_count = $util.Long.fromValue(object.intent_count)).unsigned = false;
                            else if (typeof object.intent_count === "string")
                                message.intent_count = parseInt(object.intent_count, 10);
                            else if (typeof object.intent_count === "number")
                                message.intent_count = object.intent_count;
                            else if (typeof object.intent_count === "object")
                                message.intent_count = new $util.LongBits(object.intent_count.low >>> 0, object.intent_count.high >>> 0).toNumber();
                        if (object.sys_bytes != null)
                            if ($util.Long)
                                (message.sys_bytes = $util.Long.fromValue(object.sys_bytes)).unsigned = false;
                            else if (typeof object.sys_bytes === "string")
                                message.sys_bytes = parseInt(object.sys_bytes, 10);
                            else if (typeof object.sys_bytes === "number")
                                message.sys_bytes = object.sys_bytes;
                            else if (typeof object.sys_bytes === "object")
                                message.sys_bytes = new $util.LongBits(object.sys_bytes.low >>> 0, object.sys_bytes.high >>> 0).toNumber();
                        if (object.sys_count != null)
                            if ($util.Long)
                                (message.sys_count = $util.Long.fromValue(object.sys_count)).unsigned = false;
                            else if (typeof object.sys_count === "string")
                                message.sys_count = parseInt(object.sys_count, 10);
                            else if (typeof object.sys_count === "number")
                                message.sys_count = object.sys_count;
                            else if (typeof object.sys_count === "object")
                                message.sys_count = new $util.LongBits(object.sys_count.low >>> 0, object.sys_count.high >>> 0).toNumber();
                        return message;
                    };

                    /**
                     * Creates a MVCCStats message from a plain object. Also converts values to their respective internal types.
                     * This is an alias of {@link cockroach.storage.engine.enginepb.MVCCStats.fromObject}.
                     * @function
                     * @param {Object.<string,*>} object Plain object
                     * @returns {cockroach.storage.engine.enginepb.MVCCStats} MVCCStats
                     */
                    MVCCStats.from = MVCCStats.fromObject;

                    /**
                     * Creates a plain object from a MVCCStats message. Also converts values to other types if specified.
                     * @param {cockroach.storage.engine.enginepb.MVCCStats} message MVCCStats
                     * @param {$protobuf.ConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    MVCCStats.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.defaults) {
                            if ($util.Long) {
                                let long = new $util.Long(0, 0, false);
                                object.last_update_nanos = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.last_update_nanos = options.longs === String ? "0" : 0;
                            if ($util.Long) {
                                let long = new $util.Long(0, 0, false);
                                object.intent_age = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.intent_age = options.longs === String ? "0" : 0;
                            if ($util.Long) {
                                let long = new $util.Long(0, 0, false);
                                object.gc_bytes_age = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.gc_bytes_age = options.longs === String ? "0" : 0;
                            if ($util.Long) {
                                let long = new $util.Long(0, 0, false);
                                object.live_bytes = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.live_bytes = options.longs === String ? "0" : 0;
                            if ($util.Long) {
                                let long = new $util.Long(0, 0, false);
                                object.live_count = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.live_count = options.longs === String ? "0" : 0;
                            if ($util.Long) {
                                let long = new $util.Long(0, 0, false);
                                object.key_bytes = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.key_bytes = options.longs === String ? "0" : 0;
                            if ($util.Long) {
                                let long = new $util.Long(0, 0, false);
                                object.key_count = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.key_count = options.longs === String ? "0" : 0;
                            if ($util.Long) {
                                let long = new $util.Long(0, 0, false);
                                object.val_bytes = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.val_bytes = options.longs === String ? "0" : 0;
                            if ($util.Long) {
                                let long = new $util.Long(0, 0, false);
                                object.val_count = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.val_count = options.longs === String ? "0" : 0;
                            if ($util.Long) {
                                let long = new $util.Long(0, 0, false);
                                object.intent_bytes = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.intent_bytes = options.longs === String ? "0" : 0;
                            if ($util.Long) {
                                let long = new $util.Long(0, 0, false);
                                object.intent_count = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.intent_count = options.longs === String ? "0" : 0;
                            if ($util.Long) {
                                let long = new $util.Long(0, 0, false);
                                object.sys_bytes = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.sys_bytes = options.longs === String ? "0" : 0;
                            if ($util.Long) {
                                let long = new $util.Long(0, 0, false);
                                object.sys_count = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.sys_count = options.longs === String ? "0" : 0;
                            object.contains_estimates = false;
                        }
                        if (message.last_update_nanos != null && message.hasOwnProperty("last_update_nanos"))
                            if (typeof message.last_update_nanos === "number")
                                object.last_update_nanos = options.longs === String ? String(message.last_update_nanos) : message.last_update_nanos;
                            else
                                object.last_update_nanos = options.longs === String ? $util.Long.prototype.toString.call(message.last_update_nanos) : options.longs === Number ? new $util.LongBits(message.last_update_nanos.low >>> 0, message.last_update_nanos.high >>> 0).toNumber() : message.last_update_nanos;
                        if (message.intent_age != null && message.hasOwnProperty("intent_age"))
                            if (typeof message.intent_age === "number")
                                object.intent_age = options.longs === String ? String(message.intent_age) : message.intent_age;
                            else
                                object.intent_age = options.longs === String ? $util.Long.prototype.toString.call(message.intent_age) : options.longs === Number ? new $util.LongBits(message.intent_age.low >>> 0, message.intent_age.high >>> 0).toNumber() : message.intent_age;
                        if (message.gc_bytes_age != null && message.hasOwnProperty("gc_bytes_age"))
                            if (typeof message.gc_bytes_age === "number")
                                object.gc_bytes_age = options.longs === String ? String(message.gc_bytes_age) : message.gc_bytes_age;
                            else
                                object.gc_bytes_age = options.longs === String ? $util.Long.prototype.toString.call(message.gc_bytes_age) : options.longs === Number ? new $util.LongBits(message.gc_bytes_age.low >>> 0, message.gc_bytes_age.high >>> 0).toNumber() : message.gc_bytes_age;
                        if (message.live_bytes != null && message.hasOwnProperty("live_bytes"))
                            if (typeof message.live_bytes === "number")
                                object.live_bytes = options.longs === String ? String(message.live_bytes) : message.live_bytes;
                            else
                                object.live_bytes = options.longs === String ? $util.Long.prototype.toString.call(message.live_bytes) : options.longs === Number ? new $util.LongBits(message.live_bytes.low >>> 0, message.live_bytes.high >>> 0).toNumber() : message.live_bytes;
                        if (message.live_count != null && message.hasOwnProperty("live_count"))
                            if (typeof message.live_count === "number")
                                object.live_count = options.longs === String ? String(message.live_count) : message.live_count;
                            else
                                object.live_count = options.longs === String ? $util.Long.prototype.toString.call(message.live_count) : options.longs === Number ? new $util.LongBits(message.live_count.low >>> 0, message.live_count.high >>> 0).toNumber() : message.live_count;
                        if (message.key_bytes != null && message.hasOwnProperty("key_bytes"))
                            if (typeof message.key_bytes === "number")
                                object.key_bytes = options.longs === String ? String(message.key_bytes) : message.key_bytes;
                            else
                                object.key_bytes = options.longs === String ? $util.Long.prototype.toString.call(message.key_bytes) : options.longs === Number ? new $util.LongBits(message.key_bytes.low >>> 0, message.key_bytes.high >>> 0).toNumber() : message.key_bytes;
                        if (message.key_count != null && message.hasOwnProperty("key_count"))
                            if (typeof message.key_count === "number")
                                object.key_count = options.longs === String ? String(message.key_count) : message.key_count;
                            else
                                object.key_count = options.longs === String ? $util.Long.prototype.toString.call(message.key_count) : options.longs === Number ? new $util.LongBits(message.key_count.low >>> 0, message.key_count.high >>> 0).toNumber() : message.key_count;
                        if (message.val_bytes != null && message.hasOwnProperty("val_bytes"))
                            if (typeof message.val_bytes === "number")
                                object.val_bytes = options.longs === String ? String(message.val_bytes) : message.val_bytes;
                            else
                                object.val_bytes = options.longs === String ? $util.Long.prototype.toString.call(message.val_bytes) : options.longs === Number ? new $util.LongBits(message.val_bytes.low >>> 0, message.val_bytes.high >>> 0).toNumber() : message.val_bytes;
                        if (message.val_count != null && message.hasOwnProperty("val_count"))
                            if (typeof message.val_count === "number")
                                object.val_count = options.longs === String ? String(message.val_count) : message.val_count;
                            else
                                object.val_count = options.longs === String ? $util.Long.prototype.toString.call(message.val_count) : options.longs === Number ? new $util.LongBits(message.val_count.low >>> 0, message.val_count.high >>> 0).toNumber() : message.val_count;
                        if (message.intent_bytes != null && message.hasOwnProperty("intent_bytes"))
                            if (typeof message.intent_bytes === "number")
                                object.intent_bytes = options.longs === String ? String(message.intent_bytes) : message.intent_bytes;
                            else
                                object.intent_bytes = options.longs === String ? $util.Long.prototype.toString.call(message.intent_bytes) : options.longs === Number ? new $util.LongBits(message.intent_bytes.low >>> 0, message.intent_bytes.high >>> 0).toNumber() : message.intent_bytes;
                        if (message.intent_count != null && message.hasOwnProperty("intent_count"))
                            if (typeof message.intent_count === "number")
                                object.intent_count = options.longs === String ? String(message.intent_count) : message.intent_count;
                            else
                                object.intent_count = options.longs === String ? $util.Long.prototype.toString.call(message.intent_count) : options.longs === Number ? new $util.LongBits(message.intent_count.low >>> 0, message.intent_count.high >>> 0).toNumber() : message.intent_count;
                        if (message.sys_bytes != null && message.hasOwnProperty("sys_bytes"))
                            if (typeof message.sys_bytes === "number")
                                object.sys_bytes = options.longs === String ? String(message.sys_bytes) : message.sys_bytes;
                            else
                                object.sys_bytes = options.longs === String ? $util.Long.prototype.toString.call(message.sys_bytes) : options.longs === Number ? new $util.LongBits(message.sys_bytes.low >>> 0, message.sys_bytes.high >>> 0).toNumber() : message.sys_bytes;
                        if (message.sys_count != null && message.hasOwnProperty("sys_count"))
                            if (typeof message.sys_count === "number")
                                object.sys_count = options.longs === String ? String(message.sys_count) : message.sys_count;
                            else
                                object.sys_count = options.longs === String ? $util.Long.prototype.toString.call(message.sys_count) : options.longs === Number ? new $util.LongBits(message.sys_count.low >>> 0, message.sys_count.high >>> 0).toNumber() : message.sys_count;
                        if (message.contains_estimates != null && message.hasOwnProperty("contains_estimates"))
                            object.contains_estimates = message.contains_estimates;
                        return object;
                    };

                    /**
                     * Creates a plain object from this MVCCStats message. Also converts values to other types if specified.
                     * @param {$protobuf.ConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    MVCCStats.prototype.toObject = function toObject(options) {
                        return this.constructor.toObject(this, options);
                    };

                    /**
                     * Converts this MVCCStats to JSON.
                     * @returns {Object.<string,*>} JSON object
                     */
                    MVCCStats.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return MVCCStats;
                })();

                return enginepb;
            })();

            return engine;
        })();

        storage.Liveness = (function() {

            /**
             * Properties of a Liveness.
             * @typedef cockroach.storage.Liveness$Properties
             * @type {Object}
             * @property {number} [node_id] Liveness node_id.
             * @property {Long} [epoch] Liveness epoch.
             * @property {cockroach.util.hlc.Timestamp$Properties} [expiration] Liveness expiration.
             * @property {boolean} [draining] Liveness draining.
             */

            /**
             * Constructs a new Liveness.
             * @exports cockroach.storage.Liveness
             * @constructor
             * @param {cockroach.storage.Liveness$Properties=} [properties] Properties to set
             */
            function Liveness(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Liveness node_id.
             * @type {number}
             */
            Liveness.prototype.node_id = 0;

            /**
             * Liveness epoch.
             * @type {Long}
             */
            Liveness.prototype.epoch = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Liveness expiration.
             * @type {(cockroach.util.hlc.Timestamp$Properties|null)}
             */
            Liveness.prototype.expiration = null;

            /**
             * Liveness draining.
             * @type {boolean}
             */
            Liveness.prototype.draining = false;

            /**
             * Creates a new Liveness instance using the specified properties.
             * @param {cockroach.storage.Liveness$Properties=} [properties] Properties to set
             * @returns {cockroach.storage.Liveness} Liveness instance
             */
            Liveness.create = function create(properties) {
                return new Liveness(properties);
            };

            /**
             * Encodes the specified Liveness message. Does not implicitly {@link cockroach.storage.Liveness.verify|verify} messages.
             * @param {cockroach.storage.Liveness$Properties} message Liveness message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Liveness.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.node_id != null && message.hasOwnProperty("node_id"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.node_id);
                if (message.epoch != null && message.hasOwnProperty("epoch"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int64(message.epoch);
                if (message.expiration != null && message.hasOwnProperty("expiration"))
                    $root.cockroach.util.hlc.Timestamp.encode(message.expiration, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.draining != null && message.hasOwnProperty("draining"))
                    writer.uint32(/* id 4, wireType 0 =*/32).bool(message.draining);
                return writer;
            };

            /**
             * Encodes the specified Liveness message, length delimited. Does not implicitly {@link cockroach.storage.Liveness.verify|verify} messages.
             * @param {cockroach.storage.Liveness$Properties} message Liveness message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Liveness.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Liveness message from the specified reader or buffer.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {cockroach.storage.Liveness} Liveness
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Liveness.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.cockroach.storage.Liveness();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.node_id = reader.int32();
                        break;
                    case 2:
                        message.epoch = reader.int64();
                        break;
                    case 3:
                        message.expiration = $root.cockroach.util.hlc.Timestamp.decode(reader, reader.uint32());
                        break;
                    case 4:
                        message.draining = reader.bool();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Liveness message from the specified reader or buffer, length delimited.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {cockroach.storage.Liveness} Liveness
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Liveness.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Liveness message.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            Liveness.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.node_id != null && message.hasOwnProperty("node_id"))
                    if (!$util.isInteger(message.node_id))
                        return "node_id: integer expected";
                if (message.epoch != null && message.hasOwnProperty("epoch"))
                    if (!$util.isInteger(message.epoch) && !(message.epoch && $util.isInteger(message.epoch.low) && $util.isInteger(message.epoch.high)))
                        return "epoch: integer|Long expected";
                if (message.expiration != null && message.hasOwnProperty("expiration")) {
                    let error = $root.cockroach.util.hlc.Timestamp.verify(message.expiration);
                    if (error)
                        return "expiration." + error;
                }
                if (message.draining != null && message.hasOwnProperty("draining"))
                    if (typeof message.draining !== "boolean")
                        return "draining: boolean expected";
                return null;
            };

            /**
             * Creates a Liveness message from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {cockroach.storage.Liveness} Liveness
             */
            Liveness.fromObject = function fromObject(object) {
                if (object instanceof $root.cockroach.storage.Liveness)
                    return object;
                let message = new $root.cockroach.storage.Liveness();
                if (object.node_id != null)
                    message.node_id = object.node_id | 0;
                if (object.epoch != null)
                    if ($util.Long)
                        (message.epoch = $util.Long.fromValue(object.epoch)).unsigned = false;
                    else if (typeof object.epoch === "string")
                        message.epoch = parseInt(object.epoch, 10);
                    else if (typeof object.epoch === "number")
                        message.epoch = object.epoch;
                    else if (typeof object.epoch === "object")
                        message.epoch = new $util.LongBits(object.epoch.low >>> 0, object.epoch.high >>> 0).toNumber();
                if (object.expiration != null) {
                    if (typeof object.expiration !== "object")
                        throw TypeError(".cockroach.storage.Liveness.expiration: object expected");
                    message.expiration = $root.cockroach.util.hlc.Timestamp.fromObject(object.expiration);
                }
                if (object.draining != null)
                    message.draining = Boolean(object.draining);
                return message;
            };

            /**
             * Creates a Liveness message from a plain object. Also converts values to their respective internal types.
             * This is an alias of {@link cockroach.storage.Liveness.fromObject}.
             * @function
             * @param {Object.<string,*>} object Plain object
             * @returns {cockroach.storage.Liveness} Liveness
             */
            Liveness.from = Liveness.fromObject;

            /**
             * Creates a plain object from a Liveness message. Also converts values to other types if specified.
             * @param {cockroach.storage.Liveness} message Liveness
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Liveness.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.node_id = 0;
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, false);
                        object.epoch = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.epoch = options.longs === String ? "0" : 0;
                    object.expiration = null;
                    object.draining = false;
                }
                if (message.node_id != null && message.hasOwnProperty("node_id"))
                    object.node_id = message.node_id;
                if (message.epoch != null && message.hasOwnProperty("epoch"))
                    if (typeof message.epoch === "number")
                        object.epoch = options.longs === String ? String(message.epoch) : message.epoch;
                    else
                        object.epoch = options.longs === String ? $util.Long.prototype.toString.call(message.epoch) : options.longs === Number ? new $util.LongBits(message.epoch.low >>> 0, message.epoch.high >>> 0).toNumber() : message.epoch;
                if (message.expiration != null && message.hasOwnProperty("expiration"))
                    object.expiration = $root.cockroach.util.hlc.Timestamp.toObject(message.expiration, options);
                if (message.draining != null && message.hasOwnProperty("draining"))
                    object.draining = message.draining;
                return object;
            };

            /**
             * Creates a plain object from this Liveness message. Also converts values to other types if specified.
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Liveness.prototype.toObject = function toObject(options) {
                return this.constructor.toObject(this, options);
            };

            /**
             * Converts this Liveness to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            Liveness.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return Liveness;
        })();

        storage.storagebase = (function() {

            /**
             * Namespace storagebase.
             * @exports cockroach.storage.storagebase
             * @namespace
             */
            const storagebase = {};

            storagebase.ReplicaState = (function() {

                /**
                 * Properties of a ReplicaState.
                 * @typedef cockroach.storage.storagebase.ReplicaState$Properties
                 * @type {Object}
                 * @property {Long} [raft_applied_index] ReplicaState raft_applied_index.
                 * @property {Long} [lease_applied_index] ReplicaState lease_applied_index.
                 * @property {cockroach.roachpb.RangeDescriptor$Properties} [desc] ReplicaState desc.
                 * @property {cockroach.roachpb.Lease$Properties} [lease] ReplicaState lease.
                 * @property {cockroach.roachpb.RaftTruncatedState$Properties} [truncated_state] ReplicaState truncated_state.
                 * @property {cockroach.util.hlc.Timestamp$Properties} [gc_threshold] ReplicaState gc_threshold.
                 * @property {cockroach.storage.engine.enginepb.MVCCStats$Properties} [stats] ReplicaState stats.
                 * @property {cockroach.util.hlc.Timestamp$Properties} [txn_span_gc_threshold] ReplicaState txn_span_gc_threshold.
                 */

                /**
                 * Constructs a new ReplicaState.
                 * @exports cockroach.storage.storagebase.ReplicaState
                 * @constructor
                 * @param {cockroach.storage.storagebase.ReplicaState$Properties=} [properties] Properties to set
                 */
                function ReplicaState(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * ReplicaState raft_applied_index.
                 * @type {Long}
                 */
                ReplicaState.prototype.raft_applied_index = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

                /**
                 * ReplicaState lease_applied_index.
                 * @type {Long}
                 */
                ReplicaState.prototype.lease_applied_index = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

                /**
                 * ReplicaState desc.
                 * @type {(cockroach.roachpb.RangeDescriptor$Properties|null)}
                 */
                ReplicaState.prototype.desc = null;

                /**
                 * ReplicaState lease.
                 * @type {(cockroach.roachpb.Lease$Properties|null)}
                 */
                ReplicaState.prototype.lease = null;

                /**
                 * ReplicaState truncated_state.
                 * @type {(cockroach.roachpb.RaftTruncatedState$Properties|null)}
                 */
                ReplicaState.prototype.truncated_state = null;

                /**
                 * ReplicaState gc_threshold.
                 * @type {(cockroach.util.hlc.Timestamp$Properties|null)}
                 */
                ReplicaState.prototype.gc_threshold = null;

                /**
                 * ReplicaState stats.
                 * @type {(cockroach.storage.engine.enginepb.MVCCStats$Properties|null)}
                 */
                ReplicaState.prototype.stats = null;

                /**
                 * ReplicaState txn_span_gc_threshold.
                 * @type {(cockroach.util.hlc.Timestamp$Properties|null)}
                 */
                ReplicaState.prototype.txn_span_gc_threshold = null;

                /**
                 * Creates a new ReplicaState instance using the specified properties.
                 * @param {cockroach.storage.storagebase.ReplicaState$Properties=} [properties] Properties to set
                 * @returns {cockroach.storage.storagebase.ReplicaState} ReplicaState instance
                 */
                ReplicaState.create = function create(properties) {
                    return new ReplicaState(properties);
                };

                /**
                 * Encodes the specified ReplicaState message. Does not implicitly {@link cockroach.storage.storagebase.ReplicaState.verify|verify} messages.
                 * @param {cockroach.storage.storagebase.ReplicaState$Properties} message ReplicaState message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ReplicaState.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.raft_applied_index != null && message.hasOwnProperty("raft_applied_index"))
                        writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.raft_applied_index);
                    if (message.lease_applied_index != null && message.hasOwnProperty("lease_applied_index"))
                        writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.lease_applied_index);
                    if (message.desc != null && message.hasOwnProperty("desc"))
                        $root.cockroach.roachpb.RangeDescriptor.encode(message.desc, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    if (message.lease != null && message.hasOwnProperty("lease"))
                        $root.cockroach.roachpb.Lease.encode(message.lease, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                    if (message.truncated_state != null && message.hasOwnProperty("truncated_state"))
                        $root.cockroach.roachpb.RaftTruncatedState.encode(message.truncated_state, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                    if (message.gc_threshold != null && message.hasOwnProperty("gc_threshold"))
                        $root.cockroach.util.hlc.Timestamp.encode(message.gc_threshold, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                    if (message.stats != null && message.hasOwnProperty("stats"))
                        $root.cockroach.storage.engine.enginepb.MVCCStats.encode(message.stats, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                    if (message.txn_span_gc_threshold != null && message.hasOwnProperty("txn_span_gc_threshold"))
                        $root.cockroach.util.hlc.Timestamp.encode(message.txn_span_gc_threshold, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified ReplicaState message, length delimited. Does not implicitly {@link cockroach.storage.storagebase.ReplicaState.verify|verify} messages.
                 * @param {cockroach.storage.storagebase.ReplicaState$Properties} message ReplicaState message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ReplicaState.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a ReplicaState message from the specified reader or buffer.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {cockroach.storage.storagebase.ReplicaState} ReplicaState
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ReplicaState.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.cockroach.storage.storagebase.ReplicaState();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.raft_applied_index = reader.uint64();
                            break;
                        case 2:
                            message.lease_applied_index = reader.uint64();
                            break;
                        case 3:
                            message.desc = $root.cockroach.roachpb.RangeDescriptor.decode(reader, reader.uint32());
                            break;
                        case 4:
                            message.lease = $root.cockroach.roachpb.Lease.decode(reader, reader.uint32());
                            break;
                        case 5:
                            message.truncated_state = $root.cockroach.roachpb.RaftTruncatedState.decode(reader, reader.uint32());
                            break;
                        case 6:
                            message.gc_threshold = $root.cockroach.util.hlc.Timestamp.decode(reader, reader.uint32());
                            break;
                        case 7:
                            message.stats = $root.cockroach.storage.engine.enginepb.MVCCStats.decode(reader, reader.uint32());
                            break;
                        case 9:
                            message.txn_span_gc_threshold = $root.cockroach.util.hlc.Timestamp.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a ReplicaState message from the specified reader or buffer, length delimited.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {cockroach.storage.storagebase.ReplicaState} ReplicaState
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ReplicaState.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a ReplicaState message.
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {?string} `null` if valid, otherwise the reason why it is not
                 */
                ReplicaState.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.raft_applied_index != null && message.hasOwnProperty("raft_applied_index"))
                        if (!$util.isInteger(message.raft_applied_index) && !(message.raft_applied_index && $util.isInteger(message.raft_applied_index.low) && $util.isInteger(message.raft_applied_index.high)))
                            return "raft_applied_index: integer|Long expected";
                    if (message.lease_applied_index != null && message.hasOwnProperty("lease_applied_index"))
                        if (!$util.isInteger(message.lease_applied_index) && !(message.lease_applied_index && $util.isInteger(message.lease_applied_index.low) && $util.isInteger(message.lease_applied_index.high)))
                            return "lease_applied_index: integer|Long expected";
                    if (message.desc != null && message.hasOwnProperty("desc")) {
                        let error = $root.cockroach.roachpb.RangeDescriptor.verify(message.desc);
                        if (error)
                            return "desc." + error;
                    }
                    if (message.lease != null && message.hasOwnProperty("lease")) {
                        let error = $root.cockroach.roachpb.Lease.verify(message.lease);
                        if (error)
                            return "lease." + error;
                    }
                    if (message.truncated_state != null && message.hasOwnProperty("truncated_state")) {
                        let error = $root.cockroach.roachpb.RaftTruncatedState.verify(message.truncated_state);
                        if (error)
                            return "truncated_state." + error;
                    }
                    if (message.gc_threshold != null && message.hasOwnProperty("gc_threshold")) {
                        let error = $root.cockroach.util.hlc.Timestamp.verify(message.gc_threshold);
                        if (error)
                            return "gc_threshold." + error;
                    }
                    if (message.stats != null && message.hasOwnProperty("stats")) {
                        let error = $root.cockroach.storage.engine.enginepb.MVCCStats.verify(message.stats);
                        if (error)
                            return "stats." + error;
                    }
                    if (message.txn_span_gc_threshold != null && message.hasOwnProperty("txn_span_gc_threshold")) {
                        let error = $root.cockroach.util.hlc.Timestamp.verify(message.txn_span_gc_threshold);
                        if (error)
                            return "txn_span_gc_threshold." + error;
                    }
                    return null;
                };

                /**
                 * Creates a ReplicaState message from a plain object. Also converts values to their respective internal types.
                 * @param {Object.<string,*>} object Plain object
                 * @returns {cockroach.storage.storagebase.ReplicaState} ReplicaState
                 */
                ReplicaState.fromObject = function fromObject(object) {
                    if (object instanceof $root.cockroach.storage.storagebase.ReplicaState)
                        return object;
                    let message = new $root.cockroach.storage.storagebase.ReplicaState();
                    if (object.raft_applied_index != null)
                        if ($util.Long)
                            (message.raft_applied_index = $util.Long.fromValue(object.raft_applied_index)).unsigned = true;
                        else if (typeof object.raft_applied_index === "string")
                            message.raft_applied_index = parseInt(object.raft_applied_index, 10);
                        else if (typeof object.raft_applied_index === "number")
                            message.raft_applied_index = object.raft_applied_index;
                        else if (typeof object.raft_applied_index === "object")
                            message.raft_applied_index = new $util.LongBits(object.raft_applied_index.low >>> 0, object.raft_applied_index.high >>> 0).toNumber(true);
                    if (object.lease_applied_index != null)
                        if ($util.Long)
                            (message.lease_applied_index = $util.Long.fromValue(object.lease_applied_index)).unsigned = true;
                        else if (typeof object.lease_applied_index === "string")
                            message.lease_applied_index = parseInt(object.lease_applied_index, 10);
                        else if (typeof object.lease_applied_index === "number")
                            message.lease_applied_index = object.lease_applied_index;
                        else if (typeof object.lease_applied_index === "object")
                            message.lease_applied_index = new $util.LongBits(object.lease_applied_index.low >>> 0, object.lease_applied_index.high >>> 0).toNumber(true);
                    if (object.desc != null) {
                        if (typeof object.desc !== "object")
                            throw TypeError(".cockroach.storage.storagebase.ReplicaState.desc: object expected");
                        message.desc = $root.cockroach.roachpb.RangeDescriptor.fromObject(object.desc);
                    }
                    if (object.lease != null) {
                        if (typeof object.lease !== "object")
                            throw TypeError(".cockroach.storage.storagebase.ReplicaState.lease: object expected");
                        message.lease = $root.cockroach.roachpb.Lease.fromObject(object.lease);
                    }
                    if (object.truncated_state != null) {
                        if (typeof object.truncated_state !== "object")
                            throw TypeError(".cockroach.storage.storagebase.ReplicaState.truncated_state: object expected");
                        message.truncated_state = $root.cockroach.roachpb.RaftTruncatedState.fromObject(object.truncated_state);
                    }
                    if (object.gc_threshold != null) {
                        if (typeof object.gc_threshold !== "object")
                            throw TypeError(".cockroach.storage.storagebase.ReplicaState.gc_threshold: object expected");
                        message.gc_threshold = $root.cockroach.util.hlc.Timestamp.fromObject(object.gc_threshold);
                    }
                    if (object.stats != null) {
                        if (typeof object.stats !== "object")
                            throw TypeError(".cockroach.storage.storagebase.ReplicaState.stats: object expected");
                        message.stats = $root.cockroach.storage.engine.enginepb.MVCCStats.fromObject(object.stats);
                    }
                    if (object.txn_span_gc_threshold != null) {
                        if (typeof object.txn_span_gc_threshold !== "object")
                            throw TypeError(".cockroach.storage.storagebase.ReplicaState.txn_span_gc_threshold: object expected");
                        message.txn_span_gc_threshold = $root.cockroach.util.hlc.Timestamp.fromObject(object.txn_span_gc_threshold);
                    }
                    return message;
                };

                /**
                 * Creates a ReplicaState message from a plain object. Also converts values to their respective internal types.
                 * This is an alias of {@link cockroach.storage.storagebase.ReplicaState.fromObject}.
                 * @function
                 * @param {Object.<string,*>} object Plain object
                 * @returns {cockroach.storage.storagebase.ReplicaState} ReplicaState
                 */
                ReplicaState.from = ReplicaState.fromObject;

                /**
                 * Creates a plain object from a ReplicaState message. Also converts values to other types if specified.
                 * @param {cockroach.storage.storagebase.ReplicaState} message ReplicaState
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ReplicaState.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        if ($util.Long) {
                            let long = new $util.Long(0, 0, true);
                            object.raft_applied_index = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.raft_applied_index = options.longs === String ? "0" : 0;
                        if ($util.Long) {
                            let long = new $util.Long(0, 0, true);
                            object.lease_applied_index = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.lease_applied_index = options.longs === String ? "0" : 0;
                        object.desc = null;
                        object.lease = null;
                        object.truncated_state = null;
                        object.gc_threshold = null;
                        object.stats = null;
                        object.txn_span_gc_threshold = null;
                    }
                    if (message.raft_applied_index != null && message.hasOwnProperty("raft_applied_index"))
                        if (typeof message.raft_applied_index === "number")
                            object.raft_applied_index = options.longs === String ? String(message.raft_applied_index) : message.raft_applied_index;
                        else
                            object.raft_applied_index = options.longs === String ? $util.Long.prototype.toString.call(message.raft_applied_index) : options.longs === Number ? new $util.LongBits(message.raft_applied_index.low >>> 0, message.raft_applied_index.high >>> 0).toNumber(true) : message.raft_applied_index;
                    if (message.lease_applied_index != null && message.hasOwnProperty("lease_applied_index"))
                        if (typeof message.lease_applied_index === "number")
                            object.lease_applied_index = options.longs === String ? String(message.lease_applied_index) : message.lease_applied_index;
                        else
                            object.lease_applied_index = options.longs === String ? $util.Long.prototype.toString.call(message.lease_applied_index) : options.longs === Number ? new $util.LongBits(message.lease_applied_index.low >>> 0, message.lease_applied_index.high >>> 0).toNumber(true) : message.lease_applied_index;
                    if (message.desc != null && message.hasOwnProperty("desc"))
                        object.desc = $root.cockroach.roachpb.RangeDescriptor.toObject(message.desc, options);
                    if (message.lease != null && message.hasOwnProperty("lease"))
                        object.lease = $root.cockroach.roachpb.Lease.toObject(message.lease, options);
                    if (message.truncated_state != null && message.hasOwnProperty("truncated_state"))
                        object.truncated_state = $root.cockroach.roachpb.RaftTruncatedState.toObject(message.truncated_state, options);
                    if (message.gc_threshold != null && message.hasOwnProperty("gc_threshold"))
                        object.gc_threshold = $root.cockroach.util.hlc.Timestamp.toObject(message.gc_threshold, options);
                    if (message.stats != null && message.hasOwnProperty("stats"))
                        object.stats = $root.cockroach.storage.engine.enginepb.MVCCStats.toObject(message.stats, options);
                    if (message.txn_span_gc_threshold != null && message.hasOwnProperty("txn_span_gc_threshold"))
                        object.txn_span_gc_threshold = $root.cockroach.util.hlc.Timestamp.toObject(message.txn_span_gc_threshold, options);
                    return object;
                };

                /**
                 * Creates a plain object from this ReplicaState message. Also converts values to other types if specified.
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ReplicaState.prototype.toObject = function toObject(options) {
                    return this.constructor.toObject(this, options);
                };

                /**
                 * Converts this ReplicaState to JSON.
                 * @returns {Object.<string,*>} JSON object
                 */
                ReplicaState.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return ReplicaState;
            })();

            storagebase.RangeInfo = (function() {

                /**
                 * Properties of a RangeInfo.
                 * @typedef cockroach.storage.storagebase.RangeInfo$Properties
                 * @type {Object}
                 * @property {cockroach.storage.storagebase.ReplicaState$Properties} [state] RangeInfo state.
                 * @property {Long} [lastIndex] RangeInfo lastIndex.
                 * @property {Long} [num_pending] RangeInfo num_pending.
                 * @property {Long} [num_dropped] RangeInfo num_dropped.
                 * @property {Long} [raft_log_size] RangeInfo raft_log_size.
                 */

                /**
                 * Constructs a new RangeInfo.
                 * @exports cockroach.storage.storagebase.RangeInfo
                 * @constructor
                 * @param {cockroach.storage.storagebase.RangeInfo$Properties=} [properties] Properties to set
                 */
                function RangeInfo(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * RangeInfo state.
                 * @type {(cockroach.storage.storagebase.ReplicaState$Properties|null)}
                 */
                RangeInfo.prototype.state = null;

                /**
                 * RangeInfo lastIndex.
                 * @type {Long}
                 */
                RangeInfo.prototype.lastIndex = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

                /**
                 * RangeInfo num_pending.
                 * @type {Long}
                 */
                RangeInfo.prototype.num_pending = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

                /**
                 * RangeInfo num_dropped.
                 * @type {Long}
                 */
                RangeInfo.prototype.num_dropped = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

                /**
                 * RangeInfo raft_log_size.
                 * @type {Long}
                 */
                RangeInfo.prototype.raft_log_size = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

                /**
                 * Creates a new RangeInfo instance using the specified properties.
                 * @param {cockroach.storage.storagebase.RangeInfo$Properties=} [properties] Properties to set
                 * @returns {cockroach.storage.storagebase.RangeInfo} RangeInfo instance
                 */
                RangeInfo.create = function create(properties) {
                    return new RangeInfo(properties);
                };

                /**
                 * Encodes the specified RangeInfo message. Does not implicitly {@link cockroach.storage.storagebase.RangeInfo.verify|verify} messages.
                 * @param {cockroach.storage.storagebase.RangeInfo$Properties} message RangeInfo message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                RangeInfo.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.state != null && message.hasOwnProperty("state"))
                        $root.cockroach.storage.storagebase.ReplicaState.encode(message.state, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.lastIndex != null && message.hasOwnProperty("lastIndex"))
                        writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.lastIndex);
                    if (message.num_pending != null && message.hasOwnProperty("num_pending"))
                        writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.num_pending);
                    if (message.num_dropped != null && message.hasOwnProperty("num_dropped"))
                        writer.uint32(/* id 5, wireType 0 =*/40).uint64(message.num_dropped);
                    if (message.raft_log_size != null && message.hasOwnProperty("raft_log_size"))
                        writer.uint32(/* id 6, wireType 0 =*/48).int64(message.raft_log_size);
                    return writer;
                };

                /**
                 * Encodes the specified RangeInfo message, length delimited. Does not implicitly {@link cockroach.storage.storagebase.RangeInfo.verify|verify} messages.
                 * @param {cockroach.storage.storagebase.RangeInfo$Properties} message RangeInfo message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                RangeInfo.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a RangeInfo message from the specified reader or buffer.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {cockroach.storage.storagebase.RangeInfo} RangeInfo
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                RangeInfo.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.cockroach.storage.storagebase.RangeInfo();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.state = $root.cockroach.storage.storagebase.ReplicaState.decode(reader, reader.uint32());
                            break;
                        case 2:
                            message.lastIndex = reader.uint64();
                            break;
                        case 3:
                            message.num_pending = reader.uint64();
                            break;
                        case 5:
                            message.num_dropped = reader.uint64();
                            break;
                        case 6:
                            message.raft_log_size = reader.int64();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a RangeInfo message from the specified reader or buffer, length delimited.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {cockroach.storage.storagebase.RangeInfo} RangeInfo
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                RangeInfo.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a RangeInfo message.
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {?string} `null` if valid, otherwise the reason why it is not
                 */
                RangeInfo.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.state != null && message.hasOwnProperty("state")) {
                        let error = $root.cockroach.storage.storagebase.ReplicaState.verify(message.state);
                        if (error)
                            return "state." + error;
                    }
                    if (message.lastIndex != null && message.hasOwnProperty("lastIndex"))
                        if (!$util.isInteger(message.lastIndex) && !(message.lastIndex && $util.isInteger(message.lastIndex.low) && $util.isInteger(message.lastIndex.high)))
                            return "lastIndex: integer|Long expected";
                    if (message.num_pending != null && message.hasOwnProperty("num_pending"))
                        if (!$util.isInteger(message.num_pending) && !(message.num_pending && $util.isInteger(message.num_pending.low) && $util.isInteger(message.num_pending.high)))
                            return "num_pending: integer|Long expected";
                    if (message.num_dropped != null && message.hasOwnProperty("num_dropped"))
                        if (!$util.isInteger(message.num_dropped) && !(message.num_dropped && $util.isInteger(message.num_dropped.low) && $util.isInteger(message.num_dropped.high)))
                            return "num_dropped: integer|Long expected";
                    if (message.raft_log_size != null && message.hasOwnProperty("raft_log_size"))
                        if (!$util.isInteger(message.raft_log_size) && !(message.raft_log_size && $util.isInteger(message.raft_log_size.low) && $util.isInteger(message.raft_log_size.high)))
                            return "raft_log_size: integer|Long expected";
                    return null;
                };

                /**
                 * Creates a RangeInfo message from a plain object. Also converts values to their respective internal types.
                 * @param {Object.<string,*>} object Plain object
                 * @returns {cockroach.storage.storagebase.RangeInfo} RangeInfo
                 */
                RangeInfo.fromObject = function fromObject(object) {
                    if (object instanceof $root.cockroach.storage.storagebase.RangeInfo)
                        return object;
                    let message = new $root.cockroach.storage.storagebase.RangeInfo();
                    if (object.state != null) {
                        if (typeof object.state !== "object")
                            throw TypeError(".cockroach.storage.storagebase.RangeInfo.state: object expected");
                        message.state = $root.cockroach.storage.storagebase.ReplicaState.fromObject(object.state);
                    }
                    if (object.lastIndex != null)
                        if ($util.Long)
                            (message.lastIndex = $util.Long.fromValue(object.lastIndex)).unsigned = true;
                        else if (typeof object.lastIndex === "string")
                            message.lastIndex = parseInt(object.lastIndex, 10);
                        else if (typeof object.lastIndex === "number")
                            message.lastIndex = object.lastIndex;
                        else if (typeof object.lastIndex === "object")
                            message.lastIndex = new $util.LongBits(object.lastIndex.low >>> 0, object.lastIndex.high >>> 0).toNumber(true);
                    if (object.num_pending != null)
                        if ($util.Long)
                            (message.num_pending = $util.Long.fromValue(object.num_pending)).unsigned = true;
                        else if (typeof object.num_pending === "string")
                            message.num_pending = parseInt(object.num_pending, 10);
                        else if (typeof object.num_pending === "number")
                            message.num_pending = object.num_pending;
                        else if (typeof object.num_pending === "object")
                            message.num_pending = new $util.LongBits(object.num_pending.low >>> 0, object.num_pending.high >>> 0).toNumber(true);
                    if (object.num_dropped != null)
                        if ($util.Long)
                            (message.num_dropped = $util.Long.fromValue(object.num_dropped)).unsigned = true;
                        else if (typeof object.num_dropped === "string")
                            message.num_dropped = parseInt(object.num_dropped, 10);
                        else if (typeof object.num_dropped === "number")
                            message.num_dropped = object.num_dropped;
                        else if (typeof object.num_dropped === "object")
                            message.num_dropped = new $util.LongBits(object.num_dropped.low >>> 0, object.num_dropped.high >>> 0).toNumber(true);
                    if (object.raft_log_size != null)
                        if ($util.Long)
                            (message.raft_log_size = $util.Long.fromValue(object.raft_log_size)).unsigned = false;
                        else if (typeof object.raft_log_size === "string")
                            message.raft_log_size = parseInt(object.raft_log_size, 10);
                        else if (typeof object.raft_log_size === "number")
                            message.raft_log_size = object.raft_log_size;
                        else if (typeof object.raft_log_size === "object")
                            message.raft_log_size = new $util.LongBits(object.raft_log_size.low >>> 0, object.raft_log_size.high >>> 0).toNumber();
                    return message;
                };

                /**
                 * Creates a RangeInfo message from a plain object. Also converts values to their respective internal types.
                 * This is an alias of {@link cockroach.storage.storagebase.RangeInfo.fromObject}.
                 * @function
                 * @param {Object.<string,*>} object Plain object
                 * @returns {cockroach.storage.storagebase.RangeInfo} RangeInfo
                 */
                RangeInfo.from = RangeInfo.fromObject;

                /**
                 * Creates a plain object from a RangeInfo message. Also converts values to other types if specified.
                 * @param {cockroach.storage.storagebase.RangeInfo} message RangeInfo
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                RangeInfo.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.state = null;
                        if ($util.Long) {
                            let long = new $util.Long(0, 0, true);
                            object.lastIndex = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.lastIndex = options.longs === String ? "0" : 0;
                        if ($util.Long) {
                            let long = new $util.Long(0, 0, true);
                            object.num_pending = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.num_pending = options.longs === String ? "0" : 0;
                        if ($util.Long) {
                            let long = new $util.Long(0, 0, true);
                            object.num_dropped = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.num_dropped = options.longs === String ? "0" : 0;
                        if ($util.Long) {
                            let long = new $util.Long(0, 0, false);
                            object.raft_log_size = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.raft_log_size = options.longs === String ? "0" : 0;
                    }
                    if (message.state != null && message.hasOwnProperty("state"))
                        object.state = $root.cockroach.storage.storagebase.ReplicaState.toObject(message.state, options);
                    if (message.lastIndex != null && message.hasOwnProperty("lastIndex"))
                        if (typeof message.lastIndex === "number")
                            object.lastIndex = options.longs === String ? String(message.lastIndex) : message.lastIndex;
                        else
                            object.lastIndex = options.longs === String ? $util.Long.prototype.toString.call(message.lastIndex) : options.longs === Number ? new $util.LongBits(message.lastIndex.low >>> 0, message.lastIndex.high >>> 0).toNumber(true) : message.lastIndex;
                    if (message.num_pending != null && message.hasOwnProperty("num_pending"))
                        if (typeof message.num_pending === "number")
                            object.num_pending = options.longs === String ? String(message.num_pending) : message.num_pending;
                        else
                            object.num_pending = options.longs === String ? $util.Long.prototype.toString.call(message.num_pending) : options.longs === Number ? new $util.LongBits(message.num_pending.low >>> 0, message.num_pending.high >>> 0).toNumber(true) : message.num_pending;
                    if (message.num_dropped != null && message.hasOwnProperty("num_dropped"))
                        if (typeof message.num_dropped === "number")
                            object.num_dropped = options.longs === String ? String(message.num_dropped) : message.num_dropped;
                        else
                            object.num_dropped = options.longs === String ? $util.Long.prototype.toString.call(message.num_dropped) : options.longs === Number ? new $util.LongBits(message.num_dropped.low >>> 0, message.num_dropped.high >>> 0).toNumber(true) : message.num_dropped;
                    if (message.raft_log_size != null && message.hasOwnProperty("raft_log_size"))
                        if (typeof message.raft_log_size === "number")
                            object.raft_log_size = options.longs === String ? String(message.raft_log_size) : message.raft_log_size;
                        else
                            object.raft_log_size = options.longs === String ? $util.Long.prototype.toString.call(message.raft_log_size) : options.longs === Number ? new $util.LongBits(message.raft_log_size.low >>> 0, message.raft_log_size.high >>> 0).toNumber() : message.raft_log_size;
                    return object;
                };

                /**
                 * Creates a plain object from this RangeInfo message. Also converts values to other types if specified.
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                RangeInfo.prototype.toObject = function toObject(options) {
                    return this.constructor.toObject(this, options);
                };

                /**
                 * Converts this RangeInfo to JSON.
                 * @returns {Object.<string,*>} JSON object
                 */
                RangeInfo.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return RangeInfo;
            })();

            return storagebase;
        })();

        return storage;
    })();

    cockroach.build = (function() {

        /**
         * Namespace build.
         * @exports cockroach.build
         * @namespace
         */
        const build = {};

        build.Info = (function() {

            /**
             * Properties of an Info.
             * @typedef cockroach.build.Info$Properties
             * @type {Object}
             * @property {string} [go_version] Info go_version.
             * @property {string} [tag] Info tag.
             * @property {string} [time] Info time.
             * @property {string} [revision] Info revision.
             * @property {string} [cgo_compiler] Info cgo_compiler.
             * @property {string} [platform] Info platform.
             * @property {string} [distribution] Info distribution.
             * @property {string} [type] Info type.
             * @property {string} [dependencies] Info dependencies.
             */

            /**
             * Constructs a new Info.
             * @exports cockroach.build.Info
             * @constructor
             * @param {cockroach.build.Info$Properties=} [properties] Properties to set
             */
            function Info(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Info go_version.
             * @type {string}
             */
            Info.prototype.go_version = "";

            /**
             * Info tag.
             * @type {string}
             */
            Info.prototype.tag = "";

            /**
             * Info time.
             * @type {string}
             */
            Info.prototype.time = "";

            /**
             * Info revision.
             * @type {string}
             */
            Info.prototype.revision = "";

            /**
             * Info cgo_compiler.
             * @type {string}
             */
            Info.prototype.cgo_compiler = "";

            /**
             * Info platform.
             * @type {string}
             */
            Info.prototype.platform = "";

            /**
             * Info distribution.
             * @type {string}
             */
            Info.prototype.distribution = "";

            /**
             * Info type.
             * @type {string}
             */
            Info.prototype.type = "";

            /**
             * Info dependencies.
             * @type {string}
             */
            Info.prototype.dependencies = "";

            /**
             * Creates a new Info instance using the specified properties.
             * @param {cockroach.build.Info$Properties=} [properties] Properties to set
             * @returns {cockroach.build.Info} Info instance
             */
            Info.create = function create(properties) {
                return new Info(properties);
            };

            /**
             * Encodes the specified Info message. Does not implicitly {@link cockroach.build.Info.verify|verify} messages.
             * @param {cockroach.build.Info$Properties} message Info message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Info.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.go_version != null && message.hasOwnProperty("go_version"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.go_version);
                if (message.tag != null && message.hasOwnProperty("tag"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.tag);
                if (message.time != null && message.hasOwnProperty("time"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.time);
                if (message.revision != null && message.hasOwnProperty("revision"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.revision);
                if (message.cgo_compiler != null && message.hasOwnProperty("cgo_compiler"))
                    writer.uint32(/* id 5, wireType 2 =*/42).string(message.cgo_compiler);
                if (message.platform != null && message.hasOwnProperty("platform"))
                    writer.uint32(/* id 6, wireType 2 =*/50).string(message.platform);
                if (message.distribution != null && message.hasOwnProperty("distribution"))
                    writer.uint32(/* id 7, wireType 2 =*/58).string(message.distribution);
                if (message.type != null && message.hasOwnProperty("type"))
                    writer.uint32(/* id 8, wireType 2 =*/66).string(message.type);
                if (message.dependencies != null && message.hasOwnProperty("dependencies"))
                    writer.uint32(/* id 10000, wireType 2 =*/80002).string(message.dependencies);
                return writer;
            };

            /**
             * Encodes the specified Info message, length delimited. Does not implicitly {@link cockroach.build.Info.verify|verify} messages.
             * @param {cockroach.build.Info$Properties} message Info message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Info.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an Info message from the specified reader or buffer.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {cockroach.build.Info} Info
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Info.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.cockroach.build.Info();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.go_version = reader.string();
                        break;
                    case 2:
                        message.tag = reader.string();
                        break;
                    case 3:
                        message.time = reader.string();
                        break;
                    case 4:
                        message.revision = reader.string();
                        break;
                    case 5:
                        message.cgo_compiler = reader.string();
                        break;
                    case 6:
                        message.platform = reader.string();
                        break;
                    case 7:
                        message.distribution = reader.string();
                        break;
                    case 8:
                        message.type = reader.string();
                        break;
                    case 10000:
                        message.dependencies = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an Info message from the specified reader or buffer, length delimited.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {cockroach.build.Info} Info
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Info.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an Info message.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            Info.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.go_version != null && message.hasOwnProperty("go_version"))
                    if (!$util.isString(message.go_version))
                        return "go_version: string expected";
                if (message.tag != null && message.hasOwnProperty("tag"))
                    if (!$util.isString(message.tag))
                        return "tag: string expected";
                if (message.time != null && message.hasOwnProperty("time"))
                    if (!$util.isString(message.time))
                        return "time: string expected";
                if (message.revision != null && message.hasOwnProperty("revision"))
                    if (!$util.isString(message.revision))
                        return "revision: string expected";
                if (message.cgo_compiler != null && message.hasOwnProperty("cgo_compiler"))
                    if (!$util.isString(message.cgo_compiler))
                        return "cgo_compiler: string expected";
                if (message.platform != null && message.hasOwnProperty("platform"))
                    if (!$util.isString(message.platform))
                        return "platform: string expected";
                if (message.distribution != null && message.hasOwnProperty("distribution"))
                    if (!$util.isString(message.distribution))
                        return "distribution: string expected";
                if (message.type != null && message.hasOwnProperty("type"))
                    if (!$util.isString(message.type))
                        return "type: string expected";
                if (message.dependencies != null && message.hasOwnProperty("dependencies"))
                    if (!$util.isString(message.dependencies))
                        return "dependencies: string expected";
                return null;
            };

            /**
             * Creates an Info message from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {cockroach.build.Info} Info
             */
            Info.fromObject = function fromObject(object) {
                if (object instanceof $root.cockroach.build.Info)
                    return object;
                let message = new $root.cockroach.build.Info();
                if (object.go_version != null)
                    message.go_version = String(object.go_version);
                if (object.tag != null)
                    message.tag = String(object.tag);
                if (object.time != null)
                    message.time = String(object.time);
                if (object.revision != null)
                    message.revision = String(object.revision);
                if (object.cgo_compiler != null)
                    message.cgo_compiler = String(object.cgo_compiler);
                if (object.platform != null)
                    message.platform = String(object.platform);
                if (object.distribution != null)
                    message.distribution = String(object.distribution);
                if (object.type != null)
                    message.type = String(object.type);
                if (object.dependencies != null)
                    message.dependencies = String(object.dependencies);
                return message;
            };

            /**
             * Creates an Info message from a plain object. Also converts values to their respective internal types.
             * This is an alias of {@link cockroach.build.Info.fromObject}.
             * @function
             * @param {Object.<string,*>} object Plain object
             * @returns {cockroach.build.Info} Info
             */
            Info.from = Info.fromObject;

            /**
             * Creates a plain object from an Info message. Also converts values to other types if specified.
             * @param {cockroach.build.Info} message Info
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Info.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.go_version = "";
                    object.tag = "";
                    object.time = "";
                    object.revision = "";
                    object.cgo_compiler = "";
                    object.platform = "";
                    object.distribution = "";
                    object.type = "";
                    object.dependencies = "";
                }
                if (message.go_version != null && message.hasOwnProperty("go_version"))
                    object.go_version = message.go_version;
                if (message.tag != null && message.hasOwnProperty("tag"))
                    object.tag = message.tag;
                if (message.time != null && message.hasOwnProperty("time"))
                    object.time = message.time;
                if (message.revision != null && message.hasOwnProperty("revision"))
                    object.revision = message.revision;
                if (message.cgo_compiler != null && message.hasOwnProperty("cgo_compiler"))
                    object.cgo_compiler = message.cgo_compiler;
                if (message.platform != null && message.hasOwnProperty("platform"))
                    object.platform = message.platform;
                if (message.distribution != null && message.hasOwnProperty("distribution"))
                    object.distribution = message.distribution;
                if (message.type != null && message.hasOwnProperty("type"))
                    object.type = message.type;
                if (message.dependencies != null && message.hasOwnProperty("dependencies"))
                    object.dependencies = message.dependencies;
                return object;
            };

            /**
             * Creates a plain object from this Info message. Also converts values to other types if specified.
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Info.prototype.toObject = function toObject(options) {
                return this.constructor.toObject(this, options);
            };

            /**
             * Converts this Info to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            Info.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return Info;
        })();

        return build;
    })();

    cockroach.gossip = (function() {

        /**
         * Namespace gossip.
         * @exports cockroach.gossip
         * @namespace
         */
        const gossip = {};

        gossip.BootstrapInfo = (function() {

            /**
             * Properties of a BootstrapInfo.
             * @typedef cockroach.gossip.BootstrapInfo$Properties
             * @type {Object}
             * @property {Array.<cockroach.util.UnresolvedAddr$Properties>} [addresses] BootstrapInfo addresses.
             * @property {cockroach.util.hlc.Timestamp$Properties} [timestamp] BootstrapInfo timestamp.
             */

            /**
             * Constructs a new BootstrapInfo.
             * @exports cockroach.gossip.BootstrapInfo
             * @constructor
             * @param {cockroach.gossip.BootstrapInfo$Properties=} [properties] Properties to set
             */
            function BootstrapInfo(properties) {
                this.addresses = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * BootstrapInfo addresses.
             * @type {Array.<cockroach.util.UnresolvedAddr$Properties>}
             */
            BootstrapInfo.prototype.addresses = $util.emptyArray;

            /**
             * BootstrapInfo timestamp.
             * @type {(cockroach.util.hlc.Timestamp$Properties|null)}
             */
            BootstrapInfo.prototype.timestamp = null;

            /**
             * Creates a new BootstrapInfo instance using the specified properties.
             * @param {cockroach.gossip.BootstrapInfo$Properties=} [properties] Properties to set
             * @returns {cockroach.gossip.BootstrapInfo} BootstrapInfo instance
             */
            BootstrapInfo.create = function create(properties) {
                return new BootstrapInfo(properties);
            };

            /**
             * Encodes the specified BootstrapInfo message. Does not implicitly {@link cockroach.gossip.BootstrapInfo.verify|verify} messages.
             * @param {cockroach.gossip.BootstrapInfo$Properties} message BootstrapInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BootstrapInfo.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.addresses != null && message.addresses.length)
                    for (let i = 0; i < message.addresses.length; ++i)
                        $root.cockroach.util.UnresolvedAddr.encode(message.addresses[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                    $root.cockroach.util.hlc.Timestamp.encode(message.timestamp, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified BootstrapInfo message, length delimited. Does not implicitly {@link cockroach.gossip.BootstrapInfo.verify|verify} messages.
             * @param {cockroach.gossip.BootstrapInfo$Properties} message BootstrapInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BootstrapInfo.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a BootstrapInfo message from the specified reader or buffer.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {cockroach.gossip.BootstrapInfo} BootstrapInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BootstrapInfo.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.cockroach.gossip.BootstrapInfo();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.addresses && message.addresses.length))
                            message.addresses = [];
                        message.addresses.push($root.cockroach.util.UnresolvedAddr.decode(reader, reader.uint32()));
                        break;
                    case 2:
                        message.timestamp = $root.cockroach.util.hlc.Timestamp.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a BootstrapInfo message from the specified reader or buffer, length delimited.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {cockroach.gossip.BootstrapInfo} BootstrapInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BootstrapInfo.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a BootstrapInfo message.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            BootstrapInfo.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.addresses != null && message.hasOwnProperty("addresses")) {
                    if (!Array.isArray(message.addresses))
                        return "addresses: array expected";
                    for (let i = 0; i < message.addresses.length; ++i) {
                        let error = $root.cockroach.util.UnresolvedAddr.verify(message.addresses[i]);
                        if (error)
                            return "addresses." + error;
                    }
                }
                if (message.timestamp != null && message.hasOwnProperty("timestamp")) {
                    let error = $root.cockroach.util.hlc.Timestamp.verify(message.timestamp);
                    if (error)
                        return "timestamp." + error;
                }
                return null;
            };

            /**
             * Creates a BootstrapInfo message from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {cockroach.gossip.BootstrapInfo} BootstrapInfo
             */
            BootstrapInfo.fromObject = function fromObject(object) {
                if (object instanceof $root.cockroach.gossip.BootstrapInfo)
                    return object;
                let message = new $root.cockroach.gossip.BootstrapInfo();
                if (object.addresses) {
                    if (!Array.isArray(object.addresses))
                        throw TypeError(".cockroach.gossip.BootstrapInfo.addresses: array expected");
                    message.addresses = [];
                    for (let i = 0; i < object.addresses.length; ++i) {
                        if (typeof object.addresses[i] !== "object")
                            throw TypeError(".cockroach.gossip.BootstrapInfo.addresses: object expected");
                        message.addresses[i] = $root.cockroach.util.UnresolvedAddr.fromObject(object.addresses[i]);
                    }
                }
                if (object.timestamp != null) {
                    if (typeof object.timestamp !== "object")
                        throw TypeError(".cockroach.gossip.BootstrapInfo.timestamp: object expected");
                    message.timestamp = $root.cockroach.util.hlc.Timestamp.fromObject(object.timestamp);
                }
                return message;
            };

            /**
             * Creates a BootstrapInfo message from a plain object. Also converts values to their respective internal types.
             * This is an alias of {@link cockroach.gossip.BootstrapInfo.fromObject}.
             * @function
             * @param {Object.<string,*>} object Plain object
             * @returns {cockroach.gossip.BootstrapInfo} BootstrapInfo
             */
            BootstrapInfo.from = BootstrapInfo.fromObject;

            /**
             * Creates a plain object from a BootstrapInfo message. Also converts values to other types if specified.
             * @param {cockroach.gossip.BootstrapInfo} message BootstrapInfo
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            BootstrapInfo.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.addresses = [];
                if (options.defaults)
                    object.timestamp = null;
                if (message.addresses && message.addresses.length) {
                    object.addresses = [];
                    for (let j = 0; j < message.addresses.length; ++j)
                        object.addresses[j] = $root.cockroach.util.UnresolvedAddr.toObject(message.addresses[j], options);
                }
                if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                    object.timestamp = $root.cockroach.util.hlc.Timestamp.toObject(message.timestamp, options);
                return object;
            };

            /**
             * Creates a plain object from this BootstrapInfo message. Also converts values to other types if specified.
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            BootstrapInfo.prototype.toObject = function toObject(options) {
                return this.constructor.toObject(this, options);
            };

            /**
             * Converts this BootstrapInfo to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            BootstrapInfo.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return BootstrapInfo;
        })();

        gossip.Request = (function() {

            /**
             * Properties of a Request.
             * @typedef cockroach.gossip.Request$Properties
             * @type {Object}
             * @property {number} [node_id] Request node_id.
             * @property {cockroach.util.UnresolvedAddr$Properties} [addr] Request addr.
             * @property {Object.<string,Long>} [high_water_stamps] Request high_water_stamps.
             * @property {Object.<string,cockroach.gossip.Info$Properties>} [delta] Request delta.
             * @property {Uint8Array} [cluster_id] Request cluster_id.
             */

            /**
             * Constructs a new Request.
             * @exports cockroach.gossip.Request
             * @constructor
             * @param {cockroach.gossip.Request$Properties=} [properties] Properties to set
             */
            function Request(properties) {
                this.high_water_stamps = {};
                this.delta = {};
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Request node_id.
             * @type {number}
             */
            Request.prototype.node_id = 0;

            /**
             * Request addr.
             * @type {(cockroach.util.UnresolvedAddr$Properties|null)}
             */
            Request.prototype.addr = null;

            /**
             * Request high_water_stamps.
             * @type {Object.<string,Long>}
             */
            Request.prototype.high_water_stamps = $util.emptyObject;

            /**
             * Request delta.
             * @type {Object.<string,cockroach.gossip.Info$Properties>}
             */
            Request.prototype.delta = $util.emptyObject;

            /**
             * Request cluster_id.
             * @type {Uint8Array}
             */
            Request.prototype.cluster_id = $util.newBuffer([]);

            /**
             * Creates a new Request instance using the specified properties.
             * @param {cockroach.gossip.Request$Properties=} [properties] Properties to set
             * @returns {cockroach.gossip.Request} Request instance
             */
            Request.create = function create(properties) {
                return new Request(properties);
            };

            /**
             * Encodes the specified Request message. Does not implicitly {@link cockroach.gossip.Request.verify|verify} messages.
             * @param {cockroach.gossip.Request$Properties} message Request message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Request.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.node_id != null && message.hasOwnProperty("node_id"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.node_id);
                if (message.addr != null && message.hasOwnProperty("addr"))
                    $root.cockroach.util.UnresolvedAddr.encode(message.addr, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.high_water_stamps != null && message.hasOwnProperty("high_water_stamps"))
                    for (let keys = Object.keys(message.high_water_stamps), i = 0; i < keys.length; ++i)
                        writer.uint32(/* id 3, wireType 2 =*/26).fork().uint32(/* id 1, wireType 0 =*/8).int32(keys[i]).uint32(/* id 2, wireType 0 =*/16).int64(message.high_water_stamps[keys[i]]).ldelim();
                if (message.delta != null && message.hasOwnProperty("delta"))
                    for (let keys = Object.keys(message.delta), i = 0; i < keys.length; ++i) {
                        writer.uint32(/* id 4, wireType 2 =*/34).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]);
                        $root.cockroach.gossip.Info.encode(message.delta[keys[i]], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim().ldelim();
                    }
                if (message.cluster_id != null && message.hasOwnProperty("cluster_id"))
                    writer.uint32(/* id 5, wireType 2 =*/42).bytes(message.cluster_id);
                return writer;
            };

            /**
             * Encodes the specified Request message, length delimited. Does not implicitly {@link cockroach.gossip.Request.verify|verify} messages.
             * @param {cockroach.gossip.Request$Properties} message Request message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Request.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Request message from the specified reader or buffer.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {cockroach.gossip.Request} Request
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Request.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.cockroach.gossip.Request(), key;
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.node_id = reader.int32();
                        break;
                    case 2:
                        message.addr = $root.cockroach.util.UnresolvedAddr.decode(reader, reader.uint32());
                        break;
                    case 3:
                        reader.skip().pos++;
                        if (message.high_water_stamps === $util.emptyObject)
                            message.high_water_stamps = {};
                        key = reader.int32();
                        reader.pos++;
                        message.high_water_stamps[key] = reader.int64();
                        break;
                    case 4:
                        reader.skip().pos++;
                        if (message.delta === $util.emptyObject)
                            message.delta = {};
                        key = reader.string();
                        reader.pos++;
                        message.delta[key] = $root.cockroach.gossip.Info.decode(reader, reader.uint32());
                        break;
                    case 5:
                        message.cluster_id = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Request message from the specified reader or buffer, length delimited.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {cockroach.gossip.Request} Request
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Request.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Request message.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            Request.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.node_id != null && message.hasOwnProperty("node_id"))
                    if (!$util.isInteger(message.node_id))
                        return "node_id: integer expected";
                if (message.addr != null && message.hasOwnProperty("addr")) {
                    let error = $root.cockroach.util.UnresolvedAddr.verify(message.addr);
                    if (error)
                        return "addr." + error;
                }
                if (message.high_water_stamps != null && message.hasOwnProperty("high_water_stamps")) {
                    if (!$util.isObject(message.high_water_stamps))
                        return "high_water_stamps: object expected";
                    let key = Object.keys(message.high_water_stamps);
                    for (let i = 0; i < key.length; ++i) {
                        if (!$util.key32Re.test(key[i]))
                            return "high_water_stamps: integer key{k:int32} expected";
                        if (!$util.isInteger(message.high_water_stamps[key[i]]) && !(message.high_water_stamps[key[i]] && $util.isInteger(message.high_water_stamps[key[i]].low) && $util.isInteger(message.high_water_stamps[key[i]].high)))
                            return "high_water_stamps: integer|Long{k:int32} expected";
                    }
                }
                if (message.delta != null && message.hasOwnProperty("delta")) {
                    if (!$util.isObject(message.delta))
                        return "delta: object expected";
                    let key = Object.keys(message.delta);
                    for (let i = 0; i < key.length; ++i) {
                        let error = $root.cockroach.gossip.Info.verify(message.delta[key[i]]);
                        if (error)
                            return "delta." + error;
                    }
                }
                if (message.cluster_id != null && message.hasOwnProperty("cluster_id"))
                    if (!(message.cluster_id && typeof message.cluster_id.length === "number" || $util.isString(message.cluster_id)))
                        return "cluster_id: buffer expected";
                return null;
            };

            /**
             * Creates a Request message from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {cockroach.gossip.Request} Request
             */
            Request.fromObject = function fromObject(object) {
                if (object instanceof $root.cockroach.gossip.Request)
                    return object;
                let message = new $root.cockroach.gossip.Request();
                if (object.node_id != null)
                    message.node_id = object.node_id | 0;
                if (object.addr != null) {
                    if (typeof object.addr !== "object")
                        throw TypeError(".cockroach.gossip.Request.addr: object expected");
                    message.addr = $root.cockroach.util.UnresolvedAddr.fromObject(object.addr);
                }
                if (object.high_water_stamps) {
                    if (typeof object.high_water_stamps !== "object")
                        throw TypeError(".cockroach.gossip.Request.high_water_stamps: object expected");
                    message.high_water_stamps = {};
                    for (let keys = Object.keys(object.high_water_stamps), i = 0; i < keys.length; ++i)
                        if ($util.Long)
                            (message.high_water_stamps[keys[i]] = $util.Long.fromValue(object.high_water_stamps[keys[i]])).unsigned = false;
                        else if (typeof object.high_water_stamps[keys[i]] === "string")
                            message.high_water_stamps[keys[i]] = parseInt(object.high_water_stamps[keys[i]], 10);
                        else if (typeof object.high_water_stamps[keys[i]] === "number")
                            message.high_water_stamps[keys[i]] = object.high_water_stamps[keys[i]];
                        else if (typeof object.high_water_stamps[keys[i]] === "object")
                            message.high_water_stamps[keys[i]] = new $util.LongBits(object.high_water_stamps[keys[i]].low >>> 0, object.high_water_stamps[keys[i]].high >>> 0).toNumber();
                }
                if (object.delta) {
                    if (typeof object.delta !== "object")
                        throw TypeError(".cockroach.gossip.Request.delta: object expected");
                    message.delta = {};
                    for (let keys = Object.keys(object.delta), i = 0; i < keys.length; ++i) {
                        if (typeof object.delta[keys[i]] !== "object")
                            throw TypeError(".cockroach.gossip.Request.delta: object expected");
                        message.delta[keys[i]] = $root.cockroach.gossip.Info.fromObject(object.delta[keys[i]]);
                    }
                }
                if (object.cluster_id != null)
                    if (typeof object.cluster_id === "string")
                        $util.base64.decode(object.cluster_id, message.cluster_id = $util.newBuffer($util.base64.length(object.cluster_id)), 0);
                    else if (object.cluster_id.length)
                        message.cluster_id = object.cluster_id;
                return message;
            };

            /**
             * Creates a Request message from a plain object. Also converts values to their respective internal types.
             * This is an alias of {@link cockroach.gossip.Request.fromObject}.
             * @function
             * @param {Object.<string,*>} object Plain object
             * @returns {cockroach.gossip.Request} Request
             */
            Request.from = Request.fromObject;

            /**
             * Creates a plain object from a Request message. Also converts values to other types if specified.
             * @param {cockroach.gossip.Request} message Request
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Request.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.objects || options.defaults) {
                    object.high_water_stamps = {};
                    object.delta = {};
                }
                if (options.defaults) {
                    object.node_id = 0;
                    object.addr = null;
                    object.cluster_id = options.bytes === String ? "" : [];
                }
                if (message.node_id != null && message.hasOwnProperty("node_id"))
                    object.node_id = message.node_id;
                if (message.addr != null && message.hasOwnProperty("addr"))
                    object.addr = $root.cockroach.util.UnresolvedAddr.toObject(message.addr, options);
                let keys2;
                if (message.high_water_stamps && (keys2 = Object.keys(message.high_water_stamps)).length) {
                    object.high_water_stamps = {};
                    for (let j = 0; j < keys2.length; ++j)
                        if (typeof message.high_water_stamps[keys2[j]] === "number")
                            object.high_water_stamps[keys2[j]] = options.longs === String ? String(message.high_water_stamps[keys2[j]]) : message.high_water_stamps[keys2[j]];
                        else
                            object.high_water_stamps[keys2[j]] = options.longs === String ? $util.Long.prototype.toString.call(message.high_water_stamps[keys2[j]]) : options.longs === Number ? new $util.LongBits(message.high_water_stamps[keys2[j]].low >>> 0, message.high_water_stamps[keys2[j]].high >>> 0).toNumber() : message.high_water_stamps[keys2[j]];
                }
                if (message.delta && (keys2 = Object.keys(message.delta)).length) {
                    object.delta = {};
                    for (let j = 0; j < keys2.length; ++j)
                        object.delta[keys2[j]] = $root.cockroach.gossip.Info.toObject(message.delta[keys2[j]], options);
                }
                if (message.cluster_id != null && message.hasOwnProperty("cluster_id"))
                    object.cluster_id = options.bytes === String ? $util.base64.encode(message.cluster_id, 0, message.cluster_id.length) : options.bytes === Array ? Array.prototype.slice.call(message.cluster_id) : message.cluster_id;
                return object;
            };

            /**
             * Creates a plain object from this Request message. Also converts values to other types if specified.
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Request.prototype.toObject = function toObject(options) {
                return this.constructor.toObject(this, options);
            };

            /**
             * Converts this Request to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            Request.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return Request;
        })();

        gossip.Response = (function() {

            /**
             * Properties of a Response.
             * @typedef cockroach.gossip.Response$Properties
             * @type {Object}
             * @property {number} [node_id] Response node_id.
             * @property {cockroach.util.UnresolvedAddr$Properties} [addr] Response addr.
             * @property {cockroach.util.UnresolvedAddr$Properties} [alternate_addr] Response alternate_addr.
             * @property {number} [alternate_node_id] Response alternate_node_id.
             * @property {Object.<string,cockroach.gossip.Info$Properties>} [delta] Response delta.
             * @property {Object.<string,Long>} [high_water_stamps] Response high_water_stamps.
             */

            /**
             * Constructs a new Response.
             * @exports cockroach.gossip.Response
             * @constructor
             * @param {cockroach.gossip.Response$Properties=} [properties] Properties to set
             */
            function Response(properties) {
                this.delta = {};
                this.high_water_stamps = {};
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Response node_id.
             * @type {number}
             */
            Response.prototype.node_id = 0;

            /**
             * Response addr.
             * @type {(cockroach.util.UnresolvedAddr$Properties|null)}
             */
            Response.prototype.addr = null;

            /**
             * Response alternate_addr.
             * @type {(cockroach.util.UnresolvedAddr$Properties|null)}
             */
            Response.prototype.alternate_addr = null;

            /**
             * Response alternate_node_id.
             * @type {number}
             */
            Response.prototype.alternate_node_id = 0;

            /**
             * Response delta.
             * @type {Object.<string,cockroach.gossip.Info$Properties>}
             */
            Response.prototype.delta = $util.emptyObject;

            /**
             * Response high_water_stamps.
             * @type {Object.<string,Long>}
             */
            Response.prototype.high_water_stamps = $util.emptyObject;

            /**
             * Creates a new Response instance using the specified properties.
             * @param {cockroach.gossip.Response$Properties=} [properties] Properties to set
             * @returns {cockroach.gossip.Response} Response instance
             */
            Response.create = function create(properties) {
                return new Response(properties);
            };

            /**
             * Encodes the specified Response message. Does not implicitly {@link cockroach.gossip.Response.verify|verify} messages.
             * @param {cockroach.gossip.Response$Properties} message Response message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Response.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.node_id != null && message.hasOwnProperty("node_id"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.node_id);
                if (message.addr != null && message.hasOwnProperty("addr"))
                    $root.cockroach.util.UnresolvedAddr.encode(message.addr, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.alternate_addr != null && message.hasOwnProperty("alternate_addr"))
                    $root.cockroach.util.UnresolvedAddr.encode(message.alternate_addr, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.alternate_node_id != null && message.hasOwnProperty("alternate_node_id"))
                    writer.uint32(/* id 4, wireType 0 =*/32).int32(message.alternate_node_id);
                if (message.delta != null && message.hasOwnProperty("delta"))
                    for (let keys = Object.keys(message.delta), i = 0; i < keys.length; ++i) {
                        writer.uint32(/* id 5, wireType 2 =*/42).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]);
                        $root.cockroach.gossip.Info.encode(message.delta[keys[i]], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim().ldelim();
                    }
                if (message.high_water_stamps != null && message.hasOwnProperty("high_water_stamps"))
                    for (let keys = Object.keys(message.high_water_stamps), i = 0; i < keys.length; ++i)
                        writer.uint32(/* id 6, wireType 2 =*/50).fork().uint32(/* id 1, wireType 0 =*/8).int32(keys[i]).uint32(/* id 2, wireType 0 =*/16).int64(message.high_water_stamps[keys[i]]).ldelim();
                return writer;
            };

            /**
             * Encodes the specified Response message, length delimited. Does not implicitly {@link cockroach.gossip.Response.verify|verify} messages.
             * @param {cockroach.gossip.Response$Properties} message Response message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Response.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Response message from the specified reader or buffer.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {cockroach.gossip.Response} Response
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Response.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.cockroach.gossip.Response(), key;
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.node_id = reader.int32();
                        break;
                    case 2:
                        message.addr = $root.cockroach.util.UnresolvedAddr.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.alternate_addr = $root.cockroach.util.UnresolvedAddr.decode(reader, reader.uint32());
                        break;
                    case 4:
                        message.alternate_node_id = reader.int32();
                        break;
                    case 5:
                        reader.skip().pos++;
                        if (message.delta === $util.emptyObject)
                            message.delta = {};
                        key = reader.string();
                        reader.pos++;
                        message.delta[key] = $root.cockroach.gossip.Info.decode(reader, reader.uint32());
                        break;
                    case 6:
                        reader.skip().pos++;
                        if (message.high_water_stamps === $util.emptyObject)
                            message.high_water_stamps = {};
                        key = reader.int32();
                        reader.pos++;
                        message.high_water_stamps[key] = reader.int64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Response message from the specified reader or buffer, length delimited.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {cockroach.gossip.Response} Response
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Response.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Response message.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            Response.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.node_id != null && message.hasOwnProperty("node_id"))
                    if (!$util.isInteger(message.node_id))
                        return "node_id: integer expected";
                if (message.addr != null && message.hasOwnProperty("addr")) {
                    let error = $root.cockroach.util.UnresolvedAddr.verify(message.addr);
                    if (error)
                        return "addr." + error;
                }
                if (message.alternate_addr != null && message.hasOwnProperty("alternate_addr")) {
                    let error = $root.cockroach.util.UnresolvedAddr.verify(message.alternate_addr);
                    if (error)
                        return "alternate_addr." + error;
                }
                if (message.alternate_node_id != null && message.hasOwnProperty("alternate_node_id"))
                    if (!$util.isInteger(message.alternate_node_id))
                        return "alternate_node_id: integer expected";
                if (message.delta != null && message.hasOwnProperty("delta")) {
                    if (!$util.isObject(message.delta))
                        return "delta: object expected";
                    let key = Object.keys(message.delta);
                    for (let i = 0; i < key.length; ++i) {
                        let error = $root.cockroach.gossip.Info.verify(message.delta[key[i]]);
                        if (error)
                            return "delta." + error;
                    }
                }
                if (message.high_water_stamps != null && message.hasOwnProperty("high_water_stamps")) {
                    if (!$util.isObject(message.high_water_stamps))
                        return "high_water_stamps: object expected";
                    let key = Object.keys(message.high_water_stamps);
                    for (let i = 0; i < key.length; ++i) {
                        if (!$util.key32Re.test(key[i]))
                            return "high_water_stamps: integer key{k:int32} expected";
                        if (!$util.isInteger(message.high_water_stamps[key[i]]) && !(message.high_water_stamps[key[i]] && $util.isInteger(message.high_water_stamps[key[i]].low) && $util.isInteger(message.high_water_stamps[key[i]].high)))
                            return "high_water_stamps: integer|Long{k:int32} expected";
                    }
                }
                return null;
            };

            /**
             * Creates a Response message from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {cockroach.gossip.Response} Response
             */
            Response.fromObject = function fromObject(object) {
                if (object instanceof $root.cockroach.gossip.Response)
                    return object;
                let message = new $root.cockroach.gossip.Response();
                if (object.node_id != null)
                    message.node_id = object.node_id | 0;
                if (object.addr != null) {
                    if (typeof object.addr !== "object")
                        throw TypeError(".cockroach.gossip.Response.addr: object expected");
                    message.addr = $root.cockroach.util.UnresolvedAddr.fromObject(object.addr);
                }
                if (object.alternate_addr != null) {
                    if (typeof object.alternate_addr !== "object")
                        throw TypeError(".cockroach.gossip.Response.alternate_addr: object expected");
                    message.alternate_addr = $root.cockroach.util.UnresolvedAddr.fromObject(object.alternate_addr);
                }
                if (object.alternate_node_id != null)
                    message.alternate_node_id = object.alternate_node_id | 0;
                if (object.delta) {
                    if (typeof object.delta !== "object")
                        throw TypeError(".cockroach.gossip.Response.delta: object expected");
                    message.delta = {};
                    for (let keys = Object.keys(object.delta), i = 0; i < keys.length; ++i) {
                        if (typeof object.delta[keys[i]] !== "object")
                            throw TypeError(".cockroach.gossip.Response.delta: object expected");
                        message.delta[keys[i]] = $root.cockroach.gossip.Info.fromObject(object.delta[keys[i]]);
                    }
                }
                if (object.high_water_stamps) {
                    if (typeof object.high_water_stamps !== "object")
                        throw TypeError(".cockroach.gossip.Response.high_water_stamps: object expected");
                    message.high_water_stamps = {};
                    for (let keys = Object.keys(object.high_water_stamps), i = 0; i < keys.length; ++i)
                        if ($util.Long)
                            (message.high_water_stamps[keys[i]] = $util.Long.fromValue(object.high_water_stamps[keys[i]])).unsigned = false;
                        else if (typeof object.high_water_stamps[keys[i]] === "string")
                            message.high_water_stamps[keys[i]] = parseInt(object.high_water_stamps[keys[i]], 10);
                        else if (typeof object.high_water_stamps[keys[i]] === "number")
                            message.high_water_stamps[keys[i]] = object.high_water_stamps[keys[i]];
                        else if (typeof object.high_water_stamps[keys[i]] === "object")
                            message.high_water_stamps[keys[i]] = new $util.LongBits(object.high_water_stamps[keys[i]].low >>> 0, object.high_water_stamps[keys[i]].high >>> 0).toNumber();
                }
                return message;
            };

            /**
             * Creates a Response message from a plain object. Also converts values to their respective internal types.
             * This is an alias of {@link cockroach.gossip.Response.fromObject}.
             * @function
             * @param {Object.<string,*>} object Plain object
             * @returns {cockroach.gossip.Response} Response
             */
            Response.from = Response.fromObject;

            /**
             * Creates a plain object from a Response message. Also converts values to other types if specified.
             * @param {cockroach.gossip.Response} message Response
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Response.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.objects || options.defaults) {
                    object.delta = {};
                    object.high_water_stamps = {};
                }
                if (options.defaults) {
                    object.node_id = 0;
                    object.addr = null;
                    object.alternate_addr = null;
                    object.alternate_node_id = 0;
                }
                if (message.node_id != null && message.hasOwnProperty("node_id"))
                    object.node_id = message.node_id;
                if (message.addr != null && message.hasOwnProperty("addr"))
                    object.addr = $root.cockroach.util.UnresolvedAddr.toObject(message.addr, options);
                if (message.alternate_addr != null && message.hasOwnProperty("alternate_addr"))
                    object.alternate_addr = $root.cockroach.util.UnresolvedAddr.toObject(message.alternate_addr, options);
                if (message.alternate_node_id != null && message.hasOwnProperty("alternate_node_id"))
                    object.alternate_node_id = message.alternate_node_id;
                let keys2;
                if (message.delta && (keys2 = Object.keys(message.delta)).length) {
                    object.delta = {};
                    for (let j = 0; j < keys2.length; ++j)
                        object.delta[keys2[j]] = $root.cockroach.gossip.Info.toObject(message.delta[keys2[j]], options);
                }
                if (message.high_water_stamps && (keys2 = Object.keys(message.high_water_stamps)).length) {
                    object.high_water_stamps = {};
                    for (let j = 0; j < keys2.length; ++j)
                        if (typeof message.high_water_stamps[keys2[j]] === "number")
                            object.high_water_stamps[keys2[j]] = options.longs === String ? String(message.high_water_stamps[keys2[j]]) : message.high_water_stamps[keys2[j]];
                        else
                            object.high_water_stamps[keys2[j]] = options.longs === String ? $util.Long.prototype.toString.call(message.high_water_stamps[keys2[j]]) : options.longs === Number ? new $util.LongBits(message.high_water_stamps[keys2[j]].low >>> 0, message.high_water_stamps[keys2[j]].high >>> 0).toNumber() : message.high_water_stamps[keys2[j]];
                }
                return object;
            };

            /**
             * Creates a plain object from this Response message. Also converts values to other types if specified.
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Response.prototype.toObject = function toObject(options) {
                return this.constructor.toObject(this, options);
            };

            /**
             * Converts this Response to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            Response.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return Response;
        })();

        gossip.InfoStatus = (function() {

            /**
             * Properties of an InfoStatus.
             * @typedef cockroach.gossip.InfoStatus$Properties
             * @type {Object}
             * @property {Object.<string,cockroach.gossip.Info$Properties>} [infos] InfoStatus infos.
             */

            /**
             * Constructs a new InfoStatus.
             * @exports cockroach.gossip.InfoStatus
             * @constructor
             * @param {cockroach.gossip.InfoStatus$Properties=} [properties] Properties to set
             */
            function InfoStatus(properties) {
                this.infos = {};
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * InfoStatus infos.
             * @type {Object.<string,cockroach.gossip.Info$Properties>}
             */
            InfoStatus.prototype.infos = $util.emptyObject;

            /**
             * Creates a new InfoStatus instance using the specified properties.
             * @param {cockroach.gossip.InfoStatus$Properties=} [properties] Properties to set
             * @returns {cockroach.gossip.InfoStatus} InfoStatus instance
             */
            InfoStatus.create = function create(properties) {
                return new InfoStatus(properties);
            };

            /**
             * Encodes the specified InfoStatus message. Does not implicitly {@link cockroach.gossip.InfoStatus.verify|verify} messages.
             * @param {cockroach.gossip.InfoStatus$Properties} message InfoStatus message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            InfoStatus.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.infos != null && message.hasOwnProperty("infos"))
                    for (let keys = Object.keys(message.infos), i = 0; i < keys.length; ++i) {
                        writer.uint32(/* id 1, wireType 2 =*/10).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]);
                        $root.cockroach.gossip.Info.encode(message.infos[keys[i]], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim().ldelim();
                    }
                return writer;
            };

            /**
             * Encodes the specified InfoStatus message, length delimited. Does not implicitly {@link cockroach.gossip.InfoStatus.verify|verify} messages.
             * @param {cockroach.gossip.InfoStatus$Properties} message InfoStatus message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            InfoStatus.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an InfoStatus message from the specified reader or buffer.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {cockroach.gossip.InfoStatus} InfoStatus
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            InfoStatus.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.cockroach.gossip.InfoStatus(), key;
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        reader.skip().pos++;
                        if (message.infos === $util.emptyObject)
                            message.infos = {};
                        key = reader.string();
                        reader.pos++;
                        message.infos[key] = $root.cockroach.gossip.Info.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an InfoStatus message from the specified reader or buffer, length delimited.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {cockroach.gossip.InfoStatus} InfoStatus
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            InfoStatus.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an InfoStatus message.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            InfoStatus.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.infos != null && message.hasOwnProperty("infos")) {
                    if (!$util.isObject(message.infos))
                        return "infos: object expected";
                    let key = Object.keys(message.infos);
                    for (let i = 0; i < key.length; ++i) {
                        let error = $root.cockroach.gossip.Info.verify(message.infos[key[i]]);
                        if (error)
                            return "infos." + error;
                    }
                }
                return null;
            };

            /**
             * Creates an InfoStatus message from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {cockroach.gossip.InfoStatus} InfoStatus
             */
            InfoStatus.fromObject = function fromObject(object) {
                if (object instanceof $root.cockroach.gossip.InfoStatus)
                    return object;
                let message = new $root.cockroach.gossip.InfoStatus();
                if (object.infos) {
                    if (typeof object.infos !== "object")
                        throw TypeError(".cockroach.gossip.InfoStatus.infos: object expected");
                    message.infos = {};
                    for (let keys = Object.keys(object.infos), i = 0; i < keys.length; ++i) {
                        if (typeof object.infos[keys[i]] !== "object")
                            throw TypeError(".cockroach.gossip.InfoStatus.infos: object expected");
                        message.infos[keys[i]] = $root.cockroach.gossip.Info.fromObject(object.infos[keys[i]]);
                    }
                }
                return message;
            };

            /**
             * Creates an InfoStatus message from a plain object. Also converts values to their respective internal types.
             * This is an alias of {@link cockroach.gossip.InfoStatus.fromObject}.
             * @function
             * @param {Object.<string,*>} object Plain object
             * @returns {cockroach.gossip.InfoStatus} InfoStatus
             */
            InfoStatus.from = InfoStatus.fromObject;

            /**
             * Creates a plain object from an InfoStatus message. Also converts values to other types if specified.
             * @param {cockroach.gossip.InfoStatus} message InfoStatus
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            InfoStatus.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.objects || options.defaults)
                    object.infos = {};
                let keys2;
                if (message.infos && (keys2 = Object.keys(message.infos)).length) {
                    object.infos = {};
                    for (let j = 0; j < keys2.length; ++j)
                        object.infos[keys2[j]] = $root.cockroach.gossip.Info.toObject(message.infos[keys2[j]], options);
                }
                return object;
            };

            /**
             * Creates a plain object from this InfoStatus message. Also converts values to other types if specified.
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            InfoStatus.prototype.toObject = function toObject(options) {
                return this.constructor.toObject(this, options);
            };

            /**
             * Converts this InfoStatus to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            InfoStatus.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return InfoStatus;
        })();

        gossip.Info = (function() {

            /**
             * Properties of an Info.
             * @typedef cockroach.gossip.Info$Properties
             * @type {Object}
             * @property {cockroach.roachpb.Value$Properties} [value] Info value.
             * @property {Long} [orig_stamp] Info orig_stamp.
             * @property {Long} [ttl_stamp] Info ttl_stamp.
             * @property {number} [hops] Info hops.
             * @property {number} [node_id] Info node_id.
             * @property {number} [peer_id] Info peer_id.
             */

            /**
             * Constructs a new Info.
             * @exports cockroach.gossip.Info
             * @constructor
             * @param {cockroach.gossip.Info$Properties=} [properties] Properties to set
             */
            function Info(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Info value.
             * @type {(cockroach.roachpb.Value$Properties|null)}
             */
            Info.prototype.value = null;

            /**
             * Info orig_stamp.
             * @type {Long}
             */
            Info.prototype.orig_stamp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Info ttl_stamp.
             * @type {Long}
             */
            Info.prototype.ttl_stamp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Info hops.
             * @type {number}
             */
            Info.prototype.hops = 0;

            /**
             * Info node_id.
             * @type {number}
             */
            Info.prototype.node_id = 0;

            /**
             * Info peer_id.
             * @type {number}
             */
            Info.prototype.peer_id = 0;

            /**
             * Creates a new Info instance using the specified properties.
             * @param {cockroach.gossip.Info$Properties=} [properties] Properties to set
             * @returns {cockroach.gossip.Info} Info instance
             */
            Info.create = function create(properties) {
                return new Info(properties);
            };

            /**
             * Encodes the specified Info message. Does not implicitly {@link cockroach.gossip.Info.verify|verify} messages.
             * @param {cockroach.gossip.Info$Properties} message Info message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Info.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.value != null && message.hasOwnProperty("value"))
                    $root.cockroach.roachpb.Value.encode(message.value, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.orig_stamp != null && message.hasOwnProperty("orig_stamp"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int64(message.orig_stamp);
                if (message.ttl_stamp != null && message.hasOwnProperty("ttl_stamp"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int64(message.ttl_stamp);
                if (message.hops != null && message.hasOwnProperty("hops"))
                    writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.hops);
                if (message.node_id != null && message.hasOwnProperty("node_id"))
                    writer.uint32(/* id 5, wireType 0 =*/40).int32(message.node_id);
                if (message.peer_id != null && message.hasOwnProperty("peer_id"))
                    writer.uint32(/* id 6, wireType 0 =*/48).int32(message.peer_id);
                return writer;
            };

            /**
             * Encodes the specified Info message, length delimited. Does not implicitly {@link cockroach.gossip.Info.verify|verify} messages.
             * @param {cockroach.gossip.Info$Properties} message Info message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Info.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an Info message from the specified reader or buffer.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {cockroach.gossip.Info} Info
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Info.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.cockroach.gossip.Info();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.value = $root.cockroach.roachpb.Value.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.orig_stamp = reader.int64();
                        break;
                    case 3:
                        message.ttl_stamp = reader.int64();
                        break;
                    case 4:
                        message.hops = reader.uint32();
                        break;
                    case 5:
                        message.node_id = reader.int32();
                        break;
                    case 6:
                        message.peer_id = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an Info message from the specified reader or buffer, length delimited.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {cockroach.gossip.Info} Info
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Info.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an Info message.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            Info.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.value != null && message.hasOwnProperty("value")) {
                    let error = $root.cockroach.roachpb.Value.verify(message.value);
                    if (error)
                        return "value." + error;
                }
                if (message.orig_stamp != null && message.hasOwnProperty("orig_stamp"))
                    if (!$util.isInteger(message.orig_stamp) && !(message.orig_stamp && $util.isInteger(message.orig_stamp.low) && $util.isInteger(message.orig_stamp.high)))
                        return "orig_stamp: integer|Long expected";
                if (message.ttl_stamp != null && message.hasOwnProperty("ttl_stamp"))
                    if (!$util.isInteger(message.ttl_stamp) && !(message.ttl_stamp && $util.isInteger(message.ttl_stamp.low) && $util.isInteger(message.ttl_stamp.high)))
                        return "ttl_stamp: integer|Long expected";
                if (message.hops != null && message.hasOwnProperty("hops"))
                    if (!$util.isInteger(message.hops))
                        return "hops: integer expected";
                if (message.node_id != null && message.hasOwnProperty("node_id"))
                    if (!$util.isInteger(message.node_id))
                        return "node_id: integer expected";
                if (message.peer_id != null && message.hasOwnProperty("peer_id"))
                    if (!$util.isInteger(message.peer_id))
                        return "peer_id: integer expected";
                return null;
            };

            /**
             * Creates an Info message from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {cockroach.gossip.Info} Info
             */
            Info.fromObject = function fromObject(object) {
                if (object instanceof $root.cockroach.gossip.Info)
                    return object;
                let message = new $root.cockroach.gossip.Info();
                if (object.value != null) {
                    if (typeof object.value !== "object")
                        throw TypeError(".cockroach.gossip.Info.value: object expected");
                    message.value = $root.cockroach.roachpb.Value.fromObject(object.value);
                }
                if (object.orig_stamp != null)
                    if ($util.Long)
                        (message.orig_stamp = $util.Long.fromValue(object.orig_stamp)).unsigned = false;
                    else if (typeof object.orig_stamp === "string")
                        message.orig_stamp = parseInt(object.orig_stamp, 10);
                    else if (typeof object.orig_stamp === "number")
                        message.orig_stamp = object.orig_stamp;
                    else if (typeof object.orig_stamp === "object")
                        message.orig_stamp = new $util.LongBits(object.orig_stamp.low >>> 0, object.orig_stamp.high >>> 0).toNumber();
                if (object.ttl_stamp != null)
                    if ($util.Long)
                        (message.ttl_stamp = $util.Long.fromValue(object.ttl_stamp)).unsigned = false;
                    else if (typeof object.ttl_stamp === "string")
                        message.ttl_stamp = parseInt(object.ttl_stamp, 10);
                    else if (typeof object.ttl_stamp === "number")
                        message.ttl_stamp = object.ttl_stamp;
                    else if (typeof object.ttl_stamp === "object")
                        message.ttl_stamp = new $util.LongBits(object.ttl_stamp.low >>> 0, object.ttl_stamp.high >>> 0).toNumber();
                if (object.hops != null)
                    message.hops = object.hops >>> 0;
                if (object.node_id != null)
                    message.node_id = object.node_id | 0;
                if (object.peer_id != null)
                    message.peer_id = object.peer_id | 0;
                return message;
            };

            /**
             * Creates an Info message from a plain object. Also converts values to their respective internal types.
             * This is an alias of {@link cockroach.gossip.Info.fromObject}.
             * @function
             * @param {Object.<string,*>} object Plain object
             * @returns {cockroach.gossip.Info} Info
             */
            Info.from = Info.fromObject;

            /**
             * Creates a plain object from an Info message. Also converts values to other types if specified.
             * @param {cockroach.gossip.Info} message Info
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Info.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.value = null;
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, false);
                        object.orig_stamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.orig_stamp = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, false);
                        object.ttl_stamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.ttl_stamp = options.longs === String ? "0" : 0;
                    object.hops = 0;
                    object.node_id = 0;
                    object.peer_id = 0;
                }
                if (message.value != null && message.hasOwnProperty("value"))
                    object.value = $root.cockroach.roachpb.Value.toObject(message.value, options);
                if (message.orig_stamp != null && message.hasOwnProperty("orig_stamp"))
                    if (typeof message.orig_stamp === "number")
                        object.orig_stamp = options.longs === String ? String(message.orig_stamp) : message.orig_stamp;
                    else
                        object.orig_stamp = options.longs === String ? $util.Long.prototype.toString.call(message.orig_stamp) : options.longs === Number ? new $util.LongBits(message.orig_stamp.low >>> 0, message.orig_stamp.high >>> 0).toNumber() : message.orig_stamp;
                if (message.ttl_stamp != null && message.hasOwnProperty("ttl_stamp"))
                    if (typeof message.ttl_stamp === "number")
                        object.ttl_stamp = options.longs === String ? String(message.ttl_stamp) : message.ttl_stamp;
                    else
                        object.ttl_stamp = options.longs === String ? $util.Long.prototype.toString.call(message.ttl_stamp) : options.longs === Number ? new $util.LongBits(message.ttl_stamp.low >>> 0, message.ttl_stamp.high >>> 0).toNumber() : message.ttl_stamp;
                if (message.hops != null && message.hasOwnProperty("hops"))
                    object.hops = message.hops;
                if (message.node_id != null && message.hasOwnProperty("node_id"))
                    object.node_id = message.node_id;
                if (message.peer_id != null && message.hasOwnProperty("peer_id"))
                    object.peer_id = message.peer_id;
                return object;
            };

            /**
             * Creates a plain object from this Info message. Also converts values to other types if specified.
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Info.prototype.toObject = function toObject(options) {
                return this.constructor.toObject(this, options);
            };

            /**
             * Converts this Info to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            Info.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return Info;
        })();

        gossip.Gossip = (function() {

            /**
             * Constructs a new Gossip service.
             * @exports cockroach.gossip.Gossip
             * @extends $protobuf.rpc.Service
             * @constructor
             * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
             * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
             * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
             */
            function Gossip(rpcImpl, requestDelimited, responseDelimited) {
                $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
            }

            (Gossip.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = Gossip;

            /**
             * Creates new Gossip service using the specified rpc implementation.
             * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
             * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
             * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
             * @returns {Gossip} RPC service. Useful where requests and/or responses are streamed.
             */
            Gossip.create = function create(rpcImpl, requestDelimited, responseDelimited) {
                return new this(rpcImpl, requestDelimited, responseDelimited);
            };

            /**
             * Callback as used by {@link Gossip#gossip}.
             * @typedef Gossip_gossip_Callback
             * @type {function}
             * @param {?Error} error Error, if any
             * @param {cockroach.gossip.Response} [response] Response
             */

            /**
             * Calls Gossip.
             * @param {cockroach.gossip.Request|Object.<string,*>} request Request message or plain object
             * @param {Gossip_gossip_Callback} callback Node-style callback called with the error, if any, and Response
             * @returns {undefined}
             */
            Gossip.prototype.gossip = function gossip(request, callback) {
                return this.rpcCall(gossip, $root.cockroach.gossip.Request, $root.cockroach.gossip.Response, request, callback);
            };

            /**
             * Calls Gossip.
             * @name Gossip#gossip
             * @function
             * @param {cockroach.gossip.Request|Object.<string,*>} request Request message or plain object
             * @returns {Promise<cockroach.gossip.Response>} Promise
             * @variation 2
             */

            return Gossip;
        })();

        return gossip;
    })();

    cockroach.ts = (function() {

        /**
         * Namespace ts.
         * @exports cockroach.ts
         * @namespace
         */
        const ts = {};

        ts.tspb = (function() {

            /**
             * Namespace tspb.
             * @exports cockroach.ts.tspb
             * @namespace
             */
            const tspb = {};

            tspb.TimeSeriesDatapoint = (function() {

                /**
                 * Properties of a TimeSeriesDatapoint.
                 * @typedef cockroach.ts.tspb.TimeSeriesDatapoint$Properties
                 * @type {Object}
                 * @property {Long} [timestamp_nanos] TimeSeriesDatapoint timestamp_nanos.
                 * @property {number} [value] TimeSeriesDatapoint value.
                 */

                /**
                 * Constructs a new TimeSeriesDatapoint.
                 * @exports cockroach.ts.tspb.TimeSeriesDatapoint
                 * @constructor
                 * @param {cockroach.ts.tspb.TimeSeriesDatapoint$Properties=} [properties] Properties to set
                 */
                function TimeSeriesDatapoint(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * TimeSeriesDatapoint timestamp_nanos.
                 * @type {Long}
                 */
                TimeSeriesDatapoint.prototype.timestamp_nanos = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

                /**
                 * TimeSeriesDatapoint value.
                 * @type {number}
                 */
                TimeSeriesDatapoint.prototype.value = 0;

                /**
                 * Creates a new TimeSeriesDatapoint instance using the specified properties.
                 * @param {cockroach.ts.tspb.TimeSeriesDatapoint$Properties=} [properties] Properties to set
                 * @returns {cockroach.ts.tspb.TimeSeriesDatapoint} TimeSeriesDatapoint instance
                 */
                TimeSeriesDatapoint.create = function create(properties) {
                    return new TimeSeriesDatapoint(properties);
                };

                /**
                 * Encodes the specified TimeSeriesDatapoint message. Does not implicitly {@link cockroach.ts.tspb.TimeSeriesDatapoint.verify|verify} messages.
                 * @param {cockroach.ts.tspb.TimeSeriesDatapoint$Properties} message TimeSeriesDatapoint message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                TimeSeriesDatapoint.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.timestamp_nanos != null && message.hasOwnProperty("timestamp_nanos"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int64(message.timestamp_nanos);
                    if (message.value != null && message.hasOwnProperty("value"))
                        writer.uint32(/* id 2, wireType 1 =*/17).double(message.value);
                    return writer;
                };

                /**
                 * Encodes the specified TimeSeriesDatapoint message, length delimited. Does not implicitly {@link cockroach.ts.tspb.TimeSeriesDatapoint.verify|verify} messages.
                 * @param {cockroach.ts.tspb.TimeSeriesDatapoint$Properties} message TimeSeriesDatapoint message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                TimeSeriesDatapoint.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a TimeSeriesDatapoint message from the specified reader or buffer.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {cockroach.ts.tspb.TimeSeriesDatapoint} TimeSeriesDatapoint
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                TimeSeriesDatapoint.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.cockroach.ts.tspb.TimeSeriesDatapoint();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.timestamp_nanos = reader.int64();
                            break;
                        case 2:
                            message.value = reader.double();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a TimeSeriesDatapoint message from the specified reader or buffer, length delimited.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {cockroach.ts.tspb.TimeSeriesDatapoint} TimeSeriesDatapoint
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                TimeSeriesDatapoint.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a TimeSeriesDatapoint message.
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {?string} `null` if valid, otherwise the reason why it is not
                 */
                TimeSeriesDatapoint.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.timestamp_nanos != null && message.hasOwnProperty("timestamp_nanos"))
                        if (!$util.isInteger(message.timestamp_nanos) && !(message.timestamp_nanos && $util.isInteger(message.timestamp_nanos.low) && $util.isInteger(message.timestamp_nanos.high)))
                            return "timestamp_nanos: integer|Long expected";
                    if (message.value != null && message.hasOwnProperty("value"))
                        if (typeof message.value !== "number")
                            return "value: number expected";
                    return null;
                };

                /**
                 * Creates a TimeSeriesDatapoint message from a plain object. Also converts values to their respective internal types.
                 * @param {Object.<string,*>} object Plain object
                 * @returns {cockroach.ts.tspb.TimeSeriesDatapoint} TimeSeriesDatapoint
                 */
                TimeSeriesDatapoint.fromObject = function fromObject(object) {
                    if (object instanceof $root.cockroach.ts.tspb.TimeSeriesDatapoint)
                        return object;
                    let message = new $root.cockroach.ts.tspb.TimeSeriesDatapoint();
                    if (object.timestamp_nanos != null)
                        if ($util.Long)
                            (message.timestamp_nanos = $util.Long.fromValue(object.timestamp_nanos)).unsigned = false;
                        else if (typeof object.timestamp_nanos === "string")
                            message.timestamp_nanos = parseInt(object.timestamp_nanos, 10);
                        else if (typeof object.timestamp_nanos === "number")
                            message.timestamp_nanos = object.timestamp_nanos;
                        else if (typeof object.timestamp_nanos === "object")
                            message.timestamp_nanos = new $util.LongBits(object.timestamp_nanos.low >>> 0, object.timestamp_nanos.high >>> 0).toNumber();
                    if (object.value != null)
                        message.value = Number(object.value);
                    return message;
                };

                /**
                 * Creates a TimeSeriesDatapoint message from a plain object. Also converts values to their respective internal types.
                 * This is an alias of {@link cockroach.ts.tspb.TimeSeriesDatapoint.fromObject}.
                 * @function
                 * @param {Object.<string,*>} object Plain object
                 * @returns {cockroach.ts.tspb.TimeSeriesDatapoint} TimeSeriesDatapoint
                 */
                TimeSeriesDatapoint.from = TimeSeriesDatapoint.fromObject;

                /**
                 * Creates a plain object from a TimeSeriesDatapoint message. Also converts values to other types if specified.
                 * @param {cockroach.ts.tspb.TimeSeriesDatapoint} message TimeSeriesDatapoint
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                TimeSeriesDatapoint.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        if ($util.Long) {
                            let long = new $util.Long(0, 0, false);
                            object.timestamp_nanos = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.timestamp_nanos = options.longs === String ? "0" : 0;
                        object.value = 0;
                    }
                    if (message.timestamp_nanos != null && message.hasOwnProperty("timestamp_nanos"))
                        if (typeof message.timestamp_nanos === "number")
                            object.timestamp_nanos = options.longs === String ? String(message.timestamp_nanos) : message.timestamp_nanos;
                        else
                            object.timestamp_nanos = options.longs === String ? $util.Long.prototype.toString.call(message.timestamp_nanos) : options.longs === Number ? new $util.LongBits(message.timestamp_nanos.low >>> 0, message.timestamp_nanos.high >>> 0).toNumber() : message.timestamp_nanos;
                    if (message.value != null && message.hasOwnProperty("value"))
                        object.value = message.value;
                    return object;
                };

                /**
                 * Creates a plain object from this TimeSeriesDatapoint message. Also converts values to other types if specified.
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                TimeSeriesDatapoint.prototype.toObject = function toObject(options) {
                    return this.constructor.toObject(this, options);
                };

                /**
                 * Converts this TimeSeriesDatapoint to JSON.
                 * @returns {Object.<string,*>} JSON object
                 */
                TimeSeriesDatapoint.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return TimeSeriesDatapoint;
            })();

            tspb.TimeSeriesData = (function() {

                /**
                 * Properties of a TimeSeriesData.
                 * @typedef cockroach.ts.tspb.TimeSeriesData$Properties
                 * @type {Object}
                 * @property {string} [name] TimeSeriesData name.
                 * @property {string} [source] TimeSeriesData source.
                 * @property {Array.<cockroach.ts.tspb.TimeSeriesDatapoint$Properties>} [datapoints] TimeSeriesData datapoints.
                 */

                /**
                 * Constructs a new TimeSeriesData.
                 * @exports cockroach.ts.tspb.TimeSeriesData
                 * @constructor
                 * @param {cockroach.ts.tspb.TimeSeriesData$Properties=} [properties] Properties to set
                 */
                function TimeSeriesData(properties) {
                    this.datapoints = [];
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * TimeSeriesData name.
                 * @type {string}
                 */
                TimeSeriesData.prototype.name = "";

                /**
                 * TimeSeriesData source.
                 * @type {string}
                 */
                TimeSeriesData.prototype.source = "";

                /**
                 * TimeSeriesData datapoints.
                 * @type {Array.<cockroach.ts.tspb.TimeSeriesDatapoint$Properties>}
                 */
                TimeSeriesData.prototype.datapoints = $util.emptyArray;

                /**
                 * Creates a new TimeSeriesData instance using the specified properties.
                 * @param {cockroach.ts.tspb.TimeSeriesData$Properties=} [properties] Properties to set
                 * @returns {cockroach.ts.tspb.TimeSeriesData} TimeSeriesData instance
                 */
                TimeSeriesData.create = function create(properties) {
                    return new TimeSeriesData(properties);
                };

                /**
                 * Encodes the specified TimeSeriesData message. Does not implicitly {@link cockroach.ts.tspb.TimeSeriesData.verify|verify} messages.
                 * @param {cockroach.ts.tspb.TimeSeriesData$Properties} message TimeSeriesData message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                TimeSeriesData.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.name != null && message.hasOwnProperty("name"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                    if (message.source != null && message.hasOwnProperty("source"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.source);
                    if (message.datapoints != null && message.datapoints.length)
                        for (let i = 0; i < message.datapoints.length; ++i)
                            $root.cockroach.ts.tspb.TimeSeriesDatapoint.encode(message.datapoints[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified TimeSeriesData message, length delimited. Does not implicitly {@link cockroach.ts.tspb.TimeSeriesData.verify|verify} messages.
                 * @param {cockroach.ts.tspb.TimeSeriesData$Properties} message TimeSeriesData message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                TimeSeriesData.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a TimeSeriesData message from the specified reader or buffer.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {cockroach.ts.tspb.TimeSeriesData} TimeSeriesData
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                TimeSeriesData.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.cockroach.ts.tspb.TimeSeriesData();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.name = reader.string();
                            break;
                        case 2:
                            message.source = reader.string();
                            break;
                        case 3:
                            if (!(message.datapoints && message.datapoints.length))
                                message.datapoints = [];
                            message.datapoints.push($root.cockroach.ts.tspb.TimeSeriesDatapoint.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a TimeSeriesData message from the specified reader or buffer, length delimited.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {cockroach.ts.tspb.TimeSeriesData} TimeSeriesData
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                TimeSeriesData.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a TimeSeriesData message.
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {?string} `null` if valid, otherwise the reason why it is not
                 */
                TimeSeriesData.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.name != null && message.hasOwnProperty("name"))
                        if (!$util.isString(message.name))
                            return "name: string expected";
                    if (message.source != null && message.hasOwnProperty("source"))
                        if (!$util.isString(message.source))
                            return "source: string expected";
                    if (message.datapoints != null && message.hasOwnProperty("datapoints")) {
                        if (!Array.isArray(message.datapoints))
                            return "datapoints: array expected";
                        for (let i = 0; i < message.datapoints.length; ++i) {
                            let error = $root.cockroach.ts.tspb.TimeSeriesDatapoint.verify(message.datapoints[i]);
                            if (error)
                                return "datapoints." + error;
                        }
                    }
                    return null;
                };

                /**
                 * Creates a TimeSeriesData message from a plain object. Also converts values to their respective internal types.
                 * @param {Object.<string,*>} object Plain object
                 * @returns {cockroach.ts.tspb.TimeSeriesData} TimeSeriesData
                 */
                TimeSeriesData.fromObject = function fromObject(object) {
                    if (object instanceof $root.cockroach.ts.tspb.TimeSeriesData)
                        return object;
                    let message = new $root.cockroach.ts.tspb.TimeSeriesData();
                    if (object.name != null)
                        message.name = String(object.name);
                    if (object.source != null)
                        message.source = String(object.source);
                    if (object.datapoints) {
                        if (!Array.isArray(object.datapoints))
                            throw TypeError(".cockroach.ts.tspb.TimeSeriesData.datapoints: array expected");
                        message.datapoints = [];
                        for (let i = 0; i < object.datapoints.length; ++i) {
                            if (typeof object.datapoints[i] !== "object")
                                throw TypeError(".cockroach.ts.tspb.TimeSeriesData.datapoints: object expected");
                            message.datapoints[i] = $root.cockroach.ts.tspb.TimeSeriesDatapoint.fromObject(object.datapoints[i]);
                        }
                    }
                    return message;
                };

                /**
                 * Creates a TimeSeriesData message from a plain object. Also converts values to their respective internal types.
                 * This is an alias of {@link cockroach.ts.tspb.TimeSeriesData.fromObject}.
                 * @function
                 * @param {Object.<string,*>} object Plain object
                 * @returns {cockroach.ts.tspb.TimeSeriesData} TimeSeriesData
                 */
                TimeSeriesData.from = TimeSeriesData.fromObject;

                /**
                 * Creates a plain object from a TimeSeriesData message. Also converts values to other types if specified.
                 * @param {cockroach.ts.tspb.TimeSeriesData} message TimeSeriesData
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                TimeSeriesData.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.arrays || options.defaults)
                        object.datapoints = [];
                    if (options.defaults) {
                        object.name = "";
                        object.source = "";
                    }
                    if (message.name != null && message.hasOwnProperty("name"))
                        object.name = message.name;
                    if (message.source != null && message.hasOwnProperty("source"))
                        object.source = message.source;
                    if (message.datapoints && message.datapoints.length) {
                        object.datapoints = [];
                        for (let j = 0; j < message.datapoints.length; ++j)
                            object.datapoints[j] = $root.cockroach.ts.tspb.TimeSeriesDatapoint.toObject(message.datapoints[j], options);
                    }
                    return object;
                };

                /**
                 * Creates a plain object from this TimeSeriesData message. Also converts values to other types if specified.
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                TimeSeriesData.prototype.toObject = function toObject(options) {
                    return this.constructor.toObject(this, options);
                };

                /**
                 * Converts this TimeSeriesData to JSON.
                 * @returns {Object.<string,*>} JSON object
                 */
                TimeSeriesData.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return TimeSeriesData;
            })();

            /**
             * TimeSeriesQueryAggregator enum.
             * @name TimeSeriesQueryAggregator
             * @memberof cockroach.ts.tspb
             * @enum {number}
             * @property {number} AVG=1 AVG value
             * @property {number} SUM=2 SUM value
             * @property {number} MAX=3 MAX value
             * @property {number} MIN=4 MIN value
             */
            tspb.TimeSeriesQueryAggregator = (function() {
                const valuesById = {}, values = Object.create(valuesById);
                values[valuesById[1] = "AVG"] = 1;
                values[valuesById[2] = "SUM"] = 2;
                values[valuesById[3] = "MAX"] = 3;
                values[valuesById[4] = "MIN"] = 4;
                return values;
            })();

            /**
             * TimeSeriesQueryDerivative enum.
             * @name TimeSeriesQueryDerivative
             * @memberof cockroach.ts.tspb
             * @enum {number}
             * @property {number} NONE=0 NONE value
             * @property {number} DERIVATIVE=1 DERIVATIVE value
             * @property {number} NON_NEGATIVE_DERIVATIVE=2 NON_NEGATIVE_DERIVATIVE value
             */
            tspb.TimeSeriesQueryDerivative = (function() {
                const valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "NONE"] = 0;
                values[valuesById[1] = "DERIVATIVE"] = 1;
                values[valuesById[2] = "NON_NEGATIVE_DERIVATIVE"] = 2;
                return values;
            })();

            tspb.Query = (function() {

                /**
                 * Properties of a Query.
                 * @typedef cockroach.ts.tspb.Query$Properties
                 * @type {Object}
                 * @property {string} [name] Query name.
                 * @property {cockroach.ts.tspb.TimeSeriesQueryAggregator} [downsampler] Query downsampler.
                 * @property {cockroach.ts.tspb.TimeSeriesQueryAggregator} [source_aggregator] Query source_aggregator.
                 * @property {cockroach.ts.tspb.TimeSeriesQueryDerivative} [derivative] Query derivative.
                 * @property {Array.<string>} [sources] Query sources.
                 */

                /**
                 * Constructs a new Query.
                 * @exports cockroach.ts.tspb.Query
                 * @constructor
                 * @param {cockroach.ts.tspb.Query$Properties=} [properties] Properties to set
                 */
                function Query(properties) {
                    this.sources = [];
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Query name.
                 * @type {string}
                 */
                Query.prototype.name = "";

                /**
                 * Query downsampler.
                 * @type {cockroach.ts.tspb.TimeSeriesQueryAggregator}
                 */
                Query.prototype.downsampler = 1;

                /**
                 * Query source_aggregator.
                 * @type {cockroach.ts.tspb.TimeSeriesQueryAggregator}
                 */
                Query.prototype.source_aggregator = 2;

                /**
                 * Query derivative.
                 * @type {cockroach.ts.tspb.TimeSeriesQueryDerivative}
                 */
                Query.prototype.derivative = 0;

                /**
                 * Query sources.
                 * @type {Array.<string>}
                 */
                Query.prototype.sources = $util.emptyArray;

                /**
                 * Creates a new Query instance using the specified properties.
                 * @param {cockroach.ts.tspb.Query$Properties=} [properties] Properties to set
                 * @returns {cockroach.ts.tspb.Query} Query instance
                 */
                Query.create = function create(properties) {
                    return new Query(properties);
                };

                /**
                 * Encodes the specified Query message. Does not implicitly {@link cockroach.ts.tspb.Query.verify|verify} messages.
                 * @param {cockroach.ts.tspb.Query$Properties} message Query message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Query.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.name != null && message.hasOwnProperty("name"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                    if (message.downsampler != null && message.hasOwnProperty("downsampler"))
                        writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.downsampler);
                    if (message.source_aggregator != null && message.hasOwnProperty("source_aggregator"))
                        writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.source_aggregator);
                    if (message.derivative != null && message.hasOwnProperty("derivative"))
                        writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.derivative);
                    if (message.sources != null && message.sources.length)
                        for (let i = 0; i < message.sources.length; ++i)
                            writer.uint32(/* id 5, wireType 2 =*/42).string(message.sources[i]);
                    return writer;
                };

                /**
                 * Encodes the specified Query message, length delimited. Does not implicitly {@link cockroach.ts.tspb.Query.verify|verify} messages.
                 * @param {cockroach.ts.tspb.Query$Properties} message Query message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Query.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a Query message from the specified reader or buffer.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {cockroach.ts.tspb.Query} Query
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Query.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.cockroach.ts.tspb.Query();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.name = reader.string();
                            break;
                        case 2:
                            message.downsampler = reader.uint32();
                            break;
                        case 3:
                            message.source_aggregator = reader.uint32();
                            break;
                        case 4:
                            message.derivative = reader.uint32();
                            break;
                        case 5:
                            if (!(message.sources && message.sources.length))
                                message.sources = [];
                            message.sources.push(reader.string());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a Query message from the specified reader or buffer, length delimited.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {cockroach.ts.tspb.Query} Query
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Query.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a Query message.
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {?string} `null` if valid, otherwise the reason why it is not
                 */
                Query.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.name != null && message.hasOwnProperty("name"))
                        if (!$util.isString(message.name))
                            return "name: string expected";
                    if (message.downsampler != null && message.hasOwnProperty("downsampler"))
                        switch (message.downsampler) {
                        default:
                            return "downsampler: enum value expected";
                        case 1:
                        case 2:
                        case 3:
                        case 4:
                            break;
                        }
                    if (message.source_aggregator != null && message.hasOwnProperty("source_aggregator"))
                        switch (message.source_aggregator) {
                        default:
                            return "source_aggregator: enum value expected";
                        case 1:
                        case 2:
                        case 3:
                        case 4:
                            break;
                        }
                    if (message.derivative != null && message.hasOwnProperty("derivative"))
                        switch (message.derivative) {
                        default:
                            return "derivative: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                            break;
                        }
                    if (message.sources != null && message.hasOwnProperty("sources")) {
                        if (!Array.isArray(message.sources))
                            return "sources: array expected";
                        for (let i = 0; i < message.sources.length; ++i)
                            if (!$util.isString(message.sources[i]))
                                return "sources: string[] expected";
                    }
                    return null;
                };

                /**
                 * Creates a Query message from a plain object. Also converts values to their respective internal types.
                 * @param {Object.<string,*>} object Plain object
                 * @returns {cockroach.ts.tspb.Query} Query
                 */
                Query.fromObject = function fromObject(object) {
                    if (object instanceof $root.cockroach.ts.tspb.Query)
                        return object;
                    let message = new $root.cockroach.ts.tspb.Query();
                    if (object.name != null)
                        message.name = String(object.name);
                    switch (object.downsampler) {
                    case "AVG":
                    case 1:
                        message.downsampler = 1;
                        break;
                    case "SUM":
                    case 2:
                        message.downsampler = 2;
                        break;
                    case "MAX":
                    case 3:
                        message.downsampler = 3;
                        break;
                    case "MIN":
                    case 4:
                        message.downsampler = 4;
                        break;
                    }
                    switch (object.source_aggregator) {
                    case "AVG":
                    case 1:
                        message.source_aggregator = 1;
                        break;
                    case "SUM":
                    case 2:
                        message.source_aggregator = 2;
                        break;
                    case "MAX":
                    case 3:
                        message.source_aggregator = 3;
                        break;
                    case "MIN":
                    case 4:
                        message.source_aggregator = 4;
                        break;
                    }
                    switch (object.derivative) {
                    case "NONE":
                    case 0:
                        message.derivative = 0;
                        break;
                    case "DERIVATIVE":
                    case 1:
                        message.derivative = 1;
                        break;
                    case "NON_NEGATIVE_DERIVATIVE":
                    case 2:
                        message.derivative = 2;
                        break;
                    }
                    if (object.sources) {
                        if (!Array.isArray(object.sources))
                            throw TypeError(".cockroach.ts.tspb.Query.sources: array expected");
                        message.sources = [];
                        for (let i = 0; i < object.sources.length; ++i)
                            message.sources[i] = String(object.sources[i]);
                    }
                    return message;
                };

                /**
                 * Creates a Query message from a plain object. Also converts values to their respective internal types.
                 * This is an alias of {@link cockroach.ts.tspb.Query.fromObject}.
                 * @function
                 * @param {Object.<string,*>} object Plain object
                 * @returns {cockroach.ts.tspb.Query} Query
                 */
                Query.from = Query.fromObject;

                /**
                 * Creates a plain object from a Query message. Also converts values to other types if specified.
                 * @param {cockroach.ts.tspb.Query} message Query
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Query.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.arrays || options.defaults)
                        object.sources = [];
                    if (options.defaults) {
                        object.name = "";
                        object.downsampler = options.enums === String ? "AVG" : 1;
                        object.source_aggregator = options.enums === String ? "SUM" : 2;
                        object.derivative = options.enums === String ? "NONE" : 0;
                    }
                    if (message.name != null && message.hasOwnProperty("name"))
                        object.name = message.name;
                    if (message.downsampler != null && message.hasOwnProperty("downsampler"))
                        object.downsampler = options.enums === String ? $root.cockroach.ts.tspb.TimeSeriesQueryAggregator[message.downsampler] : message.downsampler;
                    if (message.source_aggregator != null && message.hasOwnProperty("source_aggregator"))
                        object.source_aggregator = options.enums === String ? $root.cockroach.ts.tspb.TimeSeriesQueryAggregator[message.source_aggregator] : message.source_aggregator;
                    if (message.derivative != null && message.hasOwnProperty("derivative"))
                        object.derivative = options.enums === String ? $root.cockroach.ts.tspb.TimeSeriesQueryDerivative[message.derivative] : message.derivative;
                    if (message.sources && message.sources.length) {
                        object.sources = [];
                        for (let j = 0; j < message.sources.length; ++j)
                            object.sources[j] = message.sources[j];
                    }
                    return object;
                };

                /**
                 * Creates a plain object from this Query message. Also converts values to other types if specified.
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Query.prototype.toObject = function toObject(options) {
                    return this.constructor.toObject(this, options);
                };

                /**
                 * Converts this Query to JSON.
                 * @returns {Object.<string,*>} JSON object
                 */
                Query.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return Query;
            })();

            tspb.TimeSeriesQueryRequest = (function() {

                /**
                 * Properties of a TimeSeriesQueryRequest.
                 * @typedef cockroach.ts.tspb.TimeSeriesQueryRequest$Properties
                 * @type {Object}
                 * @property {Long} [start_nanos] TimeSeriesQueryRequest start_nanos.
                 * @property {Long} [end_nanos] TimeSeriesQueryRequest end_nanos.
                 * @property {Array.<cockroach.ts.tspb.Query$Properties>} [queries] TimeSeriesQueryRequest queries.
                 * @property {Long} [sample_nanos] TimeSeriesQueryRequest sample_nanos.
                 */

                /**
                 * Constructs a new TimeSeriesQueryRequest.
                 * @exports cockroach.ts.tspb.TimeSeriesQueryRequest
                 * @constructor
                 * @param {cockroach.ts.tspb.TimeSeriesQueryRequest$Properties=} [properties] Properties to set
                 */
                function TimeSeriesQueryRequest(properties) {
                    this.queries = [];
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * TimeSeriesQueryRequest start_nanos.
                 * @type {Long}
                 */
                TimeSeriesQueryRequest.prototype.start_nanos = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

                /**
                 * TimeSeriesQueryRequest end_nanos.
                 * @type {Long}
                 */
                TimeSeriesQueryRequest.prototype.end_nanos = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

                /**
                 * TimeSeriesQueryRequest queries.
                 * @type {Array.<cockroach.ts.tspb.Query$Properties>}
                 */
                TimeSeriesQueryRequest.prototype.queries = $util.emptyArray;

                /**
                 * TimeSeriesQueryRequest sample_nanos.
                 * @type {Long}
                 */
                TimeSeriesQueryRequest.prototype.sample_nanos = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

                /**
                 * Creates a new TimeSeriesQueryRequest instance using the specified properties.
                 * @param {cockroach.ts.tspb.TimeSeriesQueryRequest$Properties=} [properties] Properties to set
                 * @returns {cockroach.ts.tspb.TimeSeriesQueryRequest} TimeSeriesQueryRequest instance
                 */
                TimeSeriesQueryRequest.create = function create(properties) {
                    return new TimeSeriesQueryRequest(properties);
                };

                /**
                 * Encodes the specified TimeSeriesQueryRequest message. Does not implicitly {@link cockroach.ts.tspb.TimeSeriesQueryRequest.verify|verify} messages.
                 * @param {cockroach.ts.tspb.TimeSeriesQueryRequest$Properties} message TimeSeriesQueryRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                TimeSeriesQueryRequest.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.start_nanos != null && message.hasOwnProperty("start_nanos"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int64(message.start_nanos);
                    if (message.end_nanos != null && message.hasOwnProperty("end_nanos"))
                        writer.uint32(/* id 2, wireType 0 =*/16).int64(message.end_nanos);
                    if (message.queries != null && message.queries.length)
                        for (let i = 0; i < message.queries.length; ++i)
                            $root.cockroach.ts.tspb.Query.encode(message.queries[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    if (message.sample_nanos != null && message.hasOwnProperty("sample_nanos"))
                        writer.uint32(/* id 4, wireType 0 =*/32).int64(message.sample_nanos);
                    return writer;
                };

                /**
                 * Encodes the specified TimeSeriesQueryRequest message, length delimited. Does not implicitly {@link cockroach.ts.tspb.TimeSeriesQueryRequest.verify|verify} messages.
                 * @param {cockroach.ts.tspb.TimeSeriesQueryRequest$Properties} message TimeSeriesQueryRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                TimeSeriesQueryRequest.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a TimeSeriesQueryRequest message from the specified reader or buffer.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {cockroach.ts.tspb.TimeSeriesQueryRequest} TimeSeriesQueryRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                TimeSeriesQueryRequest.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.cockroach.ts.tspb.TimeSeriesQueryRequest();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.start_nanos = reader.int64();
                            break;
                        case 2:
                            message.end_nanos = reader.int64();
                            break;
                        case 3:
                            if (!(message.queries && message.queries.length))
                                message.queries = [];
                            message.queries.push($root.cockroach.ts.tspb.Query.decode(reader, reader.uint32()));
                            break;
                        case 4:
                            message.sample_nanos = reader.int64();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a TimeSeriesQueryRequest message from the specified reader or buffer, length delimited.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {cockroach.ts.tspb.TimeSeriesQueryRequest} TimeSeriesQueryRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                TimeSeriesQueryRequest.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a TimeSeriesQueryRequest message.
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {?string} `null` if valid, otherwise the reason why it is not
                 */
                TimeSeriesQueryRequest.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.start_nanos != null && message.hasOwnProperty("start_nanos"))
                        if (!$util.isInteger(message.start_nanos) && !(message.start_nanos && $util.isInteger(message.start_nanos.low) && $util.isInteger(message.start_nanos.high)))
                            return "start_nanos: integer|Long expected";
                    if (message.end_nanos != null && message.hasOwnProperty("end_nanos"))
                        if (!$util.isInteger(message.end_nanos) && !(message.end_nanos && $util.isInteger(message.end_nanos.low) && $util.isInteger(message.end_nanos.high)))
                            return "end_nanos: integer|Long expected";
                    if (message.queries != null && message.hasOwnProperty("queries")) {
                        if (!Array.isArray(message.queries))
                            return "queries: array expected";
                        for (let i = 0; i < message.queries.length; ++i) {
                            let error = $root.cockroach.ts.tspb.Query.verify(message.queries[i]);
                            if (error)
                                return "queries." + error;
                        }
                    }
                    if (message.sample_nanos != null && message.hasOwnProperty("sample_nanos"))
                        if (!$util.isInteger(message.sample_nanos) && !(message.sample_nanos && $util.isInteger(message.sample_nanos.low) && $util.isInteger(message.sample_nanos.high)))
                            return "sample_nanos: integer|Long expected";
                    return null;
                };

                /**
                 * Creates a TimeSeriesQueryRequest message from a plain object. Also converts values to their respective internal types.
                 * @param {Object.<string,*>} object Plain object
                 * @returns {cockroach.ts.tspb.TimeSeriesQueryRequest} TimeSeriesQueryRequest
                 */
                TimeSeriesQueryRequest.fromObject = function fromObject(object) {
                    if (object instanceof $root.cockroach.ts.tspb.TimeSeriesQueryRequest)
                        return object;
                    let message = new $root.cockroach.ts.tspb.TimeSeriesQueryRequest();
                    if (object.start_nanos != null)
                        if ($util.Long)
                            (message.start_nanos = $util.Long.fromValue(object.start_nanos)).unsigned = false;
                        else if (typeof object.start_nanos === "string")
                            message.start_nanos = parseInt(object.start_nanos, 10);
                        else if (typeof object.start_nanos === "number")
                            message.start_nanos = object.start_nanos;
                        else if (typeof object.start_nanos === "object")
                            message.start_nanos = new $util.LongBits(object.start_nanos.low >>> 0, object.start_nanos.high >>> 0).toNumber();
                    if (object.end_nanos != null)
                        if ($util.Long)
                            (message.end_nanos = $util.Long.fromValue(object.end_nanos)).unsigned = false;
                        else if (typeof object.end_nanos === "string")
                            message.end_nanos = parseInt(object.end_nanos, 10);
                        else if (typeof object.end_nanos === "number")
                            message.end_nanos = object.end_nanos;
                        else if (typeof object.end_nanos === "object")
                            message.end_nanos = new $util.LongBits(object.end_nanos.low >>> 0, object.end_nanos.high >>> 0).toNumber();
                    if (object.queries) {
                        if (!Array.isArray(object.queries))
                            throw TypeError(".cockroach.ts.tspb.TimeSeriesQueryRequest.queries: array expected");
                        message.queries = [];
                        for (let i = 0; i < object.queries.length; ++i) {
                            if (typeof object.queries[i] !== "object")
                                throw TypeError(".cockroach.ts.tspb.TimeSeriesQueryRequest.queries: object expected");
                            message.queries[i] = $root.cockroach.ts.tspb.Query.fromObject(object.queries[i]);
                        }
                    }
                    if (object.sample_nanos != null)
                        if ($util.Long)
                            (message.sample_nanos = $util.Long.fromValue(object.sample_nanos)).unsigned = false;
                        else if (typeof object.sample_nanos === "string")
                            message.sample_nanos = parseInt(object.sample_nanos, 10);
                        else if (typeof object.sample_nanos === "number")
                            message.sample_nanos = object.sample_nanos;
                        else if (typeof object.sample_nanos === "object")
                            message.sample_nanos = new $util.LongBits(object.sample_nanos.low >>> 0, object.sample_nanos.high >>> 0).toNumber();
                    return message;
                };

                /**
                 * Creates a TimeSeriesQueryRequest message from a plain object. Also converts values to their respective internal types.
                 * This is an alias of {@link cockroach.ts.tspb.TimeSeriesQueryRequest.fromObject}.
                 * @function
                 * @param {Object.<string,*>} object Plain object
                 * @returns {cockroach.ts.tspb.TimeSeriesQueryRequest} TimeSeriesQueryRequest
                 */
                TimeSeriesQueryRequest.from = TimeSeriesQueryRequest.fromObject;

                /**
                 * Creates a plain object from a TimeSeriesQueryRequest message. Also converts values to other types if specified.
                 * @param {cockroach.ts.tspb.TimeSeriesQueryRequest} message TimeSeriesQueryRequest
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                TimeSeriesQueryRequest.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.arrays || options.defaults)
                        object.queries = [];
                    if (options.defaults) {
                        if ($util.Long) {
                            let long = new $util.Long(0, 0, false);
                            object.start_nanos = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.start_nanos = options.longs === String ? "0" : 0;
                        if ($util.Long) {
                            let long = new $util.Long(0, 0, false);
                            object.end_nanos = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.end_nanos = options.longs === String ? "0" : 0;
                        if ($util.Long) {
                            let long = new $util.Long(0, 0, false);
                            object.sample_nanos = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.sample_nanos = options.longs === String ? "0" : 0;
                    }
                    if (message.start_nanos != null && message.hasOwnProperty("start_nanos"))
                        if (typeof message.start_nanos === "number")
                            object.start_nanos = options.longs === String ? String(message.start_nanos) : message.start_nanos;
                        else
                            object.start_nanos = options.longs === String ? $util.Long.prototype.toString.call(message.start_nanos) : options.longs === Number ? new $util.LongBits(message.start_nanos.low >>> 0, message.start_nanos.high >>> 0).toNumber() : message.start_nanos;
                    if (message.end_nanos != null && message.hasOwnProperty("end_nanos"))
                        if (typeof message.end_nanos === "number")
                            object.end_nanos = options.longs === String ? String(message.end_nanos) : message.end_nanos;
                        else
                            object.end_nanos = options.longs === String ? $util.Long.prototype.toString.call(message.end_nanos) : options.longs === Number ? new $util.LongBits(message.end_nanos.low >>> 0, message.end_nanos.high >>> 0).toNumber() : message.end_nanos;
                    if (message.queries && message.queries.length) {
                        object.queries = [];
                        for (let j = 0; j < message.queries.length; ++j)
                            object.queries[j] = $root.cockroach.ts.tspb.Query.toObject(message.queries[j], options);
                    }
                    if (message.sample_nanos != null && message.hasOwnProperty("sample_nanos"))
                        if (typeof message.sample_nanos === "number")
                            object.sample_nanos = options.longs === String ? String(message.sample_nanos) : message.sample_nanos;
                        else
                            object.sample_nanos = options.longs === String ? $util.Long.prototype.toString.call(message.sample_nanos) : options.longs === Number ? new $util.LongBits(message.sample_nanos.low >>> 0, message.sample_nanos.high >>> 0).toNumber() : message.sample_nanos;
                    return object;
                };

                /**
                 * Creates a plain object from this TimeSeriesQueryRequest message. Also converts values to other types if specified.
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                TimeSeriesQueryRequest.prototype.toObject = function toObject(options) {
                    return this.constructor.toObject(this, options);
                };

                /**
                 * Converts this TimeSeriesQueryRequest to JSON.
                 * @returns {Object.<string,*>} JSON object
                 */
                TimeSeriesQueryRequest.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return TimeSeriesQueryRequest;
            })();

            tspb.TimeSeriesQueryResponse = (function() {

                /**
                 * Properties of a TimeSeriesQueryResponse.
                 * @typedef cockroach.ts.tspb.TimeSeriesQueryResponse$Properties
                 * @type {Object}
                 * @property {Array.<cockroach.ts.tspb.TimeSeriesQueryResponse.Result$Properties>} [results] TimeSeriesQueryResponse results.
                 */

                /**
                 * Constructs a new TimeSeriesQueryResponse.
                 * @exports cockroach.ts.tspb.TimeSeriesQueryResponse
                 * @constructor
                 * @param {cockroach.ts.tspb.TimeSeriesQueryResponse$Properties=} [properties] Properties to set
                 */
                function TimeSeriesQueryResponse(properties) {
                    this.results = [];
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * TimeSeriesQueryResponse results.
                 * @type {Array.<cockroach.ts.tspb.TimeSeriesQueryResponse.Result$Properties>}
                 */
                TimeSeriesQueryResponse.prototype.results = $util.emptyArray;

                /**
                 * Creates a new TimeSeriesQueryResponse instance using the specified properties.
                 * @param {cockroach.ts.tspb.TimeSeriesQueryResponse$Properties=} [properties] Properties to set
                 * @returns {cockroach.ts.tspb.TimeSeriesQueryResponse} TimeSeriesQueryResponse instance
                 */
                TimeSeriesQueryResponse.create = function create(properties) {
                    return new TimeSeriesQueryResponse(properties);
                };

                /**
                 * Encodes the specified TimeSeriesQueryResponse message. Does not implicitly {@link cockroach.ts.tspb.TimeSeriesQueryResponse.verify|verify} messages.
                 * @param {cockroach.ts.tspb.TimeSeriesQueryResponse$Properties} message TimeSeriesQueryResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                TimeSeriesQueryResponse.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.results != null && message.results.length)
                        for (let i = 0; i < message.results.length; ++i)
                            $root.cockroach.ts.tspb.TimeSeriesQueryResponse.Result.encode(message.results[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified TimeSeriesQueryResponse message, length delimited. Does not implicitly {@link cockroach.ts.tspb.TimeSeriesQueryResponse.verify|verify} messages.
                 * @param {cockroach.ts.tspb.TimeSeriesQueryResponse$Properties} message TimeSeriesQueryResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                TimeSeriesQueryResponse.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a TimeSeriesQueryResponse message from the specified reader or buffer.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {cockroach.ts.tspb.TimeSeriesQueryResponse} TimeSeriesQueryResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                TimeSeriesQueryResponse.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.cockroach.ts.tspb.TimeSeriesQueryResponse();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (!(message.results && message.results.length))
                                message.results = [];
                            message.results.push($root.cockroach.ts.tspb.TimeSeriesQueryResponse.Result.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a TimeSeriesQueryResponse message from the specified reader or buffer, length delimited.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {cockroach.ts.tspb.TimeSeriesQueryResponse} TimeSeriesQueryResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                TimeSeriesQueryResponse.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a TimeSeriesQueryResponse message.
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {?string} `null` if valid, otherwise the reason why it is not
                 */
                TimeSeriesQueryResponse.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.results != null && message.hasOwnProperty("results")) {
                        if (!Array.isArray(message.results))
                            return "results: array expected";
                        for (let i = 0; i < message.results.length; ++i) {
                            let error = $root.cockroach.ts.tspb.TimeSeriesQueryResponse.Result.verify(message.results[i]);
                            if (error)
                                return "results." + error;
                        }
                    }
                    return null;
                };

                /**
                 * Creates a TimeSeriesQueryResponse message from a plain object. Also converts values to their respective internal types.
                 * @param {Object.<string,*>} object Plain object
                 * @returns {cockroach.ts.tspb.TimeSeriesQueryResponse} TimeSeriesQueryResponse
                 */
                TimeSeriesQueryResponse.fromObject = function fromObject(object) {
                    if (object instanceof $root.cockroach.ts.tspb.TimeSeriesQueryResponse)
                        return object;
                    let message = new $root.cockroach.ts.tspb.TimeSeriesQueryResponse();
                    if (object.results) {
                        if (!Array.isArray(object.results))
                            throw TypeError(".cockroach.ts.tspb.TimeSeriesQueryResponse.results: array expected");
                        message.results = [];
                        for (let i = 0; i < object.results.length; ++i) {
                            if (typeof object.results[i] !== "object")
                                throw TypeError(".cockroach.ts.tspb.TimeSeriesQueryResponse.results: object expected");
                            message.results[i] = $root.cockroach.ts.tspb.TimeSeriesQueryResponse.Result.fromObject(object.results[i]);
                        }
                    }
                    return message;
                };

                /**
                 * Creates a TimeSeriesQueryResponse message from a plain object. Also converts values to their respective internal types.
                 * This is an alias of {@link cockroach.ts.tspb.TimeSeriesQueryResponse.fromObject}.
                 * @function
                 * @param {Object.<string,*>} object Plain object
                 * @returns {cockroach.ts.tspb.TimeSeriesQueryResponse} TimeSeriesQueryResponse
                 */
                TimeSeriesQueryResponse.from = TimeSeriesQueryResponse.fromObject;

                /**
                 * Creates a plain object from a TimeSeriesQueryResponse message. Also converts values to other types if specified.
                 * @param {cockroach.ts.tspb.TimeSeriesQueryResponse} message TimeSeriesQueryResponse
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                TimeSeriesQueryResponse.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.arrays || options.defaults)
                        object.results = [];
                    if (message.results && message.results.length) {
                        object.results = [];
                        for (let j = 0; j < message.results.length; ++j)
                            object.results[j] = $root.cockroach.ts.tspb.TimeSeriesQueryResponse.Result.toObject(message.results[j], options);
                    }
                    return object;
                };

                /**
                 * Creates a plain object from this TimeSeriesQueryResponse message. Also converts values to other types if specified.
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                TimeSeriesQueryResponse.prototype.toObject = function toObject(options) {
                    return this.constructor.toObject(this, options);
                };

                /**
                 * Converts this TimeSeriesQueryResponse to JSON.
                 * @returns {Object.<string,*>} JSON object
                 */
                TimeSeriesQueryResponse.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                TimeSeriesQueryResponse.Result = (function() {

                    /**
                     * Properties of a Result.
                     * @typedef cockroach.ts.tspb.TimeSeriesQueryResponse.Result$Properties
                     * @type {Object}
                     * @property {cockroach.ts.tspb.Query$Properties} [query] Result query.
                     * @property {Array.<cockroach.ts.tspb.TimeSeriesDatapoint$Properties>} [datapoints] Result datapoints.
                     */

                    /**
                     * Constructs a new Result.
                     * @exports cockroach.ts.tspb.TimeSeriesQueryResponse.Result
                     * @constructor
                     * @param {cockroach.ts.tspb.TimeSeriesQueryResponse.Result$Properties=} [properties] Properties to set
                     */
                    function Result(properties) {
                        this.datapoints = [];
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * Result query.
                     * @type {(cockroach.ts.tspb.Query$Properties|null)}
                     */
                    Result.prototype.query = null;

                    /**
                     * Result datapoints.
                     * @type {Array.<cockroach.ts.tspb.TimeSeriesDatapoint$Properties>}
                     */
                    Result.prototype.datapoints = $util.emptyArray;

                    /**
                     * Creates a new Result instance using the specified properties.
                     * @param {cockroach.ts.tspb.TimeSeriesQueryResponse.Result$Properties=} [properties] Properties to set
                     * @returns {cockroach.ts.tspb.TimeSeriesQueryResponse.Result} Result instance
                     */
                    Result.create = function create(properties) {
                        return new Result(properties);
                    };

                    /**
                     * Encodes the specified Result message. Does not implicitly {@link cockroach.ts.tspb.TimeSeriesQueryResponse.Result.verify|verify} messages.
                     * @param {cockroach.ts.tspb.TimeSeriesQueryResponse.Result$Properties} message Result message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Result.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.query != null && message.hasOwnProperty("query"))
                            $root.cockroach.ts.tspb.Query.encode(message.query, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                        if (message.datapoints != null && message.datapoints.length)
                            for (let i = 0; i < message.datapoints.length; ++i)
                                $root.cockroach.ts.tspb.TimeSeriesDatapoint.encode(message.datapoints[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                        return writer;
                    };

                    /**
                     * Encodes the specified Result message, length delimited. Does not implicitly {@link cockroach.ts.tspb.TimeSeriesQueryResponse.Result.verify|verify} messages.
                     * @param {cockroach.ts.tspb.TimeSeriesQueryResponse.Result$Properties} message Result message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Result.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a Result message from the specified reader or buffer.
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {cockroach.ts.tspb.TimeSeriesQueryResponse.Result} Result
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Result.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.cockroach.ts.tspb.TimeSeriesQueryResponse.Result();
                        while (reader.pos < end) {
                            let tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.query = $root.cockroach.ts.tspb.Query.decode(reader, reader.uint32());
                                break;
                            case 2:
                                if (!(message.datapoints && message.datapoints.length))
                                    message.datapoints = [];
                                message.datapoints.push($root.cockroach.ts.tspb.TimeSeriesDatapoint.decode(reader, reader.uint32()));
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a Result message from the specified reader or buffer, length delimited.
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {cockroach.ts.tspb.TimeSeriesQueryResponse.Result} Result
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Result.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a Result message.
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {?string} `null` if valid, otherwise the reason why it is not
                     */
                    Result.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.query != null && message.hasOwnProperty("query")) {
                            let error = $root.cockroach.ts.tspb.Query.verify(message.query);
                            if (error)
                                return "query." + error;
                        }
                        if (message.datapoints != null && message.hasOwnProperty("datapoints")) {
                            if (!Array.isArray(message.datapoints))
                                return "datapoints: array expected";
                            for (let i = 0; i < message.datapoints.length; ++i) {
                                let error = $root.cockroach.ts.tspb.TimeSeriesDatapoint.verify(message.datapoints[i]);
                                if (error)
                                    return "datapoints." + error;
                            }
                        }
                        return null;
                    };

                    /**
                     * Creates a Result message from a plain object. Also converts values to their respective internal types.
                     * @param {Object.<string,*>} object Plain object
                     * @returns {cockroach.ts.tspb.TimeSeriesQueryResponse.Result} Result
                     */
                    Result.fromObject = function fromObject(object) {
                        if (object instanceof $root.cockroach.ts.tspb.TimeSeriesQueryResponse.Result)
                            return object;
                        let message = new $root.cockroach.ts.tspb.TimeSeriesQueryResponse.Result();
                        if (object.query != null) {
                            if (typeof object.query !== "object")
                                throw TypeError(".cockroach.ts.tspb.TimeSeriesQueryResponse.Result.query: object expected");
                            message.query = $root.cockroach.ts.tspb.Query.fromObject(object.query);
                        }
                        if (object.datapoints) {
                            if (!Array.isArray(object.datapoints))
                                throw TypeError(".cockroach.ts.tspb.TimeSeriesQueryResponse.Result.datapoints: array expected");
                            message.datapoints = [];
                            for (let i = 0; i < object.datapoints.length; ++i) {
                                if (typeof object.datapoints[i] !== "object")
                                    throw TypeError(".cockroach.ts.tspb.TimeSeriesQueryResponse.Result.datapoints: object expected");
                                message.datapoints[i] = $root.cockroach.ts.tspb.TimeSeriesDatapoint.fromObject(object.datapoints[i]);
                            }
                        }
                        return message;
                    };

                    /**
                     * Creates a Result message from a plain object. Also converts values to their respective internal types.
                     * This is an alias of {@link cockroach.ts.tspb.TimeSeriesQueryResponse.Result.fromObject}.
                     * @function
                     * @param {Object.<string,*>} object Plain object
                     * @returns {cockroach.ts.tspb.TimeSeriesQueryResponse.Result} Result
                     */
                    Result.from = Result.fromObject;

                    /**
                     * Creates a plain object from a Result message. Also converts values to other types if specified.
                     * @param {cockroach.ts.tspb.TimeSeriesQueryResponse.Result} message Result
                     * @param {$protobuf.ConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Result.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.arrays || options.defaults)
                            object.datapoints = [];
                        if (options.defaults)
                            object.query = null;
                        if (message.query != null && message.hasOwnProperty("query"))
                            object.query = $root.cockroach.ts.tspb.Query.toObject(message.query, options);
                        if (message.datapoints && message.datapoints.length) {
                            object.datapoints = [];
                            for (let j = 0; j < message.datapoints.length; ++j)
                                object.datapoints[j] = $root.cockroach.ts.tspb.TimeSeriesDatapoint.toObject(message.datapoints[j], options);
                        }
                        return object;
                    };

                    /**
                     * Creates a plain object from this Result message. Also converts values to other types if specified.
                     * @param {$protobuf.ConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Result.prototype.toObject = function toObject(options) {
                        return this.constructor.toObject(this, options);
                    };

                    /**
                     * Converts this Result to JSON.
                     * @returns {Object.<string,*>} JSON object
                     */
                    Result.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return Result;
                })();

                return TimeSeriesQueryResponse;
            })();

            tspb.TimeSeries = (function() {

                /**
                 * Constructs a new TimeSeries service.
                 * @exports cockroach.ts.tspb.TimeSeries
                 * @extends $protobuf.rpc.Service
                 * @constructor
                 * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
                 * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
                 * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
                 */
                function TimeSeries(rpcImpl, requestDelimited, responseDelimited) {
                    $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
                }

                (TimeSeries.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = TimeSeries;

                /**
                 * Creates new TimeSeries service using the specified rpc implementation.
                 * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
                 * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
                 * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
                 * @returns {TimeSeries} RPC service. Useful where requests and/or responses are streamed.
                 */
                TimeSeries.create = function create(rpcImpl, requestDelimited, responseDelimited) {
                    return new this(rpcImpl, requestDelimited, responseDelimited);
                };

                /**
                 * Callback as used by {@link TimeSeries#query}.
                 * @typedef TimeSeries_query_Callback
                 * @type {function}
                 * @param {?Error} error Error, if any
                 * @param {cockroach.ts.tspb.TimeSeriesQueryResponse} [response] TimeSeriesQueryResponse
                 */

                /**
                 * Calls Query.
                 * @param {cockroach.ts.tspb.TimeSeriesQueryRequest|Object.<string,*>} request TimeSeriesQueryRequest message or plain object
                 * @param {TimeSeries_query_Callback} callback Node-style callback called with the error, if any, and TimeSeriesQueryResponse
                 * @returns {undefined}
                 */
                TimeSeries.prototype.query = function query(request, callback) {
                    return this.rpcCall(query, $root.cockroach.ts.tspb.TimeSeriesQueryRequest, $root.cockroach.ts.tspb.TimeSeriesQueryResponse, request, callback);
                };

                /**
                 * Calls Query.
                 * @name TimeSeries#query
                 * @function
                 * @param {cockroach.ts.tspb.TimeSeriesQueryRequest|Object.<string,*>} request TimeSeriesQueryRequest message or plain object
                 * @returns {Promise<cockroach.ts.tspb.TimeSeriesQueryResponse>} Promise
                 * @variation 2
                 */

                return TimeSeries;
            })();

            return tspb;
        })();

        return ts;
    })();

    return cockroach;
})();

export const gogoproto = $root.gogoproto = (() => {

    /**
     * Namespace gogoproto.
     * @exports gogoproto
     * @namespace
     */
    const gogoproto = {};

    return gogoproto;
})();

export const google = $root.google = (() => {

    /**
     * Namespace google.
     * @exports google
     * @namespace
     */
    const google = {};

    google.protobuf = (function() {

        /**
         * Namespace protobuf.
         * @exports google.protobuf
         * @namespace
         */
        const protobuf = {};

        protobuf.FileDescriptorSet = (function() {

            /**
             * Properties of a FileDescriptorSet.
             * @typedef google.protobuf.FileDescriptorSet$Properties
             * @type {Object}
             * @property {Array.<google.protobuf.FileDescriptorProto$Properties>} [file] FileDescriptorSet file.
             */

            /**
             * Constructs a new FileDescriptorSet.
             * @exports google.protobuf.FileDescriptorSet
             * @constructor
             * @param {google.protobuf.FileDescriptorSet$Properties=} [properties] Properties to set
             */
            function FileDescriptorSet(properties) {
                this.file = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * FileDescriptorSet file.
             * @type {Array.<google.protobuf.FileDescriptorProto$Properties>}
             */
            FileDescriptorSet.prototype.file = $util.emptyArray;

            /**
             * Creates a new FileDescriptorSet instance using the specified properties.
             * @param {google.protobuf.FileDescriptorSet$Properties=} [properties] Properties to set
             * @returns {google.protobuf.FileDescriptorSet} FileDescriptorSet instance
             */
            FileDescriptorSet.create = function create(properties) {
                return new FileDescriptorSet(properties);
            };

            /**
             * Encodes the specified FileDescriptorSet message. Does not implicitly {@link google.protobuf.FileDescriptorSet.verify|verify} messages.
             * @param {google.protobuf.FileDescriptorSet$Properties} message FileDescriptorSet message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FileDescriptorSet.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.file != null && message.file.length)
                    for (let i = 0; i < message.file.length; ++i)
                        $root.google.protobuf.FileDescriptorProto.encode(message.file[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified FileDescriptorSet message, length delimited. Does not implicitly {@link google.protobuf.FileDescriptorSet.verify|verify} messages.
             * @param {google.protobuf.FileDescriptorSet$Properties} message FileDescriptorSet message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FileDescriptorSet.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a FileDescriptorSet message from the specified reader or buffer.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.FileDescriptorSet} FileDescriptorSet
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FileDescriptorSet.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.FileDescriptorSet();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.file && message.file.length))
                            message.file = [];
                        message.file.push($root.google.protobuf.FileDescriptorProto.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a FileDescriptorSet message from the specified reader or buffer, length delimited.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.FileDescriptorSet} FileDescriptorSet
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FileDescriptorSet.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a FileDescriptorSet message.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            FileDescriptorSet.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.file != null && message.hasOwnProperty("file")) {
                    if (!Array.isArray(message.file))
                        return "file: array expected";
                    for (let i = 0; i < message.file.length; ++i) {
                        let error = $root.google.protobuf.FileDescriptorProto.verify(message.file[i]);
                        if (error)
                            return "file." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a FileDescriptorSet message from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.FileDescriptorSet} FileDescriptorSet
             */
            FileDescriptorSet.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.FileDescriptorSet)
                    return object;
                let message = new $root.google.protobuf.FileDescriptorSet();
                if (object.file) {
                    if (!Array.isArray(object.file))
                        throw TypeError(".google.protobuf.FileDescriptorSet.file: array expected");
                    message.file = [];
                    for (let i = 0; i < object.file.length; ++i) {
                        if (typeof object.file[i] !== "object")
                            throw TypeError(".google.protobuf.FileDescriptorSet.file: object expected");
                        message.file[i] = $root.google.protobuf.FileDescriptorProto.fromObject(object.file[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a FileDescriptorSet message from a plain object. Also converts values to their respective internal types.
             * This is an alias of {@link google.protobuf.FileDescriptorSet.fromObject}.
             * @function
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.FileDescriptorSet} FileDescriptorSet
             */
            FileDescriptorSet.from = FileDescriptorSet.fromObject;

            /**
             * Creates a plain object from a FileDescriptorSet message. Also converts values to other types if specified.
             * @param {google.protobuf.FileDescriptorSet} message FileDescriptorSet
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            FileDescriptorSet.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.file = [];
                if (message.file && message.file.length) {
                    object.file = [];
                    for (let j = 0; j < message.file.length; ++j)
                        object.file[j] = $root.google.protobuf.FileDescriptorProto.toObject(message.file[j], options);
                }
                return object;
            };

            /**
             * Creates a plain object from this FileDescriptorSet message. Also converts values to other types if specified.
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            FileDescriptorSet.prototype.toObject = function toObject(options) {
                return this.constructor.toObject(this, options);
            };

            /**
             * Converts this FileDescriptorSet to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            FileDescriptorSet.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return FileDescriptorSet;
        })();

        protobuf.FileDescriptorProto = (function() {

            /**
             * Properties of a FileDescriptorProto.
             * @typedef google.protobuf.FileDescriptorProto$Properties
             * @type {Object}
             * @property {string} [name] FileDescriptorProto name.
             * @property {string} ["package"] FileDescriptorProto package.
             * @property {Array.<string>} [dependency] FileDescriptorProto dependency.
             * @property {Array.<number>} [public_dependency] FileDescriptorProto public_dependency.
             * @property {Array.<number>} [weak_dependency] FileDescriptorProto weak_dependency.
             * @property {Array.<google.protobuf.DescriptorProto$Properties>} [message_type] FileDescriptorProto message_type.
             * @property {Array.<google.protobuf.EnumDescriptorProto$Properties>} [enum_type] FileDescriptorProto enum_type.
             * @property {Array.<google.protobuf.ServiceDescriptorProto$Properties>} [service] FileDescriptorProto service.
             * @property {Array.<google.protobuf.FieldDescriptorProto$Properties>} [extension] FileDescriptorProto extension.
             * @property {google.protobuf.FileOptions$Properties} [options] FileDescriptorProto options.
             * @property {google.protobuf.SourceCodeInfo$Properties} [source_code_info] FileDescriptorProto source_code_info.
             * @property {string} [syntax] FileDescriptorProto syntax.
             */

            /**
             * Constructs a new FileDescriptorProto.
             * @exports google.protobuf.FileDescriptorProto
             * @constructor
             * @param {google.protobuf.FileDescriptorProto$Properties=} [properties] Properties to set
             */
            function FileDescriptorProto(properties) {
                this.dependency = [];
                this.public_dependency = [];
                this.weak_dependency = [];
                this.message_type = [];
                this.enum_type = [];
                this.service = [];
                this.extension = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * FileDescriptorProto name.
             * @type {string}
             */
            FileDescriptorProto.prototype.name = "";

            /**
             * FileDescriptorProto package.
             * @type {string}
             */
            FileDescriptorProto.prototype["package"] = "";

            /**
             * FileDescriptorProto dependency.
             * @type {Array.<string>}
             */
            FileDescriptorProto.prototype.dependency = $util.emptyArray;

            /**
             * FileDescriptorProto public_dependency.
             * @type {Array.<number>}
             */
            FileDescriptorProto.prototype.public_dependency = $util.emptyArray;

            /**
             * FileDescriptorProto weak_dependency.
             * @type {Array.<number>}
             */
            FileDescriptorProto.prototype.weak_dependency = $util.emptyArray;

            /**
             * FileDescriptorProto message_type.
             * @type {Array.<google.protobuf.DescriptorProto$Properties>}
             */
            FileDescriptorProto.prototype.message_type = $util.emptyArray;

            /**
             * FileDescriptorProto enum_type.
             * @type {Array.<google.protobuf.EnumDescriptorProto$Properties>}
             */
            FileDescriptorProto.prototype.enum_type = $util.emptyArray;

            /**
             * FileDescriptorProto service.
             * @type {Array.<google.protobuf.ServiceDescriptorProto$Properties>}
             */
            FileDescriptorProto.prototype.service = $util.emptyArray;

            /**
             * FileDescriptorProto extension.
             * @type {Array.<google.protobuf.FieldDescriptorProto$Properties>}
             */
            FileDescriptorProto.prototype.extension = $util.emptyArray;

            /**
             * FileDescriptorProto options.
             * @type {(google.protobuf.FileOptions$Properties|null)}
             */
            FileDescriptorProto.prototype.options = null;

            /**
             * FileDescriptorProto source_code_info.
             * @type {(google.protobuf.SourceCodeInfo$Properties|null)}
             */
            FileDescriptorProto.prototype.source_code_info = null;

            /**
             * FileDescriptorProto syntax.
             * @type {string}
             */
            FileDescriptorProto.prototype.syntax = "";

            /**
             * Creates a new FileDescriptorProto instance using the specified properties.
             * @param {google.protobuf.FileDescriptorProto$Properties=} [properties] Properties to set
             * @returns {google.protobuf.FileDescriptorProto} FileDescriptorProto instance
             */
            FileDescriptorProto.create = function create(properties) {
                return new FileDescriptorProto(properties);
            };

            /**
             * Encodes the specified FileDescriptorProto message. Does not implicitly {@link google.protobuf.FileDescriptorProto.verify|verify} messages.
             * @param {google.protobuf.FileDescriptorProto$Properties} message FileDescriptorProto message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FileDescriptorProto.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && message.hasOwnProperty("name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                if (message["package"] != null && message.hasOwnProperty("package"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message["package"]);
                if (message.dependency != null && message.dependency.length)
                    for (let i = 0; i < message.dependency.length; ++i)
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.dependency[i]);
                if (message.message_type != null && message.message_type.length)
                    for (let i = 0; i < message.message_type.length; ++i)
                        $root.google.protobuf.DescriptorProto.encode(message.message_type[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.enum_type != null && message.enum_type.length)
                    for (let i = 0; i < message.enum_type.length; ++i)
                        $root.google.protobuf.EnumDescriptorProto.encode(message.enum_type[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                if (message.service != null && message.service.length)
                    for (let i = 0; i < message.service.length; ++i)
                        $root.google.protobuf.ServiceDescriptorProto.encode(message.service[i], writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                if (message.extension != null && message.extension.length)
                    for (let i = 0; i < message.extension.length; ++i)
                        $root.google.protobuf.FieldDescriptorProto.encode(message.extension[i], writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                if (message.options != null && message.hasOwnProperty("options"))
                    $root.google.protobuf.FileOptions.encode(message.options, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                if (message.source_code_info != null && message.hasOwnProperty("source_code_info"))
                    $root.google.protobuf.SourceCodeInfo.encode(message.source_code_info, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
                if (message.public_dependency != null && message.public_dependency.length)
                    for (let i = 0; i < message.public_dependency.length; ++i)
                        writer.uint32(/* id 10, wireType 0 =*/80).int32(message.public_dependency[i]);
                if (message.weak_dependency != null && message.weak_dependency.length)
                    for (let i = 0; i < message.weak_dependency.length; ++i)
                        writer.uint32(/* id 11, wireType 0 =*/88).int32(message.weak_dependency[i]);
                if (message.syntax != null && message.hasOwnProperty("syntax"))
                    writer.uint32(/* id 12, wireType 2 =*/98).string(message.syntax);
                return writer;
            };

            /**
             * Encodes the specified FileDescriptorProto message, length delimited. Does not implicitly {@link google.protobuf.FileDescriptorProto.verify|verify} messages.
             * @param {google.protobuf.FileDescriptorProto$Properties} message FileDescriptorProto message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FileDescriptorProto.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a FileDescriptorProto message from the specified reader or buffer.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.FileDescriptorProto} FileDescriptorProto
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FileDescriptorProto.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.FileDescriptorProto();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.name = reader.string();
                        break;
                    case 2:
                        message["package"] = reader.string();
                        break;
                    case 3:
                        if (!(message.dependency && message.dependency.length))
                            message.dependency = [];
                        message.dependency.push(reader.string());
                        break;
                    case 10:
                        if (!(message.public_dependency && message.public_dependency.length))
                            message.public_dependency = [];
                        if ((tag & 7) === 2) {
                            let end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.public_dependency.push(reader.int32());
                        } else
                            message.public_dependency.push(reader.int32());
                        break;
                    case 11:
                        if (!(message.weak_dependency && message.weak_dependency.length))
                            message.weak_dependency = [];
                        if ((tag & 7) === 2) {
                            let end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.weak_dependency.push(reader.int32());
                        } else
                            message.weak_dependency.push(reader.int32());
                        break;
                    case 4:
                        if (!(message.message_type && message.message_type.length))
                            message.message_type = [];
                        message.message_type.push($root.google.protobuf.DescriptorProto.decode(reader, reader.uint32()));
                        break;
                    case 5:
                        if (!(message.enum_type && message.enum_type.length))
                            message.enum_type = [];
                        message.enum_type.push($root.google.protobuf.EnumDescriptorProto.decode(reader, reader.uint32()));
                        break;
                    case 6:
                        if (!(message.service && message.service.length))
                            message.service = [];
                        message.service.push($root.google.protobuf.ServiceDescriptorProto.decode(reader, reader.uint32()));
                        break;
                    case 7:
                        if (!(message.extension && message.extension.length))
                            message.extension = [];
                        message.extension.push($root.google.protobuf.FieldDescriptorProto.decode(reader, reader.uint32()));
                        break;
                    case 8:
                        message.options = $root.google.protobuf.FileOptions.decode(reader, reader.uint32());
                        break;
                    case 9:
                        message.source_code_info = $root.google.protobuf.SourceCodeInfo.decode(reader, reader.uint32());
                        break;
                    case 12:
                        message.syntax = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a FileDescriptorProto message from the specified reader or buffer, length delimited.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.FileDescriptorProto} FileDescriptorProto
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FileDescriptorProto.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a FileDescriptorProto message.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            FileDescriptorProto.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message["package"] != null && message.hasOwnProperty("package"))
                    if (!$util.isString(message["package"]))
                        return "package: string expected";
                if (message.dependency != null && message.hasOwnProperty("dependency")) {
                    if (!Array.isArray(message.dependency))
                        return "dependency: array expected";
                    for (let i = 0; i < message.dependency.length; ++i)
                        if (!$util.isString(message.dependency[i]))
                            return "dependency: string[] expected";
                }
                if (message.public_dependency != null && message.hasOwnProperty("public_dependency")) {
                    if (!Array.isArray(message.public_dependency))
                        return "public_dependency: array expected";
                    for (let i = 0; i < message.public_dependency.length; ++i)
                        if (!$util.isInteger(message.public_dependency[i]))
                            return "public_dependency: integer[] expected";
                }
                if (message.weak_dependency != null && message.hasOwnProperty("weak_dependency")) {
                    if (!Array.isArray(message.weak_dependency))
                        return "weak_dependency: array expected";
                    for (let i = 0; i < message.weak_dependency.length; ++i)
                        if (!$util.isInteger(message.weak_dependency[i]))
                            return "weak_dependency: integer[] expected";
                }
                if (message.message_type != null && message.hasOwnProperty("message_type")) {
                    if (!Array.isArray(message.message_type))
                        return "message_type: array expected";
                    for (let i = 0; i < message.message_type.length; ++i) {
                        let error = $root.google.protobuf.DescriptorProto.verify(message.message_type[i]);
                        if (error)
                            return "message_type." + error;
                    }
                }
                if (message.enum_type != null && message.hasOwnProperty("enum_type")) {
                    if (!Array.isArray(message.enum_type))
                        return "enum_type: array expected";
                    for (let i = 0; i < message.enum_type.length; ++i) {
                        let error = $root.google.protobuf.EnumDescriptorProto.verify(message.enum_type[i]);
                        if (error)
                            return "enum_type." + error;
                    }
                }
                if (message.service != null && message.hasOwnProperty("service")) {
                    if (!Array.isArray(message.service))
                        return "service: array expected";
                    for (let i = 0; i < message.service.length; ++i) {
                        let error = $root.google.protobuf.ServiceDescriptorProto.verify(message.service[i]);
                        if (error)
                            return "service." + error;
                    }
                }
                if (message.extension != null && message.hasOwnProperty("extension")) {
                    if (!Array.isArray(message.extension))
                        return "extension: array expected";
                    for (let i = 0; i < message.extension.length; ++i) {
                        let error = $root.google.protobuf.FieldDescriptorProto.verify(message.extension[i]);
                        if (error)
                            return "extension." + error;
                    }
                }
                if (message.options != null && message.hasOwnProperty("options")) {
                    let error = $root.google.protobuf.FileOptions.verify(message.options);
                    if (error)
                        return "options." + error;
                }
                if (message.source_code_info != null && message.hasOwnProperty("source_code_info")) {
                    let error = $root.google.protobuf.SourceCodeInfo.verify(message.source_code_info);
                    if (error)
                        return "source_code_info." + error;
                }
                if (message.syntax != null && message.hasOwnProperty("syntax"))
                    if (!$util.isString(message.syntax))
                        return "syntax: string expected";
                return null;
            };

            /**
             * Creates a FileDescriptorProto message from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.FileDescriptorProto} FileDescriptorProto
             */
            FileDescriptorProto.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.FileDescriptorProto)
                    return object;
                let message = new $root.google.protobuf.FileDescriptorProto();
                if (object.name != null)
                    message.name = String(object.name);
                if (object["package"] != null)
                    message["package"] = String(object["package"]);
                if (object.dependency) {
                    if (!Array.isArray(object.dependency))
                        throw TypeError(".google.protobuf.FileDescriptorProto.dependency: array expected");
                    message.dependency = [];
                    for (let i = 0; i < object.dependency.length; ++i)
                        message.dependency[i] = String(object.dependency[i]);
                }
                if (object.public_dependency) {
                    if (!Array.isArray(object.public_dependency))
                        throw TypeError(".google.protobuf.FileDescriptorProto.public_dependency: array expected");
                    message.public_dependency = [];
                    for (let i = 0; i < object.public_dependency.length; ++i)
                        message.public_dependency[i] = object.public_dependency[i] | 0;
                }
                if (object.weak_dependency) {
                    if (!Array.isArray(object.weak_dependency))
                        throw TypeError(".google.protobuf.FileDescriptorProto.weak_dependency: array expected");
                    message.weak_dependency = [];
                    for (let i = 0; i < object.weak_dependency.length; ++i)
                        message.weak_dependency[i] = object.weak_dependency[i] | 0;
                }
                if (object.message_type) {
                    if (!Array.isArray(object.message_type))
                        throw TypeError(".google.protobuf.FileDescriptorProto.message_type: array expected");
                    message.message_type = [];
                    for (let i = 0; i < object.message_type.length; ++i) {
                        if (typeof object.message_type[i] !== "object")
                            throw TypeError(".google.protobuf.FileDescriptorProto.message_type: object expected");
                        message.message_type[i] = $root.google.protobuf.DescriptorProto.fromObject(object.message_type[i]);
                    }
                }
                if (object.enum_type) {
                    if (!Array.isArray(object.enum_type))
                        throw TypeError(".google.protobuf.FileDescriptorProto.enum_type: array expected");
                    message.enum_type = [];
                    for (let i = 0; i < object.enum_type.length; ++i) {
                        if (typeof object.enum_type[i] !== "object")
                            throw TypeError(".google.protobuf.FileDescriptorProto.enum_type: object expected");
                        message.enum_type[i] = $root.google.protobuf.EnumDescriptorProto.fromObject(object.enum_type[i]);
                    }
                }
                if (object.service) {
                    if (!Array.isArray(object.service))
                        throw TypeError(".google.protobuf.FileDescriptorProto.service: array expected");
                    message.service = [];
                    for (let i = 0; i < object.service.length; ++i) {
                        if (typeof object.service[i] !== "object")
                            throw TypeError(".google.protobuf.FileDescriptorProto.service: object expected");
                        message.service[i] = $root.google.protobuf.ServiceDescriptorProto.fromObject(object.service[i]);
                    }
                }
                if (object.extension) {
                    if (!Array.isArray(object.extension))
                        throw TypeError(".google.protobuf.FileDescriptorProto.extension: array expected");
                    message.extension = [];
                    for (let i = 0; i < object.extension.length; ++i) {
                        if (typeof object.extension[i] !== "object")
                            throw TypeError(".google.protobuf.FileDescriptorProto.extension: object expected");
                        message.extension[i] = $root.google.protobuf.FieldDescriptorProto.fromObject(object.extension[i]);
                    }
                }
                if (object.options != null) {
                    if (typeof object.options !== "object")
                        throw TypeError(".google.protobuf.FileDescriptorProto.options: object expected");
                    message.options = $root.google.protobuf.FileOptions.fromObject(object.options);
                }
                if (object.source_code_info != null) {
                    if (typeof object.source_code_info !== "object")
                        throw TypeError(".google.protobuf.FileDescriptorProto.source_code_info: object expected");
                    message.source_code_info = $root.google.protobuf.SourceCodeInfo.fromObject(object.source_code_info);
                }
                if (object.syntax != null)
                    message.syntax = String(object.syntax);
                return message;
            };

            /**
             * Creates a FileDescriptorProto message from a plain object. Also converts values to their respective internal types.
             * This is an alias of {@link google.protobuf.FileDescriptorProto.fromObject}.
             * @function
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.FileDescriptorProto} FileDescriptorProto
             */
            FileDescriptorProto.from = FileDescriptorProto.fromObject;

            /**
             * Creates a plain object from a FileDescriptorProto message. Also converts values to other types if specified.
             * @param {google.protobuf.FileDescriptorProto} message FileDescriptorProto
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            FileDescriptorProto.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults) {
                    object.dependency = [];
                    object.message_type = [];
                    object.enum_type = [];
                    object.service = [];
                    object.extension = [];
                    object.public_dependency = [];
                    object.weak_dependency = [];
                }
                if (options.defaults) {
                    object.name = "";
                    object["package"] = "";
                    object.options = null;
                    object.source_code_info = null;
                    object.syntax = "";
                }
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message["package"] != null && message.hasOwnProperty("package"))
                    object["package"] = message["package"];
                if (message.dependency && message.dependency.length) {
                    object.dependency = [];
                    for (let j = 0; j < message.dependency.length; ++j)
                        object.dependency[j] = message.dependency[j];
                }
                if (message.message_type && message.message_type.length) {
                    object.message_type = [];
                    for (let j = 0; j < message.message_type.length; ++j)
                        object.message_type[j] = $root.google.protobuf.DescriptorProto.toObject(message.message_type[j], options);
                }
                if (message.enum_type && message.enum_type.length) {
                    object.enum_type = [];
                    for (let j = 0; j < message.enum_type.length; ++j)
                        object.enum_type[j] = $root.google.protobuf.EnumDescriptorProto.toObject(message.enum_type[j], options);
                }
                if (message.service && message.service.length) {
                    object.service = [];
                    for (let j = 0; j < message.service.length; ++j)
                        object.service[j] = $root.google.protobuf.ServiceDescriptorProto.toObject(message.service[j], options);
                }
                if (message.extension && message.extension.length) {
                    object.extension = [];
                    for (let j = 0; j < message.extension.length; ++j)
                        object.extension[j] = $root.google.protobuf.FieldDescriptorProto.toObject(message.extension[j], options);
                }
                if (message.options != null && message.hasOwnProperty("options"))
                    object.options = $root.google.protobuf.FileOptions.toObject(message.options, options);
                if (message.source_code_info != null && message.hasOwnProperty("source_code_info"))
                    object.source_code_info = $root.google.protobuf.SourceCodeInfo.toObject(message.source_code_info, options);
                if (message.public_dependency && message.public_dependency.length) {
                    object.public_dependency = [];
                    for (let j = 0; j < message.public_dependency.length; ++j)
                        object.public_dependency[j] = message.public_dependency[j];
                }
                if (message.weak_dependency && message.weak_dependency.length) {
                    object.weak_dependency = [];
                    for (let j = 0; j < message.weak_dependency.length; ++j)
                        object.weak_dependency[j] = message.weak_dependency[j];
                }
                if (message.syntax != null && message.hasOwnProperty("syntax"))
                    object.syntax = message.syntax;
                return object;
            };

            /**
             * Creates a plain object from this FileDescriptorProto message. Also converts values to other types if specified.
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            FileDescriptorProto.prototype.toObject = function toObject(options) {
                return this.constructor.toObject(this, options);
            };

            /**
             * Converts this FileDescriptorProto to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            FileDescriptorProto.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return FileDescriptorProto;
        })();

        protobuf.DescriptorProto = (function() {

            /**
             * Properties of a DescriptorProto.
             * @typedef google.protobuf.DescriptorProto$Properties
             * @type {Object}
             * @property {string} [name] DescriptorProto name.
             * @property {Array.<google.protobuf.FieldDescriptorProto$Properties>} [field] DescriptorProto field.
             * @property {Array.<google.protobuf.FieldDescriptorProto$Properties>} [extension] DescriptorProto extension.
             * @property {Array.<google.protobuf.DescriptorProto$Properties>} [nested_type] DescriptorProto nested_type.
             * @property {Array.<google.protobuf.EnumDescriptorProto$Properties>} [enum_type] DescriptorProto enum_type.
             * @property {Array.<google.protobuf.DescriptorProto.ExtensionRange$Properties>} [extension_range] DescriptorProto extension_range.
             * @property {Array.<google.protobuf.OneofDescriptorProto$Properties>} [oneof_decl] DescriptorProto oneof_decl.
             * @property {google.protobuf.MessageOptions$Properties} [options] DescriptorProto options.
             * @property {Array.<google.protobuf.DescriptorProto.ReservedRange$Properties>} [reserved_range] DescriptorProto reserved_range.
             * @property {Array.<string>} [reserved_name] DescriptorProto reserved_name.
             */

            /**
             * Constructs a new DescriptorProto.
             * @exports google.protobuf.DescriptorProto
             * @constructor
             * @param {google.protobuf.DescriptorProto$Properties=} [properties] Properties to set
             */
            function DescriptorProto(properties) {
                this.field = [];
                this.extension = [];
                this.nested_type = [];
                this.enum_type = [];
                this.extension_range = [];
                this.oneof_decl = [];
                this.reserved_range = [];
                this.reserved_name = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * DescriptorProto name.
             * @type {string}
             */
            DescriptorProto.prototype.name = "";

            /**
             * DescriptorProto field.
             * @type {Array.<google.protobuf.FieldDescriptorProto$Properties>}
             */
            DescriptorProto.prototype.field = $util.emptyArray;

            /**
             * DescriptorProto extension.
             * @type {Array.<google.protobuf.FieldDescriptorProto$Properties>}
             */
            DescriptorProto.prototype.extension = $util.emptyArray;

            /**
             * DescriptorProto nested_type.
             * @type {Array.<google.protobuf.DescriptorProto$Properties>}
             */
            DescriptorProto.prototype.nested_type = $util.emptyArray;

            /**
             * DescriptorProto enum_type.
             * @type {Array.<google.protobuf.EnumDescriptorProto$Properties>}
             */
            DescriptorProto.prototype.enum_type = $util.emptyArray;

            /**
             * DescriptorProto extension_range.
             * @type {Array.<google.protobuf.DescriptorProto.ExtensionRange$Properties>}
             */
            DescriptorProto.prototype.extension_range = $util.emptyArray;

            /**
             * DescriptorProto oneof_decl.
             * @type {Array.<google.protobuf.OneofDescriptorProto$Properties>}
             */
            DescriptorProto.prototype.oneof_decl = $util.emptyArray;

            /**
             * DescriptorProto options.
             * @type {(google.protobuf.MessageOptions$Properties|null)}
             */
            DescriptorProto.prototype.options = null;

            /**
             * DescriptorProto reserved_range.
             * @type {Array.<google.protobuf.DescriptorProto.ReservedRange$Properties>}
             */
            DescriptorProto.prototype.reserved_range = $util.emptyArray;

            /**
             * DescriptorProto reserved_name.
             * @type {Array.<string>}
             */
            DescriptorProto.prototype.reserved_name = $util.emptyArray;

            /**
             * Creates a new DescriptorProto instance using the specified properties.
             * @param {google.protobuf.DescriptorProto$Properties=} [properties] Properties to set
             * @returns {google.protobuf.DescriptorProto} DescriptorProto instance
             */
            DescriptorProto.create = function create(properties) {
                return new DescriptorProto(properties);
            };

            /**
             * Encodes the specified DescriptorProto message. Does not implicitly {@link google.protobuf.DescriptorProto.verify|verify} messages.
             * @param {google.protobuf.DescriptorProto$Properties} message DescriptorProto message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DescriptorProto.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && message.hasOwnProperty("name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                if (message.field != null && message.field.length)
                    for (let i = 0; i < message.field.length; ++i)
                        $root.google.protobuf.FieldDescriptorProto.encode(message.field[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.nested_type != null && message.nested_type.length)
                    for (let i = 0; i < message.nested_type.length; ++i)
                        $root.google.protobuf.DescriptorProto.encode(message.nested_type[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.enum_type != null && message.enum_type.length)
                    for (let i = 0; i < message.enum_type.length; ++i)
                        $root.google.protobuf.EnumDescriptorProto.encode(message.enum_type[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.extension_range != null && message.extension_range.length)
                    for (let i = 0; i < message.extension_range.length; ++i)
                        $root.google.protobuf.DescriptorProto.ExtensionRange.encode(message.extension_range[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                if (message.extension != null && message.extension.length)
                    for (let i = 0; i < message.extension.length; ++i)
                        $root.google.protobuf.FieldDescriptorProto.encode(message.extension[i], writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                if (message.options != null && message.hasOwnProperty("options"))
                    $root.google.protobuf.MessageOptions.encode(message.options, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                if (message.oneof_decl != null && message.oneof_decl.length)
                    for (let i = 0; i < message.oneof_decl.length; ++i)
                        $root.google.protobuf.OneofDescriptorProto.encode(message.oneof_decl[i], writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                if (message.reserved_range != null && message.reserved_range.length)
                    for (let i = 0; i < message.reserved_range.length; ++i)
                        $root.google.protobuf.DescriptorProto.ReservedRange.encode(message.reserved_range[i], writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
                if (message.reserved_name != null && message.reserved_name.length)
                    for (let i = 0; i < message.reserved_name.length; ++i)
                        writer.uint32(/* id 10, wireType 2 =*/82).string(message.reserved_name[i]);
                return writer;
            };

            /**
             * Encodes the specified DescriptorProto message, length delimited. Does not implicitly {@link google.protobuf.DescriptorProto.verify|verify} messages.
             * @param {google.protobuf.DescriptorProto$Properties} message DescriptorProto message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DescriptorProto.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a DescriptorProto message from the specified reader or buffer.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.DescriptorProto} DescriptorProto
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DescriptorProto.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.DescriptorProto();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.name = reader.string();
                        break;
                    case 2:
                        if (!(message.field && message.field.length))
                            message.field = [];
                        message.field.push($root.google.protobuf.FieldDescriptorProto.decode(reader, reader.uint32()));
                        break;
                    case 6:
                        if (!(message.extension && message.extension.length))
                            message.extension = [];
                        message.extension.push($root.google.protobuf.FieldDescriptorProto.decode(reader, reader.uint32()));
                        break;
                    case 3:
                        if (!(message.nested_type && message.nested_type.length))
                            message.nested_type = [];
                        message.nested_type.push($root.google.protobuf.DescriptorProto.decode(reader, reader.uint32()));
                        break;
                    case 4:
                        if (!(message.enum_type && message.enum_type.length))
                            message.enum_type = [];
                        message.enum_type.push($root.google.protobuf.EnumDescriptorProto.decode(reader, reader.uint32()));
                        break;
                    case 5:
                        if (!(message.extension_range && message.extension_range.length))
                            message.extension_range = [];
                        message.extension_range.push($root.google.protobuf.DescriptorProto.ExtensionRange.decode(reader, reader.uint32()));
                        break;
                    case 8:
                        if (!(message.oneof_decl && message.oneof_decl.length))
                            message.oneof_decl = [];
                        message.oneof_decl.push($root.google.protobuf.OneofDescriptorProto.decode(reader, reader.uint32()));
                        break;
                    case 7:
                        message.options = $root.google.protobuf.MessageOptions.decode(reader, reader.uint32());
                        break;
                    case 9:
                        if (!(message.reserved_range && message.reserved_range.length))
                            message.reserved_range = [];
                        message.reserved_range.push($root.google.protobuf.DescriptorProto.ReservedRange.decode(reader, reader.uint32()));
                        break;
                    case 10:
                        if (!(message.reserved_name && message.reserved_name.length))
                            message.reserved_name = [];
                        message.reserved_name.push(reader.string());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a DescriptorProto message from the specified reader or buffer, length delimited.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.DescriptorProto} DescriptorProto
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DescriptorProto.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a DescriptorProto message.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            DescriptorProto.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.field != null && message.hasOwnProperty("field")) {
                    if (!Array.isArray(message.field))
                        return "field: array expected";
                    for (let i = 0; i < message.field.length; ++i) {
                        let error = $root.google.protobuf.FieldDescriptorProto.verify(message.field[i]);
                        if (error)
                            return "field." + error;
                    }
                }
                if (message.extension != null && message.hasOwnProperty("extension")) {
                    if (!Array.isArray(message.extension))
                        return "extension: array expected";
                    for (let i = 0; i < message.extension.length; ++i) {
                        let error = $root.google.protobuf.FieldDescriptorProto.verify(message.extension[i]);
                        if (error)
                            return "extension." + error;
                    }
                }
                if (message.nested_type != null && message.hasOwnProperty("nested_type")) {
                    if (!Array.isArray(message.nested_type))
                        return "nested_type: array expected";
                    for (let i = 0; i < message.nested_type.length; ++i) {
                        let error = $root.google.protobuf.DescriptorProto.verify(message.nested_type[i]);
                        if (error)
                            return "nested_type." + error;
                    }
                }
                if (message.enum_type != null && message.hasOwnProperty("enum_type")) {
                    if (!Array.isArray(message.enum_type))
                        return "enum_type: array expected";
                    for (let i = 0; i < message.enum_type.length; ++i) {
                        let error = $root.google.protobuf.EnumDescriptorProto.verify(message.enum_type[i]);
                        if (error)
                            return "enum_type." + error;
                    }
                }
                if (message.extension_range != null && message.hasOwnProperty("extension_range")) {
                    if (!Array.isArray(message.extension_range))
                        return "extension_range: array expected";
                    for (let i = 0; i < message.extension_range.length; ++i) {
                        let error = $root.google.protobuf.DescriptorProto.ExtensionRange.verify(message.extension_range[i]);
                        if (error)
                            return "extension_range." + error;
                    }
                }
                if (message.oneof_decl != null && message.hasOwnProperty("oneof_decl")) {
                    if (!Array.isArray(message.oneof_decl))
                        return "oneof_decl: array expected";
                    for (let i = 0; i < message.oneof_decl.length; ++i) {
                        let error = $root.google.protobuf.OneofDescriptorProto.verify(message.oneof_decl[i]);
                        if (error)
                            return "oneof_decl." + error;
                    }
                }
                if (message.options != null && message.hasOwnProperty("options")) {
                    let error = $root.google.protobuf.MessageOptions.verify(message.options);
                    if (error)
                        return "options." + error;
                }
                if (message.reserved_range != null && message.hasOwnProperty("reserved_range")) {
                    if (!Array.isArray(message.reserved_range))
                        return "reserved_range: array expected";
                    for (let i = 0; i < message.reserved_range.length; ++i) {
                        let error = $root.google.protobuf.DescriptorProto.ReservedRange.verify(message.reserved_range[i]);
                        if (error)
                            return "reserved_range." + error;
                    }
                }
                if (message.reserved_name != null && message.hasOwnProperty("reserved_name")) {
                    if (!Array.isArray(message.reserved_name))
                        return "reserved_name: array expected";
                    for (let i = 0; i < message.reserved_name.length; ++i)
                        if (!$util.isString(message.reserved_name[i]))
                            return "reserved_name: string[] expected";
                }
                return null;
            };

            /**
             * Creates a DescriptorProto message from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.DescriptorProto} DescriptorProto
             */
            DescriptorProto.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.DescriptorProto)
                    return object;
                let message = new $root.google.protobuf.DescriptorProto();
                if (object.name != null)
                    message.name = String(object.name);
                if (object.field) {
                    if (!Array.isArray(object.field))
                        throw TypeError(".google.protobuf.DescriptorProto.field: array expected");
                    message.field = [];
                    for (let i = 0; i < object.field.length; ++i) {
                        if (typeof object.field[i] !== "object")
                            throw TypeError(".google.protobuf.DescriptorProto.field: object expected");
                        message.field[i] = $root.google.protobuf.FieldDescriptorProto.fromObject(object.field[i]);
                    }
                }
                if (object.extension) {
                    if (!Array.isArray(object.extension))
                        throw TypeError(".google.protobuf.DescriptorProto.extension: array expected");
                    message.extension = [];
                    for (let i = 0; i < object.extension.length; ++i) {
                        if (typeof object.extension[i] !== "object")
                            throw TypeError(".google.protobuf.DescriptorProto.extension: object expected");
                        message.extension[i] = $root.google.protobuf.FieldDescriptorProto.fromObject(object.extension[i]);
                    }
                }
                if (object.nested_type) {
                    if (!Array.isArray(object.nested_type))
                        throw TypeError(".google.protobuf.DescriptorProto.nested_type: array expected");
                    message.nested_type = [];
                    for (let i = 0; i < object.nested_type.length; ++i) {
                        if (typeof object.nested_type[i] !== "object")
                            throw TypeError(".google.protobuf.DescriptorProto.nested_type: object expected");
                        message.nested_type[i] = $root.google.protobuf.DescriptorProto.fromObject(object.nested_type[i]);
                    }
                }
                if (object.enum_type) {
                    if (!Array.isArray(object.enum_type))
                        throw TypeError(".google.protobuf.DescriptorProto.enum_type: array expected");
                    message.enum_type = [];
                    for (let i = 0; i < object.enum_type.length; ++i) {
                        if (typeof object.enum_type[i] !== "object")
                            throw TypeError(".google.protobuf.DescriptorProto.enum_type: object expected");
                        message.enum_type[i] = $root.google.protobuf.EnumDescriptorProto.fromObject(object.enum_type[i]);
                    }
                }
                if (object.extension_range) {
                    if (!Array.isArray(object.extension_range))
                        throw TypeError(".google.protobuf.DescriptorProto.extension_range: array expected");
                    message.extension_range = [];
                    for (let i = 0; i < object.extension_range.length; ++i) {
                        if (typeof object.extension_range[i] !== "object")
                            throw TypeError(".google.protobuf.DescriptorProto.extension_range: object expected");
                        message.extension_range[i] = $root.google.protobuf.DescriptorProto.ExtensionRange.fromObject(object.extension_range[i]);
                    }
                }
                if (object.oneof_decl) {
                    if (!Array.isArray(object.oneof_decl))
                        throw TypeError(".google.protobuf.DescriptorProto.oneof_decl: array expected");
                    message.oneof_decl = [];
                    for (let i = 0; i < object.oneof_decl.length; ++i) {
                        if (typeof object.oneof_decl[i] !== "object")
                            throw TypeError(".google.protobuf.DescriptorProto.oneof_decl: object expected");
                        message.oneof_decl[i] = $root.google.protobuf.OneofDescriptorProto.fromObject(object.oneof_decl[i]);
                    }
                }
                if (object.options != null) {
                    if (typeof object.options !== "object")
                        throw TypeError(".google.protobuf.DescriptorProto.options: object expected");
                    message.options = $root.google.protobuf.MessageOptions.fromObject(object.options);
                }
                if (object.reserved_range) {
                    if (!Array.isArray(object.reserved_range))
                        throw TypeError(".google.protobuf.DescriptorProto.reserved_range: array expected");
                    message.reserved_range = [];
                    for (let i = 0; i < object.reserved_range.length; ++i) {
                        if (typeof object.reserved_range[i] !== "object")
                            throw TypeError(".google.protobuf.DescriptorProto.reserved_range: object expected");
                        message.reserved_range[i] = $root.google.protobuf.DescriptorProto.ReservedRange.fromObject(object.reserved_range[i]);
                    }
                }
                if (object.reserved_name) {
                    if (!Array.isArray(object.reserved_name))
                        throw TypeError(".google.protobuf.DescriptorProto.reserved_name: array expected");
                    message.reserved_name = [];
                    for (let i = 0; i < object.reserved_name.length; ++i)
                        message.reserved_name[i] = String(object.reserved_name[i]);
                }
                return message;
            };

            /**
             * Creates a DescriptorProto message from a plain object. Also converts values to their respective internal types.
             * This is an alias of {@link google.protobuf.DescriptorProto.fromObject}.
             * @function
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.DescriptorProto} DescriptorProto
             */
            DescriptorProto.from = DescriptorProto.fromObject;

            /**
             * Creates a plain object from a DescriptorProto message. Also converts values to other types if specified.
             * @param {google.protobuf.DescriptorProto} message DescriptorProto
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DescriptorProto.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults) {
                    object.field = [];
                    object.nested_type = [];
                    object.enum_type = [];
                    object.extension_range = [];
                    object.extension = [];
                    object.oneof_decl = [];
                    object.reserved_range = [];
                    object.reserved_name = [];
                }
                if (options.defaults) {
                    object.name = "";
                    object.options = null;
                }
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.field && message.field.length) {
                    object.field = [];
                    for (let j = 0; j < message.field.length; ++j)
                        object.field[j] = $root.google.protobuf.FieldDescriptorProto.toObject(message.field[j], options);
                }
                if (message.nested_type && message.nested_type.length) {
                    object.nested_type = [];
                    for (let j = 0; j < message.nested_type.length; ++j)
                        object.nested_type[j] = $root.google.protobuf.DescriptorProto.toObject(message.nested_type[j], options);
                }
                if (message.enum_type && message.enum_type.length) {
                    object.enum_type = [];
                    for (let j = 0; j < message.enum_type.length; ++j)
                        object.enum_type[j] = $root.google.protobuf.EnumDescriptorProto.toObject(message.enum_type[j], options);
                }
                if (message.extension_range && message.extension_range.length) {
                    object.extension_range = [];
                    for (let j = 0; j < message.extension_range.length; ++j)
                        object.extension_range[j] = $root.google.protobuf.DescriptorProto.ExtensionRange.toObject(message.extension_range[j], options);
                }
                if (message.extension && message.extension.length) {
                    object.extension = [];
                    for (let j = 0; j < message.extension.length; ++j)
                        object.extension[j] = $root.google.protobuf.FieldDescriptorProto.toObject(message.extension[j], options);
                }
                if (message.options != null && message.hasOwnProperty("options"))
                    object.options = $root.google.protobuf.MessageOptions.toObject(message.options, options);
                if (message.oneof_decl && message.oneof_decl.length) {
                    object.oneof_decl = [];
                    for (let j = 0; j < message.oneof_decl.length; ++j)
                        object.oneof_decl[j] = $root.google.protobuf.OneofDescriptorProto.toObject(message.oneof_decl[j], options);
                }
                if (message.reserved_range && message.reserved_range.length) {
                    object.reserved_range = [];
                    for (let j = 0; j < message.reserved_range.length; ++j)
                        object.reserved_range[j] = $root.google.protobuf.DescriptorProto.ReservedRange.toObject(message.reserved_range[j], options);
                }
                if (message.reserved_name && message.reserved_name.length) {
                    object.reserved_name = [];
                    for (let j = 0; j < message.reserved_name.length; ++j)
                        object.reserved_name[j] = message.reserved_name[j];
                }
                return object;
            };

            /**
             * Creates a plain object from this DescriptorProto message. Also converts values to other types if specified.
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DescriptorProto.prototype.toObject = function toObject(options) {
                return this.constructor.toObject(this, options);
            };

            /**
             * Converts this DescriptorProto to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            DescriptorProto.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            DescriptorProto.ExtensionRange = (function() {

                /**
                 * Properties of an ExtensionRange.
                 * @typedef google.protobuf.DescriptorProto.ExtensionRange$Properties
                 * @type {Object}
                 * @property {number} [start] ExtensionRange start.
                 * @property {number} [end] ExtensionRange end.
                 */

                /**
                 * Constructs a new ExtensionRange.
                 * @exports google.protobuf.DescriptorProto.ExtensionRange
                 * @constructor
                 * @param {google.protobuf.DescriptorProto.ExtensionRange$Properties=} [properties] Properties to set
                 */
                function ExtensionRange(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * ExtensionRange start.
                 * @type {number}
                 */
                ExtensionRange.prototype.start = 0;

                /**
                 * ExtensionRange end.
                 * @type {number}
                 */
                ExtensionRange.prototype.end = 0;

                /**
                 * Creates a new ExtensionRange instance using the specified properties.
                 * @param {google.protobuf.DescriptorProto.ExtensionRange$Properties=} [properties] Properties to set
                 * @returns {google.protobuf.DescriptorProto.ExtensionRange} ExtensionRange instance
                 */
                ExtensionRange.create = function create(properties) {
                    return new ExtensionRange(properties);
                };

                /**
                 * Encodes the specified ExtensionRange message. Does not implicitly {@link google.protobuf.DescriptorProto.ExtensionRange.verify|verify} messages.
                 * @param {google.protobuf.DescriptorProto.ExtensionRange$Properties} message ExtensionRange message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ExtensionRange.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.start != null && message.hasOwnProperty("start"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.start);
                    if (message.end != null && message.hasOwnProperty("end"))
                        writer.uint32(/* id 2, wireType 0 =*/16).int32(message.end);
                    return writer;
                };

                /**
                 * Encodes the specified ExtensionRange message, length delimited. Does not implicitly {@link google.protobuf.DescriptorProto.ExtensionRange.verify|verify} messages.
                 * @param {google.protobuf.DescriptorProto.ExtensionRange$Properties} message ExtensionRange message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ExtensionRange.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes an ExtensionRange message from the specified reader or buffer.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.DescriptorProto.ExtensionRange} ExtensionRange
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ExtensionRange.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.DescriptorProto.ExtensionRange();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.start = reader.int32();
                            break;
                        case 2:
                            message.end = reader.int32();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes an ExtensionRange message from the specified reader or buffer, length delimited.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {google.protobuf.DescriptorProto.ExtensionRange} ExtensionRange
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ExtensionRange.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies an ExtensionRange message.
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {?string} `null` if valid, otherwise the reason why it is not
                 */
                ExtensionRange.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.start != null && message.hasOwnProperty("start"))
                        if (!$util.isInteger(message.start))
                            return "start: integer expected";
                    if (message.end != null && message.hasOwnProperty("end"))
                        if (!$util.isInteger(message.end))
                            return "end: integer expected";
                    return null;
                };

                /**
                 * Creates an ExtensionRange message from a plain object. Also converts values to their respective internal types.
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.DescriptorProto.ExtensionRange} ExtensionRange
                 */
                ExtensionRange.fromObject = function fromObject(object) {
                    if (object instanceof $root.google.protobuf.DescriptorProto.ExtensionRange)
                        return object;
                    let message = new $root.google.protobuf.DescriptorProto.ExtensionRange();
                    if (object.start != null)
                        message.start = object.start | 0;
                    if (object.end != null)
                        message.end = object.end | 0;
                    return message;
                };

                /**
                 * Creates an ExtensionRange message from a plain object. Also converts values to their respective internal types.
                 * This is an alias of {@link google.protobuf.DescriptorProto.ExtensionRange.fromObject}.
                 * @function
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.DescriptorProto.ExtensionRange} ExtensionRange
                 */
                ExtensionRange.from = ExtensionRange.fromObject;

                /**
                 * Creates a plain object from an ExtensionRange message. Also converts values to other types if specified.
                 * @param {google.protobuf.DescriptorProto.ExtensionRange} message ExtensionRange
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ExtensionRange.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.start = 0;
                        object.end = 0;
                    }
                    if (message.start != null && message.hasOwnProperty("start"))
                        object.start = message.start;
                    if (message.end != null && message.hasOwnProperty("end"))
                        object.end = message.end;
                    return object;
                };

                /**
                 * Creates a plain object from this ExtensionRange message. Also converts values to other types if specified.
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ExtensionRange.prototype.toObject = function toObject(options) {
                    return this.constructor.toObject(this, options);
                };

                /**
                 * Converts this ExtensionRange to JSON.
                 * @returns {Object.<string,*>} JSON object
                 */
                ExtensionRange.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return ExtensionRange;
            })();

            DescriptorProto.ReservedRange = (function() {

                /**
                 * Properties of a ReservedRange.
                 * @typedef google.protobuf.DescriptorProto.ReservedRange$Properties
                 * @type {Object}
                 * @property {number} [start] ReservedRange start.
                 * @property {number} [end] ReservedRange end.
                 */

                /**
                 * Constructs a new ReservedRange.
                 * @exports google.protobuf.DescriptorProto.ReservedRange
                 * @constructor
                 * @param {google.protobuf.DescriptorProto.ReservedRange$Properties=} [properties] Properties to set
                 */
                function ReservedRange(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * ReservedRange start.
                 * @type {number}
                 */
                ReservedRange.prototype.start = 0;

                /**
                 * ReservedRange end.
                 * @type {number}
                 */
                ReservedRange.prototype.end = 0;

                /**
                 * Creates a new ReservedRange instance using the specified properties.
                 * @param {google.protobuf.DescriptorProto.ReservedRange$Properties=} [properties] Properties to set
                 * @returns {google.protobuf.DescriptorProto.ReservedRange} ReservedRange instance
                 */
                ReservedRange.create = function create(properties) {
                    return new ReservedRange(properties);
                };

                /**
                 * Encodes the specified ReservedRange message. Does not implicitly {@link google.protobuf.DescriptorProto.ReservedRange.verify|verify} messages.
                 * @param {google.protobuf.DescriptorProto.ReservedRange$Properties} message ReservedRange message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ReservedRange.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.start != null && message.hasOwnProperty("start"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.start);
                    if (message.end != null && message.hasOwnProperty("end"))
                        writer.uint32(/* id 2, wireType 0 =*/16).int32(message.end);
                    return writer;
                };

                /**
                 * Encodes the specified ReservedRange message, length delimited. Does not implicitly {@link google.protobuf.DescriptorProto.ReservedRange.verify|verify} messages.
                 * @param {google.protobuf.DescriptorProto.ReservedRange$Properties} message ReservedRange message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ReservedRange.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a ReservedRange message from the specified reader or buffer.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.DescriptorProto.ReservedRange} ReservedRange
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ReservedRange.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.DescriptorProto.ReservedRange();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.start = reader.int32();
                            break;
                        case 2:
                            message.end = reader.int32();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a ReservedRange message from the specified reader or buffer, length delimited.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {google.protobuf.DescriptorProto.ReservedRange} ReservedRange
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ReservedRange.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a ReservedRange message.
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {?string} `null` if valid, otherwise the reason why it is not
                 */
                ReservedRange.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.start != null && message.hasOwnProperty("start"))
                        if (!$util.isInteger(message.start))
                            return "start: integer expected";
                    if (message.end != null && message.hasOwnProperty("end"))
                        if (!$util.isInteger(message.end))
                            return "end: integer expected";
                    return null;
                };

                /**
                 * Creates a ReservedRange message from a plain object. Also converts values to their respective internal types.
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.DescriptorProto.ReservedRange} ReservedRange
                 */
                ReservedRange.fromObject = function fromObject(object) {
                    if (object instanceof $root.google.protobuf.DescriptorProto.ReservedRange)
                        return object;
                    let message = new $root.google.protobuf.DescriptorProto.ReservedRange();
                    if (object.start != null)
                        message.start = object.start | 0;
                    if (object.end != null)
                        message.end = object.end | 0;
                    return message;
                };

                /**
                 * Creates a ReservedRange message from a plain object. Also converts values to their respective internal types.
                 * This is an alias of {@link google.protobuf.DescriptorProto.ReservedRange.fromObject}.
                 * @function
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.DescriptorProto.ReservedRange} ReservedRange
                 */
                ReservedRange.from = ReservedRange.fromObject;

                /**
                 * Creates a plain object from a ReservedRange message. Also converts values to other types if specified.
                 * @param {google.protobuf.DescriptorProto.ReservedRange} message ReservedRange
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ReservedRange.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.start = 0;
                        object.end = 0;
                    }
                    if (message.start != null && message.hasOwnProperty("start"))
                        object.start = message.start;
                    if (message.end != null && message.hasOwnProperty("end"))
                        object.end = message.end;
                    return object;
                };

                /**
                 * Creates a plain object from this ReservedRange message. Also converts values to other types if specified.
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ReservedRange.prototype.toObject = function toObject(options) {
                    return this.constructor.toObject(this, options);
                };

                /**
                 * Converts this ReservedRange to JSON.
                 * @returns {Object.<string,*>} JSON object
                 */
                ReservedRange.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return ReservedRange;
            })();

            return DescriptorProto;
        })();

        protobuf.FieldDescriptorProto = (function() {

            /**
             * Properties of a FieldDescriptorProto.
             * @typedef google.protobuf.FieldDescriptorProto$Properties
             * @type {Object}
             * @property {string} [name] FieldDescriptorProto name.
             * @property {number} [number] FieldDescriptorProto number.
             * @property {google.protobuf.FieldDescriptorProto.Label} [label] FieldDescriptorProto label.
             * @property {google.protobuf.FieldDescriptorProto.Type} [type] FieldDescriptorProto type.
             * @property {string} [type_name] FieldDescriptorProto type_name.
             * @property {string} [extendee] FieldDescriptorProto extendee.
             * @property {string} [default_value] FieldDescriptorProto default_value.
             * @property {number} [oneof_index] FieldDescriptorProto oneof_index.
             * @property {string} [json_name] FieldDescriptorProto json_name.
             * @property {google.protobuf.FieldOptions$Properties} [options] FieldDescriptorProto options.
             */

            /**
             * Constructs a new FieldDescriptorProto.
             * @exports google.protobuf.FieldDescriptorProto
             * @constructor
             * @param {google.protobuf.FieldDescriptorProto$Properties=} [properties] Properties to set
             */
            function FieldDescriptorProto(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * FieldDescriptorProto name.
             * @type {string}
             */
            FieldDescriptorProto.prototype.name = "";

            /**
             * FieldDescriptorProto number.
             * @type {number}
             */
            FieldDescriptorProto.prototype.number = 0;

            /**
             * FieldDescriptorProto label.
             * @type {google.protobuf.FieldDescriptorProto.Label}
             */
            FieldDescriptorProto.prototype.label = 1;

            /**
             * FieldDescriptorProto type.
             * @type {google.protobuf.FieldDescriptorProto.Type}
             */
            FieldDescriptorProto.prototype.type = 1;

            /**
             * FieldDescriptorProto type_name.
             * @type {string}
             */
            FieldDescriptorProto.prototype.type_name = "";

            /**
             * FieldDescriptorProto extendee.
             * @type {string}
             */
            FieldDescriptorProto.prototype.extendee = "";

            /**
             * FieldDescriptorProto default_value.
             * @type {string}
             */
            FieldDescriptorProto.prototype.default_value = "";

            /**
             * FieldDescriptorProto oneof_index.
             * @type {number}
             */
            FieldDescriptorProto.prototype.oneof_index = 0;

            /**
             * FieldDescriptorProto json_name.
             * @type {string}
             */
            FieldDescriptorProto.prototype.json_name = "";

            /**
             * FieldDescriptorProto options.
             * @type {(google.protobuf.FieldOptions$Properties|null)}
             */
            FieldDescriptorProto.prototype.options = null;

            /**
             * Creates a new FieldDescriptorProto instance using the specified properties.
             * @param {google.protobuf.FieldDescriptorProto$Properties=} [properties] Properties to set
             * @returns {google.protobuf.FieldDescriptorProto} FieldDescriptorProto instance
             */
            FieldDescriptorProto.create = function create(properties) {
                return new FieldDescriptorProto(properties);
            };

            /**
             * Encodes the specified FieldDescriptorProto message. Does not implicitly {@link google.protobuf.FieldDescriptorProto.verify|verify} messages.
             * @param {google.protobuf.FieldDescriptorProto$Properties} message FieldDescriptorProto message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FieldDescriptorProto.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && message.hasOwnProperty("name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                if (message.extendee != null && message.hasOwnProperty("extendee"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.extendee);
                if (message.number != null && message.hasOwnProperty("number"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.number);
                if (message.label != null && message.hasOwnProperty("label"))
                    writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.label);
                if (message.type != null && message.hasOwnProperty("type"))
                    writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.type);
                if (message.type_name != null && message.hasOwnProperty("type_name"))
                    writer.uint32(/* id 6, wireType 2 =*/50).string(message.type_name);
                if (message.default_value != null && message.hasOwnProperty("default_value"))
                    writer.uint32(/* id 7, wireType 2 =*/58).string(message.default_value);
                if (message.options != null && message.hasOwnProperty("options"))
                    $root.google.protobuf.FieldOptions.encode(message.options, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                if (message.oneof_index != null && message.hasOwnProperty("oneof_index"))
                    writer.uint32(/* id 9, wireType 0 =*/72).int32(message.oneof_index);
                if (message.json_name != null && message.hasOwnProperty("json_name"))
                    writer.uint32(/* id 10, wireType 2 =*/82).string(message.json_name);
                return writer;
            };

            /**
             * Encodes the specified FieldDescriptorProto message, length delimited. Does not implicitly {@link google.protobuf.FieldDescriptorProto.verify|verify} messages.
             * @param {google.protobuf.FieldDescriptorProto$Properties} message FieldDescriptorProto message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FieldDescriptorProto.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a FieldDescriptorProto message from the specified reader or buffer.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.FieldDescriptorProto} FieldDescriptorProto
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FieldDescriptorProto.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.FieldDescriptorProto();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.name = reader.string();
                        break;
                    case 3:
                        message.number = reader.int32();
                        break;
                    case 4:
                        message.label = reader.uint32();
                        break;
                    case 5:
                        message.type = reader.uint32();
                        break;
                    case 6:
                        message.type_name = reader.string();
                        break;
                    case 2:
                        message.extendee = reader.string();
                        break;
                    case 7:
                        message.default_value = reader.string();
                        break;
                    case 9:
                        message.oneof_index = reader.int32();
                        break;
                    case 10:
                        message.json_name = reader.string();
                        break;
                    case 8:
                        message.options = $root.google.protobuf.FieldOptions.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a FieldDescriptorProto message from the specified reader or buffer, length delimited.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.FieldDescriptorProto} FieldDescriptorProto
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FieldDescriptorProto.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a FieldDescriptorProto message.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            FieldDescriptorProto.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.number != null && message.hasOwnProperty("number"))
                    if (!$util.isInteger(message.number))
                        return "number: integer expected";
                if (message.label != null && message.hasOwnProperty("label"))
                    switch (message.label) {
                    default:
                        return "label: enum value expected";
                    case 1:
                    case 2:
                    case 3:
                        break;
                    }
                if (message.type != null && message.hasOwnProperty("type"))
                    switch (message.type) {
                    default:
                        return "type: enum value expected";
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                    case 5:
                    case 6:
                    case 7:
                    case 8:
                    case 9:
                    case 10:
                    case 11:
                    case 12:
                    case 13:
                    case 14:
                    case 15:
                    case 16:
                    case 17:
                    case 18:
                        break;
                    }
                if (message.type_name != null && message.hasOwnProperty("type_name"))
                    if (!$util.isString(message.type_name))
                        return "type_name: string expected";
                if (message.extendee != null && message.hasOwnProperty("extendee"))
                    if (!$util.isString(message.extendee))
                        return "extendee: string expected";
                if (message.default_value != null && message.hasOwnProperty("default_value"))
                    if (!$util.isString(message.default_value))
                        return "default_value: string expected";
                if (message.oneof_index != null && message.hasOwnProperty("oneof_index"))
                    if (!$util.isInteger(message.oneof_index))
                        return "oneof_index: integer expected";
                if (message.json_name != null && message.hasOwnProperty("json_name"))
                    if (!$util.isString(message.json_name))
                        return "json_name: string expected";
                if (message.options != null && message.hasOwnProperty("options")) {
                    let error = $root.google.protobuf.FieldOptions.verify(message.options);
                    if (error)
                        return "options." + error;
                }
                return null;
            };

            /**
             * Creates a FieldDescriptorProto message from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.FieldDescriptorProto} FieldDescriptorProto
             */
            FieldDescriptorProto.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.FieldDescriptorProto)
                    return object;
                let message = new $root.google.protobuf.FieldDescriptorProto();
                if (object.name != null)
                    message.name = String(object.name);
                if (object.number != null)
                    message.number = object.number | 0;
                switch (object.label) {
                case "LABEL_OPTIONAL":
                case 1:
                    message.label = 1;
                    break;
                case "LABEL_REQUIRED":
                case 2:
                    message.label = 2;
                    break;
                case "LABEL_REPEATED":
                case 3:
                    message.label = 3;
                    break;
                }
                switch (object.type) {
                case "TYPE_DOUBLE":
                case 1:
                    message.type = 1;
                    break;
                case "TYPE_FLOAT":
                case 2:
                    message.type = 2;
                    break;
                case "TYPE_INT64":
                case 3:
                    message.type = 3;
                    break;
                case "TYPE_UINT64":
                case 4:
                    message.type = 4;
                    break;
                case "TYPE_INT32":
                case 5:
                    message.type = 5;
                    break;
                case "TYPE_FIXED64":
                case 6:
                    message.type = 6;
                    break;
                case "TYPE_FIXED32":
                case 7:
                    message.type = 7;
                    break;
                case "TYPE_BOOL":
                case 8:
                    message.type = 8;
                    break;
                case "TYPE_STRING":
                case 9:
                    message.type = 9;
                    break;
                case "TYPE_GROUP":
                case 10:
                    message.type = 10;
                    break;
                case "TYPE_MESSAGE":
                case 11:
                    message.type = 11;
                    break;
                case "TYPE_BYTES":
                case 12:
                    message.type = 12;
                    break;
                case "TYPE_UINT32":
                case 13:
                    message.type = 13;
                    break;
                case "TYPE_ENUM":
                case 14:
                    message.type = 14;
                    break;
                case "TYPE_SFIXED32":
                case 15:
                    message.type = 15;
                    break;
                case "TYPE_SFIXED64":
                case 16:
                    message.type = 16;
                    break;
                case "TYPE_SINT32":
                case 17:
                    message.type = 17;
                    break;
                case "TYPE_SINT64":
                case 18:
                    message.type = 18;
                    break;
                }
                if (object.type_name != null)
                    message.type_name = String(object.type_name);
                if (object.extendee != null)
                    message.extendee = String(object.extendee);
                if (object.default_value != null)
                    message.default_value = String(object.default_value);
                if (object.oneof_index != null)
                    message.oneof_index = object.oneof_index | 0;
                if (object.json_name != null)
                    message.json_name = String(object.json_name);
                if (object.options != null) {
                    if (typeof object.options !== "object")
                        throw TypeError(".google.protobuf.FieldDescriptorProto.options: object expected");
                    message.options = $root.google.protobuf.FieldOptions.fromObject(object.options);
                }
                return message;
            };

            /**
             * Creates a FieldDescriptorProto message from a plain object. Also converts values to their respective internal types.
             * This is an alias of {@link google.protobuf.FieldDescriptorProto.fromObject}.
             * @function
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.FieldDescriptorProto} FieldDescriptorProto
             */
            FieldDescriptorProto.from = FieldDescriptorProto.fromObject;

            /**
             * Creates a plain object from a FieldDescriptorProto message. Also converts values to other types if specified.
             * @param {google.protobuf.FieldDescriptorProto} message FieldDescriptorProto
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            FieldDescriptorProto.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.name = "";
                    object.extendee = "";
                    object.number = 0;
                    object.label = options.enums === String ? "LABEL_OPTIONAL" : 1;
                    object.type = options.enums === String ? "TYPE_DOUBLE" : 1;
                    object.type_name = "";
                    object.default_value = "";
                    object.options = null;
                    object.oneof_index = 0;
                    object.json_name = "";
                }
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.extendee != null && message.hasOwnProperty("extendee"))
                    object.extendee = message.extendee;
                if (message.number != null && message.hasOwnProperty("number"))
                    object.number = message.number;
                if (message.label != null && message.hasOwnProperty("label"))
                    object.label = options.enums === String ? $root.google.protobuf.FieldDescriptorProto.Label[message.label] : message.label;
                if (message.type != null && message.hasOwnProperty("type"))
                    object.type = options.enums === String ? $root.google.protobuf.FieldDescriptorProto.Type[message.type] : message.type;
                if (message.type_name != null && message.hasOwnProperty("type_name"))
                    object.type_name = message.type_name;
                if (message.default_value != null && message.hasOwnProperty("default_value"))
                    object.default_value = message.default_value;
                if (message.options != null && message.hasOwnProperty("options"))
                    object.options = $root.google.protobuf.FieldOptions.toObject(message.options, options);
                if (message.oneof_index != null && message.hasOwnProperty("oneof_index"))
                    object.oneof_index = message.oneof_index;
                if (message.json_name != null && message.hasOwnProperty("json_name"))
                    object.json_name = message.json_name;
                return object;
            };

            /**
             * Creates a plain object from this FieldDescriptorProto message. Also converts values to other types if specified.
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            FieldDescriptorProto.prototype.toObject = function toObject(options) {
                return this.constructor.toObject(this, options);
            };

            /**
             * Converts this FieldDescriptorProto to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            FieldDescriptorProto.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Type enum.
             * @name Type
             * @memberof google.protobuf.FieldDescriptorProto
             * @enum {number}
             * @property {number} TYPE_DOUBLE=1 TYPE_DOUBLE value
             * @property {number} TYPE_FLOAT=2 TYPE_FLOAT value
             * @property {number} TYPE_INT64=3 TYPE_INT64 value
             * @property {number} TYPE_UINT64=4 TYPE_UINT64 value
             * @property {number} TYPE_INT32=5 TYPE_INT32 value
             * @property {number} TYPE_FIXED64=6 TYPE_FIXED64 value
             * @property {number} TYPE_FIXED32=7 TYPE_FIXED32 value
             * @property {number} TYPE_BOOL=8 TYPE_BOOL value
             * @property {number} TYPE_STRING=9 TYPE_STRING value
             * @property {number} TYPE_GROUP=10 TYPE_GROUP value
             * @property {number} TYPE_MESSAGE=11 TYPE_MESSAGE value
             * @property {number} TYPE_BYTES=12 TYPE_BYTES value
             * @property {number} TYPE_UINT32=13 TYPE_UINT32 value
             * @property {number} TYPE_ENUM=14 TYPE_ENUM value
             * @property {number} TYPE_SFIXED32=15 TYPE_SFIXED32 value
             * @property {number} TYPE_SFIXED64=16 TYPE_SFIXED64 value
             * @property {number} TYPE_SINT32=17 TYPE_SINT32 value
             * @property {number} TYPE_SINT64=18 TYPE_SINT64 value
             */
            FieldDescriptorProto.Type = (function() {
                const valuesById = {}, values = Object.create(valuesById);
                values[valuesById[1] = "TYPE_DOUBLE"] = 1;
                values[valuesById[2] = "TYPE_FLOAT"] = 2;
                values[valuesById[3] = "TYPE_INT64"] = 3;
                values[valuesById[4] = "TYPE_UINT64"] = 4;
                values[valuesById[5] = "TYPE_INT32"] = 5;
                values[valuesById[6] = "TYPE_FIXED64"] = 6;
                values[valuesById[7] = "TYPE_FIXED32"] = 7;
                values[valuesById[8] = "TYPE_BOOL"] = 8;
                values[valuesById[9] = "TYPE_STRING"] = 9;
                values[valuesById[10] = "TYPE_GROUP"] = 10;
                values[valuesById[11] = "TYPE_MESSAGE"] = 11;
                values[valuesById[12] = "TYPE_BYTES"] = 12;
                values[valuesById[13] = "TYPE_UINT32"] = 13;
                values[valuesById[14] = "TYPE_ENUM"] = 14;
                values[valuesById[15] = "TYPE_SFIXED32"] = 15;
                values[valuesById[16] = "TYPE_SFIXED64"] = 16;
                values[valuesById[17] = "TYPE_SINT32"] = 17;
                values[valuesById[18] = "TYPE_SINT64"] = 18;
                return values;
            })();

            /**
             * Label enum.
             * @name Label
             * @memberof google.protobuf.FieldDescriptorProto
             * @enum {number}
             * @property {number} LABEL_OPTIONAL=1 LABEL_OPTIONAL value
             * @property {number} LABEL_REQUIRED=2 LABEL_REQUIRED value
             * @property {number} LABEL_REPEATED=3 LABEL_REPEATED value
             */
            FieldDescriptorProto.Label = (function() {
                const valuesById = {}, values = Object.create(valuesById);
                values[valuesById[1] = "LABEL_OPTIONAL"] = 1;
                values[valuesById[2] = "LABEL_REQUIRED"] = 2;
                values[valuesById[3] = "LABEL_REPEATED"] = 3;
                return values;
            })();

            return FieldDescriptorProto;
        })();

        protobuf.OneofDescriptorProto = (function() {

            /**
             * Properties of an OneofDescriptorProto.
             * @typedef google.protobuf.OneofDescriptorProto$Properties
             * @type {Object}
             * @property {string} [name] OneofDescriptorProto name.
             * @property {google.protobuf.OneofOptions$Properties} [options] OneofDescriptorProto options.
             */

            /**
             * Constructs a new OneofDescriptorProto.
             * @exports google.protobuf.OneofDescriptorProto
             * @constructor
             * @param {google.protobuf.OneofDescriptorProto$Properties=} [properties] Properties to set
             */
            function OneofDescriptorProto(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * OneofDescriptorProto name.
             * @type {string}
             */
            OneofDescriptorProto.prototype.name = "";

            /**
             * OneofDescriptorProto options.
             * @type {(google.protobuf.OneofOptions$Properties|null)}
             */
            OneofDescriptorProto.prototype.options = null;

            /**
             * Creates a new OneofDescriptorProto instance using the specified properties.
             * @param {google.protobuf.OneofDescriptorProto$Properties=} [properties] Properties to set
             * @returns {google.protobuf.OneofDescriptorProto} OneofDescriptorProto instance
             */
            OneofDescriptorProto.create = function create(properties) {
                return new OneofDescriptorProto(properties);
            };

            /**
             * Encodes the specified OneofDescriptorProto message. Does not implicitly {@link google.protobuf.OneofDescriptorProto.verify|verify} messages.
             * @param {google.protobuf.OneofDescriptorProto$Properties} message OneofDescriptorProto message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            OneofDescriptorProto.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && message.hasOwnProperty("name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                if (message.options != null && message.hasOwnProperty("options"))
                    $root.google.protobuf.OneofOptions.encode(message.options, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified OneofDescriptorProto message, length delimited. Does not implicitly {@link google.protobuf.OneofDescriptorProto.verify|verify} messages.
             * @param {google.protobuf.OneofDescriptorProto$Properties} message OneofDescriptorProto message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            OneofDescriptorProto.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an OneofDescriptorProto message from the specified reader or buffer.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.OneofDescriptorProto} OneofDescriptorProto
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            OneofDescriptorProto.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.OneofDescriptorProto();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.name = reader.string();
                        break;
                    case 2:
                        message.options = $root.google.protobuf.OneofOptions.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an OneofDescriptorProto message from the specified reader or buffer, length delimited.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.OneofDescriptorProto} OneofDescriptorProto
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            OneofDescriptorProto.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an OneofDescriptorProto message.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            OneofDescriptorProto.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.options != null && message.hasOwnProperty("options")) {
                    let error = $root.google.protobuf.OneofOptions.verify(message.options);
                    if (error)
                        return "options." + error;
                }
                return null;
            };

            /**
             * Creates an OneofDescriptorProto message from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.OneofDescriptorProto} OneofDescriptorProto
             */
            OneofDescriptorProto.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.OneofDescriptorProto)
                    return object;
                let message = new $root.google.protobuf.OneofDescriptorProto();
                if (object.name != null)
                    message.name = String(object.name);
                if (object.options != null) {
                    if (typeof object.options !== "object")
                        throw TypeError(".google.protobuf.OneofDescriptorProto.options: object expected");
                    message.options = $root.google.protobuf.OneofOptions.fromObject(object.options);
                }
                return message;
            };

            /**
             * Creates an OneofDescriptorProto message from a plain object. Also converts values to their respective internal types.
             * This is an alias of {@link google.protobuf.OneofDescriptorProto.fromObject}.
             * @function
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.OneofDescriptorProto} OneofDescriptorProto
             */
            OneofDescriptorProto.from = OneofDescriptorProto.fromObject;

            /**
             * Creates a plain object from an OneofDescriptorProto message. Also converts values to other types if specified.
             * @param {google.protobuf.OneofDescriptorProto} message OneofDescriptorProto
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            OneofDescriptorProto.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.name = "";
                    object.options = null;
                }
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.options != null && message.hasOwnProperty("options"))
                    object.options = $root.google.protobuf.OneofOptions.toObject(message.options, options);
                return object;
            };

            /**
             * Creates a plain object from this OneofDescriptorProto message. Also converts values to other types if specified.
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            OneofDescriptorProto.prototype.toObject = function toObject(options) {
                return this.constructor.toObject(this, options);
            };

            /**
             * Converts this OneofDescriptorProto to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            OneofDescriptorProto.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return OneofDescriptorProto;
        })();

        protobuf.EnumDescriptorProto = (function() {

            /**
             * Properties of an EnumDescriptorProto.
             * @typedef google.protobuf.EnumDescriptorProto$Properties
             * @type {Object}
             * @property {string} [name] EnumDescriptorProto name.
             * @property {Array.<google.protobuf.EnumValueDescriptorProto$Properties>} [value] EnumDescriptorProto value.
             * @property {google.protobuf.EnumOptions$Properties} [options] EnumDescriptorProto options.
             */

            /**
             * Constructs a new EnumDescriptorProto.
             * @exports google.protobuf.EnumDescriptorProto
             * @constructor
             * @param {google.protobuf.EnumDescriptorProto$Properties=} [properties] Properties to set
             */
            function EnumDescriptorProto(properties) {
                this.value = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * EnumDescriptorProto name.
             * @type {string}
             */
            EnumDescriptorProto.prototype.name = "";

            /**
             * EnumDescriptorProto value.
             * @type {Array.<google.protobuf.EnumValueDescriptorProto$Properties>}
             */
            EnumDescriptorProto.prototype.value = $util.emptyArray;

            /**
             * EnumDescriptorProto options.
             * @type {(google.protobuf.EnumOptions$Properties|null)}
             */
            EnumDescriptorProto.prototype.options = null;

            /**
             * Creates a new EnumDescriptorProto instance using the specified properties.
             * @param {google.protobuf.EnumDescriptorProto$Properties=} [properties] Properties to set
             * @returns {google.protobuf.EnumDescriptorProto} EnumDescriptorProto instance
             */
            EnumDescriptorProto.create = function create(properties) {
                return new EnumDescriptorProto(properties);
            };

            /**
             * Encodes the specified EnumDescriptorProto message. Does not implicitly {@link google.protobuf.EnumDescriptorProto.verify|verify} messages.
             * @param {google.protobuf.EnumDescriptorProto$Properties} message EnumDescriptorProto message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            EnumDescriptorProto.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && message.hasOwnProperty("name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                if (message.value != null && message.value.length)
                    for (let i = 0; i < message.value.length; ++i)
                        $root.google.protobuf.EnumValueDescriptorProto.encode(message.value[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.options != null && message.hasOwnProperty("options"))
                    $root.google.protobuf.EnumOptions.encode(message.options, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified EnumDescriptorProto message, length delimited. Does not implicitly {@link google.protobuf.EnumDescriptorProto.verify|verify} messages.
             * @param {google.protobuf.EnumDescriptorProto$Properties} message EnumDescriptorProto message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            EnumDescriptorProto.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an EnumDescriptorProto message from the specified reader or buffer.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.EnumDescriptorProto} EnumDescriptorProto
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            EnumDescriptorProto.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.EnumDescriptorProto();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.name = reader.string();
                        break;
                    case 2:
                        if (!(message.value && message.value.length))
                            message.value = [];
                        message.value.push($root.google.protobuf.EnumValueDescriptorProto.decode(reader, reader.uint32()));
                        break;
                    case 3:
                        message.options = $root.google.protobuf.EnumOptions.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an EnumDescriptorProto message from the specified reader or buffer, length delimited.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.EnumDescriptorProto} EnumDescriptorProto
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            EnumDescriptorProto.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an EnumDescriptorProto message.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            EnumDescriptorProto.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.value != null && message.hasOwnProperty("value")) {
                    if (!Array.isArray(message.value))
                        return "value: array expected";
                    for (let i = 0; i < message.value.length; ++i) {
                        let error = $root.google.protobuf.EnumValueDescriptorProto.verify(message.value[i]);
                        if (error)
                            return "value." + error;
                    }
                }
                if (message.options != null && message.hasOwnProperty("options")) {
                    let error = $root.google.protobuf.EnumOptions.verify(message.options);
                    if (error)
                        return "options." + error;
                }
                return null;
            };

            /**
             * Creates an EnumDescriptorProto message from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.EnumDescriptorProto} EnumDescriptorProto
             */
            EnumDescriptorProto.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.EnumDescriptorProto)
                    return object;
                let message = new $root.google.protobuf.EnumDescriptorProto();
                if (object.name != null)
                    message.name = String(object.name);
                if (object.value) {
                    if (!Array.isArray(object.value))
                        throw TypeError(".google.protobuf.EnumDescriptorProto.value: array expected");
                    message.value = [];
                    for (let i = 0; i < object.value.length; ++i) {
                        if (typeof object.value[i] !== "object")
                            throw TypeError(".google.protobuf.EnumDescriptorProto.value: object expected");
                        message.value[i] = $root.google.protobuf.EnumValueDescriptorProto.fromObject(object.value[i]);
                    }
                }
                if (object.options != null) {
                    if (typeof object.options !== "object")
                        throw TypeError(".google.protobuf.EnumDescriptorProto.options: object expected");
                    message.options = $root.google.protobuf.EnumOptions.fromObject(object.options);
                }
                return message;
            };

            /**
             * Creates an EnumDescriptorProto message from a plain object. Also converts values to their respective internal types.
             * This is an alias of {@link google.protobuf.EnumDescriptorProto.fromObject}.
             * @function
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.EnumDescriptorProto} EnumDescriptorProto
             */
            EnumDescriptorProto.from = EnumDescriptorProto.fromObject;

            /**
             * Creates a plain object from an EnumDescriptorProto message. Also converts values to other types if specified.
             * @param {google.protobuf.EnumDescriptorProto} message EnumDescriptorProto
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            EnumDescriptorProto.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.value = [];
                if (options.defaults) {
                    object.name = "";
                    object.options = null;
                }
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.value && message.value.length) {
                    object.value = [];
                    for (let j = 0; j < message.value.length; ++j)
                        object.value[j] = $root.google.protobuf.EnumValueDescriptorProto.toObject(message.value[j], options);
                }
                if (message.options != null && message.hasOwnProperty("options"))
                    object.options = $root.google.protobuf.EnumOptions.toObject(message.options, options);
                return object;
            };

            /**
             * Creates a plain object from this EnumDescriptorProto message. Also converts values to other types if specified.
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            EnumDescriptorProto.prototype.toObject = function toObject(options) {
                return this.constructor.toObject(this, options);
            };

            /**
             * Converts this EnumDescriptorProto to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            EnumDescriptorProto.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return EnumDescriptorProto;
        })();

        protobuf.EnumValueDescriptorProto = (function() {

            /**
             * Properties of an EnumValueDescriptorProto.
             * @typedef google.protobuf.EnumValueDescriptorProto$Properties
             * @type {Object}
             * @property {string} [name] EnumValueDescriptorProto name.
             * @property {number} [number] EnumValueDescriptorProto number.
             * @property {google.protobuf.EnumValueOptions$Properties} [options] EnumValueDescriptorProto options.
             */

            /**
             * Constructs a new EnumValueDescriptorProto.
             * @exports google.protobuf.EnumValueDescriptorProto
             * @constructor
             * @param {google.protobuf.EnumValueDescriptorProto$Properties=} [properties] Properties to set
             */
            function EnumValueDescriptorProto(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * EnumValueDescriptorProto name.
             * @type {string}
             */
            EnumValueDescriptorProto.prototype.name = "";

            /**
             * EnumValueDescriptorProto number.
             * @type {number}
             */
            EnumValueDescriptorProto.prototype.number = 0;

            /**
             * EnumValueDescriptorProto options.
             * @type {(google.protobuf.EnumValueOptions$Properties|null)}
             */
            EnumValueDescriptorProto.prototype.options = null;

            /**
             * Creates a new EnumValueDescriptorProto instance using the specified properties.
             * @param {google.protobuf.EnumValueDescriptorProto$Properties=} [properties] Properties to set
             * @returns {google.protobuf.EnumValueDescriptorProto} EnumValueDescriptorProto instance
             */
            EnumValueDescriptorProto.create = function create(properties) {
                return new EnumValueDescriptorProto(properties);
            };

            /**
             * Encodes the specified EnumValueDescriptorProto message. Does not implicitly {@link google.protobuf.EnumValueDescriptorProto.verify|verify} messages.
             * @param {google.protobuf.EnumValueDescriptorProto$Properties} message EnumValueDescriptorProto message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            EnumValueDescriptorProto.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && message.hasOwnProperty("name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                if (message.number != null && message.hasOwnProperty("number"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.number);
                if (message.options != null && message.hasOwnProperty("options"))
                    $root.google.protobuf.EnumValueOptions.encode(message.options, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified EnumValueDescriptorProto message, length delimited. Does not implicitly {@link google.protobuf.EnumValueDescriptorProto.verify|verify} messages.
             * @param {google.protobuf.EnumValueDescriptorProto$Properties} message EnumValueDescriptorProto message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            EnumValueDescriptorProto.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an EnumValueDescriptorProto message from the specified reader or buffer.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.EnumValueDescriptorProto} EnumValueDescriptorProto
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            EnumValueDescriptorProto.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.EnumValueDescriptorProto();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.name = reader.string();
                        break;
                    case 2:
                        message.number = reader.int32();
                        break;
                    case 3:
                        message.options = $root.google.protobuf.EnumValueOptions.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an EnumValueDescriptorProto message from the specified reader or buffer, length delimited.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.EnumValueDescriptorProto} EnumValueDescriptorProto
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            EnumValueDescriptorProto.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an EnumValueDescriptorProto message.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            EnumValueDescriptorProto.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.number != null && message.hasOwnProperty("number"))
                    if (!$util.isInteger(message.number))
                        return "number: integer expected";
                if (message.options != null && message.hasOwnProperty("options")) {
                    let error = $root.google.protobuf.EnumValueOptions.verify(message.options);
                    if (error)
                        return "options." + error;
                }
                return null;
            };

            /**
             * Creates an EnumValueDescriptorProto message from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.EnumValueDescriptorProto} EnumValueDescriptorProto
             */
            EnumValueDescriptorProto.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.EnumValueDescriptorProto)
                    return object;
                let message = new $root.google.protobuf.EnumValueDescriptorProto();
                if (object.name != null)
                    message.name = String(object.name);
                if (object.number != null)
                    message.number = object.number | 0;
                if (object.options != null) {
                    if (typeof object.options !== "object")
                        throw TypeError(".google.protobuf.EnumValueDescriptorProto.options: object expected");
                    message.options = $root.google.protobuf.EnumValueOptions.fromObject(object.options);
                }
                return message;
            };

            /**
             * Creates an EnumValueDescriptorProto message from a plain object. Also converts values to their respective internal types.
             * This is an alias of {@link google.protobuf.EnumValueDescriptorProto.fromObject}.
             * @function
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.EnumValueDescriptorProto} EnumValueDescriptorProto
             */
            EnumValueDescriptorProto.from = EnumValueDescriptorProto.fromObject;

            /**
             * Creates a plain object from an EnumValueDescriptorProto message. Also converts values to other types if specified.
             * @param {google.protobuf.EnumValueDescriptorProto} message EnumValueDescriptorProto
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            EnumValueDescriptorProto.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.name = "";
                    object.number = 0;
                    object.options = null;
                }
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.number != null && message.hasOwnProperty("number"))
                    object.number = message.number;
                if (message.options != null && message.hasOwnProperty("options"))
                    object.options = $root.google.protobuf.EnumValueOptions.toObject(message.options, options);
                return object;
            };

            /**
             * Creates a plain object from this EnumValueDescriptorProto message. Also converts values to other types if specified.
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            EnumValueDescriptorProto.prototype.toObject = function toObject(options) {
                return this.constructor.toObject(this, options);
            };

            /**
             * Converts this EnumValueDescriptorProto to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            EnumValueDescriptorProto.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return EnumValueDescriptorProto;
        })();

        protobuf.ServiceDescriptorProto = (function() {

            /**
             * Properties of a ServiceDescriptorProto.
             * @typedef google.protobuf.ServiceDescriptorProto$Properties
             * @type {Object}
             * @property {string} [name] ServiceDescriptorProto name.
             * @property {Array.<google.protobuf.MethodDescriptorProto$Properties>} [method] ServiceDescriptorProto method.
             * @property {google.protobuf.ServiceOptions$Properties} [options] ServiceDescriptorProto options.
             */

            /**
             * Constructs a new ServiceDescriptorProto.
             * @exports google.protobuf.ServiceDescriptorProto
             * @constructor
             * @param {google.protobuf.ServiceDescriptorProto$Properties=} [properties] Properties to set
             */
            function ServiceDescriptorProto(properties) {
                this.method = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ServiceDescriptorProto name.
             * @type {string}
             */
            ServiceDescriptorProto.prototype.name = "";

            /**
             * ServiceDescriptorProto method.
             * @type {Array.<google.protobuf.MethodDescriptorProto$Properties>}
             */
            ServiceDescriptorProto.prototype.method = $util.emptyArray;

            /**
             * ServiceDescriptorProto options.
             * @type {(google.protobuf.ServiceOptions$Properties|null)}
             */
            ServiceDescriptorProto.prototype.options = null;

            /**
             * Creates a new ServiceDescriptorProto instance using the specified properties.
             * @param {google.protobuf.ServiceDescriptorProto$Properties=} [properties] Properties to set
             * @returns {google.protobuf.ServiceDescriptorProto} ServiceDescriptorProto instance
             */
            ServiceDescriptorProto.create = function create(properties) {
                return new ServiceDescriptorProto(properties);
            };

            /**
             * Encodes the specified ServiceDescriptorProto message. Does not implicitly {@link google.protobuf.ServiceDescriptorProto.verify|verify} messages.
             * @param {google.protobuf.ServiceDescriptorProto$Properties} message ServiceDescriptorProto message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ServiceDescriptorProto.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && message.hasOwnProperty("name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                if (message.method != null && message.method.length)
                    for (let i = 0; i < message.method.length; ++i)
                        $root.google.protobuf.MethodDescriptorProto.encode(message.method[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.options != null && message.hasOwnProperty("options"))
                    $root.google.protobuf.ServiceOptions.encode(message.options, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified ServiceDescriptorProto message, length delimited. Does not implicitly {@link google.protobuf.ServiceDescriptorProto.verify|verify} messages.
             * @param {google.protobuf.ServiceDescriptorProto$Properties} message ServiceDescriptorProto message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ServiceDescriptorProto.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ServiceDescriptorProto message from the specified reader or buffer.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.ServiceDescriptorProto} ServiceDescriptorProto
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ServiceDescriptorProto.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.ServiceDescriptorProto();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.name = reader.string();
                        break;
                    case 2:
                        if (!(message.method && message.method.length))
                            message.method = [];
                        message.method.push($root.google.protobuf.MethodDescriptorProto.decode(reader, reader.uint32()));
                        break;
                    case 3:
                        message.options = $root.google.protobuf.ServiceOptions.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ServiceDescriptorProto message from the specified reader or buffer, length delimited.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.ServiceDescriptorProto} ServiceDescriptorProto
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ServiceDescriptorProto.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ServiceDescriptorProto message.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            ServiceDescriptorProto.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.method != null && message.hasOwnProperty("method")) {
                    if (!Array.isArray(message.method))
                        return "method: array expected";
                    for (let i = 0; i < message.method.length; ++i) {
                        let error = $root.google.protobuf.MethodDescriptorProto.verify(message.method[i]);
                        if (error)
                            return "method." + error;
                    }
                }
                if (message.options != null && message.hasOwnProperty("options")) {
                    let error = $root.google.protobuf.ServiceOptions.verify(message.options);
                    if (error)
                        return "options." + error;
                }
                return null;
            };

            /**
             * Creates a ServiceDescriptorProto message from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.ServiceDescriptorProto} ServiceDescriptorProto
             */
            ServiceDescriptorProto.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.ServiceDescriptorProto)
                    return object;
                let message = new $root.google.protobuf.ServiceDescriptorProto();
                if (object.name != null)
                    message.name = String(object.name);
                if (object.method) {
                    if (!Array.isArray(object.method))
                        throw TypeError(".google.protobuf.ServiceDescriptorProto.method: array expected");
                    message.method = [];
                    for (let i = 0; i < object.method.length; ++i) {
                        if (typeof object.method[i] !== "object")
                            throw TypeError(".google.protobuf.ServiceDescriptorProto.method: object expected");
                        message.method[i] = $root.google.protobuf.MethodDescriptorProto.fromObject(object.method[i]);
                    }
                }
                if (object.options != null) {
                    if (typeof object.options !== "object")
                        throw TypeError(".google.protobuf.ServiceDescriptorProto.options: object expected");
                    message.options = $root.google.protobuf.ServiceOptions.fromObject(object.options);
                }
                return message;
            };

            /**
             * Creates a ServiceDescriptorProto message from a plain object. Also converts values to their respective internal types.
             * This is an alias of {@link google.protobuf.ServiceDescriptorProto.fromObject}.
             * @function
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.ServiceDescriptorProto} ServiceDescriptorProto
             */
            ServiceDescriptorProto.from = ServiceDescriptorProto.fromObject;

            /**
             * Creates a plain object from a ServiceDescriptorProto message. Also converts values to other types if specified.
             * @param {google.protobuf.ServiceDescriptorProto} message ServiceDescriptorProto
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ServiceDescriptorProto.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.method = [];
                if (options.defaults) {
                    object.name = "";
                    object.options = null;
                }
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.method && message.method.length) {
                    object.method = [];
                    for (let j = 0; j < message.method.length; ++j)
                        object.method[j] = $root.google.protobuf.MethodDescriptorProto.toObject(message.method[j], options);
                }
                if (message.options != null && message.hasOwnProperty("options"))
                    object.options = $root.google.protobuf.ServiceOptions.toObject(message.options, options);
                return object;
            };

            /**
             * Creates a plain object from this ServiceDescriptorProto message. Also converts values to other types if specified.
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ServiceDescriptorProto.prototype.toObject = function toObject(options) {
                return this.constructor.toObject(this, options);
            };

            /**
             * Converts this ServiceDescriptorProto to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            ServiceDescriptorProto.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ServiceDescriptorProto;
        })();

        protobuf.MethodDescriptorProto = (function() {

            /**
             * Properties of a MethodDescriptorProto.
             * @typedef google.protobuf.MethodDescriptorProto$Properties
             * @type {Object}
             * @property {string} [name] MethodDescriptorProto name.
             * @property {string} [input_type] MethodDescriptorProto input_type.
             * @property {string} [output_type] MethodDescriptorProto output_type.
             * @property {google.protobuf.MethodOptions$Properties} [options] MethodDescriptorProto options.
             * @property {boolean} [client_streaming] MethodDescriptorProto client_streaming.
             * @property {boolean} [server_streaming] MethodDescriptorProto server_streaming.
             */

            /**
             * Constructs a new MethodDescriptorProto.
             * @exports google.protobuf.MethodDescriptorProto
             * @constructor
             * @param {google.protobuf.MethodDescriptorProto$Properties=} [properties] Properties to set
             */
            function MethodDescriptorProto(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * MethodDescriptorProto name.
             * @type {string}
             */
            MethodDescriptorProto.prototype.name = "";

            /**
             * MethodDescriptorProto input_type.
             * @type {string}
             */
            MethodDescriptorProto.prototype.input_type = "";

            /**
             * MethodDescriptorProto output_type.
             * @type {string}
             */
            MethodDescriptorProto.prototype.output_type = "";

            /**
             * MethodDescriptorProto options.
             * @type {(google.protobuf.MethodOptions$Properties|null)}
             */
            MethodDescriptorProto.prototype.options = null;

            /**
             * MethodDescriptorProto client_streaming.
             * @type {boolean}
             */
            MethodDescriptorProto.prototype.client_streaming = false;

            /**
             * MethodDescriptorProto server_streaming.
             * @type {boolean}
             */
            MethodDescriptorProto.prototype.server_streaming = false;

            /**
             * Creates a new MethodDescriptorProto instance using the specified properties.
             * @param {google.protobuf.MethodDescriptorProto$Properties=} [properties] Properties to set
             * @returns {google.protobuf.MethodDescriptorProto} MethodDescriptorProto instance
             */
            MethodDescriptorProto.create = function create(properties) {
                return new MethodDescriptorProto(properties);
            };

            /**
             * Encodes the specified MethodDescriptorProto message. Does not implicitly {@link google.protobuf.MethodDescriptorProto.verify|verify} messages.
             * @param {google.protobuf.MethodDescriptorProto$Properties} message MethodDescriptorProto message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MethodDescriptorProto.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && message.hasOwnProperty("name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                if (message.input_type != null && message.hasOwnProperty("input_type"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.input_type);
                if (message.output_type != null && message.hasOwnProperty("output_type"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.output_type);
                if (message.options != null && message.hasOwnProperty("options"))
                    $root.google.protobuf.MethodOptions.encode(message.options, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.client_streaming != null && message.hasOwnProperty("client_streaming"))
                    writer.uint32(/* id 5, wireType 0 =*/40).bool(message.client_streaming);
                if (message.server_streaming != null && message.hasOwnProperty("server_streaming"))
                    writer.uint32(/* id 6, wireType 0 =*/48).bool(message.server_streaming);
                return writer;
            };

            /**
             * Encodes the specified MethodDescriptorProto message, length delimited. Does not implicitly {@link google.protobuf.MethodDescriptorProto.verify|verify} messages.
             * @param {google.protobuf.MethodDescriptorProto$Properties} message MethodDescriptorProto message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MethodDescriptorProto.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a MethodDescriptorProto message from the specified reader or buffer.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.MethodDescriptorProto} MethodDescriptorProto
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MethodDescriptorProto.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.MethodDescriptorProto();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.name = reader.string();
                        break;
                    case 2:
                        message.input_type = reader.string();
                        break;
                    case 3:
                        message.output_type = reader.string();
                        break;
                    case 4:
                        message.options = $root.google.protobuf.MethodOptions.decode(reader, reader.uint32());
                        break;
                    case 5:
                        message.client_streaming = reader.bool();
                        break;
                    case 6:
                        message.server_streaming = reader.bool();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a MethodDescriptorProto message from the specified reader or buffer, length delimited.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.MethodDescriptorProto} MethodDescriptorProto
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MethodDescriptorProto.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a MethodDescriptorProto message.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            MethodDescriptorProto.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.input_type != null && message.hasOwnProperty("input_type"))
                    if (!$util.isString(message.input_type))
                        return "input_type: string expected";
                if (message.output_type != null && message.hasOwnProperty("output_type"))
                    if (!$util.isString(message.output_type))
                        return "output_type: string expected";
                if (message.options != null && message.hasOwnProperty("options")) {
                    let error = $root.google.protobuf.MethodOptions.verify(message.options);
                    if (error)
                        return "options." + error;
                }
                if (message.client_streaming != null && message.hasOwnProperty("client_streaming"))
                    if (typeof message.client_streaming !== "boolean")
                        return "client_streaming: boolean expected";
                if (message.server_streaming != null && message.hasOwnProperty("server_streaming"))
                    if (typeof message.server_streaming !== "boolean")
                        return "server_streaming: boolean expected";
                return null;
            };

            /**
             * Creates a MethodDescriptorProto message from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.MethodDescriptorProto} MethodDescriptorProto
             */
            MethodDescriptorProto.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.MethodDescriptorProto)
                    return object;
                let message = new $root.google.protobuf.MethodDescriptorProto();
                if (object.name != null)
                    message.name = String(object.name);
                if (object.input_type != null)
                    message.input_type = String(object.input_type);
                if (object.output_type != null)
                    message.output_type = String(object.output_type);
                if (object.options != null) {
                    if (typeof object.options !== "object")
                        throw TypeError(".google.protobuf.MethodDescriptorProto.options: object expected");
                    message.options = $root.google.protobuf.MethodOptions.fromObject(object.options);
                }
                if (object.client_streaming != null)
                    message.client_streaming = Boolean(object.client_streaming);
                if (object.server_streaming != null)
                    message.server_streaming = Boolean(object.server_streaming);
                return message;
            };

            /**
             * Creates a MethodDescriptorProto message from a plain object. Also converts values to their respective internal types.
             * This is an alias of {@link google.protobuf.MethodDescriptorProto.fromObject}.
             * @function
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.MethodDescriptorProto} MethodDescriptorProto
             */
            MethodDescriptorProto.from = MethodDescriptorProto.fromObject;

            /**
             * Creates a plain object from a MethodDescriptorProto message. Also converts values to other types if specified.
             * @param {google.protobuf.MethodDescriptorProto} message MethodDescriptorProto
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            MethodDescriptorProto.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.name = "";
                    object.input_type = "";
                    object.output_type = "";
                    object.options = null;
                    object.client_streaming = false;
                    object.server_streaming = false;
                }
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.input_type != null && message.hasOwnProperty("input_type"))
                    object.input_type = message.input_type;
                if (message.output_type != null && message.hasOwnProperty("output_type"))
                    object.output_type = message.output_type;
                if (message.options != null && message.hasOwnProperty("options"))
                    object.options = $root.google.protobuf.MethodOptions.toObject(message.options, options);
                if (message.client_streaming != null && message.hasOwnProperty("client_streaming"))
                    object.client_streaming = message.client_streaming;
                if (message.server_streaming != null && message.hasOwnProperty("server_streaming"))
                    object.server_streaming = message.server_streaming;
                return object;
            };

            /**
             * Creates a plain object from this MethodDescriptorProto message. Also converts values to other types if specified.
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            MethodDescriptorProto.prototype.toObject = function toObject(options) {
                return this.constructor.toObject(this, options);
            };

            /**
             * Converts this MethodDescriptorProto to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            MethodDescriptorProto.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return MethodDescriptorProto;
        })();

        protobuf.FileOptions = (function() {

            /**
             * Properties of a FileOptions.
             * @typedef google.protobuf.FileOptions$Properties
             * @type {Object}
             * @property {string} [java_package] FileOptions java_package.
             * @property {string} [java_outer_classname] FileOptions java_outer_classname.
             * @property {boolean} [java_multiple_files] FileOptions java_multiple_files.
             * @property {boolean} [java_generate_equals_and_hash] FileOptions java_generate_equals_and_hash.
             * @property {boolean} [java_string_check_utf8] FileOptions java_string_check_utf8.
             * @property {google.protobuf.FileOptions.OptimizeMode} [optimize_for] FileOptions optimize_for.
             * @property {string} [go_package] FileOptions go_package.
             * @property {boolean} [cc_generic_services] FileOptions cc_generic_services.
             * @property {boolean} [java_generic_services] FileOptions java_generic_services.
             * @property {boolean} [py_generic_services] FileOptions py_generic_services.
             * @property {boolean} [deprecated] FileOptions deprecated.
             * @property {boolean} [cc_enable_arenas] FileOptions cc_enable_arenas.
             * @property {string} [objc_class_prefix] FileOptions objc_class_prefix.
             * @property {string} [csharp_namespace] FileOptions csharp_namespace.
             * @property {Array.<google.protobuf.UninterpretedOption$Properties>} [uninterpreted_option] FileOptions uninterpreted_option.
             * @property {boolean} [".gogoproto.goproto_getters_all"] FileOptions .gogoproto.goproto_getters_all.
             * @property {boolean} [".gogoproto.goproto_enum_prefix_all"] FileOptions .gogoproto.goproto_enum_prefix_all.
             * @property {boolean} [".gogoproto.goproto_stringer_all"] FileOptions .gogoproto.goproto_stringer_all.
             * @property {boolean} [".gogoproto.verbose_equal_all"] FileOptions .gogoproto.verbose_equal_all.
             * @property {boolean} [".gogoproto.face_all"] FileOptions .gogoproto.face_all.
             * @property {boolean} [".gogoproto.gostring_all"] FileOptions .gogoproto.gostring_all.
             * @property {boolean} [".gogoproto.populate_all"] FileOptions .gogoproto.populate_all.
             * @property {boolean} [".gogoproto.stringer_all"] FileOptions .gogoproto.stringer_all.
             * @property {boolean} [".gogoproto.onlyone_all"] FileOptions .gogoproto.onlyone_all.
             * @property {boolean} [".gogoproto.equal_all"] FileOptions .gogoproto.equal_all.
             * @property {boolean} [".gogoproto.description_all"] FileOptions .gogoproto.description_all.
             * @property {boolean} [".gogoproto.testgen_all"] FileOptions .gogoproto.testgen_all.
             * @property {boolean} [".gogoproto.benchgen_all"] FileOptions .gogoproto.benchgen_all.
             * @property {boolean} [".gogoproto.marshaler_all"] FileOptions .gogoproto.marshaler_all.
             * @property {boolean} [".gogoproto.unmarshaler_all"] FileOptions .gogoproto.unmarshaler_all.
             * @property {boolean} [".gogoproto.stable_marshaler_all"] FileOptions .gogoproto.stable_marshaler_all.
             * @property {boolean} [".gogoproto.sizer_all"] FileOptions .gogoproto.sizer_all.
             * @property {boolean} [".gogoproto.goproto_enum_stringer_all"] FileOptions .gogoproto.goproto_enum_stringer_all.
             * @property {boolean} [".gogoproto.enum_stringer_all"] FileOptions .gogoproto.enum_stringer_all.
             * @property {boolean} [".gogoproto.unsafe_marshaler_all"] FileOptions .gogoproto.unsafe_marshaler_all.
             * @property {boolean} [".gogoproto.unsafe_unmarshaler_all"] FileOptions .gogoproto.unsafe_unmarshaler_all.
             * @property {boolean} [".gogoproto.goproto_extensions_map_all"] FileOptions .gogoproto.goproto_extensions_map_all.
             * @property {boolean} [".gogoproto.goproto_unrecognized_all"] FileOptions .gogoproto.goproto_unrecognized_all.
             * @property {boolean} [".gogoproto.gogoproto_import"] FileOptions .gogoproto.gogoproto_import.
             * @property {boolean} [".gogoproto.protosizer_all"] FileOptions .gogoproto.protosizer_all.
             * @property {boolean} [".gogoproto.compare_all"] FileOptions .gogoproto.compare_all.
             * @property {boolean} [".gogoproto.typedecl_all"] FileOptions .gogoproto.typedecl_all.
             * @property {boolean} [".gogoproto.enumdecl_all"] FileOptions .gogoproto.enumdecl_all.
             * @property {boolean} [".gogoproto.goproto_registration"] FileOptions .gogoproto.goproto_registration.
             */

            /**
             * Constructs a new FileOptions.
             * @exports google.protobuf.FileOptions
             * @constructor
             * @param {google.protobuf.FileOptions$Properties=} [properties] Properties to set
             */
            function FileOptions(properties) {
                this.uninterpreted_option = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * FileOptions java_package.
             * @type {string}
             */
            FileOptions.prototype.java_package = "";

            /**
             * FileOptions java_outer_classname.
             * @type {string}
             */
            FileOptions.prototype.java_outer_classname = "";

            /**
             * FileOptions java_multiple_files.
             * @type {boolean}
             */
            FileOptions.prototype.java_multiple_files = false;

            /**
             * FileOptions java_generate_equals_and_hash.
             * @type {boolean}
             */
            FileOptions.prototype.java_generate_equals_and_hash = false;

            /**
             * FileOptions java_string_check_utf8.
             * @type {boolean}
             */
            FileOptions.prototype.java_string_check_utf8 = false;

            /**
             * FileOptions optimize_for.
             * @type {google.protobuf.FileOptions.OptimizeMode}
             */
            FileOptions.prototype.optimize_for = 1;

            /**
             * FileOptions go_package.
             * @type {string}
             */
            FileOptions.prototype.go_package = "";

            /**
             * FileOptions cc_generic_services.
             * @type {boolean}
             */
            FileOptions.prototype.cc_generic_services = false;

            /**
             * FileOptions java_generic_services.
             * @type {boolean}
             */
            FileOptions.prototype.java_generic_services = false;

            /**
             * FileOptions py_generic_services.
             * @type {boolean}
             */
            FileOptions.prototype.py_generic_services = false;

            /**
             * FileOptions deprecated.
             * @type {boolean}
             */
            FileOptions.prototype.deprecated = false;

            /**
             * FileOptions cc_enable_arenas.
             * @type {boolean}
             */
            FileOptions.prototype.cc_enable_arenas = false;

            /**
             * FileOptions objc_class_prefix.
             * @type {string}
             */
            FileOptions.prototype.objc_class_prefix = "";

            /**
             * FileOptions csharp_namespace.
             * @type {string}
             */
            FileOptions.prototype.csharp_namespace = "";

            /**
             * FileOptions uninterpreted_option.
             * @type {Array.<google.protobuf.UninterpretedOption$Properties>}
             */
            FileOptions.prototype.uninterpreted_option = $util.emptyArray;

            /**
             * FileOptions .gogoproto.goproto_getters_all.
             * @type {boolean}
             */
            FileOptions.prototype[".gogoproto.goproto_getters_all"] = false;

            /**
             * FileOptions .gogoproto.goproto_enum_prefix_all.
             * @type {boolean}
             */
            FileOptions.prototype[".gogoproto.goproto_enum_prefix_all"] = false;

            /**
             * FileOptions .gogoproto.goproto_stringer_all.
             * @type {boolean}
             */
            FileOptions.prototype[".gogoproto.goproto_stringer_all"] = false;

            /**
             * FileOptions .gogoproto.verbose_equal_all.
             * @type {boolean}
             */
            FileOptions.prototype[".gogoproto.verbose_equal_all"] = false;

            /**
             * FileOptions .gogoproto.face_all.
             * @type {boolean}
             */
            FileOptions.prototype[".gogoproto.face_all"] = false;

            /**
             * FileOptions .gogoproto.gostring_all.
             * @type {boolean}
             */
            FileOptions.prototype[".gogoproto.gostring_all"] = false;

            /**
             * FileOptions .gogoproto.populate_all.
             * @type {boolean}
             */
            FileOptions.prototype[".gogoproto.populate_all"] = false;

            /**
             * FileOptions .gogoproto.stringer_all.
             * @type {boolean}
             */
            FileOptions.prototype[".gogoproto.stringer_all"] = false;

            /**
             * FileOptions .gogoproto.onlyone_all.
             * @type {boolean}
             */
            FileOptions.prototype[".gogoproto.onlyone_all"] = false;

            /**
             * FileOptions .gogoproto.equal_all.
             * @type {boolean}
             */
            FileOptions.prototype[".gogoproto.equal_all"] = false;

            /**
             * FileOptions .gogoproto.description_all.
             * @type {boolean}
             */
            FileOptions.prototype[".gogoproto.description_all"] = false;

            /**
             * FileOptions .gogoproto.testgen_all.
             * @type {boolean}
             */
            FileOptions.prototype[".gogoproto.testgen_all"] = false;

            /**
             * FileOptions .gogoproto.benchgen_all.
             * @type {boolean}
             */
            FileOptions.prototype[".gogoproto.benchgen_all"] = false;

            /**
             * FileOptions .gogoproto.marshaler_all.
             * @type {boolean}
             */
            FileOptions.prototype[".gogoproto.marshaler_all"] = false;

            /**
             * FileOptions .gogoproto.unmarshaler_all.
             * @type {boolean}
             */
            FileOptions.prototype[".gogoproto.unmarshaler_all"] = false;

            /**
             * FileOptions .gogoproto.stable_marshaler_all.
             * @type {boolean}
             */
            FileOptions.prototype[".gogoproto.stable_marshaler_all"] = false;

            /**
             * FileOptions .gogoproto.sizer_all.
             * @type {boolean}
             */
            FileOptions.prototype[".gogoproto.sizer_all"] = false;

            /**
             * FileOptions .gogoproto.goproto_enum_stringer_all.
             * @type {boolean}
             */
            FileOptions.prototype[".gogoproto.goproto_enum_stringer_all"] = false;

            /**
             * FileOptions .gogoproto.enum_stringer_all.
             * @type {boolean}
             */
            FileOptions.prototype[".gogoproto.enum_stringer_all"] = false;

            /**
             * FileOptions .gogoproto.unsafe_marshaler_all.
             * @type {boolean}
             */
            FileOptions.prototype[".gogoproto.unsafe_marshaler_all"] = false;

            /**
             * FileOptions .gogoproto.unsafe_unmarshaler_all.
             * @type {boolean}
             */
            FileOptions.prototype[".gogoproto.unsafe_unmarshaler_all"] = false;

            /**
             * FileOptions .gogoproto.goproto_extensions_map_all.
             * @type {boolean}
             */
            FileOptions.prototype[".gogoproto.goproto_extensions_map_all"] = false;

            /**
             * FileOptions .gogoproto.goproto_unrecognized_all.
             * @type {boolean}
             */
            FileOptions.prototype[".gogoproto.goproto_unrecognized_all"] = false;

            /**
             * FileOptions .gogoproto.gogoproto_import.
             * @type {boolean}
             */
            FileOptions.prototype[".gogoproto.gogoproto_import"] = false;

            /**
             * FileOptions .gogoproto.protosizer_all.
             * @type {boolean}
             */
            FileOptions.prototype[".gogoproto.protosizer_all"] = false;

            /**
             * FileOptions .gogoproto.compare_all.
             * @type {boolean}
             */
            FileOptions.prototype[".gogoproto.compare_all"] = false;

            /**
             * FileOptions .gogoproto.typedecl_all.
             * @type {boolean}
             */
            FileOptions.prototype[".gogoproto.typedecl_all"] = false;

            /**
             * FileOptions .gogoproto.enumdecl_all.
             * @type {boolean}
             */
            FileOptions.prototype[".gogoproto.enumdecl_all"] = false;

            /**
             * FileOptions .gogoproto.goproto_registration.
             * @type {boolean}
             */
            FileOptions.prototype[".gogoproto.goproto_registration"] = false;

            /**
             * Creates a new FileOptions instance using the specified properties.
             * @param {google.protobuf.FileOptions$Properties=} [properties] Properties to set
             * @returns {google.protobuf.FileOptions} FileOptions instance
             */
            FileOptions.create = function create(properties) {
                return new FileOptions(properties);
            };

            /**
             * Encodes the specified FileOptions message. Does not implicitly {@link google.protobuf.FileOptions.verify|verify} messages.
             * @param {google.protobuf.FileOptions$Properties} message FileOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FileOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.java_package != null && message.hasOwnProperty("java_package"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.java_package);
                if (message.java_outer_classname != null && message.hasOwnProperty("java_outer_classname"))
                    writer.uint32(/* id 8, wireType 2 =*/66).string(message.java_outer_classname);
                if (message.optimize_for != null && message.hasOwnProperty("optimize_for"))
                    writer.uint32(/* id 9, wireType 0 =*/72).uint32(message.optimize_for);
                if (message.java_multiple_files != null && message.hasOwnProperty("java_multiple_files"))
                    writer.uint32(/* id 10, wireType 0 =*/80).bool(message.java_multiple_files);
                if (message.go_package != null && message.hasOwnProperty("go_package"))
                    writer.uint32(/* id 11, wireType 2 =*/90).string(message.go_package);
                if (message.cc_generic_services != null && message.hasOwnProperty("cc_generic_services"))
                    writer.uint32(/* id 16, wireType 0 =*/128).bool(message.cc_generic_services);
                if (message.java_generic_services != null && message.hasOwnProperty("java_generic_services"))
                    writer.uint32(/* id 17, wireType 0 =*/136).bool(message.java_generic_services);
                if (message.py_generic_services != null && message.hasOwnProperty("py_generic_services"))
                    writer.uint32(/* id 18, wireType 0 =*/144).bool(message.py_generic_services);
                if (message.java_generate_equals_and_hash != null && message.hasOwnProperty("java_generate_equals_and_hash"))
                    writer.uint32(/* id 20, wireType 0 =*/160).bool(message.java_generate_equals_and_hash);
                if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                    writer.uint32(/* id 23, wireType 0 =*/184).bool(message.deprecated);
                if (message.java_string_check_utf8 != null && message.hasOwnProperty("java_string_check_utf8"))
                    writer.uint32(/* id 27, wireType 0 =*/216).bool(message.java_string_check_utf8);
                if (message.cc_enable_arenas != null && message.hasOwnProperty("cc_enable_arenas"))
                    writer.uint32(/* id 31, wireType 0 =*/248).bool(message.cc_enable_arenas);
                if (message.objc_class_prefix != null && message.hasOwnProperty("objc_class_prefix"))
                    writer.uint32(/* id 36, wireType 2 =*/290).string(message.objc_class_prefix);
                if (message.csharp_namespace != null && message.hasOwnProperty("csharp_namespace"))
                    writer.uint32(/* id 37, wireType 2 =*/298).string(message.csharp_namespace);
                if (message.uninterpreted_option != null && message.uninterpreted_option.length)
                    for (let i = 0; i < message.uninterpreted_option.length; ++i)
                        $root.google.protobuf.UninterpretedOption.encode(message.uninterpreted_option[i], writer.uint32(/* id 999, wireType 2 =*/7994).fork()).ldelim();
                if (message[".gogoproto.goproto_getters_all"] != null && message.hasOwnProperty(".gogoproto.goproto_getters_all"))
                    writer.uint32(/* id 63001, wireType 0 =*/504008).bool(message[".gogoproto.goproto_getters_all"]);
                if (message[".gogoproto.goproto_enum_prefix_all"] != null && message.hasOwnProperty(".gogoproto.goproto_enum_prefix_all"))
                    writer.uint32(/* id 63002, wireType 0 =*/504016).bool(message[".gogoproto.goproto_enum_prefix_all"]);
                if (message[".gogoproto.goproto_stringer_all"] != null && message.hasOwnProperty(".gogoproto.goproto_stringer_all"))
                    writer.uint32(/* id 63003, wireType 0 =*/504024).bool(message[".gogoproto.goproto_stringer_all"]);
                if (message[".gogoproto.verbose_equal_all"] != null && message.hasOwnProperty(".gogoproto.verbose_equal_all"))
                    writer.uint32(/* id 63004, wireType 0 =*/504032).bool(message[".gogoproto.verbose_equal_all"]);
                if (message[".gogoproto.face_all"] != null && message.hasOwnProperty(".gogoproto.face_all"))
                    writer.uint32(/* id 63005, wireType 0 =*/504040).bool(message[".gogoproto.face_all"]);
                if (message[".gogoproto.gostring_all"] != null && message.hasOwnProperty(".gogoproto.gostring_all"))
                    writer.uint32(/* id 63006, wireType 0 =*/504048).bool(message[".gogoproto.gostring_all"]);
                if (message[".gogoproto.populate_all"] != null && message.hasOwnProperty(".gogoproto.populate_all"))
                    writer.uint32(/* id 63007, wireType 0 =*/504056).bool(message[".gogoproto.populate_all"]);
                if (message[".gogoproto.stringer_all"] != null && message.hasOwnProperty(".gogoproto.stringer_all"))
                    writer.uint32(/* id 63008, wireType 0 =*/504064).bool(message[".gogoproto.stringer_all"]);
                if (message[".gogoproto.onlyone_all"] != null && message.hasOwnProperty(".gogoproto.onlyone_all"))
                    writer.uint32(/* id 63009, wireType 0 =*/504072).bool(message[".gogoproto.onlyone_all"]);
                if (message[".gogoproto.equal_all"] != null && message.hasOwnProperty(".gogoproto.equal_all"))
                    writer.uint32(/* id 63013, wireType 0 =*/504104).bool(message[".gogoproto.equal_all"]);
                if (message[".gogoproto.description_all"] != null && message.hasOwnProperty(".gogoproto.description_all"))
                    writer.uint32(/* id 63014, wireType 0 =*/504112).bool(message[".gogoproto.description_all"]);
                if (message[".gogoproto.testgen_all"] != null && message.hasOwnProperty(".gogoproto.testgen_all"))
                    writer.uint32(/* id 63015, wireType 0 =*/504120).bool(message[".gogoproto.testgen_all"]);
                if (message[".gogoproto.benchgen_all"] != null && message.hasOwnProperty(".gogoproto.benchgen_all"))
                    writer.uint32(/* id 63016, wireType 0 =*/504128).bool(message[".gogoproto.benchgen_all"]);
                if (message[".gogoproto.marshaler_all"] != null && message.hasOwnProperty(".gogoproto.marshaler_all"))
                    writer.uint32(/* id 63017, wireType 0 =*/504136).bool(message[".gogoproto.marshaler_all"]);
                if (message[".gogoproto.unmarshaler_all"] != null && message.hasOwnProperty(".gogoproto.unmarshaler_all"))
                    writer.uint32(/* id 63018, wireType 0 =*/504144).bool(message[".gogoproto.unmarshaler_all"]);
                if (message[".gogoproto.stable_marshaler_all"] != null && message.hasOwnProperty(".gogoproto.stable_marshaler_all"))
                    writer.uint32(/* id 63019, wireType 0 =*/504152).bool(message[".gogoproto.stable_marshaler_all"]);
                if (message[".gogoproto.sizer_all"] != null && message.hasOwnProperty(".gogoproto.sizer_all"))
                    writer.uint32(/* id 63020, wireType 0 =*/504160).bool(message[".gogoproto.sizer_all"]);
                if (message[".gogoproto.goproto_enum_stringer_all"] != null && message.hasOwnProperty(".gogoproto.goproto_enum_stringer_all"))
                    writer.uint32(/* id 63021, wireType 0 =*/504168).bool(message[".gogoproto.goproto_enum_stringer_all"]);
                if (message[".gogoproto.enum_stringer_all"] != null && message.hasOwnProperty(".gogoproto.enum_stringer_all"))
                    writer.uint32(/* id 63022, wireType 0 =*/504176).bool(message[".gogoproto.enum_stringer_all"]);
                if (message[".gogoproto.unsafe_marshaler_all"] != null && message.hasOwnProperty(".gogoproto.unsafe_marshaler_all"))
                    writer.uint32(/* id 63023, wireType 0 =*/504184).bool(message[".gogoproto.unsafe_marshaler_all"]);
                if (message[".gogoproto.unsafe_unmarshaler_all"] != null && message.hasOwnProperty(".gogoproto.unsafe_unmarshaler_all"))
                    writer.uint32(/* id 63024, wireType 0 =*/504192).bool(message[".gogoproto.unsafe_unmarshaler_all"]);
                if (message[".gogoproto.goproto_extensions_map_all"] != null && message.hasOwnProperty(".gogoproto.goproto_extensions_map_all"))
                    writer.uint32(/* id 63025, wireType 0 =*/504200).bool(message[".gogoproto.goproto_extensions_map_all"]);
                if (message[".gogoproto.goproto_unrecognized_all"] != null && message.hasOwnProperty(".gogoproto.goproto_unrecognized_all"))
                    writer.uint32(/* id 63026, wireType 0 =*/504208).bool(message[".gogoproto.goproto_unrecognized_all"]);
                if (message[".gogoproto.gogoproto_import"] != null && message.hasOwnProperty(".gogoproto.gogoproto_import"))
                    writer.uint32(/* id 63027, wireType 0 =*/504216).bool(message[".gogoproto.gogoproto_import"]);
                if (message[".gogoproto.protosizer_all"] != null && message.hasOwnProperty(".gogoproto.protosizer_all"))
                    writer.uint32(/* id 63028, wireType 0 =*/504224).bool(message[".gogoproto.protosizer_all"]);
                if (message[".gogoproto.compare_all"] != null && message.hasOwnProperty(".gogoproto.compare_all"))
                    writer.uint32(/* id 63029, wireType 0 =*/504232).bool(message[".gogoproto.compare_all"]);
                if (message[".gogoproto.typedecl_all"] != null && message.hasOwnProperty(".gogoproto.typedecl_all"))
                    writer.uint32(/* id 63030, wireType 0 =*/504240).bool(message[".gogoproto.typedecl_all"]);
                if (message[".gogoproto.enumdecl_all"] != null && message.hasOwnProperty(".gogoproto.enumdecl_all"))
                    writer.uint32(/* id 63031, wireType 0 =*/504248).bool(message[".gogoproto.enumdecl_all"]);
                if (message[".gogoproto.goproto_registration"] != null && message.hasOwnProperty(".gogoproto.goproto_registration"))
                    writer.uint32(/* id 63032, wireType 0 =*/504256).bool(message[".gogoproto.goproto_registration"]);
                return writer;
            };

            /**
             * Encodes the specified FileOptions message, length delimited. Does not implicitly {@link google.protobuf.FileOptions.verify|verify} messages.
             * @param {google.protobuf.FileOptions$Properties} message FileOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FileOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a FileOptions message from the specified reader or buffer.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.FileOptions} FileOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FileOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.FileOptions();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.java_package = reader.string();
                        break;
                    case 8:
                        message.java_outer_classname = reader.string();
                        break;
                    case 10:
                        message.java_multiple_files = reader.bool();
                        break;
                    case 20:
                        message.java_generate_equals_and_hash = reader.bool();
                        break;
                    case 27:
                        message.java_string_check_utf8 = reader.bool();
                        break;
                    case 9:
                        message.optimize_for = reader.uint32();
                        break;
                    case 11:
                        message.go_package = reader.string();
                        break;
                    case 16:
                        message.cc_generic_services = reader.bool();
                        break;
                    case 17:
                        message.java_generic_services = reader.bool();
                        break;
                    case 18:
                        message.py_generic_services = reader.bool();
                        break;
                    case 23:
                        message.deprecated = reader.bool();
                        break;
                    case 31:
                        message.cc_enable_arenas = reader.bool();
                        break;
                    case 36:
                        message.objc_class_prefix = reader.string();
                        break;
                    case 37:
                        message.csharp_namespace = reader.string();
                        break;
                    case 999:
                        if (!(message.uninterpreted_option && message.uninterpreted_option.length))
                            message.uninterpreted_option = [];
                        message.uninterpreted_option.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));
                        break;
                    case 63001:
                        message[".gogoproto.goproto_getters_all"] = reader.bool();
                        break;
                    case 63002:
                        message[".gogoproto.goproto_enum_prefix_all"] = reader.bool();
                        break;
                    case 63003:
                        message[".gogoproto.goproto_stringer_all"] = reader.bool();
                        break;
                    case 63004:
                        message[".gogoproto.verbose_equal_all"] = reader.bool();
                        break;
                    case 63005:
                        message[".gogoproto.face_all"] = reader.bool();
                        break;
                    case 63006:
                        message[".gogoproto.gostring_all"] = reader.bool();
                        break;
                    case 63007:
                        message[".gogoproto.populate_all"] = reader.bool();
                        break;
                    case 63008:
                        message[".gogoproto.stringer_all"] = reader.bool();
                        break;
                    case 63009:
                        message[".gogoproto.onlyone_all"] = reader.bool();
                        break;
                    case 63013:
                        message[".gogoproto.equal_all"] = reader.bool();
                        break;
                    case 63014:
                        message[".gogoproto.description_all"] = reader.bool();
                        break;
                    case 63015:
                        message[".gogoproto.testgen_all"] = reader.bool();
                        break;
                    case 63016:
                        message[".gogoproto.benchgen_all"] = reader.bool();
                        break;
                    case 63017:
                        message[".gogoproto.marshaler_all"] = reader.bool();
                        break;
                    case 63018:
                        message[".gogoproto.unmarshaler_all"] = reader.bool();
                        break;
                    case 63019:
                        message[".gogoproto.stable_marshaler_all"] = reader.bool();
                        break;
                    case 63020:
                        message[".gogoproto.sizer_all"] = reader.bool();
                        break;
                    case 63021:
                        message[".gogoproto.goproto_enum_stringer_all"] = reader.bool();
                        break;
                    case 63022:
                        message[".gogoproto.enum_stringer_all"] = reader.bool();
                        break;
                    case 63023:
                        message[".gogoproto.unsafe_marshaler_all"] = reader.bool();
                        break;
                    case 63024:
                        message[".gogoproto.unsafe_unmarshaler_all"] = reader.bool();
                        break;
                    case 63025:
                        message[".gogoproto.goproto_extensions_map_all"] = reader.bool();
                        break;
                    case 63026:
                        message[".gogoproto.goproto_unrecognized_all"] = reader.bool();
                        break;
                    case 63027:
                        message[".gogoproto.gogoproto_import"] = reader.bool();
                        break;
                    case 63028:
                        message[".gogoproto.protosizer_all"] = reader.bool();
                        break;
                    case 63029:
                        message[".gogoproto.compare_all"] = reader.bool();
                        break;
                    case 63030:
                        message[".gogoproto.typedecl_all"] = reader.bool();
                        break;
                    case 63031:
                        message[".gogoproto.enumdecl_all"] = reader.bool();
                        break;
                    case 63032:
                        message[".gogoproto.goproto_registration"] = reader.bool();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a FileOptions message from the specified reader or buffer, length delimited.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.FileOptions} FileOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FileOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a FileOptions message.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            FileOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.java_package != null && message.hasOwnProperty("java_package"))
                    if (!$util.isString(message.java_package))
                        return "java_package: string expected";
                if (message.java_outer_classname != null && message.hasOwnProperty("java_outer_classname"))
                    if (!$util.isString(message.java_outer_classname))
                        return "java_outer_classname: string expected";
                if (message.java_multiple_files != null && message.hasOwnProperty("java_multiple_files"))
                    if (typeof message.java_multiple_files !== "boolean")
                        return "java_multiple_files: boolean expected";
                if (message.java_generate_equals_and_hash != null && message.hasOwnProperty("java_generate_equals_and_hash"))
                    if (typeof message.java_generate_equals_and_hash !== "boolean")
                        return "java_generate_equals_and_hash: boolean expected";
                if (message.java_string_check_utf8 != null && message.hasOwnProperty("java_string_check_utf8"))
                    if (typeof message.java_string_check_utf8 !== "boolean")
                        return "java_string_check_utf8: boolean expected";
                if (message.optimize_for != null && message.hasOwnProperty("optimize_for"))
                    switch (message.optimize_for) {
                    default:
                        return "optimize_for: enum value expected";
                    case 1:
                    case 2:
                    case 3:
                        break;
                    }
                if (message.go_package != null && message.hasOwnProperty("go_package"))
                    if (!$util.isString(message.go_package))
                        return "go_package: string expected";
                if (message.cc_generic_services != null && message.hasOwnProperty("cc_generic_services"))
                    if (typeof message.cc_generic_services !== "boolean")
                        return "cc_generic_services: boolean expected";
                if (message.java_generic_services != null && message.hasOwnProperty("java_generic_services"))
                    if (typeof message.java_generic_services !== "boolean")
                        return "java_generic_services: boolean expected";
                if (message.py_generic_services != null && message.hasOwnProperty("py_generic_services"))
                    if (typeof message.py_generic_services !== "boolean")
                        return "py_generic_services: boolean expected";
                if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                    if (typeof message.deprecated !== "boolean")
                        return "deprecated: boolean expected";
                if (message.cc_enable_arenas != null && message.hasOwnProperty("cc_enable_arenas"))
                    if (typeof message.cc_enable_arenas !== "boolean")
                        return "cc_enable_arenas: boolean expected";
                if (message.objc_class_prefix != null && message.hasOwnProperty("objc_class_prefix"))
                    if (!$util.isString(message.objc_class_prefix))
                        return "objc_class_prefix: string expected";
                if (message.csharp_namespace != null && message.hasOwnProperty("csharp_namespace"))
                    if (!$util.isString(message.csharp_namespace))
                        return "csharp_namespace: string expected";
                if (message.uninterpreted_option != null && message.hasOwnProperty("uninterpreted_option")) {
                    if (!Array.isArray(message.uninterpreted_option))
                        return "uninterpreted_option: array expected";
                    for (let i = 0; i < message.uninterpreted_option.length; ++i) {
                        let error = $root.google.protobuf.UninterpretedOption.verify(message.uninterpreted_option[i]);
                        if (error)
                            return "uninterpreted_option." + error;
                    }
                }
                if (message[".gogoproto.goproto_getters_all"] != null && message.hasOwnProperty(".gogoproto.goproto_getters_all"))
                    if (typeof message[".gogoproto.goproto_getters_all"] !== "boolean")
                        return ".gogoproto.goproto_getters_all: boolean expected";
                if (message[".gogoproto.goproto_enum_prefix_all"] != null && message.hasOwnProperty(".gogoproto.goproto_enum_prefix_all"))
                    if (typeof message[".gogoproto.goproto_enum_prefix_all"] !== "boolean")
                        return ".gogoproto.goproto_enum_prefix_all: boolean expected";
                if (message[".gogoproto.goproto_stringer_all"] != null && message.hasOwnProperty(".gogoproto.goproto_stringer_all"))
                    if (typeof message[".gogoproto.goproto_stringer_all"] !== "boolean")
                        return ".gogoproto.goproto_stringer_all: boolean expected";
                if (message[".gogoproto.verbose_equal_all"] != null && message.hasOwnProperty(".gogoproto.verbose_equal_all"))
                    if (typeof message[".gogoproto.verbose_equal_all"] !== "boolean")
                        return ".gogoproto.verbose_equal_all: boolean expected";
                if (message[".gogoproto.face_all"] != null && message.hasOwnProperty(".gogoproto.face_all"))
                    if (typeof message[".gogoproto.face_all"] !== "boolean")
                        return ".gogoproto.face_all: boolean expected";
                if (message[".gogoproto.gostring_all"] != null && message.hasOwnProperty(".gogoproto.gostring_all"))
                    if (typeof message[".gogoproto.gostring_all"] !== "boolean")
                        return ".gogoproto.gostring_all: boolean expected";
                if (message[".gogoproto.populate_all"] != null && message.hasOwnProperty(".gogoproto.populate_all"))
                    if (typeof message[".gogoproto.populate_all"] !== "boolean")
                        return ".gogoproto.populate_all: boolean expected";
                if (message[".gogoproto.stringer_all"] != null && message.hasOwnProperty(".gogoproto.stringer_all"))
                    if (typeof message[".gogoproto.stringer_all"] !== "boolean")
                        return ".gogoproto.stringer_all: boolean expected";
                if (message[".gogoproto.onlyone_all"] != null && message.hasOwnProperty(".gogoproto.onlyone_all"))
                    if (typeof message[".gogoproto.onlyone_all"] !== "boolean")
                        return ".gogoproto.onlyone_all: boolean expected";
                if (message[".gogoproto.equal_all"] != null && message.hasOwnProperty(".gogoproto.equal_all"))
                    if (typeof message[".gogoproto.equal_all"] !== "boolean")
                        return ".gogoproto.equal_all: boolean expected";
                if (message[".gogoproto.description_all"] != null && message.hasOwnProperty(".gogoproto.description_all"))
                    if (typeof message[".gogoproto.description_all"] !== "boolean")
                        return ".gogoproto.description_all: boolean expected";
                if (message[".gogoproto.testgen_all"] != null && message.hasOwnProperty(".gogoproto.testgen_all"))
                    if (typeof message[".gogoproto.testgen_all"] !== "boolean")
                        return ".gogoproto.testgen_all: boolean expected";
                if (message[".gogoproto.benchgen_all"] != null && message.hasOwnProperty(".gogoproto.benchgen_all"))
                    if (typeof message[".gogoproto.benchgen_all"] !== "boolean")
                        return ".gogoproto.benchgen_all: boolean expected";
                if (message[".gogoproto.marshaler_all"] != null && message.hasOwnProperty(".gogoproto.marshaler_all"))
                    if (typeof message[".gogoproto.marshaler_all"] !== "boolean")
                        return ".gogoproto.marshaler_all: boolean expected";
                if (message[".gogoproto.unmarshaler_all"] != null && message.hasOwnProperty(".gogoproto.unmarshaler_all"))
                    if (typeof message[".gogoproto.unmarshaler_all"] !== "boolean")
                        return ".gogoproto.unmarshaler_all: boolean expected";
                if (message[".gogoproto.stable_marshaler_all"] != null && message.hasOwnProperty(".gogoproto.stable_marshaler_all"))
                    if (typeof message[".gogoproto.stable_marshaler_all"] !== "boolean")
                        return ".gogoproto.stable_marshaler_all: boolean expected";
                if (message[".gogoproto.sizer_all"] != null && message.hasOwnProperty(".gogoproto.sizer_all"))
                    if (typeof message[".gogoproto.sizer_all"] !== "boolean")
                        return ".gogoproto.sizer_all: boolean expected";
                if (message[".gogoproto.goproto_enum_stringer_all"] != null && message.hasOwnProperty(".gogoproto.goproto_enum_stringer_all"))
                    if (typeof message[".gogoproto.goproto_enum_stringer_all"] !== "boolean")
                        return ".gogoproto.goproto_enum_stringer_all: boolean expected";
                if (message[".gogoproto.enum_stringer_all"] != null && message.hasOwnProperty(".gogoproto.enum_stringer_all"))
                    if (typeof message[".gogoproto.enum_stringer_all"] !== "boolean")
                        return ".gogoproto.enum_stringer_all: boolean expected";
                if (message[".gogoproto.unsafe_marshaler_all"] != null && message.hasOwnProperty(".gogoproto.unsafe_marshaler_all"))
                    if (typeof message[".gogoproto.unsafe_marshaler_all"] !== "boolean")
                        return ".gogoproto.unsafe_marshaler_all: boolean expected";
                if (message[".gogoproto.unsafe_unmarshaler_all"] != null && message.hasOwnProperty(".gogoproto.unsafe_unmarshaler_all"))
                    if (typeof message[".gogoproto.unsafe_unmarshaler_all"] !== "boolean")
                        return ".gogoproto.unsafe_unmarshaler_all: boolean expected";
                if (message[".gogoproto.goproto_extensions_map_all"] != null && message.hasOwnProperty(".gogoproto.goproto_extensions_map_all"))
                    if (typeof message[".gogoproto.goproto_extensions_map_all"] !== "boolean")
                        return ".gogoproto.goproto_extensions_map_all: boolean expected";
                if (message[".gogoproto.goproto_unrecognized_all"] != null && message.hasOwnProperty(".gogoproto.goproto_unrecognized_all"))
                    if (typeof message[".gogoproto.goproto_unrecognized_all"] !== "boolean")
                        return ".gogoproto.goproto_unrecognized_all: boolean expected";
                if (message[".gogoproto.gogoproto_import"] != null && message.hasOwnProperty(".gogoproto.gogoproto_import"))
                    if (typeof message[".gogoproto.gogoproto_import"] !== "boolean")
                        return ".gogoproto.gogoproto_import: boolean expected";
                if (message[".gogoproto.protosizer_all"] != null && message.hasOwnProperty(".gogoproto.protosizer_all"))
                    if (typeof message[".gogoproto.protosizer_all"] !== "boolean")
                        return ".gogoproto.protosizer_all: boolean expected";
                if (message[".gogoproto.compare_all"] != null && message.hasOwnProperty(".gogoproto.compare_all"))
                    if (typeof message[".gogoproto.compare_all"] !== "boolean")
                        return ".gogoproto.compare_all: boolean expected";
                if (message[".gogoproto.typedecl_all"] != null && message.hasOwnProperty(".gogoproto.typedecl_all"))
                    if (typeof message[".gogoproto.typedecl_all"] !== "boolean")
                        return ".gogoproto.typedecl_all: boolean expected";
                if (message[".gogoproto.enumdecl_all"] != null && message.hasOwnProperty(".gogoproto.enumdecl_all"))
                    if (typeof message[".gogoproto.enumdecl_all"] !== "boolean")
                        return ".gogoproto.enumdecl_all: boolean expected";
                if (message[".gogoproto.goproto_registration"] != null && message.hasOwnProperty(".gogoproto.goproto_registration"))
                    if (typeof message[".gogoproto.goproto_registration"] !== "boolean")
                        return ".gogoproto.goproto_registration: boolean expected";
                return null;
            };

            /**
             * Creates a FileOptions message from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.FileOptions} FileOptions
             */
            FileOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.FileOptions)
                    return object;
                let message = new $root.google.protobuf.FileOptions();
                if (object.java_package != null)
                    message.java_package = String(object.java_package);
                if (object.java_outer_classname != null)
                    message.java_outer_classname = String(object.java_outer_classname);
                if (object.java_multiple_files != null)
                    message.java_multiple_files = Boolean(object.java_multiple_files);
                if (object.java_generate_equals_and_hash != null)
                    message.java_generate_equals_and_hash = Boolean(object.java_generate_equals_and_hash);
                if (object.java_string_check_utf8 != null)
                    message.java_string_check_utf8 = Boolean(object.java_string_check_utf8);
                switch (object.optimize_for) {
                case "SPEED":
                case 1:
                    message.optimize_for = 1;
                    break;
                case "CODE_SIZE":
                case 2:
                    message.optimize_for = 2;
                    break;
                case "LITE_RUNTIME":
                case 3:
                    message.optimize_for = 3;
                    break;
                }
                if (object.go_package != null)
                    message.go_package = String(object.go_package);
                if (object.cc_generic_services != null)
                    message.cc_generic_services = Boolean(object.cc_generic_services);
                if (object.java_generic_services != null)
                    message.java_generic_services = Boolean(object.java_generic_services);
                if (object.py_generic_services != null)
                    message.py_generic_services = Boolean(object.py_generic_services);
                if (object.deprecated != null)
                    message.deprecated = Boolean(object.deprecated);
                if (object.cc_enable_arenas != null)
                    message.cc_enable_arenas = Boolean(object.cc_enable_arenas);
                if (object.objc_class_prefix != null)
                    message.objc_class_prefix = String(object.objc_class_prefix);
                if (object.csharp_namespace != null)
                    message.csharp_namespace = String(object.csharp_namespace);
                if (object.uninterpreted_option) {
                    if (!Array.isArray(object.uninterpreted_option))
                        throw TypeError(".google.protobuf.FileOptions.uninterpreted_option: array expected");
                    message.uninterpreted_option = [];
                    for (let i = 0; i < object.uninterpreted_option.length; ++i) {
                        if (typeof object.uninterpreted_option[i] !== "object")
                            throw TypeError(".google.protobuf.FileOptions.uninterpreted_option: object expected");
                        message.uninterpreted_option[i] = $root.google.protobuf.UninterpretedOption.fromObject(object.uninterpreted_option[i]);
                    }
                }
                if (object[".gogoproto.goproto_getters_all"] != null)
                    message[".gogoproto.goproto_getters_all"] = Boolean(object[".gogoproto.goproto_getters_all"]);
                if (object[".gogoproto.goproto_enum_prefix_all"] != null)
                    message[".gogoproto.goproto_enum_prefix_all"] = Boolean(object[".gogoproto.goproto_enum_prefix_all"]);
                if (object[".gogoproto.goproto_stringer_all"] != null)
                    message[".gogoproto.goproto_stringer_all"] = Boolean(object[".gogoproto.goproto_stringer_all"]);
                if (object[".gogoproto.verbose_equal_all"] != null)
                    message[".gogoproto.verbose_equal_all"] = Boolean(object[".gogoproto.verbose_equal_all"]);
                if (object[".gogoproto.face_all"] != null)
                    message[".gogoproto.face_all"] = Boolean(object[".gogoproto.face_all"]);
                if (object[".gogoproto.gostring_all"] != null)
                    message[".gogoproto.gostring_all"] = Boolean(object[".gogoproto.gostring_all"]);
                if (object[".gogoproto.populate_all"] != null)
                    message[".gogoproto.populate_all"] = Boolean(object[".gogoproto.populate_all"]);
                if (object[".gogoproto.stringer_all"] != null)
                    message[".gogoproto.stringer_all"] = Boolean(object[".gogoproto.stringer_all"]);
                if (object[".gogoproto.onlyone_all"] != null)
                    message[".gogoproto.onlyone_all"] = Boolean(object[".gogoproto.onlyone_all"]);
                if (object[".gogoproto.equal_all"] != null)
                    message[".gogoproto.equal_all"] = Boolean(object[".gogoproto.equal_all"]);
                if (object[".gogoproto.description_all"] != null)
                    message[".gogoproto.description_all"] = Boolean(object[".gogoproto.description_all"]);
                if (object[".gogoproto.testgen_all"] != null)
                    message[".gogoproto.testgen_all"] = Boolean(object[".gogoproto.testgen_all"]);
                if (object[".gogoproto.benchgen_all"] != null)
                    message[".gogoproto.benchgen_all"] = Boolean(object[".gogoproto.benchgen_all"]);
                if (object[".gogoproto.marshaler_all"] != null)
                    message[".gogoproto.marshaler_all"] = Boolean(object[".gogoproto.marshaler_all"]);
                if (object[".gogoproto.unmarshaler_all"] != null)
                    message[".gogoproto.unmarshaler_all"] = Boolean(object[".gogoproto.unmarshaler_all"]);
                if (object[".gogoproto.stable_marshaler_all"] != null)
                    message[".gogoproto.stable_marshaler_all"] = Boolean(object[".gogoproto.stable_marshaler_all"]);
                if (object[".gogoproto.sizer_all"] != null)
                    message[".gogoproto.sizer_all"] = Boolean(object[".gogoproto.sizer_all"]);
                if (object[".gogoproto.goproto_enum_stringer_all"] != null)
                    message[".gogoproto.goproto_enum_stringer_all"] = Boolean(object[".gogoproto.goproto_enum_stringer_all"]);
                if (object[".gogoproto.enum_stringer_all"] != null)
                    message[".gogoproto.enum_stringer_all"] = Boolean(object[".gogoproto.enum_stringer_all"]);
                if (object[".gogoproto.unsafe_marshaler_all"] != null)
                    message[".gogoproto.unsafe_marshaler_all"] = Boolean(object[".gogoproto.unsafe_marshaler_all"]);
                if (object[".gogoproto.unsafe_unmarshaler_all"] != null)
                    message[".gogoproto.unsafe_unmarshaler_all"] = Boolean(object[".gogoproto.unsafe_unmarshaler_all"]);
                if (object[".gogoproto.goproto_extensions_map_all"] != null)
                    message[".gogoproto.goproto_extensions_map_all"] = Boolean(object[".gogoproto.goproto_extensions_map_all"]);
                if (object[".gogoproto.goproto_unrecognized_all"] != null)
                    message[".gogoproto.goproto_unrecognized_all"] = Boolean(object[".gogoproto.goproto_unrecognized_all"]);
                if (object[".gogoproto.gogoproto_import"] != null)
                    message[".gogoproto.gogoproto_import"] = Boolean(object[".gogoproto.gogoproto_import"]);
                if (object[".gogoproto.protosizer_all"] != null)
                    message[".gogoproto.protosizer_all"] = Boolean(object[".gogoproto.protosizer_all"]);
                if (object[".gogoproto.compare_all"] != null)
                    message[".gogoproto.compare_all"] = Boolean(object[".gogoproto.compare_all"]);
                if (object[".gogoproto.typedecl_all"] != null)
                    message[".gogoproto.typedecl_all"] = Boolean(object[".gogoproto.typedecl_all"]);
                if (object[".gogoproto.enumdecl_all"] != null)
                    message[".gogoproto.enumdecl_all"] = Boolean(object[".gogoproto.enumdecl_all"]);
                if (object[".gogoproto.goproto_registration"] != null)
                    message[".gogoproto.goproto_registration"] = Boolean(object[".gogoproto.goproto_registration"]);
                return message;
            };

            /**
             * Creates a FileOptions message from a plain object. Also converts values to their respective internal types.
             * This is an alias of {@link google.protobuf.FileOptions.fromObject}.
             * @function
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.FileOptions} FileOptions
             */
            FileOptions.from = FileOptions.fromObject;

            /**
             * Creates a plain object from a FileOptions message. Also converts values to other types if specified.
             * @param {google.protobuf.FileOptions} message FileOptions
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            FileOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.uninterpreted_option = [];
                if (options.defaults) {
                    object.java_package = "";
                    object.java_outer_classname = "";
                    object.optimize_for = options.enums === String ? "SPEED" : 1;
                    object.java_multiple_files = false;
                    object.go_package = "";
                    object.cc_generic_services = false;
                    object.java_generic_services = false;
                    object.py_generic_services = false;
                    object.java_generate_equals_and_hash = false;
                    object.deprecated = false;
                    object.java_string_check_utf8 = false;
                    object.cc_enable_arenas = false;
                    object.objc_class_prefix = "";
                    object.csharp_namespace = "";
                    object[".gogoproto.goproto_getters_all"] = false;
                    object[".gogoproto.goproto_enum_prefix_all"] = false;
                    object[".gogoproto.goproto_stringer_all"] = false;
                    object[".gogoproto.verbose_equal_all"] = false;
                    object[".gogoproto.face_all"] = false;
                    object[".gogoproto.gostring_all"] = false;
                    object[".gogoproto.populate_all"] = false;
                    object[".gogoproto.stringer_all"] = false;
                    object[".gogoproto.onlyone_all"] = false;
                    object[".gogoproto.equal_all"] = false;
                    object[".gogoproto.description_all"] = false;
                    object[".gogoproto.testgen_all"] = false;
                    object[".gogoproto.benchgen_all"] = false;
                    object[".gogoproto.marshaler_all"] = false;
                    object[".gogoproto.unmarshaler_all"] = false;
                    object[".gogoproto.stable_marshaler_all"] = false;
                    object[".gogoproto.sizer_all"] = false;
                    object[".gogoproto.goproto_enum_stringer_all"] = false;
                    object[".gogoproto.enum_stringer_all"] = false;
                    object[".gogoproto.unsafe_marshaler_all"] = false;
                    object[".gogoproto.unsafe_unmarshaler_all"] = false;
                    object[".gogoproto.goproto_extensions_map_all"] = false;
                    object[".gogoproto.goproto_unrecognized_all"] = false;
                    object[".gogoproto.gogoproto_import"] = false;
                    object[".gogoproto.protosizer_all"] = false;
                    object[".gogoproto.compare_all"] = false;
                    object[".gogoproto.typedecl_all"] = false;
                    object[".gogoproto.enumdecl_all"] = false;
                    object[".gogoproto.goproto_registration"] = false;
                }
                if (message.java_package != null && message.hasOwnProperty("java_package"))
                    object.java_package = message.java_package;
                if (message.java_outer_classname != null && message.hasOwnProperty("java_outer_classname"))
                    object.java_outer_classname = message.java_outer_classname;
                if (message.optimize_for != null && message.hasOwnProperty("optimize_for"))
                    object.optimize_for = options.enums === String ? $root.google.protobuf.FileOptions.OptimizeMode[message.optimize_for] : message.optimize_for;
                if (message.java_multiple_files != null && message.hasOwnProperty("java_multiple_files"))
                    object.java_multiple_files = message.java_multiple_files;
                if (message.go_package != null && message.hasOwnProperty("go_package"))
                    object.go_package = message.go_package;
                if (message.cc_generic_services != null && message.hasOwnProperty("cc_generic_services"))
                    object.cc_generic_services = message.cc_generic_services;
                if (message.java_generic_services != null && message.hasOwnProperty("java_generic_services"))
                    object.java_generic_services = message.java_generic_services;
                if (message.py_generic_services != null && message.hasOwnProperty("py_generic_services"))
                    object.py_generic_services = message.py_generic_services;
                if (message.java_generate_equals_and_hash != null && message.hasOwnProperty("java_generate_equals_and_hash"))
                    object.java_generate_equals_and_hash = message.java_generate_equals_and_hash;
                if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                    object.deprecated = message.deprecated;
                if (message.java_string_check_utf8 != null && message.hasOwnProperty("java_string_check_utf8"))
                    object.java_string_check_utf8 = message.java_string_check_utf8;
                if (message.cc_enable_arenas != null && message.hasOwnProperty("cc_enable_arenas"))
                    object.cc_enable_arenas = message.cc_enable_arenas;
                if (message.objc_class_prefix != null && message.hasOwnProperty("objc_class_prefix"))
                    object.objc_class_prefix = message.objc_class_prefix;
                if (message.csharp_namespace != null && message.hasOwnProperty("csharp_namespace"))
                    object.csharp_namespace = message.csharp_namespace;
                if (message.uninterpreted_option && message.uninterpreted_option.length) {
                    object.uninterpreted_option = [];
                    for (let j = 0; j < message.uninterpreted_option.length; ++j)
                        object.uninterpreted_option[j] = $root.google.protobuf.UninterpretedOption.toObject(message.uninterpreted_option[j], options);
                }
                if (message[".gogoproto.goproto_getters_all"] != null && message.hasOwnProperty(".gogoproto.goproto_getters_all"))
                    object[".gogoproto.goproto_getters_all"] = message[".gogoproto.goproto_getters_all"];
                if (message[".gogoproto.goproto_enum_prefix_all"] != null && message.hasOwnProperty(".gogoproto.goproto_enum_prefix_all"))
                    object[".gogoproto.goproto_enum_prefix_all"] = message[".gogoproto.goproto_enum_prefix_all"];
                if (message[".gogoproto.goproto_stringer_all"] != null && message.hasOwnProperty(".gogoproto.goproto_stringer_all"))
                    object[".gogoproto.goproto_stringer_all"] = message[".gogoproto.goproto_stringer_all"];
                if (message[".gogoproto.verbose_equal_all"] != null && message.hasOwnProperty(".gogoproto.verbose_equal_all"))
                    object[".gogoproto.verbose_equal_all"] = message[".gogoproto.verbose_equal_all"];
                if (message[".gogoproto.face_all"] != null && message.hasOwnProperty(".gogoproto.face_all"))
                    object[".gogoproto.face_all"] = message[".gogoproto.face_all"];
                if (message[".gogoproto.gostring_all"] != null && message.hasOwnProperty(".gogoproto.gostring_all"))
                    object[".gogoproto.gostring_all"] = message[".gogoproto.gostring_all"];
                if (message[".gogoproto.populate_all"] != null && message.hasOwnProperty(".gogoproto.populate_all"))
                    object[".gogoproto.populate_all"] = message[".gogoproto.populate_all"];
                if (message[".gogoproto.stringer_all"] != null && message.hasOwnProperty(".gogoproto.stringer_all"))
                    object[".gogoproto.stringer_all"] = message[".gogoproto.stringer_all"];
                if (message[".gogoproto.onlyone_all"] != null && message.hasOwnProperty(".gogoproto.onlyone_all"))
                    object[".gogoproto.onlyone_all"] = message[".gogoproto.onlyone_all"];
                if (message[".gogoproto.equal_all"] != null && message.hasOwnProperty(".gogoproto.equal_all"))
                    object[".gogoproto.equal_all"] = message[".gogoproto.equal_all"];
                if (message[".gogoproto.description_all"] != null && message.hasOwnProperty(".gogoproto.description_all"))
                    object[".gogoproto.description_all"] = message[".gogoproto.description_all"];
                if (message[".gogoproto.testgen_all"] != null && message.hasOwnProperty(".gogoproto.testgen_all"))
                    object[".gogoproto.testgen_all"] = message[".gogoproto.testgen_all"];
                if (message[".gogoproto.benchgen_all"] != null && message.hasOwnProperty(".gogoproto.benchgen_all"))
                    object[".gogoproto.benchgen_all"] = message[".gogoproto.benchgen_all"];
                if (message[".gogoproto.marshaler_all"] != null && message.hasOwnProperty(".gogoproto.marshaler_all"))
                    object[".gogoproto.marshaler_all"] = message[".gogoproto.marshaler_all"];
                if (message[".gogoproto.unmarshaler_all"] != null && message.hasOwnProperty(".gogoproto.unmarshaler_all"))
                    object[".gogoproto.unmarshaler_all"] = message[".gogoproto.unmarshaler_all"];
                if (message[".gogoproto.stable_marshaler_all"] != null && message.hasOwnProperty(".gogoproto.stable_marshaler_all"))
                    object[".gogoproto.stable_marshaler_all"] = message[".gogoproto.stable_marshaler_all"];
                if (message[".gogoproto.sizer_all"] != null && message.hasOwnProperty(".gogoproto.sizer_all"))
                    object[".gogoproto.sizer_all"] = message[".gogoproto.sizer_all"];
                if (message[".gogoproto.goproto_enum_stringer_all"] != null && message.hasOwnProperty(".gogoproto.goproto_enum_stringer_all"))
                    object[".gogoproto.goproto_enum_stringer_all"] = message[".gogoproto.goproto_enum_stringer_all"];
                if (message[".gogoproto.enum_stringer_all"] != null && message.hasOwnProperty(".gogoproto.enum_stringer_all"))
                    object[".gogoproto.enum_stringer_all"] = message[".gogoproto.enum_stringer_all"];
                if (message[".gogoproto.unsafe_marshaler_all"] != null && message.hasOwnProperty(".gogoproto.unsafe_marshaler_all"))
                    object[".gogoproto.unsafe_marshaler_all"] = message[".gogoproto.unsafe_marshaler_all"];
                if (message[".gogoproto.unsafe_unmarshaler_all"] != null && message.hasOwnProperty(".gogoproto.unsafe_unmarshaler_all"))
                    object[".gogoproto.unsafe_unmarshaler_all"] = message[".gogoproto.unsafe_unmarshaler_all"];
                if (message[".gogoproto.goproto_extensions_map_all"] != null && message.hasOwnProperty(".gogoproto.goproto_extensions_map_all"))
                    object[".gogoproto.goproto_extensions_map_all"] = message[".gogoproto.goproto_extensions_map_all"];
                if (message[".gogoproto.goproto_unrecognized_all"] != null && message.hasOwnProperty(".gogoproto.goproto_unrecognized_all"))
                    object[".gogoproto.goproto_unrecognized_all"] = message[".gogoproto.goproto_unrecognized_all"];
                if (message[".gogoproto.gogoproto_import"] != null && message.hasOwnProperty(".gogoproto.gogoproto_import"))
                    object[".gogoproto.gogoproto_import"] = message[".gogoproto.gogoproto_import"];
                if (message[".gogoproto.protosizer_all"] != null && message.hasOwnProperty(".gogoproto.protosizer_all"))
                    object[".gogoproto.protosizer_all"] = message[".gogoproto.protosizer_all"];
                if (message[".gogoproto.compare_all"] != null && message.hasOwnProperty(".gogoproto.compare_all"))
                    object[".gogoproto.compare_all"] = message[".gogoproto.compare_all"];
                if (message[".gogoproto.typedecl_all"] != null && message.hasOwnProperty(".gogoproto.typedecl_all"))
                    object[".gogoproto.typedecl_all"] = message[".gogoproto.typedecl_all"];
                if (message[".gogoproto.enumdecl_all"] != null && message.hasOwnProperty(".gogoproto.enumdecl_all"))
                    object[".gogoproto.enumdecl_all"] = message[".gogoproto.enumdecl_all"];
                if (message[".gogoproto.goproto_registration"] != null && message.hasOwnProperty(".gogoproto.goproto_registration"))
                    object[".gogoproto.goproto_registration"] = message[".gogoproto.goproto_registration"];
                return object;
            };

            /**
             * Creates a plain object from this FileOptions message. Also converts values to other types if specified.
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            FileOptions.prototype.toObject = function toObject(options) {
                return this.constructor.toObject(this, options);
            };

            /**
             * Converts this FileOptions to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            FileOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * OptimizeMode enum.
             * @name OptimizeMode
             * @memberof google.protobuf.FileOptions
             * @enum {number}
             * @property {number} SPEED=1 SPEED value
             * @property {number} CODE_SIZE=2 CODE_SIZE value
             * @property {number} LITE_RUNTIME=3 LITE_RUNTIME value
             */
            FileOptions.OptimizeMode = (function() {
                const valuesById = {}, values = Object.create(valuesById);
                values[valuesById[1] = "SPEED"] = 1;
                values[valuesById[2] = "CODE_SIZE"] = 2;
                values[valuesById[3] = "LITE_RUNTIME"] = 3;
                return values;
            })();

            return FileOptions;
        })();

        protobuf.MessageOptions = (function() {

            /**
             * Properties of a MessageOptions.
             * @typedef google.protobuf.MessageOptions$Properties
             * @type {Object}
             * @property {boolean} [message_set_wire_format] MessageOptions message_set_wire_format.
             * @property {boolean} [no_standard_descriptor_accessor] MessageOptions no_standard_descriptor_accessor.
             * @property {boolean} [deprecated] MessageOptions deprecated.
             * @property {boolean} [map_entry] MessageOptions map_entry.
             * @property {Array.<google.protobuf.UninterpretedOption$Properties>} [uninterpreted_option] MessageOptions uninterpreted_option.
             * @property {boolean} [".gogoproto.goproto_getters"] MessageOptions .gogoproto.goproto_getters.
             * @property {boolean} [".gogoproto.goproto_stringer"] MessageOptions .gogoproto.goproto_stringer.
             * @property {boolean} [".gogoproto.verbose_equal"] MessageOptions .gogoproto.verbose_equal.
             * @property {boolean} [".gogoproto.face"] MessageOptions .gogoproto.face.
             * @property {boolean} [".gogoproto.gostring"] MessageOptions .gogoproto.gostring.
             * @property {boolean} [".gogoproto.populate"] MessageOptions .gogoproto.populate.
             * @property {boolean} [".gogoproto.stringer"] MessageOptions .gogoproto.stringer.
             * @property {boolean} [".gogoproto.onlyone"] MessageOptions .gogoproto.onlyone.
             * @property {boolean} [".gogoproto.equal"] MessageOptions .gogoproto.equal.
             * @property {boolean} [".gogoproto.description"] MessageOptions .gogoproto.description.
             * @property {boolean} [".gogoproto.testgen"] MessageOptions .gogoproto.testgen.
             * @property {boolean} [".gogoproto.benchgen"] MessageOptions .gogoproto.benchgen.
             * @property {boolean} [".gogoproto.marshaler"] MessageOptions .gogoproto.marshaler.
             * @property {boolean} [".gogoproto.unmarshaler"] MessageOptions .gogoproto.unmarshaler.
             * @property {boolean} [".gogoproto.stable_marshaler"] MessageOptions .gogoproto.stable_marshaler.
             * @property {boolean} [".gogoproto.sizer"] MessageOptions .gogoproto.sizer.
             * @property {boolean} [".gogoproto.unsafe_marshaler"] MessageOptions .gogoproto.unsafe_marshaler.
             * @property {boolean} [".gogoproto.unsafe_unmarshaler"] MessageOptions .gogoproto.unsafe_unmarshaler.
             * @property {boolean} [".gogoproto.goproto_extensions_map"] MessageOptions .gogoproto.goproto_extensions_map.
             * @property {boolean} [".gogoproto.goproto_unrecognized"] MessageOptions .gogoproto.goproto_unrecognized.
             * @property {boolean} [".gogoproto.protosizer"] MessageOptions .gogoproto.protosizer.
             * @property {boolean} [".gogoproto.compare"] MessageOptions .gogoproto.compare.
             * @property {boolean} [".gogoproto.typedecl"] MessageOptions .gogoproto.typedecl.
             */

            /**
             * Constructs a new MessageOptions.
             * @exports google.protobuf.MessageOptions
             * @constructor
             * @param {google.protobuf.MessageOptions$Properties=} [properties] Properties to set
             */
            function MessageOptions(properties) {
                this.uninterpreted_option = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * MessageOptions message_set_wire_format.
             * @type {boolean}
             */
            MessageOptions.prototype.message_set_wire_format = false;

            /**
             * MessageOptions no_standard_descriptor_accessor.
             * @type {boolean}
             */
            MessageOptions.prototype.no_standard_descriptor_accessor = false;

            /**
             * MessageOptions deprecated.
             * @type {boolean}
             */
            MessageOptions.prototype.deprecated = false;

            /**
             * MessageOptions map_entry.
             * @type {boolean}
             */
            MessageOptions.prototype.map_entry = false;

            /**
             * MessageOptions uninterpreted_option.
             * @type {Array.<google.protobuf.UninterpretedOption$Properties>}
             */
            MessageOptions.prototype.uninterpreted_option = $util.emptyArray;

            /**
             * MessageOptions .gogoproto.goproto_getters.
             * @type {boolean}
             */
            MessageOptions.prototype[".gogoproto.goproto_getters"] = false;

            /**
             * MessageOptions .gogoproto.goproto_stringer.
             * @type {boolean}
             */
            MessageOptions.prototype[".gogoproto.goproto_stringer"] = false;

            /**
             * MessageOptions .gogoproto.verbose_equal.
             * @type {boolean}
             */
            MessageOptions.prototype[".gogoproto.verbose_equal"] = false;

            /**
             * MessageOptions .gogoproto.face.
             * @type {boolean}
             */
            MessageOptions.prototype[".gogoproto.face"] = false;

            /**
             * MessageOptions .gogoproto.gostring.
             * @type {boolean}
             */
            MessageOptions.prototype[".gogoproto.gostring"] = false;

            /**
             * MessageOptions .gogoproto.populate.
             * @type {boolean}
             */
            MessageOptions.prototype[".gogoproto.populate"] = false;

            /**
             * MessageOptions .gogoproto.stringer.
             * @type {boolean}
             */
            MessageOptions.prototype[".gogoproto.stringer"] = false;

            /**
             * MessageOptions .gogoproto.onlyone.
             * @type {boolean}
             */
            MessageOptions.prototype[".gogoproto.onlyone"] = false;

            /**
             * MessageOptions .gogoproto.equal.
             * @type {boolean}
             */
            MessageOptions.prototype[".gogoproto.equal"] = false;

            /**
             * MessageOptions .gogoproto.description.
             * @type {boolean}
             */
            MessageOptions.prototype[".gogoproto.description"] = false;

            /**
             * MessageOptions .gogoproto.testgen.
             * @type {boolean}
             */
            MessageOptions.prototype[".gogoproto.testgen"] = false;

            /**
             * MessageOptions .gogoproto.benchgen.
             * @type {boolean}
             */
            MessageOptions.prototype[".gogoproto.benchgen"] = false;

            /**
             * MessageOptions .gogoproto.marshaler.
             * @type {boolean}
             */
            MessageOptions.prototype[".gogoproto.marshaler"] = false;

            /**
             * MessageOptions .gogoproto.unmarshaler.
             * @type {boolean}
             */
            MessageOptions.prototype[".gogoproto.unmarshaler"] = false;

            /**
             * MessageOptions .gogoproto.stable_marshaler.
             * @type {boolean}
             */
            MessageOptions.prototype[".gogoproto.stable_marshaler"] = false;

            /**
             * MessageOptions .gogoproto.sizer.
             * @type {boolean}
             */
            MessageOptions.prototype[".gogoproto.sizer"] = false;

            /**
             * MessageOptions .gogoproto.unsafe_marshaler.
             * @type {boolean}
             */
            MessageOptions.prototype[".gogoproto.unsafe_marshaler"] = false;

            /**
             * MessageOptions .gogoproto.unsafe_unmarshaler.
             * @type {boolean}
             */
            MessageOptions.prototype[".gogoproto.unsafe_unmarshaler"] = false;

            /**
             * MessageOptions .gogoproto.goproto_extensions_map.
             * @type {boolean}
             */
            MessageOptions.prototype[".gogoproto.goproto_extensions_map"] = false;

            /**
             * MessageOptions .gogoproto.goproto_unrecognized.
             * @type {boolean}
             */
            MessageOptions.prototype[".gogoproto.goproto_unrecognized"] = false;

            /**
             * MessageOptions .gogoproto.protosizer.
             * @type {boolean}
             */
            MessageOptions.prototype[".gogoproto.protosizer"] = false;

            /**
             * MessageOptions .gogoproto.compare.
             * @type {boolean}
             */
            MessageOptions.prototype[".gogoproto.compare"] = false;

            /**
             * MessageOptions .gogoproto.typedecl.
             * @type {boolean}
             */
            MessageOptions.prototype[".gogoproto.typedecl"] = false;

            /**
             * Creates a new MessageOptions instance using the specified properties.
             * @param {google.protobuf.MessageOptions$Properties=} [properties] Properties to set
             * @returns {google.protobuf.MessageOptions} MessageOptions instance
             */
            MessageOptions.create = function create(properties) {
                return new MessageOptions(properties);
            };

            /**
             * Encodes the specified MessageOptions message. Does not implicitly {@link google.protobuf.MessageOptions.verify|verify} messages.
             * @param {google.protobuf.MessageOptions$Properties} message MessageOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MessageOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.message_set_wire_format != null && message.hasOwnProperty("message_set_wire_format"))
                    writer.uint32(/* id 1, wireType 0 =*/8).bool(message.message_set_wire_format);
                if (message.no_standard_descriptor_accessor != null && message.hasOwnProperty("no_standard_descriptor_accessor"))
                    writer.uint32(/* id 2, wireType 0 =*/16).bool(message.no_standard_descriptor_accessor);
                if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                    writer.uint32(/* id 3, wireType 0 =*/24).bool(message.deprecated);
                if (message.map_entry != null && message.hasOwnProperty("map_entry"))
                    writer.uint32(/* id 7, wireType 0 =*/56).bool(message.map_entry);
                if (message.uninterpreted_option != null && message.uninterpreted_option.length)
                    for (let i = 0; i < message.uninterpreted_option.length; ++i)
                        $root.google.protobuf.UninterpretedOption.encode(message.uninterpreted_option[i], writer.uint32(/* id 999, wireType 2 =*/7994).fork()).ldelim();
                if (message[".gogoproto.goproto_getters"] != null && message.hasOwnProperty(".gogoproto.goproto_getters"))
                    writer.uint32(/* id 64001, wireType 0 =*/512008).bool(message[".gogoproto.goproto_getters"]);
                if (message[".gogoproto.goproto_stringer"] != null && message.hasOwnProperty(".gogoproto.goproto_stringer"))
                    writer.uint32(/* id 64003, wireType 0 =*/512024).bool(message[".gogoproto.goproto_stringer"]);
                if (message[".gogoproto.verbose_equal"] != null && message.hasOwnProperty(".gogoproto.verbose_equal"))
                    writer.uint32(/* id 64004, wireType 0 =*/512032).bool(message[".gogoproto.verbose_equal"]);
                if (message[".gogoproto.face"] != null && message.hasOwnProperty(".gogoproto.face"))
                    writer.uint32(/* id 64005, wireType 0 =*/512040).bool(message[".gogoproto.face"]);
                if (message[".gogoproto.gostring"] != null && message.hasOwnProperty(".gogoproto.gostring"))
                    writer.uint32(/* id 64006, wireType 0 =*/512048).bool(message[".gogoproto.gostring"]);
                if (message[".gogoproto.populate"] != null && message.hasOwnProperty(".gogoproto.populate"))
                    writer.uint32(/* id 64007, wireType 0 =*/512056).bool(message[".gogoproto.populate"]);
                if (message[".gogoproto.onlyone"] != null && message.hasOwnProperty(".gogoproto.onlyone"))
                    writer.uint32(/* id 64009, wireType 0 =*/512072).bool(message[".gogoproto.onlyone"]);
                if (message[".gogoproto.equal"] != null && message.hasOwnProperty(".gogoproto.equal"))
                    writer.uint32(/* id 64013, wireType 0 =*/512104).bool(message[".gogoproto.equal"]);
                if (message[".gogoproto.description"] != null && message.hasOwnProperty(".gogoproto.description"))
                    writer.uint32(/* id 64014, wireType 0 =*/512112).bool(message[".gogoproto.description"]);
                if (message[".gogoproto.testgen"] != null && message.hasOwnProperty(".gogoproto.testgen"))
                    writer.uint32(/* id 64015, wireType 0 =*/512120).bool(message[".gogoproto.testgen"]);
                if (message[".gogoproto.benchgen"] != null && message.hasOwnProperty(".gogoproto.benchgen"))
                    writer.uint32(/* id 64016, wireType 0 =*/512128).bool(message[".gogoproto.benchgen"]);
                if (message[".gogoproto.marshaler"] != null && message.hasOwnProperty(".gogoproto.marshaler"))
                    writer.uint32(/* id 64017, wireType 0 =*/512136).bool(message[".gogoproto.marshaler"]);
                if (message[".gogoproto.unmarshaler"] != null && message.hasOwnProperty(".gogoproto.unmarshaler"))
                    writer.uint32(/* id 64018, wireType 0 =*/512144).bool(message[".gogoproto.unmarshaler"]);
                if (message[".gogoproto.stable_marshaler"] != null && message.hasOwnProperty(".gogoproto.stable_marshaler"))
                    writer.uint32(/* id 64019, wireType 0 =*/512152).bool(message[".gogoproto.stable_marshaler"]);
                if (message[".gogoproto.sizer"] != null && message.hasOwnProperty(".gogoproto.sizer"))
                    writer.uint32(/* id 64020, wireType 0 =*/512160).bool(message[".gogoproto.sizer"]);
                if (message[".gogoproto.unsafe_marshaler"] != null && message.hasOwnProperty(".gogoproto.unsafe_marshaler"))
                    writer.uint32(/* id 64023, wireType 0 =*/512184).bool(message[".gogoproto.unsafe_marshaler"]);
                if (message[".gogoproto.unsafe_unmarshaler"] != null && message.hasOwnProperty(".gogoproto.unsafe_unmarshaler"))
                    writer.uint32(/* id 64024, wireType 0 =*/512192).bool(message[".gogoproto.unsafe_unmarshaler"]);
                if (message[".gogoproto.goproto_extensions_map"] != null && message.hasOwnProperty(".gogoproto.goproto_extensions_map"))
                    writer.uint32(/* id 64025, wireType 0 =*/512200).bool(message[".gogoproto.goproto_extensions_map"]);
                if (message[".gogoproto.goproto_unrecognized"] != null && message.hasOwnProperty(".gogoproto.goproto_unrecognized"))
                    writer.uint32(/* id 64026, wireType 0 =*/512208).bool(message[".gogoproto.goproto_unrecognized"]);
                if (message[".gogoproto.protosizer"] != null && message.hasOwnProperty(".gogoproto.protosizer"))
                    writer.uint32(/* id 64028, wireType 0 =*/512224).bool(message[".gogoproto.protosizer"]);
                if (message[".gogoproto.compare"] != null && message.hasOwnProperty(".gogoproto.compare"))
                    writer.uint32(/* id 64029, wireType 0 =*/512232).bool(message[".gogoproto.compare"]);
                if (message[".gogoproto.typedecl"] != null && message.hasOwnProperty(".gogoproto.typedecl"))
                    writer.uint32(/* id 64030, wireType 0 =*/512240).bool(message[".gogoproto.typedecl"]);
                if (message[".gogoproto.stringer"] != null && message.hasOwnProperty(".gogoproto.stringer"))
                    writer.uint32(/* id 67008, wireType 0 =*/536064).bool(message[".gogoproto.stringer"]);
                return writer;
            };

            /**
             * Encodes the specified MessageOptions message, length delimited. Does not implicitly {@link google.protobuf.MessageOptions.verify|verify} messages.
             * @param {google.protobuf.MessageOptions$Properties} message MessageOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MessageOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a MessageOptions message from the specified reader or buffer.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.MessageOptions} MessageOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MessageOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.MessageOptions();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.message_set_wire_format = reader.bool();
                        break;
                    case 2:
                        message.no_standard_descriptor_accessor = reader.bool();
                        break;
                    case 3:
                        message.deprecated = reader.bool();
                        break;
                    case 7:
                        message.map_entry = reader.bool();
                        break;
                    case 999:
                        if (!(message.uninterpreted_option && message.uninterpreted_option.length))
                            message.uninterpreted_option = [];
                        message.uninterpreted_option.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));
                        break;
                    case 64001:
                        message[".gogoproto.goproto_getters"] = reader.bool();
                        break;
                    case 64003:
                        message[".gogoproto.goproto_stringer"] = reader.bool();
                        break;
                    case 64004:
                        message[".gogoproto.verbose_equal"] = reader.bool();
                        break;
                    case 64005:
                        message[".gogoproto.face"] = reader.bool();
                        break;
                    case 64006:
                        message[".gogoproto.gostring"] = reader.bool();
                        break;
                    case 64007:
                        message[".gogoproto.populate"] = reader.bool();
                        break;
                    case 67008:
                        message[".gogoproto.stringer"] = reader.bool();
                        break;
                    case 64009:
                        message[".gogoproto.onlyone"] = reader.bool();
                        break;
                    case 64013:
                        message[".gogoproto.equal"] = reader.bool();
                        break;
                    case 64014:
                        message[".gogoproto.description"] = reader.bool();
                        break;
                    case 64015:
                        message[".gogoproto.testgen"] = reader.bool();
                        break;
                    case 64016:
                        message[".gogoproto.benchgen"] = reader.bool();
                        break;
                    case 64017:
                        message[".gogoproto.marshaler"] = reader.bool();
                        break;
                    case 64018:
                        message[".gogoproto.unmarshaler"] = reader.bool();
                        break;
                    case 64019:
                        message[".gogoproto.stable_marshaler"] = reader.bool();
                        break;
                    case 64020:
                        message[".gogoproto.sizer"] = reader.bool();
                        break;
                    case 64023:
                        message[".gogoproto.unsafe_marshaler"] = reader.bool();
                        break;
                    case 64024:
                        message[".gogoproto.unsafe_unmarshaler"] = reader.bool();
                        break;
                    case 64025:
                        message[".gogoproto.goproto_extensions_map"] = reader.bool();
                        break;
                    case 64026:
                        message[".gogoproto.goproto_unrecognized"] = reader.bool();
                        break;
                    case 64028:
                        message[".gogoproto.protosizer"] = reader.bool();
                        break;
                    case 64029:
                        message[".gogoproto.compare"] = reader.bool();
                        break;
                    case 64030:
                        message[".gogoproto.typedecl"] = reader.bool();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a MessageOptions message from the specified reader or buffer, length delimited.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.MessageOptions} MessageOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MessageOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a MessageOptions message.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            MessageOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.message_set_wire_format != null && message.hasOwnProperty("message_set_wire_format"))
                    if (typeof message.message_set_wire_format !== "boolean")
                        return "message_set_wire_format: boolean expected";
                if (message.no_standard_descriptor_accessor != null && message.hasOwnProperty("no_standard_descriptor_accessor"))
                    if (typeof message.no_standard_descriptor_accessor !== "boolean")
                        return "no_standard_descriptor_accessor: boolean expected";
                if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                    if (typeof message.deprecated !== "boolean")
                        return "deprecated: boolean expected";
                if (message.map_entry != null && message.hasOwnProperty("map_entry"))
                    if (typeof message.map_entry !== "boolean")
                        return "map_entry: boolean expected";
                if (message.uninterpreted_option != null && message.hasOwnProperty("uninterpreted_option")) {
                    if (!Array.isArray(message.uninterpreted_option))
                        return "uninterpreted_option: array expected";
                    for (let i = 0; i < message.uninterpreted_option.length; ++i) {
                        let error = $root.google.protobuf.UninterpretedOption.verify(message.uninterpreted_option[i]);
                        if (error)
                            return "uninterpreted_option." + error;
                    }
                }
                if (message[".gogoproto.goproto_getters"] != null && message.hasOwnProperty(".gogoproto.goproto_getters"))
                    if (typeof message[".gogoproto.goproto_getters"] !== "boolean")
                        return ".gogoproto.goproto_getters: boolean expected";
                if (message[".gogoproto.goproto_stringer"] != null && message.hasOwnProperty(".gogoproto.goproto_stringer"))
                    if (typeof message[".gogoproto.goproto_stringer"] !== "boolean")
                        return ".gogoproto.goproto_stringer: boolean expected";
                if (message[".gogoproto.verbose_equal"] != null && message.hasOwnProperty(".gogoproto.verbose_equal"))
                    if (typeof message[".gogoproto.verbose_equal"] !== "boolean")
                        return ".gogoproto.verbose_equal: boolean expected";
                if (message[".gogoproto.face"] != null && message.hasOwnProperty(".gogoproto.face"))
                    if (typeof message[".gogoproto.face"] !== "boolean")
                        return ".gogoproto.face: boolean expected";
                if (message[".gogoproto.gostring"] != null && message.hasOwnProperty(".gogoproto.gostring"))
                    if (typeof message[".gogoproto.gostring"] !== "boolean")
                        return ".gogoproto.gostring: boolean expected";
                if (message[".gogoproto.populate"] != null && message.hasOwnProperty(".gogoproto.populate"))
                    if (typeof message[".gogoproto.populate"] !== "boolean")
                        return ".gogoproto.populate: boolean expected";
                if (message[".gogoproto.stringer"] != null && message.hasOwnProperty(".gogoproto.stringer"))
                    if (typeof message[".gogoproto.stringer"] !== "boolean")
                        return ".gogoproto.stringer: boolean expected";
                if (message[".gogoproto.onlyone"] != null && message.hasOwnProperty(".gogoproto.onlyone"))
                    if (typeof message[".gogoproto.onlyone"] !== "boolean")
                        return ".gogoproto.onlyone: boolean expected";
                if (message[".gogoproto.equal"] != null && message.hasOwnProperty(".gogoproto.equal"))
                    if (typeof message[".gogoproto.equal"] !== "boolean")
                        return ".gogoproto.equal: boolean expected";
                if (message[".gogoproto.description"] != null && message.hasOwnProperty(".gogoproto.description"))
                    if (typeof message[".gogoproto.description"] !== "boolean")
                        return ".gogoproto.description: boolean expected";
                if (message[".gogoproto.testgen"] != null && message.hasOwnProperty(".gogoproto.testgen"))
                    if (typeof message[".gogoproto.testgen"] !== "boolean")
                        return ".gogoproto.testgen: boolean expected";
                if (message[".gogoproto.benchgen"] != null && message.hasOwnProperty(".gogoproto.benchgen"))
                    if (typeof message[".gogoproto.benchgen"] !== "boolean")
                        return ".gogoproto.benchgen: boolean expected";
                if (message[".gogoproto.marshaler"] != null && message.hasOwnProperty(".gogoproto.marshaler"))
                    if (typeof message[".gogoproto.marshaler"] !== "boolean")
                        return ".gogoproto.marshaler: boolean expected";
                if (message[".gogoproto.unmarshaler"] != null && message.hasOwnProperty(".gogoproto.unmarshaler"))
                    if (typeof message[".gogoproto.unmarshaler"] !== "boolean")
                        return ".gogoproto.unmarshaler: boolean expected";
                if (message[".gogoproto.stable_marshaler"] != null && message.hasOwnProperty(".gogoproto.stable_marshaler"))
                    if (typeof message[".gogoproto.stable_marshaler"] !== "boolean")
                        return ".gogoproto.stable_marshaler: boolean expected";
                if (message[".gogoproto.sizer"] != null && message.hasOwnProperty(".gogoproto.sizer"))
                    if (typeof message[".gogoproto.sizer"] !== "boolean")
                        return ".gogoproto.sizer: boolean expected";
                if (message[".gogoproto.unsafe_marshaler"] != null && message.hasOwnProperty(".gogoproto.unsafe_marshaler"))
                    if (typeof message[".gogoproto.unsafe_marshaler"] !== "boolean")
                        return ".gogoproto.unsafe_marshaler: boolean expected";
                if (message[".gogoproto.unsafe_unmarshaler"] != null && message.hasOwnProperty(".gogoproto.unsafe_unmarshaler"))
                    if (typeof message[".gogoproto.unsafe_unmarshaler"] !== "boolean")
                        return ".gogoproto.unsafe_unmarshaler: boolean expected";
                if (message[".gogoproto.goproto_extensions_map"] != null && message.hasOwnProperty(".gogoproto.goproto_extensions_map"))
                    if (typeof message[".gogoproto.goproto_extensions_map"] !== "boolean")
                        return ".gogoproto.goproto_extensions_map: boolean expected";
                if (message[".gogoproto.goproto_unrecognized"] != null && message.hasOwnProperty(".gogoproto.goproto_unrecognized"))
                    if (typeof message[".gogoproto.goproto_unrecognized"] !== "boolean")
                        return ".gogoproto.goproto_unrecognized: boolean expected";
                if (message[".gogoproto.protosizer"] != null && message.hasOwnProperty(".gogoproto.protosizer"))
                    if (typeof message[".gogoproto.protosizer"] !== "boolean")
                        return ".gogoproto.protosizer: boolean expected";
                if (message[".gogoproto.compare"] != null && message.hasOwnProperty(".gogoproto.compare"))
                    if (typeof message[".gogoproto.compare"] !== "boolean")
                        return ".gogoproto.compare: boolean expected";
                if (message[".gogoproto.typedecl"] != null && message.hasOwnProperty(".gogoproto.typedecl"))
                    if (typeof message[".gogoproto.typedecl"] !== "boolean")
                        return ".gogoproto.typedecl: boolean expected";
                return null;
            };

            /**
             * Creates a MessageOptions message from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.MessageOptions} MessageOptions
             */
            MessageOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.MessageOptions)
                    return object;
                let message = new $root.google.protobuf.MessageOptions();
                if (object.message_set_wire_format != null)
                    message.message_set_wire_format = Boolean(object.message_set_wire_format);
                if (object.no_standard_descriptor_accessor != null)
                    message.no_standard_descriptor_accessor = Boolean(object.no_standard_descriptor_accessor);
                if (object.deprecated != null)
                    message.deprecated = Boolean(object.deprecated);
                if (object.map_entry != null)
                    message.map_entry = Boolean(object.map_entry);
                if (object.uninterpreted_option) {
                    if (!Array.isArray(object.uninterpreted_option))
                        throw TypeError(".google.protobuf.MessageOptions.uninterpreted_option: array expected");
                    message.uninterpreted_option = [];
                    for (let i = 0; i < object.uninterpreted_option.length; ++i) {
                        if (typeof object.uninterpreted_option[i] !== "object")
                            throw TypeError(".google.protobuf.MessageOptions.uninterpreted_option: object expected");
                        message.uninterpreted_option[i] = $root.google.protobuf.UninterpretedOption.fromObject(object.uninterpreted_option[i]);
                    }
                }
                if (object[".gogoproto.goproto_getters"] != null)
                    message[".gogoproto.goproto_getters"] = Boolean(object[".gogoproto.goproto_getters"]);
                if (object[".gogoproto.goproto_stringer"] != null)
                    message[".gogoproto.goproto_stringer"] = Boolean(object[".gogoproto.goproto_stringer"]);
                if (object[".gogoproto.verbose_equal"] != null)
                    message[".gogoproto.verbose_equal"] = Boolean(object[".gogoproto.verbose_equal"]);
                if (object[".gogoproto.face"] != null)
                    message[".gogoproto.face"] = Boolean(object[".gogoproto.face"]);
                if (object[".gogoproto.gostring"] != null)
                    message[".gogoproto.gostring"] = Boolean(object[".gogoproto.gostring"]);
                if (object[".gogoproto.populate"] != null)
                    message[".gogoproto.populate"] = Boolean(object[".gogoproto.populate"]);
                if (object[".gogoproto.stringer"] != null)
                    message[".gogoproto.stringer"] = Boolean(object[".gogoproto.stringer"]);
                if (object[".gogoproto.onlyone"] != null)
                    message[".gogoproto.onlyone"] = Boolean(object[".gogoproto.onlyone"]);
                if (object[".gogoproto.equal"] != null)
                    message[".gogoproto.equal"] = Boolean(object[".gogoproto.equal"]);
                if (object[".gogoproto.description"] != null)
                    message[".gogoproto.description"] = Boolean(object[".gogoproto.description"]);
                if (object[".gogoproto.testgen"] != null)
                    message[".gogoproto.testgen"] = Boolean(object[".gogoproto.testgen"]);
                if (object[".gogoproto.benchgen"] != null)
                    message[".gogoproto.benchgen"] = Boolean(object[".gogoproto.benchgen"]);
                if (object[".gogoproto.marshaler"] != null)
                    message[".gogoproto.marshaler"] = Boolean(object[".gogoproto.marshaler"]);
                if (object[".gogoproto.unmarshaler"] != null)
                    message[".gogoproto.unmarshaler"] = Boolean(object[".gogoproto.unmarshaler"]);
                if (object[".gogoproto.stable_marshaler"] != null)
                    message[".gogoproto.stable_marshaler"] = Boolean(object[".gogoproto.stable_marshaler"]);
                if (object[".gogoproto.sizer"] != null)
                    message[".gogoproto.sizer"] = Boolean(object[".gogoproto.sizer"]);
                if (object[".gogoproto.unsafe_marshaler"] != null)
                    message[".gogoproto.unsafe_marshaler"] = Boolean(object[".gogoproto.unsafe_marshaler"]);
                if (object[".gogoproto.unsafe_unmarshaler"] != null)
                    message[".gogoproto.unsafe_unmarshaler"] = Boolean(object[".gogoproto.unsafe_unmarshaler"]);
                if (object[".gogoproto.goproto_extensions_map"] != null)
                    message[".gogoproto.goproto_extensions_map"] = Boolean(object[".gogoproto.goproto_extensions_map"]);
                if (object[".gogoproto.goproto_unrecognized"] != null)
                    message[".gogoproto.goproto_unrecognized"] = Boolean(object[".gogoproto.goproto_unrecognized"]);
                if (object[".gogoproto.protosizer"] != null)
                    message[".gogoproto.protosizer"] = Boolean(object[".gogoproto.protosizer"]);
                if (object[".gogoproto.compare"] != null)
                    message[".gogoproto.compare"] = Boolean(object[".gogoproto.compare"]);
                if (object[".gogoproto.typedecl"] != null)
                    message[".gogoproto.typedecl"] = Boolean(object[".gogoproto.typedecl"]);
                return message;
            };

            /**
             * Creates a MessageOptions message from a plain object. Also converts values to their respective internal types.
             * This is an alias of {@link google.protobuf.MessageOptions.fromObject}.
             * @function
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.MessageOptions} MessageOptions
             */
            MessageOptions.from = MessageOptions.fromObject;

            /**
             * Creates a plain object from a MessageOptions message. Also converts values to other types if specified.
             * @param {google.protobuf.MessageOptions} message MessageOptions
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            MessageOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.uninterpreted_option = [];
                if (options.defaults) {
                    object.message_set_wire_format = false;
                    object.no_standard_descriptor_accessor = false;
                    object.deprecated = false;
                    object.map_entry = false;
                    object[".gogoproto.goproto_getters"] = false;
                    object[".gogoproto.goproto_stringer"] = false;
                    object[".gogoproto.verbose_equal"] = false;
                    object[".gogoproto.face"] = false;
                    object[".gogoproto.gostring"] = false;
                    object[".gogoproto.populate"] = false;
                    object[".gogoproto.onlyone"] = false;
                    object[".gogoproto.equal"] = false;
                    object[".gogoproto.description"] = false;
                    object[".gogoproto.testgen"] = false;
                    object[".gogoproto.benchgen"] = false;
                    object[".gogoproto.marshaler"] = false;
                    object[".gogoproto.unmarshaler"] = false;
                    object[".gogoproto.stable_marshaler"] = false;
                    object[".gogoproto.sizer"] = false;
                    object[".gogoproto.unsafe_marshaler"] = false;
                    object[".gogoproto.unsafe_unmarshaler"] = false;
                    object[".gogoproto.goproto_extensions_map"] = false;
                    object[".gogoproto.goproto_unrecognized"] = false;
                    object[".gogoproto.protosizer"] = false;
                    object[".gogoproto.compare"] = false;
                    object[".gogoproto.typedecl"] = false;
                    object[".gogoproto.stringer"] = false;
                }
                if (message.message_set_wire_format != null && message.hasOwnProperty("message_set_wire_format"))
                    object.message_set_wire_format = message.message_set_wire_format;
                if (message.no_standard_descriptor_accessor != null && message.hasOwnProperty("no_standard_descriptor_accessor"))
                    object.no_standard_descriptor_accessor = message.no_standard_descriptor_accessor;
                if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                    object.deprecated = message.deprecated;
                if (message.map_entry != null && message.hasOwnProperty("map_entry"))
                    object.map_entry = message.map_entry;
                if (message.uninterpreted_option && message.uninterpreted_option.length) {
                    object.uninterpreted_option = [];
                    for (let j = 0; j < message.uninterpreted_option.length; ++j)
                        object.uninterpreted_option[j] = $root.google.protobuf.UninterpretedOption.toObject(message.uninterpreted_option[j], options);
                }
                if (message[".gogoproto.goproto_getters"] != null && message.hasOwnProperty(".gogoproto.goproto_getters"))
                    object[".gogoproto.goproto_getters"] = message[".gogoproto.goproto_getters"];
                if (message[".gogoproto.goproto_stringer"] != null && message.hasOwnProperty(".gogoproto.goproto_stringer"))
                    object[".gogoproto.goproto_stringer"] = message[".gogoproto.goproto_stringer"];
                if (message[".gogoproto.verbose_equal"] != null && message.hasOwnProperty(".gogoproto.verbose_equal"))
                    object[".gogoproto.verbose_equal"] = message[".gogoproto.verbose_equal"];
                if (message[".gogoproto.face"] != null && message.hasOwnProperty(".gogoproto.face"))
                    object[".gogoproto.face"] = message[".gogoproto.face"];
                if (message[".gogoproto.gostring"] != null && message.hasOwnProperty(".gogoproto.gostring"))
                    object[".gogoproto.gostring"] = message[".gogoproto.gostring"];
                if (message[".gogoproto.populate"] != null && message.hasOwnProperty(".gogoproto.populate"))
                    object[".gogoproto.populate"] = message[".gogoproto.populate"];
                if (message[".gogoproto.onlyone"] != null && message.hasOwnProperty(".gogoproto.onlyone"))
                    object[".gogoproto.onlyone"] = message[".gogoproto.onlyone"];
                if (message[".gogoproto.equal"] != null && message.hasOwnProperty(".gogoproto.equal"))
                    object[".gogoproto.equal"] = message[".gogoproto.equal"];
                if (message[".gogoproto.description"] != null && message.hasOwnProperty(".gogoproto.description"))
                    object[".gogoproto.description"] = message[".gogoproto.description"];
                if (message[".gogoproto.testgen"] != null && message.hasOwnProperty(".gogoproto.testgen"))
                    object[".gogoproto.testgen"] = message[".gogoproto.testgen"];
                if (message[".gogoproto.benchgen"] != null && message.hasOwnProperty(".gogoproto.benchgen"))
                    object[".gogoproto.benchgen"] = message[".gogoproto.benchgen"];
                if (message[".gogoproto.marshaler"] != null && message.hasOwnProperty(".gogoproto.marshaler"))
                    object[".gogoproto.marshaler"] = message[".gogoproto.marshaler"];
                if (message[".gogoproto.unmarshaler"] != null && message.hasOwnProperty(".gogoproto.unmarshaler"))
                    object[".gogoproto.unmarshaler"] = message[".gogoproto.unmarshaler"];
                if (message[".gogoproto.stable_marshaler"] != null && message.hasOwnProperty(".gogoproto.stable_marshaler"))
                    object[".gogoproto.stable_marshaler"] = message[".gogoproto.stable_marshaler"];
                if (message[".gogoproto.sizer"] != null && message.hasOwnProperty(".gogoproto.sizer"))
                    object[".gogoproto.sizer"] = message[".gogoproto.sizer"];
                if (message[".gogoproto.unsafe_marshaler"] != null && message.hasOwnProperty(".gogoproto.unsafe_marshaler"))
                    object[".gogoproto.unsafe_marshaler"] = message[".gogoproto.unsafe_marshaler"];
                if (message[".gogoproto.unsafe_unmarshaler"] != null && message.hasOwnProperty(".gogoproto.unsafe_unmarshaler"))
                    object[".gogoproto.unsafe_unmarshaler"] = message[".gogoproto.unsafe_unmarshaler"];
                if (message[".gogoproto.goproto_extensions_map"] != null && message.hasOwnProperty(".gogoproto.goproto_extensions_map"))
                    object[".gogoproto.goproto_extensions_map"] = message[".gogoproto.goproto_extensions_map"];
                if (message[".gogoproto.goproto_unrecognized"] != null && message.hasOwnProperty(".gogoproto.goproto_unrecognized"))
                    object[".gogoproto.goproto_unrecognized"] = message[".gogoproto.goproto_unrecognized"];
                if (message[".gogoproto.protosizer"] != null && message.hasOwnProperty(".gogoproto.protosizer"))
                    object[".gogoproto.protosizer"] = message[".gogoproto.protosizer"];
                if (message[".gogoproto.compare"] != null && message.hasOwnProperty(".gogoproto.compare"))
                    object[".gogoproto.compare"] = message[".gogoproto.compare"];
                if (message[".gogoproto.typedecl"] != null && message.hasOwnProperty(".gogoproto.typedecl"))
                    object[".gogoproto.typedecl"] = message[".gogoproto.typedecl"];
                if (message[".gogoproto.stringer"] != null && message.hasOwnProperty(".gogoproto.stringer"))
                    object[".gogoproto.stringer"] = message[".gogoproto.stringer"];
                return object;
            };

            /**
             * Creates a plain object from this MessageOptions message. Also converts values to other types if specified.
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            MessageOptions.prototype.toObject = function toObject(options) {
                return this.constructor.toObject(this, options);
            };

            /**
             * Converts this MessageOptions to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            MessageOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return MessageOptions;
        })();

        protobuf.FieldOptions = (function() {

            /**
             * Properties of a FieldOptions.
             * @typedef google.protobuf.FieldOptions$Properties
             * @type {Object}
             * @property {google.protobuf.FieldOptions.CType} [ctype] FieldOptions ctype.
             * @property {boolean} [packed] FieldOptions packed.
             * @property {google.protobuf.FieldOptions.JSType} [jstype] FieldOptions jstype.
             * @property {boolean} [lazy] FieldOptions lazy.
             * @property {boolean} [deprecated] FieldOptions deprecated.
             * @property {boolean} [weak] FieldOptions weak.
             * @property {Array.<google.protobuf.UninterpretedOption$Properties>} [uninterpreted_option] FieldOptions uninterpreted_option.
             * @property {boolean} [".gogoproto.nullable"] FieldOptions .gogoproto.nullable.
             * @property {boolean} [".gogoproto.embed"] FieldOptions .gogoproto.embed.
             * @property {string} [".gogoproto.customtype"] FieldOptions .gogoproto.customtype.
             * @property {string} [".gogoproto.customname"] FieldOptions .gogoproto.customname.
             * @property {string} [".gogoproto.jsontag"] FieldOptions .gogoproto.jsontag.
             * @property {string} [".gogoproto.moretags"] FieldOptions .gogoproto.moretags.
             * @property {string} [".gogoproto.casttype"] FieldOptions .gogoproto.casttype.
             * @property {string} [".gogoproto.castkey"] FieldOptions .gogoproto.castkey.
             * @property {string} [".gogoproto.castvalue"] FieldOptions .gogoproto.castvalue.
             * @property {boolean} [".gogoproto.stdtime"] FieldOptions .gogoproto.stdtime.
             * @property {boolean} [".gogoproto.stdduration"] FieldOptions .gogoproto.stdduration.
             */

            /**
             * Constructs a new FieldOptions.
             * @exports google.protobuf.FieldOptions
             * @constructor
             * @param {google.protobuf.FieldOptions$Properties=} [properties] Properties to set
             */
            function FieldOptions(properties) {
                this.uninterpreted_option = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * FieldOptions ctype.
             * @type {google.protobuf.FieldOptions.CType}
             */
            FieldOptions.prototype.ctype = 0;

            /**
             * FieldOptions packed.
             * @type {boolean}
             */
            FieldOptions.prototype.packed = false;

            /**
             * FieldOptions jstype.
             * @type {google.protobuf.FieldOptions.JSType}
             */
            FieldOptions.prototype.jstype = 0;

            /**
             * FieldOptions lazy.
             * @type {boolean}
             */
            FieldOptions.prototype.lazy = false;

            /**
             * FieldOptions deprecated.
             * @type {boolean}
             */
            FieldOptions.prototype.deprecated = false;

            /**
             * FieldOptions weak.
             * @type {boolean}
             */
            FieldOptions.prototype.weak = false;

            /**
             * FieldOptions uninterpreted_option.
             * @type {Array.<google.protobuf.UninterpretedOption$Properties>}
             */
            FieldOptions.prototype.uninterpreted_option = $util.emptyArray;

            /**
             * FieldOptions .gogoproto.nullable.
             * @type {boolean}
             */
            FieldOptions.prototype[".gogoproto.nullable"] = false;

            /**
             * FieldOptions .gogoproto.embed.
             * @type {boolean}
             */
            FieldOptions.prototype[".gogoproto.embed"] = false;

            /**
             * FieldOptions .gogoproto.customtype.
             * @type {string}
             */
            FieldOptions.prototype[".gogoproto.customtype"] = "";

            /**
             * FieldOptions .gogoproto.customname.
             * @type {string}
             */
            FieldOptions.prototype[".gogoproto.customname"] = "";

            /**
             * FieldOptions .gogoproto.jsontag.
             * @type {string}
             */
            FieldOptions.prototype[".gogoproto.jsontag"] = "";

            /**
             * FieldOptions .gogoproto.moretags.
             * @type {string}
             */
            FieldOptions.prototype[".gogoproto.moretags"] = "";

            /**
             * FieldOptions .gogoproto.casttype.
             * @type {string}
             */
            FieldOptions.prototype[".gogoproto.casttype"] = "";

            /**
             * FieldOptions .gogoproto.castkey.
             * @type {string}
             */
            FieldOptions.prototype[".gogoproto.castkey"] = "";

            /**
             * FieldOptions .gogoproto.castvalue.
             * @type {string}
             */
            FieldOptions.prototype[".gogoproto.castvalue"] = "";

            /**
             * FieldOptions .gogoproto.stdtime.
             * @type {boolean}
             */
            FieldOptions.prototype[".gogoproto.stdtime"] = false;

            /**
             * FieldOptions .gogoproto.stdduration.
             * @type {boolean}
             */
            FieldOptions.prototype[".gogoproto.stdduration"] = false;

            /**
             * Creates a new FieldOptions instance using the specified properties.
             * @param {google.protobuf.FieldOptions$Properties=} [properties] Properties to set
             * @returns {google.protobuf.FieldOptions} FieldOptions instance
             */
            FieldOptions.create = function create(properties) {
                return new FieldOptions(properties);
            };

            /**
             * Encodes the specified FieldOptions message. Does not implicitly {@link google.protobuf.FieldOptions.verify|verify} messages.
             * @param {google.protobuf.FieldOptions$Properties} message FieldOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FieldOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.ctype != null && message.hasOwnProperty("ctype"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.ctype);
                if (message.packed != null && message.hasOwnProperty("packed"))
                    writer.uint32(/* id 2, wireType 0 =*/16).bool(message.packed);
                if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                    writer.uint32(/* id 3, wireType 0 =*/24).bool(message.deprecated);
                if (message.lazy != null && message.hasOwnProperty("lazy"))
                    writer.uint32(/* id 5, wireType 0 =*/40).bool(message.lazy);
                if (message.jstype != null && message.hasOwnProperty("jstype"))
                    writer.uint32(/* id 6, wireType 0 =*/48).uint32(message.jstype);
                if (message.weak != null && message.hasOwnProperty("weak"))
                    writer.uint32(/* id 10, wireType 0 =*/80).bool(message.weak);
                if (message.uninterpreted_option != null && message.uninterpreted_option.length)
                    for (let i = 0; i < message.uninterpreted_option.length; ++i)
                        $root.google.protobuf.UninterpretedOption.encode(message.uninterpreted_option[i], writer.uint32(/* id 999, wireType 2 =*/7994).fork()).ldelim();
                if (message[".gogoproto.nullable"] != null && message.hasOwnProperty(".gogoproto.nullable"))
                    writer.uint32(/* id 65001, wireType 0 =*/520008).bool(message[".gogoproto.nullable"]);
                if (message[".gogoproto.embed"] != null && message.hasOwnProperty(".gogoproto.embed"))
                    writer.uint32(/* id 65002, wireType 0 =*/520016).bool(message[".gogoproto.embed"]);
                if (message[".gogoproto.customtype"] != null && message.hasOwnProperty(".gogoproto.customtype"))
                    writer.uint32(/* id 65003, wireType 2 =*/520026).string(message[".gogoproto.customtype"]);
                if (message[".gogoproto.customname"] != null && message.hasOwnProperty(".gogoproto.customname"))
                    writer.uint32(/* id 65004, wireType 2 =*/520034).string(message[".gogoproto.customname"]);
                if (message[".gogoproto.jsontag"] != null && message.hasOwnProperty(".gogoproto.jsontag"))
                    writer.uint32(/* id 65005, wireType 2 =*/520042).string(message[".gogoproto.jsontag"]);
                if (message[".gogoproto.moretags"] != null && message.hasOwnProperty(".gogoproto.moretags"))
                    writer.uint32(/* id 65006, wireType 2 =*/520050).string(message[".gogoproto.moretags"]);
                if (message[".gogoproto.casttype"] != null && message.hasOwnProperty(".gogoproto.casttype"))
                    writer.uint32(/* id 65007, wireType 2 =*/520058).string(message[".gogoproto.casttype"]);
                if (message[".gogoproto.castkey"] != null && message.hasOwnProperty(".gogoproto.castkey"))
                    writer.uint32(/* id 65008, wireType 2 =*/520066).string(message[".gogoproto.castkey"]);
                if (message[".gogoproto.castvalue"] != null && message.hasOwnProperty(".gogoproto.castvalue"))
                    writer.uint32(/* id 65009, wireType 2 =*/520074).string(message[".gogoproto.castvalue"]);
                if (message[".gogoproto.stdtime"] != null && message.hasOwnProperty(".gogoproto.stdtime"))
                    writer.uint32(/* id 65010, wireType 0 =*/520080).bool(message[".gogoproto.stdtime"]);
                if (message[".gogoproto.stdduration"] != null && message.hasOwnProperty(".gogoproto.stdduration"))
                    writer.uint32(/* id 65011, wireType 0 =*/520088).bool(message[".gogoproto.stdduration"]);
                return writer;
            };

            /**
             * Encodes the specified FieldOptions message, length delimited. Does not implicitly {@link google.protobuf.FieldOptions.verify|verify} messages.
             * @param {google.protobuf.FieldOptions$Properties} message FieldOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FieldOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a FieldOptions message from the specified reader or buffer.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.FieldOptions} FieldOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FieldOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.FieldOptions();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.ctype = reader.uint32();
                        break;
                    case 2:
                        message.packed = reader.bool();
                        break;
                    case 6:
                        message.jstype = reader.uint32();
                        break;
                    case 5:
                        message.lazy = reader.bool();
                        break;
                    case 3:
                        message.deprecated = reader.bool();
                        break;
                    case 10:
                        message.weak = reader.bool();
                        break;
                    case 999:
                        if (!(message.uninterpreted_option && message.uninterpreted_option.length))
                            message.uninterpreted_option = [];
                        message.uninterpreted_option.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));
                        break;
                    case 65001:
                        message[".gogoproto.nullable"] = reader.bool();
                        break;
                    case 65002:
                        message[".gogoproto.embed"] = reader.bool();
                        break;
                    case 65003:
                        message[".gogoproto.customtype"] = reader.string();
                        break;
                    case 65004:
                        message[".gogoproto.customname"] = reader.string();
                        break;
                    case 65005:
                        message[".gogoproto.jsontag"] = reader.string();
                        break;
                    case 65006:
                        message[".gogoproto.moretags"] = reader.string();
                        break;
                    case 65007:
                        message[".gogoproto.casttype"] = reader.string();
                        break;
                    case 65008:
                        message[".gogoproto.castkey"] = reader.string();
                        break;
                    case 65009:
                        message[".gogoproto.castvalue"] = reader.string();
                        break;
                    case 65010:
                        message[".gogoproto.stdtime"] = reader.bool();
                        break;
                    case 65011:
                        message[".gogoproto.stdduration"] = reader.bool();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a FieldOptions message from the specified reader or buffer, length delimited.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.FieldOptions} FieldOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FieldOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a FieldOptions message.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            FieldOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.ctype != null && message.hasOwnProperty("ctype"))
                    switch (message.ctype) {
                    default:
                        return "ctype: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                        break;
                    }
                if (message.packed != null && message.hasOwnProperty("packed"))
                    if (typeof message.packed !== "boolean")
                        return "packed: boolean expected";
                if (message.jstype != null && message.hasOwnProperty("jstype"))
                    switch (message.jstype) {
                    default:
                        return "jstype: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                        break;
                    }
                if (message.lazy != null && message.hasOwnProperty("lazy"))
                    if (typeof message.lazy !== "boolean")
                        return "lazy: boolean expected";
                if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                    if (typeof message.deprecated !== "boolean")
                        return "deprecated: boolean expected";
                if (message.weak != null && message.hasOwnProperty("weak"))
                    if (typeof message.weak !== "boolean")
                        return "weak: boolean expected";
                if (message.uninterpreted_option != null && message.hasOwnProperty("uninterpreted_option")) {
                    if (!Array.isArray(message.uninterpreted_option))
                        return "uninterpreted_option: array expected";
                    for (let i = 0; i < message.uninterpreted_option.length; ++i) {
                        let error = $root.google.protobuf.UninterpretedOption.verify(message.uninterpreted_option[i]);
                        if (error)
                            return "uninterpreted_option." + error;
                    }
                }
                if (message[".gogoproto.nullable"] != null && message.hasOwnProperty(".gogoproto.nullable"))
                    if (typeof message[".gogoproto.nullable"] !== "boolean")
                        return ".gogoproto.nullable: boolean expected";
                if (message[".gogoproto.embed"] != null && message.hasOwnProperty(".gogoproto.embed"))
                    if (typeof message[".gogoproto.embed"] !== "boolean")
                        return ".gogoproto.embed: boolean expected";
                if (message[".gogoproto.customtype"] != null && message.hasOwnProperty(".gogoproto.customtype"))
                    if (!$util.isString(message[".gogoproto.customtype"]))
                        return ".gogoproto.customtype: string expected";
                if (message[".gogoproto.customname"] != null && message.hasOwnProperty(".gogoproto.customname"))
                    if (!$util.isString(message[".gogoproto.customname"]))
                        return ".gogoproto.customname: string expected";
                if (message[".gogoproto.jsontag"] != null && message.hasOwnProperty(".gogoproto.jsontag"))
                    if (!$util.isString(message[".gogoproto.jsontag"]))
                        return ".gogoproto.jsontag: string expected";
                if (message[".gogoproto.moretags"] != null && message.hasOwnProperty(".gogoproto.moretags"))
                    if (!$util.isString(message[".gogoproto.moretags"]))
                        return ".gogoproto.moretags: string expected";
                if (message[".gogoproto.casttype"] != null && message.hasOwnProperty(".gogoproto.casttype"))
                    if (!$util.isString(message[".gogoproto.casttype"]))
                        return ".gogoproto.casttype: string expected";
                if (message[".gogoproto.castkey"] != null && message.hasOwnProperty(".gogoproto.castkey"))
                    if (!$util.isString(message[".gogoproto.castkey"]))
                        return ".gogoproto.castkey: string expected";
                if (message[".gogoproto.castvalue"] != null && message.hasOwnProperty(".gogoproto.castvalue"))
                    if (!$util.isString(message[".gogoproto.castvalue"]))
                        return ".gogoproto.castvalue: string expected";
                if (message[".gogoproto.stdtime"] != null && message.hasOwnProperty(".gogoproto.stdtime"))
                    if (typeof message[".gogoproto.stdtime"] !== "boolean")
                        return ".gogoproto.stdtime: boolean expected";
                if (message[".gogoproto.stdduration"] != null && message.hasOwnProperty(".gogoproto.stdduration"))
                    if (typeof message[".gogoproto.stdduration"] !== "boolean")
                        return ".gogoproto.stdduration: boolean expected";
                return null;
            };

            /**
             * Creates a FieldOptions message from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.FieldOptions} FieldOptions
             */
            FieldOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.FieldOptions)
                    return object;
                let message = new $root.google.protobuf.FieldOptions();
                switch (object.ctype) {
                case "STRING":
                case 0:
                    message.ctype = 0;
                    break;
                case "CORD":
                case 1:
                    message.ctype = 1;
                    break;
                case "STRING_PIECE":
                case 2:
                    message.ctype = 2;
                    break;
                }
                if (object.packed != null)
                    message.packed = Boolean(object.packed);
                switch (object.jstype) {
                case "JS_NORMAL":
                case 0:
                    message.jstype = 0;
                    break;
                case "JS_STRING":
                case 1:
                    message.jstype = 1;
                    break;
                case "JS_NUMBER":
                case 2:
                    message.jstype = 2;
                    break;
                }
                if (object.lazy != null)
                    message.lazy = Boolean(object.lazy);
                if (object.deprecated != null)
                    message.deprecated = Boolean(object.deprecated);
                if (object.weak != null)
                    message.weak = Boolean(object.weak);
                if (object.uninterpreted_option) {
                    if (!Array.isArray(object.uninterpreted_option))
                        throw TypeError(".google.protobuf.FieldOptions.uninterpreted_option: array expected");
                    message.uninterpreted_option = [];
                    for (let i = 0; i < object.uninterpreted_option.length; ++i) {
                        if (typeof object.uninterpreted_option[i] !== "object")
                            throw TypeError(".google.protobuf.FieldOptions.uninterpreted_option: object expected");
                        message.uninterpreted_option[i] = $root.google.protobuf.UninterpretedOption.fromObject(object.uninterpreted_option[i]);
                    }
                }
                if (object[".gogoproto.nullable"] != null)
                    message[".gogoproto.nullable"] = Boolean(object[".gogoproto.nullable"]);
                if (object[".gogoproto.embed"] != null)
                    message[".gogoproto.embed"] = Boolean(object[".gogoproto.embed"]);
                if (object[".gogoproto.customtype"] != null)
                    message[".gogoproto.customtype"] = String(object[".gogoproto.customtype"]);
                if (object[".gogoproto.customname"] != null)
                    message[".gogoproto.customname"] = String(object[".gogoproto.customname"]);
                if (object[".gogoproto.jsontag"] != null)
                    message[".gogoproto.jsontag"] = String(object[".gogoproto.jsontag"]);
                if (object[".gogoproto.moretags"] != null)
                    message[".gogoproto.moretags"] = String(object[".gogoproto.moretags"]);
                if (object[".gogoproto.casttype"] != null)
                    message[".gogoproto.casttype"] = String(object[".gogoproto.casttype"]);
                if (object[".gogoproto.castkey"] != null)
                    message[".gogoproto.castkey"] = String(object[".gogoproto.castkey"]);
                if (object[".gogoproto.castvalue"] != null)
                    message[".gogoproto.castvalue"] = String(object[".gogoproto.castvalue"]);
                if (object[".gogoproto.stdtime"] != null)
                    message[".gogoproto.stdtime"] = Boolean(object[".gogoproto.stdtime"]);
                if (object[".gogoproto.stdduration"] != null)
                    message[".gogoproto.stdduration"] = Boolean(object[".gogoproto.stdduration"]);
                return message;
            };

            /**
             * Creates a FieldOptions message from a plain object. Also converts values to their respective internal types.
             * This is an alias of {@link google.protobuf.FieldOptions.fromObject}.
             * @function
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.FieldOptions} FieldOptions
             */
            FieldOptions.from = FieldOptions.fromObject;

            /**
             * Creates a plain object from a FieldOptions message. Also converts values to other types if specified.
             * @param {google.protobuf.FieldOptions} message FieldOptions
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            FieldOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.uninterpreted_option = [];
                if (options.defaults) {
                    object.ctype = options.enums === String ? "STRING" : 0;
                    object.packed = false;
                    object.deprecated = false;
                    object.lazy = false;
                    object.jstype = options.enums === String ? "JS_NORMAL" : 0;
                    object.weak = false;
                    object[".gogoproto.nullable"] = false;
                    object[".gogoproto.embed"] = false;
                    object[".gogoproto.customtype"] = "";
                    object[".gogoproto.customname"] = "";
                    object[".gogoproto.jsontag"] = "";
                    object[".gogoproto.moretags"] = "";
                    object[".gogoproto.casttype"] = "";
                    object[".gogoproto.castkey"] = "";
                    object[".gogoproto.castvalue"] = "";
                    object[".gogoproto.stdtime"] = false;
                    object[".gogoproto.stdduration"] = false;
                }
                if (message.ctype != null && message.hasOwnProperty("ctype"))
                    object.ctype = options.enums === String ? $root.google.protobuf.FieldOptions.CType[message.ctype] : message.ctype;
                if (message.packed != null && message.hasOwnProperty("packed"))
                    object.packed = message.packed;
                if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                    object.deprecated = message.deprecated;
                if (message.lazy != null && message.hasOwnProperty("lazy"))
                    object.lazy = message.lazy;
                if (message.jstype != null && message.hasOwnProperty("jstype"))
                    object.jstype = options.enums === String ? $root.google.protobuf.FieldOptions.JSType[message.jstype] : message.jstype;
                if (message.weak != null && message.hasOwnProperty("weak"))
                    object.weak = message.weak;
                if (message.uninterpreted_option && message.uninterpreted_option.length) {
                    object.uninterpreted_option = [];
                    for (let j = 0; j < message.uninterpreted_option.length; ++j)
                        object.uninterpreted_option[j] = $root.google.protobuf.UninterpretedOption.toObject(message.uninterpreted_option[j], options);
                }
                if (message[".gogoproto.nullable"] != null && message.hasOwnProperty(".gogoproto.nullable"))
                    object[".gogoproto.nullable"] = message[".gogoproto.nullable"];
                if (message[".gogoproto.embed"] != null && message.hasOwnProperty(".gogoproto.embed"))
                    object[".gogoproto.embed"] = message[".gogoproto.embed"];
                if (message[".gogoproto.customtype"] != null && message.hasOwnProperty(".gogoproto.customtype"))
                    object[".gogoproto.customtype"] = message[".gogoproto.customtype"];
                if (message[".gogoproto.customname"] != null && message.hasOwnProperty(".gogoproto.customname"))
                    object[".gogoproto.customname"] = message[".gogoproto.customname"];
                if (message[".gogoproto.jsontag"] != null && message.hasOwnProperty(".gogoproto.jsontag"))
                    object[".gogoproto.jsontag"] = message[".gogoproto.jsontag"];
                if (message[".gogoproto.moretags"] != null && message.hasOwnProperty(".gogoproto.moretags"))
                    object[".gogoproto.moretags"] = message[".gogoproto.moretags"];
                if (message[".gogoproto.casttype"] != null && message.hasOwnProperty(".gogoproto.casttype"))
                    object[".gogoproto.casttype"] = message[".gogoproto.casttype"];
                if (message[".gogoproto.castkey"] != null && message.hasOwnProperty(".gogoproto.castkey"))
                    object[".gogoproto.castkey"] = message[".gogoproto.castkey"];
                if (message[".gogoproto.castvalue"] != null && message.hasOwnProperty(".gogoproto.castvalue"))
                    object[".gogoproto.castvalue"] = message[".gogoproto.castvalue"];
                if (message[".gogoproto.stdtime"] != null && message.hasOwnProperty(".gogoproto.stdtime"))
                    object[".gogoproto.stdtime"] = message[".gogoproto.stdtime"];
                if (message[".gogoproto.stdduration"] != null && message.hasOwnProperty(".gogoproto.stdduration"))
                    object[".gogoproto.stdduration"] = message[".gogoproto.stdduration"];
                return object;
            };

            /**
             * Creates a plain object from this FieldOptions message. Also converts values to other types if specified.
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            FieldOptions.prototype.toObject = function toObject(options) {
                return this.constructor.toObject(this, options);
            };

            /**
             * Converts this FieldOptions to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            FieldOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * CType enum.
             * @name CType
             * @memberof google.protobuf.FieldOptions
             * @enum {number}
             * @property {number} STRING=0 STRING value
             * @property {number} CORD=1 CORD value
             * @property {number} STRING_PIECE=2 STRING_PIECE value
             */
            FieldOptions.CType = (function() {
                const valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "STRING"] = 0;
                values[valuesById[1] = "CORD"] = 1;
                values[valuesById[2] = "STRING_PIECE"] = 2;
                return values;
            })();

            /**
             * JSType enum.
             * @name JSType
             * @memberof google.protobuf.FieldOptions
             * @enum {number}
             * @property {number} JS_NORMAL=0 JS_NORMAL value
             * @property {number} JS_STRING=1 JS_STRING value
             * @property {number} JS_NUMBER=2 JS_NUMBER value
             */
            FieldOptions.JSType = (function() {
                const valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "JS_NORMAL"] = 0;
                values[valuesById[1] = "JS_STRING"] = 1;
                values[valuesById[2] = "JS_NUMBER"] = 2;
                return values;
            })();

            return FieldOptions;
        })();

        protobuf.OneofOptions = (function() {

            /**
             * Properties of an OneofOptions.
             * @typedef google.protobuf.OneofOptions$Properties
             * @type {Object}
             * @property {Array.<google.protobuf.UninterpretedOption$Properties>} [uninterpreted_option] OneofOptions uninterpreted_option.
             */

            /**
             * Constructs a new OneofOptions.
             * @exports google.protobuf.OneofOptions
             * @constructor
             * @param {google.protobuf.OneofOptions$Properties=} [properties] Properties to set
             */
            function OneofOptions(properties) {
                this.uninterpreted_option = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * OneofOptions uninterpreted_option.
             * @type {Array.<google.protobuf.UninterpretedOption$Properties>}
             */
            OneofOptions.prototype.uninterpreted_option = $util.emptyArray;

            /**
             * Creates a new OneofOptions instance using the specified properties.
             * @param {google.protobuf.OneofOptions$Properties=} [properties] Properties to set
             * @returns {google.protobuf.OneofOptions} OneofOptions instance
             */
            OneofOptions.create = function create(properties) {
                return new OneofOptions(properties);
            };

            /**
             * Encodes the specified OneofOptions message. Does not implicitly {@link google.protobuf.OneofOptions.verify|verify} messages.
             * @param {google.protobuf.OneofOptions$Properties} message OneofOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            OneofOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.uninterpreted_option != null && message.uninterpreted_option.length)
                    for (let i = 0; i < message.uninterpreted_option.length; ++i)
                        $root.google.protobuf.UninterpretedOption.encode(message.uninterpreted_option[i], writer.uint32(/* id 999, wireType 2 =*/7994).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified OneofOptions message, length delimited. Does not implicitly {@link google.protobuf.OneofOptions.verify|verify} messages.
             * @param {google.protobuf.OneofOptions$Properties} message OneofOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            OneofOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an OneofOptions message from the specified reader or buffer.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.OneofOptions} OneofOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            OneofOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.OneofOptions();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 999:
                        if (!(message.uninterpreted_option && message.uninterpreted_option.length))
                            message.uninterpreted_option = [];
                        message.uninterpreted_option.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an OneofOptions message from the specified reader or buffer, length delimited.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.OneofOptions} OneofOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            OneofOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an OneofOptions message.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            OneofOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.uninterpreted_option != null && message.hasOwnProperty("uninterpreted_option")) {
                    if (!Array.isArray(message.uninterpreted_option))
                        return "uninterpreted_option: array expected";
                    for (let i = 0; i < message.uninterpreted_option.length; ++i) {
                        let error = $root.google.protobuf.UninterpretedOption.verify(message.uninterpreted_option[i]);
                        if (error)
                            return "uninterpreted_option." + error;
                    }
                }
                return null;
            };

            /**
             * Creates an OneofOptions message from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.OneofOptions} OneofOptions
             */
            OneofOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.OneofOptions)
                    return object;
                let message = new $root.google.protobuf.OneofOptions();
                if (object.uninterpreted_option) {
                    if (!Array.isArray(object.uninterpreted_option))
                        throw TypeError(".google.protobuf.OneofOptions.uninterpreted_option: array expected");
                    message.uninterpreted_option = [];
                    for (let i = 0; i < object.uninterpreted_option.length; ++i) {
                        if (typeof object.uninterpreted_option[i] !== "object")
                            throw TypeError(".google.protobuf.OneofOptions.uninterpreted_option: object expected");
                        message.uninterpreted_option[i] = $root.google.protobuf.UninterpretedOption.fromObject(object.uninterpreted_option[i]);
                    }
                }
                return message;
            };

            /**
             * Creates an OneofOptions message from a plain object. Also converts values to their respective internal types.
             * This is an alias of {@link google.protobuf.OneofOptions.fromObject}.
             * @function
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.OneofOptions} OneofOptions
             */
            OneofOptions.from = OneofOptions.fromObject;

            /**
             * Creates a plain object from an OneofOptions message. Also converts values to other types if specified.
             * @param {google.protobuf.OneofOptions} message OneofOptions
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            OneofOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.uninterpreted_option = [];
                if (message.uninterpreted_option && message.uninterpreted_option.length) {
                    object.uninterpreted_option = [];
                    for (let j = 0; j < message.uninterpreted_option.length; ++j)
                        object.uninterpreted_option[j] = $root.google.protobuf.UninterpretedOption.toObject(message.uninterpreted_option[j], options);
                }
                return object;
            };

            /**
             * Creates a plain object from this OneofOptions message. Also converts values to other types if specified.
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            OneofOptions.prototype.toObject = function toObject(options) {
                return this.constructor.toObject(this, options);
            };

            /**
             * Converts this OneofOptions to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            OneofOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return OneofOptions;
        })();

        protobuf.EnumOptions = (function() {

            /**
             * Properties of an EnumOptions.
             * @typedef google.protobuf.EnumOptions$Properties
             * @type {Object}
             * @property {boolean} [allow_alias] EnumOptions allow_alias.
             * @property {boolean} [deprecated] EnumOptions deprecated.
             * @property {Array.<google.protobuf.UninterpretedOption$Properties>} [uninterpreted_option] EnumOptions uninterpreted_option.
             * @property {boolean} [".gogoproto.goproto_enum_prefix"] EnumOptions .gogoproto.goproto_enum_prefix.
             * @property {boolean} [".gogoproto.goproto_enum_stringer"] EnumOptions .gogoproto.goproto_enum_stringer.
             * @property {boolean} [".gogoproto.enum_stringer"] EnumOptions .gogoproto.enum_stringer.
             * @property {string} [".gogoproto.enum_customname"] EnumOptions .gogoproto.enum_customname.
             * @property {boolean} [".gogoproto.enumdecl"] EnumOptions .gogoproto.enumdecl.
             */

            /**
             * Constructs a new EnumOptions.
             * @exports google.protobuf.EnumOptions
             * @constructor
             * @param {google.protobuf.EnumOptions$Properties=} [properties] Properties to set
             */
            function EnumOptions(properties) {
                this.uninterpreted_option = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * EnumOptions allow_alias.
             * @type {boolean}
             */
            EnumOptions.prototype.allow_alias = false;

            /**
             * EnumOptions deprecated.
             * @type {boolean}
             */
            EnumOptions.prototype.deprecated = false;

            /**
             * EnumOptions uninterpreted_option.
             * @type {Array.<google.protobuf.UninterpretedOption$Properties>}
             */
            EnumOptions.prototype.uninterpreted_option = $util.emptyArray;

            /**
             * EnumOptions .gogoproto.goproto_enum_prefix.
             * @type {boolean}
             */
            EnumOptions.prototype[".gogoproto.goproto_enum_prefix"] = false;

            /**
             * EnumOptions .gogoproto.goproto_enum_stringer.
             * @type {boolean}
             */
            EnumOptions.prototype[".gogoproto.goproto_enum_stringer"] = false;

            /**
             * EnumOptions .gogoproto.enum_stringer.
             * @type {boolean}
             */
            EnumOptions.prototype[".gogoproto.enum_stringer"] = false;

            /**
             * EnumOptions .gogoproto.enum_customname.
             * @type {string}
             */
            EnumOptions.prototype[".gogoproto.enum_customname"] = "";

            /**
             * EnumOptions .gogoproto.enumdecl.
             * @type {boolean}
             */
            EnumOptions.prototype[".gogoproto.enumdecl"] = false;

            /**
             * Creates a new EnumOptions instance using the specified properties.
             * @param {google.protobuf.EnumOptions$Properties=} [properties] Properties to set
             * @returns {google.protobuf.EnumOptions} EnumOptions instance
             */
            EnumOptions.create = function create(properties) {
                return new EnumOptions(properties);
            };

            /**
             * Encodes the specified EnumOptions message. Does not implicitly {@link google.protobuf.EnumOptions.verify|verify} messages.
             * @param {google.protobuf.EnumOptions$Properties} message EnumOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            EnumOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.allow_alias != null && message.hasOwnProperty("allow_alias"))
                    writer.uint32(/* id 2, wireType 0 =*/16).bool(message.allow_alias);
                if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                    writer.uint32(/* id 3, wireType 0 =*/24).bool(message.deprecated);
                if (message.uninterpreted_option != null && message.uninterpreted_option.length)
                    for (let i = 0; i < message.uninterpreted_option.length; ++i)
                        $root.google.protobuf.UninterpretedOption.encode(message.uninterpreted_option[i], writer.uint32(/* id 999, wireType 2 =*/7994).fork()).ldelim();
                if (message[".gogoproto.goproto_enum_prefix"] != null && message.hasOwnProperty(".gogoproto.goproto_enum_prefix"))
                    writer.uint32(/* id 62001, wireType 0 =*/496008).bool(message[".gogoproto.goproto_enum_prefix"]);
                if (message[".gogoproto.goproto_enum_stringer"] != null && message.hasOwnProperty(".gogoproto.goproto_enum_stringer"))
                    writer.uint32(/* id 62021, wireType 0 =*/496168).bool(message[".gogoproto.goproto_enum_stringer"]);
                if (message[".gogoproto.enum_stringer"] != null && message.hasOwnProperty(".gogoproto.enum_stringer"))
                    writer.uint32(/* id 62022, wireType 0 =*/496176).bool(message[".gogoproto.enum_stringer"]);
                if (message[".gogoproto.enum_customname"] != null && message.hasOwnProperty(".gogoproto.enum_customname"))
                    writer.uint32(/* id 62023, wireType 2 =*/496186).string(message[".gogoproto.enum_customname"]);
                if (message[".gogoproto.enumdecl"] != null && message.hasOwnProperty(".gogoproto.enumdecl"))
                    writer.uint32(/* id 62024, wireType 0 =*/496192).bool(message[".gogoproto.enumdecl"]);
                return writer;
            };

            /**
             * Encodes the specified EnumOptions message, length delimited. Does not implicitly {@link google.protobuf.EnumOptions.verify|verify} messages.
             * @param {google.protobuf.EnumOptions$Properties} message EnumOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            EnumOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an EnumOptions message from the specified reader or buffer.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.EnumOptions} EnumOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            EnumOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.EnumOptions();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 2:
                        message.allow_alias = reader.bool();
                        break;
                    case 3:
                        message.deprecated = reader.bool();
                        break;
                    case 999:
                        if (!(message.uninterpreted_option && message.uninterpreted_option.length))
                            message.uninterpreted_option = [];
                        message.uninterpreted_option.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));
                        break;
                    case 62001:
                        message[".gogoproto.goproto_enum_prefix"] = reader.bool();
                        break;
                    case 62021:
                        message[".gogoproto.goproto_enum_stringer"] = reader.bool();
                        break;
                    case 62022:
                        message[".gogoproto.enum_stringer"] = reader.bool();
                        break;
                    case 62023:
                        message[".gogoproto.enum_customname"] = reader.string();
                        break;
                    case 62024:
                        message[".gogoproto.enumdecl"] = reader.bool();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an EnumOptions message from the specified reader or buffer, length delimited.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.EnumOptions} EnumOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            EnumOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an EnumOptions message.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            EnumOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.allow_alias != null && message.hasOwnProperty("allow_alias"))
                    if (typeof message.allow_alias !== "boolean")
                        return "allow_alias: boolean expected";
                if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                    if (typeof message.deprecated !== "boolean")
                        return "deprecated: boolean expected";
                if (message.uninterpreted_option != null && message.hasOwnProperty("uninterpreted_option")) {
                    if (!Array.isArray(message.uninterpreted_option))
                        return "uninterpreted_option: array expected";
                    for (let i = 0; i < message.uninterpreted_option.length; ++i) {
                        let error = $root.google.protobuf.UninterpretedOption.verify(message.uninterpreted_option[i]);
                        if (error)
                            return "uninterpreted_option." + error;
                    }
                }
                if (message[".gogoproto.goproto_enum_prefix"] != null && message.hasOwnProperty(".gogoproto.goproto_enum_prefix"))
                    if (typeof message[".gogoproto.goproto_enum_prefix"] !== "boolean")
                        return ".gogoproto.goproto_enum_prefix: boolean expected";
                if (message[".gogoproto.goproto_enum_stringer"] != null && message.hasOwnProperty(".gogoproto.goproto_enum_stringer"))
                    if (typeof message[".gogoproto.goproto_enum_stringer"] !== "boolean")
                        return ".gogoproto.goproto_enum_stringer: boolean expected";
                if (message[".gogoproto.enum_stringer"] != null && message.hasOwnProperty(".gogoproto.enum_stringer"))
                    if (typeof message[".gogoproto.enum_stringer"] !== "boolean")
                        return ".gogoproto.enum_stringer: boolean expected";
                if (message[".gogoproto.enum_customname"] != null && message.hasOwnProperty(".gogoproto.enum_customname"))
                    if (!$util.isString(message[".gogoproto.enum_customname"]))
                        return ".gogoproto.enum_customname: string expected";
                if (message[".gogoproto.enumdecl"] != null && message.hasOwnProperty(".gogoproto.enumdecl"))
                    if (typeof message[".gogoproto.enumdecl"] !== "boolean")
                        return ".gogoproto.enumdecl: boolean expected";
                return null;
            };

            /**
             * Creates an EnumOptions message from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.EnumOptions} EnumOptions
             */
            EnumOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.EnumOptions)
                    return object;
                let message = new $root.google.protobuf.EnumOptions();
                if (object.allow_alias != null)
                    message.allow_alias = Boolean(object.allow_alias);
                if (object.deprecated != null)
                    message.deprecated = Boolean(object.deprecated);
                if (object.uninterpreted_option) {
                    if (!Array.isArray(object.uninterpreted_option))
                        throw TypeError(".google.protobuf.EnumOptions.uninterpreted_option: array expected");
                    message.uninterpreted_option = [];
                    for (let i = 0; i < object.uninterpreted_option.length; ++i) {
                        if (typeof object.uninterpreted_option[i] !== "object")
                            throw TypeError(".google.protobuf.EnumOptions.uninterpreted_option: object expected");
                        message.uninterpreted_option[i] = $root.google.protobuf.UninterpretedOption.fromObject(object.uninterpreted_option[i]);
                    }
                }
                if (object[".gogoproto.goproto_enum_prefix"] != null)
                    message[".gogoproto.goproto_enum_prefix"] = Boolean(object[".gogoproto.goproto_enum_prefix"]);
                if (object[".gogoproto.goproto_enum_stringer"] != null)
                    message[".gogoproto.goproto_enum_stringer"] = Boolean(object[".gogoproto.goproto_enum_stringer"]);
                if (object[".gogoproto.enum_stringer"] != null)
                    message[".gogoproto.enum_stringer"] = Boolean(object[".gogoproto.enum_stringer"]);
                if (object[".gogoproto.enum_customname"] != null)
                    message[".gogoproto.enum_customname"] = String(object[".gogoproto.enum_customname"]);
                if (object[".gogoproto.enumdecl"] != null)
                    message[".gogoproto.enumdecl"] = Boolean(object[".gogoproto.enumdecl"]);
                return message;
            };

            /**
             * Creates an EnumOptions message from a plain object. Also converts values to their respective internal types.
             * This is an alias of {@link google.protobuf.EnumOptions.fromObject}.
             * @function
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.EnumOptions} EnumOptions
             */
            EnumOptions.from = EnumOptions.fromObject;

            /**
             * Creates a plain object from an EnumOptions message. Also converts values to other types if specified.
             * @param {google.protobuf.EnumOptions} message EnumOptions
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            EnumOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.uninterpreted_option = [];
                if (options.defaults) {
                    object.allow_alias = false;
                    object.deprecated = false;
                    object[".gogoproto.goproto_enum_prefix"] = false;
                    object[".gogoproto.goproto_enum_stringer"] = false;
                    object[".gogoproto.enum_stringer"] = false;
                    object[".gogoproto.enum_customname"] = "";
                    object[".gogoproto.enumdecl"] = false;
                }
                if (message.allow_alias != null && message.hasOwnProperty("allow_alias"))
                    object.allow_alias = message.allow_alias;
                if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                    object.deprecated = message.deprecated;
                if (message.uninterpreted_option && message.uninterpreted_option.length) {
                    object.uninterpreted_option = [];
                    for (let j = 0; j < message.uninterpreted_option.length; ++j)
                        object.uninterpreted_option[j] = $root.google.protobuf.UninterpretedOption.toObject(message.uninterpreted_option[j], options);
                }
                if (message[".gogoproto.goproto_enum_prefix"] != null && message.hasOwnProperty(".gogoproto.goproto_enum_prefix"))
                    object[".gogoproto.goproto_enum_prefix"] = message[".gogoproto.goproto_enum_prefix"];
                if (message[".gogoproto.goproto_enum_stringer"] != null && message.hasOwnProperty(".gogoproto.goproto_enum_stringer"))
                    object[".gogoproto.goproto_enum_stringer"] = message[".gogoproto.goproto_enum_stringer"];
                if (message[".gogoproto.enum_stringer"] != null && message.hasOwnProperty(".gogoproto.enum_stringer"))
                    object[".gogoproto.enum_stringer"] = message[".gogoproto.enum_stringer"];
                if (message[".gogoproto.enum_customname"] != null && message.hasOwnProperty(".gogoproto.enum_customname"))
                    object[".gogoproto.enum_customname"] = message[".gogoproto.enum_customname"];
                if (message[".gogoproto.enumdecl"] != null && message.hasOwnProperty(".gogoproto.enumdecl"))
                    object[".gogoproto.enumdecl"] = message[".gogoproto.enumdecl"];
                return object;
            };

            /**
             * Creates a plain object from this EnumOptions message. Also converts values to other types if specified.
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            EnumOptions.prototype.toObject = function toObject(options) {
                return this.constructor.toObject(this, options);
            };

            /**
             * Converts this EnumOptions to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            EnumOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return EnumOptions;
        })();

        protobuf.EnumValueOptions = (function() {

            /**
             * Properties of an EnumValueOptions.
             * @typedef google.protobuf.EnumValueOptions$Properties
             * @type {Object}
             * @property {boolean} [deprecated] EnumValueOptions deprecated.
             * @property {Array.<google.protobuf.UninterpretedOption$Properties>} [uninterpreted_option] EnumValueOptions uninterpreted_option.
             * @property {string} [".gogoproto.enumvalue_customname"] EnumValueOptions .gogoproto.enumvalue_customname.
             */

            /**
             * Constructs a new EnumValueOptions.
             * @exports google.protobuf.EnumValueOptions
             * @constructor
             * @param {google.protobuf.EnumValueOptions$Properties=} [properties] Properties to set
             */
            function EnumValueOptions(properties) {
                this.uninterpreted_option = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * EnumValueOptions deprecated.
             * @type {boolean}
             */
            EnumValueOptions.prototype.deprecated = false;

            /**
             * EnumValueOptions uninterpreted_option.
             * @type {Array.<google.protobuf.UninterpretedOption$Properties>}
             */
            EnumValueOptions.prototype.uninterpreted_option = $util.emptyArray;

            /**
             * EnumValueOptions .gogoproto.enumvalue_customname.
             * @type {string}
             */
            EnumValueOptions.prototype[".gogoproto.enumvalue_customname"] = "";

            /**
             * Creates a new EnumValueOptions instance using the specified properties.
             * @param {google.protobuf.EnumValueOptions$Properties=} [properties] Properties to set
             * @returns {google.protobuf.EnumValueOptions} EnumValueOptions instance
             */
            EnumValueOptions.create = function create(properties) {
                return new EnumValueOptions(properties);
            };

            /**
             * Encodes the specified EnumValueOptions message. Does not implicitly {@link google.protobuf.EnumValueOptions.verify|verify} messages.
             * @param {google.protobuf.EnumValueOptions$Properties} message EnumValueOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            EnumValueOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                    writer.uint32(/* id 1, wireType 0 =*/8).bool(message.deprecated);
                if (message.uninterpreted_option != null && message.uninterpreted_option.length)
                    for (let i = 0; i < message.uninterpreted_option.length; ++i)
                        $root.google.protobuf.UninterpretedOption.encode(message.uninterpreted_option[i], writer.uint32(/* id 999, wireType 2 =*/7994).fork()).ldelim();
                if (message[".gogoproto.enumvalue_customname"] != null && message.hasOwnProperty(".gogoproto.enumvalue_customname"))
                    writer.uint32(/* id 66001, wireType 2 =*/528010).string(message[".gogoproto.enumvalue_customname"]);
                return writer;
            };

            /**
             * Encodes the specified EnumValueOptions message, length delimited. Does not implicitly {@link google.protobuf.EnumValueOptions.verify|verify} messages.
             * @param {google.protobuf.EnumValueOptions$Properties} message EnumValueOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            EnumValueOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an EnumValueOptions message from the specified reader or buffer.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.EnumValueOptions} EnumValueOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            EnumValueOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.EnumValueOptions();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.deprecated = reader.bool();
                        break;
                    case 999:
                        if (!(message.uninterpreted_option && message.uninterpreted_option.length))
                            message.uninterpreted_option = [];
                        message.uninterpreted_option.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));
                        break;
                    case 66001:
                        message[".gogoproto.enumvalue_customname"] = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an EnumValueOptions message from the specified reader or buffer, length delimited.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.EnumValueOptions} EnumValueOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            EnumValueOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an EnumValueOptions message.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            EnumValueOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                    if (typeof message.deprecated !== "boolean")
                        return "deprecated: boolean expected";
                if (message.uninterpreted_option != null && message.hasOwnProperty("uninterpreted_option")) {
                    if (!Array.isArray(message.uninterpreted_option))
                        return "uninterpreted_option: array expected";
                    for (let i = 0; i < message.uninterpreted_option.length; ++i) {
                        let error = $root.google.protobuf.UninterpretedOption.verify(message.uninterpreted_option[i]);
                        if (error)
                            return "uninterpreted_option." + error;
                    }
                }
                if (message[".gogoproto.enumvalue_customname"] != null && message.hasOwnProperty(".gogoproto.enumvalue_customname"))
                    if (!$util.isString(message[".gogoproto.enumvalue_customname"]))
                        return ".gogoproto.enumvalue_customname: string expected";
                return null;
            };

            /**
             * Creates an EnumValueOptions message from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.EnumValueOptions} EnumValueOptions
             */
            EnumValueOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.EnumValueOptions)
                    return object;
                let message = new $root.google.protobuf.EnumValueOptions();
                if (object.deprecated != null)
                    message.deprecated = Boolean(object.deprecated);
                if (object.uninterpreted_option) {
                    if (!Array.isArray(object.uninterpreted_option))
                        throw TypeError(".google.protobuf.EnumValueOptions.uninterpreted_option: array expected");
                    message.uninterpreted_option = [];
                    for (let i = 0; i < object.uninterpreted_option.length; ++i) {
                        if (typeof object.uninterpreted_option[i] !== "object")
                            throw TypeError(".google.protobuf.EnumValueOptions.uninterpreted_option: object expected");
                        message.uninterpreted_option[i] = $root.google.protobuf.UninterpretedOption.fromObject(object.uninterpreted_option[i]);
                    }
                }
                if (object[".gogoproto.enumvalue_customname"] != null)
                    message[".gogoproto.enumvalue_customname"] = String(object[".gogoproto.enumvalue_customname"]);
                return message;
            };

            /**
             * Creates an EnumValueOptions message from a plain object. Also converts values to their respective internal types.
             * This is an alias of {@link google.protobuf.EnumValueOptions.fromObject}.
             * @function
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.EnumValueOptions} EnumValueOptions
             */
            EnumValueOptions.from = EnumValueOptions.fromObject;

            /**
             * Creates a plain object from an EnumValueOptions message. Also converts values to other types if specified.
             * @param {google.protobuf.EnumValueOptions} message EnumValueOptions
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            EnumValueOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.uninterpreted_option = [];
                if (options.defaults) {
                    object.deprecated = false;
                    object[".gogoproto.enumvalue_customname"] = "";
                }
                if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                    object.deprecated = message.deprecated;
                if (message.uninterpreted_option && message.uninterpreted_option.length) {
                    object.uninterpreted_option = [];
                    for (let j = 0; j < message.uninterpreted_option.length; ++j)
                        object.uninterpreted_option[j] = $root.google.protobuf.UninterpretedOption.toObject(message.uninterpreted_option[j], options);
                }
                if (message[".gogoproto.enumvalue_customname"] != null && message.hasOwnProperty(".gogoproto.enumvalue_customname"))
                    object[".gogoproto.enumvalue_customname"] = message[".gogoproto.enumvalue_customname"];
                return object;
            };

            /**
             * Creates a plain object from this EnumValueOptions message. Also converts values to other types if specified.
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            EnumValueOptions.prototype.toObject = function toObject(options) {
                return this.constructor.toObject(this, options);
            };

            /**
             * Converts this EnumValueOptions to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            EnumValueOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return EnumValueOptions;
        })();

        protobuf.ServiceOptions = (function() {

            /**
             * Properties of a ServiceOptions.
             * @typedef google.protobuf.ServiceOptions$Properties
             * @type {Object}
             * @property {boolean} [deprecated] ServiceOptions deprecated.
             * @property {Array.<google.protobuf.UninterpretedOption$Properties>} [uninterpreted_option] ServiceOptions uninterpreted_option.
             */

            /**
             * Constructs a new ServiceOptions.
             * @exports google.protobuf.ServiceOptions
             * @constructor
             * @param {google.protobuf.ServiceOptions$Properties=} [properties] Properties to set
             */
            function ServiceOptions(properties) {
                this.uninterpreted_option = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ServiceOptions deprecated.
             * @type {boolean}
             */
            ServiceOptions.prototype.deprecated = false;

            /**
             * ServiceOptions uninterpreted_option.
             * @type {Array.<google.protobuf.UninterpretedOption$Properties>}
             */
            ServiceOptions.prototype.uninterpreted_option = $util.emptyArray;

            /**
             * Creates a new ServiceOptions instance using the specified properties.
             * @param {google.protobuf.ServiceOptions$Properties=} [properties] Properties to set
             * @returns {google.protobuf.ServiceOptions} ServiceOptions instance
             */
            ServiceOptions.create = function create(properties) {
                return new ServiceOptions(properties);
            };

            /**
             * Encodes the specified ServiceOptions message. Does not implicitly {@link google.protobuf.ServiceOptions.verify|verify} messages.
             * @param {google.protobuf.ServiceOptions$Properties} message ServiceOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ServiceOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                    writer.uint32(/* id 33, wireType 0 =*/264).bool(message.deprecated);
                if (message.uninterpreted_option != null && message.uninterpreted_option.length)
                    for (let i = 0; i < message.uninterpreted_option.length; ++i)
                        $root.google.protobuf.UninterpretedOption.encode(message.uninterpreted_option[i], writer.uint32(/* id 999, wireType 2 =*/7994).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified ServiceOptions message, length delimited. Does not implicitly {@link google.protobuf.ServiceOptions.verify|verify} messages.
             * @param {google.protobuf.ServiceOptions$Properties} message ServiceOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ServiceOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ServiceOptions message from the specified reader or buffer.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.ServiceOptions} ServiceOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ServiceOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.ServiceOptions();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 33:
                        message.deprecated = reader.bool();
                        break;
                    case 999:
                        if (!(message.uninterpreted_option && message.uninterpreted_option.length))
                            message.uninterpreted_option = [];
                        message.uninterpreted_option.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ServiceOptions message from the specified reader or buffer, length delimited.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.ServiceOptions} ServiceOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ServiceOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ServiceOptions message.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            ServiceOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                    if (typeof message.deprecated !== "boolean")
                        return "deprecated: boolean expected";
                if (message.uninterpreted_option != null && message.hasOwnProperty("uninterpreted_option")) {
                    if (!Array.isArray(message.uninterpreted_option))
                        return "uninterpreted_option: array expected";
                    for (let i = 0; i < message.uninterpreted_option.length; ++i) {
                        let error = $root.google.protobuf.UninterpretedOption.verify(message.uninterpreted_option[i]);
                        if (error)
                            return "uninterpreted_option." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a ServiceOptions message from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.ServiceOptions} ServiceOptions
             */
            ServiceOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.ServiceOptions)
                    return object;
                let message = new $root.google.protobuf.ServiceOptions();
                if (object.deprecated != null)
                    message.deprecated = Boolean(object.deprecated);
                if (object.uninterpreted_option) {
                    if (!Array.isArray(object.uninterpreted_option))
                        throw TypeError(".google.protobuf.ServiceOptions.uninterpreted_option: array expected");
                    message.uninterpreted_option = [];
                    for (let i = 0; i < object.uninterpreted_option.length; ++i) {
                        if (typeof object.uninterpreted_option[i] !== "object")
                            throw TypeError(".google.protobuf.ServiceOptions.uninterpreted_option: object expected");
                        message.uninterpreted_option[i] = $root.google.protobuf.UninterpretedOption.fromObject(object.uninterpreted_option[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a ServiceOptions message from a plain object. Also converts values to their respective internal types.
             * This is an alias of {@link google.protobuf.ServiceOptions.fromObject}.
             * @function
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.ServiceOptions} ServiceOptions
             */
            ServiceOptions.from = ServiceOptions.fromObject;

            /**
             * Creates a plain object from a ServiceOptions message. Also converts values to other types if specified.
             * @param {google.protobuf.ServiceOptions} message ServiceOptions
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ServiceOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.uninterpreted_option = [];
                if (options.defaults)
                    object.deprecated = false;
                if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                    object.deprecated = message.deprecated;
                if (message.uninterpreted_option && message.uninterpreted_option.length) {
                    object.uninterpreted_option = [];
                    for (let j = 0; j < message.uninterpreted_option.length; ++j)
                        object.uninterpreted_option[j] = $root.google.protobuf.UninterpretedOption.toObject(message.uninterpreted_option[j], options);
                }
                return object;
            };

            /**
             * Creates a plain object from this ServiceOptions message. Also converts values to other types if specified.
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ServiceOptions.prototype.toObject = function toObject(options) {
                return this.constructor.toObject(this, options);
            };

            /**
             * Converts this ServiceOptions to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            ServiceOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ServiceOptions;
        })();

        protobuf.MethodOptions = (function() {

            /**
             * Properties of a MethodOptions.
             * @typedef google.protobuf.MethodOptions$Properties
             * @type {Object}
             * @property {boolean} [deprecated] MethodOptions deprecated.
             * @property {Array.<google.protobuf.UninterpretedOption$Properties>} [uninterpreted_option] MethodOptions uninterpreted_option.
             * @property {google.api.HttpRule$Properties} [".google.api.http"] MethodOptions .google.api.http.
             */

            /**
             * Constructs a new MethodOptions.
             * @exports google.protobuf.MethodOptions
             * @constructor
             * @param {google.protobuf.MethodOptions$Properties=} [properties] Properties to set
             */
            function MethodOptions(properties) {
                this.uninterpreted_option = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * MethodOptions deprecated.
             * @type {boolean}
             */
            MethodOptions.prototype.deprecated = false;

            /**
             * MethodOptions uninterpreted_option.
             * @type {Array.<google.protobuf.UninterpretedOption$Properties>}
             */
            MethodOptions.prototype.uninterpreted_option = $util.emptyArray;

            /**
             * MethodOptions .google.api.http.
             * @type {(google.api.HttpRule$Properties|null)}
             */
            MethodOptions.prototype[".google.api.http"] = null;

            /**
             * Creates a new MethodOptions instance using the specified properties.
             * @param {google.protobuf.MethodOptions$Properties=} [properties] Properties to set
             * @returns {google.protobuf.MethodOptions} MethodOptions instance
             */
            MethodOptions.create = function create(properties) {
                return new MethodOptions(properties);
            };

            /**
             * Encodes the specified MethodOptions message. Does not implicitly {@link google.protobuf.MethodOptions.verify|verify} messages.
             * @param {google.protobuf.MethodOptions$Properties} message MethodOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MethodOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                    writer.uint32(/* id 33, wireType 0 =*/264).bool(message.deprecated);
                if (message.uninterpreted_option != null && message.uninterpreted_option.length)
                    for (let i = 0; i < message.uninterpreted_option.length; ++i)
                        $root.google.protobuf.UninterpretedOption.encode(message.uninterpreted_option[i], writer.uint32(/* id 999, wireType 2 =*/7994).fork()).ldelim();
                if (message[".google.api.http"] != null && message.hasOwnProperty(".google.api.http"))
                    $root.google.api.HttpRule.encode(message[".google.api.http"], writer.uint32(/* id 72295728, wireType 2 =*/578365826).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified MethodOptions message, length delimited. Does not implicitly {@link google.protobuf.MethodOptions.verify|verify} messages.
             * @param {google.protobuf.MethodOptions$Properties} message MethodOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MethodOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a MethodOptions message from the specified reader or buffer.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.MethodOptions} MethodOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MethodOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.MethodOptions();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 33:
                        message.deprecated = reader.bool();
                        break;
                    case 999:
                        if (!(message.uninterpreted_option && message.uninterpreted_option.length))
                            message.uninterpreted_option = [];
                        message.uninterpreted_option.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));
                        break;
                    case 72295728:
                        message[".google.api.http"] = $root.google.api.HttpRule.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a MethodOptions message from the specified reader or buffer, length delimited.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.MethodOptions} MethodOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MethodOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a MethodOptions message.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            MethodOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                    if (typeof message.deprecated !== "boolean")
                        return "deprecated: boolean expected";
                if (message.uninterpreted_option != null && message.hasOwnProperty("uninterpreted_option")) {
                    if (!Array.isArray(message.uninterpreted_option))
                        return "uninterpreted_option: array expected";
                    for (let i = 0; i < message.uninterpreted_option.length; ++i) {
                        let error = $root.google.protobuf.UninterpretedOption.verify(message.uninterpreted_option[i]);
                        if (error)
                            return "uninterpreted_option." + error;
                    }
                }
                if (message[".google.api.http"] != null && message.hasOwnProperty(".google.api.http")) {
                    let error = $root.google.api.HttpRule.verify(message[".google.api.http"]);
                    if (error)
                        return ".google.api.http." + error;
                }
                return null;
            };

            /**
             * Creates a MethodOptions message from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.MethodOptions} MethodOptions
             */
            MethodOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.MethodOptions)
                    return object;
                let message = new $root.google.protobuf.MethodOptions();
                if (object.deprecated != null)
                    message.deprecated = Boolean(object.deprecated);
                if (object.uninterpreted_option) {
                    if (!Array.isArray(object.uninterpreted_option))
                        throw TypeError(".google.protobuf.MethodOptions.uninterpreted_option: array expected");
                    message.uninterpreted_option = [];
                    for (let i = 0; i < object.uninterpreted_option.length; ++i) {
                        if (typeof object.uninterpreted_option[i] !== "object")
                            throw TypeError(".google.protobuf.MethodOptions.uninterpreted_option: object expected");
                        message.uninterpreted_option[i] = $root.google.protobuf.UninterpretedOption.fromObject(object.uninterpreted_option[i]);
                    }
                }
                if (object[".google.api.http"] != null) {
                    if (typeof object[".google.api.http"] !== "object")
                        throw TypeError(".google.protobuf.MethodOptions..google.api.http: object expected");
                    message[".google.api.http"] = $root.google.api.HttpRule.fromObject(object[".google.api.http"]);
                }
                return message;
            };

            /**
             * Creates a MethodOptions message from a plain object. Also converts values to their respective internal types.
             * This is an alias of {@link google.protobuf.MethodOptions.fromObject}.
             * @function
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.MethodOptions} MethodOptions
             */
            MethodOptions.from = MethodOptions.fromObject;

            /**
             * Creates a plain object from a MethodOptions message. Also converts values to other types if specified.
             * @param {google.protobuf.MethodOptions} message MethodOptions
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            MethodOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.uninterpreted_option = [];
                if (options.defaults) {
                    object.deprecated = false;
                    object[".google.api.http"] = null;
                }
                if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                    object.deprecated = message.deprecated;
                if (message.uninterpreted_option && message.uninterpreted_option.length) {
                    object.uninterpreted_option = [];
                    for (let j = 0; j < message.uninterpreted_option.length; ++j)
                        object.uninterpreted_option[j] = $root.google.protobuf.UninterpretedOption.toObject(message.uninterpreted_option[j], options);
                }
                if (message[".google.api.http"] != null && message.hasOwnProperty(".google.api.http"))
                    object[".google.api.http"] = $root.google.api.HttpRule.toObject(message[".google.api.http"], options);
                return object;
            };

            /**
             * Creates a plain object from this MethodOptions message. Also converts values to other types if specified.
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            MethodOptions.prototype.toObject = function toObject(options) {
                return this.constructor.toObject(this, options);
            };

            /**
             * Converts this MethodOptions to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            MethodOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return MethodOptions;
        })();

        protobuf.UninterpretedOption = (function() {

            /**
             * Properties of an UninterpretedOption.
             * @typedef google.protobuf.UninterpretedOption$Properties
             * @type {Object}
             * @property {Array.<google.protobuf.UninterpretedOption.NamePart$Properties>} [name] UninterpretedOption name.
             * @property {string} [identifier_value] UninterpretedOption identifier_value.
             * @property {Long} [positive_int_value] UninterpretedOption positive_int_value.
             * @property {Long} [negative_int_value] UninterpretedOption negative_int_value.
             * @property {number} [double_value] UninterpretedOption double_value.
             * @property {Uint8Array} [string_value] UninterpretedOption string_value.
             * @property {string} [aggregate_value] UninterpretedOption aggregate_value.
             */

            /**
             * Constructs a new UninterpretedOption.
             * @exports google.protobuf.UninterpretedOption
             * @constructor
             * @param {google.protobuf.UninterpretedOption$Properties=} [properties] Properties to set
             */
            function UninterpretedOption(properties) {
                this.name = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * UninterpretedOption name.
             * @type {Array.<google.protobuf.UninterpretedOption.NamePart$Properties>}
             */
            UninterpretedOption.prototype.name = $util.emptyArray;

            /**
             * UninterpretedOption identifier_value.
             * @type {string}
             */
            UninterpretedOption.prototype.identifier_value = "";

            /**
             * UninterpretedOption positive_int_value.
             * @type {Long}
             */
            UninterpretedOption.prototype.positive_int_value = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * UninterpretedOption negative_int_value.
             * @type {Long}
             */
            UninterpretedOption.prototype.negative_int_value = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * UninterpretedOption double_value.
             * @type {number}
             */
            UninterpretedOption.prototype.double_value = 0;

            /**
             * UninterpretedOption string_value.
             * @type {Uint8Array}
             */
            UninterpretedOption.prototype.string_value = $util.newBuffer([]);

            /**
             * UninterpretedOption aggregate_value.
             * @type {string}
             */
            UninterpretedOption.prototype.aggregate_value = "";

            /**
             * Creates a new UninterpretedOption instance using the specified properties.
             * @param {google.protobuf.UninterpretedOption$Properties=} [properties] Properties to set
             * @returns {google.protobuf.UninterpretedOption} UninterpretedOption instance
             */
            UninterpretedOption.create = function create(properties) {
                return new UninterpretedOption(properties);
            };

            /**
             * Encodes the specified UninterpretedOption message. Does not implicitly {@link google.protobuf.UninterpretedOption.verify|verify} messages.
             * @param {google.protobuf.UninterpretedOption$Properties} message UninterpretedOption message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            UninterpretedOption.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && message.name.length)
                    for (let i = 0; i < message.name.length; ++i)
                        $root.google.protobuf.UninterpretedOption.NamePart.encode(message.name[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.identifier_value != null && message.hasOwnProperty("identifier_value"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.identifier_value);
                if (message.positive_int_value != null && message.hasOwnProperty("positive_int_value"))
                    writer.uint32(/* id 4, wireType 0 =*/32).uint64(message.positive_int_value);
                if (message.negative_int_value != null && message.hasOwnProperty("negative_int_value"))
                    writer.uint32(/* id 5, wireType 0 =*/40).int64(message.negative_int_value);
                if (message.double_value != null && message.hasOwnProperty("double_value"))
                    writer.uint32(/* id 6, wireType 1 =*/49).double(message.double_value);
                if (message.string_value != null && message.hasOwnProperty("string_value"))
                    writer.uint32(/* id 7, wireType 2 =*/58).bytes(message.string_value);
                if (message.aggregate_value != null && message.hasOwnProperty("aggregate_value"))
                    writer.uint32(/* id 8, wireType 2 =*/66).string(message.aggregate_value);
                return writer;
            };

            /**
             * Encodes the specified UninterpretedOption message, length delimited. Does not implicitly {@link google.protobuf.UninterpretedOption.verify|verify} messages.
             * @param {google.protobuf.UninterpretedOption$Properties} message UninterpretedOption message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            UninterpretedOption.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an UninterpretedOption message from the specified reader or buffer.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.UninterpretedOption} UninterpretedOption
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            UninterpretedOption.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.UninterpretedOption();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 2:
                        if (!(message.name && message.name.length))
                            message.name = [];
                        message.name.push($root.google.protobuf.UninterpretedOption.NamePart.decode(reader, reader.uint32()));
                        break;
                    case 3:
                        message.identifier_value = reader.string();
                        break;
                    case 4:
                        message.positive_int_value = reader.uint64();
                        break;
                    case 5:
                        message.negative_int_value = reader.int64();
                        break;
                    case 6:
                        message.double_value = reader.double();
                        break;
                    case 7:
                        message.string_value = reader.bytes();
                        break;
                    case 8:
                        message.aggregate_value = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an UninterpretedOption message from the specified reader or buffer, length delimited.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.UninterpretedOption} UninterpretedOption
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            UninterpretedOption.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an UninterpretedOption message.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            UninterpretedOption.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name")) {
                    if (!Array.isArray(message.name))
                        return "name: array expected";
                    for (let i = 0; i < message.name.length; ++i) {
                        let error = $root.google.protobuf.UninterpretedOption.NamePart.verify(message.name[i]);
                        if (error)
                            return "name." + error;
                    }
                }
                if (message.identifier_value != null && message.hasOwnProperty("identifier_value"))
                    if (!$util.isString(message.identifier_value))
                        return "identifier_value: string expected";
                if (message.positive_int_value != null && message.hasOwnProperty("positive_int_value"))
                    if (!$util.isInteger(message.positive_int_value) && !(message.positive_int_value && $util.isInteger(message.positive_int_value.low) && $util.isInteger(message.positive_int_value.high)))
                        return "positive_int_value: integer|Long expected";
                if (message.negative_int_value != null && message.hasOwnProperty("negative_int_value"))
                    if (!$util.isInteger(message.negative_int_value) && !(message.negative_int_value && $util.isInteger(message.negative_int_value.low) && $util.isInteger(message.negative_int_value.high)))
                        return "negative_int_value: integer|Long expected";
                if (message.double_value != null && message.hasOwnProperty("double_value"))
                    if (typeof message.double_value !== "number")
                        return "double_value: number expected";
                if (message.string_value != null && message.hasOwnProperty("string_value"))
                    if (!(message.string_value && typeof message.string_value.length === "number" || $util.isString(message.string_value)))
                        return "string_value: buffer expected";
                if (message.aggregate_value != null && message.hasOwnProperty("aggregate_value"))
                    if (!$util.isString(message.aggregate_value))
                        return "aggregate_value: string expected";
                return null;
            };

            /**
             * Creates an UninterpretedOption message from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.UninterpretedOption} UninterpretedOption
             */
            UninterpretedOption.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.UninterpretedOption)
                    return object;
                let message = new $root.google.protobuf.UninterpretedOption();
                if (object.name) {
                    if (!Array.isArray(object.name))
                        throw TypeError(".google.protobuf.UninterpretedOption.name: array expected");
                    message.name = [];
                    for (let i = 0; i < object.name.length; ++i) {
                        if (typeof object.name[i] !== "object")
                            throw TypeError(".google.protobuf.UninterpretedOption.name: object expected");
                        message.name[i] = $root.google.protobuf.UninterpretedOption.NamePart.fromObject(object.name[i]);
                    }
                }
                if (object.identifier_value != null)
                    message.identifier_value = String(object.identifier_value);
                if (object.positive_int_value != null)
                    if ($util.Long)
                        (message.positive_int_value = $util.Long.fromValue(object.positive_int_value)).unsigned = true;
                    else if (typeof object.positive_int_value === "string")
                        message.positive_int_value = parseInt(object.positive_int_value, 10);
                    else if (typeof object.positive_int_value === "number")
                        message.positive_int_value = object.positive_int_value;
                    else if (typeof object.positive_int_value === "object")
                        message.positive_int_value = new $util.LongBits(object.positive_int_value.low >>> 0, object.positive_int_value.high >>> 0).toNumber(true);
                if (object.negative_int_value != null)
                    if ($util.Long)
                        (message.negative_int_value = $util.Long.fromValue(object.negative_int_value)).unsigned = false;
                    else if (typeof object.negative_int_value === "string")
                        message.negative_int_value = parseInt(object.negative_int_value, 10);
                    else if (typeof object.negative_int_value === "number")
                        message.negative_int_value = object.negative_int_value;
                    else if (typeof object.negative_int_value === "object")
                        message.negative_int_value = new $util.LongBits(object.negative_int_value.low >>> 0, object.negative_int_value.high >>> 0).toNumber();
                if (object.double_value != null)
                    message.double_value = Number(object.double_value);
                if (object.string_value != null)
                    if (typeof object.string_value === "string")
                        $util.base64.decode(object.string_value, message.string_value = $util.newBuffer($util.base64.length(object.string_value)), 0);
                    else if (object.string_value.length)
                        message.string_value = object.string_value;
                if (object.aggregate_value != null)
                    message.aggregate_value = String(object.aggregate_value);
                return message;
            };

            /**
             * Creates an UninterpretedOption message from a plain object. Also converts values to their respective internal types.
             * This is an alias of {@link google.protobuf.UninterpretedOption.fromObject}.
             * @function
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.UninterpretedOption} UninterpretedOption
             */
            UninterpretedOption.from = UninterpretedOption.fromObject;

            /**
             * Creates a plain object from an UninterpretedOption message. Also converts values to other types if specified.
             * @param {google.protobuf.UninterpretedOption} message UninterpretedOption
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            UninterpretedOption.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.name = [];
                if (options.defaults) {
                    object.identifier_value = "";
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.positive_int_value = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.positive_int_value = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, false);
                        object.negative_int_value = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.negative_int_value = options.longs === String ? "0" : 0;
                    object.double_value = 0;
                    object.string_value = options.bytes === String ? "" : [];
                    object.aggregate_value = "";
                }
                if (message.name && message.name.length) {
                    object.name = [];
                    for (let j = 0; j < message.name.length; ++j)
                        object.name[j] = $root.google.protobuf.UninterpretedOption.NamePart.toObject(message.name[j], options);
                }
                if (message.identifier_value != null && message.hasOwnProperty("identifier_value"))
                    object.identifier_value = message.identifier_value;
                if (message.positive_int_value != null && message.hasOwnProperty("positive_int_value"))
                    if (typeof message.positive_int_value === "number")
                        object.positive_int_value = options.longs === String ? String(message.positive_int_value) : message.positive_int_value;
                    else
                        object.positive_int_value = options.longs === String ? $util.Long.prototype.toString.call(message.positive_int_value) : options.longs === Number ? new $util.LongBits(message.positive_int_value.low >>> 0, message.positive_int_value.high >>> 0).toNumber(true) : message.positive_int_value;
                if (message.negative_int_value != null && message.hasOwnProperty("negative_int_value"))
                    if (typeof message.negative_int_value === "number")
                        object.negative_int_value = options.longs === String ? String(message.negative_int_value) : message.negative_int_value;
                    else
                        object.negative_int_value = options.longs === String ? $util.Long.prototype.toString.call(message.negative_int_value) : options.longs === Number ? new $util.LongBits(message.negative_int_value.low >>> 0, message.negative_int_value.high >>> 0).toNumber() : message.negative_int_value;
                if (message.double_value != null && message.hasOwnProperty("double_value"))
                    object.double_value = message.double_value;
                if (message.string_value != null && message.hasOwnProperty("string_value"))
                    object.string_value = options.bytes === String ? $util.base64.encode(message.string_value, 0, message.string_value.length) : options.bytes === Array ? Array.prototype.slice.call(message.string_value) : message.string_value;
                if (message.aggregate_value != null && message.hasOwnProperty("aggregate_value"))
                    object.aggregate_value = message.aggregate_value;
                return object;
            };

            /**
             * Creates a plain object from this UninterpretedOption message. Also converts values to other types if specified.
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            UninterpretedOption.prototype.toObject = function toObject(options) {
                return this.constructor.toObject(this, options);
            };

            /**
             * Converts this UninterpretedOption to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            UninterpretedOption.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            UninterpretedOption.NamePart = (function() {

                /**
                 * Properties of a NamePart.
                 * @typedef google.protobuf.UninterpretedOption.NamePart$Properties
                 * @type {Object}
                 * @property {string} name_part NamePart name_part.
                 * @property {boolean} is_extension NamePart is_extension.
                 */

                /**
                 * Constructs a new NamePart.
                 * @exports google.protobuf.UninterpretedOption.NamePart
                 * @constructor
                 * @param {google.protobuf.UninterpretedOption.NamePart$Properties=} [properties] Properties to set
                 */
                function NamePart(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * NamePart name_part.
                 * @type {string}
                 */
                NamePart.prototype.name_part = "";

                /**
                 * NamePart is_extension.
                 * @type {boolean}
                 */
                NamePart.prototype.is_extension = false;

                /**
                 * Creates a new NamePart instance using the specified properties.
                 * @param {google.protobuf.UninterpretedOption.NamePart$Properties=} [properties] Properties to set
                 * @returns {google.protobuf.UninterpretedOption.NamePart} NamePart instance
                 */
                NamePart.create = function create(properties) {
                    return new NamePart(properties);
                };

                /**
                 * Encodes the specified NamePart message. Does not implicitly {@link google.protobuf.UninterpretedOption.NamePart.verify|verify} messages.
                 * @param {google.protobuf.UninterpretedOption.NamePart$Properties} message NamePart message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                NamePart.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.name_part);
                    writer.uint32(/* id 2, wireType 0 =*/16).bool(message.is_extension);
                    return writer;
                };

                /**
                 * Encodes the specified NamePart message, length delimited. Does not implicitly {@link google.protobuf.UninterpretedOption.NamePart.verify|verify} messages.
                 * @param {google.protobuf.UninterpretedOption.NamePart$Properties} message NamePart message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                NamePart.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a NamePart message from the specified reader or buffer.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.UninterpretedOption.NamePart} NamePart
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                NamePart.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.UninterpretedOption.NamePart();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.name_part = reader.string();
                            break;
                        case 2:
                            message.is_extension = reader.bool();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    if (!message.hasOwnProperty("name_part"))
                        throw $util.ProtocolError("missing required 'name_part'", { instance: message });
                    if (!message.hasOwnProperty("is_extension"))
                        throw $util.ProtocolError("missing required 'is_extension'", { instance: message });
                    return message;
                };

                /**
                 * Decodes a NamePart message from the specified reader or buffer, length delimited.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {google.protobuf.UninterpretedOption.NamePart} NamePart
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                NamePart.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a NamePart message.
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {?string} `null` if valid, otherwise the reason why it is not
                 */
                NamePart.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (!$util.isString(message.name_part))
                        return "name_part: string expected";
                    if (typeof message.is_extension !== "boolean")
                        return "is_extension: boolean expected";
                    return null;
                };

                /**
                 * Creates a NamePart message from a plain object. Also converts values to their respective internal types.
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.UninterpretedOption.NamePart} NamePart
                 */
                NamePart.fromObject = function fromObject(object) {
                    if (object instanceof $root.google.protobuf.UninterpretedOption.NamePart)
                        return object;
                    let message = new $root.google.protobuf.UninterpretedOption.NamePart();
                    if (object.name_part != null)
                        message.name_part = String(object.name_part);
                    if (object.is_extension != null)
                        message.is_extension = Boolean(object.is_extension);
                    return message;
                };

                /**
                 * Creates a NamePart message from a plain object. Also converts values to their respective internal types.
                 * This is an alias of {@link google.protobuf.UninterpretedOption.NamePart.fromObject}.
                 * @function
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.UninterpretedOption.NamePart} NamePart
                 */
                NamePart.from = NamePart.fromObject;

                /**
                 * Creates a plain object from a NamePart message. Also converts values to other types if specified.
                 * @param {google.protobuf.UninterpretedOption.NamePart} message NamePart
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                NamePart.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.name_part = "";
                        object.is_extension = false;
                    }
                    if (message.name_part != null && message.hasOwnProperty("name_part"))
                        object.name_part = message.name_part;
                    if (message.is_extension != null && message.hasOwnProperty("is_extension"))
                        object.is_extension = message.is_extension;
                    return object;
                };

                /**
                 * Creates a plain object from this NamePart message. Also converts values to other types if specified.
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                NamePart.prototype.toObject = function toObject(options) {
                    return this.constructor.toObject(this, options);
                };

                /**
                 * Converts this NamePart to JSON.
                 * @returns {Object.<string,*>} JSON object
                 */
                NamePart.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return NamePart;
            })();

            return UninterpretedOption;
        })();

        protobuf.SourceCodeInfo = (function() {

            /**
             * Properties of a SourceCodeInfo.
             * @typedef google.protobuf.SourceCodeInfo$Properties
             * @type {Object}
             * @property {Array.<google.protobuf.SourceCodeInfo.Location$Properties>} [location] SourceCodeInfo location.
             */

            /**
             * Constructs a new SourceCodeInfo.
             * @exports google.protobuf.SourceCodeInfo
             * @constructor
             * @param {google.protobuf.SourceCodeInfo$Properties=} [properties] Properties to set
             */
            function SourceCodeInfo(properties) {
                this.location = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * SourceCodeInfo location.
             * @type {Array.<google.protobuf.SourceCodeInfo.Location$Properties>}
             */
            SourceCodeInfo.prototype.location = $util.emptyArray;

            /**
             * Creates a new SourceCodeInfo instance using the specified properties.
             * @param {google.protobuf.SourceCodeInfo$Properties=} [properties] Properties to set
             * @returns {google.protobuf.SourceCodeInfo} SourceCodeInfo instance
             */
            SourceCodeInfo.create = function create(properties) {
                return new SourceCodeInfo(properties);
            };

            /**
             * Encodes the specified SourceCodeInfo message. Does not implicitly {@link google.protobuf.SourceCodeInfo.verify|verify} messages.
             * @param {google.protobuf.SourceCodeInfo$Properties} message SourceCodeInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SourceCodeInfo.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.location != null && message.location.length)
                    for (let i = 0; i < message.location.length; ++i)
                        $root.google.protobuf.SourceCodeInfo.Location.encode(message.location[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified SourceCodeInfo message, length delimited. Does not implicitly {@link google.protobuf.SourceCodeInfo.verify|verify} messages.
             * @param {google.protobuf.SourceCodeInfo$Properties} message SourceCodeInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SourceCodeInfo.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a SourceCodeInfo message from the specified reader or buffer.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.SourceCodeInfo} SourceCodeInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SourceCodeInfo.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.SourceCodeInfo();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.location && message.location.length))
                            message.location = [];
                        message.location.push($root.google.protobuf.SourceCodeInfo.Location.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a SourceCodeInfo message from the specified reader or buffer, length delimited.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.SourceCodeInfo} SourceCodeInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SourceCodeInfo.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a SourceCodeInfo message.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            SourceCodeInfo.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.location != null && message.hasOwnProperty("location")) {
                    if (!Array.isArray(message.location))
                        return "location: array expected";
                    for (let i = 0; i < message.location.length; ++i) {
                        let error = $root.google.protobuf.SourceCodeInfo.Location.verify(message.location[i]);
                        if (error)
                            return "location." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a SourceCodeInfo message from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.SourceCodeInfo} SourceCodeInfo
             */
            SourceCodeInfo.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.SourceCodeInfo)
                    return object;
                let message = new $root.google.protobuf.SourceCodeInfo();
                if (object.location) {
                    if (!Array.isArray(object.location))
                        throw TypeError(".google.protobuf.SourceCodeInfo.location: array expected");
                    message.location = [];
                    for (let i = 0; i < object.location.length; ++i) {
                        if (typeof object.location[i] !== "object")
                            throw TypeError(".google.protobuf.SourceCodeInfo.location: object expected");
                        message.location[i] = $root.google.protobuf.SourceCodeInfo.Location.fromObject(object.location[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a SourceCodeInfo message from a plain object. Also converts values to their respective internal types.
             * This is an alias of {@link google.protobuf.SourceCodeInfo.fromObject}.
             * @function
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.SourceCodeInfo} SourceCodeInfo
             */
            SourceCodeInfo.from = SourceCodeInfo.fromObject;

            /**
             * Creates a plain object from a SourceCodeInfo message. Also converts values to other types if specified.
             * @param {google.protobuf.SourceCodeInfo} message SourceCodeInfo
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SourceCodeInfo.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.location = [];
                if (message.location && message.location.length) {
                    object.location = [];
                    for (let j = 0; j < message.location.length; ++j)
                        object.location[j] = $root.google.protobuf.SourceCodeInfo.Location.toObject(message.location[j], options);
                }
                return object;
            };

            /**
             * Creates a plain object from this SourceCodeInfo message. Also converts values to other types if specified.
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SourceCodeInfo.prototype.toObject = function toObject(options) {
                return this.constructor.toObject(this, options);
            };

            /**
             * Converts this SourceCodeInfo to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            SourceCodeInfo.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            SourceCodeInfo.Location = (function() {

                /**
                 * Properties of a Location.
                 * @typedef google.protobuf.SourceCodeInfo.Location$Properties
                 * @type {Object}
                 * @property {Array.<number>} [path] Location path.
                 * @property {Array.<number>} [span] Location span.
                 * @property {string} [leading_comments] Location leading_comments.
                 * @property {string} [trailing_comments] Location trailing_comments.
                 * @property {Array.<string>} [leading_detached_comments] Location leading_detached_comments.
                 */

                /**
                 * Constructs a new Location.
                 * @exports google.protobuf.SourceCodeInfo.Location
                 * @constructor
                 * @param {google.protobuf.SourceCodeInfo.Location$Properties=} [properties] Properties to set
                 */
                function Location(properties) {
                    this.path = [];
                    this.span = [];
                    this.leading_detached_comments = [];
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Location path.
                 * @type {Array.<number>}
                 */
                Location.prototype.path = $util.emptyArray;

                /**
                 * Location span.
                 * @type {Array.<number>}
                 */
                Location.prototype.span = $util.emptyArray;

                /**
                 * Location leading_comments.
                 * @type {string}
                 */
                Location.prototype.leading_comments = "";

                /**
                 * Location trailing_comments.
                 * @type {string}
                 */
                Location.prototype.trailing_comments = "";

                /**
                 * Location leading_detached_comments.
                 * @type {Array.<string>}
                 */
                Location.prototype.leading_detached_comments = $util.emptyArray;

                /**
                 * Creates a new Location instance using the specified properties.
                 * @param {google.protobuf.SourceCodeInfo.Location$Properties=} [properties] Properties to set
                 * @returns {google.protobuf.SourceCodeInfo.Location} Location instance
                 */
                Location.create = function create(properties) {
                    return new Location(properties);
                };

                /**
                 * Encodes the specified Location message. Does not implicitly {@link google.protobuf.SourceCodeInfo.Location.verify|verify} messages.
                 * @param {google.protobuf.SourceCodeInfo.Location$Properties} message Location message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Location.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.path != null && message.path.length) {
                        writer.uint32(/* id 1, wireType 2 =*/10).fork();
                        for (let i = 0; i < message.path.length; ++i)
                            writer.int32(message.path[i]);
                        writer.ldelim();
                    }
                    if (message.span != null && message.span.length) {
                        writer.uint32(/* id 2, wireType 2 =*/18).fork();
                        for (let i = 0; i < message.span.length; ++i)
                            writer.int32(message.span[i]);
                        writer.ldelim();
                    }
                    if (message.leading_comments != null && message.hasOwnProperty("leading_comments"))
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.leading_comments);
                    if (message.trailing_comments != null && message.hasOwnProperty("trailing_comments"))
                        writer.uint32(/* id 4, wireType 2 =*/34).string(message.trailing_comments);
                    if (message.leading_detached_comments != null && message.leading_detached_comments.length)
                        for (let i = 0; i < message.leading_detached_comments.length; ++i)
                            writer.uint32(/* id 6, wireType 2 =*/50).string(message.leading_detached_comments[i]);
                    return writer;
                };

                /**
                 * Encodes the specified Location message, length delimited. Does not implicitly {@link google.protobuf.SourceCodeInfo.Location.verify|verify} messages.
                 * @param {google.protobuf.SourceCodeInfo.Location$Properties} message Location message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Location.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a Location message from the specified reader or buffer.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.SourceCodeInfo.Location} Location
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Location.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.SourceCodeInfo.Location();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (!(message.path && message.path.length))
                                message.path = [];
                            if ((tag & 7) === 2) {
                                let end2 = reader.uint32() + reader.pos;
                                while (reader.pos < end2)
                                    message.path.push(reader.int32());
                            } else
                                message.path.push(reader.int32());
                            break;
                        case 2:
                            if (!(message.span && message.span.length))
                                message.span = [];
                            if ((tag & 7) === 2) {
                                let end2 = reader.uint32() + reader.pos;
                                while (reader.pos < end2)
                                    message.span.push(reader.int32());
                            } else
                                message.span.push(reader.int32());
                            break;
                        case 3:
                            message.leading_comments = reader.string();
                            break;
                        case 4:
                            message.trailing_comments = reader.string();
                            break;
                        case 6:
                            if (!(message.leading_detached_comments && message.leading_detached_comments.length))
                                message.leading_detached_comments = [];
                            message.leading_detached_comments.push(reader.string());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a Location message from the specified reader or buffer, length delimited.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {google.protobuf.SourceCodeInfo.Location} Location
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Location.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a Location message.
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {?string} `null` if valid, otherwise the reason why it is not
                 */
                Location.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.path != null && message.hasOwnProperty("path")) {
                        if (!Array.isArray(message.path))
                            return "path: array expected";
                        for (let i = 0; i < message.path.length; ++i)
                            if (!$util.isInteger(message.path[i]))
                                return "path: integer[] expected";
                    }
                    if (message.span != null && message.hasOwnProperty("span")) {
                        if (!Array.isArray(message.span))
                            return "span: array expected";
                        for (let i = 0; i < message.span.length; ++i)
                            if (!$util.isInteger(message.span[i]))
                                return "span: integer[] expected";
                    }
                    if (message.leading_comments != null && message.hasOwnProperty("leading_comments"))
                        if (!$util.isString(message.leading_comments))
                            return "leading_comments: string expected";
                    if (message.trailing_comments != null && message.hasOwnProperty("trailing_comments"))
                        if (!$util.isString(message.trailing_comments))
                            return "trailing_comments: string expected";
                    if (message.leading_detached_comments != null && message.hasOwnProperty("leading_detached_comments")) {
                        if (!Array.isArray(message.leading_detached_comments))
                            return "leading_detached_comments: array expected";
                        for (let i = 0; i < message.leading_detached_comments.length; ++i)
                            if (!$util.isString(message.leading_detached_comments[i]))
                                return "leading_detached_comments: string[] expected";
                    }
                    return null;
                };

                /**
                 * Creates a Location message from a plain object. Also converts values to their respective internal types.
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.SourceCodeInfo.Location} Location
                 */
                Location.fromObject = function fromObject(object) {
                    if (object instanceof $root.google.protobuf.SourceCodeInfo.Location)
                        return object;
                    let message = new $root.google.protobuf.SourceCodeInfo.Location();
                    if (object.path) {
                        if (!Array.isArray(object.path))
                            throw TypeError(".google.protobuf.SourceCodeInfo.Location.path: array expected");
                        message.path = [];
                        for (let i = 0; i < object.path.length; ++i)
                            message.path[i] = object.path[i] | 0;
                    }
                    if (object.span) {
                        if (!Array.isArray(object.span))
                            throw TypeError(".google.protobuf.SourceCodeInfo.Location.span: array expected");
                        message.span = [];
                        for (let i = 0; i < object.span.length; ++i)
                            message.span[i] = object.span[i] | 0;
                    }
                    if (object.leading_comments != null)
                        message.leading_comments = String(object.leading_comments);
                    if (object.trailing_comments != null)
                        message.trailing_comments = String(object.trailing_comments);
                    if (object.leading_detached_comments) {
                        if (!Array.isArray(object.leading_detached_comments))
                            throw TypeError(".google.protobuf.SourceCodeInfo.Location.leading_detached_comments: array expected");
                        message.leading_detached_comments = [];
                        for (let i = 0; i < object.leading_detached_comments.length; ++i)
                            message.leading_detached_comments[i] = String(object.leading_detached_comments[i]);
                    }
                    return message;
                };

                /**
                 * Creates a Location message from a plain object. Also converts values to their respective internal types.
                 * This is an alias of {@link google.protobuf.SourceCodeInfo.Location.fromObject}.
                 * @function
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.SourceCodeInfo.Location} Location
                 */
                Location.from = Location.fromObject;

                /**
                 * Creates a plain object from a Location message. Also converts values to other types if specified.
                 * @param {google.protobuf.SourceCodeInfo.Location} message Location
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Location.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.arrays || options.defaults) {
                        object.path = [];
                        object.span = [];
                        object.leading_detached_comments = [];
                    }
                    if (options.defaults) {
                        object.leading_comments = "";
                        object.trailing_comments = "";
                    }
                    if (message.path && message.path.length) {
                        object.path = [];
                        for (let j = 0; j < message.path.length; ++j)
                            object.path[j] = message.path[j];
                    }
                    if (message.span && message.span.length) {
                        object.span = [];
                        for (let j = 0; j < message.span.length; ++j)
                            object.span[j] = message.span[j];
                    }
                    if (message.leading_comments != null && message.hasOwnProperty("leading_comments"))
                        object.leading_comments = message.leading_comments;
                    if (message.trailing_comments != null && message.hasOwnProperty("trailing_comments"))
                        object.trailing_comments = message.trailing_comments;
                    if (message.leading_detached_comments && message.leading_detached_comments.length) {
                        object.leading_detached_comments = [];
                        for (let j = 0; j < message.leading_detached_comments.length; ++j)
                            object.leading_detached_comments[j] = message.leading_detached_comments[j];
                    }
                    return object;
                };

                /**
                 * Creates a plain object from this Location message. Also converts values to other types if specified.
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Location.prototype.toObject = function toObject(options) {
                    return this.constructor.toObject(this, options);
                };

                /**
                 * Converts this Location to JSON.
                 * @returns {Object.<string,*>} JSON object
                 */
                Location.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return Location;
            })();

            return SourceCodeInfo;
        })();

        protobuf.GeneratedCodeInfo = (function() {

            /**
             * Properties of a GeneratedCodeInfo.
             * @typedef google.protobuf.GeneratedCodeInfo$Properties
             * @type {Object}
             * @property {Array.<google.protobuf.GeneratedCodeInfo.Annotation$Properties>} [annotation] GeneratedCodeInfo annotation.
             */

            /**
             * Constructs a new GeneratedCodeInfo.
             * @exports google.protobuf.GeneratedCodeInfo
             * @constructor
             * @param {google.protobuf.GeneratedCodeInfo$Properties=} [properties] Properties to set
             */
            function GeneratedCodeInfo(properties) {
                this.annotation = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GeneratedCodeInfo annotation.
             * @type {Array.<google.protobuf.GeneratedCodeInfo.Annotation$Properties>}
             */
            GeneratedCodeInfo.prototype.annotation = $util.emptyArray;

            /**
             * Creates a new GeneratedCodeInfo instance using the specified properties.
             * @param {google.protobuf.GeneratedCodeInfo$Properties=} [properties] Properties to set
             * @returns {google.protobuf.GeneratedCodeInfo} GeneratedCodeInfo instance
             */
            GeneratedCodeInfo.create = function create(properties) {
                return new GeneratedCodeInfo(properties);
            };

            /**
             * Encodes the specified GeneratedCodeInfo message. Does not implicitly {@link google.protobuf.GeneratedCodeInfo.verify|verify} messages.
             * @param {google.protobuf.GeneratedCodeInfo$Properties} message GeneratedCodeInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GeneratedCodeInfo.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.annotation != null && message.annotation.length)
                    for (let i = 0; i < message.annotation.length; ++i)
                        $root.google.protobuf.GeneratedCodeInfo.Annotation.encode(message.annotation[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified GeneratedCodeInfo message, length delimited. Does not implicitly {@link google.protobuf.GeneratedCodeInfo.verify|verify} messages.
             * @param {google.protobuf.GeneratedCodeInfo$Properties} message GeneratedCodeInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GeneratedCodeInfo.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GeneratedCodeInfo message from the specified reader or buffer.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.GeneratedCodeInfo} GeneratedCodeInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GeneratedCodeInfo.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.GeneratedCodeInfo();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.annotation && message.annotation.length))
                            message.annotation = [];
                        message.annotation.push($root.google.protobuf.GeneratedCodeInfo.Annotation.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GeneratedCodeInfo message from the specified reader or buffer, length delimited.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.GeneratedCodeInfo} GeneratedCodeInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GeneratedCodeInfo.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GeneratedCodeInfo message.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            GeneratedCodeInfo.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.annotation != null && message.hasOwnProperty("annotation")) {
                    if (!Array.isArray(message.annotation))
                        return "annotation: array expected";
                    for (let i = 0; i < message.annotation.length; ++i) {
                        let error = $root.google.protobuf.GeneratedCodeInfo.Annotation.verify(message.annotation[i]);
                        if (error)
                            return "annotation." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a GeneratedCodeInfo message from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.GeneratedCodeInfo} GeneratedCodeInfo
             */
            GeneratedCodeInfo.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.GeneratedCodeInfo)
                    return object;
                let message = new $root.google.protobuf.GeneratedCodeInfo();
                if (object.annotation) {
                    if (!Array.isArray(object.annotation))
                        throw TypeError(".google.protobuf.GeneratedCodeInfo.annotation: array expected");
                    message.annotation = [];
                    for (let i = 0; i < object.annotation.length; ++i) {
                        if (typeof object.annotation[i] !== "object")
                            throw TypeError(".google.protobuf.GeneratedCodeInfo.annotation: object expected");
                        message.annotation[i] = $root.google.protobuf.GeneratedCodeInfo.Annotation.fromObject(object.annotation[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a GeneratedCodeInfo message from a plain object. Also converts values to their respective internal types.
             * This is an alias of {@link google.protobuf.GeneratedCodeInfo.fromObject}.
             * @function
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.GeneratedCodeInfo} GeneratedCodeInfo
             */
            GeneratedCodeInfo.from = GeneratedCodeInfo.fromObject;

            /**
             * Creates a plain object from a GeneratedCodeInfo message. Also converts values to other types if specified.
             * @param {google.protobuf.GeneratedCodeInfo} message GeneratedCodeInfo
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GeneratedCodeInfo.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.annotation = [];
                if (message.annotation && message.annotation.length) {
                    object.annotation = [];
                    for (let j = 0; j < message.annotation.length; ++j)
                        object.annotation[j] = $root.google.protobuf.GeneratedCodeInfo.Annotation.toObject(message.annotation[j], options);
                }
                return object;
            };

            /**
             * Creates a plain object from this GeneratedCodeInfo message. Also converts values to other types if specified.
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GeneratedCodeInfo.prototype.toObject = function toObject(options) {
                return this.constructor.toObject(this, options);
            };

            /**
             * Converts this GeneratedCodeInfo to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            GeneratedCodeInfo.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            GeneratedCodeInfo.Annotation = (function() {

                /**
                 * Properties of an Annotation.
                 * @typedef google.protobuf.GeneratedCodeInfo.Annotation$Properties
                 * @type {Object}
                 * @property {Array.<number>} [path] Annotation path.
                 * @property {string} [source_file] Annotation source_file.
                 * @property {number} [begin] Annotation begin.
                 * @property {number} [end] Annotation end.
                 */

                /**
                 * Constructs a new Annotation.
                 * @exports google.protobuf.GeneratedCodeInfo.Annotation
                 * @constructor
                 * @param {google.protobuf.GeneratedCodeInfo.Annotation$Properties=} [properties] Properties to set
                 */
                function Annotation(properties) {
                    this.path = [];
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Annotation path.
                 * @type {Array.<number>}
                 */
                Annotation.prototype.path = $util.emptyArray;

                /**
                 * Annotation source_file.
                 * @type {string}
                 */
                Annotation.prototype.source_file = "";

                /**
                 * Annotation begin.
                 * @type {number}
                 */
                Annotation.prototype.begin = 0;

                /**
                 * Annotation end.
                 * @type {number}
                 */
                Annotation.prototype.end = 0;

                /**
                 * Creates a new Annotation instance using the specified properties.
                 * @param {google.protobuf.GeneratedCodeInfo.Annotation$Properties=} [properties] Properties to set
                 * @returns {google.protobuf.GeneratedCodeInfo.Annotation} Annotation instance
                 */
                Annotation.create = function create(properties) {
                    return new Annotation(properties);
                };

                /**
                 * Encodes the specified Annotation message. Does not implicitly {@link google.protobuf.GeneratedCodeInfo.Annotation.verify|verify} messages.
                 * @param {google.protobuf.GeneratedCodeInfo.Annotation$Properties} message Annotation message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Annotation.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.path != null && message.path.length) {
                        writer.uint32(/* id 1, wireType 2 =*/10).fork();
                        for (let i = 0; i < message.path.length; ++i)
                            writer.int32(message.path[i]);
                        writer.ldelim();
                    }
                    if (message.source_file != null && message.hasOwnProperty("source_file"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.source_file);
                    if (message.begin != null && message.hasOwnProperty("begin"))
                        writer.uint32(/* id 3, wireType 0 =*/24).int32(message.begin);
                    if (message.end != null && message.hasOwnProperty("end"))
                        writer.uint32(/* id 4, wireType 0 =*/32).int32(message.end);
                    return writer;
                };

                /**
                 * Encodes the specified Annotation message, length delimited. Does not implicitly {@link google.protobuf.GeneratedCodeInfo.Annotation.verify|verify} messages.
                 * @param {google.protobuf.GeneratedCodeInfo.Annotation$Properties} message Annotation message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Annotation.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes an Annotation message from the specified reader or buffer.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.GeneratedCodeInfo.Annotation} Annotation
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Annotation.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.GeneratedCodeInfo.Annotation();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (!(message.path && message.path.length))
                                message.path = [];
                            if ((tag & 7) === 2) {
                                let end2 = reader.uint32() + reader.pos;
                                while (reader.pos < end2)
                                    message.path.push(reader.int32());
                            } else
                                message.path.push(reader.int32());
                            break;
                        case 2:
                            message.source_file = reader.string();
                            break;
                        case 3:
                            message.begin = reader.int32();
                            break;
                        case 4:
                            message.end = reader.int32();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes an Annotation message from the specified reader or buffer, length delimited.
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {google.protobuf.GeneratedCodeInfo.Annotation} Annotation
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Annotation.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies an Annotation message.
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {?string} `null` if valid, otherwise the reason why it is not
                 */
                Annotation.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.path != null && message.hasOwnProperty("path")) {
                        if (!Array.isArray(message.path))
                            return "path: array expected";
                        for (let i = 0; i < message.path.length; ++i)
                            if (!$util.isInteger(message.path[i]))
                                return "path: integer[] expected";
                    }
                    if (message.source_file != null && message.hasOwnProperty("source_file"))
                        if (!$util.isString(message.source_file))
                            return "source_file: string expected";
                    if (message.begin != null && message.hasOwnProperty("begin"))
                        if (!$util.isInteger(message.begin))
                            return "begin: integer expected";
                    if (message.end != null && message.hasOwnProperty("end"))
                        if (!$util.isInteger(message.end))
                            return "end: integer expected";
                    return null;
                };

                /**
                 * Creates an Annotation message from a plain object. Also converts values to their respective internal types.
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.GeneratedCodeInfo.Annotation} Annotation
                 */
                Annotation.fromObject = function fromObject(object) {
                    if (object instanceof $root.google.protobuf.GeneratedCodeInfo.Annotation)
                        return object;
                    let message = new $root.google.protobuf.GeneratedCodeInfo.Annotation();
                    if (object.path) {
                        if (!Array.isArray(object.path))
                            throw TypeError(".google.protobuf.GeneratedCodeInfo.Annotation.path: array expected");
                        message.path = [];
                        for (let i = 0; i < object.path.length; ++i)
                            message.path[i] = object.path[i] | 0;
                    }
                    if (object.source_file != null)
                        message.source_file = String(object.source_file);
                    if (object.begin != null)
                        message.begin = object.begin | 0;
                    if (object.end != null)
                        message.end = object.end | 0;
                    return message;
                };

                /**
                 * Creates an Annotation message from a plain object. Also converts values to their respective internal types.
                 * This is an alias of {@link google.protobuf.GeneratedCodeInfo.Annotation.fromObject}.
                 * @function
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.GeneratedCodeInfo.Annotation} Annotation
                 */
                Annotation.from = Annotation.fromObject;

                /**
                 * Creates a plain object from an Annotation message. Also converts values to other types if specified.
                 * @param {google.protobuf.GeneratedCodeInfo.Annotation} message Annotation
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Annotation.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.arrays || options.defaults)
                        object.path = [];
                    if (options.defaults) {
                        object.source_file = "";
                        object.begin = 0;
                        object.end = 0;
                    }
                    if (message.path && message.path.length) {
                        object.path = [];
                        for (let j = 0; j < message.path.length; ++j)
                            object.path[j] = message.path[j];
                    }
                    if (message.source_file != null && message.hasOwnProperty("source_file"))
                        object.source_file = message.source_file;
                    if (message.begin != null && message.hasOwnProperty("begin"))
                        object.begin = message.begin;
                    if (message.end != null && message.hasOwnProperty("end"))
                        object.end = message.end;
                    return object;
                };

                /**
                 * Creates a plain object from this Annotation message. Also converts values to other types if specified.
                 * @param {$protobuf.ConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Annotation.prototype.toObject = function toObject(options) {
                    return this.constructor.toObject(this, options);
                };

                /**
                 * Converts this Annotation to JSON.
                 * @returns {Object.<string,*>} JSON object
                 */
                Annotation.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return Annotation;
            })();

            return GeneratedCodeInfo;
        })();

        protobuf.Timestamp = (function() {

            /**
             * Properties of a Timestamp.
             * @typedef google.protobuf.Timestamp$Properties
             * @type {Object}
             * @property {Long} [seconds] Timestamp seconds.
             * @property {number} [nanos] Timestamp nanos.
             */

            /**
             * Constructs a new Timestamp.
             * @exports google.protobuf.Timestamp
             * @constructor
             * @param {google.protobuf.Timestamp$Properties=} [properties] Properties to set
             */
            function Timestamp(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Timestamp seconds.
             * @type {Long}
             */
            Timestamp.prototype.seconds = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Timestamp nanos.
             * @type {number}
             */
            Timestamp.prototype.nanos = 0;

            /**
             * Creates a new Timestamp instance using the specified properties.
             * @param {google.protobuf.Timestamp$Properties=} [properties] Properties to set
             * @returns {google.protobuf.Timestamp} Timestamp instance
             */
            Timestamp.create = function create(properties) {
                return new Timestamp(properties);
            };

            /**
             * Encodes the specified Timestamp message. Does not implicitly {@link google.protobuf.Timestamp.verify|verify} messages.
             * @param {google.protobuf.Timestamp$Properties} message Timestamp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Timestamp.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.seconds != null && message.hasOwnProperty("seconds"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int64(message.seconds);
                if (message.nanos != null && message.hasOwnProperty("nanos"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.nanos);
                return writer;
            };

            /**
             * Encodes the specified Timestamp message, length delimited. Does not implicitly {@link google.protobuf.Timestamp.verify|verify} messages.
             * @param {google.protobuf.Timestamp$Properties} message Timestamp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Timestamp.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Timestamp message from the specified reader or buffer.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.Timestamp} Timestamp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Timestamp.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.Timestamp();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.seconds = reader.int64();
                        break;
                    case 2:
                        message.nanos = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Timestamp message from the specified reader or buffer, length delimited.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.Timestamp} Timestamp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Timestamp.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Timestamp message.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            Timestamp.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.seconds != null && message.hasOwnProperty("seconds"))
                    if (!$util.isInteger(message.seconds) && !(message.seconds && $util.isInteger(message.seconds.low) && $util.isInteger(message.seconds.high)))
                        return "seconds: integer|Long expected";
                if (message.nanos != null && message.hasOwnProperty("nanos"))
                    if (!$util.isInteger(message.nanos))
                        return "nanos: integer expected";
                return null;
            };

            /**
             * Creates a Timestamp message from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.Timestamp} Timestamp
             */
            Timestamp.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.Timestamp)
                    return object;
                let message = new $root.google.protobuf.Timestamp();
                if (object.seconds != null)
                    if ($util.Long)
                        (message.seconds = $util.Long.fromValue(object.seconds)).unsigned = false;
                    else if (typeof object.seconds === "string")
                        message.seconds = parseInt(object.seconds, 10);
                    else if (typeof object.seconds === "number")
                        message.seconds = object.seconds;
                    else if (typeof object.seconds === "object")
                        message.seconds = new $util.LongBits(object.seconds.low >>> 0, object.seconds.high >>> 0).toNumber();
                if (object.nanos != null)
                    message.nanos = object.nanos | 0;
                return message;
            };

            /**
             * Creates a Timestamp message from a plain object. Also converts values to their respective internal types.
             * This is an alias of {@link google.protobuf.Timestamp.fromObject}.
             * @function
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.Timestamp} Timestamp
             */
            Timestamp.from = Timestamp.fromObject;

            /**
             * Creates a plain object from a Timestamp message. Also converts values to other types if specified.
             * @param {google.protobuf.Timestamp} message Timestamp
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Timestamp.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, false);
                        object.seconds = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.seconds = options.longs === String ? "0" : 0;
                    object.nanos = 0;
                }
                if (message.seconds != null && message.hasOwnProperty("seconds"))
                    if (typeof message.seconds === "number")
                        object.seconds = options.longs === String ? String(message.seconds) : message.seconds;
                    else
                        object.seconds = options.longs === String ? $util.Long.prototype.toString.call(message.seconds) : options.longs === Number ? new $util.LongBits(message.seconds.low >>> 0, message.seconds.high >>> 0).toNumber() : message.seconds;
                if (message.nanos != null && message.hasOwnProperty("nanos"))
                    object.nanos = message.nanos;
                return object;
            };

            /**
             * Creates a plain object from this Timestamp message. Also converts values to other types if specified.
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Timestamp.prototype.toObject = function toObject(options) {
                return this.constructor.toObject(this, options);
            };

            /**
             * Converts this Timestamp to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            Timestamp.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return Timestamp;
        })();

        return protobuf;
    })();

    google.api = (function() {

        /**
         * Namespace api.
         * @exports google.api
         * @namespace
         */
        const api = {};

        api.HttpRule = (function() {

            /**
             * Properties of a HttpRule.
             * @typedef google.api.HttpRule$Properties
             * @type {Object}
             * @property {string} [get] HttpRule get.
             * @property {string} [put] HttpRule put.
             * @property {string} [post] HttpRule post.
             * @property {string} ["delete"] HttpRule delete.
             * @property {string} [patch] HttpRule patch.
             * @property {google.api.CustomHttpPattern$Properties} [custom] HttpRule custom.
             * @property {string} [body] HttpRule body.
             * @property {Array.<google.api.HttpRule$Properties>} [additional_bindings] HttpRule additional_bindings.
             */

            /**
             * Constructs a new HttpRule.
             * @exports google.api.HttpRule
             * @constructor
             * @param {google.api.HttpRule$Properties=} [properties] Properties to set
             */
            function HttpRule(properties) {
                this.additional_bindings = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * HttpRule get.
             * @type {string}
             */
            HttpRule.prototype.get = "";

            /**
             * HttpRule put.
             * @type {string}
             */
            HttpRule.prototype.put = "";

            /**
             * HttpRule post.
             * @type {string}
             */
            HttpRule.prototype.post = "";

            /**
             * HttpRule delete.
             * @type {string}
             */
            HttpRule.prototype["delete"] = "";

            /**
             * HttpRule patch.
             * @type {string}
             */
            HttpRule.prototype.patch = "";

            /**
             * HttpRule custom.
             * @type {(google.api.CustomHttpPattern$Properties|null)}
             */
            HttpRule.prototype.custom = null;

            /**
             * HttpRule body.
             * @type {string}
             */
            HttpRule.prototype.body = "";

            /**
             * HttpRule additional_bindings.
             * @type {Array.<google.api.HttpRule$Properties>}
             */
            HttpRule.prototype.additional_bindings = $util.emptyArray;

            // OneOf field names bound to virtual getters and setters
            let $oneOfFields;

            /**
             * HttpRule pattern.
             * @name google.api.HttpRule#pattern
             * @type {string|undefined}
             */
            Object.defineProperty(HttpRule.prototype, "pattern", {
                get: $util.oneOfGetter($oneOfFields = ["get", "put", "post", "delete", "patch", "custom"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new HttpRule instance using the specified properties.
             * @param {google.api.HttpRule$Properties=} [properties] Properties to set
             * @returns {google.api.HttpRule} HttpRule instance
             */
            HttpRule.create = function create(properties) {
                return new HttpRule(properties);
            };

            /**
             * Encodes the specified HttpRule message. Does not implicitly {@link google.api.HttpRule.verify|verify} messages.
             * @param {google.api.HttpRule$Properties} message HttpRule message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            HttpRule.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.get != null && message.hasOwnProperty("get"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.get);
                if (message.put != null && message.hasOwnProperty("put"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.put);
                if (message.post != null && message.hasOwnProperty("post"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.post);
                if (message["delete"] != null && message.hasOwnProperty("delete"))
                    writer.uint32(/* id 5, wireType 2 =*/42).string(message["delete"]);
                if (message.patch != null && message.hasOwnProperty("patch"))
                    writer.uint32(/* id 6, wireType 2 =*/50).string(message.patch);
                if (message.body != null && message.hasOwnProperty("body"))
                    writer.uint32(/* id 7, wireType 2 =*/58).string(message.body);
                if (message.custom != null && message.hasOwnProperty("custom"))
                    $root.google.api.CustomHttpPattern.encode(message.custom, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                if (message.additional_bindings != null && message.additional_bindings.length)
                    for (let i = 0; i < message.additional_bindings.length; ++i)
                        $root.google.api.HttpRule.encode(message.additional_bindings[i], writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified HttpRule message, length delimited. Does not implicitly {@link google.api.HttpRule.verify|verify} messages.
             * @param {google.api.HttpRule$Properties} message HttpRule message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            HttpRule.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a HttpRule message from the specified reader or buffer.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.api.HttpRule} HttpRule
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            HttpRule.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.api.HttpRule();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 2:
                        message.get = reader.string();
                        break;
                    case 3:
                        message.put = reader.string();
                        break;
                    case 4:
                        message.post = reader.string();
                        break;
                    case 5:
                        message["delete"] = reader.string();
                        break;
                    case 6:
                        message.patch = reader.string();
                        break;
                    case 8:
                        message.custom = $root.google.api.CustomHttpPattern.decode(reader, reader.uint32());
                        break;
                    case 7:
                        message.body = reader.string();
                        break;
                    case 11:
                        if (!(message.additional_bindings && message.additional_bindings.length))
                            message.additional_bindings = [];
                        message.additional_bindings.push($root.google.api.HttpRule.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a HttpRule message from the specified reader or buffer, length delimited.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.api.HttpRule} HttpRule
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            HttpRule.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a HttpRule message.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            HttpRule.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                let properties = {};
                if (message.get != null && message.hasOwnProperty("get")) {
                    properties.pattern = 1;
                    if (!$util.isString(message.get))
                        return "get: string expected";
                }
                if (message.put != null && message.hasOwnProperty("put")) {
                    if (properties.pattern === 1)
                        return "pattern: multiple values";
                    properties.pattern = 1;
                    if (!$util.isString(message.put))
                        return "put: string expected";
                }
                if (message.post != null && message.hasOwnProperty("post")) {
                    if (properties.pattern === 1)
                        return "pattern: multiple values";
                    properties.pattern = 1;
                    if (!$util.isString(message.post))
                        return "post: string expected";
                }
                if (message["delete"] != null && message.hasOwnProperty("delete")) {
                    if (properties.pattern === 1)
                        return "pattern: multiple values";
                    properties.pattern = 1;
                    if (!$util.isString(message["delete"]))
                        return "delete: string expected";
                }
                if (message.patch != null && message.hasOwnProperty("patch")) {
                    if (properties.pattern === 1)
                        return "pattern: multiple values";
                    properties.pattern = 1;
                    if (!$util.isString(message.patch))
                        return "patch: string expected";
                }
                if (message.custom != null && message.hasOwnProperty("custom")) {
                    if (properties.pattern === 1)
                        return "pattern: multiple values";
                    properties.pattern = 1;
                    let error = $root.google.api.CustomHttpPattern.verify(message.custom);
                    if (error)
                        return "custom." + error;
                }
                if (message.body != null && message.hasOwnProperty("body"))
                    if (!$util.isString(message.body))
                        return "body: string expected";
                if (message.additional_bindings != null && message.hasOwnProperty("additional_bindings")) {
                    if (!Array.isArray(message.additional_bindings))
                        return "additional_bindings: array expected";
                    for (let i = 0; i < message.additional_bindings.length; ++i) {
                        let error = $root.google.api.HttpRule.verify(message.additional_bindings[i]);
                        if (error)
                            return "additional_bindings." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a HttpRule message from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {google.api.HttpRule} HttpRule
             */
            HttpRule.fromObject = function fromObject(object) {
                if (object instanceof $root.google.api.HttpRule)
                    return object;
                let message = new $root.google.api.HttpRule();
                if (object.get != null)
                    message.get = String(object.get);
                if (object.put != null)
                    message.put = String(object.put);
                if (object.post != null)
                    message.post = String(object.post);
                if (object["delete"] != null)
                    message["delete"] = String(object["delete"]);
                if (object.patch != null)
                    message.patch = String(object.patch);
                if (object.custom != null) {
                    if (typeof object.custom !== "object")
                        throw TypeError(".google.api.HttpRule.custom: object expected");
                    message.custom = $root.google.api.CustomHttpPattern.fromObject(object.custom);
                }
                if (object.body != null)
                    message.body = String(object.body);
                if (object.additional_bindings) {
                    if (!Array.isArray(object.additional_bindings))
                        throw TypeError(".google.api.HttpRule.additional_bindings: array expected");
                    message.additional_bindings = [];
                    for (let i = 0; i < object.additional_bindings.length; ++i) {
                        if (typeof object.additional_bindings[i] !== "object")
                            throw TypeError(".google.api.HttpRule.additional_bindings: object expected");
                        message.additional_bindings[i] = $root.google.api.HttpRule.fromObject(object.additional_bindings[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a HttpRule message from a plain object. Also converts values to their respective internal types.
             * This is an alias of {@link google.api.HttpRule.fromObject}.
             * @function
             * @param {Object.<string,*>} object Plain object
             * @returns {google.api.HttpRule} HttpRule
             */
            HttpRule.from = HttpRule.fromObject;

            /**
             * Creates a plain object from a HttpRule message. Also converts values to other types if specified.
             * @param {google.api.HttpRule} message HttpRule
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            HttpRule.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.additional_bindings = [];
                if (options.defaults)
                    object.body = "";
                if (message.get != null && message.hasOwnProperty("get")) {
                    object.get = message.get;
                    if (options.oneofs)
                        object.pattern = "get";
                }
                if (message.put != null && message.hasOwnProperty("put")) {
                    object.put = message.put;
                    if (options.oneofs)
                        object.pattern = "put";
                }
                if (message.post != null && message.hasOwnProperty("post")) {
                    object.post = message.post;
                    if (options.oneofs)
                        object.pattern = "post";
                }
                if (message["delete"] != null && message.hasOwnProperty("delete")) {
                    object["delete"] = message["delete"];
                    if (options.oneofs)
                        object.pattern = "delete";
                }
                if (message.patch != null && message.hasOwnProperty("patch")) {
                    object.patch = message.patch;
                    if (options.oneofs)
                        object.pattern = "patch";
                }
                if (message.body != null && message.hasOwnProperty("body"))
                    object.body = message.body;
                if (message.custom != null && message.hasOwnProperty("custom")) {
                    object.custom = $root.google.api.CustomHttpPattern.toObject(message.custom, options);
                    if (options.oneofs)
                        object.pattern = "custom";
                }
                if (message.additional_bindings && message.additional_bindings.length) {
                    object.additional_bindings = [];
                    for (let j = 0; j < message.additional_bindings.length; ++j)
                        object.additional_bindings[j] = $root.google.api.HttpRule.toObject(message.additional_bindings[j], options);
                }
                return object;
            };

            /**
             * Creates a plain object from this HttpRule message. Also converts values to other types if specified.
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            HttpRule.prototype.toObject = function toObject(options) {
                return this.constructor.toObject(this, options);
            };

            /**
             * Converts this HttpRule to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            HttpRule.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return HttpRule;
        })();

        api.CustomHttpPattern = (function() {

            /**
             * Properties of a CustomHttpPattern.
             * @typedef google.api.CustomHttpPattern$Properties
             * @type {Object}
             * @property {string} [kind] CustomHttpPattern kind.
             * @property {string} [path] CustomHttpPattern path.
             */

            /**
             * Constructs a new CustomHttpPattern.
             * @exports google.api.CustomHttpPattern
             * @constructor
             * @param {google.api.CustomHttpPattern$Properties=} [properties] Properties to set
             */
            function CustomHttpPattern(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * CustomHttpPattern kind.
             * @type {string}
             */
            CustomHttpPattern.prototype.kind = "";

            /**
             * CustomHttpPattern path.
             * @type {string}
             */
            CustomHttpPattern.prototype.path = "";

            /**
             * Creates a new CustomHttpPattern instance using the specified properties.
             * @param {google.api.CustomHttpPattern$Properties=} [properties] Properties to set
             * @returns {google.api.CustomHttpPattern} CustomHttpPattern instance
             */
            CustomHttpPattern.create = function create(properties) {
                return new CustomHttpPattern(properties);
            };

            /**
             * Encodes the specified CustomHttpPattern message. Does not implicitly {@link google.api.CustomHttpPattern.verify|verify} messages.
             * @param {google.api.CustomHttpPattern$Properties} message CustomHttpPattern message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CustomHttpPattern.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.kind != null && message.hasOwnProperty("kind"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.kind);
                if (message.path != null && message.hasOwnProperty("path"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.path);
                return writer;
            };

            /**
             * Encodes the specified CustomHttpPattern message, length delimited. Does not implicitly {@link google.api.CustomHttpPattern.verify|verify} messages.
             * @param {google.api.CustomHttpPattern$Properties} message CustomHttpPattern message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CustomHttpPattern.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a CustomHttpPattern message from the specified reader or buffer.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.api.CustomHttpPattern} CustomHttpPattern
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CustomHttpPattern.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.api.CustomHttpPattern();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.kind = reader.string();
                        break;
                    case 2:
                        message.path = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a CustomHttpPattern message from the specified reader or buffer, length delimited.
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.api.CustomHttpPattern} CustomHttpPattern
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CustomHttpPattern.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a CustomHttpPattern message.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            CustomHttpPattern.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.kind != null && message.hasOwnProperty("kind"))
                    if (!$util.isString(message.kind))
                        return "kind: string expected";
                if (message.path != null && message.hasOwnProperty("path"))
                    if (!$util.isString(message.path))
                        return "path: string expected";
                return null;
            };

            /**
             * Creates a CustomHttpPattern message from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {google.api.CustomHttpPattern} CustomHttpPattern
             */
            CustomHttpPattern.fromObject = function fromObject(object) {
                if (object instanceof $root.google.api.CustomHttpPattern)
                    return object;
                let message = new $root.google.api.CustomHttpPattern();
                if (object.kind != null)
                    message.kind = String(object.kind);
                if (object.path != null)
                    message.path = String(object.path);
                return message;
            };

            /**
             * Creates a CustomHttpPattern message from a plain object. Also converts values to their respective internal types.
             * This is an alias of {@link google.api.CustomHttpPattern.fromObject}.
             * @function
             * @param {Object.<string,*>} object Plain object
             * @returns {google.api.CustomHttpPattern} CustomHttpPattern
             */
            CustomHttpPattern.from = CustomHttpPattern.fromObject;

            /**
             * Creates a plain object from a CustomHttpPattern message. Also converts values to other types if specified.
             * @param {google.api.CustomHttpPattern} message CustomHttpPattern
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            CustomHttpPattern.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.kind = "";
                    object.path = "";
                }
                if (message.kind != null && message.hasOwnProperty("kind"))
                    object.kind = message.kind;
                if (message.path != null && message.hasOwnProperty("path"))
                    object.path = message.path;
                return object;
            };

            /**
             * Creates a plain object from this CustomHttpPattern message. Also converts values to other types if specified.
             * @param {$protobuf.ConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            CustomHttpPattern.prototype.toObject = function toObject(options) {
                return this.constructor.toObject(this, options);
            };

            /**
             * Converts this CustomHttpPattern to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            CustomHttpPattern.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return CustomHttpPattern;
        })();

        return api;
    })();

    return google;
})();

export const raftpb = $root.raftpb = (() => {

    /**
     * Namespace raftpb.
     * @exports raftpb
     * @namespace
     */
    const raftpb = {};

    /**
     * EntryType enum.
     * @name EntryType
     * @memberof raftpb
     * @enum {number}
     * @property {number} EntryNormal=0 EntryNormal value
     * @property {number} EntryConfChange=1 EntryConfChange value
     */
    raftpb.EntryType = (function() {
        const valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "EntryNormal"] = 0;
        values[valuesById[1] = "EntryConfChange"] = 1;
        return values;
    })();

    raftpb.Entry = (function() {

        /**
         * Properties of an Entry.
         * @typedef raftpb.Entry$Properties
         * @type {Object}
         * @property {Long} [Term] Entry Term.
         * @property {Long} [Index] Entry Index.
         * @property {raftpb.EntryType} [Type] Entry Type.
         * @property {Uint8Array} [Data] Entry Data.
         */

        /**
         * Constructs a new Entry.
         * @exports raftpb.Entry
         * @constructor
         * @param {raftpb.Entry$Properties=} [properties] Properties to set
         */
        function Entry(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Entry Term.
         * @type {Long}
         */
        Entry.prototype.Term = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * Entry Index.
         * @type {Long}
         */
        Entry.prototype.Index = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * Entry Type.
         * @type {raftpb.EntryType}
         */
        Entry.prototype.Type = 0;

        /**
         * Entry Data.
         * @type {Uint8Array}
         */
        Entry.prototype.Data = $util.newBuffer([]);

        /**
         * Creates a new Entry instance using the specified properties.
         * @param {raftpb.Entry$Properties=} [properties] Properties to set
         * @returns {raftpb.Entry} Entry instance
         */
        Entry.create = function create(properties) {
            return new Entry(properties);
        };

        /**
         * Encodes the specified Entry message. Does not implicitly {@link raftpb.Entry.verify|verify} messages.
         * @param {raftpb.Entry$Properties} message Entry message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Entry.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.Type != null && message.hasOwnProperty("Type"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.Type);
            if (message.Term != null && message.hasOwnProperty("Term"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.Term);
            if (message.Index != null && message.hasOwnProperty("Index"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.Index);
            if (message.Data != null && message.hasOwnProperty("Data"))
                writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.Data);
            return writer;
        };

        /**
         * Encodes the specified Entry message, length delimited. Does not implicitly {@link raftpb.Entry.verify|verify} messages.
         * @param {raftpb.Entry$Properties} message Entry message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Entry.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an Entry message from the specified reader or buffer.
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {raftpb.Entry} Entry
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Entry.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.raftpb.Entry();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 2:
                    message.Term = reader.uint64();
                    break;
                case 3:
                    message.Index = reader.uint64();
                    break;
                case 1:
                    message.Type = reader.uint32();
                    break;
                case 4:
                    message.Data = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an Entry message from the specified reader or buffer, length delimited.
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {raftpb.Entry} Entry
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Entry.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an Entry message.
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {?string} `null` if valid, otherwise the reason why it is not
         */
        Entry.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.Term != null && message.hasOwnProperty("Term"))
                if (!$util.isInteger(message.Term) && !(message.Term && $util.isInteger(message.Term.low) && $util.isInteger(message.Term.high)))
                    return "Term: integer|Long expected";
            if (message.Index != null && message.hasOwnProperty("Index"))
                if (!$util.isInteger(message.Index) && !(message.Index && $util.isInteger(message.Index.low) && $util.isInteger(message.Index.high)))
                    return "Index: integer|Long expected";
            if (message.Type != null && message.hasOwnProperty("Type"))
                switch (message.Type) {
                default:
                    return "Type: enum value expected";
                case 0:
                case 1:
                    break;
                }
            if (message.Data != null && message.hasOwnProperty("Data"))
                if (!(message.Data && typeof message.Data.length === "number" || $util.isString(message.Data)))
                    return "Data: buffer expected";
            return null;
        };

        /**
         * Creates an Entry message from a plain object. Also converts values to their respective internal types.
         * @param {Object.<string,*>} object Plain object
         * @returns {raftpb.Entry} Entry
         */
        Entry.fromObject = function fromObject(object) {
            if (object instanceof $root.raftpb.Entry)
                return object;
            let message = new $root.raftpb.Entry();
            if (object.Term != null)
                if ($util.Long)
                    (message.Term = $util.Long.fromValue(object.Term)).unsigned = true;
                else if (typeof object.Term === "string")
                    message.Term = parseInt(object.Term, 10);
                else if (typeof object.Term === "number")
                    message.Term = object.Term;
                else if (typeof object.Term === "object")
                    message.Term = new $util.LongBits(object.Term.low >>> 0, object.Term.high >>> 0).toNumber(true);
            if (object.Index != null)
                if ($util.Long)
                    (message.Index = $util.Long.fromValue(object.Index)).unsigned = true;
                else if (typeof object.Index === "string")
                    message.Index = parseInt(object.Index, 10);
                else if (typeof object.Index === "number")
                    message.Index = object.Index;
                else if (typeof object.Index === "object")
                    message.Index = new $util.LongBits(object.Index.low >>> 0, object.Index.high >>> 0).toNumber(true);
            switch (object.Type) {
            case "EntryNormal":
            case 0:
                message.Type = 0;
                break;
            case "EntryConfChange":
            case 1:
                message.Type = 1;
                break;
            }
            if (object.Data != null)
                if (typeof object.Data === "string")
                    $util.base64.decode(object.Data, message.Data = $util.newBuffer($util.base64.length(object.Data)), 0);
                else if (object.Data.length)
                    message.Data = object.Data;
            return message;
        };

        /**
         * Creates an Entry message from a plain object. Also converts values to their respective internal types.
         * This is an alias of {@link raftpb.Entry.fromObject}.
         * @function
         * @param {Object.<string,*>} object Plain object
         * @returns {raftpb.Entry} Entry
         */
        Entry.from = Entry.fromObject;

        /**
         * Creates a plain object from an Entry message. Also converts values to other types if specified.
         * @param {raftpb.Entry} message Entry
         * @param {$protobuf.ConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Entry.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.Type = options.enums === String ? "EntryNormal" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.Term = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.Term = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.Index = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.Index = options.longs === String ? "0" : 0;
                object.Data = options.bytes === String ? "" : [];
            }
            if (message.Type != null && message.hasOwnProperty("Type"))
                object.Type = options.enums === String ? $root.raftpb.EntryType[message.Type] : message.Type;
            if (message.Term != null && message.hasOwnProperty("Term"))
                if (typeof message.Term === "number")
                    object.Term = options.longs === String ? String(message.Term) : message.Term;
                else
                    object.Term = options.longs === String ? $util.Long.prototype.toString.call(message.Term) : options.longs === Number ? new $util.LongBits(message.Term.low >>> 0, message.Term.high >>> 0).toNumber(true) : message.Term;
            if (message.Index != null && message.hasOwnProperty("Index"))
                if (typeof message.Index === "number")
                    object.Index = options.longs === String ? String(message.Index) : message.Index;
                else
                    object.Index = options.longs === String ? $util.Long.prototype.toString.call(message.Index) : options.longs === Number ? new $util.LongBits(message.Index.low >>> 0, message.Index.high >>> 0).toNumber(true) : message.Index;
            if (message.Data != null && message.hasOwnProperty("Data"))
                object.Data = options.bytes === String ? $util.base64.encode(message.Data, 0, message.Data.length) : options.bytes === Array ? Array.prototype.slice.call(message.Data) : message.Data;
            return object;
        };

        /**
         * Creates a plain object from this Entry message. Also converts values to other types if specified.
         * @param {$protobuf.ConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Entry.prototype.toObject = function toObject(options) {
            return this.constructor.toObject(this, options);
        };

        /**
         * Converts this Entry to JSON.
         * @returns {Object.<string,*>} JSON object
         */
        Entry.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Entry;
    })();

    raftpb.SnapshotMetadata = (function() {

        /**
         * Properties of a SnapshotMetadata.
         * @typedef raftpb.SnapshotMetadata$Properties
         * @type {Object}
         * @property {raftpb.ConfState$Properties} [conf_state] SnapshotMetadata conf_state.
         * @property {Long} [index] SnapshotMetadata index.
         * @property {Long} [term] SnapshotMetadata term.
         */

        /**
         * Constructs a new SnapshotMetadata.
         * @exports raftpb.SnapshotMetadata
         * @constructor
         * @param {raftpb.SnapshotMetadata$Properties=} [properties] Properties to set
         */
        function SnapshotMetadata(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SnapshotMetadata conf_state.
         * @type {(raftpb.ConfState$Properties|null)}
         */
        SnapshotMetadata.prototype.conf_state = null;

        /**
         * SnapshotMetadata index.
         * @type {Long}
         */
        SnapshotMetadata.prototype.index = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * SnapshotMetadata term.
         * @type {Long}
         */
        SnapshotMetadata.prototype.term = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * Creates a new SnapshotMetadata instance using the specified properties.
         * @param {raftpb.SnapshotMetadata$Properties=} [properties] Properties to set
         * @returns {raftpb.SnapshotMetadata} SnapshotMetadata instance
         */
        SnapshotMetadata.create = function create(properties) {
            return new SnapshotMetadata(properties);
        };

        /**
         * Encodes the specified SnapshotMetadata message. Does not implicitly {@link raftpb.SnapshotMetadata.verify|verify} messages.
         * @param {raftpb.SnapshotMetadata$Properties} message SnapshotMetadata message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SnapshotMetadata.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.conf_state != null && message.hasOwnProperty("conf_state"))
                $root.raftpb.ConfState.encode(message.conf_state, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.index != null && message.hasOwnProperty("index"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.index);
            if (message.term != null && message.hasOwnProperty("term"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.term);
            return writer;
        };

        /**
         * Encodes the specified SnapshotMetadata message, length delimited. Does not implicitly {@link raftpb.SnapshotMetadata.verify|verify} messages.
         * @param {raftpb.SnapshotMetadata$Properties} message SnapshotMetadata message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SnapshotMetadata.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SnapshotMetadata message from the specified reader or buffer.
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {raftpb.SnapshotMetadata} SnapshotMetadata
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SnapshotMetadata.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.raftpb.SnapshotMetadata();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.conf_state = $root.raftpb.ConfState.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.index = reader.uint64();
                    break;
                case 3:
                    message.term = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SnapshotMetadata message from the specified reader or buffer, length delimited.
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {raftpb.SnapshotMetadata} SnapshotMetadata
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SnapshotMetadata.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SnapshotMetadata message.
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {?string} `null` if valid, otherwise the reason why it is not
         */
        SnapshotMetadata.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.conf_state != null && message.hasOwnProperty("conf_state")) {
                let error = $root.raftpb.ConfState.verify(message.conf_state);
                if (error)
                    return "conf_state." + error;
            }
            if (message.index != null && message.hasOwnProperty("index"))
                if (!$util.isInteger(message.index) && !(message.index && $util.isInteger(message.index.low) && $util.isInteger(message.index.high)))
                    return "index: integer|Long expected";
            if (message.term != null && message.hasOwnProperty("term"))
                if (!$util.isInteger(message.term) && !(message.term && $util.isInteger(message.term.low) && $util.isInteger(message.term.high)))
                    return "term: integer|Long expected";
            return null;
        };

        /**
         * Creates a SnapshotMetadata message from a plain object. Also converts values to their respective internal types.
         * @param {Object.<string,*>} object Plain object
         * @returns {raftpb.SnapshotMetadata} SnapshotMetadata
         */
        SnapshotMetadata.fromObject = function fromObject(object) {
            if (object instanceof $root.raftpb.SnapshotMetadata)
                return object;
            let message = new $root.raftpb.SnapshotMetadata();
            if (object.conf_state != null) {
                if (typeof object.conf_state !== "object")
                    throw TypeError(".raftpb.SnapshotMetadata.conf_state: object expected");
                message.conf_state = $root.raftpb.ConfState.fromObject(object.conf_state);
            }
            if (object.index != null)
                if ($util.Long)
                    (message.index = $util.Long.fromValue(object.index)).unsigned = true;
                else if (typeof object.index === "string")
                    message.index = parseInt(object.index, 10);
                else if (typeof object.index === "number")
                    message.index = object.index;
                else if (typeof object.index === "object")
                    message.index = new $util.LongBits(object.index.low >>> 0, object.index.high >>> 0).toNumber(true);
            if (object.term != null)
                if ($util.Long)
                    (message.term = $util.Long.fromValue(object.term)).unsigned = true;
                else if (typeof object.term === "string")
                    message.term = parseInt(object.term, 10);
                else if (typeof object.term === "number")
                    message.term = object.term;
                else if (typeof object.term === "object")
                    message.term = new $util.LongBits(object.term.low >>> 0, object.term.high >>> 0).toNumber(true);
            return message;
        };

        /**
         * Creates a SnapshotMetadata message from a plain object. Also converts values to their respective internal types.
         * This is an alias of {@link raftpb.SnapshotMetadata.fromObject}.
         * @function
         * @param {Object.<string,*>} object Plain object
         * @returns {raftpb.SnapshotMetadata} SnapshotMetadata
         */
        SnapshotMetadata.from = SnapshotMetadata.fromObject;

        /**
         * Creates a plain object from a SnapshotMetadata message. Also converts values to other types if specified.
         * @param {raftpb.SnapshotMetadata} message SnapshotMetadata
         * @param {$protobuf.ConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SnapshotMetadata.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.conf_state = null;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.index = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.index = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.term = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.term = options.longs === String ? "0" : 0;
            }
            if (message.conf_state != null && message.hasOwnProperty("conf_state"))
                object.conf_state = $root.raftpb.ConfState.toObject(message.conf_state, options);
            if (message.index != null && message.hasOwnProperty("index"))
                if (typeof message.index === "number")
                    object.index = options.longs === String ? String(message.index) : message.index;
                else
                    object.index = options.longs === String ? $util.Long.prototype.toString.call(message.index) : options.longs === Number ? new $util.LongBits(message.index.low >>> 0, message.index.high >>> 0).toNumber(true) : message.index;
            if (message.term != null && message.hasOwnProperty("term"))
                if (typeof message.term === "number")
                    object.term = options.longs === String ? String(message.term) : message.term;
                else
                    object.term = options.longs === String ? $util.Long.prototype.toString.call(message.term) : options.longs === Number ? new $util.LongBits(message.term.low >>> 0, message.term.high >>> 0).toNumber(true) : message.term;
            return object;
        };

        /**
         * Creates a plain object from this SnapshotMetadata message. Also converts values to other types if specified.
         * @param {$protobuf.ConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SnapshotMetadata.prototype.toObject = function toObject(options) {
            return this.constructor.toObject(this, options);
        };

        /**
         * Converts this SnapshotMetadata to JSON.
         * @returns {Object.<string,*>} JSON object
         */
        SnapshotMetadata.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return SnapshotMetadata;
    })();

    raftpb.Snapshot = (function() {

        /**
         * Properties of a Snapshot.
         * @typedef raftpb.Snapshot$Properties
         * @type {Object}
         * @property {Uint8Array} [data] Snapshot data.
         * @property {raftpb.SnapshotMetadata$Properties} [metadata] Snapshot metadata.
         */

        /**
         * Constructs a new Snapshot.
         * @exports raftpb.Snapshot
         * @constructor
         * @param {raftpb.Snapshot$Properties=} [properties] Properties to set
         */
        function Snapshot(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Snapshot data.
         * @type {Uint8Array}
         */
        Snapshot.prototype.data = $util.newBuffer([]);

        /**
         * Snapshot metadata.
         * @type {(raftpb.SnapshotMetadata$Properties|null)}
         */
        Snapshot.prototype.metadata = null;

        /**
         * Creates a new Snapshot instance using the specified properties.
         * @param {raftpb.Snapshot$Properties=} [properties] Properties to set
         * @returns {raftpb.Snapshot} Snapshot instance
         */
        Snapshot.create = function create(properties) {
            return new Snapshot(properties);
        };

        /**
         * Encodes the specified Snapshot message. Does not implicitly {@link raftpb.Snapshot.verify|verify} messages.
         * @param {raftpb.Snapshot$Properties} message Snapshot message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Snapshot.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.data != null && message.hasOwnProperty("data"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.data);
            if (message.metadata != null && message.hasOwnProperty("metadata"))
                $root.raftpb.SnapshotMetadata.encode(message.metadata, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Snapshot message, length delimited. Does not implicitly {@link raftpb.Snapshot.verify|verify} messages.
         * @param {raftpb.Snapshot$Properties} message Snapshot message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Snapshot.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Snapshot message from the specified reader or buffer.
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {raftpb.Snapshot} Snapshot
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Snapshot.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.raftpb.Snapshot();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.data = reader.bytes();
                    break;
                case 2:
                    message.metadata = $root.raftpb.SnapshotMetadata.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Snapshot message from the specified reader or buffer, length delimited.
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {raftpb.Snapshot} Snapshot
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Snapshot.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Snapshot message.
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {?string} `null` if valid, otherwise the reason why it is not
         */
        Snapshot.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.data != null && message.hasOwnProperty("data"))
                if (!(message.data && typeof message.data.length === "number" || $util.isString(message.data)))
                    return "data: buffer expected";
            if (message.metadata != null && message.hasOwnProperty("metadata")) {
                let error = $root.raftpb.SnapshotMetadata.verify(message.metadata);
                if (error)
                    return "metadata." + error;
            }
            return null;
        };

        /**
         * Creates a Snapshot message from a plain object. Also converts values to their respective internal types.
         * @param {Object.<string,*>} object Plain object
         * @returns {raftpb.Snapshot} Snapshot
         */
        Snapshot.fromObject = function fromObject(object) {
            if (object instanceof $root.raftpb.Snapshot)
                return object;
            let message = new $root.raftpb.Snapshot();
            if (object.data != null)
                if (typeof object.data === "string")
                    $util.base64.decode(object.data, message.data = $util.newBuffer($util.base64.length(object.data)), 0);
                else if (object.data.length)
                    message.data = object.data;
            if (object.metadata != null) {
                if (typeof object.metadata !== "object")
                    throw TypeError(".raftpb.Snapshot.metadata: object expected");
                message.metadata = $root.raftpb.SnapshotMetadata.fromObject(object.metadata);
            }
            return message;
        };

        /**
         * Creates a Snapshot message from a plain object. Also converts values to their respective internal types.
         * This is an alias of {@link raftpb.Snapshot.fromObject}.
         * @function
         * @param {Object.<string,*>} object Plain object
         * @returns {raftpb.Snapshot} Snapshot
         */
        Snapshot.from = Snapshot.fromObject;

        /**
         * Creates a plain object from a Snapshot message. Also converts values to other types if specified.
         * @param {raftpb.Snapshot} message Snapshot
         * @param {$protobuf.ConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Snapshot.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.data = options.bytes === String ? "" : [];
                object.metadata = null;
            }
            if (message.data != null && message.hasOwnProperty("data"))
                object.data = options.bytes === String ? $util.base64.encode(message.data, 0, message.data.length) : options.bytes === Array ? Array.prototype.slice.call(message.data) : message.data;
            if (message.metadata != null && message.hasOwnProperty("metadata"))
                object.metadata = $root.raftpb.SnapshotMetadata.toObject(message.metadata, options);
            return object;
        };

        /**
         * Creates a plain object from this Snapshot message. Also converts values to other types if specified.
         * @param {$protobuf.ConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Snapshot.prototype.toObject = function toObject(options) {
            return this.constructor.toObject(this, options);
        };

        /**
         * Converts this Snapshot to JSON.
         * @returns {Object.<string,*>} JSON object
         */
        Snapshot.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Snapshot;
    })();

    /**
     * MessageType enum.
     * @name MessageType
     * @memberof raftpb
     * @enum {number}
     * @property {number} MsgHup=0 MsgHup value
     * @property {number} MsgBeat=1 MsgBeat value
     * @property {number} MsgProp=2 MsgProp value
     * @property {number} MsgApp=3 MsgApp value
     * @property {number} MsgAppResp=4 MsgAppResp value
     * @property {number} MsgVote=5 MsgVote value
     * @property {number} MsgVoteResp=6 MsgVoteResp value
     * @property {number} MsgSnap=7 MsgSnap value
     * @property {number} MsgHeartbeat=8 MsgHeartbeat value
     * @property {number} MsgHeartbeatResp=9 MsgHeartbeatResp value
     * @property {number} MsgUnreachable=10 MsgUnreachable value
     * @property {number} MsgSnapStatus=11 MsgSnapStatus value
     * @property {number} MsgCheckQuorum=12 MsgCheckQuorum value
     * @property {number} MsgTransferLeader=13 MsgTransferLeader value
     * @property {number} MsgTimeoutNow=14 MsgTimeoutNow value
     * @property {number} MsgReadIndex=15 MsgReadIndex value
     * @property {number} MsgReadIndexResp=16 MsgReadIndexResp value
     * @property {number} MsgPreVote=17 MsgPreVote value
     * @property {number} MsgPreVoteResp=18 MsgPreVoteResp value
     */
    raftpb.MessageType = (function() {
        const valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "MsgHup"] = 0;
        values[valuesById[1] = "MsgBeat"] = 1;
        values[valuesById[2] = "MsgProp"] = 2;
        values[valuesById[3] = "MsgApp"] = 3;
        values[valuesById[4] = "MsgAppResp"] = 4;
        values[valuesById[5] = "MsgVote"] = 5;
        values[valuesById[6] = "MsgVoteResp"] = 6;
        values[valuesById[7] = "MsgSnap"] = 7;
        values[valuesById[8] = "MsgHeartbeat"] = 8;
        values[valuesById[9] = "MsgHeartbeatResp"] = 9;
        values[valuesById[10] = "MsgUnreachable"] = 10;
        values[valuesById[11] = "MsgSnapStatus"] = 11;
        values[valuesById[12] = "MsgCheckQuorum"] = 12;
        values[valuesById[13] = "MsgTransferLeader"] = 13;
        values[valuesById[14] = "MsgTimeoutNow"] = 14;
        values[valuesById[15] = "MsgReadIndex"] = 15;
        values[valuesById[16] = "MsgReadIndexResp"] = 16;
        values[valuesById[17] = "MsgPreVote"] = 17;
        values[valuesById[18] = "MsgPreVoteResp"] = 18;
        return values;
    })();

    raftpb.Message = (function() {

        /**
         * Properties of a Message.
         * @typedef raftpb.Message$Properties
         * @type {Object}
         * @property {raftpb.MessageType} [type] Message type.
         * @property {Long} [to] Message to.
         * @property {Long} [from] Message from.
         * @property {Long} [term] Message term.
         * @property {Long} [logTerm] Message logTerm.
         * @property {Long} [index] Message index.
         * @property {Array.<raftpb.Entry$Properties>} [entries] Message entries.
         * @property {Long} [commit] Message commit.
         * @property {raftpb.Snapshot$Properties} [snapshot] Message snapshot.
         * @property {boolean} [reject] Message reject.
         * @property {Long} [rejectHint] Message rejectHint.
         * @property {Uint8Array} [context] Message context.
         */

        /**
         * Constructs a new Message.
         * @exports raftpb.Message
         * @constructor
         * @param {raftpb.Message$Properties=} [properties] Properties to set
         */
        function Message(properties) {
            this.entries = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Message type.
         * @type {raftpb.MessageType}
         */
        Message.prototype.type = 0;

        /**
         * Message to.
         * @type {Long}
         */
        Message.prototype.to = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * Message from.
         * @type {Long}
         */
        Message.prototype.from = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * Message term.
         * @type {Long}
         */
        Message.prototype.term = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * Message logTerm.
         * @type {Long}
         */
        Message.prototype.logTerm = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * Message index.
         * @type {Long}
         */
        Message.prototype.index = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * Message entries.
         * @type {Array.<raftpb.Entry$Properties>}
         */
        Message.prototype.entries = $util.emptyArray;

        /**
         * Message commit.
         * @type {Long}
         */
        Message.prototype.commit = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * Message snapshot.
         * @type {(raftpb.Snapshot$Properties|null)}
         */
        Message.prototype.snapshot = null;

        /**
         * Message reject.
         * @type {boolean}
         */
        Message.prototype.reject = false;

        /**
         * Message rejectHint.
         * @type {Long}
         */
        Message.prototype.rejectHint = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * Message context.
         * @type {Uint8Array}
         */
        Message.prototype.context = $util.newBuffer([]);

        /**
         * Creates a new Message instance using the specified properties.
         * @param {raftpb.Message$Properties=} [properties] Properties to set
         * @returns {raftpb.Message} Message instance
         */
        Message.create = function create(properties) {
            return new Message(properties);
        };

        /**
         * Encodes the specified Message message. Does not implicitly {@link raftpb.Message.verify|verify} messages.
         * @param {raftpb.Message$Properties} message Message message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Message.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.type != null && message.hasOwnProperty("type"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.type);
            if (message.to != null && message.hasOwnProperty("to"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.to);
            if (message.from != null && message.hasOwnProperty("from"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.from);
            if (message.term != null && message.hasOwnProperty("term"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint64(message.term);
            if (message.logTerm != null && message.hasOwnProperty("logTerm"))
                writer.uint32(/* id 5, wireType 0 =*/40).uint64(message.logTerm);
            if (message.index != null && message.hasOwnProperty("index"))
                writer.uint32(/* id 6, wireType 0 =*/48).uint64(message.index);
            if (message.entries != null && message.entries.length)
                for (let i = 0; i < message.entries.length; ++i)
                    $root.raftpb.Entry.encode(message.entries[i], writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
            if (message.commit != null && message.hasOwnProperty("commit"))
                writer.uint32(/* id 8, wireType 0 =*/64).uint64(message.commit);
            if (message.snapshot != null && message.hasOwnProperty("snapshot"))
                $root.raftpb.Snapshot.encode(message.snapshot, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
            if (message.reject != null && message.hasOwnProperty("reject"))
                writer.uint32(/* id 10, wireType 0 =*/80).bool(message.reject);
            if (message.rejectHint != null && message.hasOwnProperty("rejectHint"))
                writer.uint32(/* id 11, wireType 0 =*/88).uint64(message.rejectHint);
            if (message.context != null && message.hasOwnProperty("context"))
                writer.uint32(/* id 12, wireType 2 =*/98).bytes(message.context);
            return writer;
        };

        /**
         * Encodes the specified Message message, length delimited. Does not implicitly {@link raftpb.Message.verify|verify} messages.
         * @param {raftpb.Message$Properties} message Message message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Message.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Message message from the specified reader or buffer.
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {raftpb.Message} Message
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Message.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.raftpb.Message();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.type = reader.uint32();
                    break;
                case 2:
                    message.to = reader.uint64();
                    break;
                case 3:
                    message.from = reader.uint64();
                    break;
                case 4:
                    message.term = reader.uint64();
                    break;
                case 5:
                    message.logTerm = reader.uint64();
                    break;
                case 6:
                    message.index = reader.uint64();
                    break;
                case 7:
                    if (!(message.entries && message.entries.length))
                        message.entries = [];
                    message.entries.push($root.raftpb.Entry.decode(reader, reader.uint32()));
                    break;
                case 8:
                    message.commit = reader.uint64();
                    break;
                case 9:
                    message.snapshot = $root.raftpb.Snapshot.decode(reader, reader.uint32());
                    break;
                case 10:
                    message.reject = reader.bool();
                    break;
                case 11:
                    message.rejectHint = reader.uint64();
                    break;
                case 12:
                    message.context = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Message message from the specified reader or buffer, length delimited.
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {raftpb.Message} Message
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Message.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Message message.
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {?string} `null` if valid, otherwise the reason why it is not
         */
        Message.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.type != null && message.hasOwnProperty("type"))
                switch (message.type) {
                default:
                    return "type: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                case 7:
                case 8:
                case 9:
                case 10:
                case 11:
                case 12:
                case 13:
                case 14:
                case 15:
                case 16:
                case 17:
                case 18:
                    break;
                }
            if (message.to != null && message.hasOwnProperty("to"))
                if (!$util.isInteger(message.to) && !(message.to && $util.isInteger(message.to.low) && $util.isInteger(message.to.high)))
                    return "to: integer|Long expected";
            if (message.from != null && message.hasOwnProperty("from"))
                if (!$util.isInteger(message.from) && !(message.from && $util.isInteger(message.from.low) && $util.isInteger(message.from.high)))
                    return "from: integer|Long expected";
            if (message.term != null && message.hasOwnProperty("term"))
                if (!$util.isInteger(message.term) && !(message.term && $util.isInteger(message.term.low) && $util.isInteger(message.term.high)))
                    return "term: integer|Long expected";
            if (message.logTerm != null && message.hasOwnProperty("logTerm"))
                if (!$util.isInteger(message.logTerm) && !(message.logTerm && $util.isInteger(message.logTerm.low) && $util.isInteger(message.logTerm.high)))
                    return "logTerm: integer|Long expected";
            if (message.index != null && message.hasOwnProperty("index"))
                if (!$util.isInteger(message.index) && !(message.index && $util.isInteger(message.index.low) && $util.isInteger(message.index.high)))
                    return "index: integer|Long expected";
            if (message.entries != null && message.hasOwnProperty("entries")) {
                if (!Array.isArray(message.entries))
                    return "entries: array expected";
                for (let i = 0; i < message.entries.length; ++i) {
                    let error = $root.raftpb.Entry.verify(message.entries[i]);
                    if (error)
                        return "entries." + error;
                }
            }
            if (message.commit != null && message.hasOwnProperty("commit"))
                if (!$util.isInteger(message.commit) && !(message.commit && $util.isInteger(message.commit.low) && $util.isInteger(message.commit.high)))
                    return "commit: integer|Long expected";
            if (message.snapshot != null && message.hasOwnProperty("snapshot")) {
                let error = $root.raftpb.Snapshot.verify(message.snapshot);
                if (error)
                    return "snapshot." + error;
            }
            if (message.reject != null && message.hasOwnProperty("reject"))
                if (typeof message.reject !== "boolean")
                    return "reject: boolean expected";
            if (message.rejectHint != null && message.hasOwnProperty("rejectHint"))
                if (!$util.isInteger(message.rejectHint) && !(message.rejectHint && $util.isInteger(message.rejectHint.low) && $util.isInteger(message.rejectHint.high)))
                    return "rejectHint: integer|Long expected";
            if (message.context != null && message.hasOwnProperty("context"))
                if (!(message.context && typeof message.context.length === "number" || $util.isString(message.context)))
                    return "context: buffer expected";
            return null;
        };

        /**
         * Creates a Message message from a plain object. Also converts values to their respective internal types.
         * @param {Object.<string,*>} object Plain object
         * @returns {raftpb.Message} Message
         */
        Message.fromObject = function fromObject(object) {
            if (object instanceof $root.raftpb.Message)
                return object;
            let message = new $root.raftpb.Message();
            switch (object.type) {
            case "MsgHup":
            case 0:
                message.type = 0;
                break;
            case "MsgBeat":
            case 1:
                message.type = 1;
                break;
            case "MsgProp":
            case 2:
                message.type = 2;
                break;
            case "MsgApp":
            case 3:
                message.type = 3;
                break;
            case "MsgAppResp":
            case 4:
                message.type = 4;
                break;
            case "MsgVote":
            case 5:
                message.type = 5;
                break;
            case "MsgVoteResp":
            case 6:
                message.type = 6;
                break;
            case "MsgSnap":
            case 7:
                message.type = 7;
                break;
            case "MsgHeartbeat":
            case 8:
                message.type = 8;
                break;
            case "MsgHeartbeatResp":
            case 9:
                message.type = 9;
                break;
            case "MsgUnreachable":
            case 10:
                message.type = 10;
                break;
            case "MsgSnapStatus":
            case 11:
                message.type = 11;
                break;
            case "MsgCheckQuorum":
            case 12:
                message.type = 12;
                break;
            case "MsgTransferLeader":
            case 13:
                message.type = 13;
                break;
            case "MsgTimeoutNow":
            case 14:
                message.type = 14;
                break;
            case "MsgReadIndex":
            case 15:
                message.type = 15;
                break;
            case "MsgReadIndexResp":
            case 16:
                message.type = 16;
                break;
            case "MsgPreVote":
            case 17:
                message.type = 17;
                break;
            case "MsgPreVoteResp":
            case 18:
                message.type = 18;
                break;
            }
            if (object.to != null)
                if ($util.Long)
                    (message.to = $util.Long.fromValue(object.to)).unsigned = true;
                else if (typeof object.to === "string")
                    message.to = parseInt(object.to, 10);
                else if (typeof object.to === "number")
                    message.to = object.to;
                else if (typeof object.to === "object")
                    message.to = new $util.LongBits(object.to.low >>> 0, object.to.high >>> 0).toNumber(true);
            if (object.from != null)
                if ($util.Long)
                    (message.from = $util.Long.fromValue(object.from)).unsigned = true;
                else if (typeof object.from === "string")
                    message.from = parseInt(object.from, 10);
                else if (typeof object.from === "number")
                    message.from = object.from;
                else if (typeof object.from === "object")
                    message.from = new $util.LongBits(object.from.low >>> 0, object.from.high >>> 0).toNumber(true);
            if (object.term != null)
                if ($util.Long)
                    (message.term = $util.Long.fromValue(object.term)).unsigned = true;
                else if (typeof object.term === "string")
                    message.term = parseInt(object.term, 10);
                else if (typeof object.term === "number")
                    message.term = object.term;
                else if (typeof object.term === "object")
                    message.term = new $util.LongBits(object.term.low >>> 0, object.term.high >>> 0).toNumber(true);
            if (object.logTerm != null)
                if ($util.Long)
                    (message.logTerm = $util.Long.fromValue(object.logTerm)).unsigned = true;
                else if (typeof object.logTerm === "string")
                    message.logTerm = parseInt(object.logTerm, 10);
                else if (typeof object.logTerm === "number")
                    message.logTerm = object.logTerm;
                else if (typeof object.logTerm === "object")
                    message.logTerm = new $util.LongBits(object.logTerm.low >>> 0, object.logTerm.high >>> 0).toNumber(true);
            if (object.index != null)
                if ($util.Long)
                    (message.index = $util.Long.fromValue(object.index)).unsigned = true;
                else if (typeof object.index === "string")
                    message.index = parseInt(object.index, 10);
                else if (typeof object.index === "number")
                    message.index = object.index;
                else if (typeof object.index === "object")
                    message.index = new $util.LongBits(object.index.low >>> 0, object.index.high >>> 0).toNumber(true);
            if (object.entries) {
                if (!Array.isArray(object.entries))
                    throw TypeError(".raftpb.Message.entries: array expected");
                message.entries = [];
                for (let i = 0; i < object.entries.length; ++i) {
                    if (typeof object.entries[i] !== "object")
                        throw TypeError(".raftpb.Message.entries: object expected");
                    message.entries[i] = $root.raftpb.Entry.fromObject(object.entries[i]);
                }
            }
            if (object.commit != null)
                if ($util.Long)
                    (message.commit = $util.Long.fromValue(object.commit)).unsigned = true;
                else if (typeof object.commit === "string")
                    message.commit = parseInt(object.commit, 10);
                else if (typeof object.commit === "number")
                    message.commit = object.commit;
                else if (typeof object.commit === "object")
                    message.commit = new $util.LongBits(object.commit.low >>> 0, object.commit.high >>> 0).toNumber(true);
            if (object.snapshot != null) {
                if (typeof object.snapshot !== "object")
                    throw TypeError(".raftpb.Message.snapshot: object expected");
                message.snapshot = $root.raftpb.Snapshot.fromObject(object.snapshot);
            }
            if (object.reject != null)
                message.reject = Boolean(object.reject);
            if (object.rejectHint != null)
                if ($util.Long)
                    (message.rejectHint = $util.Long.fromValue(object.rejectHint)).unsigned = true;
                else if (typeof object.rejectHint === "string")
                    message.rejectHint = parseInt(object.rejectHint, 10);
                else if (typeof object.rejectHint === "number")
                    message.rejectHint = object.rejectHint;
                else if (typeof object.rejectHint === "object")
                    message.rejectHint = new $util.LongBits(object.rejectHint.low >>> 0, object.rejectHint.high >>> 0).toNumber(true);
            if (object.context != null)
                if (typeof object.context === "string")
                    $util.base64.decode(object.context, message.context = $util.newBuffer($util.base64.length(object.context)), 0);
                else if (object.context.length)
                    message.context = object.context;
            return message;
        };

        /**
         * Creates a Message message from a plain object. Also converts values to their respective internal types.
         * This is an alias of {@link raftpb.Message.fromObject}.
         * @function
         * @param {Object.<string,*>} object Plain object
         * @returns {raftpb.Message} Message
         */
        Message.from = Message.fromObject;

        /**
         * Creates a plain object from a Message message. Also converts values to other types if specified.
         * @param {raftpb.Message} message Message
         * @param {$protobuf.ConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Message.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.entries = [];
            if (options.defaults) {
                object.type = options.enums === String ? "MsgHup" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.to = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.to = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.from = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.from = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.term = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.term = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.logTerm = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.logTerm = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.index = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.index = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.commit = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.commit = options.longs === String ? "0" : 0;
                object.snapshot = null;
                object.reject = false;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.rejectHint = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.rejectHint = options.longs === String ? "0" : 0;
                object.context = options.bytes === String ? "" : [];
            }
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = options.enums === String ? $root.raftpb.MessageType[message.type] : message.type;
            if (message.to != null && message.hasOwnProperty("to"))
                if (typeof message.to === "number")
                    object.to = options.longs === String ? String(message.to) : message.to;
                else
                    object.to = options.longs === String ? $util.Long.prototype.toString.call(message.to) : options.longs === Number ? new $util.LongBits(message.to.low >>> 0, message.to.high >>> 0).toNumber(true) : message.to;
            if (message.from != null && message.hasOwnProperty("from"))
                if (typeof message.from === "number")
                    object.from = options.longs === String ? String(message.from) : message.from;
                else
                    object.from = options.longs === String ? $util.Long.prototype.toString.call(message.from) : options.longs === Number ? new $util.LongBits(message.from.low >>> 0, message.from.high >>> 0).toNumber(true) : message.from;
            if (message.term != null && message.hasOwnProperty("term"))
                if (typeof message.term === "number")
                    object.term = options.longs === String ? String(message.term) : message.term;
                else
                    object.term = options.longs === String ? $util.Long.prototype.toString.call(message.term) : options.longs === Number ? new $util.LongBits(message.term.low >>> 0, message.term.high >>> 0).toNumber(true) : message.term;
            if (message.logTerm != null && message.hasOwnProperty("logTerm"))
                if (typeof message.logTerm === "number")
                    object.logTerm = options.longs === String ? String(message.logTerm) : message.logTerm;
                else
                    object.logTerm = options.longs === String ? $util.Long.prototype.toString.call(message.logTerm) : options.longs === Number ? new $util.LongBits(message.logTerm.low >>> 0, message.logTerm.high >>> 0).toNumber(true) : message.logTerm;
            if (message.index != null && message.hasOwnProperty("index"))
                if (typeof message.index === "number")
                    object.index = options.longs === String ? String(message.index) : message.index;
                else
                    object.index = options.longs === String ? $util.Long.prototype.toString.call(message.index) : options.longs === Number ? new $util.LongBits(message.index.low >>> 0, message.index.high >>> 0).toNumber(true) : message.index;
            if (message.entries && message.entries.length) {
                object.entries = [];
                for (let j = 0; j < message.entries.length; ++j)
                    object.entries[j] = $root.raftpb.Entry.toObject(message.entries[j], options);
            }
            if (message.commit != null && message.hasOwnProperty("commit"))
                if (typeof message.commit === "number")
                    object.commit = options.longs === String ? String(message.commit) : message.commit;
                else
                    object.commit = options.longs === String ? $util.Long.prototype.toString.call(message.commit) : options.longs === Number ? new $util.LongBits(message.commit.low >>> 0, message.commit.high >>> 0).toNumber(true) : message.commit;
            if (message.snapshot != null && message.hasOwnProperty("snapshot"))
                object.snapshot = $root.raftpb.Snapshot.toObject(message.snapshot, options);
            if (message.reject != null && message.hasOwnProperty("reject"))
                object.reject = message.reject;
            if (message.rejectHint != null && message.hasOwnProperty("rejectHint"))
                if (typeof message.rejectHint === "number")
                    object.rejectHint = options.longs === String ? String(message.rejectHint) : message.rejectHint;
                else
                    object.rejectHint = options.longs === String ? $util.Long.prototype.toString.call(message.rejectHint) : options.longs === Number ? new $util.LongBits(message.rejectHint.low >>> 0, message.rejectHint.high >>> 0).toNumber(true) : message.rejectHint;
            if (message.context != null && message.hasOwnProperty("context"))
                object.context = options.bytes === String ? $util.base64.encode(message.context, 0, message.context.length) : options.bytes === Array ? Array.prototype.slice.call(message.context) : message.context;
            return object;
        };

        /**
         * Creates a plain object from this Message message. Also converts values to other types if specified.
         * @param {$protobuf.ConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Message.prototype.toObject = function toObject(options) {
            return this.constructor.toObject(this, options);
        };

        /**
         * Converts this Message to JSON.
         * @returns {Object.<string,*>} JSON object
         */
        Message.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Message;
    })();

    raftpb.HardState = (function() {

        /**
         * Properties of a HardState.
         * @typedef raftpb.HardState$Properties
         * @type {Object}
         * @property {Long} [term] HardState term.
         * @property {Long} [vote] HardState vote.
         * @property {Long} [commit] HardState commit.
         */

        /**
         * Constructs a new HardState.
         * @exports raftpb.HardState
         * @constructor
         * @param {raftpb.HardState$Properties=} [properties] Properties to set
         */
        function HardState(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * HardState term.
         * @type {Long}
         */
        HardState.prototype.term = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * HardState vote.
         * @type {Long}
         */
        HardState.prototype.vote = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * HardState commit.
         * @type {Long}
         */
        HardState.prototype.commit = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * Creates a new HardState instance using the specified properties.
         * @param {raftpb.HardState$Properties=} [properties] Properties to set
         * @returns {raftpb.HardState} HardState instance
         */
        HardState.create = function create(properties) {
            return new HardState(properties);
        };

        /**
         * Encodes the specified HardState message. Does not implicitly {@link raftpb.HardState.verify|verify} messages.
         * @param {raftpb.HardState$Properties} message HardState message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        HardState.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.term != null && message.hasOwnProperty("term"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.term);
            if (message.vote != null && message.hasOwnProperty("vote"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.vote);
            if (message.commit != null && message.hasOwnProperty("commit"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.commit);
            return writer;
        };

        /**
         * Encodes the specified HardState message, length delimited. Does not implicitly {@link raftpb.HardState.verify|verify} messages.
         * @param {raftpb.HardState$Properties} message HardState message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        HardState.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a HardState message from the specified reader or buffer.
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {raftpb.HardState} HardState
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        HardState.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.raftpb.HardState();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.term = reader.uint64();
                    break;
                case 2:
                    message.vote = reader.uint64();
                    break;
                case 3:
                    message.commit = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a HardState message from the specified reader or buffer, length delimited.
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {raftpb.HardState} HardState
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        HardState.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a HardState message.
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {?string} `null` if valid, otherwise the reason why it is not
         */
        HardState.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.term != null && message.hasOwnProperty("term"))
                if (!$util.isInteger(message.term) && !(message.term && $util.isInteger(message.term.low) && $util.isInteger(message.term.high)))
                    return "term: integer|Long expected";
            if (message.vote != null && message.hasOwnProperty("vote"))
                if (!$util.isInteger(message.vote) && !(message.vote && $util.isInteger(message.vote.low) && $util.isInteger(message.vote.high)))
                    return "vote: integer|Long expected";
            if (message.commit != null && message.hasOwnProperty("commit"))
                if (!$util.isInteger(message.commit) && !(message.commit && $util.isInteger(message.commit.low) && $util.isInteger(message.commit.high)))
                    return "commit: integer|Long expected";
            return null;
        };

        /**
         * Creates a HardState message from a plain object. Also converts values to their respective internal types.
         * @param {Object.<string,*>} object Plain object
         * @returns {raftpb.HardState} HardState
         */
        HardState.fromObject = function fromObject(object) {
            if (object instanceof $root.raftpb.HardState)
                return object;
            let message = new $root.raftpb.HardState();
            if (object.term != null)
                if ($util.Long)
                    (message.term = $util.Long.fromValue(object.term)).unsigned = true;
                else if (typeof object.term === "string")
                    message.term = parseInt(object.term, 10);
                else if (typeof object.term === "number")
                    message.term = object.term;
                else if (typeof object.term === "object")
                    message.term = new $util.LongBits(object.term.low >>> 0, object.term.high >>> 0).toNumber(true);
            if (object.vote != null)
                if ($util.Long)
                    (message.vote = $util.Long.fromValue(object.vote)).unsigned = true;
                else if (typeof object.vote === "string")
                    message.vote = parseInt(object.vote, 10);
                else if (typeof object.vote === "number")
                    message.vote = object.vote;
                else if (typeof object.vote === "object")
                    message.vote = new $util.LongBits(object.vote.low >>> 0, object.vote.high >>> 0).toNumber(true);
            if (object.commit != null)
                if ($util.Long)
                    (message.commit = $util.Long.fromValue(object.commit)).unsigned = true;
                else if (typeof object.commit === "string")
                    message.commit = parseInt(object.commit, 10);
                else if (typeof object.commit === "number")
                    message.commit = object.commit;
                else if (typeof object.commit === "object")
                    message.commit = new $util.LongBits(object.commit.low >>> 0, object.commit.high >>> 0).toNumber(true);
            return message;
        };

        /**
         * Creates a HardState message from a plain object. Also converts values to their respective internal types.
         * This is an alias of {@link raftpb.HardState.fromObject}.
         * @function
         * @param {Object.<string,*>} object Plain object
         * @returns {raftpb.HardState} HardState
         */
        HardState.from = HardState.fromObject;

        /**
         * Creates a plain object from a HardState message. Also converts values to other types if specified.
         * @param {raftpb.HardState} message HardState
         * @param {$protobuf.ConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        HardState.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.term = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.term = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.vote = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.vote = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.commit = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.commit = options.longs === String ? "0" : 0;
            }
            if (message.term != null && message.hasOwnProperty("term"))
                if (typeof message.term === "number")
                    object.term = options.longs === String ? String(message.term) : message.term;
                else
                    object.term = options.longs === String ? $util.Long.prototype.toString.call(message.term) : options.longs === Number ? new $util.LongBits(message.term.low >>> 0, message.term.high >>> 0).toNumber(true) : message.term;
            if (message.vote != null && message.hasOwnProperty("vote"))
                if (typeof message.vote === "number")
                    object.vote = options.longs === String ? String(message.vote) : message.vote;
                else
                    object.vote = options.longs === String ? $util.Long.prototype.toString.call(message.vote) : options.longs === Number ? new $util.LongBits(message.vote.low >>> 0, message.vote.high >>> 0).toNumber(true) : message.vote;
            if (message.commit != null && message.hasOwnProperty("commit"))
                if (typeof message.commit === "number")
                    object.commit = options.longs === String ? String(message.commit) : message.commit;
                else
                    object.commit = options.longs === String ? $util.Long.prototype.toString.call(message.commit) : options.longs === Number ? new $util.LongBits(message.commit.low >>> 0, message.commit.high >>> 0).toNumber(true) : message.commit;
            return object;
        };

        /**
         * Creates a plain object from this HardState message. Also converts values to other types if specified.
         * @param {$protobuf.ConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        HardState.prototype.toObject = function toObject(options) {
            return this.constructor.toObject(this, options);
        };

        /**
         * Converts this HardState to JSON.
         * @returns {Object.<string,*>} JSON object
         */
        HardState.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return HardState;
    })();

    raftpb.ConfState = (function() {

        /**
         * Properties of a ConfState.
         * @typedef raftpb.ConfState$Properties
         * @type {Object}
         * @property {Array.<Long>} [nodes] ConfState nodes.
         */

        /**
         * Constructs a new ConfState.
         * @exports raftpb.ConfState
         * @constructor
         * @param {raftpb.ConfState$Properties=} [properties] Properties to set
         */
        function ConfState(properties) {
            this.nodes = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ConfState nodes.
         * @type {Array.<Long>}
         */
        ConfState.prototype.nodes = $util.emptyArray;

        /**
         * Creates a new ConfState instance using the specified properties.
         * @param {raftpb.ConfState$Properties=} [properties] Properties to set
         * @returns {raftpb.ConfState} ConfState instance
         */
        ConfState.create = function create(properties) {
            return new ConfState(properties);
        };

        /**
         * Encodes the specified ConfState message. Does not implicitly {@link raftpb.ConfState.verify|verify} messages.
         * @param {raftpb.ConfState$Properties} message ConfState message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ConfState.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.nodes != null && message.nodes.length)
                for (let i = 0; i < message.nodes.length; ++i)
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.nodes[i]);
            return writer;
        };

        /**
         * Encodes the specified ConfState message, length delimited. Does not implicitly {@link raftpb.ConfState.verify|verify} messages.
         * @param {raftpb.ConfState$Properties} message ConfState message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ConfState.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ConfState message from the specified reader or buffer.
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {raftpb.ConfState} ConfState
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ConfState.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.raftpb.ConfState();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.nodes && message.nodes.length))
                        message.nodes = [];
                    if ((tag & 7) === 2) {
                        let end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.nodes.push(reader.uint64());
                    } else
                        message.nodes.push(reader.uint64());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ConfState message from the specified reader or buffer, length delimited.
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {raftpb.ConfState} ConfState
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ConfState.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ConfState message.
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {?string} `null` if valid, otherwise the reason why it is not
         */
        ConfState.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.nodes != null && message.hasOwnProperty("nodes")) {
                if (!Array.isArray(message.nodes))
                    return "nodes: array expected";
                for (let i = 0; i < message.nodes.length; ++i)
                    if (!$util.isInteger(message.nodes[i]) && !(message.nodes[i] && $util.isInteger(message.nodes[i].low) && $util.isInteger(message.nodes[i].high)))
                        return "nodes: integer|Long[] expected";
            }
            return null;
        };

        /**
         * Creates a ConfState message from a plain object. Also converts values to their respective internal types.
         * @param {Object.<string,*>} object Plain object
         * @returns {raftpb.ConfState} ConfState
         */
        ConfState.fromObject = function fromObject(object) {
            if (object instanceof $root.raftpb.ConfState)
                return object;
            let message = new $root.raftpb.ConfState();
            if (object.nodes) {
                if (!Array.isArray(object.nodes))
                    throw TypeError(".raftpb.ConfState.nodes: array expected");
                message.nodes = [];
                for (let i = 0; i < object.nodes.length; ++i)
                    if ($util.Long)
                        (message.nodes[i] = $util.Long.fromValue(object.nodes[i])).unsigned = true;
                    else if (typeof object.nodes[i] === "string")
                        message.nodes[i] = parseInt(object.nodes[i], 10);
                    else if (typeof object.nodes[i] === "number")
                        message.nodes[i] = object.nodes[i];
                    else if (typeof object.nodes[i] === "object")
                        message.nodes[i] = new $util.LongBits(object.nodes[i].low >>> 0, object.nodes[i].high >>> 0).toNumber(true);
            }
            return message;
        };

        /**
         * Creates a ConfState message from a plain object. Also converts values to their respective internal types.
         * This is an alias of {@link raftpb.ConfState.fromObject}.
         * @function
         * @param {Object.<string,*>} object Plain object
         * @returns {raftpb.ConfState} ConfState
         */
        ConfState.from = ConfState.fromObject;

        /**
         * Creates a plain object from a ConfState message. Also converts values to other types if specified.
         * @param {raftpb.ConfState} message ConfState
         * @param {$protobuf.ConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ConfState.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.nodes = [];
            if (message.nodes && message.nodes.length) {
                object.nodes = [];
                for (let j = 0; j < message.nodes.length; ++j)
                    if (typeof message.nodes[j] === "number")
                        object.nodes[j] = options.longs === String ? String(message.nodes[j]) : message.nodes[j];
                    else
                        object.nodes[j] = options.longs === String ? $util.Long.prototype.toString.call(message.nodes[j]) : options.longs === Number ? new $util.LongBits(message.nodes[j].low >>> 0, message.nodes[j].high >>> 0).toNumber(true) : message.nodes[j];
            }
            return object;
        };

        /**
         * Creates a plain object from this ConfState message. Also converts values to other types if specified.
         * @param {$protobuf.ConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ConfState.prototype.toObject = function toObject(options) {
            return this.constructor.toObject(this, options);
        };

        /**
         * Converts this ConfState to JSON.
         * @returns {Object.<string,*>} JSON object
         */
        ConfState.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ConfState;
    })();

    /**
     * ConfChangeType enum.
     * @name ConfChangeType
     * @memberof raftpb
     * @enum {number}
     * @property {number} ConfChangeAddNode=0 ConfChangeAddNode value
     * @property {number} ConfChangeRemoveNode=1 ConfChangeRemoveNode value
     * @property {number} ConfChangeUpdateNode=2 ConfChangeUpdateNode value
     */
    raftpb.ConfChangeType = (function() {
        const valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "ConfChangeAddNode"] = 0;
        values[valuesById[1] = "ConfChangeRemoveNode"] = 1;
        values[valuesById[2] = "ConfChangeUpdateNode"] = 2;
        return values;
    })();

    raftpb.ConfChange = (function() {

        /**
         * Properties of a ConfChange.
         * @typedef raftpb.ConfChange$Properties
         * @type {Object}
         * @property {Long} [ID] ConfChange ID.
         * @property {raftpb.ConfChangeType} [Type] ConfChange Type.
         * @property {Long} [NodeID] ConfChange NodeID.
         * @property {Uint8Array} [Context] ConfChange Context.
         */

        /**
         * Constructs a new ConfChange.
         * @exports raftpb.ConfChange
         * @constructor
         * @param {raftpb.ConfChange$Properties=} [properties] Properties to set
         */
        function ConfChange(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ConfChange ID.
         * @type {Long}
         */
        ConfChange.prototype.ID = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * ConfChange Type.
         * @type {raftpb.ConfChangeType}
         */
        ConfChange.prototype.Type = 0;

        /**
         * ConfChange NodeID.
         * @type {Long}
         */
        ConfChange.prototype.NodeID = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * ConfChange Context.
         * @type {Uint8Array}
         */
        ConfChange.prototype.Context = $util.newBuffer([]);

        /**
         * Creates a new ConfChange instance using the specified properties.
         * @param {raftpb.ConfChange$Properties=} [properties] Properties to set
         * @returns {raftpb.ConfChange} ConfChange instance
         */
        ConfChange.create = function create(properties) {
            return new ConfChange(properties);
        };

        /**
         * Encodes the specified ConfChange message. Does not implicitly {@link raftpb.ConfChange.verify|verify} messages.
         * @param {raftpb.ConfChange$Properties} message ConfChange message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ConfChange.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.ID != null && message.hasOwnProperty("ID"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.ID);
            if (message.Type != null && message.hasOwnProperty("Type"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.Type);
            if (message.NodeID != null && message.hasOwnProperty("NodeID"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.NodeID);
            if (message.Context != null && message.hasOwnProperty("Context"))
                writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.Context);
            return writer;
        };

        /**
         * Encodes the specified ConfChange message, length delimited. Does not implicitly {@link raftpb.ConfChange.verify|verify} messages.
         * @param {raftpb.ConfChange$Properties} message ConfChange message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ConfChange.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ConfChange message from the specified reader or buffer.
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {raftpb.ConfChange} ConfChange
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ConfChange.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.raftpb.ConfChange();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.ID = reader.uint64();
                    break;
                case 2:
                    message.Type = reader.uint32();
                    break;
                case 3:
                    message.NodeID = reader.uint64();
                    break;
                case 4:
                    message.Context = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ConfChange message from the specified reader or buffer, length delimited.
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {raftpb.ConfChange} ConfChange
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ConfChange.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ConfChange message.
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {?string} `null` if valid, otherwise the reason why it is not
         */
        ConfChange.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.ID != null && message.hasOwnProperty("ID"))
                if (!$util.isInteger(message.ID) && !(message.ID && $util.isInteger(message.ID.low) && $util.isInteger(message.ID.high)))
                    return "ID: integer|Long expected";
            if (message.Type != null && message.hasOwnProperty("Type"))
                switch (message.Type) {
                default:
                    return "Type: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
            if (message.NodeID != null && message.hasOwnProperty("NodeID"))
                if (!$util.isInteger(message.NodeID) && !(message.NodeID && $util.isInteger(message.NodeID.low) && $util.isInteger(message.NodeID.high)))
                    return "NodeID: integer|Long expected";
            if (message.Context != null && message.hasOwnProperty("Context"))
                if (!(message.Context && typeof message.Context.length === "number" || $util.isString(message.Context)))
                    return "Context: buffer expected";
            return null;
        };

        /**
         * Creates a ConfChange message from a plain object. Also converts values to their respective internal types.
         * @param {Object.<string,*>} object Plain object
         * @returns {raftpb.ConfChange} ConfChange
         */
        ConfChange.fromObject = function fromObject(object) {
            if (object instanceof $root.raftpb.ConfChange)
                return object;
            let message = new $root.raftpb.ConfChange();
            if (object.ID != null)
                if ($util.Long)
                    (message.ID = $util.Long.fromValue(object.ID)).unsigned = true;
                else if (typeof object.ID === "string")
                    message.ID = parseInt(object.ID, 10);
                else if (typeof object.ID === "number")
                    message.ID = object.ID;
                else if (typeof object.ID === "object")
                    message.ID = new $util.LongBits(object.ID.low >>> 0, object.ID.high >>> 0).toNumber(true);
            switch (object.Type) {
            case "ConfChangeAddNode":
            case 0:
                message.Type = 0;
                break;
            case "ConfChangeRemoveNode":
            case 1:
                message.Type = 1;
                break;
            case "ConfChangeUpdateNode":
            case 2:
                message.Type = 2;
                break;
            }
            if (object.NodeID != null)
                if ($util.Long)
                    (message.NodeID = $util.Long.fromValue(object.NodeID)).unsigned = true;
                else if (typeof object.NodeID === "string")
                    message.NodeID = parseInt(object.NodeID, 10);
                else if (typeof object.NodeID === "number")
                    message.NodeID = object.NodeID;
                else if (typeof object.NodeID === "object")
                    message.NodeID = new $util.LongBits(object.NodeID.low >>> 0, object.NodeID.high >>> 0).toNumber(true);
            if (object.Context != null)
                if (typeof object.Context === "string")
                    $util.base64.decode(object.Context, message.Context = $util.newBuffer($util.base64.length(object.Context)), 0);
                else if (object.Context.length)
                    message.Context = object.Context;
            return message;
        };

        /**
         * Creates a ConfChange message from a plain object. Also converts values to their respective internal types.
         * This is an alias of {@link raftpb.ConfChange.fromObject}.
         * @function
         * @param {Object.<string,*>} object Plain object
         * @returns {raftpb.ConfChange} ConfChange
         */
        ConfChange.from = ConfChange.fromObject;

        /**
         * Creates a plain object from a ConfChange message. Also converts values to other types if specified.
         * @param {raftpb.ConfChange} message ConfChange
         * @param {$protobuf.ConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ConfChange.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.ID = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.ID = options.longs === String ? "0" : 0;
                object.Type = options.enums === String ? "ConfChangeAddNode" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.NodeID = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.NodeID = options.longs === String ? "0" : 0;
                object.Context = options.bytes === String ? "" : [];
            }
            if (message.ID != null && message.hasOwnProperty("ID"))
                if (typeof message.ID === "number")
                    object.ID = options.longs === String ? String(message.ID) : message.ID;
                else
                    object.ID = options.longs === String ? $util.Long.prototype.toString.call(message.ID) : options.longs === Number ? new $util.LongBits(message.ID.low >>> 0, message.ID.high >>> 0).toNumber(true) : message.ID;
            if (message.Type != null && message.hasOwnProperty("Type"))
                object.Type = options.enums === String ? $root.raftpb.ConfChangeType[message.Type] : message.Type;
            if (message.NodeID != null && message.hasOwnProperty("NodeID"))
                if (typeof message.NodeID === "number")
                    object.NodeID = options.longs === String ? String(message.NodeID) : message.NodeID;
                else
                    object.NodeID = options.longs === String ? $util.Long.prototype.toString.call(message.NodeID) : options.longs === Number ? new $util.LongBits(message.NodeID.low >>> 0, message.NodeID.high >>> 0).toNumber(true) : message.NodeID;
            if (message.Context != null && message.hasOwnProperty("Context"))
                object.Context = options.bytes === String ? $util.base64.encode(message.Context, 0, message.Context.length) : options.bytes === Array ? Array.prototype.slice.call(message.Context) : message.Context;
            return object;
        };

        /**
         * Creates a plain object from this ConfChange message. Also converts values to other types if specified.
         * @param {$protobuf.ConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ConfChange.prototype.toObject = function toObject(options) {
            return this.constructor.toObject(this, options);
        };

        /**
         * Converts this ConfChange to JSON.
         * @returns {Object.<string,*>} JSON object
         */
        ConfChange.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ConfChange;
    })();

    return raftpb;
})();

export { $root as default };
