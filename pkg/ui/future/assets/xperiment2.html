<!DOCTYPE html>
<html lang="en">
  <head>
    <script src="https://cdn.jsdelivr.net/npm/htmx.org@2.0.8/dist/htmx.js" integrity="sha384-ezjq8118wdwdRMj+nX4bevEi+cDLTbhLAeFF688VK8tPDGeLUe0WoY2MiBZtSla72F" crossorigin="anonymous"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/alpinejs@3.x.x/dist/cdn.min.js"></script>
    <link rel=stylesheet href=https://unpkg.com/missing.css@1.2.0>
  	<link href="https://cdn.jsdelivr.net/npm/prismjs@v1.x/themes/prism.css" rel="stylesheet" />
    <script src="https://cdn.jsdelivr.net/npm/uplot@1.6.32/dist/uPlot.iife.js"></script>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/uplot@1.6.32/dist/uPlot.min.css">
    <style>
      .u-tooltip {
        position: absolute;
        display: none;
        background: rgba(0, 0, 0, 0.9);
        color: white;
        padding: 8px;
        border-radius: 4px;
        font-size: 12px;
        pointer-events: none;
        z-index: 1000;
      }
      .u-time {
        margin-bottom: 4px;
        font-weight: bold;
      }
      .u-series {
        display: flex;
        align-items: center;
        gap: 6px;
      }
      .u-marker {
        width: 10px;
        height: 10px;
        border-radius: 50%;
        border: 2px solid;
      }
      .u-label {
        font-weight: 500;
      }
      .status {
        padding: 10px;
        margin: 10px;
        border-radius: 4px;
      }
      .status.loading {
        background: #f0f0f0;
        color: #666;
      }
      .status.error {
        background: #ffebee;
        color: #c62828;
      }
      .status.success {
        background: #e8f5e9;
        color: #2e7d32;
      }
    </style>
  </head>

  <body>
  <main>
    <section class="tool-bar margin-block">
      <form class="flex-row" x-data="{ custom: false }">
        <div>
          <label for=category>Interval:</label>
          <select id=category placeholder="Select a category..." x-on:change="custom = $event.target.value === 'Custom'">
            <option>Last 10m</option>
            <option>Last 30m</option>
            <option>Last 1h</option>
            <option>Custom</option>
          </select>
        </div>
        <div>
          <label for="start-time">Start:</label>
          <input
            type="datetime-local"
            id="start-time"
            name="start-time"
            value="" x-bind:disabled="!custom" />
        </div>
        <div>
          <label for="end-time">End:</label>
          <input
            type="datetime-local"
            id="end-time"
            name="end-time"
            value="" x-bind:disabled="!custom" />
        </div>
      </form>
    </section>
    <div id="status" class="status loading">Loading metric data...</div>
    <div id="graph1"></div>
  </main>

  <script>
// Global set of colors for graph series.
const seriesPalette = [
  "#475872",
  "#FFCD02",
  "#F16969",
  "#4E9FD1",
  "#49D990",
  "#D77FBF",
  "#87326D",
  "#A3415B",
  "#B59153",
  "#C9DB6D",
  "#203D9B",
  "#748BF2",
  "#91C8F2",
  "#FF9696",
  "#EF843C",
  "#DCCD4B",
];

// Helper function to format timestamps
function formatTime(timestamp) {
  const date = new Date(timestamp);
  return date.toLocaleTimeString('en-US', {
    hour: '2-digit',
    minute: '2-digit',
    second: '2-digit'
  });
}

// Helper function to format byte values
function formatBytes(bytes) {
  if (bytes == null) return '--';
  if (bytes >= 1e12) return (bytes / 1e12).toFixed(2) + ' TB';
  if (bytes >= 1e9) return (bytes / 1e9).toFixed(2) + ' GB';
  if (bytes >= 1e6) return (bytes / 1e6).toFixed(2) + ' MB';
  if (bytes >= 1e3) return (bytes / 1e3).toFixed(2) + ' KB';
  return bytes.toFixed(0) + ' B';
}

// Hover tooltip plugin adapted from the React component
function hoverTooltipPlugin(xFormatter, yFormatter) {
  const shiftX = 10;
  const shiftY = 10;
  let tooltipLeftOffset = 0;
  let tooltipTopOffset = 0;

  const tooltip = document.createElement("div");
  tooltip.className = "u-tooltip";

  const timeNode = document.createElement("div");
  timeNode.className = "u-time";
  tooltip.appendChild(timeNode);

  const seriesNode = document.createElement("div");
  seriesNode.className = "u-series";

  const markerNode = document.createElement("div");
  markerNode.className = "u-marker";

  const labelNode = document.createElement("div");
  labelNode.className = "u-label";

  const dataNode = document.createTextNode(`--`);

  seriesNode.appendChild(markerNode);
  seriesNode.appendChild(labelNode);
  seriesNode.appendChild(dataNode);
  tooltip.appendChild(seriesNode);

  let seriesIdx = null;
  let dataIdx = null;
  let over;
  let tooltipVisible = false;

  function showTooltip() {
    if (!tooltipVisible) {
      tooltip.style.display = "block";
      over.style.cursor = "pointer";
      tooltipVisible = true;
    }
  }

  function hideTooltip() {
    if (tooltipVisible) {
      tooltip.style.display = "none";
      over.style.cursor = null;
      tooltipVisible = false;
    }
  }

  function setTooltip(u) {
    showTooltip();

    const top = u.valToPos(u.data[seriesIdx][dataIdx], u.series[seriesIdx].scale);
    const lft = u.valToPos(u.data[0][dataIdx], "x");

    tooltip.style.top = tooltipTopOffset + top + shiftX + "px";
    tooltip.style.left = tooltipLeftOffset + lft + shiftY + "px";

    timeNode.textContent = `Time: ${xFormatter(u.data[0][dataIdx])}`;
    labelNode.textContent = `${u.series[seriesIdx].label}:`;
    dataNode.textContent = ` ${yFormatter(u.data[seriesIdx][dataIdx])}`;

    const stroke = u.series[seriesIdx].stroke;
    if (typeof stroke === "function" && stroke.length === 0) {
      markerNode.style.background = stroke(u, seriesIdx);
    } else if (typeof stroke === "string") {
      markerNode.style.borderColor = stroke;
    }
  }

  return {
    hooks: {
      ready: [
        (u) => {
          over = u.over;
          tooltipLeftOffset = parseFloat(over.style.left);
          tooltipTopOffset = parseFloat(over.style.top);
          u.root.querySelector(".u-wrap").appendChild(tooltip);
        },
      ],
      setCursor: [
        (u) => {
          const c = u.cursor;

          if (dataIdx !== c.idx) {
            dataIdx = c.idx;

            if (seriesIdx != null) setTooltip(u);
          }
        },
      ],
      setSeries: [
        (u, sidx) => {
          if (seriesIdx !== sidx) {
            seriesIdx = sidx;

            if (sidx == null) hideTooltip();
            else if (dataIdx !== null) setTooltip(u);
          }
        },
      ],
    },
  };
}

// Convert nanoseconds to milliseconds
function nanoToMilli(nanos) {
  if (typeof nanos === 'string') {
    return Math.floor(parseInt(nanos) / 1000000);
  }
  return Math.floor(nanos / 1000000);
}

// Fetch time series data from CockroachDB
async function fetchTimeSeriesData(metricName, durationMinutes = 30) {
  const endNanos = Date.now() * 1000000; // Current time in nanoseconds
  const startNanos = endNanos - (durationMinutes * 60 * 1000000000); // Duration ago in nanoseconds
  const sampleNanos = 10 * 1000000000; // 10 seconds in nanoseconds

  const request = {
    start_nanos: startNanos,
    end_nanos: endNanos,
    queries: [
      {
        name: metricName,
        downsampler: "AVG",
        source_aggregator: "SUM",
        derivative: "NONE",
        sources: []
      }
    ],
    sample_nanos: sampleNanos
  };

  // Use relative URL if we're on localhost:8080, otherwise use absolute URL
  let tsQueryUrl = 'http://localhost:8080/ts/query';
  if (window.location.hostname === 'localhost' && window.location.port === '8080') {
    tsQueryUrl = '/ts/query';
  }

  try {
    const response = await fetch(tsQueryUrl, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(request)
    });

    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }

    const data = await response.json();
    return data;
  } catch (error) {
    console.error('Error fetching time series data:', error);
    throw error;
  }
}

// Convert TimeSeriesQueryResponse to uPlot format
function convertToUPlotData(response) {
  if (!response || !response.results || response.results.length === 0) {
    return [[]];
  }

  const allData = [];

  // Process each result (we might have multiple sources)
  response.results.forEach((result, idx) => {
    if (!result.datapoints || result.datapoints.length === 0) {
      return;
    }

    // Extract timestamps and values
    const timestamps = [];
    const values = [];

    result.datapoints.forEach(dp => {
      timestamps.push(nanoToMilli(dp.timestamp_nanos));
      values.push(dp.value);
    });

    // For the first result, add timestamps as the first array
    if (idx === 0) {
      allData.push(timestamps);
    }

    allData.push(values);
  });

  return allData.length > 0 ? allData : [[]];
}

// Configure and create the uPlot chart
function createChart(data, metricName = "cr.node.sys.rss") {
  const opts = {
    width: 947,
    height: 300,
    cursor: {
      lock: true,
      focus: {
        prox: 5,
      },
    },
    legend: {
      show: true,
      isolate: true,
      markers: {
        stroke: () => null,
        fill: (u, i) => {
          const stroke = u.series[i].stroke;
          if (typeof stroke === "function" && stroke.length === 0) {
            return stroke(u, i);
          } else if (typeof stroke === "string") {
            return stroke;
          }
        },
      },
    },
    // Use milliseconds for timestamps
    ms: 1,
    series: [
      {
        label: "Time",
        value: (u, rawValue) => formatTime(rawValue),
      },
      {
        show: true,
        scale: "y",
        label: "RSS Memory",
        stroke: seriesPalette[0],
        width: 1.5,
        points: {
          show: true,
        },
        value: (u, rawValue) => formatBytes(rawValue),
        spanGaps: false,
      },
    ],
    axes: [
      {
        // X-axis (time)
        values: (u, vals) => vals.map(v => formatTime(v)),
        splits: (u, axisIdx, scaleMin, scaleMax) => {
          const range = scaleMax - scaleMin;
          const tickCount = 6;
          const tickSize = range / tickCount;
          const ticks = [];
          for (let i = 0; i <= tickCount; i++) {
            ticks.push(scaleMin + i * tickSize);
          }
          return ticks;
        },
      },
      {
        // Y-axis
        label: "Memory (RSS)",
        values: (u, vals) => vals.map(v => formatBytes(v)),
        labelGap: 5,
        scale: "y",
      },
    ],
    scales: {
      x: {
        time: false,
      },
      y: {
        auto: true,
      },
    },
    plugins: [
      hoverTooltipPlugin(formatTime, formatBytes),
    ],
    hooks: {
      setSelect: [
        (self) => {
          // Handle zooming
          if (self.select && self.select.width > 0) {
            const leftIdx = self.posToIdx(self.select.left);
            const rightIdx = self.posToIdx(self.select.left + self.select.width);
            console.log('Zoom selection:', {
              startTime: formatTime(self.data[0][leftIdx]),
              endTime: formatTime(self.data[0][rightIdx])
            });
          }
        },
      ],
    },
  };

  const graphEl = document.getElementById('graph1');
  return new uPlot(opts, data, graphEl);
}

// Update status message
function updateStatus(message, type = 'loading') {
  const statusEl = document.getElementById('status');
  statusEl.textContent = message;
  statusEl.className = `status ${type}`;
}

// Main initialization function
async function initializeChart() {
  let chart = null;
  const metricName = 'cr.node.sys.rss';

  async function fetchAndUpdate() {
    try {
      updateStatus(`Fetching ${metricName} data...`, 'loading');

      const response = await fetchTimeSeriesData(metricName, 30);
      const uPlotData = convertToUPlotData(response);

      if (uPlotData.length <= 1 || uPlotData[0].length === 0) {
        updateStatus(`No data available for ${metricName}`, 'error');
        return;
      }

      const dataPoints = uPlotData[0].length;
      updateStatus(`Displaying ${dataPoints} data points for ${metricName}`, 'success');

      if (chart) {
        // Update existing chart
        chart.setData(uPlotData);
      } else {
        // Create new chart
        chart = createChart(uPlotData, metricName);
      }
    } catch (error) {
      updateStatus(`Error: ${error.message}`, 'error');
      console.error('Failed to fetch or display data:', error);
    }
  }

  // Initial fetch
  await fetchAndUpdate();

  // Refresh data every 10 seconds
  setInterval(fetchAndUpdate, 10000);
}

// Initialize the chart when the page loads
document.addEventListener('DOMContentLoaded', () => {
  initializeChart();
});

  </script>

  <script src="https://cdn.jsdelivr.net/npm/prismjs@v1.x/components/prism-core.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/prismjs@v1.x/plugins/autoloader/prism-autoloader.min.js"></script>
  </body>
</html>