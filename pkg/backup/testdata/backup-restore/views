# Make sure that db names are rewritten in a view restored to a new db name.
new-cluster name=s
----

exec-sql
CREATE DATABASE db1;
----

exec-sql
USE db1;
----

exec-sql
CREATE SCHEMA sc1;
----

exec-sql
CREATE TYPE sc1.enum1 AS ENUM('Good');
----

exec-sql
CREATE TABLE sc1.tbl1(a INT PRIMARY KEY);
----

exec-sql
CREATE VIEW sc1.v1 AS SELECT a, 'Good'::sc1.enum1 FROM sc1.tbl1;
----

exec-sql
INSERT INTO sc1.tbl1 VALUES (123);
----

query-sql
SELECT * FROM sc1.v1;
----
123 Good

query-sql
SHOW CREATE VIEW sc1.v1;
----
sc1.v1 CREATE VIEW sc1.v1 (
	a,
	enum1
) AS SELECT a, 'Good':::sc1.enum1 FROM db1.sc1.tbl1;

exec-sql
BACKUP DATABASE db1 INTO 'nodelocal://1/test/'
----

exec-sql
DROP DATABASE db1
----

exec-sql
RESTORE DATABASE db1 FROM LATEST IN 'nodelocal://1/test/' WITH new_db_name = db1_new
----

exec-sql
USE db1_new
----

query-sql
SHOW CREATE VIEW db1_new.sc1.v1;
----
db1_new.sc1.v1 CREATE VIEW sc1.v1 (
	a,
	enum1
) AS SELECT a, 'Good':::sc1.enum1 FROM db1_new.sc1.tbl1;

# Test backing up and restoring a view that references a UDF.
# Regression test for issue #149782.

subtest restore_table_view_with_udf_skip_missing

exec-sql
CREATE DATABASE udf_db;
----

exec-sql
USE udf_db;
----

exec-sql
CREATE FUNCTION f1(x INT) RETURNS INT AS $$
BEGIN
  RETURN x + 1;
END;
$$ LANGUAGE PLpgSQL;
----

exec-sql
CREATE TABLE t (id INT PRIMARY KEY, name VARCHAR(256), money INT);
----

exec-sql
CREATE VIEW v AS SELECT id, name, f1(money) FROM t;
----

exec-sql
INSERT INTO t VALUES (1, 'test', 100);
----

query-sql
SELECT * FROM v;
----
1 test 101

exec-sql
BACKUP DATABASE udf_db INTO 'nodelocal://1/test_udf/';
----

exec-sql
DROP VIEW v;
----

exec-sql
DROP TABLE t;
----

# This should work with skip_missing_udfs option.
exec-sql
RESTORE TABLE udf_db.v, udf_db.t FROM LATEST IN 'nodelocal://1/test_udf/' WITH skip_missing_udfs;
----

query-sql
SELECT * FROM v;
----
1 test 101

exec-sql
DROP VIEW v;
----

exec-sql
DROP TABLE t;
----

exec-sql
DROP FUNCTION f1;
----

exec-sql
DROP DATABASE udf_db;
----

subtest end

subtest restore_table_view_with_udf_no_skip_missing

exec-sql
CREATE DATABASE udf_db_err;
----

exec-sql
USE udf_db_err;
----

exec-sql
CREATE FUNCTION f1(x INT) RETURNS INT AS $$
BEGIN
  RETURN x + 1;
END;
$$ LANGUAGE PLpgSQL;
----

exec-sql
CREATE TABLE t (id INT PRIMARY KEY, name VARCHAR(256), money INT);
----

exec-sql
CREATE VIEW v AS SELECT id, name, f1(money) FROM t;
----

exec-sql
INSERT INTO t VALUES (1, 'test', 100);
----

exec-sql
BACKUP DATABASE udf_db_err INTO 'nodelocal://1/test_udf_err/';
----

exec-sql
DROP VIEW v;
----

exec-sql
DROP TABLE t;
----

# This should fail without skip_missing_udfs option.
exec-sql expect-error-regex=(cannot restore table "v" without referenced function [0-9]+ \(or "skip_missing_udfs" option\))
RESTORE TABLE udf_db_err.v, udf_db_err.t FROM LATEST IN 'nodelocal://1/test_udf_err/';
----
regex matches error

exec-sql
DROP FUNCTION f1;
----

exec-sql
DROP DATABASE udf_db_err;
----

subtest end

subtest restore_database_with_view_referencing_udf

exec-sql
CREATE DATABASE udf_db2;
----

exec-sql
USE udf_db2;
----

exec-sql
CREATE FUNCTION f1(x INT) RETURNS INT AS $$
BEGIN
  RETURN x + 1;
END;
$$ LANGUAGE PLpgSQL;
----

exec-sql
CREATE TABLE t (id INT PRIMARY KEY, name VARCHAR(256), money INT);
----

exec-sql
CREATE VIEW v AS SELECT id, name, f1(money) FROM t;
----

exec-sql
INSERT INTO t VALUES (1, 'test', 100);
----

query-sql
SELECT * FROM v;
----
1 test 101

exec-sql
BACKUP DATABASE udf_db2 INTO 'nodelocal://1/test_udf2/';
----

exec-sql
DROP DATABASE udf_db2;
----

# This should restore the database with proper references between the view and the function.
exec-sql
RESTORE DATABASE udf_db2 FROM LATEST IN 'nodelocal://1/test_udf2/' WITH new_db_name='udf_db2_new';
----

exec-sql
USE udf_db2_new;
----

query-sql
SELECT * FROM v;
----
1 test 101

exec-sql
DROP DATABASE udf_db2_new;
----

subtest end
