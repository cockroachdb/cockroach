# Test backing up and restoring a database with triggers.
new-cluster name=s
----

exec-sql
CREATE DATABASE db1;
----

exec-sql
USE db1;
----

exec-sql
CREATE SCHEMA sc1;
----

exec-sql
CREATE TABLE sc1.tbl1(a INT PRIMARY KEY);
----

exec-sql
CREATE TYPE sc1.enum1 AS ENUM('Good');
----

exec-sql
CREATE SEQUENCE sc1.sq1;
----

exec-sql
CREATE FUNCTION sc1.f1() RETURNS TRIGGER LANGUAGE PLpgSQL AS $$
  DECLARE
    x INT := 0;
    foobar sc1.enum1;
  BEGIN
    SELECT a FROM sc1.tbl1;
    SELECT a FROM sc2.tbl2;
    SELECT 'Good'::sc1.enum1;
    RAISE NOTICE '%', nextval('sc1.sq1');
    RETURN NEW;
  END
$$;
----

exec-sql
CREATE PROCEDURE p_nested(a sc1.enum1) LANGUAGE PLpgSQL AS $$
  BEGIN
    RAISE NOTICE 'a: %', a;
    SELECT nextval('sc1.sq1');
  END
$$;
----

exec-sql
CREATE SCHEMA sc2;
----

exec-sql
CREATE TABLE sc2.tbl2(a INT PRIMARY KEY);
----

exec-sql
CREATE FUNCTION sc2.f2() RETURNS TRIGGER LANGUAGE PLpgSQL AS $$
  DECLARE
    x INT;
  BEGIN
    SELECT a INTO x FROM sc1.tbl1 LIMIT 1;
    RAISE NOTICE 'x: %', x;
    CALL p_nested('Good'::sc1.enum1);
    RETURN NEW;
  END
$$;
----

query-sql
WITH descs AS (
  SELECT relname, tab->'table'->'triggers' AS triggers FROM (
    SELECT relname, crdb_internal.pb_to_json('cockroach.sql.sqlbase.Descriptor', descriptor, false) AS tab
    FROM system.descriptor d INNER JOIN pg_class c ON d.id = c.oid::INT
    WHERE relname = 'tbl1' OR relname = 'tbl2'
  )
)
SELECT relname, t.name FROM descs, LATERAL (
  SELECT value->'name' FROM jsonb_array_elements(descs.triggers)
) AS t(name)
ORDER BY relname, t.name
----

exec-sql
CREATE TRIGGER tr1 AFTER INSERT ON sc1.tbl1 FOR EACH ROW EXECUTE FUNCTION sc1.f1();
----

query-sql
WITH descs AS (
  SELECT relname, tab->'table'->'triggers' AS triggers FROM (
    SELECT relname, crdb_internal.pb_to_json('cockroach.sql.sqlbase.Descriptor', descriptor, false) AS tab
    FROM system.descriptor d INNER JOIN pg_class c ON d.id = c.oid::INT
    WHERE relname = 'tbl1' OR relname = 'tbl2'
  )
)
SELECT relname, t.name FROM descs, LATERAL (
  SELECT value->'name' FROM jsonb_array_elements(descs.triggers)
) AS t(name)
ORDER BY relname, t.name
----
tbl1 "tr1"

exec-sql
CREATE TRIGGER tr2 AFTER INSERT ON sc2.tbl2 FOR EACH ROW EXECUTE FUNCTION sc2.f2();
----

query-sql
WITH descs AS (
  SELECT relname, tab->'table'->'triggers' AS triggers FROM (
    SELECT relname, crdb_internal.pb_to_json('cockroach.sql.sqlbase.Descriptor', descriptor, false) AS tab
    FROM system.descriptor d INNER JOIN pg_class c ON d.id = c.oid::INT
    WHERE relname = 'tbl1' OR relname = 'tbl2'
  )
)
SELECT relname, t.name FROM descs, LATERAL (
  SELECT value->'name' FROM jsonb_array_elements(descs.triggers)
) AS t(name)
ORDER BY relname, t.name
----
tbl1 "tr1"
tbl2 "tr2"

query-sql
SELECT nextval('sc1.sq1'::REGCLASS)
----
1

exec-sql
INSERT INTO sc1.tbl1 VALUES (123)
----
NOTICE: 2

query-sql
SELECT nextval('sc1.sq1'::REGCLASS)
----
3

exec-sql
INSERT INTO sc2.tbl2 VALUES (123)
----
NOTICE: x: 123
NOTICE: a: Good

query-sql
SELECT nextval('sc1.sq1'::REGCLASS)
----
5

exec-sql
BACKUP DATABASE db1 INTO 'nodelocal://1/test/'
----

query-sql
WITH descs AS (
  SHOW BACKUP LATEST IN 'nodelocal://1/test/'
)
SELECT database_name, parent_schema_name, object_name, object_type, is_full_cluster FROM descs
ORDER BY database_name, parent_schema_name, object_name
----
<nil> <nil> db1 database false
db1 <nil> public schema false
db1 <nil> sc1 schema false
db1 <nil> sc2 schema false
db1 public p_nested function false
db1 sc1 _enum1 type false
db1 sc1 enum1 type false
db1 sc1 f1 function false
db1 sc1 sq1 table false
db1 sc1 tbl1 table false
db1 sc2 f2 function false
db1 sc2 tbl2 table false

exec-sql
DROP DATABASE db1
----

exec-sql
RESTORE DATABASE db1 FROM LATEST IN 'nodelocal://1/test/' WITH new_db_name = db1_new
----

exec-sql
USE db1_new
----

# Make sure dependency IDs are rewritten.
# Note that technically this only tests forward-reference IDs in depended-on
# objects are rewritten. But since we have cross-references validation, so this
# also means back-references in UDF descriptor are good.
exec-sql
DROP SEQUENCE sc1.sq1
----
pq: cannot drop sequence sq1 because other objects depend on it

exec-sql
DROP FUNCTION sc1.f1
----
pq: cannot drop function "f1" because other objects ([db1_new.sc1.tbl1]) still depend on it

exec-sql
DROP FUNCTION sc2.f2
----
pq: cannot drop function "f2" because other objects ([db1_new.sc2.tbl2]) still depend on it

exec-sql
DROP PROCEDURE p_nested
----
pq: cannot drop function "p_nested" because other objects ([db1_new.sc2.tbl2, db1_new.sc2.f2]) still depend on it

exec-sql
DROP TABLE sc1.tbl1
----
pq: cannot drop table tbl1 because other objects depend on it

exec-sql
ALTER TABLE sc1.tbl1 RENAME TO tbl1_new
----
pq: cannot rename relation "db1_new.sc1.tbl1" because trigger "tr1" on table "tbl1" depends on it

exec-sql
ALTER TABLE sc1.tbl1 SET SCHEMA sc2;
----
pq: cannot set schema on relation "db1_new.sc1.tbl1" because trigger "tr1" on table "tbl1" depends on it

exec-sql
DROP TYPE sc1.enum1
----
pq: cannot drop type "enum1" because other objects ([db1_new.sc1.tbl1 db1_new.public.p_nested db1_new.sc2.tbl2 db1_new.sc2.f2]) still depend on it

query-sql
SELECT nextval('sc1.sq1'::REGCLASS)
----
6

exec-sql
INSERT INTO sc1.tbl1 VALUES (124)
----
NOTICE: 7

query-sql
SELECT nextval('sc1.sq1'::REGCLASS)
----
8

exec-sql
INSERT INTO sc2.tbl2 VALUES (124)
----
NOTICE: x: 123
NOTICE: a: Good

query-sql
SELECT nextval('sc1.sq1'::REGCLASS)
----
10

query-sql
WITH descs AS (
  SELECT relname, tab->'table'->'triggers' AS triggers FROM (
    SELECT relname, crdb_internal.pb_to_json('cockroach.sql.sqlbase.Descriptor', descriptor, false) AS tab
    FROM system.descriptor d INNER JOIN pg_class c ON d.id = c.oid::INT
    WHERE relname = 'tbl1' OR relname = 'tbl2'
  )
)
SELECT relname, t.name FROM descs, LATERAL (
  SELECT value->'name' FROM jsonb_array_elements(descs.triggers)
) AS t(name)
ORDER BY relname, t.name
----
tbl1 "tr1"
tbl2 "tr2"

# ==============================================================================
# Test a partial RESTORE, with missing routine dependencies.
# ==============================================================================

exec-sql
BACKUP DATABASE db1_new INTO 'nodelocal://1/test/'
----

exec-sql
CREATE DATABASE db2;
----

exec-sql expect-error-regex=(cannot restore table "tbl1" without referenced function [0-9]+ \(or "skip_missing_udfs" option\))
RESTORE TABLE sc1.tbl1 FROM LATEST IN 'nodelocal://1/test/' WITH into_db = 'db2';
----
regex matches error

exec-sql
RESTORE TABLE sc1.tbl1,sc2.tbl2,sc1.sq1 FROM LATEST IN 'nodelocal://1/test/' WITH into_db = 'db2', skip_missing_udfs;
----

exec-sql
USE db2
----

# The table will be restored without the trigger, since the trigger's function
# is missing.
query-sql
WITH descs AS (
  SELECT relname, tab->'table'->'triggers' AS triggers FROM (
    SELECT relname, crdb_internal.pb_to_json('cockroach.sql.sqlbase.Descriptor', descriptor, false) AS tab
    FROM system.descriptor d INNER JOIN pg_class c ON d.id = c.oid::INT
    WHERE relname = 'tbl1' OR relname = 'tbl2'
  )
)
SELECT relname, t.name FROM descs, LATERAL (
  SELECT value->'name' FROM jsonb_array_elements(descs.triggers)
) AS t(name)
ORDER BY relname, t.name
----

# Do DDLs to validate the the dependencies were properly maintained when the
# trigger was dropped by restore.
exec-sql
ALTER TABLE sc2.tbl2 RENAME TO table2;
----

exec-sql
DROP TABLE sc1.tbl1
----

exec-sql
DROP SEQUENCE sc1.sq1;
----

exec-sql
DROP DATABASE db1_new;
----

exec-sql
DROP TYPE sc1.enum1;
----

exec-sql
ALTER TABLE sc2.table2 RENAME TO tbl2;
----

# ==============================================================================
# Test backup/restore with two triggers on the same table, each referencing a
# different function that depends on a different column of another table. This
# verifies that DependedOnBy backrefs on the referenced table are correctly
# maintained when multiple triggers from the same table produce separate
# backrefs.
#
# Additionally, this test simulates the legacy format (TriggerID=0 in backrefs)
# to verify that maybeRepairTriggerBackrefs correctly handles two legacy backref
# entries from different triggers pointing to the same table.
#
# NOTE: since the test simulates the legacy format, it can be removed once we
# no longer need support with pre-26.2 backups. At that time, we can also remove
# the RepairedTriggerBackrefs post-restore logic.
# ==============================================================================

exec-sql
CREATE DATABASE db3;
----

exec-sql
USE db3;
----

exec-sql
CREATE TABLE tbl2(x INT PRIMARY KEY, y INT);
----

exec-sql
CREATE FUNCTION f1() RETURNS TRIGGER LANGUAGE PLpgSQL AS $$
  DECLARE
    v INT;
  BEGIN
    SELECT x INTO v FROM tbl2 LIMIT 1;
    RAISE NOTICE 'f1 fired';
    RETURN NEW;
  END
$$;
----

exec-sql
CREATE FUNCTION f2() RETURNS TRIGGER LANGUAGE PLpgSQL AS $$
  DECLARE
    v INT;
  BEGIN
    SELECT y INTO v FROM tbl2 LIMIT 1;
    RAISE NOTICE 'f2 fired';
    RETURN NEW;
  END
$$;
----

exec-sql
CREATE TABLE tbl1(a INT PRIMARY KEY, b INT);
----

exec-sql
CREATE TRIGGER tr1 AFTER INSERT ON tbl1 FOR EACH ROW EXECUTE FUNCTION f1();
----

exec-sql
CREATE TRIGGER tr2 AFTER UPDATE ON tbl1 FOR EACH ROW EXECUTE FUNCTION f2();
----

# Inspect backrefs on tbl2 - should show two entries with distinct TriggerIDs
# and different column references.
query-sql
SELECT COALESCE((elem->>'triggerId')::INT, 0) AS trigger_id, COALESCE(elem->>'columnIds', 'NULL') AS column_ids
FROM system.descriptor,
  LATERAL jsonb_array_elements(
    crdb_internal.pb_to_json('cockroach.sql.sqlbase.Descriptor', descriptor)->'table'->'dependedOnBy'
  ) AS elem
WHERE id = 'tbl2'::REGCLASS::OID::INT
ORDER BY trigger_id
----
1 [1]
2 [2]

# Simulate legacy format by zeroing out TriggerIDs using unsafe_upsert_descriptor.
# In older versions, trigger backrefs had TriggerID=0. This leaves two entries
# both with TriggerID=0 pointing to the same table, which tests the edge case in
# maybeRepairTriggerBackrefs.
query-sql
WITH desc_data AS (
  SELECT id, crdb_internal.pb_to_json('cockroach.sql.sqlbase.Descriptor', descriptor) AS j
  FROM system.descriptor
  WHERE id = 'tbl2'::REGCLASS::OID::INT
),
modified AS (
  SELECT id, jsonb_set(
    j,
    ARRAY['table', 'dependedOnBy'],
    (SELECT jsonb_agg(elem - 'triggerId') FROM jsonb_array_elements(j->'table'->'dependedOnBy') AS elem)
  ) AS j
  FROM desc_data
)
SELECT crdb_internal.unsafe_upsert_descriptor(id, crdb_internal.json_to_pb('cockroach.sql.sqlbase.Descriptor', j), true)
FROM modified
----
true

# Verify TriggerIDs are now zero (legacy format) in the on-disk descriptor.
query-sql
SELECT COALESCE((elem->>'triggerId')::INT, 0) AS trigger_id, COALESCE(elem->>'columnIds', 'NULL') AS column_ids
FROM system.descriptor,
  LATERAL jsonb_array_elements(
    crdb_internal.pb_to_json('cockroach.sql.sqlbase.Descriptor', descriptor)->'table'->'dependedOnBy'
  ) AS elem
WHERE id = 'tbl2'::REGCLASS::OID::INT
ORDER BY trigger_id, column_ids
----
0 [1]
0 [2]

exec-sql
BACKUP DATABASE db3 INTO 'nodelocal://1/test_two_triggers/';
----

# Don't drop db3 (its corrupted descriptors would cause DROP to fail).
# Instead, restore directly into a new database name.
exec-sql
RESTORE DATABASE db3 FROM LATEST IN 'nodelocal://1/test_two_triggers/' WITH new_db_name = db3_new;
----

exec-sql
USE db3_new;
----

# After restore, maybeRepairTriggerBackrefs should produce exactly two backrefs
# with correct TriggerIDs (not four, which would happen if the repair function
# didn't deduplicate legacy entries pointing to the same table). Column IDs are
# empty because the repair can't determine which columns each trigger references;
# empty is treated as "depends on the whole table" (overly conservative but safe).
query-sql
SELECT COALESCE((elem->>'triggerId')::INT, 0) AS trigger_id, COALESCE(elem->>'columnIds', 'NULL') AS column_ids
FROM system.descriptor,
  LATERAL jsonb_array_elements(
    crdb_internal.pb_to_json('cockroach.sql.sqlbase.Descriptor', descriptor)->'table'->'dependedOnBy'
  ) AS elem
WHERE id = 'tbl2'::REGCLASS::OID::INT
ORDER BY trigger_id
----
1 NULL
2 NULL

# Verify both triggers are present.
query-sql
WITH descs AS (
  SELECT relname, tab->'table'->'triggers' AS triggers FROM (
    SELECT relname, crdb_internal.pb_to_json('cockroach.sql.sqlbase.Descriptor', descriptor, false) AS tab
    FROM system.descriptor d INNER JOIN pg_class c ON d.id = c.oid::INT
    WHERE relname = 'tbl1'
  )
)
SELECT relname, t.name FROM descs, LATERAL (
  SELECT value->'name' FROM jsonb_array_elements(descs.triggers)
) AS t(name)
ORDER BY relname, t.name
----
tbl1 "tr1"
tbl1 "tr2"

# Verify both triggers fire.
exec-sql
INSERT INTO tbl1 VALUES (1, 10);
----
NOTICE: f1 fired

exec-sql
UPDATE tbl1 SET b = 20 WHERE a = 1;
----
NOTICE: f2 fired

# Neither function can be dropped while triggers depend on them.
exec-sql
DROP FUNCTION f1;
----
pq: cannot drop function "f1" because other objects ([db3_new.public.tbl1]) still depend on it

exec-sql
DROP FUNCTION f2;
----
pq: cannot drop function "f2" because other objects ([db3_new.public.tbl1]) still depend on it

# Drop one trigger; its function can now be dropped.
exec-sql
DROP TRIGGER tr1 ON tbl1;
----

exec-sql
DROP FUNCTION f1;
----

# The other function still can't be dropped.
exec-sql
DROP FUNCTION f2;
----
pq: cannot drop function "f2" because other objects ([db3_new.public.tbl1]) still depend on it

# Drop the second trigger; now f2 can be dropped.
exec-sql
DROP TRIGGER tr2 ON tbl1;
----

exec-sql
DROP FUNCTION f2;
----

exec-sql
DROP DATABASE db3_new;
----

# ==============================================================================
# Test that when there is only one trigger referencing a table, the legacy
# backref repair preserves the original column IDs (since with only one trigger
# we know for sure which columns are referenced).
#
# NOTE: since the test simulates the legacy format, it can be removed once we
# no longer need support with pre-26.2 backups. At that time, we can also remove
# the RepairedTriggerBackrefs post-restore logic.
# ==============================================================================

exec-sql
CREATE DATABASE db4;
----

exec-sql
USE db4;
----

exec-sql
CREATE TABLE tbl2(x INT PRIMARY KEY, y INT);
----

exec-sql
CREATE FUNCTION f1() RETURNS TRIGGER LANGUAGE PLpgSQL AS $$
  DECLARE
    v INT;
  BEGIN
    SELECT y INTO v FROM tbl2 LIMIT 1;
    RAISE NOTICE 'f1 fired';
    RETURN NEW;
  END
$$;
----

exec-sql
CREATE TABLE tbl1(a INT PRIMARY KEY);
----

exec-sql
CREATE TRIGGER tr1 AFTER INSERT ON tbl1 FOR EACH ROW EXECUTE FUNCTION f1();
----

# With only one trigger, the backref should have the correct column IDs.
query-sql
SELECT COALESCE((elem->>'triggerId')::INT, 0) AS trigger_id, COALESCE(elem->>'columnIds', 'NULL') AS column_ids
FROM system.descriptor,
  LATERAL jsonb_array_elements(
    crdb_internal.pb_to_json('cockroach.sql.sqlbase.Descriptor', descriptor)->'table'->'dependedOnBy'
  ) AS elem
WHERE id = 'tbl2'::REGCLASS::OID::INT
ORDER BY trigger_id
----
1 [2]

# Simulate legacy format by zeroing out TriggerID.
query-sql
WITH desc_data AS (
  SELECT id, crdb_internal.pb_to_json('cockroach.sql.sqlbase.Descriptor', descriptor) AS j
  FROM system.descriptor
  WHERE id = 'tbl2'::REGCLASS::OID::INT
),
modified AS (
  SELECT id, jsonb_set(
    j,
    ARRAY['table', 'dependedOnBy'],
    (SELECT jsonb_agg(elem - 'triggerId') FROM jsonb_array_elements(j->'table'->'dependedOnBy') AS elem)
  ) AS j
  FROM desc_data
)
SELECT crdb_internal.unsafe_upsert_descriptor(id, crdb_internal.json_to_pb('cockroach.sql.sqlbase.Descriptor', j), true)
FROM modified
----
true

# Verify TriggerID is now zero.
query-sql
SELECT COALESCE((elem->>'triggerId')::INT, 0) AS trigger_id, COALESCE(elem->>'columnIds', 'NULL') AS column_ids
FROM system.descriptor,
  LATERAL jsonb_array_elements(
    crdb_internal.pb_to_json('cockroach.sql.sqlbase.Descriptor', descriptor)->'table'->'dependedOnBy'
  ) AS elem
WHERE id = 'tbl2'::REGCLASS::OID::INT
ORDER BY trigger_id
----
0 [2]

exec-sql
BACKUP DATABASE db4 INTO 'nodelocal://1/test_single_trigger/';
----

exec-sql
RESTORE DATABASE db4 FROM LATEST IN 'nodelocal://1/test_single_trigger/' WITH new_db_name = db4_new;
----

exec-sql
USE db4_new;
----

# After restore, the single trigger's backref should have the correct TriggerID
# AND the original column IDs preserved (since there's only one trigger, we know
# the columns belong to it).
query-sql
SELECT COALESCE((elem->>'triggerId')::INT, 0) AS trigger_id, COALESCE(elem->>'columnIds', 'NULL') AS column_ids
FROM system.descriptor,
  LATERAL jsonb_array_elements(
    crdb_internal.pb_to_json('cockroach.sql.sqlbase.Descriptor', descriptor)->'table'->'dependedOnBy'
  ) AS elem
WHERE id = 'tbl2'::REGCLASS::OID::INT
ORDER BY trigger_id
----
1 [2]

exec-sql
DROP DATABASE db4_new;
----

# ==============================================================================
# Regression test for restoring a schema that contains both a table with
# triggers and the function referenced by one of the triggers. This is a
# table-level restore where some trigger functions ARE present in the restore
# target.
# ==============================================================================

exec-sql
CREATE DATABASE db5;
----

exec-sql
USE db5;
----

exec-sql
CREATE SCHEMA sc_keep;
----

exec-sql
CREATE SCHEMA sc_drop;
----

exec-sql
CREATE TABLE sc_keep.tbl1(a INT PRIMARY KEY, b INT);
----

exec-sql
CREATE TABLE sc_keep.tbl2(a INT, b INT);
----

exec-sql
CREATE FUNCTION sc_keep.f1() RETURNS TRIGGER LANGUAGE PLpgSQL AS $$
  BEGIN
    SELECT a FROM sc_keep.tbl2;
    RETURN NEW;
  END
$$;
----

exec-sql
CREATE FUNCTION sc_drop.f2() RETURNS TRIGGER LANGUAGE PLpgSQL AS $$
  BEGIN
    SELECT b FROM sc_keep.tbl2;
    RETURN NEW;
  END
$$;
----

# Create two triggers on the same table, each referencing a function in a
# different schema.
exec-sql
CREATE TRIGGER tr1 AFTER INSERT ON sc_keep.tbl1 FOR EACH ROW EXECUTE FUNCTION sc_keep.f1();
----

exec-sql
CREATE TRIGGER tr2 AFTER INSERT ON sc_keep.tbl1 FOR EACH ROW EXECUTE FUNCTION sc_drop.f2();
----

query-sql
WITH descs AS (
  SELECT relname, tab->'table'->'triggers' AS triggers FROM (
    SELECT relname, crdb_internal.pb_to_json('cockroach.sql.sqlbase.Descriptor', descriptor, false) AS tab
    FROM system.descriptor d INNER JOIN pg_class c ON d.id = c.oid::INT
    WHERE relname = 'tbl1'
  )
)
SELECT relname, t.name FROM descs, LATERAL (
  SELECT value->'name' FROM jsonb_array_elements(descs.triggers)
) AS t(name)
ORDER BY relname, t.name
----
tbl1 "tr1"
tbl1 "tr2"

exec-sql
BACKUP DATABASE db5 INTO 'nodelocal://1/test_schema_restore/'
----

# Drop and recreate the schemas to set up for the restore.
exec-sql
DROP SCHEMA sc_keep CASCADE;
----

exec-sql
DROP FUNCTION sc_drop.f2;
----

# Restore only sc_keep.* which includes f1 but NOT f2.
# This should work: tr1 should be kept (its function f1 is restored),
# tr2 should be dropped (its function f2 is missing).
exec-sql
RESTORE TABLE db5.sc_keep.* FROM LATEST IN 'nodelocal://1/test_schema_restore/' WITH skip_missing_udfs;
----

# Verify that tr1 is present (function was restored) and tr2 is dropped
# (function was missing).
query-sql
WITH descs AS (
  SELECT relname, tab->'table'->'triggers' AS triggers FROM (
    SELECT relname, crdb_internal.pb_to_json('cockroach.sql.sqlbase.Descriptor', descriptor, false) AS tab
    FROM system.descriptor d INNER JOIN pg_class c ON d.id = c.oid::INT
    WHERE relname = 'tbl1'
  )
)
SELECT relname, t.name FROM descs, LATERAL (
  SELECT value->'name' FROM jsonb_array_elements(descs.triggers)
) AS t(name)
ORDER BY relname, t.name
----
tbl1 "tr1"

# Verify that the trigger and function work correctly.
exec-sql
INSERT INTO sc_keep.tbl1 VALUES (1, 1);
----

# Clean up.
exec-sql
DROP TRIGGER tr1 ON sc_keep.tbl1;
----

exec-sql
DROP FUNCTION sc_keep.f1;
----

exec-sql
DROP DATABASE db5;
----

# ==============================================================================
# Test function collision detection during table-level restore. When restoring
# a schema's objects into a schema that already has the trigger's function, the
# restore should detect the collision and remap the function to the existing one
# rather than creating a duplicate.
# ==============================================================================

exec-sql
CREATE DATABASE db6;
----

exec-sql
USE db6;
----

exec-sql
CREATE SCHEMA sc;
----

exec-sql
CREATE TABLE sc.tbl1(a INT PRIMARY KEY);
----

exec-sql
CREATE FUNCTION sc.f1() RETURNS TRIGGER LANGUAGE PLpgSQL AS $$
  BEGIN
    RAISE NOTICE 'trigger fired';
    RETURN NEW;
  END
$$;
----

exec-sql
CREATE TRIGGER tr1 AFTER INSERT ON sc.tbl1 FOR EACH ROW EXECUTE FUNCTION sc.f1();
----

exec-sql
BACKUP DATABASE db6 INTO 'nodelocal://1/test_func_collision/';
----

# Drop the schema and recreate it with just the function. This means the schema
# exists (with a new ID) and the function exists (with a new ID), but the table
# is missing.
exec-sql
DROP SCHEMA sc CASCADE;
----

exec-sql
CREATE SCHEMA sc;
----

exec-sql
CREATE FUNCTION sc.f1() RETURNS TRIGGER LANGUAGE PLpgSQL AS $$
  BEGIN
    RAISE NOTICE 'trigger fired';
    RETURN NEW;
  END
$$;
----

# Restore all objects from sc. The schema and function f1 already exist in the
# target, so the restore should detect the collision and remap the function to
# the existing descriptor.
exec-sql
RESTORE TABLE db6.sc.* FROM LATEST IN 'nodelocal://1/test_func_collision/';
----

# Verify the trigger is present on the restored table.
query-sql
WITH descs AS (
  SELECT relname, tab->'table'->'triggers' AS triggers FROM (
    SELECT relname, crdb_internal.pb_to_json('cockroach.sql.sqlbase.Descriptor', descriptor, false) AS tab
    FROM system.descriptor d INNER JOIN pg_class c ON d.id = c.oid::INT
    WHERE relname = 'tbl1'
  )
)
SELECT relname, t.name FROM descs, LATERAL (
  SELECT value->'name' FROM jsonb_array_elements(descs.triggers)
) AS t(name)
ORDER BY relname, t.name
----
tbl1 "tr1"

# Verify the trigger fires correctly (the function is correctly linked).
exec-sql
INSERT INTO sc.tbl1 VALUES (1);
----
NOTICE: trigger fired

# Verify that the function can be dropped only after removing its dependents.
exec-sql
DROP FUNCTION sc.f1;
----
pq: cannot drop function "f1" because other objects ([db6.sc.tbl1]) still depend on it

# Clean up.
exec-sql
DROP TRIGGER tr1 ON sc.tbl1;
----

exec-sql
DROP FUNCTION sc.f1;
----

exec-sql
DROP DATABASE db6;
----

# ==============================================================================
# Test function collision detection with overloaded function names. When the
# target schema has both f1() (trigger function) and f1(my_enum) (regular
# function with a UDT parameter), restoring a table with a trigger calling f1()
# should correctly match to the existing f1() overload and not be confused by
# f1(my_enum).
# ==============================================================================

exec-sql
CREATE DATABASE db7;
----

exec-sql
USE db7;
----

exec-sql
CREATE SCHEMA sc;
----

exec-sql
CREATE TABLE sc.tbl1(a INT PRIMARY KEY);
----

exec-sql
CREATE FUNCTION sc.f1() RETURNS TRIGGER LANGUAGE PLpgSQL AS $$
  BEGIN
    RAISE NOTICE 'trigger fired';
    RETURN NEW;
  END
$$;
----

exec-sql
CREATE TRIGGER tr1 AFTER INSERT ON sc.tbl1 FOR EACH ROW EXECUTE FUNCTION sc.f1();
----

exec-sql
BACKUP DATABASE db7 INTO 'nodelocal://1/test_func_overload_match/';
----

# Drop the schema and recreate it with f1() (trigger) AND f1(my_enum) (regular
# function with a user-defined enum parameter). The restore should match to
# the existing f1() and ignore f1(my_enum).
exec-sql
DROP SCHEMA sc CASCADE;
----

exec-sql
CREATE SCHEMA sc;
----

exec-sql
CREATE TYPE sc.my_enum AS ENUM ('a', 'b', 'c');
----

exec-sql
CREATE FUNCTION sc.f1() RETURNS TRIGGER LANGUAGE PLpgSQL AS $$
  BEGIN
    RAISE NOTICE 'trigger fired';
    RETURN NEW;
  END
$$;
----

exec-sql
CREATE FUNCTION sc.f1(a sc.my_enum) RETURNS TEXT LANGUAGE PLpgSQL AS $$
  BEGIN
    RETURN a::TEXT;
  END
$$;
----

exec-sql
RESTORE TABLE db7.sc.* FROM LATEST IN 'nodelocal://1/test_func_overload_match/';
----

# Verify the trigger is present on the restored table.
query-sql
WITH descs AS (
  SELECT relname, tab->'table'->'triggers' AS triggers FROM (
    SELECT relname, crdb_internal.pb_to_json('cockroach.sql.sqlbase.Descriptor', descriptor, false) AS tab
    FROM system.descriptor d INNER JOIN pg_class c ON d.id = c.oid::INT
    WHERE relname = 'tbl1'
  )
)
SELECT relname, t.name FROM descs, LATERAL (
  SELECT value->'name' FROM jsonb_array_elements(descs.triggers)
) AS t(name)
ORDER BY relname, t.name
----
tbl1 "tr1"

# Verify the trigger fires correctly.
exec-sql
INSERT INTO sc.tbl1 VALUES (1);
----
NOTICE: trigger fired

# Verify both function overloads exist in the schema descriptor: f1() and
# f1(my_enum). We query the schema descriptor's functions map and check the
# number of arguments for each overload.
let $db7_sc_id
WITH db_id AS (
  SELECT id FROM system.namespace WHERE name = 'db7'
),
schema_id AS (
  SELECT ns.id
  FROM system.namespace AS ns
  JOIN db_id ON ns."parentID" = db_id.id
  WHERE ns.name = 'sc'
)
SELECT id FROM schema_id;
----

query-sql
WITH to_json AS (
    SELECT
      crdb_internal.pb_to_json(
        'cockroach.sql.sqlbase.Descriptor',
        descriptor,
        false
      ) AS d
    FROM system.descriptor
    WHERE id = $db7_sc_id
),
sigs AS (
  SELECT jsonb_array_elements(d->'schema'->'functions'->'f1'->'signatures') AS sig
  FROM to_json
)
SELECT
  COALESCE(jsonb_array_length(sig->'argTypes'), 0) AS num_args
FROM sigs
ORDER BY num_args;
----
0
1

# The f1() trigger function can't be dropped while the trigger depends on it.
exec-sql
DROP FUNCTION sc.f1();
----
pq: cannot drop function "f1" because other objects ([db7.sc.tbl1]) still depend on it

# The f1(my_enum) overload can be dropped independently.
exec-sql
DROP FUNCTION sc.f1(sc.my_enum);
----

# Clean up.
exec-sql
DROP TRIGGER tr1 ON sc.tbl1;
----

exec-sql
DROP FUNCTION sc.f1;
----

exec-sql
DROP DATABASE db7;
----

# ==============================================================================
# Test that when the target schema has a function with the same name but a
# different signature (f1(int) but not f1()), restoring a table with a trigger
# calling f1() should NOT match the existing f1(int). Instead, it should create
# a new f1() overload.
# ==============================================================================

exec-sql
CREATE DATABASE db8;
----

exec-sql
USE db8;
----

exec-sql
CREATE SCHEMA sc;
----

exec-sql
CREATE TABLE sc.tbl1(a INT PRIMARY KEY);
----

exec-sql
CREATE FUNCTION sc.f1() RETURNS TRIGGER LANGUAGE PLpgSQL AS $$
  BEGIN
    RAISE NOTICE 'trigger fired';
    RETURN NEW;
  END
$$;
----

exec-sql
CREATE TRIGGER tr1 AFTER INSERT ON sc.tbl1 FOR EACH ROW EXECUTE FUNCTION sc.f1();
----

exec-sql
BACKUP DATABASE db8 INTO 'nodelocal://1/test_func_no_sig_match/';
----

# Drop the schema and recreate it with only f1(int) (a regular function, not a
# trigger function). The restore should see "f1" in the schema's function map
# but find no matching signature, so it should create the trigger function f1()
# as a new overload.
exec-sql
DROP SCHEMA sc CASCADE;
----

exec-sql
CREATE SCHEMA sc;
----

exec-sql
CREATE FUNCTION sc.f1(a INT) RETURNS INT LANGUAGE PLpgSQL AS $$
  BEGIN
    RETURN a + 1;
  END
$$;
----

exec-sql
RESTORE TABLE db8.sc.* FROM LATEST IN 'nodelocal://1/test_func_no_sig_match/';
----

# Verify the trigger is present on the restored table.
query-sql
WITH descs AS (
  SELECT relname, tab->'table'->'triggers' AS triggers FROM (
    SELECT relname, crdb_internal.pb_to_json('cockroach.sql.sqlbase.Descriptor', descriptor, false) AS tab
    FROM system.descriptor d INNER JOIN pg_class c ON d.id = c.oid::INT
    WHERE relname = 'tbl1'
  )
)
SELECT relname, t.name FROM descs, LATERAL (
  SELECT value->'name' FROM jsonb_array_elements(descs.triggers)
) AS t(name)
ORDER BY relname, t.name
----
tbl1 "tr1"

# Verify the trigger fires correctly.
exec-sql
INSERT INTO sc.tbl1 VALUES (1);
----
NOTICE: trigger fired

# Verify both overloads exist in the schema descriptor: the restored f1() and
# the pre-existing f1(int).
let $db8_sc_id
WITH db_id AS (
  SELECT id FROM system.namespace WHERE name = 'db8'
),
schema_id AS (
  SELECT ns.id
  FROM system.namespace AS ns
  JOIN db_id ON ns."parentID" = db_id.id
  WHERE ns.name = 'sc'
)
SELECT id FROM schema_id;
----

query-sql
WITH to_json AS (
    SELECT
      crdb_internal.pb_to_json(
        'cockroach.sql.sqlbase.Descriptor',
        descriptor,
        false
      ) AS d
    FROM system.descriptor
    WHERE id = $db8_sc_id
),
sigs AS (
  SELECT jsonb_array_elements(d->'schema'->'functions'->'f1'->'signatures') AS sig
  FROM to_json
)
SELECT
  COALESCE(jsonb_array_length(sig->'argTypes'), 0) AS num_args,
  CASE
    WHEN jsonb_array_length(sig->'argTypes') > 0
    THEN (SELECT string_agg(elem->>'oid', ', ' ORDER BY ordinality) FROM jsonb_array_elements(sig->'argTypes') WITH ORDINALITY AS t(elem, ordinality))
    ELSE 'none'
  END AS arg_oids
FROM sigs
ORDER BY num_args;
----
0 none
1 20

# The restored f1() can't be dropped while the trigger depends on it.
exec-sql
DROP FUNCTION sc.f1();
----
pq: cannot drop function "f1" because other objects ([db8.sc.tbl1]) still depend on it

# The pre-existing f1(int) can be dropped independently.
exec-sql
DROP FUNCTION sc.f1(INT);
----

# Clean up.
exec-sql
DROP TRIGGER tr1 ON sc.tbl1;
----

exec-sql
DROP FUNCTION sc.f1;
----

exec-sql
DROP DATABASE db8;
----
