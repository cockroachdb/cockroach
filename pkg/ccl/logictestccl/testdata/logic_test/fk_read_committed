statement ok
CREATE TABLE jars (j INT PRIMARY KEY)

statement ok
CREATE TABLE cookies (c INT PRIMARY KEY, j INT REFERENCES jars (j), FAMILY (c, j))

statement ok
SET SESSION CHARACTERISTICS AS TRANSACTION ISOLATION LEVEL READ COMMITTED

statement ok
INSERT INTO jars VALUES (1), (2)

statement ok
INSERT INTO cookies VALUES (1, 1)

statement ok
UPDATE cookies SET j = 2 WHERE c = 1

query error violates foreign key constraint
UPDATE jars SET j = j + 4

query error violates foreign key constraint
DELETE FROM jars WHERE j = 2

statement count 1
DELETE FROM cookies WHERE c = 1

statement count 1
DELETE FROM jars WHERE j = 2

# Test that we do not use parallel FK checks under RC (see #111888).
subtest no-parallel-fk-checks

statement ok
CREATE TABLE a (a PRIMARY KEY) AS SELECT 1

statement ok
CREATE TABLE b (b PRIMARY KEY) AS SELECT 1

statement ok
CREATE TABLE c (c PRIMARY KEY) AS SELECT 1

statement ok
CREATE TABLE d (d PRIMARY KEY) AS SELECT 1

statement ok
CREATE TABLE e (e PRIMARY KEY) AS SELECT 1

statement ok
CREATE TABLE f (
  a INT REFERENCES a (a) ON UPDATE CASCADE,
  b INT REFERENCES b (b),
  c INT REFERENCES c (c),
  d INT REFERENCES d (d),
  e INT REFERENCES e (e),
  f INT PRIMARY KEY
)

statement ok
SET enable_insert_fast_path = off

statement ok
INSERT INTO f VALUES (1, 1, 1, 1, 1, 1)

statement ok
RESET enable_insert_fast_path

# Test that we do not use parallel FK checks under RC (see #111888).
subtest no-parallel-fk-checks-from-cascade

statement ok
CREATE TABLE x (
  x INT,
  FOREIGN KEY (x) REFERENCES a (a) ON UPDATE CASCADE,
  FOREIGN KEY (x) REFERENCES b (b),
  FOREIGN KEY (x) REFERENCES c (c),
  FOREIGN KEY (x) REFERENCES d (d),
  FOREIGN KEY (x) REFERENCES e (e)
)

statement ok
INSERT INTO x VALUES (1)

statement error pq: update on table "x" violates foreign key constraint
UPDATE a SET a = 2 WHERE a = 1

statement ok
INSERT INTO b VALUES (2)

statement ok
INSERT INTO c VALUES (2)

statement ok
INSERT INTO d VALUES (2)

statement ok
INSERT INTO e VALUES (2)

statement ok
UPDATE a SET a = 2 WHERE a = 1

subtest fk_cascade_race_150282

statement ok
CREATE TABLE parent_150282 (
  p INT PRIMARY KEY,
  i INT,
  j INT,
  INDEX (i),
  INDEX (j)
);

statement ok
CREATE TABLE child_150282 (
  c INT PRIMARY KEY,
  p INT REFERENCES parent_150282 (p) ON DELETE CASCADE ON UPDATE CASCADE,
  INDEX (p)
);

statement ok
GRANT ALL ON TABLE parent_150282 TO testuser;

statement ok
GRANT ALL ON TABLE child_150282 TO testuser;

statement ok
INSERT INTO parent_150282 VALUES (1, 2, 3);

user root

statement ok
BEGIN ISOLATION LEVEL READ COMMITTED;

statement ok
SELECT 1;

statement async fk_delete
WITH sleep AS (SELECT pg_sleep(2)) DELETE FROM parent_150282@parent_150282_i_idx WHERE i = 2;

user testuser

statement ok
SET lock_timeout = '10s';
SET enable_implicit_fk_locking_for_serializable = on;
SET enable_shared_locking_for_serializable = on;
SET enable_durable_locking_for_serializable = on;
INSERT INTO child_150282 VALUES (4, 1);

user root

awaitstatement fk_delete

statement ok
COMMIT;

user testuser

query III
SELECT * FROM parent_150282;
----

query II
SELECT * FROM child_150282;
----

statement ok
INSERT INTO parent_150282 VALUES (1, 2, 3);

user root

statement ok
BEGIN ISOLATION LEVEL READ COMMITTED;

statement ok
SELECT 1;

statement async fk_update
WITH sleep AS (SELECT pg_sleep(2)) UPDATE parent_150282 SET p = 4 WHERE i = 2;

user testuser

statement ok
SET lock_timeout = '10s';
SET enable_implicit_fk_locking_for_serializable = on;
SET enable_shared_locking_for_serializable = on;
SET enable_durable_locking_for_serializable = on;
INSERT INTO child_150282 VALUES (4, 1);

user root

awaitstatement fk_update

statement ok
COMMIT;

query III
SELECT * FROM parent_150282;
----
4 2 3

query II
SELECT * FROM child_150282;
----
4 4

# Test the fk delete fast path.
statement count 1
DELETE FROM parent_150282;

statement count 0
DELETE FROM child_150282;

statement ok
INSERT INTO parent_150282 VALUES (1, 2, 3);

user root

statement ok
BEGIN ISOLATION LEVEL READ COMMITTED;

statement ok
SELECT 1;

statement async fk_delete
WITH sleep AS (SELECT pg_sleep(2)) DELETE FROM parent_150282 WHERE p = 1;

user testuser

statement ok
SET lock_timeout = '10s';
SET enable_implicit_fk_locking_for_serializable = on;
SET enable_shared_locking_for_serializable = on;
SET enable_durable_locking_for_serializable = on;
INSERT INTO child_150282 VALUES (4, 1);

user root

awaitstatement fk_delete

statement ok
COMMIT;

query III
SELECT * FROM parent_150282;
----

query II
SELECT * FROM child_150282;
----

user testuser

statement ok
RESET lock_timeout;
RESET enable_implicit_fk_locking_for_serializable;
RESET enable_shared_locking_for_serializable;
RESET enable_durable_locking_for_serializable

user root

subtest end

subtest fk_cascade_race_151663

statement ok
CREATE TABLE parent_151663 (
  p INT PRIMARY KEY,
  q INT
);

statement ok
CREATE TABLE child_151663 (
  c INT PRIMARY KEY,
  p INT REFERENCES parent_151663 (p),
  INDEX (p),
  FAMILY (c, p)
);

statement ok
CREATE USER testuser2;
CREATE USER testuser3

statement ok
GRANT ALL ON TABLE parent_151663 TO testuser;
GRANT ALL ON TABLE parent_151663 TO testuser2;
GRANT ALL ON TABLE parent_151663 TO testuser3;
GRANT ALL ON TABLE child_151663 TO testuser3

statement ok
INSERT INTO parent_151663 VALUES (1, 0), (2, 0), (3, 0)

# The timeline of this test is:
#
#  testuser        testuser2        testuser3        root
#  --------        ---------        ---------        ----
#  begin
#  update p=2
#                  begin
#                  lock p=3
#                                   begin RC
#                                   start DELETE
#                                   wait on p=3
#                                                    begin SSI
#                                                    start INSERT
#                                                    wait on p=2
#  rollback
#                                                    lock p=1, p=2
#                  rollback
#                                   wait on p=1
#                                                    insert c=10, c=20
#                                                    finish INSERT
#                                                    commit
#                                   delete p=1
#                                   FK check child
#                                   finish DELETE
#                                   commit
#
# The transactions run by testuser3 and root are the important part. testuser
# and testuser2 only exist to control the timing of the transactions run by
# testuser3 and root.
#
# The transactions run by testuser3 and root conflict with each other. To
# prevent a FK violation they need to either run serially, or one transaction
# needs to fail.
#
# This test demonstrates that we need locking during both the parent FK check
# and the child FK check to prevent a FK violation.
#
# The parent FK check is performed by the Serializable INSERT run by
# root. Without locking during this check, the two transactions are not
# guaranteed to detect the conflict with each other. For example, without this
# locking, the Read Committed DELETE could finish after the INSERT's FK check
# but before its insert. The INSERT could then write a phantom child row and
# have a successful read refresh, and both transactions could commit. Locking
# during the parent FK check avoids this by forcing the transactions to
# coordinate on the parent row.
#
# The child FK check is performed by the Read Committed DELETE run by
# testuser3. Without locking during this check, the Read Committed DELETE could
# perform a stale read for its child FK check, missing a newer child row. For
# example, it could miss the row written by the Serializable INSERT and
# successfully commit. (Serializable isolation does not have this same risk of
# stale reads and thus does not need locking during child FK checks.)
#
# For more discussion of this and other scenarios please see #151663.

user testuser

statement ok
BEGIN

# Use an update on p=2 to block the future insert by root.
statement ok
UPDATE parent_151663 SET q = q + 1 WHERE p = 2

user testuser2

statement ok
BEGIN

# Use a lock on p=3 to block the future delete by testuser3.
statement ok
SELECT * FROM parent_151663 WHERE p = 3 FOR UPDATE

user testuser3

statement ok
BEGIN ISOLATION LEVEL READ COMMITTED

statement ok
SELECT 1

statement async fkdelete error pgcode 23503 delete on table "parent_151663" violates foreign key constraint "child_151663_p_fkey" on table "child_151663"\nDETAIL: Key \(p\)=\(1\) is still referenced from table "child_151663"\.
DELETE FROM parent_151663 WHERE p = (SELECT 1 FROM parent_151663 WHERE p = 3 FOR UPDATE)

user root

# Give the delete a moment to wait on the p=3 lock by testuser2.
statement ok
SELECT pg_sleep(2)

# The serializable insert needs this locking to properly sychronize with the
# read committed delete.
statement ok
SET enable_implicit_fk_locking_for_serializable = on;
SET enable_shared_locking_for_serializable = on;
SET enable_durable_locking_for_serializable = on

statement ok
BEGIN ISOLATION LEVEL SERIALIZABLE

statement async fkinsert
INSERT INTO child_151663 VALUES (10, 1), (20, 2)

user testuser

# Give the insert a moment to wait on the p=2 update by testuser.
statement ok
SELECT pg_sleep(2)

statement ok
ROLLBACK

user testuser2

# Give the insert a moment to lock p=1.
statement ok
SELECT pg_sleep(2)

statement ok
ROLLBACK

user root

awaitstatement fkinsert

statement ok
COMMIT

user testuser3

awaitstatement fkdelete

statement ok
COMMIT

user root

# Check that there are no orphan children.

query II
SELECT * FROM parent_151663 ORDER BY p
----
1  0
2  0
3  0

query II
SELECT * FROM child_151663 ORDER BY c
----
10  1
20  2

statement ok
RESET enable_implicit_fk_locking_for_serializable;
RESET enable_shared_locking_for_serializable;
RESET enable_durable_locking_for_serializable

subtest end

# This subtest systematically tests FK constraint enforcement with the
# read_committed_non_locking_checks_enabled setting. The tests cover all
# combinations of isolation levels:
#   - RC txn (with non-locking checks) + RC txn (with non-locking checks)
#   - RC txn (with non-locking checks) + Serializable txn
#   - Serializable txn + RC txn (with non-locking checks)
#
# For each combination, we test an insert into the child table concurrent with
# DELETE and UPDATE CHECKS and CASCADES.
subtest non_locking_checks_enabled

statement ok
CREATE TABLE parent_cascade (
  p INT PRIMARY KEY,
  v INT,
  FAMILY (p, v)
)

statement ok
CREATE TABLE child_cascade (
  c INT PRIMARY KEY,
  p INT REFERENCES parent_cascade(p) ON DELETE CASCADE ON UPDATE CASCADE,
  FAMILY (c, p)
)

statement ok
CREATE TABLE parent_check (
  p INT PRIMARY KEY,
  v INT,
  FAMILY (p, v)
)

statement ok
CREATE TABLE child_check (
  c INT PRIMARY KEY,
  p INT REFERENCES parent_check(p),
  FAMILY (c, p)
)

statement ok
GRANT ALL ON TABLE parent_cascade TO testuser;
GRANT ALL ON TABLE child_cascade TO testuser;
GRANT ALL ON TABLE parent_check TO testuser;
GRANT ALL ON TABLE child_check TO testuser

# ==============================================================================
# RC + RC: Both transactions use Read Committed with non-locking checks.
# ==============================================================================

subtest rc_rc

# Configure both users for Read Committed with non-locking checks.
statement ok
SET SESSION CHARACTERISTICS AS TRANSACTION ISOLATION LEVEL READ COMMITTED

statement ok
SET read_committed_non_locking_checks_enabled = true

user testuser

statement ok
SET SESSION CHARACTERISTICS AS TRANSACTION ISOLATION LEVEL READ COMMITTED

statement ok
SET read_committed_non_locking_checks_enabled = true

user root

# RC DELETE with FK CASCADE + concurrent RC INSERT into child.
subtest rc_rc/cascade_delete

statement ok
INSERT INTO parent_cascade VALUES (1, 10), (2, 20)

statement ok
INSERT INTO child_cascade VALUES (100, 1), (200, 2)

statement ok
BEGIN

statement async fk_delete
WITH sleep AS (SELECT pg_sleep(2)) DELETE FROM parent_cascade WHERE p = 1

user testuser

statement ok
INSERT INTO child_cascade VALUES (300, 1)

user root

awaitstatement fk_delete

# DELETE statement should be retried at a higher timestamp and succeed.
statement ok
COMMIT

# Verify that parent 1 was deleted and both children were cascaded.
query II rowsort
SELECT * FROM parent_cascade
----
2  20

query II rowsort
SELECT * FROM child_cascade
----
200  2

# RC UPDATE with FK CASCADE + concurrent RC INSERT into child.
subtest rc_rc/cascade_update

statement ok
INSERT INTO parent_cascade VALUES (3, 30)

statement ok
INSERT INTO child_cascade VALUES (300, 3)

statement ok
BEGIN

statement async fk_update
WITH sleep AS (SELECT pg_sleep(2)) UPDATE parent_cascade SET p = 4 WHERE p = 3

user testuser

statement ok
INSERT INTO child_cascade VALUES (400, 3)

user root

awaitstatement fk_update

# UPDATE statement should be retried at a higher timestamp and succeed.
statement ok
COMMIT

# Verify that parent 3 was updated to 4 and both children were cascaded.
query II rowsort
SELECT * FROM parent_cascade
----
2  20
4  30

query II rowsort
SELECT * FROM child_cascade
----
200  2
300  4
400  4

# RC INSERT into child + concurrent RC DELETE of parent.
subtest rc_rc/check_insert_delete

statement ok
INSERT INTO parent_check VALUES (1, 10), (2, 20)

statement ok
INSERT INTO child_check VALUES (100, 1)

statement ok
BEGIN

statement async conflict error pgcode 23503 insert on table "child_check" violates foreign key constraint "child_check_p_fkey"
WITH sleep AS (SELECT pg_sleep(2)) INSERT INTO child_check VALUES (200, 2)

user testuser

statement count 1
DELETE FROM parent_check WHERE p = 2

user root

awaitstatement conflict

# RC statement
statement ok
ABORT

# Verify that parent 2 was deleted and child 200 was not inserted (FK violation).
query II rowsort
SELECT * FROM parent_check
----
1  10

query II rowsort
SELECT * FROM child_check
----
100  1

# RC DELETE of parent + concurrent RC INSERT into child.
subtest rc_rc/check_delete_insert

statement ok
INSERT INTO parent_check VALUES (3, 30), (4, 40)

statement ok
INSERT INTO child_check VALUES (300, 3)

statement ok
BEGIN

statement async conflict error pgcode 23503 delete on table "parent_check" violates foreign key constraint "child_check_p_fkey" on table "child_check"
WITH sleep AS (SELECT pg_sleep(2)) DELETE FROM parent_check WHERE p = 3

user testuser

statement ok
INSERT INTO child_check VALUES (400, 3)

user root

awaitstatement conflict

# DELETE statement should fail due to FK violation.
statement ok
ABORT

# Verify that parent 3 still exists and both children were inserted.
query II rowsort
SELECT * FROM parent_check
----
1  10
3  30
4  40

query II rowsort
SELECT * FROM child_check
----
100  1
300  3
400  3

subtest rc_rc/end

# ==============================================================================
# RC + Serializable: RC with non-locking checks + Serializable transaction.
# ==============================================================================

subtest rc_ssi

# Configure root for Read Committed with non-locking checks, testuser for
# Serializable.
statement ok
SET SESSION CHARACTERISTICS AS TRANSACTION ISOLATION LEVEL READ COMMITTED

statement ok
SET read_committed_non_locking_checks_enabled = true

user testuser

statement ok
SET SESSION CHARACTERISTICS AS TRANSACTION ISOLATION LEVEL SERIALIZABLE

user root

# RC DELETE with FK CASCADE + concurrent SSI INSERT into child.
subtest rc_ssi/cascade_delete

statement count 3
DELETE FROM child_cascade WHERE true

statement count 2
DELETE FROM parent_cascade WHERE true

statement ok
INSERT INTO parent_cascade VALUES (5, 50), (6, 60)

statement ok
INSERT INTO child_cascade VALUES (500, 5), (600, 6)

statement ok
BEGIN

statement async fk_delete_ssi
WITH sleep AS (SELECT pg_sleep(2)) DELETE FROM parent_cascade WHERE p = 5

user testuser

statement ok
INSERT INTO child_cascade VALUES (700, 5)

user root

awaitstatement fk_delete_ssi

# RC statement should be retried at a higher timestamp and succeed.
statement ok
COMMIT

# Verify that parent 5 was deleted and child 700 was cascaded (retry sees SSI
# insert).
query II rowsort
SELECT * FROM parent_cascade
----
6  60

query II rowsort
SELECT * FROM child_cascade
----
600  6

subtest rc_ssi/cascade_update

# RC UPDATE with FK CASCADE + concurrent SSI INSERT into child.
statement ok
INSERT INTO parent_cascade VALUES (7, 70)

statement ok
INSERT INTO child_cascade VALUES (800, 7)

statement ok
BEGIN

statement async fk_update_ssi
WITH sleep AS (SELECT pg_sleep(2)) UPDATE parent_cascade SET p = 8 WHERE p = 7

user testuser

statement ok
INSERT INTO child_cascade VALUES (900, 7)

user root

awaitstatement fk_update_ssi

# RC statement should be retried at a higher timestamp and succeed.
statement ok
COMMIT

# Verify that parent 7 was updated to 8 and both children were cascaded.
query II rowsort
SELECT * FROM parent_cascade
----
6  60
8  70

query II rowsort
SELECT * FROM child_cascade
----
600  6
800  8
900  8

subtest rc_ssi/check_insert_delete

# RC INSERT into child + concurrent SSI DELETE of parent.
statement count 3
DELETE FROM child_check WHERE true

statement count 3
DELETE FROM parent_check WHERE true

statement ok
INSERT INTO parent_check VALUES (3, 30), (4, 40)

statement ok
INSERT INTO child_check VALUES (300, 3)

statement ok
BEGIN

statement async conflict error pgcode 23503 insert on table "child_check" violates foreign key constraint "child_check_p_fkey"
WITH sleep AS (SELECT pg_sleep(2)) INSERT INTO child_check VALUES (400, 4)

user testuser

statement count 1
DELETE FROM parent_check WHERE p = 4

user root

awaitstatement conflict

statement ok
ABORT

# Verify that parent 4 was deleted and child 400 was not inserted (FK violation).
query II rowsort
SELECT * FROM parent_check
----
3  30

query II rowsort
SELECT * FROM child_check
----
300  3

# RC DELETE of parent + concurrent SSI INSERT into child.
subtest rc_ssi/check_delete_insert

statement ok
INSERT INTO parent_check VALUES (5, 50), (6, 60)

statement ok
INSERT INTO child_check VALUES (500, 5)

statement ok
BEGIN

statement async conflict error pgcode 23503 delete on table "parent_check" violates foreign key constraint "child_check_p_fkey" on table "child_check"
WITH sleep AS (SELECT pg_sleep(2)) DELETE FROM parent_check WHERE p = 5

user testuser

statement ok
INSERT INTO child_check VALUES (600, 5)

user root

awaitstatement conflict

# DELETE statement should fail due to FK violation.
statement ok
ABORT

# Verify that parent 5 still exists and both children were inserted.
query II rowsort
SELECT * FROM parent_check
----
3  30
5  50
6  60

query II rowsort
SELECT * FROM child_check
----
300  3
500  5
600  5

subtest rc_ssi/end

# ==============================================================================
# Serializable + RC: Serializable transaction + RC with non-locking checks.
# ==============================================================================

subtest ssi_rc

# Configure root for Serializable, testuser for Read Committed with non-locking
# checks.
statement ok
SET SESSION CHARACTERISTICS AS TRANSACTION ISOLATION LEVEL SERIALIZABLE

user testuser

statement ok
SET SESSION CHARACTERISTICS AS TRANSACTION ISOLATION LEVEL READ COMMITTED

statement ok
SET read_committed_non_locking_checks_enabled = true

user root

# SSI DELETE with FK CASCADE + concurrent RC INSERT into child.
subtest ssi_rc/cascade_delete

statement count 3
DELETE FROM child_cascade WHERE true

statement count 2
DELETE FROM parent_cascade WHERE true

statement ok
INSERT INTO parent_cascade VALUES (9, 90), (10, 100)

statement ok
INSERT INTO child_cascade VALUES (1000, 9), (1100, 10)

statement ok
BEGIN

# NB: commit in a batch with the async statement to get the same behavior when
# the write buffer is metamorphically enabled or disabled. There are two cases:
#
# 1) With the write buffer disabled, the DELETE intent is written first, and
#    encounters the parent table read performed by the RC INSERT's check. This
#    bumps the SSI transaction's timestamp, and it can trivially refresh since
#    it hasn't performed reads yet. Then, the SSI statement's cascade to the
#    child table happens at the new timestamp, and correctly deletes the new
#    child row.
#
# 2) With the write buffer enabled, the DELETE intent is buffered and a locking
#    read performed instead. The SSI transaction's timestamp is not bumped, and
#    its cascade reads below the timestamp of the RC INSERT intent. At commit
#    when the buffer is flushed, the SSI DELETE intent has its timestamp bumped
#    by the RC's parent table check, and the SSI transaction fails to refresh
#    because the read it did for the FK cascade is now stale. With COMMIT
#    submitted as part of the pgwire batch, the SSI transaction can be
#    transparently retried at a higher timestamp.
statement async fk_delete_rc ok
WITH sleep AS (SELECT pg_sleep(2)) DELETE FROM parent_cascade WHERE p = 9;
COMMIT;

user testuser

statement ok
INSERT INTO child_cascade VALUES (1200, 9)

user root

awaitstatement fk_delete_rc

# The SSI DELETE will push its timestamp beyond the RC INSERT and succeed.
query II rowsort
SELECT * FROM parent_cascade
----
10  100

query II rowsort
SELECT * FROM child_cascade
----
1100  10

# SSI UPDATE with FK CASCADE + concurrent RC INSERT into child.
subtest ssi_rc/cascade_update

statement ok
INSERT INTO parent_cascade VALUES (11, 110)

statement ok
INSERT INTO child_cascade VALUES (1300, 11)

statement ok
BEGIN

statement async fk_update_rc
WITH sleep AS (SELECT pg_sleep(2)) UPDATE parent_cascade SET p = 12 WHERE p = 11

user testuser

statement ok
INSERT INTO child_cascade VALUES (1400, 11)

user root

awaitstatement fk_update_rc

statement error pgcode 40001 TransactionRetryWithProtoRefreshError
COMMIT

# Verify that SSI UPDATE failed due to conflict and RC INSERT succeeded.
query II rowsort
SELECT * FROM parent_cascade
----
10  100
11  110

query II rowsort
SELECT * FROM child_cascade
----
1100  10
1300  11
1400  11

# SSI INSERT into child + concurrent RC DELETE of parent.
subtest ssi_rc/check_insert_delete

statement count 3
DELETE FROM child_check WHERE true

statement count 3
DELETE FROM parent_check WHERE true

statement ok
INSERT INTO parent_check VALUES (5, 50), (6, 60)

statement ok
INSERT INTO child_check VALUES (500, 5)

statement ok
BEGIN

# NB: commit in a batch with the async statement to get the same behavior when
# the write buffer is metamorphically enabled or disabled. There are two cases:
#
# 1) With the write buffer disabled, the INSERT intent is written first, and
#    encounters the child table read performed by the RC DELETE's check. This
#    bumps the SSI transaction's timestamp, and it can trivially refresh since
#    it hasn't performed reads yet. Then, the SSI statement's check of the
#    parent table happens at the new timestamp, and sees that there is no longer
#    a row.
#
# 2) With the write buffer enabled, the INSERT intent is buffered and a locking
#    read performed instead. The SSI transaction's timestamp is not bumped, and
#    its check is performed below the timestamp of the RC DELETE intent. At
#    commit when the buffer is flushed, the SSI INSERT intent has its timestamp
#    bumped by the RC's child table check, and the SSI transaction fails to
#    refresh because the read it did for the FK check is now stale. With COMMIT
#    submitted as part of the pgwire batch, the SSI transaction can be
#    transparently retried at a higher timestamp.
statement async conflict error pgcode 23503 insert on table "child_check" violates foreign key constraint "child_check_p_fkey"
WITH sleep AS (SELECT pg_sleep(2)) INSERT INTO child_check VALUES (600, 6);
COMMIT;

user testuser

statement count 1
DELETE FROM parent_check WHERE p = 6

query II rowsort
SELECT * FROM parent_check
----
5  50

query II rowsort
SELECT * FROM child_check
----
500  5

user root

awaitstatement conflict

statement ok
COMMIT;

# Verify that RC DELETE succeeded and SSI INSERT failed with FK violation.
query II rowsort
SELECT * FROM parent_check
----
5  50

query II rowsort
SELECT * FROM child_check
----
500  5

# SSI DELETE of parent + concurrent RC INSERT into child.
subtest ssi_rc/check_delete_insert

statement ok
INSERT INTO parent_check VALUES (7, 70), (8, 80)

statement ok
INSERT INTO child_check VALUES (700, 7)

statement ok
BEGIN

statement async conflict error pgcode 23503 delete on table "parent_check" violates foreign key constraint "child_check_p_fkey" on table "child_check"
WITH sleep AS (SELECT pg_sleep(2)) DELETE FROM parent_check WHERE p = 7

user testuser

statement ok
INSERT INTO child_check VALUES (800, 7)

user root

awaitstatement conflict

statement ok
ABORT

# Verify that SSI DELETE failed due to conflict and RC INSERT succeeded.
query II rowsort
SELECT * FROM parent_check
----
5  50
7  70
8  80

query II rowsort
SELECT * FROM child_check
----
500  5
700  7
800  7

subtest ssi_rc/end

subtest end
