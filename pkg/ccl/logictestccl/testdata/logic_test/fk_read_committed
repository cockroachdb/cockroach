statement ok
CREATE TABLE jars (j INT PRIMARY KEY)

statement ok
CREATE TABLE cookies (c INT PRIMARY KEY, j INT REFERENCES jars (j), FAMILY (c, j))

statement ok
SET SESSION CHARACTERISTICS AS TRANSACTION ISOLATION LEVEL READ COMMITTED

statement ok
INSERT INTO jars VALUES (1), (2)

statement ok
INSERT INTO cookies VALUES (1, 1)

statement ok
UPDATE cookies SET j = 2 WHERE c = 1

query error violates foreign key constraint
UPDATE jars SET j = j + 4

query error violates foreign key constraint
DELETE FROM jars WHERE j = 2

statement ok
DELETE FROM cookies WHERE c = 1

statement ok
DELETE FROM jars WHERE j = 2

# Test that we do not use parallel FK checks under RC (see #111888).
subtest no-parallel-fk-checks

statement ok
CREATE TABLE a (a PRIMARY KEY) AS SELECT 1

statement ok
CREATE TABLE b (b PRIMARY KEY) AS SELECT 1

statement ok
CREATE TABLE c (c PRIMARY KEY) AS SELECT 1

statement ok
CREATE TABLE d (d PRIMARY KEY) AS SELECT 1

statement ok
CREATE TABLE e (e PRIMARY KEY) AS SELECT 1

statement ok
CREATE TABLE f (
  a INT REFERENCES a (a) ON UPDATE CASCADE,
  b INT REFERENCES b (b),
  c INT REFERENCES c (c),
  d INT REFERENCES d (d),
  e INT REFERENCES e (e),
  f INT PRIMARY KEY
)

statement ok
SET enable_insert_fast_path = off

statement ok
INSERT INTO f VALUES (1, 1, 1, 1, 1, 1)

statement ok
RESET enable_insert_fast_path

# Test that we do not use parallel FK checks under RC (see #111888).
subtest no-parallel-fk-checks-from-cascade

statement ok
CREATE TABLE x (
  x INT,
  FOREIGN KEY (x) REFERENCES a (a) ON UPDATE CASCADE,
  FOREIGN KEY (x) REFERENCES b (b),
  FOREIGN KEY (x) REFERENCES c (c),
  FOREIGN KEY (x) REFERENCES d (d),
  FOREIGN KEY (x) REFERENCES e (e)
)

statement ok
INSERT INTO x VALUES (1)

statement error pq: update on table "x" violates foreign key constraint
UPDATE a SET a = 2 WHERE a = 1

statement ok
INSERT INTO b VALUES (2)

statement ok
INSERT INTO c VALUES (2)

statement ok
INSERT INTO d VALUES (2)

statement ok
INSERT INTO e VALUES (2)

statement ok
UPDATE a SET a = 2 WHERE a = 1

subtest fk_cascade_race_150282

statement ok
CREATE TABLE parent_150282 (
  p INT PRIMARY KEY,
  i INT,
  j INT,
  INDEX (i),
  INDEX (j)
);

statement ok
CREATE TABLE child_150282 (
  c INT PRIMARY KEY,
  p INT REFERENCES parent_150282 (p) ON DELETE CASCADE ON UPDATE CASCADE,
  INDEX (p)
);

statement ok
GRANT ALL ON TABLE parent_150282 TO testuser;

statement ok
GRANT ALL ON TABLE child_150282 TO testuser;

statement ok
INSERT INTO parent_150282 VALUES (1, 2, 3);

user root

statement ok
BEGIN ISOLATION LEVEL READ COMMITTED;

statement ok
SELECT 1;

statement async fk_delete
WITH sleep AS (SELECT pg_sleep(1)) DELETE FROM parent_150282@parent_150282_i_idx WHERE i = 2;

user testuser

statement ok
SET enable_implicit_fk_locking_for_serializable = on;
SET enable_shared_locking_for_serializable = on;
SET enable_durable_locking_for_serializable = on;
INSERT INTO child_150282 VALUES (4, 1);

user root

awaitstatement fk_delete

statement ok
COMMIT;

user testuser

query III
SELECT * FROM parent_150282;
----

query II
SELECT * FROM child_150282;
----

statement ok
INSERT INTO parent_150282 VALUES (1, 2, 3);

user root

statement ok
BEGIN ISOLATION LEVEL READ COMMITTED;

statement ok
SELECT 1;

statement async fk_update
WITH sleep AS (SELECT pg_sleep(1)) UPDATE parent_150282 SET p = 4 WHERE i = 2;

user testuser

statement ok
SET enable_implicit_fk_locking_for_serializable = on;
SET enable_shared_locking_for_serializable = on;
SET enable_durable_locking_for_serializable = on;
INSERT INTO child_150282 VALUES (4, 1);

user root

awaitstatement fk_update

statement ok
COMMIT;

query III
SELECT * FROM parent_150282;
----
4 2 3

query II
SELECT * FROM child_150282;
----
4 4

# Test the fk delete fast path
statement ok
DELETE FROM parent_150282;

statement ok
DELETE FROM child_150282;

statement ok
INSERT INTO parent_150282 VALUES (1, 2, 3);

user root

statement ok
BEGIN ISOLATION LEVEL READ COMMITTED;

statement ok
SELECT 1;

statement async fk_delete
WITH sleep AS (SELECT pg_sleep(1)) DELETE FROM parent_150282 WHERE p = 1;

user testuser

statement ok
SET enable_implicit_fk_locking_for_serializable = on;
SET enable_shared_locking_for_serializable = on;
SET enable_durable_locking_for_serializable = on;
INSERT INTO child_150282 VALUES (4, 1);

user root

awaitstatement fk_delete

statement ok
COMMIT;

query III
SELECT * FROM parent_150282;
----

query II
SELECT * FROM child_150282;
----

user testuser

statement ok
RESET enable_implicit_fk_locking_for_serializable;
RESET enable_shared_locking_for_serializable;
RESET enable_durable_locking_for_serializable

user root

subtest end

subtest fk_cascade_race_151663

statement ok
CREATE TABLE parent_151663 (
  p INT PRIMARY KEY,
  q INT
);

statement ok
CREATE TABLE child_151663 (
  c INT PRIMARY KEY,
  p INT REFERENCES parent_151663 (p),
  INDEX (p),
  FAMILY (c, p)
);

statement ok
CREATE USER testuser2;
CREATE USER testuser3

statement ok
GRANT ALL ON TABLE parent_151663 TO testuser;
GRANT ALL ON TABLE parent_151663 TO testuser2;
GRANT ALL ON TABLE parent_151663 TO testuser3;
GRANT ALL ON TABLE child_151663 TO testuser3

statement ok
INSERT INTO parent_151663 VALUES (1, 0), (2, 0), (3, 0)

# The timeline of this test is:
#
#  testuser        testuser2        testuser3        root
#  --------        ---------        ---------        ----
#  begin
#  update p=2
#                  begin
#                  lock p=3
#                                   begin RC
#                                   start DELETE
#                                   wait on p=3
#                                                    begin SSI
#                                                    start INSERT
#                                                    wait on p=2
#  rollback
#                                                    lock p=1, p=2
#                  rollback
#                                   wait on p=1
#                                                    insert c=10, c=20
#                                                    finish INSERT
#                                                    commit
#                                   delete p=1
#                                   FK check child
#                                   finish DELETE
#                                   commit
#
# The transactions run by testuser3 and root are the important part. testuser
# and testuser2 only exist to control the timing of the transactions run by
# testuser3 and root.
#
# The transactions run by testuser3 and root conflict with each other. To
# prevent a FK violation they need to either run serially, or one transaction
# needs to fail.
#
# This test demonstrates that we need locking during both the parent FK check
# and the child FK check to prevent a FK violation.
#
# The parent FK check is performed by the Serializable INSERT run by
# root. Without locking during this check, the two transactions are not
# guaranteed to detect the conflict with each other. For example, without this
# locking, the Read Committed DELETE could finish after the INSERT's FK check
# but before its insert. The INSERT could then write a phantom child row and
# have a successful read refresh, and both transactions could commit. Locking
# during the parent FK check avoids this by forcing the transactions to
# coordinate on the parent row.
#
# The child FK check is performed by the Read Committed DELETE run by
# testuser3. Without locking during this check, the Read Committed DELETE could
# perform a stale read for its child FK check, missing a newer child row. For
# example, it could miss the row written by the Serializable INSERT and
# successfully commit. (Serializable isolation does not have this same risk of
# stale reads and thus does not need locking during child FK checks.)
#
# For more discussion of this and other scenarios please see #151663.

user testuser

statement ok
BEGIN

# Use an update on p=2 to block the future insert by root.
statement ok
UPDATE parent_151663 SET q = q + 1 WHERE p = 2

user testuser2

statement ok
BEGIN

# Use a lock on p=3 to block the future delete by testuser3.
statement ok
SELECT * FROM parent_151663 WHERE p = 3 FOR UPDATE

user testuser3

statement ok
BEGIN ISOLATION LEVEL READ COMMITTED

statement ok
SELECT 1

statement async fkdelete error pgcode 23503 delete on table "parent_151663" violates foreign key constraint "child_151663_p_fkey" on table "child_151663"\nDETAIL: Key \(p\)=\(1\) is still referenced from table "child_151663"\.
DELETE FROM parent_151663 WHERE p = (SELECT 1 FROM parent_151663 WHERE p = 3 FOR UPDATE)

user root

# Give the delete a moment to wait on the p=3 lock by testuser2.
statement ok
SELECT pg_sleep(1)

# The serializable insert needs this locking to properly sychronize with the
# read committed delete.
statement ok
SET enable_implicit_fk_locking_for_serializable = on;
SET enable_shared_locking_for_serializable = on;
SET enable_durable_locking_for_serializable = on

statement ok
BEGIN ISOLATION LEVEL SERIALIZABLE

statement async fkinsert
INSERT INTO child_151663 VALUES (10, 1), (20, 2)

user testuser

# Give the insert a moment to wait on the p=2 update by testuser.
statement ok
SELECT pg_sleep(1)

statement ok
ROLLBACK

user testuser2

# Give the insert a moment to lock p=1.
statement ok
SELECT pg_sleep(1)

statement ok
ROLLBACK

user root

awaitstatement fkinsert

statement ok
COMMIT

user testuser3

awaitstatement fkdelete

statement ok
COMMIT

user root

# Check that there are no orphan children.

query II
SELECT * FROM parent_151663 ORDER BY p
----
1  0
2  0
3  0

query II
SELECT * FROM child_151663 ORDER BY c
----
10  1
20  2

statement ok
RESET enable_implicit_fk_locking_for_serializable;
RESET enable_shared_locking_for_serializable;
RESET enable_durable_locking_for_serializable

subtest end
