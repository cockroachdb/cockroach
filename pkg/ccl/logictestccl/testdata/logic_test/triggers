# LogicTest: !local-legacy-schema-changer !local-prepared
# knob-opt: allow-unsafe

# Include some hidden columns that won't be visible to triggers.
statement ok
CREATE TABLE xy (x INT PRIMARY KEY, foo INT NOT VISIBLE, y INT, bar INT NOT VISIBLE);

statement ok
CREATE TABLE ab (a INT, foo INT NOT VISIBLE, b INT);

# ==============================================================================
# Trigger functions cannot be directly invoked.
# ==============================================================================

subtest direct_invocation

statement ok
CREATE FUNCTION f() RETURNS TRIGGER LANGUAGE PLpgSQL AS $$ BEGIN RETURN NULL; END $$;

statement error pgcode 0A000 pq: trigger functions can only be called as triggers
SELECT f();

statement error pgcode 0A000 pq: trigger functions can only be called as triggers
CREATE FUNCTION foo() RETURNS INT LANGUAGE SQL AS $$ SELECT f(); SELECT 1; $$;

statement error pgcode 0A000 pq: trigger functions can only be called as triggers
CREATE FUNCTION foo() RETURNS INT LANGUAGE PLpgSQL AS $$ BEGIN SELECT f(); RETURN 1; END $$;

statement ok
DROP FUNCTION f;

# ==============================================================================
# Test invalid usage of parameters in trigger functions.
# ==============================================================================

# Trigger functions are not allowed to be defined with parameters. Instead,
# arguments are passed through the implicitly defined TG_ARGV variable.
subtest parameters

statement error pgcode 42P13 pq: trigger functions cannot have declared arguments
CREATE FUNCTION f(x TEXT) RETURNS TRIGGER LANGUAGE PLpgSQL AS $$ BEGIN RETURN NULL; END $$;

statement error pgcode 42P13 pq: function result type must be string because of OUT parameters
CREATE FUNCTION f(OUT x TEXT) RETURNS TRIGGER LANGUAGE PLpgSQL AS $$ BEGIN RETURN NULL; END $$;

statement error pgcode 42P13 pq: function result type must be string because of OUT parameters
CREATE FUNCTION f(INOUT x TEXT) RETURNS TRIGGER LANGUAGE PLpgSQL AS $$ BEGIN RETURN NULL; END $$;

# ==============================================================================
# Test invalid usage of the TRIGGER datatype in PL/pgSQL routines.
# ==============================================================================

subtest trigger_in_plpgsql_routine

statement error pgcode 0A000 pq: cannot accept a value of type trigger
CREATE FUNCTION f() RETURNS RECORD LANGUAGE PLpgSQL AS $$ BEGIN RETURN NULL::TRIGGER; END $$;

statement error pgcode 0A000 pq: PL/pgSQL functions cannot accept type trigger
CREATE FUNCTION f(x TRIGGER) RETURNS INT LANGUAGE PLpgSQL AS $$ BEGIN RETURN NULL; END $$;

statement error pgcode 0A000 pq: PL/pgSQL functions cannot accept type trigger
CREATE FUNCTION f(OUT x TRIGGER) LANGUAGE PLpgSQL AS $$ BEGIN RETURN NULL; END $$;

statement error pgcode 0A000 pq: PL/pgSQL functions cannot accept type trigger
CREATE FUNCTION f(INOUT x TRIGGER) RETURNS INT LANGUAGE PLpgSQL AS $$ BEGIN RETURN NULL; END $$;

statement error pgcode 0A000 pq: PL/pgSQL functions cannot accept type trigger
CREATE PROCEDURE p(x TRIGGER) LANGUAGE PLpgSQL AS $$ BEGIN END $$;

statement error pgcode 0A000 pq: PL/pgSQL functions cannot accept type trigger
CREATE PROCEDURE p(OUT x TRIGGER) LANGUAGE PLpgSQL AS $$ BEGIN END $$;

statement error pgcode 0A000 pq: PL/pgSQL functions cannot accept type trigger
CREATE PROCEDURE p(INOUT x TRIGGER) LANGUAGE PLpgSQL AS $$ BEGIN END $$;

# ==============================================================================
# Test invalid usage of the TRIGGER datatype in SQL routines.
# ==============================================================================

subtest trigger_in_sql_routine

statement error pgcode 0A000 pq: cannot accept a value of type trigger
CREATE FUNCTION f() RETURNS RECORD LANGUAGE SQL AS $$ SELECT NULL::TRIGGER; $$;

statement error pgcode 42P13 pq: SQL functions cannot return type trigger
CREATE FUNCTION f() RETURNS TRIGGER LANGUAGE SQL AS $$ SELECT NULL $$;

statement error pgcode 42P13 pq: SQL functions cannot have arguments of type trigger
CREATE FUNCTION f(x TRIGGER) RETURNS INT LANGUAGE SQL AS $$ SELECT NULL $$;

statement error pgcode 42P13 pq: SQL functions cannot return type trigger
CREATE FUNCTION f(OUT x TRIGGER) LANGUAGE SQL AS $$ SELECT NULL $$;

statement error pgcode 42P13 pq: SQL functions cannot return type trigger
CREATE FUNCTION f(INOUT x TRIGGER) RETURNS INT LANGUAGE SQL AS $$ SELECT NULL $$;

statement error pgcode 42P13 pq: SQL functions cannot have arguments of type trigger
CREATE PROCEDURE p(x TRIGGER) LANGUAGE SQL AS $$ SELECT NULL $$;

statement error pgcode 42P13 pq: SQL functions cannot return type trigger
CREATE PROCEDURE p(OUT x TRIGGER) LANGUAGE SQL AS $$ SELECT NULL $$;

statement error pgcode 42P13 pq: SQL functions cannot return type trigger
CREATE PROCEDURE p(INOUT x TRIGGER) LANGUAGE SQL AS $$ SELECT NULL $$;

# ==============================================================================
# Test invalid usage of the TRIGGER datatype in SQL statements.
# ==============================================================================

subtest trigger_in_sql_statement

# Cast.
statement error pgcode 0A000 pq: cannot accept a value of type trigger
SELECT NULL::TRIGGER;

# Trigger array cast.
statement error pgcode 42704 pq: at or near "EOF": syntax error: type trigger\[\] does not exist
SELECT NULL::TRIGGER[];

# Invalid cast from integer.
statement error pgcode 42846 pq: invalid cast: int -> trigger
SELECT 1::TRIGGER;

# Type annotation.
statement error pgcode 0A000 pq: cannot accept a value of type trigger
SELECT NULL:::TRIGGER;

# The builtin type-conversion function should not be usable.
statement error pgcode 0A000 pq: cannot accept a value of type trigger
SELECT trigger_in(1);

# Builtin type conversion function with NULL argument.
# NOTE: this case succeeds because the function is not actually called
# or fully type-checked when it is supplied NULL arguments.
# statement error pgcode 0A000 pq: cannot accept a value of type trigger
statement ok
SELECT trigger_in(NULL);

# ==============================================================================
# Test invalid usage of the TRIGGER datatype in CREATE statements.
# ==============================================================================

subtest trigger_in_create

# Column type.
statement error pgcode 42P16 pq: value type trigger cannot be used for table columns
CREATE TABLE t (x INT, y TRIGGER, z TEXT);

# Array column type.
statement error pgcode 42704 pq: at or near ",": syntax error: type trigger\[\] does not exist
CREATE TABLE t (x INT, y TRIGGER[], z TEXT);

# Cast in partial index predicate.
statement error pgcode 0A000 pq: cannot accept a value of type trigger
CREATE TABLE t (x INT, y INT, INDEX (y) WHERE (NULL::TRIGGER IS NOT NULL));

# Cast in computed column expression.
statement error pgcode 0A000 pq: cannot accept a value of type trigger
CREATE TABLE t (x INT, y BOOL GENERATED ALWAYS AS (NULL::TRIGGER IS NOT NULL) STORED);

# Trigger UDT field.
statement error pgcode 0A000 pq: cannot accept a value of type trigger
CREATE TYPE udt AS (x INT, y TRIGGER, z TEXT);

# Trigger array UDT field.
statement error pgcode 42704 pq: at or near ",": syntax error: type trigger\[\] does not exist
CREATE TYPE udt AS (x INT, y TRIGGER[], z TEXT);

# ==============================================================================
# Trigger functions support basic PL/pgSQL statements.
# ==============================================================================

subtest basic_plpgsql

# RETURN statement.
statement ok
CREATE FUNCTION f() RETURNS TRIGGER LANGUAGE PLpgSQL AS $$ BEGIN RETURN ROW(1, 2); END $$;

statement ok
DROP FUNCTION f;

# Variable declaration and assignment.
statement ok
CREATE FUNCTION f() RETURNS TRIGGER LANGUAGE PLpgSQL AS $$
  DECLARE
    x INT := 1;
    y INT;
  BEGIN
    y := 2;
    RETURN NULL;
  END
$$;

statement ok
DROP FUNCTION f;

# RAISE statement.
statement ok
CREATE FUNCTION f() RETURNS TRIGGER LANGUAGE PLpgSQL AS $$ BEGIN RAISE NOTICE 'hello'; RETURN NULL; END $$;

statement ok
DROP FUNCTION f;

# IF statement.
statement ok
CREATE FUNCTION f() RETURNS TRIGGER LANGUAGE PLpgSQL AS $$
  BEGIN
    IF now() > '2021-07-12 09:02:10-08:00'::TIMESTAMPTZ THEN
      RETURN NULL;
    ELSE
      RETURN ROW(1, 2, 3);
    END IF;
  END
$$;

statement ok
DROP FUNCTION f;

# WHILE statement.
statement ok
CREATE FUNCTION f() RETURNS TRIGGER LANGUAGE PLpgSQL AS $$
  DECLARE
    x INT := 0;
  BEGIN
    WHILE x < 10 LOOP
      x := x + 1;
    END LOOP;
    RETURN ROW(x);
  END
$$;

statement ok
DROP FUNCTION f;

# OPEN and FETCH statements.
statement ok
CREATE FUNCTION f() RETURNS TRIGGER LANGUAGE PLpgSQL AS $$
  DECLARE
    c CURSOR FOR SELECT 1;
    x INT;
  BEGIN
    OPEN c;
    FETCH c INTO x;
    CLOSE c;
    RETURN ROW(x);
  END
$$;

statement ok
DROP FUNCTION f;

# Combination of statements.
statement ok
CREATE FUNCTION f() RETURNS TRIGGER LANGUAGE PLpgSQL AS $$
  DECLARE
    x INT := 1;
    y INT := 2;
  BEGIN
    RAISE NOTICE 'x: %, y: %', x, y;
    IF x = 1 THEN
      RETURN ROW(1, 2);
    ELSE
      RETURN ROW(3, 4);
    END IF;
  END
$$;

statement ok
DROP FUNCTION f;

# ==============================================================================
# Correct usage of PL/pgSQL statements is enforced at function creation.
# ==============================================================================

subtest invalid_plpgsql

# RETURN statement must return a row.
statement error pgcode 42601 pq: missing expression at or near "RETURN;"
CREATE FUNCTION f() RETURNS TRIGGER LANGUAGE PLpgSQL AS $$ BEGIN RETURN; END $$;

# Assigning to a nonexistent variable is not allowed.
statement error pgcode 42601 pq: "nonexistent" is not a known variable
CREATE FUNCTION f() RETURNS TRIGGER LANGUAGE PLpgSQL AS $$
  BEGIN
    nonexistent := 'foo';
    RAISE NOTICE '%', nonexistent;
    RETURN NULL;
  END
$$;

# Cannot assign to a constant variable.
statement error pgcode 22005 pq: variable "x" is declared CONSTANT
CREATE FUNCTION f() RETURNS TRIGGER LANGUAGE PLpgSQL AS $$
  DECLARE
    x CONSTANT INT := 1;
  BEGIN
    x := 2;
    RETURN NULL;
  END
$$;

# Cursor cannot be opened with an INSERT statement.
statement error pgcode 42P11 pq: cannot open INSERT query as cursor
CREATE FUNCTION f() RETURNS TRIGGER LANGUAGE PLpgSQL AS $$
  DECLARE
    c CURSOR FOR INSERT INTO t VALUES (1);
  BEGIN
    OPEN c;
    RETURN NULL;
  END
$$;

# Transaction control statements are not allowed.
statement error pgcode 2D000 pq: invalid transaction termination
CREATE FUNCTION f() RETURNS TRIGGER LANGUAGE PLpgSQL AS $$ BEGIN COMMIT; RETURN NULL; END $$;

# ==============================================================================
# Trigger functions have a set of implicitly-defined variables.
# ==============================================================================

# It is possible to assign to the implicit variables, including OLD and NEW.
# TODO(#126727) The tg_op assignment is lower-cased because the INTO clause is
# currently case-sensitive.
statement ok
CREATE FUNCTION f() RETURNS TRIGGER LANGUAGE PLpgSQL AS $$
  BEGIN
    TG_NAME := 'foo';
    SELECT t INTO tg_op FROM ops_table;
    OLD := ROW(1, 2, 3);
    NEW := (SELECT * FROM xyz LIMIT 1);
    RETURN NEW;
  END
$$;

statement ok
DROP FUNCTION f;

# Shadowing the implicit variables is not allowed (tracked in #117508).
statement error pgcode 0A000 pq: unimplemented: variable shadowing is not yet implemented
CREATE FUNCTION f() RETURNS TRIGGER LANGUAGE PLpgSQL AS $$
  DECLARE
    tg_op TEXT := 'foo';
  BEGIN
    RETURN NEW;
  END
$$;

# ==============================================================================
# SQL expressions are not analyzed during function creation.
# ==============================================================================

subtest lazy_analysis

# Arbitrary variables/columns (and fields of those variables) may be referenced
# in an unbound PL/pgSQL trigger function, even if they do not exist.
statement ok
CREATE FUNCTION f() RETURNS TRIGGER LANGUAGE PLpgSQL AS $$
  DECLARE
    foo INT := NEW.x;
  BEGIN
    RAISE NOTICE '%', NEW.this_field_may_not_exist;
    RAISE NOTICE '%', OLD.we_do_not_now_until_trigger_creation;
    RETURN OLD.y + foo;
  END
$$;

statement ok
DROP FUNCTION f;

# Arbitrary relations may be referenced in an unbound PL/pgSQL trigger function,
# even if they do not exist.
statement ok
CREATE FUNCTION f() RETURNS TRIGGER LANGUAGE PLpgSQL AS $$
  DECLARE
    foo INT := (SELECT x FROM new_rows LIMIT 1);
  BEGIN
    RAISE NOTICE 'bar: %', (SELECT one, two FROM non_existent_table);
    RETURN (SELECT y FROM old_rows LIMIT 1) + foo;
  END
$$;

statement ok
DROP FUNCTION f;

# SQL statements must still have correct syntax.
statement error pgcode 42601 pq: at or near ";": at or near "sel": syntax error
CREATE FUNCTION f() RETURNS TRIGGER LANGUAGE PLpgSQL AS $$
  BEGIN
    SEL y FROM old_rows LIMIT 1;
    RETURN foo;
  END
$$;

# ==============================================================================
# Test CREATE OR REPLACE behavior for trigger functions.
# ==============================================================================

subtest create_or_replace

statement ok
CREATE FUNCTION f() RETURNS TRIGGER LANGUAGE PLpgSQL AS $$ BEGIN RETURN NULL; END $$;

statement ok
CREATE OR REPLACE FUNCTION f() RETURNS TRIGGER LANGUAGE PLpgSQL AS $$ BEGIN RETURN NULL; END $$;

# The first function should have been replaced.
query T
SELECT create_statement FROM [SHOW CREATE FUNCTION f];
----
CREATE FUNCTION public.f()
  RETURNS TRIGGER
  VOLATILE
  NOT LEAKPROOF
  CALLED ON NULL INPUT
  LANGUAGE plpgsql
  SECURITY INVOKER
  AS $$
  BEGIN
  RETURN NULL;
  END;
$$

statement ok
CREATE OR REPLACE FUNCTION f() RETURNS TRIGGER LANGUAGE PLpgSQL AS $$ BEGIN RETURN ROW(1, 2); END $$;

# The replacement function should have a different body.
query T
SELECT create_statement FROM [SHOW CREATE FUNCTION f];
----
CREATE FUNCTION public.f()
  RETURNS TRIGGER
  VOLATILE
  NOT LEAKPROOF
  CALLED ON NULL INPUT
  LANGUAGE plpgsql
  SECURITY INVOKER
  AS $$
  BEGIN
  RETURN (1, 2);
  END;
$$

statement ok
DROP FUNCTION f;

# CREATE OR REPLACE should succeed when there is no existing function.
statement ok
CREATE OR REPLACE FUNCTION f() RETURNS TRIGGER LANGUAGE PLpgSQL AS $$ BEGIN RETURN NULL; END $$;

query T
SELECT create_statement FROM [SHOW CREATE FUNCTION f];
----
CREATE FUNCTION public.f()
  RETURNS TRIGGER
  VOLATILE
  NOT LEAKPROOF
  CALLED ON NULL INPUT
  LANGUAGE plpgsql
  SECURITY INVOKER
  AS $$
  BEGIN
  RETURN NULL;
  END;
$$

statement ok
DROP FUNCTION f;

# ==============================================================================
# Test invalid target tables, views, and functions.
# ==============================================================================

subtest invalid_targets

statement ok
CREATE VIEW v AS SELECT * FROM xy;

statement ok
CREATE MATERIALIZED VIEW mv AS SELECT * FROM xy;

statement ok
CREATE FUNCTION f() RETURNS TRIGGER LANGUAGE PLpgSQL AS $$
  BEGIN
    RAISE NOTICE 'foo!';
    RETURN NULL;
  END;
$$;

# Nonexistent table.
statement error pgcode 42P01 pq: relation "nonexistent" does not exist
CREATE TRIGGER foo AFTER INSERT ON nonexistent FOR EACH ROW EXECUTE FUNCTION f();

# System tables cannot have triggers.
statement error pgcode 42501 pq: user root does not have TRIGGER privilege on relation jobs
CREATE TRIGGER foo BEFORE UPDATE ON system.jobs EXECUTE FUNCTION f();

# Virtual tables cannot have triggers.
statement error pgcode 42501 pq: user root does not have TRIGGER privilege on relation pg_roles
CREATE TRIGGER foo BEFORE UPDATE ON pg_catalog.pg_roles EXECUTE FUNCTION f();

# Materialized views cannot have triggers.
statement error pgcode 42809 pq: relation "mv" cannot have triggers\nDETAIL: This operation is not supported for materialized views.
CREATE TRIGGER foo AFTER DELETE ON mv FOR EACH ROW EXECUTE FUNCTION f();

# Nonexistent function.
statement error pgcode 42883 pq: unknown function: nonexistent()
CREATE TRIGGER foo BEFORE UPDATE ON xy FOR EACH ROW EXECUTE FUNCTION nonexistent();

statement ok
CREATE FUNCTION not_trigger() RETURNS INT LANGUAGE SQL AS $$ SELECT 1 $$;

# The function must be a trigger function.
statement error pgcode 42P17 pq: function not_trigger must return type trigger
CREATE TRIGGER foo AFTER INSERT ON xy FOR EACH ROW EXECUTE FUNCTION not_trigger();

# ==============================================================================
# Test invalid trigger options.
# ==============================================================================

subtest options

statement error pgcode 42809 pq: "xy" is a table\nDETAIL: Tables cannot have INSTEAD OF triggers.
CREATE TRIGGER foo INSTEAD OF INSERT ON xy EXECUTE FUNCTION f();

statement error pgcode 42809 pq: "xy" is a table\nDETAIL: Tables cannot have INSTEAD OF triggers.
CREATE TRIGGER foo INSTEAD OF UPDATE ON xy FOR EACH ROW EXECUTE FUNCTION f();

statement error pgcode 42809 pq: "v" is a view\nDETAIL: Views cannot have row-level BEFORE or AFTER triggers.
CREATE TRIGGER foo BEFORE UPDATE ON v FOR EACH ROW EXECUTE FUNCTION f();

statement error pgcode 42809 pq: "v" is a view\nDETAIL: Views cannot have row-level BEFORE or AFTER triggers.
CREATE TRIGGER foo AFTER INSERT ON v FOR EACH ROW EXECUTE FUNCTION f();

statement error pgcode 42809 pq: "v" is a view\nDETAIL: Views cannot have TRUNCATE triggers.
CREATE TRIGGER foo INSTEAD OF TRUNCATE ON v EXECUTE FUNCTION f();

statement error pgcode 0A000 pq: INSTEAD OF triggers must be FOR EACH ROW
CREATE TRIGGER foo INSTEAD OF INSERT ON v FOR EACH STATEMENT EXECUTE FUNCTION f();

statement error pgcode 0A000 pq: INSTEAD OF triggers cannot have WHEN conditions
CREATE TRIGGER foo INSTEAD OF INSERT ON v FOR EACH ROW WHEN (1 = 1) EXECUTE FUNCTION f();

statement error pgcode 0A000 pq: INSTEAD OF triggers cannot have column lists
CREATE TRIGGER foo INSTEAD OF UPDATE OF x, y ON v FOR EACH ROW EXECUTE FUNCTION f();

# Only UPDATE triggers can have column lists.
statement error pgcode 42601 pq: at or near "of": syntax error
CREATE TRIGGER foo BEFORE INSERT OF x, y ON xy FOR EACH ROW EXECUTE FUNCTION f();

statement error pgcode 42P17 pq: NEW TABLE can only be specified for an INSERT or UPDATE trigger
CREATE TRIGGER foo AFTER DELETE ON xy REFERENCING NEW TABLE AS nt EXECUTE FUNCTION f();

statement error pgcode 42P17 pq: OLD TABLE can only be specified for a DELETE or UPDATE trigger
CREATE TRIGGER foo AFTER INSERT ON xy REFERENCING OLD TABLE AS ot EXECUTE FUNCTION f();

statement error pgcode 42601 pq: cannot specify NEW more than once
CREATE TRIGGER foo AFTER UPDATE ON xy REFERENCING NEW TABLE AS nt NEW TABLE AS nt2 EXECUTE FUNCTION f();

statement error pgcode 42601 pq: cannot specify OLD more than once
CREATE TRIGGER foo AFTER UPDATE ON xy REFERENCING OLD TABLE AS ot OLD TABLE AS ot2 EXECUTE FUNCTION f();

statement error pgcode 0A000 pq: ROW variable naming in the REFERENCING clause is not supported
CREATE TRIGGER foo AFTER UPDATE ON xy REFERENCING OLD ROW AS ot EXECUTE FUNCTION f();

statement error pgcode 42P17 pq: OLD TABLE name and NEW TABLE name cannot be the same
CREATE TRIGGER foo AFTER UPDATE ON xy REFERENCING OLD TABLE AS nt NEW TABLE AS nt EXECUTE FUNCTION f();

statement error pgcode 42P17 pq: transition table name can only be specified for an AFTER trigger
CREATE TRIGGER foo BEFORE UPDATE ON xy REFERENCING NEW TABLE AS nt EXECUTE FUNCTION f();

statement error pgcode 42P17 pq: TRUNCATE triggers cannot specify transition tables
CREATE TRIGGER foo AFTER TRUNCATE ON xy REFERENCING NEW TABLE AS nt EXECUTE FUNCTION f();

statement error pgcode 0A000 pq: transition tables cannot be specified for triggers with more than one event
CREATE TRIGGER foo AFTER INSERT OR UPDATE ON xy REFERENCING NEW TABLE AS nt EXECUTE FUNCTION f();

statement error pgcode 0A000 pq: transition tables cannot be specified for triggers with column lists
CREATE TRIGGER foo AFTER UPDATE OF x ON xy REFERENCING NEW TABLE AS nt EXECUTE FUNCTION f();

# ==============================================================================
# Test invalid trigger WHEN clause.
# ==============================================================================

subtest when_clause

# The WHEN clause must be of type BOOL.
statement error pgcode 42804 pq: argument of WHEN must be type bool, not type int
CREATE TRIGGER foo AFTER INSERT ON xy FOR EACH ROW WHEN (1) EXECUTE FUNCTION f();

# The WHEN clause cannot reference table columns.
statement error pgcode 42703 pq: column "x" does not exist\nHINT: column references in a trigger WHEN clause must be prefixed with NEW or OLD
CREATE TRIGGER foo AFTER INSERT ON xy FOR EACH ROW WHEN (x = 1) EXECUTE FUNCTION f();

# The WHEN clause cannot contain a subquery.
statement error pgcode 0A000 pq: subqueries are not allowed in WHEN
CREATE TRIGGER foo AFTER INSERT ON xy FOR EACH ROW WHEN (SELECT 1) EXECUTE FUNCTION f();

# TODO(#126362): uncomment these test cases.
# statement error pgcode 42P17 pq: statement trigger's WHEN condition cannot reference column values
# CREATE TRIGGER foo AFTER INSERT ON xy WHEN (NEW IS NULL) EXECUTE FUNCTION f();
#
# statement error pgcode 42P17 pq: statement trigger's WHEN condition cannot reference column values
# CREATE TRIGGER foo AFTER INSERT ON xy WHEN (OLD IS NULL) EXECUTE FUNCTION f();

statement error pgcode 42P17 pq: DELETE trigger's WHEN condition cannot reference NEW values
CREATE TRIGGER foo AFTER DELETE ON xy FOR EACH ROW WHEN (NEW IS NULL) EXECUTE FUNCTION f();

statement error pgcode 42P17 pq: INSERT trigger's WHEN condition cannot reference OLD values
CREATE TRIGGER foo AFTER INSERT ON xy FOR EACH ROW WHEN (OLD IS NULL) EXECUTE FUNCTION f();

# ==============================================================================
# Test early binding/validation on trigger creation.
# ==============================================================================

subtest early_binding

# SQL statements and expressions within a trigger function are lazily validated.
# This means that trigger function creation will catch syntax errors in SQL, but
# not other types of errors.
#
# Case with a nonexistent table.
statement ok
CREATE FUNCTION g() RETURNS TRIGGER AS $$
  BEGIN
    INSERT INTO nonexistent VALUES (1, 2);
    RETURN NULL;
  END;
$$ LANGUAGE PLpgSQL;

statement error pgcode 42P01 pq: relation "nonexistent" does not exist
CREATE TRIGGER foo BEFORE INSERT ON xy FOR EACH ROW EXECUTE FUNCTION g();

statement ok
DROP FUNCTION g;
CREATE FUNCTION g() RETURNS TRIGGER AS $$
  BEGIN
    IF (SELECT count(*) FROM nonexistent) > 0 THEN
      RETURN NULL;
    ELSE
      RETURN NEW;
    END IF;
  END;
$$ LANGUAGE PLpgSQL;

statement error pgcode 42P01 pq: relation "nonexistent" does not exist
CREATE TRIGGER foo AFTER UPDATE ON xy FOR EACH ROW EXECUTE FUNCTION g();

# Case with a nonexistent function reference.
statement ok
DROP FUNCTION g;
CREATE FUNCTION g() RETURNS TRIGGER AS $$
  BEGIN
    RAISE NOTICE '%', f_nonexistent();
    RETURN NEW;
  END;
$$ LANGUAGE PLpgSQL;

statement error pgcode 42883 pq: unknown function: f_nonexistent()
CREATE TRIGGER foo AFTER DELETE ON xy FOR EACH ROW EXECUTE FUNCTION g();

# Case with a nonexistent type reference.
statement ok
DROP FUNCTION g;
CREATE FUNCTION g() RETURNS TRIGGER AS $$
  BEGIN
    RETURN ROW(1, 2)::typ_nonexistent;
  END;
$$ LANGUAGE PLpgSQL;

statement error pgcode 42704 pq: type "typ_nonexistent" does not exist
CREATE TRIGGER foo BEFORE INSERT ON xy FOR EACH ROW EXECUTE FUNCTION g();

# Incorrect type in a SQL expression.
statement ok
DROP FUNCTION g;
CREATE FUNCTION g() RETURNS TRIGGER AS $$
  BEGIN
    IF 'not a bool' THEN
      RETURN NEW;
    ELSE
      RETURN NULL;
    END IF;
  END;
$$ LANGUAGE PLpgSQL;

statement error pgcode 22P02 pq: could not parse "not a bool" as type bool: invalid bool value
CREATE TRIGGER foo AFTER UPDATE ON xy FOR EACH ROW EXECUTE FUNCTION g();

# Disallowed SQL statement.
statement ok
DROP FUNCTION g;
CREATE FUNCTION g() RETURNS TRIGGER AS $$
  BEGIN
    CREATE TABLE foo (x INT, y INT);
    RETURN NEW;
  END;
$$ LANGUAGE PLpgSQL;

statement error pgcode 0A000 pq: unimplemented: CREATE TABLE usage inside a function definition
CREATE TRIGGER foo AFTER DELETE ON xy FOR EACH ROW EXECUTE FUNCTION g();

statement ok
DROP FUNCTION g;

# Incorrect function volatility.
statement ok
CREATE TABLE t (a INT, b INT);
CREATE FUNCTION g() RETURNS TRIGGER LANGUAGE PLpgSQL IMMUTABLE AS $$
  BEGIN
    SELECT count(*) FROM t;
    RETURN NEW;
  END;
$$;

statement error pgcode 22023 pq: referencing relations is not allowed in immutable function
CREATE TRIGGER foo AFTER INSERT ON xy FOR EACH ROW EXECUTE FUNCTION g();

statement ok
DROP FUNCTION g();
DROP TABLE t;

# ==============================================================================
# Test duplicate and nonexistent triggers as CREATE/DROP targets.
# ==============================================================================

subtest duplicate_nonexistent

statement ok
CREATE TRIGGER foo AFTER INSERT ON xy FOR EACH ROW EXECUTE FUNCTION f();

statement error pgcode 42710 pq: trigger "foo" for relation "xy" already exists
CREATE TRIGGER foo AFTER INSERT ON xy FOR EACH ROW EXECUTE FUNCTION f();

# It is possible to create another trigger with a different name.
statement ok
CREATE TRIGGER bar AFTER INSERT ON xy FOR EACH ROW EXECUTE FUNCTION f();

statement ok
DROP TRIGGER foo ON xy;

statement ok
DROP TRIGGER bar ON xy;

# Dropping a nonexistent trigger is an error.
statement error pgcode 42704 pq: trigger "foo" for table "xy" does not exist
DROP TRIGGER foo ON xy;

# The IF EXISTS syntax allows dropping a nonexistent trigger without error.
statement ok
DROP TRIGGER IF EXISTS foo ON xy;

# CASCADE and RESTRICT are accepted for PostgreSQL compatibility. Since triggers
# don't have dependents, they behave identically to a drop without these options.
statement ok
CREATE TRIGGER foo AFTER INSERT ON xy FOR EACH ROW EXECUTE FUNCTION f();

statement ok
DROP TRIGGER foo ON xy CASCADE;

statement ok
CREATE TRIGGER foo AFTER INSERT ON xy FOR EACH ROW EXECUTE FUNCTION f();

statement ok
DROP TRIGGER foo ON xy RESTRICT;

# ==============================================================================
# Test dependency tracking for a relation reference.
# ==============================================================================

subtest relation_dependency

statement ok
CREATE TABLE t (a INT, b INT);

statement ok
CREATE FUNCTION g() RETURNS TRIGGER LANGUAGE PLpgSQL AS $$
  BEGIN
    INSERT INTO t VALUES (1, 2);
    RETURN NULL;
  END;
$$;

statement ok
CREATE TRIGGER foo AFTER INSERT ON xy FOR EACH ROW EXECUTE FUNCTION g();

statement error pgcode 2BP01 pq: cannot drop table t because other objects depend on it
DROP TABLE t;

statement error pgcode 2BP01 pq: cannot drop function "g" because other objects \(\[test.public.xy\]\) still depend on it
DROP FUNCTION g;

statement ok
DROP TRIGGER foo ON xy;

statement ok
DROP TABLE t;

# Now, the trigger function refers to a nonexistent relation, so the trigger
# cannot be created.
statement error pgcode 42P01 pq: relation "t" does not exist
CREATE TRIGGER foo AFTER INSERT ON xy FOR EACH ROW EXECUTE FUNCTION g();

statement ok
DROP FUNCTION g;

subtest pg_trigger_depth

# Test pg_trigger_depth() - based on PostgreSQL regress test.

statement ok
CREATE TABLE depth_a (id INT NOT NULL PRIMARY KEY);

statement ok
CREATE TABLE depth_b (id INT NOT NULL PRIMARY KEY);

statement ok
CREATE TABLE depth_c (id INT NOT NULL PRIMARY KEY);

statement ok
CREATE FUNCTION depth_a_tf() RETURNS TRIGGER LANGUAGE PLpgSQL AS $$
BEGIN
  RAISE NOTICE '%: depth = %', TG_NAME, pg_trigger_depth();
  INSERT INTO depth_b VALUES ((NEW).id);
  RAISE NOTICE '%: depth = %', TG_NAME, pg_trigger_depth();
  RETURN NEW;
END;
$$;

statement ok
CREATE TRIGGER depth_a_tr BEFORE INSERT ON depth_a
  FOR EACH ROW EXECUTE FUNCTION depth_a_tf();

statement ok
CREATE FUNCTION depth_b_tf() RETURNS TRIGGER LANGUAGE PLpgSQL AS $$
BEGIN
  RAISE NOTICE '%: depth = %', TG_NAME, pg_trigger_depth();
  INSERT INTO depth_c VALUES ((NEW).id);
  RAISE NOTICE '%: depth = %', TG_NAME, pg_trigger_depth();
  RETURN NEW;
END;
$$;

statement ok
CREATE TRIGGER depth_b_tr BEFORE INSERT ON depth_b
  FOR EACH ROW EXECUTE FUNCTION depth_b_tf();

statement ok
CREATE FUNCTION depth_c_tf() RETURNS TRIGGER LANGUAGE PLpgSQL AS $$
BEGIN
  RAISE NOTICE '%: depth = %', TG_NAME, pg_trigger_depth();
  RETURN NEW;
END;
$$;

statement ok
CREATE TRIGGER depth_c_tr BEFORE INSERT ON depth_c
  FOR EACH ROW EXECUTE FUNCTION depth_c_tf();

# pg_trigger_depth() returns 0 outside of triggers.
query I
SELECT pg_trigger_depth();
----
0

# Insert into depth_a triggers a cascade: depth_a -> depth_b -> depth_c.
# depth_a_tr fires at depth 1, depth_b_tr at depth 2, depth_c_tr at depth 3.
query T noticetrace
INSERT INTO depth_a VALUES (1);
----
NOTICE: depth_a_tr: depth = 1
NOTICE: depth_b_tr: depth = 2
NOTICE: depth_c_tr: depth = 3
NOTICE: depth_b_tr: depth = 2
NOTICE: depth_a_tr: depth = 1

query I
SELECT pg_trigger_depth();
----
0

# Test with AFTER triggers as well.
statement ok
CREATE TABLE depth_after (id INT NOT NULL PRIMARY KEY);

statement ok
CREATE FUNCTION depth_after_tf() RETURNS TRIGGER LANGUAGE PLpgSQL AS $$
BEGIN
  RAISE NOTICE '%: depth = %', TG_NAME, pg_trigger_depth();
  RETURN NULL;
END;
$$;

statement ok
CREATE TRIGGER depth_after_tr AFTER INSERT ON depth_after
  FOR EACH ROW EXECUTE FUNCTION depth_after_tf();

query T noticetrace
INSERT INTO depth_after VALUES (1);
----
NOTICE: depth_after_tr: depth = 1

statement ok
DROP TABLE depth_after CASCADE;

statement ok
DROP FUNCTION depth_after_tf;

statement ok
DROP TABLE depth_a, depth_b, depth_c CASCADE;

statement ok
DROP FUNCTION depth_a_tf, depth_b_tf, depth_c_tf;

subtest end

# ==============================================================================
# Test replacing a trigger function with active triggers (issue #134555).
# The new function body should take effect for all dependent triggers.
# ==============================================================================

subtest replace_trigger_function_with_active_triggers

skipif config local-mixed-25.4 local-mixed-26.1
statement ok
CREATE TABLE t_replace (a INT PRIMARY KEY, b TEXT);

skipif config local-mixed-25.4 local-mixed-26.1
statement ok
CREATE TABLE audit_log (op TEXT, val TEXT);

# Create a trigger function that logs 'v1' to identify the original version.
skipif config local-mixed-25.4 local-mixed-26.1
statement ok
CREATE FUNCTION tf_replace() RETURNS TRIGGER LANGUAGE PLpgSQL AS $$
  BEGIN
    INSERT INTO audit_log VALUES (tg_op, 'v1');
    RETURN NEW;
  END
$$;

skipif config local-mixed-25.4 local-mixed-26.1
statement ok
CREATE TRIGGER tr_replace BEFORE INSERT ON t_replace FOR EACH ROW EXECUTE FUNCTION tf_replace();

# Verify the trigger fires with the original function body.
skipif config local-mixed-25.4 local-mixed-26.1
statement ok
INSERT INTO t_replace VALUES (1, 'hello');

skipif config local-mixed-25.4 local-mixed-26.1
query TT
SELECT * FROM audit_log ORDER BY op;
----
INSERT  v1

skipif config local-mixed-25.4 local-mixed-26.1
statement count 1
DELETE FROM audit_log;

# Replace the trigger function with a new body that logs 'v2'.
skipif config local-mixed-25.4 local-mixed-26.1
statement ok
CREATE OR REPLACE FUNCTION tf_replace() RETURNS TRIGGER LANGUAGE PLpgSQL AS $$
  BEGIN
    INSERT INTO audit_log VALUES (tg_op, 'v2');
    RETURN NEW;
  END
$$;

# Verify the trigger fires with the new function body.
skipif config local-mixed-25.4 local-mixed-26.1
statement ok
INSERT INTO t_replace VALUES (2, 'world');

skipif config local-mixed-25.4 local-mixed-26.1
query TT
SELECT * FROM audit_log ORDER BY op;
----
INSERT  v2

skipif config local-mixed-25.4 local-mixed-26.1
statement ok
DROP TRIGGER tr_replace ON t_replace;

skipif config local-mixed-25.4 local-mixed-26.1
statement ok
DROP TABLE t_replace, audit_log;

skipif config local-mixed-25.4 local-mixed-26.1
statement ok
DROP FUNCTION tf_replace;

subtest end

subtest replace_trigger_function_multiple_triggers

skipif config local-mixed-25.4 local-mixed-26.1
statement ok
CREATE TABLE t_m1 (a INT PRIMARY KEY);

skipif config local-mixed-25.4 local-mixed-26.1
statement ok
CREATE TABLE t_m2 (a INT PRIMARY KEY);

skipif config local-mixed-25.4 local-mixed-26.1
statement ok
CREATE TABLE audit_log (src TEXT, val TEXT);

skipif config local-mixed-25.4 local-mixed-26.1
statement ok
CREATE FUNCTION tf_multi() RETURNS TRIGGER LANGUAGE PLpgSQL AS $$
  BEGIN
    INSERT INTO audit_log VALUES (tg_table_name, 'v1');
    RETURN NEW;
  END
$$;

skipif config local-mixed-25.4 local-mixed-26.1
statement ok
CREATE TRIGGER tr1 BEFORE INSERT ON t_m1 FOR EACH ROW EXECUTE FUNCTION tf_multi();

skipif config local-mixed-25.4 local-mixed-26.1
statement ok
CREATE TRIGGER tr2 BEFORE INSERT ON t_m2 FOR EACH ROW EXECUTE FUNCTION tf_multi();

skipif config local-mixed-25.4 local-mixed-26.1
statement ok
INSERT INTO t_m1 VALUES (1);

skipif config local-mixed-25.4 local-mixed-26.1
statement ok
INSERT INTO t_m2 VALUES (1);

skipif config local-mixed-25.4 local-mixed-26.1
query TT rowsort
SELECT * FROM audit_log;
----
t_m1  v1
t_m2  v1

skipif config local-mixed-25.4 local-mixed-26.1
statement count 2
DELETE FROM audit_log;

# Replace the function — both triggers should pick up the new body.
skipif config local-mixed-25.4 local-mixed-26.1
statement ok
CREATE OR REPLACE FUNCTION tf_multi() RETURNS TRIGGER LANGUAGE PLpgSQL AS $$
  BEGIN
    INSERT INTO audit_log VALUES (tg_table_name, 'v2');
    RETURN NEW;
  END
$$;

skipif config local-mixed-25.4 local-mixed-26.1
statement ok
INSERT INTO t_m1 VALUES (2);

skipif config local-mixed-25.4 local-mixed-26.1
statement ok
INSERT INTO t_m2 VALUES (2);

skipif config local-mixed-25.4 local-mixed-26.1
query TT rowsort
SELECT * FROM audit_log;
----
t_m1  v2
t_m2  v2

skipif config local-mixed-25.4 local-mixed-26.1
statement ok
DROP TRIGGER tr1 ON t_m1;

skipif config local-mixed-25.4 local-mixed-26.1
statement ok
DROP TRIGGER tr2 ON t_m2;

skipif config local-mixed-25.4 local-mixed-26.1
statement ok
DROP TABLE t_m1, t_m2, audit_log;

skipif config local-mixed-25.4 local-mixed-26.1
statement ok
DROP FUNCTION tf_multi;

subtest end

# ==============================================================================
# Test that replacing a trigger function correctly updates dependency tracking.
# After replacement, new deps should be tracked and old deps should be released.
# ==============================================================================

subtest replace_trigger_function_deps

skipif config local-mixed-25.4 local-mixed-26.1
statement ok
CREATE TYPE my_enum AS ENUM ('a', 'b');

skipif config local-mixed-25.4 local-mixed-26.1
statement ok
CREATE TABLE t_deps (a INT PRIMARY KEY);

skipif config local-mixed-25.4 local-mixed-26.1
statement ok
CREATE TABLE log_deps (val TEXT);

skipif config local-mixed-25.4 local-mixed-26.1
statement ok
CREATE TABLE other_log (val TEXT);

# Start with a simple trigger function that does not reference the type or other_log.
skipif config local-mixed-25.4 local-mixed-26.1
statement ok
CREATE FUNCTION tf_deps() RETURNS TRIGGER LANGUAGE PLpgSQL AS $$
  BEGIN
    INSERT INTO log_deps VALUES ('fired');
    RETURN NEW;
  END
$$;

skipif config local-mixed-25.4 local-mixed-26.1
statement ok
CREATE TRIGGER tr_deps BEFORE INSERT ON t_deps FOR EACH ROW EXECUTE FUNCTION tf_deps();

# The type and other_log are not yet referenced, so they can be dropped.
# (Don't actually drop them — just verify no dependency error.)

# Replace the function to reference the enum type and other_log table.
skipif config local-mixed-25.4 local-mixed-26.1
statement ok
CREATE OR REPLACE FUNCTION tf_deps() RETURNS TRIGGER LANGUAGE PLpgSQL AS $$
  BEGIN
    INSERT INTO other_log VALUES ('a'::my_enum::TEXT);
    RETURN NEW;
  END
$$;

# Verify the trigger fires with the new body.
skipif config local-mixed-25.4 local-mixed-26.1
statement ok
INSERT INTO t_deps VALUES (1);

skipif config local-mixed-25.4 local-mixed-26.1
query T
SELECT * FROM other_log;
----
a

# Now the type and other_log are referenced — dropping them should be blocked.
skipif config local-mixed-25.4 local-mixed-26.1
statement error pq: cannot drop type "my_enum" because other objects \(\[test.public.t_deps\]\) still depend on it
DROP TYPE my_enum;

skipif config local-mixed-25.4 local-mixed-26.1
statement error pq: cannot drop relation "other_log" because trigger "tr_deps" on table "t_deps" depends on it
DROP TABLE other_log;

# log_deps is no longer referenced after the replace, so it can be dropped.
skipif config local-mixed-25.4 local-mixed-26.1
statement ok
DROP TABLE log_deps;

# Clean up.
skipif config local-mixed-25.4 local-mixed-26.1
statement ok
DROP TRIGGER tr_deps ON t_deps;

skipif config local-mixed-25.4 local-mixed-26.1
statement ok
DROP TABLE t_deps, other_log;

skipif config local-mixed-25.4 local-mixed-26.1
statement ok
DROP FUNCTION tf_deps;

skipif config local-mixed-25.4 local-mixed-26.1
statement ok
DROP TYPE my_enum;

subtest end

subtest regression_134630

statement ok
CREATE TABLE t1 (a INT, b INT);
CREATE TABLE t2 (a INT, b INT);

statement ok
CREATE FUNCTION g() RETURNS TRIGGER LANGUAGE PLpgSQL AS $$
  BEGIN
    INSERT INTO t2 VALUES ((NEW).a, (NEW).b);
    RETURN NEW;
  END
$$;

statement ok
CREATE TRIGGER foo BEFORE INSERT OR UPDATE ON t1 FOR EACH ROW EXECUTE FUNCTION g();

# Make sure the legacy schema-changer correctly removes the backreference from
# t2 to t1.
statement ok
SET autocommit_before_ddl = false

statement ok
DROP TABLE t1;
DROP TABLE t2;
DROP FUNCTION g;

statement ok
RESET autocommit_before_ddl

# ==============================================================================
# Test dependency tracking for a user-defined type reference.
# ==============================================================================

subtest type_dependency

statement ok
CREATE TYPE typ AS (x INT, y INT);

statement ok
CREATE FUNCTION g() RETURNS TRIGGER LANGUAGE PLpgSQL AS $$
  DECLARE
    a typ;
  BEGIN
    RETURN a;
  END;
$$;

statement ok
CREATE TRIGGER foo AFTER INSERT ON xy FOR EACH ROW EXECUTE FUNCTION g();

statement error pgcode 2BP01 pq: cannot drop type "typ" because other objects \(\[test.public.xy\]\) still depend on it
DROP TYPE typ;

statement error pgcode 2BP01 pq: cannot drop function "g" because other objects \(\[test.public.xy\]\) still depend on it
DROP FUNCTION g;

statement ok
DROP TRIGGER foo ON xy;

statement ok
DROP TYPE typ;

# Now, the trigger function refers to a nonexistent type, so the trigger
# cannot be created.
statement error pgcode 42704 pq: type "typ" does not exist
CREATE TRIGGER foo AFTER INSERT ON xy FOR EACH ROW EXECUTE FUNCTION g();

statement ok
DROP FUNCTION g;

# ==============================================================================
# Test dependency tracking for a routine reference.
# ==============================================================================

subtest routine_dependency

statement ok
CREATE FUNCTION g() RETURNS INT LANGUAGE SQL AS $$ SELECT 1; $$;

statement ok
CREATE FUNCTION g2() RETURNS TRIGGER LANGUAGE PLpgSQL AS $$
  BEGIN
    RAISE NOTICE '%', g();
    RETURN NULL;
  END;
$$;

statement ok
CREATE TRIGGER foo AFTER INSERT ON xy FOR EACH ROW EXECUTE FUNCTION g2();

statement error pgcode 2BP01 pq: cannot drop function "g" because other objects \(\[test.public.xy\]\) still depend on it
DROP FUNCTION g;

statement ok
DROP TRIGGER foo ON xy;

statement ok
DROP FUNCTION g;

# Now, the trigger function refers to a nonexistent routine, so the trigger
# cannot be created.
statement error pgcode 42883 pq: unknown function: g()
CREATE TRIGGER foo AFTER INSERT ON xy FOR EACH ROW EXECUTE FUNCTION g2();

statement ok
DROP FUNCTION g2;

# ==============================================================================
# Test renaming referenced objects.
# ==============================================================================

subtest renaming

statement ok
CREATE TABLE t (a INT, b INT);

statement ok
CREATE SEQUENCE s;

statement ok
CREATE TYPE typ AS (x INT, y INT);

statement ok
CREATE FUNCTION g() RETURNS INT LANGUAGE SQL AS $$ SELECT 1; $$;

statement ok
CREATE FUNCTION trigger_func() RETURNS TRIGGER LANGUAGE PLpgSQL AS $$
  DECLARE
    a typ;
  BEGIN
    RAISE NOTICE '%, %', g(), nextval('s');
    INSERT INTO t VALUES (1, 2);
    RETURN a;
  END;
$$;

statement ok
CREATE TRIGGER foo AFTER INSERT ON xy FOR EACH ROW EXECUTE FUNCTION trigger_func();

# Relations are referenced by name, so renaming the table is not allowed.
onlyif config local-legacy-schema-changer
statement error pgcode 2BP01 cannot rename relation "t" because trigger "foo" on table "xy" depends on it
ALTER TABLE t RENAME TO t2;

skipif config local-legacy-schema-changer
statement error pgcode 2BP01 cannot rename relation "test.public.t" because trigger "foo" on table "xy" depends on it
ALTER TABLE t RENAME TO t2;

# Sequences are remapped to their IDs, so renaming is allowed.
statement ok
ALTER SEQUENCE s RENAME TO s2;

# Types are remapped to their IDs, so renaming is allowed.
statement ok
ALTER TYPE typ RENAME TO typ2;

# Routines are referenced by name, so renaming is not allowed.
statement ok
ALTER FUNCTION g RENAME TO g2;

statement ok
DROP TRIGGER foo ON xy;

statement ok
DROP FUNCTION trigger_func;
DROP FUNCTION g2;
DROP TYPE typ2;
DROP SEQUENCE s2;
DROP TABLE t;

# ==============================================================================
# Test privilege checks.
# ==============================================================================

subtest privileges

statement ok
CREATE TABLE t (a INT, b INT);

statement ok
CREATE FUNCTION g() RETURNS TRIGGER LANGUAGE PLpgSQL AS $$ BEGIN RETURN NULL; END $$;

statement ok
REVOKE EXECUTE ON FUNCTION g() FROM PUBLIC;

user testuser

# Trigger creation requires the TRIGGER privilege on the target table.
statement error pgcode 42501 pq: user testuser does not have TRIGGER privilege on relation t
CREATE TRIGGER foo AFTER INSERT ON t FOR EACH ROW EXECUTE FUNCTION g();

user root

statement ok
GRANT TRIGGER ON TABLE t TO testuser;

user testuser

# Trigger creation requires the EXECUTE privilege on the trigger function.
statement error pgcode 42501 pq: user testuser does not have EXECUTE privilege on function g
CREATE TRIGGER foo AFTER INSERT ON t FOR EACH ROW EXECUTE FUNCTION g();

user root

statement ok
GRANT EXECUTE ON FUNCTION g TO testuser;

user testuser

# With TRIGGER on the table and EXECUTE on the function, the user can create
# a trigger. The user does not have to own the table or function.
statement ok
CREATE TRIGGER foo AFTER INSERT ON t FOR EACH ROW EXECUTE FUNCTION g();

# The user can only drop the trigger if they own the table.
statement error pgcode 42501 pq: must be owner of relation t
DROP TRIGGER foo ON t;

user root

statement ok
ALTER TABLE t OWNER TO testuser;

statement ok
REVOKE ALL ON TABLE t FROM testuser;
REVOKE ALL ON FUNCTION g FROM testuser;

user testuser

# Now the user can drop the trigger, despite having no privileges on either the
# function or the table.
statement ok
DROP TRIGGER foo ON t;

user root

statement ok
DROP FUNCTION g;
DROP TABLE t;

# ==============================================================================
# Test cascading drops with a trigger.
# ==============================================================================

subtest cascade_dsc

statement ok
CREATE DATABASE db;

statement ok
USE db;

statement ok
CREATE FUNCTION i() RETURNS TRIGGER LANGUAGE PLpgSQL AS $$ BEGIN SELECT 1 FROM t; RETURN NULL; END; $$;

statement ok
CREATE TABLE t (a INT, b INT);

statement ok
CREATE FUNCTION g() RETURNS TRIGGER LANGUAGE PLpgSQL AS $$ BEGIN SELECT a, b FROM t; RETURN NULL; END; $$;

statement ok
CREATE TRIGGER foo AFTER INSERT ON t FOR EACH ROW EXECUTE FUNCTION g();

statement ok
CREATE TRIGGER bar AFTER INSERT ON t FOR EACH ROW EXECUTE FUNCTION i();

statement ok
USE test;

statement ok
DROP DATABASE db CASCADE;

statement ok
CREATE SCHEMA s;

statement ok
CREATE TABLE s.t (a INT, b INT);

statement ok
CREATE FUNCTION s.g() RETURNS TRIGGER LANGUAGE PLpgSQL AS $$ BEGIN SELECT * FROM s.t; RETURN NULL; END; $$;

statement ok
CREATE TRIGGER foo AFTER INSERT ON s.t FOR EACH ROW EXECUTE FUNCTION s.g();

statement ok
DROP SCHEMA s CASCADE;

# Like cascade_dsc, but the DROP is doing with the legacy schema changer
subtest cascade_legacy

let $use_decl_sc
SHOW use_declarative_schema_changer

statement ok
CREATE DATABASE db;

statement ok
USE db;

statement ok
CREATE FUNCTION i() RETURNS TRIGGER LANGUAGE PLpgSQL AS $$ BEGIN SELECT 1 FROM other; RETURN NULL; END; $$;

statement ok
CREATE TABLE t (a INT, b INT);

statement ok
CREATE TABLE other (n INT PRIMARY KEY, j INT);

statement ok
CREATE FUNCTION g() RETURNS TRIGGER LANGUAGE PLpgSQL AS $$ BEGIN SELECT a, b FROM t; RETURN NULL; END; $$;

statement ok
CREATE TRIGGER foo AFTER INSERT ON t FOR EACH ROW EXECUTE FUNCTION g();

statement ok
CREATE TRIGGER bar AFTER INSERT ON t FOR EACH ROW EXECUTE FUNCTION i();

statement ok
USE test;

statement ok
set use_declarative_schema_changer = 'off';

statement ok
DROP DATABASE db CASCADE;

statement ok
SET use_declarative_schema_changer = $use_decl_sc;

statement ok
CREATE SCHEMA s;

statement ok
CREATE TABLE s.t (a INT, b INT);

statement ok
CREATE TABLE s.other (n INT PRIMARY KEY);

statement ok
CREATE FUNCTION s.g() RETURNS TRIGGER LANGUAGE PLpgSQL AS $$ BEGIN SELECT * FROM s.t; SELECT 1 FROM s.other; RETURN NULL; END; $$;

statement ok
CREATE TRIGGER foo AFTER INSERT ON s.t FOR EACH ROW EXECUTE FUNCTION s.g();

statement ok
set use_declarative_schema_changer = 'off';

statement ok
DROP SCHEMA s CASCADE;

statement ok
SET use_declarative_schema_changer = $use_decl_sc;

# ==============================================================================
# Test references across schemas and databases.
# ==============================================================================

subtest cross_schema_database

statement ok
CREATE SCHEMA s;

statement ok
CREATE DATABASE db;

statement ok
CREATE TABLE s.xy (x INT, y INT);

statement ok
CREATE FUNCTION s.f() RETURNS TRIGGER LANGUAGE PLpgSQL AS $$
  BEGIN
    RAISE NOTICE 'bar!';
    RETURN NULL;
  END;
$$;

statement ok
CREATE TYPE s.typ AS (x INT, y INT);

statement ok
USE db;

statement ok
CREATE TABLE xy (x INT, y INT);

statement ok
CREATE FUNCTION f() RETURNS TRIGGER LANGUAGE PLpgSQL AS $$
  BEGIN
    RAISE NOTICE 'baz!';
    RETURN NULL;
  END;
$$;

statement ok
CREATE TYPE typ AS (x INT, y INT);

statement ok
USE test;

statement ok
CREATE TRIGGER foo AFTER INSERT ON s.xy FOR EACH ROW EXECUTE FUNCTION s.f();

statement ok
DROP TRIGGER foo ON s.xy;

statement ok
CREATE TRIGGER foo AFTER INSERT ON xy FOR EACH ROW EXECUTE FUNCTION s.f();

statement ok
DROP TRIGGER foo ON xy;

statement ok
CREATE TRIGGER foo AFTER INSERT ON s.xy FOR EACH ROW EXECUTE FUNCTION f();

statement ok
DROP TRIGGER foo ON s.xy;

statement error pgcode 0A000 pq: cross-database function references not allowed
CREATE TRIGGER foo AFTER INSERT ON xy FOR EACH ROW EXECUTE FUNCTION db.public.f();

statement error pgcode 0A000 pq: unimplemented: cross-db references not supported
CREATE TRIGGER foo AFTER INSERT ON db.public.xy FOR EACH ROW EXECUTE FUNCTION f();

statement error pgcode 0A000 pq: unimplemented: cross-db references not supported
CREATE TRIGGER foo AFTER INSERT ON db.public.xy FOR EACH ROW EXECUTE FUNCTION db.public.f();

statement ok
CREATE FUNCTION g() RETURNS TRIGGER LANGUAGE PLpgSQL AS $$
  BEGIN
    INSERT INTO db.xy VALUES (1, 2);
    RETURN NULL;
  END;
$$;

statement error pgcode 0A000 pq: dependent relation xy cannot be from another database
CREATE TRIGGER foo AFTER INSERT ON xy FOR EACH ROW EXECUTE FUNCTION g();

statement ok
DROP FUNCTION g;

statement ok
CREATE FUNCTION g() RETURNS TRIGGER LANGUAGE PLpgSQL AS $$
  BEGIN
    RAISE NOTICE '%', pg_typeof(ROW(1, 2)::db.typ);
    RETURN NULL;
  END;
$$;

statement error pgcode 0A000 pq: cross database type references are not supported: db.public.typ
CREATE TRIGGER foo AFTER INSERT ON xy FOR EACH ROW EXECUTE FUNCTION g();

statement ok
DROP FUNCTION g;

statement ok
DROP SCHEMA s CASCADE;

statement ok
DROP DATABASE db CASCADE;

# ==============================================================================
# Test cyclical table references.
# ==============================================================================

subtest cyclical

statement ok
CREATE TABLE t (a INT, b INT);

statement ok
CREATE FUNCTION g() RETURNS TRIGGER LANGUAGE PLpgSQL AS $$
  DECLARE
    cnt INT := 0;
  BEGIN
    SELECT count(*) INTO cnt FROM t;
    IF cnt < 10 THEN
      INSERT INTO t VALUES (1, 2);
    END IF;
    RAISE NOTICE 'HERE';
    RETURN NULL;
  END;
$$;

# NOTE: the trigger is both attached to table "t", and references it via the
# trigger function. This should not prevent dropping the trigger or table.
statement ok
CREATE TRIGGER foo AFTER INSERT ON t FOR EACH ROW EXECUTE FUNCTION g();

statement ok
DROP TRIGGER foo ON t;

statement ok
CREATE TRIGGER foo AFTER INSERT ON t FOR EACH ROW EXECUTE FUNCTION g();

statement ok
DROP TABLE t;

statement ok
DROP FUNCTION g;

# ==============================================================================
# Test changing search path.
# ==============================================================================

subtest search_path

let $xy_oid
SELECT oid FROM pg_class WHERE relname = 'xy';

statement ok
CREATE PROCEDURE show_triggers() LANGUAGE PLpgSQL AS $$
  DECLARE
    foo JSON;
    name JSON;
    body JSON;
    curs REFCURSOR;
  BEGIN
    SELECT
      crdb_internal.pb_to_json(
        'cockroach.sql.sqlbase.Descriptor',
        descriptor,
        false
      ) INTO foo
    FROM
      system.descriptor
    WHERE id = $xy_oid;
    foo := foo->'table'->'triggers';
    OPEN curs FOR SELECT value->'name', value->'funcBody' FROM jsonb_array_elements(foo);
    LOOP
      FETCH curs INTO name, body;
      IF name IS NULL THEN
        EXIT;
      END IF;
      RAISE NOTICE '%->%', name, split_part(split_part(body::TEXT, ' ', 7), ')', 1);
    END LOOP;
  END;
$$;

statement ok
CREATE SCHEMA s;

statement ok
CREATE TABLE t (a INT, b INT);

statement ok
CREATE TABLE s.t (a INT, b INT);

statement ok
CREATE FUNCTION g() RETURNS TRIGGER LANGUAGE PLpgSQL AS $$
  BEGIN
    RAISE NOTICE '%', (SELECT max(a) FROM t);
    RETURN NULL;
  END
$$;

statement ok
CREATE TRIGGER foo AFTER INSERT ON xy FOR EACH ROW EXECUTE FUNCTION g();

# The trigger function body stored with the trigger should reference the table
# on the public schema.
query T noticetrace
CALL show_triggers();
----
NOTICE: "foo"->test.public.t

statement ok
SET search_path = s,public;

statement ok
CREATE TRIGGER bar AFTER INSERT ON xy FOR EACH ROW EXECUTE FUNCTION g();

# The first trigger should still reference the table on the public schema, but
# the second should reference the table on schema "s".
query T noticetrace
CALL show_triggers();
----
NOTICE: "foo"->test.public.t
NOTICE: "bar"->test.s.t

# The trigger function is still unqualified.
query TT
SHOW CREATE FUNCTION g;
----
g  CREATE FUNCTION public.g()
     RETURNS TRIGGER
     VOLATILE
     NOT LEAKPROOF
     CALLED ON NULL INPUT
     LANGUAGE plpgsql
     SECURITY INVOKER
     AS $$
     BEGIN
     RAISE NOTICE '%', (SELECT max(a) FROM t);
     RETURN NULL;
     END;
   $$

statement ok
RESET search_path;

statement ok
DROP TRIGGER foo ON xy;

statement ok
DROP TRIGGER bar ON xy;

statement ok
DROP SCHEMA s CASCADE;
DROP TABLE t;
DROP FUNCTION g;

# ==============================================================================
# Test row-level BEFORE triggers.
# ==============================================================================

# Use the row engine to prevent batching from interfering with execution order
# between triggers on different rows.
statement ok
SET vectorize=off;

subtest before_row_basic

statement ok
CREATE FUNCTION g() RETURNS TRIGGER LANGUAGE PLpgSQL AS $$
  BEGIN
    RAISE NOTICE '%: old: %, new: %', TG_OP, OLD, NEW;
    RETURN COALESCE(NEW, OLD);
  END
$$;

statement count 0
DELETE FROM xy WHERE True;

# Test a basic INSERT trigger.
statement ok
CREATE TRIGGER foo BEFORE INSERT ON xy FOR EACH ROW EXECUTE FUNCTION g();

query T noticetrace
INSERT INTO xy VALUES (1, 2);
----
NOTICE: INSERT: old: <NULL>, new: (1,2)

statement ok
DROP TRIGGER foo ON xy;

# Test a basic UPDATE trigger.
statement ok
CREATE TRIGGER foo BEFORE UPDATE ON xy FOR EACH ROW EXECUTE FUNCTION g();

query T noticetrace
UPDATE xy SET x = 3 WHERE x = 1;
----
NOTICE: UPDATE: old: (1,2), new: (3,2)

statement ok
DROP TRIGGER foo ON xy;

# Test a basic DELETE trigger.
statement ok
CREATE TRIGGER foo BEFORE DELETE ON xy FOR EACH ROW EXECUTE FUNCTION g();

query T noticetrace
DELETE FROM xy WHERE x = 3;
----
NOTICE: DELETE: old: (3,2), new: <NULL>

query II rowsort
SELECT * FROM xy;
----

statement ok
DROP TRIGGER foo ON xy;

# Triggers can be defined to operate on multiple events.
statement ok
CREATE TRIGGER foo BEFORE INSERT OR UPDATE OR DELETE ON xy FOR EACH ROW EXECUTE FUNCTION g();

query T noticetrace
INSERT INTO xy VALUES (1, 2);
----
NOTICE: INSERT: old: <NULL>, new: (1,2)

query T noticetrace
UPDATE xy SET x = 3 WHERE x = 1;
----
NOTICE: UPDATE: old: (1,2), new: (3,2)

query T noticetrace
DELETE FROM xy WHERE x = 3;
----
NOTICE: DELETE: old: (3,2), new: <NULL>

query II rowsort
SELECT * FROM xy;
----

# UPSERT operations can fire both INSERT and UPDATE triggers.
#
# First, insert some rows without conflicts.
query T noticetrace
INSERT INTO xy VALUES (1, 2), (3, 4) ON CONFLICT (x) DO UPDATE SET y = xy.y + 10;
----
NOTICE: INSERT: old: <NULL>, new: (1,2)
NOTICE: INSERT: old: <NULL>, new: (3,4)

query II rowsort
SELECT * FROM xy;
----
1  2
3  4

# Repeat, but with some conflicting rows.
query T noticetrace
INSERT INTO xy VALUES (1, 2), (3, 4), (5, 6) ON CONFLICT (x) DO UPDATE SET y = xy.y + 10;
----
NOTICE: INSERT: old: <NULL>, new: (1,2)
NOTICE: UPDATE: old: (1,2), new: (1,12)
NOTICE: INSERT: old: <NULL>, new: (3,4)
NOTICE: UPDATE: old: (3,4), new: (3,14)
NOTICE: INSERT: old: <NULL>, new: (5,6)

query II rowsort
SELECT * FROM xy;
----
1  12
3  14
5  6

# Example with the explicit UPSERT syntax.
query T noticetrace
UPSERT INTO xy VALUES (1, -2), (3, -4), (5, -6), (7, -8);
----
NOTICE: INSERT: old: <NULL>, new: (1,-2)
NOTICE: UPDATE: old: (1,12), new: (1,-2)
NOTICE: INSERT: old: <NULL>, new: (3,-4)
NOTICE: UPDATE: old: (3,14), new: (3,-4)
NOTICE: INSERT: old: <NULL>, new: (5,-6)
NOTICE: UPDATE: old: (5,6), new: (5,-6)
NOTICE: INSERT: old: <NULL>, new: (7,-8)

query II rowsort
SELECT * FROM xy;
----
1  -2
3  -4
5  -6
7  -8

statement count 4
DELETE FROM xy WHERE True;

statement ok
DROP TRIGGER foo ON xy;

statement ok
DROP FUNCTION g;

# ==============================================================================
# Test row-level BEFORE triggers that modify the row.
# ==============================================================================

subtest before_row_modify

statement ok
CREATE FUNCTION g() RETURNS TRIGGER LANGUAGE PLpgSQL AS $$
  DECLARE new_new xy;
  BEGIN
    new_new = ROW((NEW).x, (NEW).y + 10);
    RAISE NOTICE '%: old: %, new: %, new_new: %', TG_OP, OLD, NEW, new_new;
    RETURN new_new;
  END
$$;

# Test an INSERT trigger that modifies the row.
statement ok
CREATE TRIGGER foo BEFORE INSERT ON xy FOR EACH ROW EXECUTE FUNCTION g();

query T noticetrace
INSERT INTO xy VALUES (1, 2), (3, 4);
----
NOTICE: INSERT: old: <NULL>, new: (1,2), new_new: (1,12)
NOTICE: INSERT: old: <NULL>, new: (3,4), new_new: (3,14)

# The inserted "y" values should reflect the increment in the trigger function.
query II rowsort
SELECT * FROM xy;
----
1  12
3  14

# Test an UPDATE trigger that modifies the row.
statement ok
CREATE TRIGGER foo2 BEFORE UPDATE ON xy FOR EACH ROW EXECUTE FUNCTION g();

query T noticetrace
UPDATE xy SET x = 5 WHERE x = 1;
----
NOTICE: UPDATE: old: (1,12), new: (5,12), new_new: (5,22)

# The updated row should have incremented "y" once again.
query II rowsort
SELECT * FROM xy;
----
3  14
5  22

# The trigger function updates the row after the update is applied.
query T noticetrace
UPDATE xy SET y = xy.y * 10 WHERE x = 5;
----
NOTICE: UPDATE: old: (5,22), new: (5,220), new_new: (5,230)

query II rowsort
SELECT * FROM xy;
----
3  14
5  230

statement count 2
DELETE FROM xy WHERE True;
INSERT INTO xy VALUES (1, 2), (3, 4);

query II rowsort
SELECT * FROM xy;
----
1  12
3  14

# When both INSERT and UPDATE triggers fire, modifications from both are applied
# to the row. First the INSERT trigger's modification will be applied, then the
# update specified in the ON CONFLICT clause, and finally the UPDATE trigger's
# modification.
query T noticetrace
INSERT INTO xy VALUES (1, 2), (3, 4), (5, 6) ON CONFLICT (x) DO UPDATE SET y = xy.y * 10;
----
NOTICE: INSERT: old: <NULL>, new: (1,2), new_new: (1,12)
NOTICE: UPDATE: old: (1,12), new: (1,120), new_new: (1,130)
NOTICE: INSERT: old: <NULL>, new: (3,4), new_new: (3,14)
NOTICE: UPDATE: old: (3,14), new: (3,140), new_new: (3,150)
NOTICE: INSERT: old: <NULL>, new: (5,6), new_new: (5,16)

query II rowsort
SELECT * FROM xy;
----
1  130
3  150
5  16

# No update is applied for ON CONFLICT DO NOTHING.
query T noticetrace
INSERT INTO xy VALUES (1, 2), (3, 4), (5, 6) ON CONFLICT (x) DO NOTHING;
----
NOTICE: INSERT: old: <NULL>, new: (1,2), new_new: (1,12)
NOTICE: INSERT: old: <NULL>, new: (3,4), new_new: (3,14)
NOTICE: INSERT: old: <NULL>, new: (5,6), new_new: (5,16)

query II rowsort
SELECT * FROM xy;
----
1  130
3  150
5  16

statement count 1
DELETE FROM xy WHERE x = 5;

# UPSERT with ON CONFLICT syntax. Note that the effect of the INSERT trigger
# propagates to the special "excluded" data source.
query T noticetrace
INSERT INTO xy VALUES (1, 2), (3, 4), (5, 6) ON CONFLICT (x) DO UPDATE SET y = excluded.y;
----
NOTICE: INSERT: old: <NULL>, new: (1,2), new_new: (1,12)
NOTICE: UPDATE: old: (1,130), new: (1,12), new_new: (1,22)
NOTICE: INSERT: old: <NULL>, new: (3,4), new_new: (3,14)
NOTICE: UPDATE: old: (3,150), new: (3,14), new_new: (3,24)
NOTICE: INSERT: old: <NULL>, new: (5,6), new_new: (5,16)

query II rowsort
SELECT * FROM xy;
----
1  22
3  24
5  16

# Similar to the previous case, but modifying the EXCLUDED row in the DO UPDATE
# clause.
query T noticetrace
INSERT INTO xy VALUES (1, 2), (3, 4), (5, 6) ON CONFLICT (x) DO UPDATE SET y = excluded.y - 1;
----
NOTICE: INSERT: old: <NULL>, new: (1,2), new_new: (1,12)
NOTICE: UPDATE: old: (1,22), new: (1,11), new_new: (1,21)
NOTICE: INSERT: old: <NULL>, new: (3,4), new_new: (3,14)
NOTICE: UPDATE: old: (3,24), new: (3,13), new_new: (3,23)
NOTICE: INSERT: old: <NULL>, new: (5,6), new_new: (5,16)
NOTICE: UPDATE: old: (5,16), new: (5,15), new_new: (5,25)

query II rowsort
SELECT * FROM xy;
----
1  21
3  23
5  25

statement count 1
DELETE FROM xy WHERE x = 5;

# UPSERT with explicit syntax.
query T noticetrace
UPSERT INTO xy VALUES (1, 2), (3, 4), (5, 6);
----
NOTICE: INSERT: old: <NULL>, new: (1,2), new_new: (1,12)
NOTICE: UPDATE: old: (1,21), new: (1,12), new_new: (1,22)
NOTICE: INSERT: old: <NULL>, new: (3,4), new_new: (3,14)
NOTICE: UPDATE: old: (3,23), new: (3,14), new_new: (3,24)
NOTICE: INSERT: old: <NULL>, new: (5,6), new_new: (5,16)

query II rowsort
SELECT * FROM xy;
----
1  22
3  24
5  16

statement count 1
DELETE FROM xy WHERE x = 5;

# The old version of conflicting rows can be accessed via the relation's name.
query T noticetrace
INSERT INTO xy VALUES (1, 2), (3, 4), (5, 6) ON CONFLICT (x) DO UPDATE SET y = xy.y + 10;
----
NOTICE: INSERT: old: <NULL>, new: (1,2), new_new: (1,12)
NOTICE: UPDATE: old: (1,22), new: (1,32), new_new: (1,42)
NOTICE: INSERT: old: <NULL>, new: (3,4), new_new: (3,14)
NOTICE: UPDATE: old: (3,24), new: (3,34), new_new: (3,44)
NOTICE: INSERT: old: <NULL>, new: (5,6), new_new: (5,16)

query II rowsort
SELECT * FROM xy;
----
1  42
3  44
5  16

# When there is a WHERE clause for the DO UPDATE part of the UPSERT, the UPDATE
# trigger fires only for the rows that are actually updated. The INSERT trigger
# fires for every row.
#
# Rows that are filtered by this clause are ignored, like for DO NOTHING.
query T noticetrace
INSERT INTO xy VALUES (1, 2), (3, 4), (5, 6) ON CONFLICT (x) DO UPDATE SET y = xy.y + 100 WHERE xy.x <> 3;
----
NOTICE: INSERT: old: <NULL>, new: (1,2), new_new: (1,12)
NOTICE: UPDATE: old: (1,42), new: (1,142), new_new: (1,152)
NOTICE: INSERT: old: <NULL>, new: (3,4), new_new: (3,14)
NOTICE: INSERT: old: <NULL>, new: (5,6), new_new: (5,16)
NOTICE: UPDATE: old: (5,16), new: (5,116), new_new: (5,126)

query II rowsort
SELECT * FROM xy;
----
1  152
3  44
5  126

statement ok
DROP TRIGGER foo ON xy;

statement ok
DROP TRIGGER foo2 ON xy;

statement ok
DROP FUNCTION g;

# DELETE triggers cannot modify the row. The custom is to return OLD, although
# any non-NULL value will have the same effect.
statement ok
CREATE FUNCTION g() RETURNS TRIGGER LANGUAGE PLpgSQL AS $$
  DECLARE ret xy;
  BEGIN
    ret := ROW((OLD).x + 10, (OLD).y + 10);
    RAISE NOTICE '%: old: %, new: %, ret: %', TG_OP, OLD, NEW, ret;
    RETURN ret;
  END
$$;

statement ok
CREATE TRIGGER foo BEFORE DELETE ON xy FOR EACH ROW EXECUTE FUNCTION g();

query T noticetrace
DELETE FROM xy WHERE x = 3;
----
NOTICE: DELETE: old: (3,44), new: <NULL>, ret: (13,54)

# Only the row with x = 3 should be deleted.
query II rowsort
SELECT * FROM xy;
----
1  152
5  126

statement ok
DROP TRIGGER foo ON xy;

statement ok
DROP FUNCTION g;

statement count 2
DELETE FROM xy WHERE True;

# ==============================================================================
# Test row-level BEFORE triggers that filter the row.
# ==============================================================================

subtest before_row_filter

statement ok
CREATE FUNCTION g() RETURNS TRIGGER LANGUAGE PLpgSQL AS $$
  DECLARE val xy := COALESCE(NEW, OLD);
  BEGIN
    RAISE NOTICE '%: old: %, new: %', TG_OP, OLD, NEW;
    IF (val).x % 2 = 0 THEN
      RETURN val;
    ELSE
      RETURN NULL;
    END IF;
  END
$$;

statement ok
CREATE TRIGGER foo BEFORE INSERT ON xy FOR EACH ROW EXECUTE FUNCTION g();

query T noticetrace
INSERT INTO xy VALUES (1, 1), (2, 2), (3, 3), (4, 4);
----
NOTICE: INSERT: old: <NULL>, new: (1,1)
NOTICE: INSERT: old: <NULL>, new: (2,2)
NOTICE: INSERT: old: <NULL>, new: (3,3)
NOTICE: INSERT: old: <NULL>, new: (4,4)

query II rowsort
SELECT * FROM xy;
----
2  2
4  4

statement ok
DROP TRIGGER foo ON xy;

# Fill in the missing values.
statement ok
INSERT INTO xy VALUES (1, 1), (3, 3);

statement ok
CREATE TRIGGER foo BEFORE UPDATE OR DELETE ON xy FOR EACH ROW EXECUTE FUNCTION g();

query T noticetrace
UPDATE xy SET y = y + 10;
----
NOTICE: UPDATE: old: (1,1), new: (1,11)
NOTICE: UPDATE: old: (2,2), new: (2,12)
NOTICE: UPDATE: old: (3,3), new: (3,13)
NOTICE: UPDATE: old: (4,4), new: (4,14)

query II rowsort
SELECT * FROM xy;
----
1  1
2  12
3  3
4  14

query T noticetrace
DELETE FROM xy WHERE True;
----
NOTICE: DELETE: old: (1,1), new: <NULL>
NOTICE: DELETE: old: (2,12), new: <NULL>
NOTICE: DELETE: old: (3,3), new: <NULL>
NOTICE: DELETE: old: (4,14), new: <NULL>

query II rowsort
SELECT * FROM xy;
----
1  1
3  3

statement ok
DROP TRIGGER foo ON xy;

statement ok
DROP FUNCTION g;

# Include hidden columns that won't be visible to triggers.
statement ok
CREATE TABLE nullable (a INT, foo INT NOT VISIBLE, b INT, bar INT NOT VISIBLE DEFAULT 1);

# A tuple with only NULL elements does not cause the filter to remove rows.
statement ok
CREATE FUNCTION g() RETURNS TRIGGER LANGUAGE PLpgSQL AS $$
  BEGIN
    RAISE NOTICE '%: old: %, new: %', TG_OP, OLD, NEW;
    RETURN ROW(NULL, NULL);
  END
$$;

statement ok
CREATE TRIGGER foo BEFORE INSERT OR UPDATE OR DELETE ON nullable FOR EACH ROW EXECUTE FUNCTION g();

query T noticetrace
INSERT INTO nullable VALUES (1, 1), (2, 2), (3, 3);
----
NOTICE: INSERT: old: <NULL>, new: (1,1)
NOTICE: INSERT: old: <NULL>, new: (2,2)
NOTICE: INSERT: old: <NULL>, new: (3,3)

# NOTE: the trigger does not modify the default value of "bar".
query III rowsort
SELECT *, bar FROM nullable;
----
NULL  NULL  1
NULL  NULL  1
NULL  NULL  1

query T noticetrace
UPDATE nullable SET b = 10;
----
NOTICE: UPDATE: old: (,), new: (,10)
NOTICE: UPDATE: old: (,), new: (,10)
NOTICE: UPDATE: old: (,), new: (,10)

query III rowsort
SELECT *, bar FROM nullable;
----
NULL  NULL  1
NULL  NULL  1
NULL  NULL  1

query T noticetrace
DELETE FROM nullable WHERE a IS NULL LIMIT 2;
----
NOTICE: DELETE: old: (,), new: <NULL>
NOTICE: DELETE: old: (,), new: <NULL>

query III rowsort
SELECT *, bar FROM nullable;
----
NULL  NULL  1

statement ok
DROP TABLE nullable;

statement ok
DROP FUNCTION g;

statement count 2
DELETE FROM xy WHERE True;

# ==============================================================================
# Test row-level BEFORE triggers with a WHERE clause.
# ==============================================================================

subtest before_row_where

statement ok
CREATE FUNCTION g() RETURNS TRIGGER LANGUAGE PLpgSQL AS $$
  BEGIN
    RAISE NOTICE '%: old: %, new: %', TG_OP, OLD, NEW;
    RETURN COALESCE(NEW, OLD);
  END
$$;

statement ok
CREATE TRIGGER foo BEFORE INSERT ON xy FOR EACH ROW WHEN ((NEW).x % 2 = 0) EXECUTE FUNCTION g();

# The trigger should not fire for the odd values, but they should still be
# inserted.
query T noticetrace
INSERT INTO xy VALUES (1, 1), (2, 2), (3, 3), (4, 4);
----
NOTICE: INSERT: old: <NULL>, new: (2,2)
NOTICE: INSERT: old: <NULL>, new: (4,4)

query II rowsort
SELECT * FROM xy;
----
1  1
2  2
3  3
4  4

statement ok
CREATE TRIGGER foo2 BEFORE UPDATE OR DELETE ON xy FOR EACH ROW WHEN ((OLD).x % 2 = 0) EXECUTE FUNCTION g();

# The trigger should not fire for the odd values, but they should still be
# updated.
query T noticetrace
UPDATE xy SET y = y + 10;
----
NOTICE: UPDATE: old: (2,2), new: (2,12)
NOTICE: UPDATE: old: (4,4), new: (4,14)

query II rowsort
SELECT * FROM xy;
----
1  11
2  12
3  13
4  14

# The trigger should not fire for the odd values, but they should still be
# deleted.
query T noticetrace
DELETE FROM xy WHERE True;
----
NOTICE: DELETE: old: (2,12), new: <NULL>
NOTICE: DELETE: old: (4,14), new: <NULL>

query II rowsort
SELECT * FROM xy;
----

statement ok
DROP TRIGGER foo ON xy;

statement ok
DROP TRIGGER foo2 ON xy;

statement ok
DROP FUNCTION g;

statement count 0
DELETE FROM xy WHERE True;

# ==============================================================================
# Test row-level AFTER triggers.
# ==============================================================================

subtest after_row

statement ok
CREATE FUNCTION g() RETURNS TRIGGER LANGUAGE PLpgSQL AS $$
  BEGIN
    RAISE NOTICE '%: old: %, new: %', TG_OP, OLD, NEW;
    RETURN COALESCE(NEW, OLD);
  END
$$;

# Test a basic INSERT trigger.
statement ok
CREATE TRIGGER foo AFTER INSERT ON xy FOR EACH ROW EXECUTE FUNCTION g();

query T noticetrace
INSERT INTO xy VALUES (1, 2);
----
NOTICE: INSERT: old: <NULL>, new: (1,2)

statement ok
DROP TRIGGER foo ON xy;

# Test a basic UPDATE trigger.
statement ok
CREATE TRIGGER foo AFTER UPDATE ON xy FOR EACH ROW EXECUTE FUNCTION g();

query T noticetrace
UPDATE xy SET x = 3 WHERE x = 1;
----
NOTICE: UPDATE: old: (1,2), new: (3,2)

statement ok
DROP TRIGGER foo ON xy;

# Test a basic DELETE trigger.
statement ok
CREATE TRIGGER foo AFTER DELETE ON xy FOR EACH ROW EXECUTE FUNCTION g();

query T noticetrace
DELETE FROM xy WHERE x = 3;
----
NOTICE: DELETE: old: (3,2), new: <NULL>

statement ok
DROP TRIGGER foo ON xy;

# Triggers can be defined to operate on multiple events.
statement ok
CREATE TRIGGER foo AFTER INSERT OR UPDATE OR DELETE ON xy FOR EACH ROW EXECUTE FUNCTION g();

query T noticetrace
INSERT INTO xy VALUES (1, 2);
----
NOTICE: INSERT: old: <NULL>, new: (1,2)

query T noticetrace
UPDATE xy SET x = 3 WHERE x = 1;
----
NOTICE: UPDATE: old: (1,2), new: (3,2)

query T noticetrace
DELETE FROM xy WHERE x = 3;
----
NOTICE: DELETE: old: (3,2), new: <NULL>

query II rowsort
SELECT * FROM xy;
----

# UPSERT operations can fire both INSERT and UPDATE triggers.
#
# First, insert some rows without conflicts.
query T noticetrace
INSERT INTO xy VALUES (1, 2), (3, 4) ON CONFLICT (x) DO UPDATE SET y = xy.y + 10;
----
NOTICE: INSERT: old: <NULL>, new: (1,2)
NOTICE: INSERT: old: <NULL>, new: (3,4)

query II rowsort
SELECT * FROM xy;
----
1  2
3  4

# Repeat, but with some conflicting rows.
query T noticetrace
INSERT INTO xy VALUES (1, 2), (3, 4), (5, 6) ON CONFLICT (x) DO UPDATE SET y = xy.y + 10;
----
NOTICE: UPDATE: old: (1,2), new: (1,12)
NOTICE: UPDATE: old: (3,4), new: (3,14)
NOTICE: INSERT: old: <NULL>, new: (5,6)

query II rowsort
SELECT * FROM xy;
----
1  12
3  14
5  6

# Example with the explicit UPSERT syntax.
query T noticetrace
UPSERT INTO xy VALUES (1, -2), (3, -4), (5, -6), (7, -8);
----
NOTICE: UPDATE: old: (1,12), new: (1,-2)
NOTICE: UPDATE: old: (3,14), new: (3,-4)
NOTICE: UPDATE: old: (5,6), new: (5,-6)
NOTICE: INSERT: old: <NULL>, new: (7,-8)

query II rowsort
SELECT * FROM xy;
----
1  -2
3  -4
5  -6
7  -8

statement ok
DROP TRIGGER foo ON xy;

statement ok
DROP FUNCTION g;

statement count 4
DELETE FROM xy WHERE True;

# The return value of an AFTER trigger is ignored.
statement ok
CREATE FUNCTION g() RETURNS TRIGGER LANGUAGE PLpgSQL AS $$
  BEGIN
    RAISE NOTICE '%: old: %, new: %', TG_OP, OLD, NEW;
    RETURN ROW(1000, -10000);
  END
$$;

statement ok
CREATE TRIGGER foo AFTER INSERT ON xy FOR EACH ROW EXECUTE FUNCTION g();

query T noticetrace
INSERT INTO xy VALUES (1, 2);
----
NOTICE: INSERT: old: <NULL>, new: (1,2)

query II rowsort
SELECT * FROM xy;
----
1  2

statement ok
DROP TRIGGER foo ON xy;

statement ok
DROP FUNCTION g;

statement count 1
DELETE FROM xy WHERE True;

# ==============================================================================
# Test row-level AFTER triggers with a WHEN clause.
# ==============================================================================

subtest after_row_where

statement ok
CREATE FUNCTION g() RETURNS TRIGGER LANGUAGE PLpgSQL AS $$
  BEGIN
    RAISE NOTICE '%: old: %, new: %', TG_OP, OLD, NEW;
    RETURN NULL;
  END
$$;

statement ok
CREATE TRIGGER foo AFTER INSERT ON xy FOR EACH ROW WHEN ((NEW).x % 2 = 0) EXECUTE FUNCTION g();

# The trigger should not fire for the odd values.
query T noticetrace
INSERT INTO xy VALUES (1, 1), (2, 2), (3, 3), (4, 4);
----
NOTICE: INSERT: old: <NULL>, new: (2,2)
NOTICE: INSERT: old: <NULL>, new: (4,4)

query II rowsort
SELECT * FROM xy;
----
1  1
2  2
3  3
4  4

statement ok
CREATE TRIGGER foo2 AFTER UPDATE OR DELETE ON xy FOR EACH ROW WHEN ((OLD).x % 2 = 0) EXECUTE FUNCTION g();

# The trigger should not fire for the odd values.
query T noticetrace
UPDATE xy SET y = y + 10;
----
NOTICE: UPDATE: old: (2,2), new: (2,12)
NOTICE: UPDATE: old: (4,4), new: (4,14)

query II rowsort
SELECT * FROM xy;
----
1  11
2  12
3  13
4  14

# The trigger should not fire for the odd values.
query T noticetrace
DELETE FROM xy WHERE True;
----
NOTICE: DELETE: old: (2,12), new: <NULL>
NOTICE: DELETE: old: (4,14), new: <NULL>

query II rowsort
SELECT * FROM xy;
----

statement ok
DROP TRIGGER foo ON xy;

statement ok
DROP TRIGGER foo2 ON xy;

statement ok
DROP FUNCTION g;

statement count 0
DELETE FROM xy WHERE True;

# ==============================================================================
# Test interaction between row-level BEFORE and AFTER triggers.
# ==============================================================================

subtest before_after_row

statement ok
CREATE FUNCTION g() RETURNS TRIGGER LANGUAGE PLpgSQL AS $$
  BEGIN
    RAISE NOTICE '% %: % -> %', TG_WHEN, TG_OP, OLD, NEW;
    IF NEW IS NOT NULL AND TG_WHEN = 'BEFORE' THEN
      NEW.x := (NEW).x * 10;
      RAISE NOTICE 'changing the row to %', NEW;
    END IF;
    RETURN COALESCE(NEW, OLD);
  END
$$;

statement ok
CREATE TRIGGER foo BEFORE INSERT ON xy FOR EACH ROW EXECUTE FUNCTION g();

statement ok
CREATE TRIGGER bar AFTER INSERT ON xy FOR EACH ROW EXECUTE FUNCTION g();

# The AFTER trigger should observe the effect of the BEFORE trigger.
query T noticetrace
INSERT INTO xy VALUES (1, 2), (3, 4);
----
NOTICE: BEFORE INSERT: <NULL> -> (1,2)
NOTICE: changing the row to (10,2)
NOTICE: BEFORE INSERT: <NULL> -> (3,4)
NOTICE: changing the row to (30,4)
NOTICE: AFTER INSERT: <NULL> -> (10,2)
NOTICE: AFTER INSERT: <NULL> -> (30,4)

query II rowsort
SELECT * FROM xy;
----
10  2
30  4

statement ok
DROP TRIGGER foo ON xy;

statement ok
DROP TRIGGER bar ON xy;

statement ok
DROP FUNCTION g;

statement count 2
DELETE FROM xy WHERE True;

# ==============================================================================
# Test cyclical triggers.
# ==============================================================================

statement ok
CREATE TABLE t1 (a INT, b INT);
CREATE TABLE t2 (a INT, b INT);

# Test cyclical AFTER triggers.
subtest cyclical_after_triggers

statement ok
SET recursion_depth_limit = 10;

statement ok
CREATE FUNCTION insert_t1() RETURNS TRIGGER LANGUAGE PLpgSQL AS $$
  BEGIN
    RAISE NOTICE ' ';
    RAISE NOTICE '% trigger % with NEW: %', TG_WHEN, TG_NAME, NEW;
    RAISE NOTICE 'max t1.a: %, max t2.a: %', (SELECT max(a) FROM t1), (SELECT max(a) FROM t2);
    RAISE NOTICE 'inserting into t1: %', ROW((NEW).a + 1, (NEW).b);
    INSERT INTO t1 VALUES ((NEW).a + 1, (NEW).b);
    RETURN NEW;
  END
$$;
CREATE FUNCTION insert_t2() RETURNS TRIGGER LANGUAGE PLpgSQL AS $$
  BEGIN
    RAISE NOTICE ' ';
    RAISE NOTICE '% trigger % with NEW: %', TG_WHEN, TG_NAME, NEW;
    RAISE NOTICE 'max t1.a: %, max t2.a: %', (SELECT max(a) FROM t1), (SELECT max(a) FROM t2);
    RAISE NOTICE 'inserting into t2: %', ROW((NEW).a + 1, (NEW).b);
    INSERT INTO t2 VALUES ((NEW).a + 1, (NEW).b);
    RETURN NEW;
  END
$$;

statement ok
CREATE TRIGGER foo AFTER INSERT ON t1 FOR EACH ROW EXECUTE FUNCTION insert_t2();

statement ok
CREATE TRIGGER bar AFTER INSERT ON t2 FOR EACH ROW EXECUTE FUNCTION insert_t1();

# The triggers should fire until the limit is reached.
statement error pgcode 09000 pq: trigger reached recursion depth limit: 10
INSERT INTO t1 VALUES (1, 1);

statement ok
DROP TRIGGER foo ON t1;

# Add a WHEN clause to end the cycle after a few iterations.
statement ok
CREATE TRIGGER foo AFTER INSERT ON t1 FOR EACH ROW WHEN ((NEW).a < 5) EXECUTE FUNCTION insert_t2();

query T noticetrace
INSERT INTO t1 VALUES (1, 1);
----
NOTICE:
NOTICE: AFTER trigger foo with NEW: (1,1)
NOTICE: max t1.a: 1, max t2.a: <NULL>
NOTICE: inserting into t2: (2,1)
NOTICE:
NOTICE: AFTER trigger bar with NEW: (2,1)
NOTICE: max t1.a: 1, max t2.a: 2
NOTICE: inserting into t1: (3,1)
NOTICE:
NOTICE: AFTER trigger foo with NEW: (3,1)
NOTICE: max t1.a: 3, max t2.a: 2
NOTICE: inserting into t2: (4,1)
NOTICE:
NOTICE: AFTER trigger bar with NEW: (4,1)
NOTICE: max t1.a: 3, max t2.a: 4
NOTICE: inserting into t1: (5,1)

query II rowsort
SELECT * FROM t1;
----
1  1
3  1
5  1

query II rowsort
SELECT * FROM t2;
----
2  1
4  1

statement count 3
DELETE FROM t1 WHERE True;

statement count 2
DELETE FROM t2 WHERE True;

statement ok
DROP TRIGGER foo ON t1;

statement ok
DROP TRIGGER bar ON t2;

# Test cyclical BEFORE triggers.
subtest cyclical_before_triggers

statement ok
CREATE TRIGGER foo BEFORE INSERT ON t1 FOR EACH ROW EXECUTE FUNCTION insert_t2();

statement ok
CREATE TRIGGER bar BEFORE INSERT ON t2 FOR EACH ROW EXECUTE FUNCTION insert_t1();

# The triggers should fire until the limit is reached.
statement error pgcode 09000 pq: trigger reached recursion depth limit: 10
INSERT INTO t1 VALUES (1, 1);

statement ok
DROP TRIGGER foo ON t1;

# Add a WHEN clause to end the cycle after a few iterations.
statement ok
CREATE TRIGGER foo BEFORE INSERT ON t1 FOR EACH ROW WHEN ((NEW).a < 5) EXECUTE FUNCTION insert_t2();

query T noticetrace
INSERT INTO t1 VALUES (1, 1);
----
NOTICE:
NOTICE: BEFORE trigger foo with NEW: (1,1)
NOTICE: max t1.a: <NULL>, max t2.a: <NULL>
NOTICE: inserting into t2: (2,1)
NOTICE:
NOTICE: BEFORE trigger bar with NEW: (2,1)
NOTICE: max t1.a: <NULL>, max t2.a: <NULL>
NOTICE: inserting into t1: (3,1)
NOTICE:
NOTICE: BEFORE trigger foo with NEW: (3,1)
NOTICE: max t1.a: <NULL>, max t2.a: <NULL>
NOTICE: inserting into t2: (4,1)
NOTICE:
NOTICE: BEFORE trigger bar with NEW: (4,1)
NOTICE: max t1.a: <NULL>, max t2.a: <NULL>
NOTICE: inserting into t1: (5,1)

query II rowsort
SELECT * FROM t1;
----
1  1
3  1
5  1

query II rowsort
SELECT * FROM t2;
----
2  1
4  1

statement count 3
DELETE FROM t1 WHERE True;

statement count 2
DELETE FROM t2 WHERE True;

# Test mutually cyclical BEFORE and AFTER triggers.
subtest cyclical_before_after_triggers

statement ok
DROP TRIGGER foo ON t1;

statement ok
CREATE TRIGGER foo AFTER INSERT ON t1 FOR EACH ROW EXECUTE FUNCTION insert_t2();

# The triggers should fire until the limit is reached.
statement error pgcode 09000 pq: trigger reached recursion depth limit: 10
INSERT INTO t1 VALUES (1, 1);

statement ok
DROP TRIGGER foo ON t1;

# Add a WHEN clause to end the cycle after a few iterations.
statement ok
CREATE TRIGGER foo AFTER INSERT ON t1 FOR EACH ROW WHEN ((NEW).a < 5) EXECUTE FUNCTION insert_t2();

query T noticetrace
INSERT INTO t1 VALUES (1, 1);
----
NOTICE:
NOTICE: AFTER trigger foo with NEW: (1,1)
NOTICE: max t1.a: 1, max t2.a: <NULL>
NOTICE: inserting into t2: (2,1)
NOTICE:
NOTICE: BEFORE trigger bar with NEW: (2,1)
NOTICE: max t1.a: 1, max t2.a: <NULL>
NOTICE: inserting into t1: (3,1)
NOTICE:
NOTICE: AFTER trigger foo with NEW: (3,1)
NOTICE: max t1.a: 3, max t2.a: <NULL>
NOTICE: inserting into t2: (4,1)
NOTICE:
NOTICE: BEFORE trigger bar with NEW: (4,1)
NOTICE: max t1.a: 3, max t2.a: <NULL>
NOTICE: inserting into t1: (5,1)

query II rowsort
SELECT * FROM t1;
----
1  1
3  1
5  1

query II rowsort
SELECT * FROM t2;
----
2  1
4  1

statement count 3
DELETE FROM t1 WHERE True;

statement count 2
DELETE FROM t2 WHERE True;

statement ok
DROP TRIGGER foo ON t1;

statement ok
DROP TRIGGER bar ON t2;

# Test a single cyclical trigger.
subtest cyclical_trigger_singleton

statement ok
CREATE TRIGGER foo AFTER INSERT ON t1 FOR EACH ROW EXECUTE FUNCTION insert_t1();

# The trigger should fire until the limit is reached.
statement error pgcode 09000 pq: trigger reached recursion depth limit: 10
INSERT INTO t1 VALUES (1, 1);

statement ok
DROP TRIGGER foo ON t1;

# Add a WHEN clause to end the cycle after a few iterations.
statement ok
CREATE TRIGGER foo AFTER INSERT ON t1 FOR EACH ROW WHEN ((NEW).a < 5) EXECUTE FUNCTION insert_t1();

query T noticetrace
INSERT INTO t1 VALUES (1, 1);
----
NOTICE:
NOTICE: AFTER trigger foo with NEW: (1,1)
NOTICE: max t1.a: 1, max t2.a: <NULL>
NOTICE: inserting into t1: (2,1)
NOTICE:
NOTICE: AFTER trigger foo with NEW: (2,1)
NOTICE: max t1.a: 2, max t2.a: <NULL>
NOTICE: inserting into t1: (3,1)
NOTICE:
NOTICE: AFTER trigger foo with NEW: (3,1)
NOTICE: max t1.a: 3, max t2.a: <NULL>
NOTICE: inserting into t1: (4,1)
NOTICE:
NOTICE: AFTER trigger foo with NEW: (4,1)
NOTICE: max t1.a: 4, max t2.a: <NULL>
NOTICE: inserting into t1: (5,1)

query II rowsort
SELECT * FROM t1;
----
1  1
2  1
3  1
4  1
5  1

statement count 5
DELETE FROM t1 WHERE True;

statement ok
DROP TRIGGER foo ON t1;

statement ok
CREATE TRIGGER bar BEFORE INSERT ON t1 FOR EACH ROW EXECUTE FUNCTION insert_t1();

# The trigger should fire until the limit is reached.
statement error pgcode 09000 pq: trigger reached recursion depth limit: 10
INSERT INTO t1 VALUES (1, 1);

statement ok
DROP TRIGGER bar ON t1;

# Add a WHEN clause to end the cycle after a few iterations.
statement ok
CREATE TRIGGER bar BEFORE INSERT ON t1 FOR EACH ROW WHEN ((NEW).a < 5) EXECUTE FUNCTION insert_t1();

query T noticetrace
INSERT INTO t1 VALUES (1, 1);
----
NOTICE:
NOTICE: BEFORE trigger bar with NEW: (1,1)
NOTICE: max t1.a: <NULL>, max t2.a: <NULL>
NOTICE: inserting into t1: (2,1)
NOTICE:
NOTICE: BEFORE trigger bar with NEW: (2,1)
NOTICE: max t1.a: <NULL>, max t2.a: <NULL>
NOTICE: inserting into t1: (3,1)
NOTICE:
NOTICE: BEFORE trigger bar with NEW: (3,1)
NOTICE: max t1.a: <NULL>, max t2.a: <NULL>
NOTICE: inserting into t1: (4,1)
NOTICE:
NOTICE: BEFORE trigger bar with NEW: (4,1)
NOTICE: max t1.a: <NULL>, max t2.a: <NULL>
NOTICE: inserting into t1: (5,1)

query II rowsort
SELECT * FROM t1;
----
1  1
2  1
3  1
4  1
5  1

statement count 5
DELETE FROM t1 WHERE True;

statement ok
DROP TRIGGER bar ON t1;

statement ok
DROP FUNCTION insert_t1;
DROP FUNCTION insert_t2;
DROP TABLE t1;
DROP TABLE t2;

statement ok
RESET recursion_depth_limit;

# ==============================================================================
# Test row-level trigger interaction with FK cascades and checks.
# ==============================================================================

subtest cascades_fire_triggers

statement ok
CREATE TABLE parent (k INT PRIMARY KEY);
CREATE TABLE child (k INT PRIMARY KEY, v INT REFERENCES parent(k) ON UPDATE CASCADE ON DELETE CASCADE);

statement ok
CREATE FUNCTION g() RETURNS TRIGGER LANGUAGE PLpgSQL AS $$
  BEGIN
    RAISE NOTICE '% % ON %: % -> %', TG_WHEN, TG_OP, TG_TABLE_NAME, OLD, NEW;
    RETURN COALESCE(NEW, OLD);
  END
$$;

statement ok
CREATE TRIGGER foo BEFORE INSERT OR UPDATE OR DELETE ON parent FOR EACH ROW EXECUTE FUNCTION g();

statement ok
CREATE TRIGGER bar AFTER INSERT OR UPDATE OR DELETE ON parent FOR EACH ROW EXECUTE FUNCTION g();

statement ok
CREATE TRIGGER foo BEFORE INSERT OR UPDATE OR DELETE ON child FOR EACH ROW EXECUTE FUNCTION g();

statement ok
CREATE TRIGGER bar AFTER INSERT OR UPDATE OR DELETE ON child FOR EACH ROW EXECUTE FUNCTION g();

statement ok
INSERT INTO parent VALUES (1), (2), (3);
INSERT INTO child VALUES (1, 1), (2, 2), (3, 2), (4, 3);

query T noticetrace
UPDATE parent SET k = k * 10 WHERE k = 2 OR k = 3;
----
NOTICE: BEFORE UPDATE ON parent: (2) -> (20)
NOTICE: BEFORE UPDATE ON parent: (3) -> (30)
NOTICE: BEFORE UPDATE ON child: (2,2) -> (2,20)
NOTICE: BEFORE UPDATE ON child: (3,2) -> (3,20)
NOTICE: BEFORE UPDATE ON child: (4,3) -> (4,30)
NOTICE: AFTER UPDATE ON parent: (2) -> (20)
NOTICE: AFTER UPDATE ON parent: (3) -> (30)
NOTICE: AFTER UPDATE ON child: (2,2) -> (2,20)
NOTICE: AFTER UPDATE ON child: (3,2) -> (3,20)
NOTICE: AFTER UPDATE ON child: (4,3) -> (4,30)

query T noticetrace
DELETE FROM parent WHERE k = 20 OR k = 30;
----
NOTICE: BEFORE DELETE ON parent: (20) -> <NULL>
NOTICE: BEFORE DELETE ON parent: (30) -> <NULL>
NOTICE: BEFORE DELETE ON child: (2,20) -> <NULL>
NOTICE: BEFORE DELETE ON child: (3,20) -> <NULL>
NOTICE: BEFORE DELETE ON child: (4,30) -> <NULL>
NOTICE: AFTER DELETE ON parent: (20) -> <NULL>
NOTICE: AFTER DELETE ON parent: (30) -> <NULL>
NOTICE: AFTER DELETE ON child: (2,20) -> <NULL>
NOTICE: AFTER DELETE ON child: (3,20) -> <NULL>
NOTICE: AFTER DELETE ON child: (4,30) -> <NULL>

statement count 1
DELETE FROM child WHERE True;

statement count 1
DELETE FROM parent WHERE True;

statement ok
INSERT INTO parent VALUES (1), (2), (3);
INSERT INTO child VALUES (1, 1), (2, 2), (3, 2), (4, 3);

subtest before_trigger_fires_cascades

# Create a trigger function that will map inserts into the "ab" table into
# updates and delete on the "parent" table.
statement ok
CREATE FUNCTION h() RETURNS TRIGGER LANGUAGE PLpgSQL AS $$
  DECLARE
    from_k INT := (NEW).a;
    to_k INT := (NEW).b;
  BEGIN
    IF to_k IS NULL THEN
      RAISE NOTICE 'delete from parent in trigger where k = %', from_k;
      DELETE FROM parent WHERE k = from_k;
    ELSE
      RAISE NOTICE 'update parent.k to % in trigger where k = %', to_k, from_k;
      UPDATE parent SET k = to_k WHERE k = from_k;
    END IF;
    RETURN COALESCE(NEW, OLD);
  END
$$;

statement ok
CREATE TRIGGER foo BEFORE INSERT ON ab FOR EACH ROW EXECUTE FUNCTION h();

query T noticetrace
INSERT INTO ab VALUES (2, 20), (3, 30);
----
NOTICE: update parent.k to 20 in trigger where k = 2
NOTICE: BEFORE UPDATE ON parent: (2) -> (20)
NOTICE: BEFORE UPDATE ON child: (2,2) -> (2,20)
NOTICE: BEFORE UPDATE ON child: (3,2) -> (3,20)
NOTICE: AFTER UPDATE ON parent: (2) -> (20)
NOTICE: AFTER UPDATE ON child: (2,2) -> (2,20)
NOTICE: AFTER UPDATE ON child: (3,2) -> (3,20)
NOTICE: update parent.k to 30 in trigger where k = 3
NOTICE: BEFORE UPDATE ON parent: (3) -> (30)
NOTICE: BEFORE UPDATE ON child: (4,3) -> (4,30)
NOTICE: AFTER UPDATE ON parent: (3) -> (30)
NOTICE: AFTER UPDATE ON child: (4,3) -> (4,30)

query T noticetrace
INSERT INTO ab VALUES (20, NULL), (30, NULL);
----
NOTICE: delete from parent in trigger where k = 20
NOTICE: BEFORE DELETE ON parent: (20) -> <NULL>
NOTICE: BEFORE DELETE ON child: (2,20) -> <NULL>
NOTICE: BEFORE DELETE ON child: (3,20) -> <NULL>
NOTICE: AFTER DELETE ON parent: (20) -> <NULL>
NOTICE: AFTER DELETE ON child: (2,20) -> <NULL>
NOTICE: AFTER DELETE ON child: (3,20) -> <NULL>
NOTICE: delete from parent in trigger where k = 30
NOTICE: BEFORE DELETE ON parent: (30) -> <NULL>
NOTICE: BEFORE DELETE ON child: (4,30) -> <NULL>
NOTICE: AFTER DELETE ON parent: (30) -> <NULL>
NOTICE: AFTER DELETE ON child: (4,30) -> <NULL>

statement ok
DROP TRIGGER foo ON ab;

statement count 1
DELETE FROM child WHERE True;

statement count 1
DELETE FROM parent WHERE True;

statement ok
INSERT INTO parent VALUES (1), (2), (3);
INSERT INTO child VALUES (1, 1), (2, 2), (3, 2), (4, 3);

subtest after_trigger_fires_cascades

statement ok
CREATE TRIGGER foo AFTER INSERT OR DELETE ON ab FOR EACH ROW EXECUTE FUNCTION h();

query T noticetrace
INSERT INTO ab VALUES (2, 20), (3, 30);
----
NOTICE: update parent.k to 20 in trigger where k = 2
NOTICE: BEFORE UPDATE ON parent: (2) -> (20)
NOTICE: BEFORE UPDATE ON child: (2,2) -> (2,20)
NOTICE: BEFORE UPDATE ON child: (3,2) -> (3,20)
NOTICE: AFTER UPDATE ON parent: (2) -> (20)
NOTICE: AFTER UPDATE ON child: (2,2) -> (2,20)
NOTICE: AFTER UPDATE ON child: (3,2) -> (3,20)
NOTICE: update parent.k to 30 in trigger where k = 3
NOTICE: BEFORE UPDATE ON parent: (3) -> (30)
NOTICE: BEFORE UPDATE ON child: (4,3) -> (4,30)
NOTICE: AFTER UPDATE ON parent: (3) -> (30)
NOTICE: AFTER UPDATE ON child: (4,3) -> (4,30)

query T noticetrace
INSERT INTO ab VALUES (20, NULL), (30, NULL);
----
NOTICE: delete from parent in trigger where k = 20
NOTICE: BEFORE DELETE ON parent: (20) -> <NULL>
NOTICE: BEFORE DELETE ON child: (2,20) -> <NULL>
NOTICE: BEFORE DELETE ON child: (3,20) -> <NULL>
NOTICE: AFTER DELETE ON parent: (20) -> <NULL>
NOTICE: AFTER DELETE ON child: (2,20) -> <NULL>
NOTICE: AFTER DELETE ON child: (3,20) -> <NULL>
NOTICE: delete from parent in trigger where k = 30
NOTICE: BEFORE DELETE ON parent: (30) -> <NULL>
NOTICE: BEFORE DELETE ON child: (4,30) -> <NULL>
NOTICE: AFTER DELETE ON parent: (30) -> <NULL>
NOTICE: AFTER DELETE ON child: (4,30) -> <NULL>

statement ok
DROP TRIGGER foo ON ab;

statement ok
DROP FUNCTION h;

statement count 8
DELETE FROM ab WHERE True;

statement count 1
DELETE FROM child WHERE True;

statement count 1
DELETE FROM parent WHERE True;

# FK checks happen before AFTER triggers that were fired by the main query.
subtest fk_checks_before_triggers

# Create a second child table with no cascade behavior.
statement ok
CREATE TABLE child2 (k INT PRIMARY KEY, v INT REFERENCES parent(k));

statement ok
CREATE TRIGGER foo BEFORE INSERT OR UPDATE OR DELETE ON child2 FOR EACH ROW EXECUTE FUNCTION g();

statement ok
CREATE TRIGGER bar AFTER INSERT OR UPDATE OR DELETE ON child2 FOR EACH ROW EXECUTE FUNCTION g();

statement ok
INSERT INTO parent VALUES (1), (2), (3);
INSERT INTO child VALUES (1, 1), (2, 2), (3, 2), (4, 3);
INSERT INTO child2 VALUES (1, 1), (2, 2), (3, 2), (4, 3);

# Create procedures to print when a FK violation is encountered.
statement ok
CREATE PROCEDURE wrap_parent_update(k_old INT, k_new INT) LANGUAGE PLpgSQL AS $$
  BEGIN
    IF k_new IS NULL THEN
      DELETE FROM parent WHERE k = k_old;
    ELSE
      UPDATE parent SET k = k_new WHERE k = k_old;
    END IF;
  EXCEPTION WHEN foreign_key_violation THEN
    RAISE NOTICE 'FK violation updating parent from % to %', k_old, k_new;
  END
$$;

statement ok
CREATE PROCEDURE wrap_child2_insert(k INT, v INT) LANGUAGE PLpgSQL AS $$
  BEGIN
    INSERT INTO child2 VALUES (k, v);
  EXCEPTION WHEN foreign_key_violation THEN
    RAISE NOTICE 'FK violation inserting (%, %) into child2', k, v;
  END
$$;

# Try deleting a referenced row in the parent table.
query T noticetrace
CALL wrap_parent_update(2, NULL);
----
NOTICE: BEFORE DELETE ON parent: (2) -> <NULL>
NOTICE: BEFORE DELETE ON child: (2,2) -> <NULL>
NOTICE: BEFORE DELETE ON child: (3,2) -> <NULL>
NOTICE: FK violation updating parent from 2 to <NULL>

# Try updating a referenced row in the parent table.
query T noticetrace
CALL wrap_parent_update(2, 10);
----
NOTICE: BEFORE UPDATE ON parent: (2) -> (10)
NOTICE: BEFORE UPDATE ON child: (2,2) -> (2,10)
NOTICE: BEFORE UPDATE ON child: (3,2) -> (3,10)
NOTICE: FK violation updating parent from 2 to 10

# Try inserting a row with no reference into the child2 table.
query T noticetrace
CALL wrap_child2_insert(10, 10);
----
NOTICE: BEFORE INSERT ON child2: <NULL> -> (10,10)
NOTICE: FK violation inserting (10, 10) into child2

statement ok
DROP PROCEDURE wrap_parent_update;
DROP PROCEDURE wrap_child2_insert;
DROP TABLE child2;

# Unless "unsafe_allow_triggers_modifying_cascades" is set, triggers are not
# allowed to modify or filter rows the mutation for a cascade.
subtest triggers_modify_fk_cascades

statement ok
CREATE FUNCTION h() RETURNS TRIGGER LANGUAGE PLpgSQL AS $$
  BEGIN
    NEW.k := (NEW).k + 100;
    OLD.k := (OLD).k + 100;
    RETURN COALESCE(NEW, OLD);
  END
$$;

statement ok
CREATE FUNCTION filter() RETURNS TRIGGER LANGUAGE PLpgSQL AS $$
  BEGIN
    RETURN NULL;
  END
$$;

statement count 4
DELETE FROM child WHERE True;

statement count 3
DELETE FROM parent WHERE True;

statement ok
INSERT INTO parent VALUES (1), (2), (3);
INSERT INTO child VALUES (1, 1), (2, 2), (3, 2), (4, 3);

statement ok
CREATE TRIGGER mod BEFORE INSERT OR UPDATE OR DELETE ON child FOR EACH ROW EXECUTE FUNCTION h();

statement error pgcode 27000 pq: trigger mod attempted to modify or filter a row in a cascade operation: \(1,11\)
UPDATE parent SET k = k + 10 WHERE k < 3;

statement error pgcode 27000 pq: trigger mod attempted to modify or filter a row in a cascade operation: \(1,1\)
DELETE FROM parent WHERE k < 3;

statement ok
SET unsafe_allow_triggers_modifying_cascades = true;

statement ok
UPDATE parent SET k = k + 10 WHERE k < 3;

statement count 0
DELETE FROM parent WHERE k < 3;

statement ok
RESET unsafe_allow_triggers_modifying_cascades;

statement ok
DROP TRIGGER mod ON child;

statement count 4
DELETE FROM child WHERE True;

statement count 3
DELETE FROM parent WHERE True;

statement ok
INSERT INTO parent VALUES (1), (2), (3);
INSERT INTO child VALUES (1, 1), (2, 2), (3, 2), (4, 3);

statement ok
CREATE TRIGGER filter BEFORE INSERT OR UPDATE OR DELETE ON child FOR EACH ROW EXECUTE FUNCTION filter();

statement error pgcode 27000 pq: trigger filter attempted to modify or filter a row in a cascade operation: \(1,11\)
UPDATE parent SET k = k + 10 WHERE k < 3;

statement error pgcode 27000 pq: trigger filter attempted to modify or filter a row in a cascade operation: \(1,1\)
DELETE FROM parent WHERE k < 3;

statement ok
SET unsafe_allow_triggers_modifying_cascades = true;

statement ok
UPDATE parent SET k = k + 10 WHERE k < 3;

statement count 0
DELETE FROM parent WHERE k < 3;

statement ok
RESET unsafe_allow_triggers_modifying_cascades;

statement ok
DROP TRIGGER filter ON child;

statement count 4
DELETE FROM child WHERE True;
DELETE FROM parent WHERE True;
INSERT INTO parent VALUES (1), (2), (3);
INSERT INTO child VALUES (1, 1), (2, 2), (3, 2), (4, 3);

# Modifications to mutated rows made by BEFORE triggers are visible to cascades.
subtest before_trigger_modifies_fk_cascades

statement ok
CREATE TRIGGER mod BEFORE INSERT OR UPDATE OR DELETE ON parent FOR EACH ROW EXECUTE FUNCTION h();

query T noticetrace
UPDATE parent SET k = k + 10 WHERE k < 3;
----
NOTICE: BEFORE UPDATE ON parent: (1) -> (11)
NOTICE: BEFORE UPDATE ON parent: (2) -> (12)
NOTICE: BEFORE UPDATE ON child: (1,1) -> (1,111)
NOTICE: BEFORE UPDATE ON child: (2,2) -> (2,112)
NOTICE: BEFORE UPDATE ON child: (3,2) -> (3,112)
NOTICE: AFTER UPDATE ON parent: (1) -> (111)
NOTICE: AFTER UPDATE ON parent: (2) -> (112)
NOTICE: AFTER UPDATE ON child: (1,1) -> (1,111)
NOTICE: AFTER UPDATE ON child: (2,2) -> (2,112)
NOTICE: AFTER UPDATE ON child: (3,2) -> (3,112)

query II rowsort
SELECT * FROM child;
----
1  111
2  112
3  112
4  3

query T noticetrace
DELETE FROM parent WHERE k > 3;
----
NOTICE: BEFORE DELETE ON parent: (111) -> <NULL>
NOTICE: BEFORE DELETE ON parent: (112) -> <NULL>
NOTICE: BEFORE DELETE ON child: (1,111) -> <NULL>
NOTICE: BEFORE DELETE ON child: (2,112) -> <NULL>
NOTICE: BEFORE DELETE ON child: (3,112) -> <NULL>
NOTICE: AFTER DELETE ON parent: (111) -> <NULL>
NOTICE: AFTER DELETE ON parent: (112) -> <NULL>
NOTICE: AFTER DELETE ON child: (1,111) -> <NULL>
NOTICE: AFTER DELETE ON child: (2,112) -> <NULL>
NOTICE: AFTER DELETE ON child: (3,112) -> <NULL>

query II rowsort
SELECT * FROM child;
----
4  3

statement ok
DROP TRIGGER mod ON parent;

subtest cascade_diamond

# Create a diamond cascade structure.
statement ok
DROP TABLE child;
DELETE FROM parent WHERE True;

statement ok
CREATE TABLE child (k INT PRIMARY KEY, v INT UNIQUE NOT NULL REFERENCES parent(k) ON UPDATE CASCADE ON DELETE CASCADE);
CREATE TABLE child2 (k INT PRIMARY KEY, v INT UNIQUE NOT NULL REFERENCES parent(k) ON UPDATE CASCADE ON DELETE CASCADE);

statement ok
CREATE TRIGGER foo BEFORE INSERT OR UPDATE OR DELETE ON child FOR EACH ROW EXECUTE FUNCTION g();

statement ok
CREATE TRIGGER bar AFTER INSERT OR UPDATE OR DELETE ON child FOR EACH ROW EXECUTE FUNCTION g();

statement ok
CREATE TRIGGER foo BEFORE INSERT OR UPDATE OR DELETE ON child2 FOR EACH ROW EXECUTE FUNCTION g();

statement ok
CREATE TRIGGER bar AFTER INSERT OR UPDATE OR DELETE ON child2 FOR EACH ROW EXECUTE FUNCTION g();

statement ok
CREATE TABLE grandchild (
  k INT PRIMARY KEY,
  v INT REFERENCES child(v) ON UPDATE CASCADE ON DELETE CASCADE,
  v2 INT REFERENCES child2(v) ON UPDATE CASCADE ON DELETE CASCADE
);

statement ok
CREATE TRIGGER foo BEFORE INSERT OR UPDATE OR DELETE ON grandchild FOR EACH ROW EXECUTE FUNCTION g();

statement ok
CREATE TRIGGER bar AFTER INSERT OR UPDATE OR DELETE ON grandchild FOR EACH ROW EXECUTE FUNCTION g();

statement ok
INSERT INTO parent VALUES (1), (2), (3);
INSERT INTO child VALUES (1, 1), (2, 2), (3, 3);
INSERT INTO child2 VALUES (1, 1), (2, 2), (3, 3);
INSERT INTO grandchild VALUES (1, 1, 1), (2, 2, 2), (3, 2, 2), (4, 3, 3);

# Update the parent table, which should cascade to the children and grandchild.
# Note that both child tables cascade to the grandchild.
#
# Regression test for #133784 and #133792.
query T noticetrace
UPDATE parent SET k = k + 10 WHERE k < 3;
----
NOTICE: BEFORE UPDATE ON parent: (1) -> (11)
NOTICE: BEFORE UPDATE ON parent: (2) -> (12)
NOTICE: BEFORE UPDATE ON child: (1,1) -> (1,11)
NOTICE: BEFORE UPDATE ON child: (2,2) -> (2,12)
NOTICE: BEFORE UPDATE ON child2: (1,1) -> (1,11)
NOTICE: BEFORE UPDATE ON child2: (2,2) -> (2,12)
NOTICE: AFTER UPDATE ON parent: (1) -> (11)
NOTICE: AFTER UPDATE ON parent: (2) -> (12)
NOTICE: AFTER UPDATE ON child: (1,1) -> (1,11)
NOTICE: AFTER UPDATE ON child: (2,2) -> (2,12)
NOTICE: AFTER UPDATE ON child2: (1,1) -> (1,11)
NOTICE: AFTER UPDATE ON child2: (2,2) -> (2,12)
NOTICE: BEFORE UPDATE ON grandchild: (1,1,1) -> (1,11,1)
NOTICE: BEFORE UPDATE ON grandchild: (2,2,2) -> (2,12,2)
NOTICE: BEFORE UPDATE ON grandchild: (3,2,2) -> (3,12,2)
NOTICE: BEFORE UPDATE ON grandchild: (1,11,1) -> (1,11,11)
NOTICE: BEFORE UPDATE ON grandchild: (2,12,2) -> (2,12,12)
NOTICE: BEFORE UPDATE ON grandchild: (3,12,2) -> (3,12,12)
NOTICE: AFTER UPDATE ON grandchild: (1,1,1) -> (1,11,1)
NOTICE: AFTER UPDATE ON grandchild: (2,2,2) -> (2,12,2)
NOTICE: AFTER UPDATE ON grandchild: (3,2,2) -> (3,12,2)
NOTICE: AFTER UPDATE ON grandchild: (1,11,1) -> (1,11,11)
NOTICE: AFTER UPDATE ON grandchild: (2,12,2) -> (2,12,12)
NOTICE: AFTER UPDATE ON grandchild: (3,12,2) -> (3,12,12)

query II rowsort
SELECT * FROM child;
----
1  11
2  12
3  3

query II rowsort
SELECT * FROM child2;
----
1  11
2  12
3  3

query III rowsort
SELECT * FROM grandchild;
----
1  11  11
2  12  12
3  12  12
4  3   3

statement ok
DROP TABLE grandchild;
DROP TABLE child;
DROP TABLE child2;
DROP TABLE parent;
DROP FUNCTION g;
DROP FUNCTION h;
DROP FUNCTION filter;

# Regression test for #134745: fire DELETE triggers for cascading deletes.
subtest delete_cascade_triggers

statement ok
CREATE TABLE parent (k INT PRIMARY KEY);
CREATE TABLE child (v INT NOT NULL REFERENCES parent(k) ON DELETE CASCADE);

statement ok
CREATE FUNCTION g() RETURNS TRIGGER LANGUAGE PLpgSQL AS $$
  BEGIN
    RAISE NOTICE '%', TG_OP;
    RETURN COALESCE(NEW, OLD);
  END
$$;

statement ok
INSERT INTO parent VALUES (1), (2), (3);
INSERT INTO child VALUES (1), (2), (2);

statement ok
CREATE TRIGGER foo BEFORE INSERT OR DELETE ON child FOR EACH ROW EXECUTE FUNCTION g();

query T noticetrace
DELETE FROM parent WHERE k = 2;
----
NOTICE: DELETE
NOTICE: DELETE

statement ok
DROP TRIGGER foo ON child;

statement ok
DROP FUNCTION g;
DROP TABLE child;
DROP TABLE parent;

# ==============================================================================
# Test order of execution.
# ==============================================================================

subtest before_row_order

statement ok
CREATE FUNCTION g() RETURNS TRIGGER LANGUAGE PLpgSQL AS $$
  BEGIN
    RAISE NOTICE '%: old: %, new: %', TG_NAME, OLD, NEW;
    RETURN COALESCE(NEW, OLD);
  END
$$;

statement ok
CREATE FUNCTION h() RETURNS TRIGGER LANGUAGE PLpgSQL AS $$
  BEGIN
    RAISE NOTICE '%: old: %, new: %', TG_NAME, OLD, NEW;
    RETURN COALESCE(NEW, OLD);
  END
$$;

statement ok
CREATE TRIGGER c_trig BEFORE INSERT ON xy FOR EACH ROW EXECUTE FUNCTION g();

statement ok
CREATE TRIGGER d_trig BEFORE INSERT ON xy FOR EACH ROW EXECUTE FUNCTION g();

statement ok
CREATE TRIGGER b_trig BEFORE INSERT ON xy FOR EACH ROW EXECUTE FUNCTION h();

statement ok
CREATE TRIGGER a_trig BEFORE INSERT ON xy FOR EACH ROW EXECUTE FUNCTION g();

query T noticetrace
INSERT INTO xy VALUES (1, 2);
----
NOTICE: a_trig: old: <NULL>, new: (1,2)
NOTICE: b_trig: old: <NULL>, new: (1,2)
NOTICE: c_trig: old: <NULL>, new: (1,2)
NOTICE: d_trig: old: <NULL>, new: (1,2)

statement ok
DROP TRIGGER a_trig ON xy;

statement ok
DROP TRIGGER b_trig ON xy;

statement ok
DROP TRIGGER c_trig ON xy;

statement ok
DROP TRIGGER d_trig ON xy;

statement count 1
DELETE FROM xy WHERE True;

subtest after_row_order

statement ok
CREATE TRIGGER c_trig AFTER INSERT ON xy FOR EACH ROW EXECUTE FUNCTION g();

statement ok
CREATE TRIGGER d_trig AFTER INSERT ON xy FOR EACH ROW EXECUTE FUNCTION g();

statement ok
CREATE TRIGGER b_trig AFTER INSERT ON xy FOR EACH ROW EXECUTE FUNCTION h();

statement ok
CREATE TRIGGER a_trig AFTER INSERT ON xy FOR EACH ROW EXECUTE FUNCTION g();

query T noticetrace
INSERT INTO xy VALUES (1, 2);
----
NOTICE: a_trig: old: <NULL>, new: (1,2)
NOTICE: b_trig: old: <NULL>, new: (1,2)
NOTICE: c_trig: old: <NULL>, new: (1,2)
NOTICE: d_trig: old: <NULL>, new: (1,2)

statement ok
DROP TRIGGER a_trig ON xy;

statement ok
DROP TRIGGER b_trig ON xy;

statement ok
DROP TRIGGER c_trig ON xy;

statement ok
DROP TRIGGER d_trig ON xy;

statement ok
DROP FUNCTION g;

statement ok
DROP FUNCTION h;

statement count 1
DELETE FROM xy WHERE True;

subtest before_after_row_order

statement ok
CREATE FUNCTION g() RETURNS TRIGGER LANGUAGE PLpgSQL AS $$
  BEGIN
    RAISE NOTICE '% %: old: %, new: %', TG_WHEN, TG_OP, OLD, NEW;
    RETURN COALESCE(NEW, OLD);
  END
$$;

statement ok
CREATE TRIGGER foo BEFORE INSERT OR UPDATE ON xy FOR EACH ROW EXECUTE FUNCTION g();

statement ok
CREATE TRIGGER bar AFTER INSERT OR UPDATE ON xy FOR EACH ROW EXECUTE FUNCTION g();

# First, all BEFORE triggers are executed. Then, the mutation is executed.
# Finally, the AFTER triggers are executed using the buffer.
query T noticetrace
INSERT INTO xy VALUES (1, 2), (3, 4);
----
NOTICE: BEFORE INSERT: old: <NULL>, new: (1,2)
NOTICE: BEFORE INSERT: old: <NULL>, new: (3,4)
NOTICE: AFTER INSERT: old: <NULL>, new: (1,2)
NOTICE: AFTER INSERT: old: <NULL>, new: (3,4)

# Notice that BEFORE INSERT triggers fire for every input row, while
# AFTER INSERT triggers fire only for those that did not encounter conflicts.
query T noticetrace
UPSERT INTO xy VALUES (1, 2), (3, 4), (5, 6);
----
NOTICE: BEFORE INSERT: old: <NULL>, new: (1,2)
NOTICE: BEFORE UPDATE: old: (1,2), new: (1,2)
NOTICE: BEFORE INSERT: old: <NULL>, new: (3,4)
NOTICE: BEFORE UPDATE: old: (3,4), new: (3,4)
NOTICE: BEFORE INSERT: old: <NULL>, new: (5,6)
NOTICE: AFTER UPDATE: old: (1,2), new: (1,2)
NOTICE: AFTER UPDATE: old: (3,4), new: (3,4)
NOTICE: AFTER INSERT: old: <NULL>, new: (5,6)

statement ok
DROP TRIGGER foo ON xy;

statement ok
DROP TRIGGER bar ON xy;

statement ok
DROP FUNCTION g;

statement count 3
DELETE FROM xy WHERE True;

# ==============================================================================
# Test row-level trigger interaction with computed columns.
# ==============================================================================

# BEFORE triggers do not observe the values of computed columns. Instead, they
# see NULLs. In addition, while a BEFORE trigger can modify a computed column,
# the changed value is ignored. In contrast, the computed column *does* show
# the effect of modifications to the columns it depends on.
subtest before_computed_columns

statement ok
CREATE TABLE computed (a INT, b INT, c INT AS (a + b) STORED, d INT AS (a - b) VIRTUAL);

statement ok
CREATE FUNCTION g() RETURNS TRIGGER LANGUAGE PLpgSQL AS $$
  BEGIN
    RAISE NOTICE 'g()';
    RAISE NOTICE 'NEW: %', NEW;
    NEW.c = 12345;
    NEW.d = 67890;
    RAISE NOTICE 'NEW after change: %', NEW;
    RETURN NEW;
  END
$$;

statement ok
CREATE TRIGGER b_foo BEFORE INSERT OR UPDATE ON computed FOR EACH ROW EXECUTE FUNCTION g();

# BEFORE triggers do not observe the values of computed columns. Instead, they
# see NULLs. In addition, while a BEFORE trigger can modify a computed column,
# the changed value is ignored.
query T noticetrace
INSERT INTO computed VALUES (1, 2);
----
NOTICE: g()
NOTICE: NEW: (1,2,,)
NOTICE: NEW after change: (1,2,12345,67890)

query IIII rowsort
SELECT * FROM computed;
----
1  2  3  -1

query T noticetrace
UPDATE computed SET a = 10, b = 20 WHERE a = 1;
----
NOTICE: g()
NOTICE: NEW: (10,20,,)
NOTICE: NEW after change: (10,20,12345,67890)

query IIII rowsort
SELECT * FROM computed;
----
10  20  30  -10

# The computed column *does* show the effect of modifications to the columns it
# depends on.
statement ok
CREATE FUNCTION h() RETURNS TRIGGER LANGUAGE PLpgSQL AS $$
  BEGIN
    RAISE NOTICE 'h()';
    RAISE NOTICE 'NEW: %', NEW;
    NEW.a = (NEW).a + 100;
    NEW.b = (NEW).b + 200;
    RAISE NOTICE 'NEW after change: %', NEW;
    RETURN NEW;
  END
$$;

# Create triggers that fire before and after the previous one.
statement ok
CREATE TRIGGER a_foo BEFORE INSERT OR UPDATE ON computed FOR EACH ROW EXECUTE FUNCTION h();

statement ok
CREATE TRIGGER c_foo BEFORE INSERT OR UPDATE ON computed FOR EACH ROW EXECUTE FUNCTION h();

query T noticetrace
INSERT INTO computed VALUES (3, 4);
----
NOTICE: h()
NOTICE: NEW: (3,4,,)
NOTICE: NEW after change: (103,204,,)
NOTICE: g()
NOTICE: NEW: (103,204,,)
NOTICE: NEW after change: (103,204,12345,67890)
NOTICE: h()
NOTICE: NEW: (103,204,12345,67890)
NOTICE: NEW after change: (203,404,12345,67890)

query IIII rowsort
SELECT * FROM computed;
----
10   20   30   -10
203  404  607  -201

query T noticetrace
UPDATE computed SET a = 30, b = 40 WHERE a = 203;
----
NOTICE: h()
NOTICE: NEW: (30,40,,)
NOTICE: NEW after change: (130,240,,)
NOTICE: g()
NOTICE: NEW: (130,240,,)
NOTICE: NEW after change: (130,240,12345,67890)
NOTICE: h()
NOTICE: NEW: (130,240,12345,67890)
NOTICE: NEW after change: (230,440,12345,67890)

query IIII rowsort
SELECT * FROM computed;
----
10   20   30   -10
230  440  670  -210

# AFTER triggers observe the values of computed columns. They can also modify
# computed columns, but the updated value is ignored (in fact, any modification
# is ignored for AFTER triggers).
subtest after_computed_columns

statement ok
CREATE TRIGGER trig AFTER INSERT OR UPDATE ON computed FOR EACH ROW EXECUTE FUNCTION g();

query T noticetrace
INSERT INTO computed VALUES (5, 6);
----
NOTICE: h()
NOTICE: NEW: (5,6,,)
NOTICE: NEW after change: (105,206,,)
NOTICE: g()
NOTICE: NEW: (105,206,,)
NOTICE: NEW after change: (105,206,12345,67890)
NOTICE: h()
NOTICE: NEW: (105,206,12345,67890)
NOTICE: NEW after change: (205,406,12345,67890)
NOTICE: g()
NOTICE: NEW: (205,406,611,-201)
NOTICE: NEW after change: (205,406,12345,67890)

query IIII rowsort
SELECT * FROM computed;
----
10   20   30   -10
230  440  670  -210
205  406  611  -201

query T noticetrace
UPDATE computed SET a = 50, b = 60 WHERE a = 230;
----
NOTICE: h()
NOTICE: NEW: (50,60,,)
NOTICE: NEW after change: (150,260,,)
NOTICE: g()
NOTICE: NEW: (150,260,,)
NOTICE: NEW after change: (150,260,12345,67890)
NOTICE: h()
NOTICE: NEW: (150,260,12345,67890)
NOTICE: NEW after change: (250,460,12345,67890)
NOTICE: g()
NOTICE: NEW: (250,460,710,-210)
NOTICE: NEW after change: (250,460,12345,67890)

query IIII rowsort
SELECT * FROM computed;
----
10   20   30   -10
250  460  710  -210
205  406  611  -201

statement ok
DROP TRIGGER trig ON computed;

statement ok
DROP TRIGGER a_foo ON computed;

statement ok
DROP TRIGGER b_foo ON computed;

statement ok
DROP TRIGGER c_foo ON computed;

# The WHEN clause for a BEFORE trigger should observe NULL values for computed
# columns. For an AFTER trigger, the WHEN clause should observe the computed
# values.
subtest when_computed_columns

statement ok
CREATE TRIGGER trig BEFORE INSERT OR UPDATE ON computed
FOR EACH ROW WHEN ((NEW).c IS NULL AND (NEW).d IS NULL) EXECUTE FUNCTION g();

statement ok
CREATE TRIGGER trig_after AFTER INSERT OR UPDATE ON computed
FOR EACH ROW WHEN ((NEW).c IS NOT NULL AND (NEW).d IS NOT NULL) EXECUTE FUNCTION g();

query T noticetrace
INSERT INTO computed VALUES (7, 8);
----
NOTICE: g()
NOTICE: NEW: (7,8,,)
NOTICE: NEW after change: (7,8,12345,67890)
NOTICE: g()
NOTICE: NEW: (7,8,15,-1)
NOTICE: NEW after change: (7,8,12345,67890)

query IIII rowsort
SELECT * FROM computed;
----
10   20   30   -10
250  460  710  -210
205  406  611  -201
7    8    15   -1

query T noticetrace
UPDATE computed SET a = 70, b = 80 WHERE a = 7;
----
NOTICE: g()
NOTICE: NEW: (70,80,,)
NOTICE: NEW after change: (70,80,12345,67890)
NOTICE: g()
NOTICE: NEW: (70,80,150,-10)
NOTICE: NEW after change: (70,80,12345,67890)

query IIII rowsort
SELECT * FROM computed;
----
10   20   30   -10
250  460  710  -210
205  406  611  -201
70   80   150  -10

statement ok
DROP TABLE computed;
DROP FUNCTION g;
DROP FUNCTION h;

# ==============================================================================
# Test SHOW TRIGGERS.
# ==============================================================================

subtest show_triggers

statement ok
CREATE TABLE t (a INT, b INT, c INT);

statement ok
CREATE FUNCTION g() RETURNS TRIGGER LANGUAGE PLpgSQL AS $$ BEGIN RETURN NEW; END $$;

query TB colnames
SHOW TRIGGERS FROM t;
----
trigger_name  enabled

statement ok
CREATE TRIGGER foo BEFORE INSERT ON t FOR EACH ROW EXECUTE FUNCTION g();

query TB colnames
SHOW TRIGGERS FROM t;
----
trigger_name  enabled
foo           true

statement ok
CREATE TRIGGER bar AFTER INSERT ON t FOR EACH ROW EXECUTE FUNCTION g();

query TB colnames,rowsort
SHOW TRIGGERS FROM t;
----
trigger_name  enabled
foo           true
bar           true

statement ok
DROP TRIGGER foo ON t;

query TB colnames
SHOW TRIGGERS FROM t;
----
trigger_name  enabled
bar           true

statement ok
DROP TRIGGER bar ON t;

query TB colnames
SHOW TRIGGERS FROM t;
----
trigger_name  enabled

subtest show_triggers_privileges

# The user must have any privilege on the table (or be its owner) to see its
# triggers.
statement ok
REVOKE ALL ON TABLE t FROM testuser;

user testuser

statement error pgcode 42501 pq: user testuser has no privileges on relation t
SHOW TRIGGERS FROM t;

user root

statement ok
GRANT INSERT ON TABLE t TO testuser;

user testuser

statement ok
SHOW TRIGGERS FROM t;

user root

statement ok
REVOKE ALL ON TABLE t FROM testuser;
ALTER TABLE t OWNER TO testuser;

user testuser

statement ok
SHOW TRIGGERS FROM t;

user root

statement ok
DROP FUNCTION g;
DROP TABLE t;

# ==============================================================================
# Test SHOW CREATE TRIGGER.
# ==============================================================================

subtest show_create_trigger

statement ok
CREATE TABLE t (a INT, b INT, c INT);
CREATE FUNCTION g() RETURNS TRIGGER AS $$ BEGIN RETURN NEW; END $$ LANGUAGE PLpgSQL;

statement error pgcode 42704 pq: trigger foo for table t does not exist
SHOW CREATE TRIGGER foo ON t;

statement ok
CREATE TRIGGER tr AFTER INSERT ON t FOR EACH ROW EXECUTE FUNCTION g();

statement ok
CREATE TRIGGER tr2 BEFORE UPDATE ON t FOR EACH ROW EXECUTE FUNCTION g();

statement ok
CREATE TRIGGER tr3 AFTER INSERT OR UPDATE ON t FOR EACH ROW WHEN ((NEW).a < 5) EXECUTE FUNCTION g();

query TT colnames
SHOW CREATE TRIGGER tr ON t;
----
trigger_name  create_statement
tr            CREATE TRIGGER tr AFTER INSERT ON test.public.t FOR EACH ROW EXECUTE FUNCTION test.public.g()

query TT colnames
SHOW CREATE TRIGGER tr2 ON t;
----
trigger_name  create_statement
tr2           CREATE TRIGGER tr2 BEFORE UPDATE ON test.public.t FOR EACH ROW EXECUTE FUNCTION test.public.g()

query TT colnames
SHOW CREATE TRIGGER tr3 ON t;
----
trigger_name  create_statement
tr3           CREATE TRIGGER tr3 AFTER INSERT OR UPDATE ON test.public.t FOR EACH ROW WHEN (new).a < 5:::INT8 EXECUTE FUNCTION test.public.g()

statement ok
DROP TRIGGER tr ON t;

statement error pgcode 42704 pq: trigger tr for table t does not exist
SHOW CREATE TRIGGER tr ON t;

subtest show_create_trigger_privileges

# The user must have any privilege on the table (or be its owner).
statement ok
REVOKE ALL ON TABLE t FROM testuser;

user testuser

statement error pgcode 42501 pq: user testuser has no privileges on relation t
SHOW CREATE TRIGGER tr2 ON t;

user root

statement ok
GRANT INSERT ON t TO testuser;

user testuser

statement ok
SHOW CREATE TRIGGER tr2 ON t;

user root

statement ok
REVOKE ALL ON t FROM testuser;
ALTER TABLE t OWNER TO testuser;

user testuser

statement ok
SHOW CREATE TRIGGER tr2 ON t;

user root

statement ok
DROP TABLE t;
DROP FUNCTION g;

# ==============================================================================
# Test restrictions on multiple mutations to the same table.
# ==============================================================================

subtest multiple_mutations

statement ok
CREATE TABLE t1 (a INT, b INT);
CREATE TABLE t2 (a INT, b INT);
CREATE TABLE parent (k INT PRIMARY KEY);
CREATE TABLE child (k INT PRIMARY KEY, v INT REFERENCES parent(k) ON DELETE CASCADE);

statement ok
CREATE FUNCTION g() RETURNS TRIGGER LANGUAGE PLpgSQL AS $$
  BEGIN
    INSERT INTO t2 VALUES (100, 200);
    RETURN COALESCE(NEW, OLD);
  END
$$;

statement ok
CREATE FUNCTION h() RETURNS TRIGGER LANGUAGE PLpgSQL AS $$
  BEGIN
    UPDATE t2 SET b = b + 100 WHERE a = 100;
    RETURN COALESCE(NEW, OLD);
  END
$$;

statement ok
CREATE FUNCTION insert_t1() RETURNS INT LANGUAGE PLpgSQL AS $$ BEGIN INSERT INTO t1 VALUES (1, 1); RETURN 0; END $$;
CREATE FUNCTION delete_parent() RETURNS INT LANGUAGE PLpgSQL AS $$ BEGIN DELETE FROM parent WHERE k = 1; RETURN 0; END $$;

# ------------------------------------------------------------------------------
# Test a BEFORE trigger with an INSERT statement.
# ------------------------------------------------------------------------------

statement ok
CREATE TRIGGER foo BEFORE INSERT OR UPDATE ON t1 FOR EACH ROW EXECUTE FUNCTION g();

statement ok
CREATE TRIGGER bar BEFORE DELETE ON child FOR EACH ROW EXECUTE FUNCTION g();

# Multiple mutations of the same table are allowed if they all use INSERT
# without ON CONFLICT.
statement ok
WITH foo AS (INSERT INTO t2 VALUES (1, 1) RETURNING a) INSERT INTO t1 VALUES (1, 1);

statement ok
WITH foo AS (INSERT INTO t2 VALUES (1, 1) RETURNING a) SELECT insert_t1();

statement ok
UPSERT INTO parent VALUES (1);
UPSERT INTO child VALUES (1, 1);
WITH foo AS (INSERT INTO t2 VALUES (1, 1) RETURNING a) DELETE FROM parent WHERE k = 1;

# Wrapping the DELETE on parent in a UDF causes the FK cascade (and therefore
# the BEFORE trigger) to execute as part of the main query. However, INSERT
# statements do not conflict with one another.
statement ok
UPSERT INTO parent VALUES (1);
UPSERT INTO child VALUES (1, 1);
WITH foo AS (INSERT INTO t2 VALUES (1, 1) RETURNING a) SELECT delete_parent();

# The triggered INSERT conflicts with the outer UPDATE.
statement error pgcode 0A000 pq: multiple mutations of the same table "t2" are not supported unless they all use INSERT without ON CONFLICT
WITH foo AS (UPDATE t2 SET b = 1 WHERE a = 1 RETURNING a) INSERT INTO t1 VALUES (1, 1);

statement error pgcode 0A000 pq: multiple mutations of the same table "t2" are not supported unless they all use INSERT without ON CONFLICT
WITH foo AS (UPDATE t2 SET b = 1 WHERE a = 1 RETURNING a) SELECT insert_t1();

# The triggered INSERT does not conflict with the outer UPDATE because it is run
# as part of the FK cascade after the main query.
statement ok
UPSERT INTO parent VALUES (1);
UPSERT INTO child VALUES (1, 1);
WITH foo AS (UPDATE t2 SET b = 1 WHERE a = 1 RETURNING a) DELETE FROM parent WHERE k = 1;

# Wrapping the DELETE on parent in a UDF causes the FK cascade (and therefore
# the BEFORE trigger) to execute as part of the main query. As a result, the
# triggered INSERT conflicts with the outer UPDATE.
statement error pgcode 0A000 pq: while building cascade expression: multiple mutations of the same table "t2" are not supported unless they all use INSERT without ON CONFLICT
UPSERT INTO parent VALUES (1);
UPSERT INTO child VALUES (1, 1);
WITH foo AS (UPDATE t2 SET b = 1 WHERE a = 1 RETURNING a) SELECT delete_parent();

statement ok
DROP TRIGGER foo ON t1;

statement ok
DROP TRIGGER bar ON child;

# ------------------------------------------------------------------------------
# Test a BEFORE trigger with an UPDATE statement.
# ------------------------------------------------------------------------------

statement ok
CREATE TRIGGER foo BEFORE INSERT OR UPDATE ON t1 FOR EACH ROW EXECUTE FUNCTION h();

statement ok
CREATE TRIGGER bar BEFORE DELETE ON child FOR EACH ROW EXECUTE FUNCTION h();

# The triggered UPDATE conflicts with the outer INSERT.
statement error pgcode 0A000 pq: multiple mutations of the same table "t2" are not supported unless they all use INSERT without ON CONFLICT
WITH foo AS (INSERT INTO t2 VALUES (1, 1) RETURNING a) INSERT INTO t1 VALUES (1, 2);

statement error pgcode 0A000 pq: multiple mutations of the same table "t2" are not supported unless they all use INSERT without ON CONFLICT
WITH foo AS (INSERT INTO t2 VALUES (1, 1) RETURNING a) SELECT insert_t1();

# The triggered UPDATE does not conflict with the outer INSERT because it is run
# as part of the FK cascade after the main query.
statement ok
UPSERT INTO parent VALUES (1);
UPSERT INTO child VALUES (1, 1);
WITH foo AS (INSERT INTO t2 VALUES (1, 1) RETURNING a) DELETE FROM parent WHERE k = 1;

# Wrapping the DELETE on parent in a UDF causes the FK cascade (and therefore
# the BEFORE trigger) to execute as part of the main query. As a result, the
# triggered UPDATE conflicts with the outer INSERT.
statement error pgcode 0A000 pq: while building cascade expression: multiple mutations of the same table "t2" are not supported unless they all use INSERT without ON CONFLICT
UPSERT INTO parent VALUES (1);
UPSERT INTO child VALUES (1, 1);
WITH foo AS (INSERT INTO t2 VALUES (1, 1) RETURNING a) SELECT delete_parent();

# Even though the triggered UPDATE executes twice, the mutations are allowed
# because they are "siblings".
statement ok
WITH foo AS (INSERT INTO t1 VALUES (1, 2) RETURNING a) INSERT INTO t1 VALUES (1, 1);

statement ok
WITH foo AS (INSERT INTO t1 VALUES (1, 2) RETURNING a) SELECT insert_t1();

statement ok
WITH foo AS (SELECT insert_t1()) SELECT insert_t1();

statement ok
DROP TRIGGER foo ON t1;

statement ok
DROP TRIGGER bar ON child;

# ------------------------------------------------------------------------------
# Test an AFTER trigger with an INSERT statement.
# ------------------------------------------------------------------------------

statement ok
CREATE TRIGGER foo AFTER INSERT OR UPDATE ON t1 FOR EACH ROW EXECUTE FUNCTION g();

statement ok
CREATE TRIGGER bar AFTER DELETE ON child FOR EACH ROW EXECUTE FUNCTION g();

# INSERT without ON CONFLICT is always allowed.
statement ok
WITH foo AS (INSERT INTO t2 VALUES (1, 1) RETURNING a) INSERT INTO t1 VALUES (1, 1);

statement ok
WITH foo AS (INSERT INTO t2 VALUES (1, 1) RETURNING a) SELECT insert_t1();

statement ok
UPSERT INTO parent VALUES (1);
UPSERT INTO child VALUES (1, 1);
WITH foo AS (INSERT INTO t2 VALUES (1, 1) RETURNING a) DELETE FROM parent WHERE k = 1;

# Wrapping the DELETE on parent in a UDF causes the FK cascade (and therefore
# the AFTER trigger) to execute as part of the main query. However, INSERT
# statements do not conflict with one another.
statement ok
UPSERT INTO parent VALUES (1);
UPSERT INTO child VALUES (1, 1);
WITH foo AS (INSERT INTO t2 VALUES (1, 1) RETURNING a) SELECT delete_parent();

# The triggered INSERT does not conflict with the outer UPDATE on t2 because the
# trigger is run as a post-query.
statement ok
WITH foo AS (UPDATE t2 SET b = 1 WHERE a = 1 RETURNING a) INSERT INTO t1 VALUES (1, 1);

# When the INSERT into t1 is wrapped in a UDF, the AFTER trigger is run within
# the UDF, and so the triggered INSERT on t2 conflicts with the outer UPDATE.
statement error pgcode 0A000 pq: while building trigger expression: multiple mutations of the same table "t2" are not supported unless they all use INSERT without ON CONFLICT
WITH foo AS (UPDATE t2 SET b = 1 WHERE a = 1 RETURNING a) SELECT insert_t1();

# The triggered INSERT does not conflict with the outer UPDATE because it is run
# after the FK cascade, which runs after the main query.
statement ok
UPSERT INTO parent VALUES (1);
UPSERT INTO child VALUES (1, 1);
WITH foo AS (UPDATE t2 SET b = 1 WHERE a = 1 RETURNING a) DELETE FROM parent WHERE k = 1;

# Wrapping the DELETE on parent in a UDF causes the FK cascade (and therefore
# the AFTER trigger) to execute as part of the main query. As a result, the
# triggered INSERT conflicts with the outer UPDATE.
statement error pgcode 0A000 pq: while building trigger expression: multiple mutations of the same table "t2" are not supported unless they all use INSERT without ON CONFLICT
UPSERT INTO parent VALUES (1);
UPSERT INTO child VALUES (1, 1);
WITH foo AS (UPDATE t2 SET b = 1 WHERE a = 1 RETURNING a) SELECT delete_parent();

statement ok
DROP TRIGGER foo ON t1;

statement ok
DROP TRIGGER bar ON child;

# ------------------------------------------------------------------------------
# Test an AFTER trigger with an UPDATE statement.
# ------------------------------------------------------------------------------

statement ok
CREATE TRIGGER foo AFTER INSERT OR UPDATE ON t1 FOR EACH ROW EXECUTE FUNCTION h();

statement ok
CREATE TRIGGER bar AFTER DELETE ON child FOR EACH ROW EXECUTE FUNCTION h();

# The triggered UPDATE does not conflict with the outer INSERT on t2 because the
# trigger is run as a post-query.
statement ok
WITH foo AS (INSERT INTO t2 VALUES (1, 1) RETURNING a) INSERT INTO t1 VALUES (1, 1);

# When the INSERT into t1 is wrapped in a UDF, the AFTER trigger is run within
# the UDF, and so the triggered UPDATE on t2 conflicts with the outer INSERT.
statement error pgcode 0A000 pq: while building trigger expression: multiple mutations of the same table "t2" are not supported unless they all use INSERT without ON CONFLICT
WITH foo AS (INSERT INTO t2 VALUES (1, 1) RETURNING a) SELECT insert_t1();

# The triggered UPDATE does not conflict with the outer INSERT because it is run
# after the FK cascade, which runs after the main query.
statement ok
UPSERT INTO parent VALUES (1);
UPSERT INTO child VALUES (1, 1);
WITH foo AS (INSERT INTO t2 VALUES (1, 1) RETURNING a) DELETE FROM parent WHERE k = 1;

# Wrapping the DELETE on parent in a UDF causes the FK cascade (and therefore
# the AFTER trigger) to execute as part of the main query. As a result, the
# triggered UPDATE conflicts with the outer INSERT.
statement error pgcode 0A000 pq: while building trigger expression: multiple mutations of the same table "t2" are not supported unless they all use INSERT without ON CONFLICT
UPSERT INTO parent VALUES (1);
UPSERT INTO child VALUES (1, 1);
WITH foo AS (INSERT INTO t2 VALUES (1, 1) RETURNING a) SELECT delete_parent();

# The triggered UPDATE does not conflict with the outer UPDATE on t2 because the
# trigger is run as a post-query.
statement ok
WITH foo AS (UPDATE t2 SET b = 1 WHERE a = 1 RETURNING a) INSERT INTO t1 VALUES (1, 1);

# Wrapping the INSERT on t1 in a UDF means the trigger is run within the scope
# of the UDF, so the triggered UPDATE on t2 conflicts with the outer UPDATE.
statement error pgcode 0A000 pq: while building trigger expression: multiple mutations of the same table "t2" are not supported unless they all use INSERT without ON CONFLICT
WITH foo AS (UPDATE t2 SET b = 1 WHERE a = 1 RETURNING a) SELECT insert_t1();

# The triggered UPDATE does not conflict with the outer UPDATE because it is run
# after the FK cascade, which runs after the main query.
statement ok
UPSERT INTO parent VALUES (1);
UPSERT INTO child VALUES (1, 1);
WITH foo AS (UPDATE t2 SET b = 1 WHERE a = 1 RETURNING a) DELETE FROM parent WHERE k = 1;

# Wrapping the DELETE on parent in a UDF causes the FK cascade (and therefore
# the AFTER trigger) to execute as part of the main query. As a result, the
# triggered UPDATE conflicts with the outer UPDATE.
statement error pgcode 0A000 pq: while building trigger expression: multiple mutations of the same table "t2" are not supported unless they all use INSERT without ON CONFLICT
UPSERT INTO parent VALUES (1);
UPSERT INTO child VALUES (1, 1);
WITH foo AS (UPDATE t2 SET b = 1 WHERE a = 1 RETURNING a) SELECT delete_parent();

# Even though the trigger executes an UPDATE on t2 twice, the mutations are
# allowed because they are executed as post-queries.
statement ok
WITH foo AS (INSERT INTO t1 VALUES (1, 2) RETURNING a) INSERT INTO t1 VALUES (1, 1);

# Even though the trigger executes an UPDATE on t2 twice, the mutations are
# allowed because one is executed as a post-query.
statement ok
WITH foo AS (INSERT INTO t1 VALUES (1, 2) RETURNING a) SELECT insert_t1();

# Even though the trigger executes an UPDATE on t2 twice, the mutations are
# allowed because they are "siblings".
statement ok
WITH foo AS (SELECT insert_t1()) SELECT insert_t1();

statement ok
DROP TRIGGER foo ON t1;

statement ok
DROP TRIGGER bar ON child;

statement ok
DROP FUNCTION insert_t1;
DROP TABLE t1;
DROP TABLE t2;
DROP FUNCTION g;
DROP FUNCTION h;

# ------------------------------------------------------------------------------
# Test a trigger conflicting with a FK cascade mutation.
# ------------------------------------------------------------------------------

statement ok
CREATE FUNCTION g() RETURNS TRIGGER LANGUAGE PLpgSQL AS $$
  BEGIN
    UPDATE child SET k = k + 1 WHERE True;
    RETURN OLD;
  END
$$;

statement ok
CREATE TRIGGER foo BEFORE DELETE ON child FOR EACH ROW EXECUTE FUNCTION g();

# The triggered UPDATE conflicts with the cascaded DELETE on child.
statement error pgcode 0A000 pq: while building cascade expression: multiple mutations of the same table "child" are not supported unless they all use INSERT without ON CONFLICT
UPSERT INTO parent VALUES (1);
UPSERT INTO child VALUES (1, 1);
DELETE FROM parent WHERE k = 1;

statement ok
DROP TRIGGER foo ON child;

statement ok
CREATE TRIGGER foo AFTER DELETE ON child FOR EACH ROW EXECUTE FUNCTION g();

# The triggered UPDATE does not conflict with the cascaded DELETE on child
# because the trigger is run as a post-query.
statement ok
UPSERT INTO parent VALUES (1);
UPSERT INTO child VALUES (1, 1);
DELETE FROM parent WHERE k = 1;

statement ok
DROP FUNCTION delete_parent;
DROP TABLE child;
DROP TABLE parent;
DROP FUNCTION g;

# ==============================================================================
# Test unsupported syntax.
# ==============================================================================

subtest unsupported

# CREATE OR REPLACE TRIGGER when the trigger does not exist yet creates it.
statement ok
CREATE OR REPLACE TRIGGER replace_test BEFORE INSERT ON xy FOR EACH ROW EXECUTE FUNCTION f();

query TT
SHOW CREATE TRIGGER replace_test ON xy;
----
replace_test  CREATE TRIGGER replace_test BEFORE INSERT ON test.public.xy FOR EACH ROW EXECUTE FUNCTION test.public.f()

# CREATE OR REPLACE TRIGGER when the trigger already exists replaces it.
statement ok
CREATE OR REPLACE TRIGGER replace_test AFTER UPDATE ON xy FOR EACH ROW EXECUTE FUNCTION f();

query TT
SHOW CREATE TRIGGER replace_test ON xy;
----
replace_test  CREATE TRIGGER replace_test AFTER UPDATE ON test.public.xy FOR EACH ROW EXECUTE FUNCTION test.public.f()

# CREATE TRIGGER (without REPLACE) still errors on duplicate.
statement error pgcode 42710 pq: trigger "replace_test" for relation "xy" already exists
CREATE TRIGGER replace_test AFTER INSERT ON xy FOR EACH ROW EXECUTE FUNCTION f();

statement ok
DROP TRIGGER replace_test ON xy;

statement error pgcode 0A000 pq: unimplemented: statement-level triggers are not yet supported
CREATE TRIGGER foo AFTER INSERT ON xy FOR EACH STATEMENT EXECUTE FUNCTION f();

statement error pgcode 0A000 pq: unimplemented: INSTEAD OF triggers are not yet supported
CREATE TRIGGER foo INSTEAD OF INSERT ON v FOR EACH ROW EXECUTE FUNCTION f();

statement error pgcode 0A000 pq: unimplemented: REFERENCING clause is not yet supported for triggers
CREATE TRIGGER foo AFTER INSERT ON xy REFERENCING NEW TABLE AS nt FOR EACH ROW EXECUTE FUNCTION f();

# TODO(#126362): uncomment this case.
# statement error pgcode 0A000 pq: unimplemented: TRUNCATE triggers are not yet supported
# CREATE TRIGGER foo AFTER TRUNCATE ON xy FOR EACH STATEMENT EXECUTE FUNCTION f();

statement error pgcode 0A000 pq: unimplemented: column lists are not yet supported for triggers
CREATE TRIGGER foo AFTER UPDATE OF y ON xy FOR EACH ROW EXECUTE FUNCTION f();

statement ok
CREATE TRIGGER foo AFTER INSERT ON xy FOR EACH ROW EXECUTE FUNCTION f();

# Verify we log to the event log.
query T retry
select "eventType" from system.eventlog WHERE "eventType" <> 'finish_schema_change' order by timestamp desc limit 1;
----
create_trigger

# Replacing a trigger function with active triggers is now supported (#134555).
onlyif config local-mixed-25.4 local-mixed-26.1
statement error pgcode 0A000 pq: unimplemented: cannot replace a trigger function with an active trigger
CREATE OR REPLACE FUNCTION f() RETURNS TRIGGER LANGUAGE PLpgSQL AS $$ BEGIN RETURN NEW; END $$;

skipif config local-mixed-25.4 local-mixed-26.1
statement ok
CREATE OR REPLACE FUNCTION f() RETURNS TRIGGER LANGUAGE PLpgSQL AS $$ BEGIN RETURN NEW; END $$;

statement ok
DROP TRIGGER foo ON xy;

# Verify we log to the event log.
query T retry
select "eventType" from system.eventlog order by timestamp desc limit 1;
----
drop_trigger

# ==============================================================================
# Test that descriptor backreferences are cleaned up.
# ==============================================================================

subtest ensure_back_ref_cleanup

statement ok
create table listings_balance (c1 int);

# Create a function that references listings_balance
statement ok
create or replace function update_listing_balance()
returns TRIGGER language PLpgSQL AS
$$
BEGIN
  INSERT INTO listings_balance VALUES (1);
  RETURN NEW;
END
$$;

statement ok
CREATE TABLE transaction_entries (c1 int);

# Create a trigger that references listings_balance through the trigger function.
statement ok
create trigger tr AFTER INSERT OR UPDATE ON transaction_entries FOR EACH ROW execute function update_listing_balance();

# Force the legacy schema change for the drop table. We will save the original
# DSC setting so that it be reset properly.
let $use_decl_sc
SHOW use_declarative_schema_changer

statement ok
SET use_declarative_schema_changer = off;

# This should cleanup the dependency in listings_balance.
statement ok
DROP TABLE transaction_entries;

# Reinstate original DSC setting
statement ok
SET use_declarative_schema_changer = $use_decl_sc;

statement ok
DROP FUNCTION update_listing_balance ;

# Sanity to verify the dependency no longer exists.
statement ok
drop table listings_balance cascade;

# ==============================================================================
# Test trigger arguments.
# ==============================================================================

statement ok
CREATE FUNCTION g() RETURNS TRIGGER LANGUAGE PLpgSQL AS $$
  BEGIN
    RAISE NOTICE 'NEW: %', NEW;
    RAISE NOTICE 'OLD: %', OLD;
    RAISE NOTICE 'TG_NAME: %', TG_NAME;
    RAISE NOTICE 'TG_WHEN: %', TG_WHEN;
    RAISE NOTICE 'TG_LEVEL: %', TG_LEVEL;
    RAISE NOTICE 'TG_OP: %', TG_OP;
    RAISE NOTICE 'TG_RELID: %', TG_RELID;
    RAISE NOTICE 'TG_RELNAME: %', TG_RELNAME;
    RAISE NOTICE 'TG_TABLE_NAME: %', TG_TABLE_NAME;
    RAISE NOTICE 'TG_TABLE_SCHEMA: %', TG_TABLE_SCHEMA;
    RAISE NOTICE 'TG_NARGS: %', TG_NARGS;
    RAISE NOTICE 'TG_ARGV: %', TG_ARGV;
    RETURN NEW;
  END
$$;

statement ok
CREATE TRIGGER foo BEFORE INSERT OR UPDATE ON xy FOR EACH ROW WHEN ((NEW).x = 1) EXECUTE FUNCTION g();

statement ok
CREATE TRIGGER bar AFTER INSERT OR UPDATE ON xy FOR EACH ROW WHEN ((NEW).x = 1) EXECUTE FUNCTION g();

query T noticetrace
INSERT INTO xy VALUES (1, 2);
----
NOTICE: NEW: (1,2)
NOTICE: OLD: <NULL>
NOTICE: TG_NAME: foo
NOTICE: TG_WHEN: BEFORE
NOTICE: TG_LEVEL: ROW
NOTICE: TG_OP: INSERT
NOTICE: TG_RELID: 106
NOTICE: TG_RELNAME: xy
NOTICE: TG_TABLE_NAME: xy
NOTICE: TG_TABLE_SCHEMA: public
NOTICE: TG_NARGS: 0
NOTICE: TG_ARGV: {}
NOTICE: NEW: (1,2)
NOTICE: OLD: <NULL>
NOTICE: TG_NAME: bar
NOTICE: TG_WHEN: AFTER
NOTICE: TG_LEVEL: ROW
NOTICE: TG_OP: INSERT
NOTICE: TG_RELID: 106
NOTICE: TG_RELNAME: xy
NOTICE: TG_TABLE_NAME: xy
NOTICE: TG_TABLE_SCHEMA: public
NOTICE: TG_NARGS: 0
NOTICE: TG_ARGV: {}

query T noticetrace
UPDATE xy SET y = 3 WHERE x = 1;
----
NOTICE: NEW: (1,3)
NOTICE: OLD: (1,2)
NOTICE: TG_NAME: foo
NOTICE: TG_WHEN: BEFORE
NOTICE: TG_LEVEL: ROW
NOTICE: TG_OP: UPDATE
NOTICE: TG_RELID: 106
NOTICE: TG_RELNAME: xy
NOTICE: TG_TABLE_NAME: xy
NOTICE: TG_TABLE_SCHEMA: public
NOTICE: TG_NARGS: 0
NOTICE: TG_ARGV: {}
NOTICE: NEW: (1,3)
NOTICE: OLD: (1,2)
NOTICE: TG_NAME: bar
NOTICE: TG_WHEN: AFTER
NOTICE: TG_LEVEL: ROW
NOTICE: TG_OP: UPDATE
NOTICE: TG_RELID: 106
NOTICE: TG_RELNAME: xy
NOTICE: TG_TABLE_NAME: xy
NOTICE: TG_TABLE_SCHEMA: public
NOTICE: TG_NARGS: 0
NOTICE: TG_ARGV: {}

statement ok
DROP TRIGGER foo ON xy;

statement ok
DROP TRIGGER bar ON xy;

statement ok
DROP FUNCTION g;

statement count 1
DELETE FROM xy WHERE true;

# ==============================================================================
# Test information_schema.triggers and pg_catalog.pg_trigger
# ==============================================================================

subtest trigger_introspection

# Create test tables and trigger functions.
statement ok
CREATE TABLE test_triggers (
    id INT PRIMARY KEY,
    name TEXT,
    value INT
);

statement ok
CREATE TABLE audit_log (
    id SERIAL PRIMARY KEY,
    table_name TEXT,
    operation TEXT,
    timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

statement ok
CREATE FUNCTION trigger_func1() RETURNS TRIGGER AS $$
  BEGIN
    INSERT INTO audit_log (table_name, operation)
    VALUES (TG_TABLE_NAME, TG_OP);
    RETURN NEW;
  END;
$$ LANGUAGE PLpgSQL;

statement ok
CREATE FUNCTION trigger_func2() RETURNS TRIGGER AS $$
  BEGIN
    RAISE NOTICE 'Trigger fired';
    RETURN NEW;
  END;
$$ LANGUAGE PLpgSQL;

statement ok
CREATE TRIGGER after_insert_row
AFTER INSERT ON test_triggers
FOR EACH ROW
EXECUTE FUNCTION trigger_func1();

statement ok
CREATE TRIGGER before_update_row
BEFORE UPDATE ON test_triggers
FOR EACH ROW
WHEN ((NEW).value > 100)
EXECUTE FUNCTION trigger_func2();

statement ok
CREATE TRIGGER after_delete_row
AFTER DELETE ON test_triggers
FOR EACH ROW
EXECUTE FUNCTION trigger_func1();

query TTTTTTITTTTT colnames
SELECT
    trigger_catalog,
    trigger_schema,
    trigger_name,
    event_manipulation,
    event_object_schema,
    event_object_table,
    action_order,
    action_orientation,
    action_timing,
    action_reference_old_table,
    action_reference_new_table,
    created
FROM information_schema.triggers
WHERE event_object_table = 'test_triggers'
ORDER BY trigger_name;
----
trigger_catalog  trigger_schema  trigger_name       event_manipulation  event_object_schema  event_object_table  action_order  action_orientation  action_timing  action_reference_old_table  action_reference_new_table  created
test             public          after_delete_row   DELETE              public               test_triggers       NULL          ROW                 AFTER          NULL                        NULL                        NULL
test             public          after_insert_row   INSERT              public               test_triggers       NULL          ROW                 AFTER          NULL                        NULL                        NULL
test             public          before_update_row  UPDATE              public               test_triggers       NULL          ROW                 BEFORE         NULL                        NULL                        NULL

# Test trigger with WHEN condition.
query TTT colnames
SELECT
    trigger_name,
    action_condition,
    action_statement
FROM information_schema.triggers
WHERE trigger_name = 'before_update_row';
----
trigger_name       action_condition     action_statement
before_update_row  ((new).value > 100)  EXECUTE FUNCTION trigger_func2()

# Create trigger with transition tables.
statement ok
CREATE FUNCTION trigger_func3() RETURNS TRIGGER AS $$
  BEGIN
    RETURN NULL;
  END;
$$ LANGUAGE PLpgSQL;

# TODO(#126362, #135655): Enable tests for statement-level triggers when supported.
statement error statement-level triggers are not yet supported
CREATE TRIGGER after_update_transition
AFTER UPDATE ON test_triggers
REFERENCING OLD TABLE AS old_data NEW TABLE AS new_data
FOR EACH STATEMENT
EXECUTE FUNCTION trigger_func3();

# TODO(#126362, #135655): Enable tests for statement-level triggers when supported.
# The expected results are:
# trigger_name             action_orientation  action_reference_old_table  action_reference_new_table  action_reference_old_row
# after_update_transition  STATEMENT           old_data                    new_data                    NULL
query TTTTT colnames
SELECT
    trigger_name,
    action_orientation,
    action_reference_old_table,
    action_reference_new_table,
    action_reference_old_row
FROM information_schema.triggers
WHERE trigger_name = 'after_update_transition';
----
trigger_name  action_orientation  action_reference_old_table  action_reference_new_table  action_reference_old_row

# TODO(#126362, #135655): Populate tgoldtable and tgnewtable.
# The expected results are:
# tgname                   tgoldtable  tgnewtable
# after_update_transition  old_data    new_data
query TTT colnames
SELECT tgname, tgoldtable, tgnewtable
FROM pg_catalog.pg_trigger
WHERE tgname = 'after_update_transition';
----
tgname  tgoldtable  tgnewtable

# Test multiple event types (create a trigger for multiple events).
statement ok
CREATE TRIGGER multi_event_trigger
BEFORE INSERT OR UPDATE OR DELETE ON test_triggers
FOR EACH ROW
EXECUTE FUNCTION trigger_func1();

# Each event should appear as a separate row.
query TTT colnames
SELECT
    trigger_name,
    event_manipulation,
    action_timing
FROM information_schema.triggers
WHERE trigger_name = 'multi_event_trigger'
ORDER BY event_manipulation;
----
trigger_name         event_manipulation  action_timing
multi_event_trigger  DELETE              BEFORE
multi_event_trigger  INSERT              BEFORE
multi_event_trigger  UPDATE              BEFORE

# Create a schema and add a trigger there.
statement ok
CREATE SCHEMA other_schema;

statement ok
CREATE TABLE other_schema.test_table (id INT PRIMARY KEY, data TEXT);

statement ok
CREATE TRIGGER other_schema_trigger
AFTER INSERT ON other_schema.test_table
FOR EACH ROW
EXECUTE FUNCTION trigger_func1();

query TI colnames
SELECT
    trigger_schema,
    count(*) AS trigger_count
FROM information_schema.triggers
WHERE trigger_catalog = 'test'
GROUP BY trigger_schema
ORDER BY trigger_schema;
----
trigger_schema  trigger_count
other_schema    1
public          6

# Create a trigger with arguments to test tgnargs and tgargs.
statement ok
CREATE TRIGGER trigger_with_args
AFTER INSERT ON test_triggers
FOR EACH ROW
EXECUTE FUNCTION trigger_func1('arg1', 'arg2', 'test value with spaces');

# Test pg_catalog.pg_trigger.
query TIBITTT colnames
SELECT
    tgname,
    tgtype,
    tgfoid > 0 AS has_func_oid,
    tgnargs,
    tgenabled,
    tgoldtable,
    tgnewtable
FROM pg_catalog.pg_trigger
WHERE tgrelid = 'test_triggers'::regclass
ORDER BY tgname;
----
tgname              tgtype  has_func_oid  tgnargs  tgenabled  tgoldtable  tgnewtable
after_delete_row    9       true          0        A          NULL        NULL
after_insert_row    5       true          0        A          NULL        NULL
before_update_row   19      true          0        A          NULL        NULL
multi_event_trigger 31      true          0        A          NULL        NULL
trigger_with_args   5       true          3        A          NULL        NULL

# Test INSTEAD OF triggers (not yet implemented)
statement error pgcode 42809 "test_triggers" is a table\nDETAIL: Tables cannot have INSTEAD OF triggers.
CREATE TRIGGER instead_of_trigger INSTEAD OF INSERT ON test_triggers
FOR EACH ROW EXECUTE FUNCTION trigger_func1();

statement error pgcode 42809 "test_triggers" is a table\nDETAIL: Tables cannot have INSTEAD OF triggers.
CREATE TRIGGER instead_of_update_trigger INSTEAD OF UPDATE ON test_triggers
FOR EACH ROW EXECUTE FUNCTION trigger_func1();

statement error pgcode 42809 "test_triggers" is a table\nDETAIL: Tables cannot have INSTEAD OF triggers.
CREATE TRIGGER instead_of_delete_trigger INSTEAD OF DELETE ON test_triggers
FOR EACH ROW EXECUTE FUNCTION trigger_func1();

# Test TRUNCATE triggers (not yet implemented)
statement error statement-level triggers are not yet supported
CREATE TRIGGER truncate_trigger AFTER TRUNCATE ON test_triggers
FOR EACH STATEMENT EXECUTE FUNCTION trigger_func1();

statement error statement-level triggers are not yet supported
CREATE TRIGGER before_truncate_trigger BEFORE TRUNCATE ON test_triggers
FOR EACH STATEMENT EXECUTE FUNCTION trigger_func1();

# Test tgtype bitmap calculation
# Bit 0: FOR EACH ROW (1) or FOR EACH STATEMENT (0)
# Bit 1: BEFORE (2) or AFTER (0)
# Bits 2-4: INSERT (4), DELETE (8), UPDATE (16)
# TODO(#126363, #135657): Add tests for INSTEAD OF and TRUNCATE triggers here when supported.
query TBBBBBBB colnames
SELECT
    tgname,
    (tgtype::INT & 1) > 0 AS is_row_level,
    (tgtype::INT & 2) > 0 AS is_before,
    (tgtype::INT & 4) > 0 AS has_insert,
    (tgtype::INT & 8) > 0 AS has_delete,
    (tgtype::INT & 16) > 0 AS has_update,
    (tgtype::INT & 32) > 0 AS has_instead,
    (tgtype::INT & 64) > 0 AS has_truncate
FROM pg_catalog.pg_trigger
WHERE tgrelid = 'test_triggers'::regclass
ORDER BY tgname;
----
tgname               is_row_level  is_before  has_insert  has_delete  has_update  has_instead  has_truncate
after_delete_row     true          false      false       true        false       false        false
after_insert_row     true          false      true        false       false       false        false
before_update_row    true          true       false       false       true        false        false
multi_event_trigger  true          true       true        true        true        false        false
trigger_with_args    true          false      true        false       false       false        false

# Check trigger arguments and column attributes.
# TODO(#135656): Populate the tgattr column.
query TITT colnames
SELECT
    tgname,
    tgnargs,
    encode(tgargs, 'escape') AS tgargs,
    tgattr
FROM pg_catalog.pg_trigger
WHERE tgrelid = 'test_triggers'::regclass
ORDER BY tgname;
----
tgname               tgnargs  tgargs                                      tgattr
after_delete_row     0        ·                                           ·
after_insert_row     0        ·                                           ·
before_update_row    0        ·                                           ·
multi_event_trigger  0        ·                                           ·
trigger_with_args    3        arg1\000arg2\000test value with spaces\000  ·

# Test trigger with WHEN condition.
query TTT colnames
SELECT
    tgname,
    tgqual,
    tgattr
FROM pg_catalog.pg_trigger
WHERE tgrelid = 'test_triggers'::regclass AND tgqual IS NOT NULL;
----
tgname             tgqual               tgattr
before_update_row  ((new).value > 100)  ·

# Test cross-schema trigger.
query TTT colnames
SELECT
    tgname,
    tgrelid::regclass::text AS table_name,
    tgfoid::regproc::text AS trigger_func_name
FROM pg_catalog.pg_trigger
WHERE tgrelid = 'other_schema.test_table'::regclass;
----
tgname                table_name  trigger_func_name
other_schema_trigger  test_table  trigger_func1

# Clean up
statement ok
DROP TABLE test_triggers CASCADE;

statement ok
DROP TABLE other_schema.test_table CASCADE;

statement ok
DROP SCHEMA other_schema;

statement ok
DROP TABLE audit_log CASCADE;

statement ok
DROP FUNCTION trigger_func1, trigger_func2, trigger_func3;

subtest end

# ==============================================================================
# Test ALTER TABLE ENABLE/DISABLE TRIGGER syntax.
# ==============================================================================

subtest enable_disable_trigger

skipif config local-mixed-25.4 local-mixed-26.1
statement ok
CREATE TABLE enable_disable_t (a INT PRIMARY KEY, b INT);

# Create an audit table to track trigger executions.
skipif config local-mixed-25.4 local-mixed-26.1
statement ok
CREATE TABLE trigger_audit (
  id SERIAL PRIMARY KEY,
  trigger_name TEXT,
  op TEXT,
  old_a INT,
  new_a INT
);

# Create a trigger function that records its execution in the audit table.
skipif config local-mixed-25.4 local-mixed-26.1
statement ok
CREATE FUNCTION audit_trigger_func()
RETURNS TRIGGER AS $$
BEGIN
  IF TG_OP = 'INSERT' THEN
    INSERT INTO trigger_audit (trigger_name, op, new_a) VALUES (TG_NAME, TG_OP, (NEW).a);
    RETURN NEW;
  ELSIF TG_OP = 'UPDATE' THEN
    INSERT INTO trigger_audit (trigger_name, op, old_a, new_a) VALUES (TG_NAME, TG_OP, (OLD).a, (NEW).a);
    RETURN NEW;
  ELSIF TG_OP = 'DELETE' THEN
    INSERT INTO trigger_audit (trigger_name, op, old_a) VALUES (TG_NAME, TG_OP, (OLD).a);
    RETURN OLD;
  END IF;
  RETURN NULL;
END;
$$ LANGUAGE plpgsql;

skipif config local-mixed-25.4 local-mixed-26.1
statement ok
CREATE TRIGGER insert_trigger
  AFTER INSERT ON enable_disable_t
  FOR EACH ROW
  EXECUTE FUNCTION audit_trigger_func();

# Verify trigger is enabled by default (tgenabled = 'A' for always).
skipif config local-mixed-25.4 local-mixed-26.1
query T
SELECT tgenabled FROM pg_trigger WHERE tgname = 'insert_trigger';
----
A

# SHOW TRIGGERS should also report enabled = true.
skipif config local-mixed-25.4 local-mixed-26.1
query TB
SHOW TRIGGERS FROM enable_disable_t;
----
insert_trigger  true

# Insert a row - trigger should fire and record in audit table.
skipif config local-mixed-25.4 local-mixed-26.1
statement ok
INSERT INTO enable_disable_t VALUES (1, 100);

skipif config local-mixed-25.4 local-mixed-26.1
query TTI
SELECT trigger_name, op, new_a FROM trigger_audit ORDER BY id;
----
insert_trigger  INSERT  1

# Disable the trigger.
skipif config local-mixed-25.4 local-mixed-26.1
statement ok
ALTER TABLE enable_disable_t DISABLE TRIGGER insert_trigger;

skipif config local-mixed-25.4 local-mixed-26.1
query T
SELECT tgenabled FROM pg_trigger WHERE tgname = 'insert_trigger';
----
D

# SHOW TRIGGERS should report enabled = false.
skipif config local-mixed-25.4 local-mixed-26.1
query TB
SHOW TRIGGERS FROM enable_disable_t;
----
insert_trigger  false

# Insert another row - trigger should NOT fire since it's disabled.
skipif config local-mixed-25.4 local-mixed-26.1
statement ok
INSERT INTO enable_disable_t VALUES (2, 200);

# Audit table should still have only the first entry.
skipif config local-mixed-25.4 local-mixed-26.1
query TTI
SELECT trigger_name, op, new_a FROM trigger_audit ORDER BY id;
----
insert_trigger  INSERT  1

# Re-enable the trigger.
skipif config local-mixed-25.4 local-mixed-26.1
statement ok
ALTER TABLE enable_disable_t ENABLE TRIGGER insert_trigger;

skipif config local-mixed-25.4 local-mixed-26.1
query T
SELECT tgenabled FROM pg_trigger WHERE tgname = 'insert_trigger';
----
A

# Insert another row - trigger should fire again.
skipif config local-mixed-25.4 local-mixed-26.1
statement ok
INSERT INTO enable_disable_t VALUES (3, 300);

skipif config local-mixed-25.4 local-mixed-26.1
query TTI
SELECT trigger_name, op, new_a FROM trigger_audit ORDER BY id;
----
insert_trigger  INSERT  1
insert_trigger  INSERT  3

# Test that disabling an already disabled trigger is a no-op.
skipif config local-mixed-25.4 local-mixed-26.1
statement ok
ALTER TABLE enable_disable_t DISABLE TRIGGER insert_trigger;

skipif config local-mixed-25.4 local-mixed-26.1
statement ok
ALTER TABLE enable_disable_t DISABLE TRIGGER insert_trigger;

skipif config local-mixed-25.4 local-mixed-26.1
query T
SELECT tgenabled FROM pg_trigger WHERE tgname = 'insert_trigger';
----
D

# Test that enabling an already enabled trigger is a no-op.
skipif config local-mixed-25.4 local-mixed-26.1
statement ok
ALTER TABLE enable_disable_t ENABLE TRIGGER insert_trigger;

skipif config local-mixed-25.4 local-mixed-26.1
statement ok
ALTER TABLE enable_disable_t ENABLE TRIGGER insert_trigger;

skipif config local-mixed-25.4 local-mixed-26.1
query T
SELECT tgenabled FROM pg_trigger WHERE tgname = 'insert_trigger';
----
A

# Test error when trigger doesn't exist.
skipif config local-mixed-25.4 local-mixed-26.1
statement error trigger "nonexistent" for table "enable_disable_t" does not exist
ALTER TABLE enable_disable_t DISABLE TRIGGER nonexistent;

# Create a second trigger to test ALL/USER keywords.
skipif config local-mixed-25.4 local-mixed-26.1
statement ok
CREATE TRIGGER update_trigger
  AFTER UPDATE ON enable_disable_t
  FOR EACH ROW
  EXECUTE FUNCTION audit_trigger_func();

# Clear the audit table to start fresh for ALL/USER tests.
skipif config local-mixed-25.4 local-mixed-26.1
statement count 2
DELETE FROM trigger_audit;

# Both triggers should be enabled.
skipif config local-mixed-25.4 local-mixed-26.1
query TT rowsort
SELECT tgname, tgenabled FROM pg_trigger WHERE tgrelid = 'enable_disable_t'::regclass ORDER BY tgname;
----
insert_trigger  A
update_trigger  A

# Insert and update - both triggers should fire.
skipif config local-mixed-25.4 local-mixed-26.1
statement ok
INSERT INTO enable_disable_t VALUES (10, 1000);

skipif config local-mixed-25.4 local-mixed-26.1
statement ok
UPDATE enable_disable_t SET b = 1001 WHERE a = 10;

skipif config local-mixed-25.4 local-mixed-26.1
query TTI rowsort
SELECT trigger_name, op, coalesce(new_a, old_a) as a_val FROM trigger_audit ORDER BY id;
----
insert_trigger  INSERT  10
update_trigger  UPDATE  10

# Clear audit and test DISABLE TRIGGER ALL.
skipif config local-mixed-25.4 local-mixed-26.1
statement count 2
DELETE FROM trigger_audit;

skipif config local-mixed-25.4 local-mixed-26.1
statement ok
ALTER TABLE enable_disable_t DISABLE TRIGGER ALL;

skipif config local-mixed-25.4 local-mixed-26.1
query TT rowsort
SELECT tgname, tgenabled FROM pg_trigger WHERE tgrelid = 'enable_disable_t'::regclass ORDER BY tgname;
----
insert_trigger  D
update_trigger  D

# SHOW TRIGGERS should report both as disabled.
skipif config local-mixed-25.4 local-mixed-26.1
query TB rowsort
SHOW TRIGGERS FROM enable_disable_t;
----
insert_trigger  false
update_trigger  false

# Neither trigger should fire when disabled.
skipif config local-mixed-25.4 local-mixed-26.1
statement ok
INSERT INTO enable_disable_t VALUES (11, 1100);

skipif config local-mixed-25.4 local-mixed-26.1
statement ok
UPDATE enable_disable_t SET b = 1101 WHERE a = 11;

# Audit table should be empty.
skipif config local-mixed-25.4 local-mixed-26.1
query I
SELECT count(*) FROM trigger_audit;
----
0

# Test ENABLE TRIGGER ALL.
skipif config local-mixed-25.4 local-mixed-26.1
statement ok
ALTER TABLE enable_disable_t ENABLE TRIGGER ALL;

skipif config local-mixed-25.4 local-mixed-26.1
query TT rowsort
SELECT tgname, tgenabled FROM pg_trigger WHERE tgrelid = 'enable_disable_t'::regclass ORDER BY tgname;
----
insert_trigger  A
update_trigger  A

# Both triggers should fire again.
skipif config local-mixed-25.4 local-mixed-26.1
statement ok
INSERT INTO enable_disable_t VALUES (12, 1200);

skipif config local-mixed-25.4 local-mixed-26.1
statement ok
UPDATE enable_disable_t SET b = 1201 WHERE a = 12;

skipif config local-mixed-25.4 local-mixed-26.1
query TTI rowsort
SELECT trigger_name, op, coalesce(new_a, old_a) as a_val FROM trigger_audit ORDER BY id;
----
insert_trigger  INSERT  12
update_trigger  UPDATE  12

# Clear audit and test selective disable.
skipif config local-mixed-25.4 local-mixed-26.1
statement count 2
DELETE FROM trigger_audit;

# Disable only one trigger.
skipif config local-mixed-25.4 local-mixed-26.1
statement ok
ALTER TABLE enable_disable_t DISABLE TRIGGER insert_trigger;

skipif config local-mixed-25.4 local-mixed-26.1
query TT rowsort
SELECT tgname, tgenabled FROM pg_trigger WHERE tgrelid = 'enable_disable_t'::regclass ORDER BY tgname;
----
insert_trigger  D
update_trigger  A

# Insert and update - only update trigger should fire.
skipif config local-mixed-25.4 local-mixed-26.1
statement ok
INSERT INTO enable_disable_t VALUES (13, 1300);

skipif config local-mixed-25.4 local-mixed-26.1
statement ok
UPDATE enable_disable_t SET b = 1301 WHERE a = 13;

skipif config local-mixed-25.4 local-mixed-26.1
query TT
SELECT trigger_name, op FROM trigger_audit ORDER BY id;
----
update_trigger  UPDATE

# Clear audit and test DISABLE TRIGGER USER (same as ALL in CockroachDB).
skipif config local-mixed-25.4 local-mixed-26.1
statement count 1
DELETE FROM trigger_audit;

skipif config local-mixed-25.4 local-mixed-26.1
statement ok
ALTER TABLE enable_disable_t ENABLE TRIGGER insert_trigger;

skipif config local-mixed-25.4 local-mixed-26.1
statement ok
ALTER TABLE enable_disable_t DISABLE TRIGGER USER;

skipif config local-mixed-25.4 local-mixed-26.1
query TT rowsort
SELECT tgname, tgenabled FROM pg_trigger WHERE tgrelid = 'enable_disable_t'::regclass ORDER BY tgname;
----
insert_trigger  D
update_trigger  D

# Neither trigger should fire.
skipif config local-mixed-25.4 local-mixed-26.1
statement ok
INSERT INTO enable_disable_t VALUES (14, 1400);

skipif config local-mixed-25.4 local-mixed-26.1
query I
SELECT count(*) FROM trigger_audit;
----
0

# Test ENABLE TRIGGER USER (same as ALL in CockroachDB).
skipif config local-mixed-25.4 local-mixed-26.1
statement ok
ALTER TABLE enable_disable_t ENABLE TRIGGER USER;

skipif config local-mixed-25.4 local-mixed-26.1
query TT rowsort
SELECT tgname, tgenabled FROM pg_trigger WHERE tgrelid = 'enable_disable_t'::regclass ORDER BY tgname;
----
insert_trigger  A
update_trigger  A

# Test that ALL/USER on a table with no triggers is a no-op.
skipif config local-mixed-25.4 local-mixed-26.1
statement ok
CREATE TABLE enable_disable_t_empty (a INT PRIMARY KEY);

skipif config local-mixed-25.4 local-mixed-26.1
statement ok
ALTER TABLE enable_disable_t_empty DISABLE TRIGGER ALL;

skipif config local-mixed-25.4 local-mixed-26.1
statement ok
ALTER TABLE enable_disable_t_empty ENABLE TRIGGER USER;

skipif config local-mixed-25.4 local-mixed-26.1
statement ok
DROP TABLE enable_disable_t_empty;

# Test combining with other ALTER TABLE commands.
skipif config local-mixed-25.4 local-mixed-26.1
statement ok
ALTER TABLE enable_disable_t DISABLE TRIGGER insert_trigger, DISABLE TRIGGER update_trigger;

skipif config local-mixed-25.4 local-mixed-26.1
query TT rowsort
SELECT tgname, tgenabled FROM pg_trigger WHERE tgrelid = 'enable_disable_t'::regclass ORDER BY tgname;
----
insert_trigger  D
update_trigger  D

skipif config local-mixed-25.4 local-mixed-26.1
statement ok
ALTER TABLE enable_disable_t ENABLE TRIGGER insert_trigger, ENABLE TRIGGER update_trigger;

skipif config local-mixed-25.4 local-mixed-26.1
query TT rowsort
SELECT tgname, tgenabled FROM pg_trigger WHERE tgrelid = 'enable_disable_t'::regclass ORDER BY tgname;
----
insert_trigger  A
update_trigger  A

# Test with IF EXISTS on table.
skipif config local-mixed-25.4 local-mixed-26.1
statement ok
ALTER TABLE IF EXISTS nonexistent_table DISABLE TRIGGER some_trigger;

# Clean up.
skipif config local-mixed-25.4 local-mixed-26.1
statement ok
DROP TABLE enable_disable_t;

skipif config local-mixed-25.4 local-mixed-26.1
statement ok
DROP TABLE trigger_audit;

skipif config local-mixed-25.4 local-mixed-26.1
statement ok
DROP FUNCTION audit_trigger_func;

subtest end

# ==============================================================================
# Regression tests.
# ==============================================================================

# Test that CREATE and DROP TRIGGER work when sent in a statement batch.

subtest create_drop_in_batch_statement

statement ok
CREATE TABLE tab_141810 (
  id  INT PRIMARY KEY,
  a   INT,
  b   INT
);
CREATE OR REPLACE FUNCTION func_141810() RETURNS TRIGGER LANGUAGE PLpgSQL AS $$
  BEGIN
    IF TG_OP = 'INSERT' THEN
      NEW.a := 1;
    END IF;
    NEW.b := 2;
    RETURN NEW;
  END;
$$;
CREATE TRIGGER trg_141810
  BEFORE INSERT OR UPDATE ON tab_141810
  FOR EACH ROW
  EXECUTE FUNCTION func_141810();
INSERT INTO tab_141810 (id) VALUES (1);
DROP TRIGGER trg_141810 ON tab_141810;
INSERT INTO tab_141810 (id) VALUES (2);

query III
SELECT id, a, b FROM tab_141810 ORDER BY id
----
1  1     2
2  NULL  NULL

# Test that CREATE and DROP TRIGGER work in a prepared statement.

subtest create_drop_prepared

statement ok
PREPARE foo AS CREATE TRIGGER trg_141810 BEFORE INSERT ON tab_141810 FOR EACH ROW EXECUTE FUNCTION func_141810();

statement ok
EXECUTE foo;

statement ok
INSERT INTO tab_141810 VALUES (3);

statement ok
PREPARE bar AS DROP TRIGGER trg_141810 ON tab_141810;

statement ok
EXECUTE bar;

statement ok
INSERT INTO tab_141810 VALUES (4);

query III
SELECT id, a, b FROM tab_141810 ORDER BY id
----
1  1     2
2  NULL  NULL
3  1     2
4  NULL  NULL

# Test case sensitivity of column names in triggers.
subtest case_sensitivity

# Setup: clean up any existing tables and functions
statement ok
DROP TABLE IF EXISTS t1, t2, t3;

statement ok
DROP TRIGGER IF EXISTS tr1 ON t1;
DROP TRIGGER IF EXISTS tr2 ON t1;
DROP TRIGGER IF EXISTS tr3 ON t1;
-- tr4 failed to create, so no need to drop

statement ok
DROP TRIGGER IF EXISTS tr5 ON t2;
DROP TRIGGER IF EXISTS tr6 ON t2;
DROP TRIGGER IF EXISTS tr7 ON t2;
-- tr8 failed to create, so no need to drop

statement ok
DROP TRIGGER IF EXISTS tr12 ON t3;
-- tr9, tr10, tr11 failed to create, so no need to drop

# Setup: Create tables with different casing
statement ok
CREATE TABLE t1 (foo_bar INT);
CREATE TABLE t2 ("foo_bar" INT);
CREATE TABLE t3 ("FOO_BAR" INT);

# Trigger functions with different quoting/casing styles
statement ok
CREATE FUNCTION f1() RETURNS TRIGGER LANGUAGE PLpgSQL AS $$
  BEGIN
    NEW.foo_bar := 1;
    RETURN NEW;
  END;
$$;

statement ok
CREATE FUNCTION f2() RETURNS TRIGGER LANGUAGE PLpgSQL AS $$
  BEGIN
    NEW.FOO_BAR := 1;
    RETURN NEW;
  END;
$$;

statement ok
CREATE FUNCTION f3() RETURNS TRIGGER LANGUAGE PLpgSQL AS $$
  BEGIN
    NEW."foo_bar" := 1;
    RETURN NEW;
  END;
$$;

statement ok
CREATE FUNCTION f4() RETURNS TRIGGER LANGUAGE PLpgSQL AS $$
  BEGIN
    NEW."FOO_BAR" := 1;
    RETURN NEW;
  END;
$$;

# Attach each function to each table and check success/failure

# Unquoted table
statement ok
CREATE TRIGGER tr1 BEFORE INSERT ON t1 FOR EACH ROW EXECUTE FUNCTION f1();

statement ok
CREATE TRIGGER tr2 BEFORE INSERT ON t1 FOR EACH ROW EXECUTE FUNCTION f2();

statement ok
CREATE TRIGGER tr3 BEFORE INSERT ON t1 FOR EACH ROW EXECUTE FUNCTION f3();

statement error pgcode 42703 pq: record "new" has no field "FOO_BAR"
CREATE TRIGGER tr4 BEFORE INSERT ON t1 FOR EACH ROW EXECUTE FUNCTION f4();

# Quoted lowercase column
statement ok
CREATE TRIGGER tr5 BEFORE INSERT ON t2 FOR EACH ROW EXECUTE FUNCTION f1();

statement ok
CREATE TRIGGER tr6 BEFORE INSERT ON t2 FOR EACH ROW EXECUTE FUNCTION f2();

statement ok
CREATE TRIGGER tr7 BEFORE INSERT ON t2 FOR EACH ROW EXECUTE FUNCTION f3();

statement error pgcode 42703 pq: record "new" has no field "FOO_BAR"
CREATE TRIGGER tr8 BEFORE INSERT ON t2 FOR EACH ROW EXECUTE FUNCTION f4();

# Quoted uppercase column
statement error pgcode 42703 pq: record "new" has no field "foo_bar"
CREATE TRIGGER tr9 BEFORE INSERT ON t3 FOR EACH ROW EXECUTE FUNCTION f1();

statement error pgcode 42703 pq: record "new" has no field "foo_bar"
CREATE TRIGGER tr10 BEFORE INSERT ON t3 FOR EACH ROW EXECUTE FUNCTION f2();

statement error pgcode 42703 pq: record "new" has no field "foo_bar"
CREATE TRIGGER tr11 BEFORE INSERT ON t3 FOR EACH ROW EXECUTE FUNCTION f3();

statement ok
CREATE TRIGGER tr12 BEFORE INSERT ON t3 FOR EACH ROW EXECUTE FUNCTION f4();

# Drop all tables
statement ok
DROP TABLE t1;
DROP TABLE t2;
DROP TABLE t3;

# Drop all functions
statement ok
DROP FUNCTION f1();
DROP FUNCTION f2();
DROP FUNCTION f3();
DROP FUNCTION f4();

subtest end

# Regression test for #135311: TG_ARGV should be 0-indexed like PostgreSQL.
subtest regression_135311

statement ok
DROP FUNCTION IF EXISTS g;

statement ok
CREATE FUNCTION g() RETURNS TRIGGER LANGUAGE PLpgSQL AS $$
  BEGIN
    RAISE NOTICE 'g()';
    RAISE NOTICE 'TG_ARGV[0]: %', TG_ARGV[0];
    RAISE NOTICE 'TG_ARGV[1]: %', TG_ARGV[1];
    RETURN NEW;
  END
$$;

statement ok
CREATE TRIGGER foo BEFORE INSERT ON xy FOR EACH ROW EXECUTE FUNCTION g('first', 'second');

query T noticetrace
INSERT INTO xy VALUES (1, 2);
----
NOTICE: g()
NOTICE: TG_ARGV[0]: first
NOTICE: TG_ARGV[1]: second

statement ok
DROP TRIGGER foo ON xy;

statement ok
DROP FUNCTION g;

# Test assigning TG_ARGV to a TEXT[] variable, then doing a zero-indexed read.
# Note: This matches Postgres behavior, and keeps the array as zero-indexed.
statement ok
CREATE FUNCTION g() RETURNS TRIGGER LANGUAGE PLpgSQL AS $$
  DECLARE
    args TEXT[];
  BEGIN
    args := TG_ARGV;
    RAISE NOTICE 'args[0]: %', args[0];
    RAISE NOTICE 'args[1]: %', args[1];
    RETURN NEW;
  END
$$;

statement ok
CREATE TRIGGER foo BEFORE INSERT ON xy FOR EACH ROW EXECUTE FUNCTION g('arg_one', 'arg_two');

query T noticetrace
INSERT INTO xy VALUES (100, 200);
----
NOTICE: args[0]: arg_one
NOTICE: args[1]: arg_two

statement ok
DROP TRIGGER foo ON xy;

statement ok
DROP FUNCTION g;

# Test a helper function that takes a TEXT[] argument and does a zero-indexed
# read on it.
# Note: In PostgreSQL, when TG_ARGV is passed to a function, it retains its
# zero-indexed behavior.
statement ok
CREATE FUNCTION read_args(arr TEXT[]) RETURNS TEXT LANGUAGE PLpgSQL AS $$
  BEGIN
    RETURN 'arr[0]=' || COALESCE(arr[0], 'NULL') || ', arr[1]=' || COALESCE(arr[1], 'NULL');
  END
$$;

statement ok
CREATE FUNCTION g() RETURNS TRIGGER LANGUAGE PLpgSQL AS $$
  BEGIN
    RAISE NOTICE 'direct TG_ARGV[0]: %', TG_ARGV[0];
    RAISE NOTICE 'via helper: %', read_args(TG_ARGV);
    RETURN NEW;
  END
$$;

statement ok
CREATE TRIGGER foo BEFORE INSERT ON xy FOR EACH ROW EXECUTE FUNCTION g('helper_one', 'helper_two');

query T noticetrace
INSERT INTO xy VALUES (102, 202);
----
NOTICE: direct TG_ARGV[0]: helper_one
NOTICE: via helper: arr[0]=helper_one, arr[1]=helper_two

statement ok
DROP TRIGGER foo ON xy;

statement ok
DROP FUNCTION g;

statement ok
DROP FUNCTION read_args;

subtest end

subtest regression_146889

statement ok
CREATE TABLE parent146889 (k INT PRIMARY KEY)

statement ok
CREATE TABLE child146889 (ref INT REFERENCES parent146889(k) ON DELETE CASCADE)

statement ok
INSERT INTO parent146889 VALUES (1);
INSERT INTO child146889 VALUES (1);

statement ok
CREATE FUNCTION f146889() RETURNS TRIGGER LANGUAGE PLpgSQL AS $$
  BEGIN
    RAISE NOTICE '%', (SELECT count(*) FROM parent146889);
    RETURN NULL;
  END
$$;

statement ok
CREATE TRIGGER t AFTER DELETE ON parent146889 FOR EACH ROW EXECUTE FUNCTION f146889();

query T noticetrace
DELETE FROM parent146889 WHERE k = 1;
----
NOTICE: 0

subtest end

subtest dependency_142370

statement ok
create table t1(n int primary key, j int, k int);

statement ok
create index i1 on t1(k ASC);

statement ok
create index i2 on t1(k DESC);

statement ok
create table other(n int primary key, j int, k int);

statement ok
create index i1 on other(k ASC);

statement ok
create index i2 on other(k DESC);

statement ok
CREATE FUNCTION f1 ()
RETURNS VOID
LANGUAGE SQL
AS $$
  SELECT 1
$$;

statement ok
CREATE TYPE e AS ENUM('a');

statement ok
CREATE OR REPLACE FUNCTION audit_changes()
                                RETURNS TRIGGER AS $$
                                BEGIN
                                 SELECT f1();
                                 SELECT *, 'a'::e FROM t1@i1 WHERE j=32;
                                 SELECT *, 'a'::e FROM t1@i2 WHERE j=32;
                                 SELECT *, 'a'::e FROM other@i1 WHERE j=32;
                                 SELECT *, 'a'::e FROM other@i2 WHERE j=32;
                                 RETURN NULL;
                                END;
                                $$ LANGUAGE PLpgSQL;

statement ok
CREATE TRIGGER audit_trigger AFTER INSERT OR UPDATE OR DELETE ON t1 FOR EACH ROW EXECUTE FUNCTION audit_changes();

statement error pq: cannot drop column "j" because trigger "audit_trigger" on table "t1" depends on it
alter table t1 drop column j;

statement error pq: cannot drop column "j" because trigger "audit_trigger" on table "t1" depends on it
alter table other drop column j;

statement error pq: cannot alter type of column "j" because trigger "audit_trigger" on table "t1" depends on it
alter table t1 alter column j set data type text;

statement error pq: cannot alter type of column "j" because trigger "audit_trigger" on table "t1" depends on it
alter table other alter column j set data type text;

statement error pq: cannot drop index "i1" because trigger "audit_trigger" on table "t1" depends on it
drop index t1@i1;

statement error pq: cannot drop index "i1" because trigger "audit_trigger" on table "t1" depends on it
drop index other@i1;

statement error pq: cannot drop function "f1" because other objects \(\[test.public.t1\]\) still depend on it
DROP FUNCTION f1;

statement error pq: unimplemented: drop function cascade not supported
DROP FUNCTION f1 CASCADE;

statement error pq: cannot drop type "e" because other objects \(\[test.public.t1\]\) still depend on it
DROP TYPE e;

statement error pq: unimplemented: DROP TYPE CASCADE is not yet supported
DROP TYPE e CASCADE;

statement error pq: cannot drop table other because other objects depend on it
DROP TABLE other;

# Verify the trigger still works
statement ok
INSERT INTO t1 VALUES (0,0,0);

# This test doesn't run with the legacy schema config because CREATE/DROP
# trigger isn't implemented there. We enable legacy to run DDL to verify
# the dependencies.
let $use_decl_sc
SHOW use_declarative_schema_changer

statement ok
set use_declarative_schema_changer = 'off';

# Disable schema locking to ensure that errors from it do not interfere
# with dependency checking.
statement ok
ALTER TABLE t1 SET (schema_locked = false);

statement ok
ALTER TABLE other SET (schema_locked = false);

statement error pq: cannot alter type of column "j" because trigger "audit_trigger" on table "t1" depends on it
alter table t1 alter column j set data type text;

statement error pq: cannot alter type of column "j" because trigger "audit_trigger" on table "t1" depends on it
alter table other alter column j set data type text;

statement error pq: cannot rename column "j" because trigger "audit_trigger" on table "t1" depends on it
alter table t1 rename column j to j2;

statement error pq: cannot rename column "j" because trigger "audit_trigger" on table "t1" depends on it
alter table other rename column j to j2;

statement error pq: cannot drop column "j" because trigger "audit_trigger" on table "t1" depends on it
alter table t1 drop column j;

statement error pq: cannot drop column "j" because trigger "audit_trigger" on table "t1" depends on it
alter table other drop column j;

statement error pq: cannot drop index "i1" because trigger "audit_trigger" on table "t1" depends on it
drop index t1@i1;

statement error pq: cannot drop index "i1" because trigger "audit_trigger" on table "t1" depends on it
drop index other@i1;

statement error pq: cannot drop function "f1" because other objects \(\[test.public.t1\]\) still depend on it
DROP FUNCTION f1;

statement error pq: unimplemented: drop function cascade not supported
DROP FUNCTION f1 CASCADE;

statement error pq: cannot drop type "e" because other objects \(\[test.public.t1\]\) still depend on it
DROP TYPE e;

statement error pq: unimplemented: DROP TYPE CASCADE is not yet supported
DROP TYPE e CASCADE;

statement error pq: cannot drop relation "other" because trigger "audit_trigger" on table "t1" depends on it
DROP TABLE other;

statement ok
set use_declarative_schema_changer = $use_decl_sc;

# Verify the trigger still works after all the failed operations above.
statement ok
INSERT INTO t1(n,k) VALUES (1,1);

# DROP TABLE CASCADE on a referenced table should drop the dependent trigger.
statement ok
DROP TABLE other CASCADE;

# Table t1 still exists but the trigger was dropped.
statement error pq: trigger "audit_trigger" for table "t1" does not exist
DROP TRIGGER audit_trigger ON t1;

# Verify t1 still works.
statement ok
SELECT * FROM t1;

statement ok
DROP TABLE t1;
DROP TYPE e;
DROP FUNCTION f1;
DROP FUNCTION audit_changes;

# Test DROP COLUMN CASCADE on a referenced table with trigger dependencies.
statement ok
CREATE TABLE t_col(n INT PRIMARY KEY, j INT, k INT);

statement ok
CREATE TABLE t_col_other(n INT PRIMARY KEY, j INT);

statement ok
CREATE FUNCTION trigger_col() RETURNS TRIGGER AS $$
BEGIN
  SELECT * FROM t_col_other WHERE j=1;
  RETURN NULL;
END;
$$ LANGUAGE PLpgSQL;

statement ok
CREATE TRIGGER trg_col AFTER INSERT ON t_col FOR EACH ROW EXECUTE FUNCTION trigger_col();

# Without CASCADE, dropping the column should be blocked.
statement error pq: cannot drop column "j" because trigger "trg_col" on table "t_col" depends on it
ALTER TABLE t_col_other DROP COLUMN j;

# With CASCADE, the column and trigger should be dropped.
statement ok
ALTER TABLE t_col_other DROP COLUMN j CASCADE;

# The trigger was dropped.
query TB colnames
SHOW TRIGGERS FROM t_col;
----
trigger_name  enabled

statement error pq: trigger "trg_col" for table "t_col" does not exist
DROP TRIGGER trg_col ON t_col;

# DML still works.
statement ok
INSERT INTO t_col VALUES (1, 1, 1);

statement ok
DROP TABLE t_col;
DROP TABLE t_col_other;
DROP FUNCTION trigger_col;

# Test DROP INDEX CASCADE with trigger dependencies.
statement ok
CREATE TABLE t_idx(n INT PRIMARY KEY, k INT);

statement ok
CREATE INDEX idx1 ON t_idx(k ASC);

statement ok
CREATE FUNCTION trigger_idx() RETURNS TRIGGER AS $$
BEGIN
  SELECT * FROM t_idx@idx1 WHERE k=1;
  RETURN NULL;
END;
$$ LANGUAGE PLpgSQL;

statement ok
CREATE TRIGGER trg_idx AFTER INSERT ON t_idx FOR EACH ROW EXECUTE FUNCTION trigger_idx();

# Without CASCADE, dropping the index should be blocked.
statement error pq: cannot drop index "idx1" because trigger "trg_idx" on table "t_idx" depends on it
DROP INDEX t_idx@idx1;

# With CASCADE, the index and trigger should be dropped.
statement ok
DROP INDEX t_idx@idx1 CASCADE;

# The trigger was dropped.
query TB colnames
SHOW TRIGGERS FROM t_idx;
----
trigger_name  enabled

statement error pq: trigger "trg_idx" for table "t_idx" does not exist
DROP TRIGGER trg_idx ON t_idx;

# DML still works.
statement ok
INSERT INTO t_idx VALUES (1, 1);

statement ok
DROP TABLE t_idx;
DROP FUNCTION trigger_idx;

# Test DROP COLUMN CASCADE on the trigger's own table (the exact scenario
# from issue #142370).
statement ok
CREATE TABLE t1(n INT PRIMARY KEY, j INT);

statement ok
CREATE OR REPLACE FUNCTION audit_changes()
RETURNS TRIGGER AS $$
BEGIN
  SELECT * FROM t1 WHERE j=32;
  RETURN NULL;
END;
$$ LANGUAGE PLpgSQL;

statement ok
CREATE TRIGGER audit_trigger AFTER INSERT OR UPDATE OR DELETE ON t1 FOR EACH ROW EXECUTE FUNCTION audit_changes();

# Without CASCADE, dropping the column should be blocked.
statement error pq: cannot drop column "j" because trigger "audit_trigger" on table "t1" depends on it
ALTER TABLE t1 DROP COLUMN j;

# With CASCADE, the column and trigger should be dropped.
statement ok
ALTER TABLE t1 DROP COLUMN j CASCADE;

# The trigger was dropped.
query TB colnames
SHOW TRIGGERS FROM t1;
----
trigger_name  enabled

statement error pq: trigger "audit_trigger" for table "t1" does not exist
DROP TRIGGER audit_trigger ON t1;

# Inserts work after the column and trigger are dropped.
statement ok
INSERT INTO t1 VALUES (32);

statement ok
DROP TABLE t1;
DROP FUNCTION audit_changes;

# Test CASCADE with the legacy schema changer. Triggers are created with the
# declarative schema changer, then DDL CASCADE is run with legacy.

# Test DROP COLUMN CASCADE on a referenced table (legacy).
statement ok
CREATE TABLE t_lcol(n INT PRIMARY KEY, j INT, k INT);
CREATE TABLE t_lcol_other(n INT PRIMARY KEY, j INT);

statement ok
CREATE FUNCTION trigger_lcol() RETURNS TRIGGER AS $$
BEGIN
  SELECT * FROM t_lcol_other WHERE j=1;
  RETURN NULL;
END;
$$ LANGUAGE PLpgSQL;

statement ok
CREATE TRIGGER trg_lcol AFTER INSERT ON t_lcol FOR EACH ROW EXECUTE FUNCTION trigger_lcol();

statement ok
SET use_declarative_schema_changer = 'off';

statement ok
ALTER TABLE t_lcol_other SET (schema_locked = false);

statement ok
ALTER TABLE t_lcol_other DROP COLUMN j CASCADE;

statement ok
SET use_declarative_schema_changer = 'on';

# The trigger was dropped.
query TB colnames
SHOW TRIGGERS FROM t_lcol;
----
trigger_name  enabled

statement error pq: trigger "trg_lcol" for table "t_lcol" does not exist
DROP TRIGGER trg_lcol ON t_lcol;

statement ok
INSERT INTO t_lcol VALUES (1, 1, 1);

statement ok
DROP TABLE t_lcol;
DROP TABLE t_lcol_other;
DROP FUNCTION trigger_lcol;

# Test DROP INDEX CASCADE (legacy).
statement ok
CREATE TABLE t_lidx(n INT PRIMARY KEY, k INT);
CREATE INDEX lidx1 ON t_lidx(k ASC);

statement ok
CREATE FUNCTION trigger_lidx() RETURNS TRIGGER AS $$
BEGIN
  SELECT * FROM t_lidx@lidx1 WHERE k=1;
  RETURN NULL;
END;
$$ LANGUAGE PLpgSQL;

statement ok
CREATE TRIGGER trg_lidx AFTER INSERT ON t_lidx FOR EACH ROW EXECUTE FUNCTION trigger_lidx();

statement ok
SET use_declarative_schema_changer = 'off';

statement ok
ALTER TABLE t_lidx SET (schema_locked = false);

statement ok
DROP INDEX t_lidx@lidx1 CASCADE;

statement ok
SET use_declarative_schema_changer = 'on';

# The trigger was dropped.
query TB colnames
SHOW TRIGGERS FROM t_lidx;
----
trigger_name  enabled

statement error pq: trigger "trg_lidx" for table "t_lidx" does not exist
DROP TRIGGER trg_lidx ON t_lidx;

statement ok
INSERT INTO t_lidx VALUES (1, 1);

statement ok
DROP TABLE t_lidx;
DROP FUNCTION trigger_lidx;

# Test DROP COLUMN CASCADE on the trigger's own table (legacy, #142370).
statement ok
CREATE TABLE t1(n INT PRIMARY KEY, j INT);

statement ok
CREATE OR REPLACE FUNCTION audit_changes()
RETURNS TRIGGER AS $$
BEGIN
  SELECT * FROM t1 WHERE j=32;
  RETURN NULL;
END;
$$ LANGUAGE PLpgSQL;

statement ok
CREATE TRIGGER audit_trigger AFTER INSERT OR UPDATE OR DELETE ON t1 FOR EACH ROW EXECUTE FUNCTION audit_changes();

statement ok
SET use_declarative_schema_changer = 'off';

statement ok
ALTER TABLE t1 SET (schema_locked = false);

# Without CASCADE, dropping the column should be blocked.
statement error pq: cannot drop column "j" because trigger "audit_trigger" on table "t1" depends on it
ALTER TABLE t1 DROP COLUMN j;

# With CASCADE, the column and trigger should be dropped.
statement ok
ALTER TABLE t1 DROP COLUMN j CASCADE;

statement ok
SET use_declarative_schema_changer = 'on';

# The trigger was dropped.
query TB colnames
SHOW TRIGGERS FROM t1;
----
trigger_name  enabled

statement error pq: trigger "audit_trigger" for table "t1" does not exist
DROP TRIGGER audit_trigger ON t1;

statement ok
INSERT INTO t1 VALUES (32);

statement ok
DROP TABLE t1;
DROP FUNCTION audit_changes;

subtest end

subtest self_ref_and_fk

statement ok
CREATE SCHEMA sc1;

statement ok
CREATE TABLE sc1.tab1 (
    col1 INT,
    PRIMARY KEY (col1)
);

# Self-referencing FK
statement ok
ALTER TABLE sc1.tab1
ADD CONSTRAINT fk_self FOREIGN KEY (col1)
REFERENCES sc1.tab1 (col1)
ON DELETE CASCADE;

# Trigger function that selects from same table
statement ok
CREATE FUNCTION tf1() RETURNS TRIGGER AS $$
BEGIN
  SELECT 1 FROM sc1.tab1;
  RETURN NULL;
END;
$$ LANGUAGE PLpgSQL;

# Create the trigger that adds a forward and backward reference on sc1.tab1.
statement ok
CREATE TRIGGER tr1
BEFORE INSERT OR UPDATE ON sc1.tab1
FOR EACH ROW EXECUTE FUNCTION tf1();

# Drop the trigger. Prior to #147981, this used to leave the backref to sc1.tab1
# around causing an infinite loop during DROP SCHEMA.
statement ok
DROP TRIGGER tr1 ON sc1.tab1;

# This test doesn't run with the legacy schema config because CREATE/DROP
# trigger isn't implemented there. We enable legacy to run DROP DDL to verify
# the dependencies handling. We do that in a transaction that is rolled back so
# we can retry with the DSC.
let $use_decl_sc
SHOW use_declarative_schema_changer

statement ok
set use_declarative_schema_changer = 'off';

statement ok
BEGIN;
DROP SCHEMA sc1 CASCADE;
ROLLBACK;

statement ok
set use_declarative_schema_changer = $use_decl_sc;

statement ok
DROP SCHEMA sc1 CASCADE;

subtest end

# Previously, we had a bug where we did not properly look at references
# in a trigger when cleaning up back references on sequences. See
# issue #148103
subtest trigger_shared_backrefs

statement ok
CREATE SEQUENCE sc_tr_backref;

statement ok
CREATE TABLE sc_tr_tbl ();

statement ok
CREATE FUNCTION sc_tr_backref_f1() RETURNS TRIGGER AS $$
BEGIN
  SELECT nextval('sc_tr_backref');
  RETURN NULL;
END;
$$ LANGUAGE PLpgSQL;

statement ok
CREATE TRIGGER tr1
BEFORE INSERT OR UPDATE ON sc_tr_tbl
FOR EACH ROW EXECUTE FUNCTION sc_tr_backref_f1();

statement ok
ALTER TABLE sc_tr_tbl
  ADD CONSTRAINT ck1 CHECK (nextval('sc_tr_backref') < 1000);

statement ok
ALTER TABLE sc_tr_tbl DROP CONSTRAINT ck1;

statement ok
DROP TRIGGER tr1 ON sc_tr_tbl;

subtest end

# Regression test for unnecessary column dependencies added to a routine with a
# mutation that involves a trigger.
subtest regression_158154

statement ok
CREATE TABLE xy_158154 (x INT, y INT);

statement ok
CREATE FUNCTION g() RETURNS TRIGGER LANGUAGE PLpgSQL AS $$
  BEGIN
    SELECT x, y FROM xy_158154;
    RAISE NOTICE '%: old: %, new: %', TG_OP, OLD, NEW;
    RETURN COALESCE(NEW, OLD);
  END
$$;

statement ok
CREATE TRIGGER foo BEFORE INSERT ON xy_158154 FOR EACH ROW EXECUTE FUNCTION g();

statement ok
CREATE PROCEDURE p(blah INT) LANGUAGE SQL AS $$
  INSERT INTO xy_158154 (x) VALUES (blah);
$$;

statement ok
CALL p(100)

statement error pgcode 2BP01 pq: cannot drop column "y" because trigger "foo" on table "xy_158154" depends on it
ALTER TABLE xy_158154 DROP COLUMN y;

statement ok
DROP TRIGGER foo ON xy_158154;
DROP FUNCTION g();

# The procedure should not prevent the column drop.
statement ok
ALTER TABLE xy_158154 DROP COLUMN y;

statement ok
CALL p(200)

query I rowsort
SELECT * FROM xy_158154;
----
100
200

statement ok
DROP PROCEDURE p

statement ok
DROP TABLE xy_158154

subtest end

# Regression test for dropping a trigger when a policy on the same table
# references the same sequence. Previously, the trigger's backref would
# incorrectly remain because the policy's reference was considered sufficient.
subtest regression_trigger_policy_shared_sequence_backref

statement ok
CREATE SEQUENCE seq_tr_policy;

statement ok
CREATE TABLE t_tr_policy (id INT PRIMARY KEY, data INT);

statement ok
CREATE FUNCTION trigger_fn_policy() RETURNS TRIGGER AS $$
BEGIN
  SELECT nextval('seq_tr_policy');
  RETURN NEW;
END;
$$ LANGUAGE PLpgSQL;

statement ok
CREATE TRIGGER my_trigger AFTER INSERT ON t_tr_policy
FOR EACH ROW EXECUTE FUNCTION trigger_fn_policy();

statement ok
ALTER TABLE t_tr_policy ENABLE ROW LEVEL SECURITY;

statement ok
CREATE POLICY my_policy ON t_tr_policy USING (nextval('seq_tr_policy') < 1000);

# Before dropping the trigger, the sequence should have two backrefs:
# one from the trigger (with trigger_id != 0) and one from the policy (trigger_id = 0).
query TI colnames
SELECT
  n.name,
  (d->>'triggerId')::INT as trigger_id
FROM (
  SELECT jsonb_array_elements(crdb_internal.pb_to_json('cockroach.sql.sqlbase.Descriptor', descriptor)->'table'->'dependedOnBy') as d
  FROM system.descriptor
  WHERE id = 'seq_tr_policy'::REGCLASS::INT
)
JOIN system.namespace n ON (d->>'id')::INT = n.id
ORDER BY 1, 2;
----
name         trigger_id
t_tr_policy  NULL
t_tr_policy  1

statement ok
DROP TRIGGER my_trigger ON t_tr_policy;

# After dropping the trigger, only the policy's backref should remain.
query TI colnames
SELECT
  n.name,
  (d->>'triggerId')::INT as trigger_id
FROM (
  SELECT jsonb_array_elements(crdb_internal.pb_to_json('cockroach.sql.sqlbase.Descriptor', descriptor)->'table'->'dependedOnBy') as d
  FROM system.descriptor
  WHERE id = 'seq_tr_policy'::REGCLASS::INT
)
JOIN system.namespace n ON (d->>'id')::INT = n.id
ORDER BY 1, 2;
----
name         trigger_id
t_tr_policy  NULL

statement ok
DROP POLICY my_policy ON t_tr_policy;
DROP TABLE t_tr_policy;
DROP FUNCTION trigger_fn_policy;
DROP SEQUENCE seq_tr_policy;

subtest end

# ==============================================================================
# End of regression tests. Add new features above the regression test section.
# ==============================================================================
