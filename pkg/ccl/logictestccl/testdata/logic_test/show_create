statement ok
CREATE TABLE residents (
	id INT,
	name STRING,
	country STRING,
	PRIMARY KEY (country, id)
)

query TT
SHOW CREATE INDEXES FROM residents
----
residents_pkey  CREATE UNIQUE INDEX residents_pkey ON public.residents (country ASC, id ASC)

query TT
SHOW CREATE SECONDARY INDEXES FROM residents
----

statement ok
ALTER TABLE residents PARTITION BY LIST (country) (
	PARTITION north_america VALUES IN ('CA', 'US', 'MX'),
	PARTITION DEFAULT VALUES IN (default)
)

query TT
SHOW CREATE INDEXES FROM residents
----
residents_pkey  CREATE UNIQUE INDEX residents_pkey ON public.residents (country ASC, id ASC) PARTITION BY LIST (country) (
                PARTITION north_america VALUES IN (('CA'), ('US'), ('MX')),
                PARTITION "default" VALUES IN ((DEFAULT))
)

statement ok
CREATE UNIQUE INDEX ON residents (id) PARTITION BY RANGE (id) (
	PARTITION negative VALUES FROM (MINVALUE) TO (0),
	PARTITION nonnegative VALUES FROM (0) TO (MAXVALUE)
)

query TT
SELECT * FROM [SHOW CREATE INDEXES FROM residents] ORDER BY index_name DESC
----
residents_pkey    CREATE UNIQUE INDEX residents_pkey ON public.residents (country ASC, id ASC) PARTITION BY LIST (country) (
                  PARTITION north_america VALUES IN (('CA'), ('US'), ('MX')),
                  PARTITION "default" VALUES IN ((DEFAULT))
)
residents_id_key  CREATE UNIQUE INDEX residents_id_key ON public.residents (id ASC) PARTITION BY RANGE (id) (
                  PARTITION negative VALUES FROM (MINVALUE) TO (0),
                  PARTITION nonnegative VALUES FROM (0) TO (MAXVALUE)
)

query TT
SHOW CREATE SECONDARY INDEXES FROM residents
----
residents_id_key  CREATE UNIQUE INDEX residents_id_key ON public.residents (id ASC) PARTITION BY RANGE (id) (
                  PARTITION negative VALUES FROM (MINVALUE) TO (0),
                  PARTITION nonnegative VALUES FROM (0) TO (MAXVALUE)
)

statement ok
CREATE FUNCTION r1() RETURNS INT LANGUAGE SQL AS 'SELECT 1'

statement ok
CREATE FUNCTION r1(i INT) RETURNS INT LANGUAGE SQL AS 'SELECT 1'

statement ok
CREATE PROCEDURE r1(s STRING) LANGUAGE SQL AS 'SELECT 1'

statement ok
CREATE PROCEDURE r1(s STRING, i INT) LANGUAGE SQL AS 'SELECT 1'

query TT
SELECT * FROM [SHOW CREATE FUNCTION r1] ORDER BY 2
----
r1  CREATE FUNCTION public.r1()
      RETURNS INT8
      VOLATILE
      NOT LEAKPROOF
      CALLED ON NULL INPUT
      LANGUAGE SQL
      SECURITY INVOKER
      AS $$
      SELECT 1;
    $$
r1  CREATE FUNCTION public.r1(i INT8)
      RETURNS INT8
      VOLATILE
      NOT LEAKPROOF
      CALLED ON NULL INPUT
      LANGUAGE SQL
      SECURITY INVOKER
      AS $$
      SELECT 1;
    $$

skipif config local-mixed-23.1
query TT
SELECT * FROM [SHOW CREATE PROCEDURE r1] ORDER BY 2
----
r1  CREATE PROCEDURE public.r1(s STRING)
      LANGUAGE SQL
      SECURITY INVOKER
      AS $$
      SELECT 1;
    $$
r1  CREATE PROCEDURE public.r1(s STRING, i INT8)
      LANGUAGE SQL
      SECURITY INVOKER
      AS $$
      SELECT 1;
    $$

statement ok
CREATE SCHEMA sc

statement ok
CREATE FUNCTION sc.r2() RETURNS INT LANGUAGE SQL AS 'SELECT 1'

statement ok
CREATE PROCEDURE sc.r2(s STRING) LANGUAGE SQL AS 'SELECT 1'

statement error pgcode 42883 pq: unknown function: r2()
SHOW CREATE FUNCTION r2;

statement error pgcode 42883 pq: unknown procedure: r2()
SHOW CREATE PROCEDURE r2;

statement ok
SET search_path = sc;

query TT
SHOW CREATE FUNCTION r2
----
r2  CREATE FUNCTION sc.r2()
      RETURNS INT8
      VOLATILE
      NOT LEAKPROOF
      CALLED ON NULL INPUT
      LANGUAGE SQL
      SECURITY INVOKER
      AS $$
      SELECT 1;
    $$

query TT
SHOW CREATE PROCEDURE r2
----
r2  CREATE PROCEDURE sc.r2(s STRING)
      LANGUAGE SQL
      SECURITY INVOKER
      AS $$
      SELECT 1;
    $$

statement ok
RESET search_path;

# Regression test for #112134 - correctly parse and display PLpgSQL.
statement ok
CREATE FUNCTION f112134() RETURNS INT AS $$
  DECLARE
    x INT := 0;
    i INT := 0;
  BEGIN
    WHILE i < 3 LOOP
      x := x + i;
      i := i + 1;
    END LOOP;
    RETURN x;
  END
$$ LANGUAGE PLpgSQL;

# TODO(112136): Fix the formatting.
query TT
SHOW CREATE FUNCTION f112134;
----
f112134  CREATE FUNCTION public.f112134()
           RETURNS INT8
           VOLATILE
           NOT LEAKPROOF
           CALLED ON NULL INPUT
           LANGUAGE plpgsql
           SECURITY INVOKER
           AS $$
           DECLARE
           x INT8 := 0;
           i INT8 := 0;
           BEGIN
           WHILE i < 3 LOOP
           x := x + i;
           i := i + 1;
           END LOOP;
           RETURN x;
           END;
         $$

subtest show_create_trigger

statement ok
CREATE TABLE t (a INT, b INT, c INT);
CREATE FUNCTION f() RETURNS TRIGGER AS $$ BEGIN RETURN NEW; END $$ LANGUAGE PLpgSQL;

statement error pgcode 42704 pq: trigger foo for table t does not exist
SHOW CREATE TRIGGER foo ON t;

statement ok
CREATE TRIGGER tr AFTER INSERT ON t FOR EACH ROW EXECUTE FUNCTION f();

statement ok
CREATE TRIGGER tr2 BEFORE UPDATE ON t FOR EACH ROW EXECUTE FUNCTION f();

statement ok
CREATE TRIGGER tr3 AFTER INSERT OR UPDATE ON t FOR EACH ROW WHEN ((NEW).a < 5) EXECUTE FUNCTION f();

query TT colnames
SHOW CREATE TRIGGER tr ON t;
----
trigger_name  create_statement
tr            CREATE TRIGGER tr AFTER INSERT ON test.public.t FOR EACH ROW EXECUTE FUNCTION test.public.f()

query TT colnames
SHOW CREATE TRIGGER tr2 ON t;
----
trigger_name  create_statement
tr2           CREATE TRIGGER tr2 BEFORE UPDATE ON test.public.t FOR EACH ROW EXECUTE FUNCTION test.public.f()

query TT colnames
SHOW CREATE TRIGGER tr3 ON t;
----
trigger_name  create_statement
tr3           CREATE TRIGGER tr3 AFTER INSERT OR UPDATE ON test.public.t FOR EACH ROW WHEN (new).a < 5:::INT8 EXECUTE FUNCTION test.public.f()

statement ok
DROP TRIGGER tr ON t;

statement error pgcode 42704 pq: trigger tr for table t does not exist
SHOW CREATE TRIGGER tr ON t;

# The user must have any privilege on the table (or be its owner).
statement ok
REVOKE ALL ON TABLE t FROM testuser;

user testuser

statement error pgcode 42501 pq: user testuser has no privileges on relation t
SHOW CREATE TRIGGER tr2 ON t;

user root

statement ok
GRANT INSERT ON t TO testuser;

user testuser

statement ok
SHOW CREATE TRIGGER tr2 ON t;

user root

statement ok
REVOKE ALL ON t FROM testuser;
ALTER TABLE t OWNER TO testuser;

user testuser

statement ok
SHOW CREATE TRIGGER tr2 ON t;

user root

statement ok
DROP TABLE t;
DROP FUNCTION f;
