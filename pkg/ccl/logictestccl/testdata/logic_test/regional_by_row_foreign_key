# LogicTest: multiregion-9node-3region-3azs multiregion-9node-3region-3azs-vec-off multiregion-9node-3region-3azs-tenant multiregion-9node-3region-3azs-no-los !metamorphic-batch-sizes

statement ok
CREATE DATABASE multi_region_test_db PRIMARY REGION "ca-central-1" REGIONS "ap-southeast-2", "us-east-1" SURVIVE REGION FAILURE

statement ok
USE multi_region_test_db

statement ok
SET experimental_enable_unique_without_index_constraints = true;

statement ok
SET CLUSTER SETTING feature.infer_rbr_region_col_using_constraint.enabled = true;

# NOTE: in a multiregion database, the default locality is REGIONAL BY TABLE in
# the primary region.
statement ok
CREATE TABLE parent_default (
  k INT PRIMARY KEY,
  v INT,
  region crdb_internal_region,
  UNIQUE WITHOUT INDEX (k, region)
);
INSERT INTO parent_default (k, v, region) (VALUES
  (1, 10, 'ca-central-1'),
  (2, 20, 'ap-southeast-2'),
  (3, 30, 'us-east-1'),
  (4, 40, 'ca-central-1'),
  (5, 50, 'ap-southeast-2'),
  (6, 60, 'us-east-1')
)

statement ok
CREATE TABLE parent_rbt (
  k INT PRIMARY KEY,
  v INT,
  region crdb_internal_region,
  UNIQUE WITHOUT INDEX (k, region)
) LOCALITY REGIONAL BY TABLE IN "us-east-1";
INSERT INTO parent_rbt (k, v, region) (SELECT k, v, region FROM parent_default)

statement ok
CREATE TABLE parent_global (
  k INT PRIMARY KEY,
  v INT,
  region crdb_internal_region,
  UNIQUE WITHOUT INDEX (k, region)
) LOCALITY GLOBAL;
INSERT INTO parent_global (k, v, region) (SELECT k, v, region FROM parent_default)

statement ok
CREATE TABLE parent_rbr (k INT PRIMARY KEY, v INT) LOCALITY REGIONAL BY ROW;
INSERT INTO parent_rbr (k, v, crdb_region) (SELECT k, v, region FROM parent_default)

statement ok
CREATE TABLE parent_unique_region (
  k INT PRIMARY KEY,
  v INT,
  region crdb_internal_region UNIQUE,
  UNIQUE WITHOUT INDEX (k, region)
);
INSERT INTO parent_unique_region (k, v, region) (SELECT DISTINCT ON (region) k, v, region FROM parent_default ORDER BY region, k)

statement ok
CREATE TABLE parent_unique_nullable (
  x INT NOT NULL,
  y INT,
  UNIQUE (x, y),
  UNIQUE WITHOUT INDEX (x, y, crdb_region),
  FAMILY (x, y, crdb_region)
) LOCALITY REGIONAL BY ROW;
INSERT INTO parent_unique_nullable (x, y, crdb_region) (SELECT k, v, region FROM parent_default);
INSERT INTO parent_unique_nullable (x, y, crdb_region) (VALUES
  (7, NULL, 'ca-central-1'),
  (8, NULL, 'ap-southeast-2'),
  (9, NULL, 'us-east-1')
)

# ==============================================================================
# Test invalid usage of RBR using constraint during table creation.
# ==============================================================================

subtest invalid

# Nonexistent constraint.
statement error pgcode 42704 pq: constraint named "foo" does not exist
CREATE TABLE child (
  k INT PRIMARY KEY,
  parent_k INT
) WITH (infer_rbr_region_col_using_constraint = 'foo') LOCALITY REGIONAL BY ROW

# Wrong type of constraint.
statement error pgcode 42P16 pq: constraint "foo" is not a foreign key constraint
CREATE TABLE child (
  k INT PRIMARY KEY,
  parent_k INT,
  UNIQUE INDEX foo (parent_k)
) WITH (infer_rbr_region_col_using_constraint = 'foo') LOCALITY REGIONAL BY ROW

# Region column must be in the foreign key constraint.
statement error pgcode 42P16 pq: cannot use constraint "foo" to determine the region column for REGIONAL BY ROW as it does not include the region column "crdb_region"
CREATE TABLE child (
  k INT PRIMARY KEY,
  parent_k INT,
  CONSTRAINT foo FOREIGN KEY (parent_k) REFERENCES parent_rbr (k)
) WITH (infer_rbr_region_col_using_constraint = 'foo') LOCALITY REGIONAL BY ROW

# Region column cannot be the only column in the foreign key constraint.
statement error pgcode 42P16 pq: cannot use constraint "foo" to determine the region column for REGIONAL BY ROW as it only includes the region column
CREATE TABLE child (
  k INT PRIMARY KEY,
  parent_k INT,
  CONSTRAINT foo FOREIGN KEY (crdb_region) REFERENCES parent_unique_region (region)
) WITH (infer_rbr_region_col_using_constraint = 'foo') LOCALITY REGIONAL BY ROW

# The region column cannot be a computed column.
statement error pgcode 42P16 pq: cannot use computed column "crdb_region" as the region column in a REGIONAL BY ROW table with the "infer_rbr_region_col_using_constraint" storage parameter specified
CREATE TABLE child (
  k INT PRIMARY KEY,
  parent_k INT,
  crdb_region crdb_internal_region AS (CASE WHEN k = 1 THEN 'ca-central-1'::crdb_internal_region ELSE 'us-east-1'::crdb_internal_region END) STORED,
  CONSTRAINT foo FOREIGN KEY (crdb_region, parent_k) REFERENCES parent_rbr (crdb_region, k)
) WITH (infer_rbr_region_col_using_constraint = 'foo') LOCALITY REGIONAL BY ROW

# Stored computed columns cannot reference the region column.
statement error pgcode 42P16 pq: computed column "computed_col" cannot reference the region column "crdb_region" in a REGIONAL BY ROW table with "infer_rbr_region_col_using_constraint" specified
CREATE TABLE child (
  k INT PRIMARY KEY,
  parent_k INT,
  crdb_region crdb_internal_region NOT VISIBLE NOT NULL DEFAULT default_to_database_primary_region(gateway_region())::crdb_internal_region,
  computed_col TEXT AS (crdb_region::TEXT) STORED,
  CONSTRAINT foo FOREIGN KEY (crdb_region, parent_k) REFERENCES parent_rbr (crdb_region, k)
) WITH (infer_rbr_region_col_using_constraint = 'foo') LOCALITY REGIONAL BY ROW

# Virtual computed columns cannot reference the region column.
statement error pgcode 42P16 pq: computed column "computed_col" cannot reference the region column "crdb_region" in a REGIONAL BY ROW table with "infer_rbr_region_col_using_constraint" specified
CREATE TABLE child (
  k INT PRIMARY KEY,
  parent_k INT,
  crdb_region crdb_internal_region NOT VISIBLE NOT NULL DEFAULT default_to_database_primary_region(gateway_region())::crdb_internal_region,
  computed_col TEXT AS (crdb_region::TEXT) VIRTUAL,
  CONSTRAINT foo FOREIGN KEY (crdb_region, parent_k) REFERENCES parent_rbr (crdb_region, k)
) WITH (infer_rbr_region_col_using_constraint = 'foo') LOCALITY REGIONAL BY ROW

# Expression indexes cannot reference the region column.
statement error pgcode 42P16 pq: computed column "crdb_internal_idx_expr" cannot reference the region column "crdb_region" in a REGIONAL BY ROW table with "infer_rbr_region_col_using_constraint" specified
CREATE TABLE child (
  k INT PRIMARY KEY,
  parent_k INT,
  crdb_region crdb_internal_region NOT VISIBLE NOT NULL DEFAULT default_to_database_primary_region(gateway_region())::crdb_internal_region,
  INDEX ((crdb_region::TEXT)),
  CONSTRAINT foo FOREIGN KEY (crdb_region, parent_k) REFERENCES parent_rbr (crdb_region, k)
) WITH (infer_rbr_region_col_using_constraint = 'foo') LOCALITY REGIONAL BY ROW

# Cannot set the storage param on a REGIONAL BY TABLE table.
statement error pgcode 22023 pq: storage parameter "infer_rbr_region_col_using_constraint" can only be set on REGIONAL BY ROW tables
CREATE TABLE child (
  k INT PRIMARY KEY,
  parent_k INT,
  crdb_region crdb_internal_region,
  CONSTRAINT foo FOREIGN KEY (crdb_region, parent_k) REFERENCES parent_rbr (crdb_region, k)
) WITH (infer_rbr_region_col_using_constraint = 'foo');

# Cannot set the storage param on a GLOBAL table.
statement error pgcode 22023 pq: storage parameter "infer_rbr_region_col_using_constraint" can only be set on REGIONAL BY ROW tables
CREATE TABLE child (
  k INT PRIMARY KEY,
  parent_k INT,
  crdb_region crdb_internal_region,
  CONSTRAINT foo FOREIGN KEY (crdb_region, parent_k) REFERENCES parent_rbr (crdb_region, k)
) WITH (infer_rbr_region_col_using_constraint = 'foo') LOCALITY GLOBAL;

statement ok
RESET CLUSTER SETTING feature.infer_rbr_region_col_using_constraint.enabled;

statement error pgcode 0A000 pq: storage parameter "infer_rbr_region_col_using_constraint" is not enabled; set the cluster setting "feature.infer_rbr_region_col_using_constraint.enabled" to true to enable it
CREATE TABLE child (
  k INT PRIMARY KEY,
  parent_k INT,
  CONSTRAINT foo FOREIGN KEY (crdb_region, parent_k) REFERENCES parent_rbr (crdb_region, k)
) WITH (infer_rbr_region_col_using_constraint = 'foo') LOCALITY REGIONAL BY ROW;

statement ok
SET CLUSTER SETTING feature.infer_rbr_region_col_using_constraint.enabled = true;

# ==============================================================================
# Test invalid usage of RBR using constraint during table alteration.
# ==============================================================================

statement ok
SET create_table_with_schema_locked = false;

statement ok
CREATE TABLE child (
  k INT PRIMARY KEY,
  parent_k INT,
  CONSTRAINT foo FOREIGN KEY (crdb_region, parent_k) REFERENCES parent_rbr (crdb_region, k),
  CONSTRAINT no_region FOREIGN KEY (parent_k) REFERENCES parent_rbr (k),
  CONSTRAINT only_region FOREIGN KEY (crdb_region) REFERENCES parent_unique_region (region),
  UNIQUE INDEX baz (parent_k)
) WITH (infer_rbr_region_col_using_constraint = 'foo') LOCALITY REGIONAL BY ROW

statement ok
RESET create_table_with_schema_locked;

# Cannot drop the foreign key that supports the RBR constraint.
statement error pgcode 42P16 pq: cannot drop constraint foo as it is used to determine the region in a REGIONAL BY ROW table
ALTER TABLE child DROP CONSTRAINT foo

# Nonexistent constraint.
statement error pgcode 42704 pq: constraint named "bar" does not exist
ALTER TABLE child SET (infer_rbr_region_col_using_constraint = 'bar')

# Wrong type of constraint.
statement error pgcode 42P16 pq: constraint "baz" is not a foreign key constraint
ALTER TABLE child SET (infer_rbr_region_col_using_constraint = 'baz')

# Region column must be in the foreign key constraint.
statement error pgcode 42P16 pq: cannot use constraint "no_region" to determine the region column for REGIONAL BY ROW as it does not include the region column "crdb_region"
ALTER TABLE child SET (infer_rbr_region_col_using_constraint = 'no_region')

# Region column cannot be the only column in the foreign key constraint.
statement error pgcode 42P16 pq: cannot use constraint "only_region" to determine the region column for REGIONAL BY ROW as it only includes the region column
ALTER TABLE child SET (infer_rbr_region_col_using_constraint = 'only_region')

# Stored computed columns cannot reference the region column.
statement error pgcode 42P16 pq: computed column "computed_col" cannot reference the region column "crdb_region" in a REGIONAL BY ROW table with "infer_rbr_region_col_using_constraint" specified
ALTER TABLE child ADD COLUMN computed_col TEXT AS (crdb_region::TEXT) STORED;

# Virtual computed columns cannot reference the region column.
statement error pgcode 42P16 pq: computed column "computed_col" cannot reference the region column "crdb_region" in a REGIONAL BY ROW table with "infer_rbr_region_col_using_constraint" specified
ALTER TABLE child ADD COLUMN computed_col TEXT AS (crdb_region::TEXT) VIRTUAL;

statement error pgcode 42P16 pq: computed column "crdb_internal_idx_expr" cannot reference the region column "crdb_region" in a REGIONAL BY ROW table with "infer_rbr_region_col_using_constraint" specified
CREATE INDEX foo ON child ((crdb_region::TEXT))

statement ok
DROP TABLE child

# The region column cannot be a computed column.
statement ok
CREATE TABLE child (
  k INT PRIMARY KEY,
  parent_k INT,
  crdb_region crdb_internal_region AS (CASE WHEN k = 1 THEN 'ca-central-1'::crdb_internal_region ELSE 'us-east-1'::crdb_internal_region END) STORED,
  CONSTRAINT foo FOREIGN KEY (crdb_region, parent_k) REFERENCES parent_rbr (crdb_region, k)
) LOCALITY REGIONAL BY ROW;

statement error pgcode 42P16 pq: cannot use computed column "crdb_region" as the region column in a REGIONAL BY ROW table with the "infer_rbr_region_col_using_constraint" storage parameter specified
ALTER TABLE child SET (infer_rbr_region_col_using_constraint = 'foo');

statement ok
DROP TABLE child;

# Cannot set the storage param on a REGIONAL BY TABLE table.
statement ok
CREATE TABLE child (
  k INT PRIMARY KEY,
  parent_k INT,
  crdb_region crdb_internal_region,
  CONSTRAINT foo FOREIGN KEY (crdb_region, parent_k) REFERENCES parent_rbr (crdb_region, k)
)

statement error pgcode 22023 pq: storage parameter "infer_rbr_region_col_using_constraint" can only be set on REGIONAL BY ROW tables
ALTER TABLE child SET (infer_rbr_region_col_using_constraint = 'foo')

statement ok
DROP TABLE child

# Cannot set the storage param on a GLOBAL table.
statement ok
CREATE TABLE child (
  k INT PRIMARY KEY,
  parent_k INT,
  crdb_region crdb_internal_region,
  CONSTRAINT foo FOREIGN KEY (crdb_region, parent_k) REFERENCES parent_rbr (crdb_region, k)
) LOCALITY GLOBAL

statement error pgcode 22023 pq: storage parameter "infer_rbr_region_col_using_constraint" can only be set on REGIONAL BY ROW tables
ALTER TABLE child SET (infer_rbr_region_col_using_constraint = 'foo')

statement ok
DROP TABLE child

statement ok
CREATE TABLE child (
  k INT PRIMARY KEY,
  parent_k INT,
  CONSTRAINT foo FOREIGN KEY (crdb_region, parent_k) REFERENCES parent_rbr (crdb_region, k)
) LOCALITY REGIONAL BY ROW;

statement ok
RESET CLUSTER SETTING feature.infer_rbr_region_col_using_constraint.enabled;

statement error pgcode 0A000 pq: storage parameter "infer_rbr_region_col_using_constraint" is not enabled; set the cluster setting "feature.infer_rbr_region_col_using_constraint.enabled" to true to enable it
ALTER TABLE child SET (infer_rbr_region_col_using_constraint = 'foo')

statement ok
SET CLUSTER SETTING feature.infer_rbr_region_col_using_constraint.enabled = true;

statement ok
DROP TABLE child

subtest end

# ==============================================================================
# Test quoted constraint name.
# ==============================================================================

subtest quoted_constraint_name

# Use a constraint name that requires quoting and itself includes quotes.
statement ok
CREATE TABLE child (
  k INT PRIMARY KEY,
  parent_k INT,
  CONSTRAINT "F ""o'o B'""ar" FOREIGN KEY (crdb_region, parent_k) REFERENCES parent_rbr (crdb_region, k),
  FAMILY (k, parent_k, crdb_region)
) WITH (infer_rbr_region_col_using_constraint = "F ""o'o B'""ar") LOCALITY REGIONAL BY ROW;

query T
SELECT create_statement FROM [SHOW CREATE TABLE child]
----
CREATE TABLE public.child (
  k INT8 NOT NULL,
  parent_k INT8 NULL,
  crdb_region public.crdb_internal_region NOT VISIBLE NOT NULL DEFAULT default_to_database_primary_region(gateway_region())::public.crdb_internal_region,
  CONSTRAINT child_pkey PRIMARY KEY (k ASC),
  CONSTRAINT "F ""o'o B'""ar" FOREIGN KEY (crdb_region, parent_k) REFERENCES public.parent_rbr(crdb_region, k),
  FAMILY fam_0_k_parent_k_crdb_region (k, parent_k, crdb_region)
) WITH (schema_locked = true, infer_rbr_region_col_using_constraint = "F \"o'o B'\"ar") LOCALITY REGIONAL BY ROW;

statement ok
DROP TABLE child;

subtest end

# ==============================================================================
# Test schema changes.
# ==============================================================================

subtest schema_changes

statement ok
SET create_table_with_schema_locked = false;

statement ok
CREATE TABLE child (
  k INT PRIMARY KEY,
  parent_k INT,
  CONSTRAINT foo FOREIGN KEY (crdb_region, parent_k) REFERENCES parent_rbr (crdb_region, k),
  FAMILY (k, parent_k, crdb_region)
) WITH (infer_rbr_region_col_using_constraint = 'foo') LOCALITY REGIONAL BY ROW;

statement ok
RESET create_table_with_schema_locked;

# Renaming the constraint should update the storage param.
statement ok
ALTER TABLE child RENAME CONSTRAINT foo TO bar;

query T
SELECT create_statement FROM [SHOW CREATE TABLE child]
----
CREATE TABLE public.child (
  k INT8 NOT NULL,
  parent_k INT8 NULL,
  crdb_region public.crdb_internal_region NOT VISIBLE NOT NULL DEFAULT default_to_database_primary_region(gateway_region())::public.crdb_internal_region,
  CONSTRAINT child_pkey PRIMARY KEY (k ASC),
  CONSTRAINT bar FOREIGN KEY (crdb_region, parent_k) REFERENCES public.parent_rbr(crdb_region, k),
  FAMILY fam_0_k_parent_k_crdb_region (k, parent_k, crdb_region)
) WITH (infer_rbr_region_col_using_constraint = "bar") LOCALITY REGIONAL BY ROW;

# Rename the region column.
statement ok
ALTER TABLE child RENAME COLUMN crdb_region TO foo_region;

query T
SELECT create_statement FROM [SHOW CREATE TABLE child]
----
CREATE TABLE public.child (
  k INT8 NOT NULL,
  parent_k INT8 NULL,
  foo_region public.crdb_internal_region NOT VISIBLE NOT NULL DEFAULT default_to_database_primary_region(gateway_region())::public.crdb_internal_region,
  CONSTRAINT child_pkey PRIMARY KEY (k ASC),
  CONSTRAINT bar FOREIGN KEY (foo_region, parent_k) REFERENCES public.parent_rbr(crdb_region, k),
  FAMILY fam_0_k_parent_k_crdb_region (k, parent_k, foo_region)
) WITH (infer_rbr_region_col_using_constraint = "bar") LOCALITY REGIONAL BY ROW AS foo_region;

# Add another foreign key constraint.
statement ok
ALTER TABLE child ADD CONSTRAINT baz FOREIGN KEY (foo_region, parent_k) REFERENCES parent_rbr (crdb_region, k);

# Use the new constraint. This change is allowed by schema_locked.
statement ok
ALTER TABLE child SET (schema_locked = true);

statement ok
ALTER TABLE child SET (infer_rbr_region_col_using_constraint = 'baz');

query T
SELECT create_statement FROM [SHOW CREATE TABLE child]
----
CREATE TABLE public.child (
  k INT8 NOT NULL,
  parent_k INT8 NULL,
  foo_region public.crdb_internal_region NOT VISIBLE NOT NULL DEFAULT default_to_database_primary_region(gateway_region())::public.crdb_internal_region,
  CONSTRAINT child_pkey PRIMARY KEY (k ASC),
  CONSTRAINT bar FOREIGN KEY (foo_region, parent_k) REFERENCES public.parent_rbr(crdb_region, k),
  CONSTRAINT baz FOREIGN KEY (foo_region, parent_k) REFERENCES public.parent_rbr(crdb_region, k),
  FAMILY fam_0_k_parent_k_crdb_region (k, parent_k, foo_region)
) WITH (schema_locked = true, infer_rbr_region_col_using_constraint = "baz") LOCALITY REGIONAL BY ROW AS foo_region;

statement ok
ALTER TABLE child SET (schema_locked = false);

# Attempt to set the locality in a way that changes the region column.
# This fails because the new region column would not be part of the foreign
# key constraint.
statement error pgcode 42P16 pq: cannot change the REGIONAL BY ROW column from foo_region to crdb_region when "infer_rbr_region_col_using_constraint" is set
ALTER TABLE child SET LOCALITY REGIONAL BY ROW;

# Alter the locality to the same value.
statement ok
ALTER TABLE child SET LOCALITY REGIONAL BY ROW AS foo_region;

# Unset the storage parameter.
statement ok
ALTER TABLE child RESET (infer_rbr_region_col_using_constraint);

query T
SELECT create_statement FROM [SHOW CREATE TABLE child]
----
CREATE TABLE public.child (
  k INT8 NOT NULL,
  parent_k INT8 NULL,
  foo_region public.crdb_internal_region NOT VISIBLE NOT NULL DEFAULT default_to_database_primary_region(gateway_region())::public.crdb_internal_region,
  CONSTRAINT child_pkey PRIMARY KEY (k ASC),
  CONSTRAINT bar FOREIGN KEY (foo_region, parent_k) REFERENCES public.parent_rbr(crdb_region, k),
  CONSTRAINT baz FOREIGN KEY (foo_region, parent_k) REFERENCES public.parent_rbr(crdb_region, k),
  FAMILY fam_0_k_parent_k_crdb_region (k, parent_k, foo_region)
) LOCALITY REGIONAL BY ROW AS foo_region;

# Alter the locality to REGIONAL BY TABLE. The storage param should be
# automatically unset.
statement ok
ALTER TABLE child SET (infer_rbr_region_col_using_constraint = 'bar');

statement ok
ALTER TABLE child SET LOCALITY REGIONAL BY TABLE;

query T
SELECT create_statement FROM [SHOW CREATE TABLE child]
----
CREATE TABLE public.child (
  k INT8 NOT NULL,
  parent_k INT8 NULL,
  foo_region public.crdb_internal_region NOT VISIBLE NOT NULL DEFAULT default_to_database_primary_region(gateway_region())::public.crdb_internal_region,
  CONSTRAINT child_pkey PRIMARY KEY (k ASC),
  CONSTRAINT bar FOREIGN KEY (foo_region, parent_k) REFERENCES public.parent_rbr(crdb_region, k),
  CONSTRAINT baz FOREIGN KEY (foo_region, parent_k) REFERENCES public.parent_rbr(crdb_region, k),
  FAMILY fam_0_k_parent_k_crdb_region (k, parent_k, foo_region)
) LOCALITY REGIONAL BY TABLE IN PRIMARY REGION;

# Alter the locality to GLOBAL. The storage param should be automatically unset.
statement ok
ALTER TABLE child SET LOCALITY REGIONAL BY ROW AS foo_region;

statement ok
ALTER TABLE child SET (infer_rbr_region_col_using_constraint = 'baz');

statement ok
ALTER TABLE child SET LOCALITY GLOBAL;

query T
SELECT create_statement FROM [SHOW CREATE TABLE child]
----
CREATE TABLE public.child (
  k INT8 NOT NULL,
  parent_k INT8 NULL,
  foo_region public.crdb_internal_region NOT VISIBLE NOT NULL DEFAULT default_to_database_primary_region(gateway_region())::public.crdb_internal_region,
  CONSTRAINT child_pkey PRIMARY KEY (k ASC),
  CONSTRAINT bar FOREIGN KEY (foo_region, parent_k) REFERENCES public.parent_rbr(crdb_region, k),
  CONSTRAINT baz FOREIGN KEY (foo_region, parent_k) REFERENCES public.parent_rbr(crdb_region, k),
  FAMILY fam_0_k_parent_k_crdb_region (k, parent_k, foo_region)
) LOCALITY GLOBAL;

statement ok
DROP TABLE child;

subtest end

# ==============================================================================
# Test with parent REGIONAL BY TABLE in primary region (default).
# ==============================================================================

subtest rbt_default

statement ok
CREATE TABLE child (
  k INT,
  v INT,
  CONSTRAINT foo FOREIGN KEY (crdb_region, k) REFERENCES parent_rbt (region, k)
) WITH (infer_rbr_region_col_using_constraint = 'foo') LOCALITY REGIONAL BY ROW

statement ok
CREATE FUNCTION display_child() RETURNS TABLE (
  k INT,
  child_region crdb_internal_region,
  parent_region crdb_internal_region
) AS $$
  SELECT c.k, c.crdb_region, p.region
  FROM child c LEFT JOIN parent_rbt p ON c.k = p.k;
$$ LANGUAGE SQL STABLE;

statement ok
INSERT INTO child (k) (VALUES (1), (2), (3), (NULL))

query ITT colnames
SELECT * FROM display_child() ORDER BY k, child_region
----
k     child_region    parent_region
NULL  ap-southeast-2  NULL
1     ca-central-1    ca-central-1
2     ap-southeast-2  ap-southeast-2
3     us-east-1       us-east-1

# If the user specifies values for the region column, they override the storage
# param and no lookup is performed.
statement ok
INSERT INTO child (k, crdb_region) (VALUES (4, 'ca-central-1'), (5, 'ap-southeast-2'), (6, 'us-east-1'), (NULL, 'us-east-1'))

query ITT colnames
SELECT * FROM display_child() ORDER BY k, child_region
----
k     child_region    parent_region
NULL  ap-southeast-2  NULL
NULL  us-east-1       NULL
1     ca-central-1    ca-central-1
2     ap-southeast-2  ap-southeast-2
3     us-east-1       us-east-1
4     ca-central-1    ca-central-1
5     ap-southeast-2  ap-southeast-2
6     us-east-1       us-east-1

statement ok
UPDATE child SET k = 4 WHERE k IS NULL

query ITT colnames
SELECT * FROM display_child() ORDER BY k, child_region
----
k  child_region    parent_region
1  ca-central-1    ca-central-1
2  ap-southeast-2  ap-southeast-2
3  us-east-1       us-east-1
4  ca-central-1    ca-central-1
4  ca-central-1    ca-central-1
4  ca-central-1    ca-central-1
5  ap-southeast-2  ap-southeast-2
6  us-east-1       us-east-1

statement ok
UPDATE child SET k = NULL WHERE k = 4 OR k = 2

query ITT colnames
SELECT * FROM display_child() ORDER BY k, child_region
----
k     child_region    parent_region
NULL  ap-southeast-2  NULL
NULL  ca-central-1    NULL
NULL  ca-central-1    NULL
NULL  ca-central-1    NULL
1     ca-central-1    ca-central-1
3     us-east-1       us-east-1
5     ap-southeast-2  ap-southeast-2
6     us-east-1       us-east-1

# An UPDATE that doesn't modify any of the columns in the FK does not change
# the region column.
statement ok
UPDATE child SET v = 100 WHERE True;

query ITT colnames
SELECT * FROM display_child() ORDER BY k, child_region
----
k     child_region    parent_region
NULL  ap-southeast-2  NULL
NULL  ca-central-1    NULL
NULL  ca-central-1    NULL
NULL  ca-central-1    NULL
1     ca-central-1    ca-central-1
3     us-east-1       us-east-1
5     ap-southeast-2  ap-southeast-2
6     us-east-1       us-east-1

# FK validation is performed even when the lookup is elided, so an attempt to
# insert a row with a region that does not match the parent table will fail.
statement error pgcode 23503 pq: insert on table "child" violates foreign key constraint "foo"\nDETAIL: Key \(crdb_region, k\)=\('ap-southeast-2', 4\) is not present in table "parent_rbt".
INSERT INTO child (k, crdb_region) (VALUES (4, 'ap-southeast-2'))

statement ok
DROP FUNCTION display_child

statement ok
DROP TABLE child

subtest end

# ==============================================================================
# Test with parent REGIONAL BY TABLE in secondary region.
# ==============================================================================

subtest rbt_secondary

statement ok
CREATE TABLE child (
  k INT,
  CONSTRAINT foo FOREIGN KEY (crdb_region, k) REFERENCES parent_rbt (region, k)
) WITH (infer_rbr_region_col_using_constraint = 'foo') LOCALITY REGIONAL BY ROW

statement ok
CREATE FUNCTION display_child() RETURNS TABLE (
  k INT,
  child_region crdb_internal_region,
  parent_region crdb_internal_region
) AS $$
  SELECT c.k, c.crdb_region, p.region
  FROM child c LEFT JOIN parent_rbt p ON c.k = p.k;
$$ LANGUAGE SQL STABLE;

statement ok
INSERT INTO child (VALUES (1), (2), (3), (4), (5), (6), (NULL), (NULL))

query ITT colnames
SELECT * FROM display_child() ORDER BY k, child_region
----
k     child_region    parent_region
NULL  ap-southeast-2  NULL
NULL  ap-southeast-2  NULL
1     ca-central-1    ca-central-1
2     ap-southeast-2  ap-southeast-2
3     us-east-1       us-east-1
4     ca-central-1    ca-central-1
5     ap-southeast-2  ap-southeast-2
6     us-east-1       us-east-1

statement ok
UPDATE child SET k = 4 WHERE k IS NULL

query ITT colnames
SELECT * FROM display_child() ORDER BY k, child_region
----
k  child_region    parent_region
1  ca-central-1    ca-central-1
2  ap-southeast-2  ap-southeast-2
3  us-east-1       us-east-1
4  ca-central-1    ca-central-1
4  ca-central-1    ca-central-1
4  ca-central-1    ca-central-1
5  ap-southeast-2  ap-southeast-2
6  us-east-1       us-east-1

statement ok
DROP FUNCTION display_child

statement ok
DROP TABLE child

subtest end

# ==============================================================================
# Test with parent GLOBAL table.
# ==============================================================================

subtest global

statement ok
CREATE TABLE child (
  k INT,
  CONSTRAINT foo FOREIGN KEY (crdb_region, k) REFERENCES parent_global (region, k)
) WITH (infer_rbr_region_col_using_constraint = 'foo') LOCALITY REGIONAL BY ROW

statement ok
CREATE FUNCTION display_child() RETURNS TABLE (
  k INT,
  child_region crdb_internal_region,
  parent_region crdb_internal_region
) AS $$
  SELECT c.k, c.crdb_region, p.region
  FROM child c LEFT JOIN parent_global p ON c.k = p.k;
$$ LANGUAGE SQL STABLE;

statement ok
INSERT INTO child (VALUES (1), (2), (3), (4), (5), (6), (NULL), (NULL))

query ITT colnames
SELECT * FROM display_child() ORDER BY k, child_region
----
k     child_region    parent_region
NULL  ap-southeast-2  NULL
NULL  ap-southeast-2  NULL
1     ca-central-1    ca-central-1
2     ap-southeast-2  ap-southeast-2
3     us-east-1       us-east-1
4     ca-central-1    ca-central-1
5     ap-southeast-2  ap-southeast-2
6     us-east-1       us-east-1

statement ok
UPDATE child SET k = 4 WHERE k IS NULL

query ITT colnames
SELECT * FROM display_child() ORDER BY k, child_region
----
k  child_region    parent_region
1  ca-central-1    ca-central-1
2  ap-southeast-2  ap-southeast-2
3  us-east-1       us-east-1
4  ca-central-1    ca-central-1
4  ca-central-1    ca-central-1
4  ca-central-1    ca-central-1
5  ap-southeast-2  ap-southeast-2
6  us-east-1       us-east-1

statement ok
DROP FUNCTION display_child

statement ok
DROP TABLE child

subtest end

# ==============================================================================
# Test with parent REGIONAL BY ROW table.
# ==============================================================================

subtest rbr

statement ok
CREATE TABLE child (
  k INT,
  CONSTRAINT foo FOREIGN KEY (crdb_region, k) REFERENCES parent_rbr (crdb_region, k)
) WITH (infer_rbr_region_col_using_constraint = 'foo') LOCALITY REGIONAL BY ROW

statement ok
CREATE FUNCTION display_child() RETURNS TABLE (
  k INT,
  child_region crdb_internal_region,
  parent_region crdb_internal_region
) AS $$
  SELECT c.k, c.crdb_region, p.crdb_region
  FROM child c LEFT JOIN parent_rbr p ON c.k = p.k;
$$ LANGUAGE SQL STABLE;

statement ok
INSERT INTO child (VALUES (1), (2), (3), (4), (5), (6), (NULL), (NULL))

query ITT colnames
SELECT * FROM display_child() ORDER BY k, child_region
----
k     child_region    parent_region
NULL  ap-southeast-2  NULL
NULL  ap-southeast-2  NULL
1     ca-central-1    ca-central-1
2     ap-southeast-2  ap-southeast-2
3     us-east-1       us-east-1
4     ca-central-1    ca-central-1
5     ap-southeast-2  ap-southeast-2
6     us-east-1       us-east-1

statement ok
UPDATE child SET k = 4 WHERE k IS NULL

query ITT colnames
SELECT * FROM display_child() ORDER BY k, child_region
----
k  child_region    parent_region
1  ca-central-1    ca-central-1
2  ap-southeast-2  ap-southeast-2
3  us-east-1       us-east-1
4  ca-central-1    ca-central-1
4  ca-central-1    ca-central-1
4  ca-central-1    ca-central-1
5  ap-southeast-2  ap-southeast-2
6  us-east-1       us-east-1

statement ok
DROP FUNCTION display_child

statement ok
DROP TABLE child

subtest end

# ==============================================================================
# Test with parent multi-column unique constraint containing nullable column.
# ==============================================================================

subtest rbr_multi_column_with_nullable

statement ok
CREATE TABLE child (
  x INT,
  y INT,
  CONSTRAINT foo FOREIGN KEY (crdb_region, x, y) REFERENCES parent_unique_nullable (crdb_region, x, y)
) WITH (infer_rbr_region_col_using_constraint = 'foo') LOCALITY REGIONAL BY ROW

statement ok
CREATE FUNCTION display_child() RETURNS TABLE (
  x INT,
  y INT,
  child_region crdb_internal_region,
  parent_region crdb_internal_region
) AS $$
  SELECT c.x, c.y, c.crdb_region, p.crdb_region
  FROM child c LEFT JOIN parent_unique_nullable p ON c.x = p.x AND c.y = p.y;
$$ LANGUAGE SQL STABLE;

statement ok
INSERT INTO child (VALUES (1, NULL), (2, 20), (3, 30), (4, 40), (5, 50), (NULL, 60), (NULL, NULL), (NULL, NULL))

query IITT colnames
SELECT * FROM display_child() ORDER BY x, y, child_region
----
x     y     child_region    parent_region
NULL  NULL  ap-southeast-2  NULL
NULL  NULL  ap-southeast-2  NULL
NULL  60    ap-southeast-2  NULL
1     NULL  ap-southeast-2  NULL
2     20    ap-southeast-2  ap-southeast-2
3     30    us-east-1       us-east-1
4     40    ca-central-1    ca-central-1
5     50    ap-southeast-2  ap-southeast-2

statement ok
UPDATE child SET y = x * 10 WHERE y IS NULL

query IITT colnames
SELECT * FROM display_child() ORDER BY x, y, child_region
----
x     y     child_region    parent_region
NULL  NULL  ap-southeast-2  NULL
NULL  NULL  ap-southeast-2  NULL
NULL  60    ap-southeast-2  NULL
1     10    ca-central-1    ca-central-1
2     20    ap-southeast-2  ap-southeast-2
3     30    us-east-1       us-east-1
4     40    ca-central-1    ca-central-1
5     50    ap-southeast-2  ap-southeast-2

statement ok
UPDATE child SET x = y // 10 WHERE x IS NULL

query IITT colnames
SELECT * FROM display_child() ORDER BY x, y, child_region
----
x     y     child_region    parent_region
NULL  NULL  ap-southeast-2  NULL
NULL  NULL  ap-southeast-2  NULL
1     10    ca-central-1    ca-central-1
2     20    ap-southeast-2  ap-southeast-2
3     30    us-east-1       us-east-1
4     40    ca-central-1    ca-central-1
5     50    ap-southeast-2  ap-southeast-2
6     60    us-east-1       us-east-1

statement ok
UPDATE child SET y = NULL WHERE True

query IITT colnames
SELECT * FROM display_child() ORDER BY x, y, child_region
----
x     y     child_region    parent_region
NULL  NULL  ap-southeast-2  NULL
NULL  NULL  ap-southeast-2  NULL
1     NULL  ca-central-1    NULL
2     NULL  ap-southeast-2  NULL
3     NULL  us-east-1       NULL
4     NULL  ca-central-1    NULL
5     NULL  ap-southeast-2  NULL
6     NULL  us-east-1       NULL

statement ok
DROP FUNCTION display_child

statement ok
DROP TABLE child

subtest end

# ==============================================================================
# Region column inference is compatible with hash-sharded indexes.
# ==============================================================================

subtest rbr_hash_sharded

statement ok
CREATE TABLE child (
  v INT,
  k INT,
  INDEX (v) USING HASH,
  INDEX (k) USING HASH,
  CONSTRAINT foo FOREIGN KEY (crdb_region, k) REFERENCES parent_rbr (crdb_region, k)
) WITH (infer_rbr_region_col_using_constraint = 'foo') LOCALITY REGIONAL BY ROW

statement ok
CREATE FUNCTION display_child() RETURNS TABLE (
  v INT,
  k INT,
  child_region crdb_internal_region,
  parent_region crdb_internal_region
) AS $$
  SELECT c.v, c.k, c.crdb_region, p.crdb_region
  FROM child c LEFT JOIN parent_rbr p ON c.k = p.k;
$$ LANGUAGE SQL STABLE;

statement ok
INSERT INTO child (VALUES (100, 1), (200, 2), (300, 3), (400, 4), (500, 5), (600, 6), (700, NULL), (800, NULL))

query IITT colnames
SELECT * FROM display_child() ORDER BY v
----
v    k     child_region    parent_region
100  1     ca-central-1    ca-central-1
200  2     ap-southeast-2  ap-southeast-2
300  3     us-east-1       us-east-1
400  4     ca-central-1    ca-central-1
500  5     ap-southeast-2  ap-southeast-2
600  6     us-east-1       us-east-1
700  NULL  ap-southeast-2  NULL
800  NULL  ap-southeast-2  NULL

statement ok
UPDATE child SET k = 4 WHERE k IS NULL

query IITT colnames
SELECT * FROM display_child() ORDER BY v
----
v    k  child_region    parent_region
100  1  ca-central-1    ca-central-1
200  2  ap-southeast-2  ap-southeast-2
300  3  us-east-1       us-east-1
400  4  ca-central-1    ca-central-1
500  5  ap-southeast-2  ap-southeast-2
600  6  us-east-1       us-east-1
700  4  ca-central-1    ca-central-1
800  4  ca-central-1    ca-central-1

statement ok
DROP FUNCTION display_child

statement ok
DROP TABLE child

subtest end

# ==============================================================================
# Test with MATCH FULL foreign key constraint.
# ==============================================================================

subtest rbr_match_full

statement ok
CREATE TABLE child (
  x INT,
  y INT,
  CONSTRAINT foo FOREIGN KEY (crdb_region, x, y) REFERENCES parent_unique_nullable (crdb_region, x, y) MATCH FULL
) WITH (infer_rbr_region_col_using_constraint = 'foo') LOCALITY REGIONAL BY ROW

statement ok
CREATE FUNCTION display_child() RETURNS TABLE (
  x INT,
  y INT,
  child_region crdb_internal_region,
  parent_region crdb_internal_region
) AS $$
  SELECT c.x, c.y, c.crdb_region, p.crdb_region
  FROM child c LEFT JOIN parent_unique_nullable p ON c.x = p.x AND c.y = p.y;
$$ LANGUAGE SQL STABLE;

# The non-null region column prevents setting other FK columns to NULL.
statement error pgcode 23503 pq: insert on table "child" violates foreign key constraint "foo"\nDETAIL: MATCH FULL does not allow mixing of null and nonnull key values
INSERT INTO child (VALUES (NULL, NULL), (NULL, NULL))

statement ok
INSERT INTO child (VALUES (1, 10), (2, 20), (3, 30), (4, 40), (5, 50), (6, 60))

query IITT colnames
SELECT * FROM display_child() ORDER BY x, y, child_region
----
x  y   child_region    parent_region
1  10  ca-central-1    ca-central-1
2  20  ap-southeast-2  ap-southeast-2
3  30  us-east-1       us-east-1
4  40  ca-central-1    ca-central-1
5  50  ap-southeast-2  ap-southeast-2
6  60  us-east-1       us-east-1

statement ok
UPDATE child SET x = 3, y = 30 WHERE x = 5 OR x = 6;

query IITT colnames
SELECT * FROM display_child() ORDER BY x, y, child_region
----
x  y   child_region    parent_region
1  10  ca-central-1    ca-central-1
2  20  ap-southeast-2  ap-southeast-2
3  30  us-east-1       us-east-1
3  30  us-east-1       us-east-1
3  30  us-east-1       us-east-1
4  40  ca-central-1    ca-central-1

statement error pgcode 23503 pq: update on table "child" violates foreign key constraint "foo"\nDETAIL: MATCH FULL does not allow mixing of null and nonnull key values
UPDATE child SET x = NULL WHERE x = 3;

statement ok
DROP FUNCTION display_child;

statement ok
DROP TABLE child;

subtest end

# ==============================================================================
# Test with unvalidated foreign key constraint.
# ==============================================================================

subtest rbr_unvalidated_fk

statement ok
SET create_table_with_schema_locked = false;

statement ok
CREATE TABLE child (
  x INT,
  y INT
) LOCALITY REGIONAL BY ROW;

statement ok
RESET create_table_with_schema_locked;

statement ok
INSERT INTO child (VALUES (0, 0), (4, 40), (7, 70))

# The NOT VALID foreign key constraint allows existing rows that do not
# satisfy the foreign key condition. However, the FK constraint is still used
# to determine the region column for child rows that have matches.
statement ok
ALTER TABLE child ADD CONSTRAINT foo FOREIGN KEY (crdb_region, x, y) REFERENCES parent_unique_nullable (crdb_region, x, y) NOT VALID

statement ok
ALTER TABLE child SET (infer_rbr_region_col_using_constraint = 'foo');

statement ok
INSERT INTO child (VALUES (1, 10), (2, 20), (3, 30), (5, 50), (6, 60), (NULL, 80), (NULL, NULL))

statement ok
CREATE FUNCTION display_child() RETURNS TABLE (
  x INT,
  y INT,
  child_region crdb_internal_region,
  parent_region crdb_internal_region
) AS $$
  SELECT c.x, c.y, c.crdb_region, p.crdb_region
  FROM child c LEFT JOIN parent_unique_nullable p ON c.x = p.x AND c.y = p.y;
$$ LANGUAGE SQL STABLE;

# Note the row for which x = 4, which was inserted before the storage param
# was set.
query IITT colnames
SELECT * FROM display_child() ORDER BY x, y, child_region
----
x     y     child_region    parent_region
NULL  NULL  ap-southeast-2  NULL
NULL  80    ap-southeast-2  NULL
0     0     ap-southeast-2  NULL
1     10    ca-central-1    ca-central-1
2     20    ap-southeast-2  ap-southeast-2
3     30    us-east-1       us-east-1
4     40    ap-southeast-2  ca-central-1
5     50    ap-southeast-2  ap-southeast-2
6     60    us-east-1       us-east-1
7     70    ap-southeast-2  NULL

# Updating the x = 4 row causes it to use the region from the parent table.
statement ok
UPDATE child SET y = 40 WHERE x = 4;

query IITT colnames
SELECT * FROM display_child() ORDER BY x, y, child_region
----
x     y     child_region    parent_region
NULL  NULL  ap-southeast-2  NULL
NULL  80    ap-southeast-2  NULL
0     0     ap-southeast-2  NULL
1     10    ca-central-1    ca-central-1
2     20    ap-southeast-2  ap-southeast-2
3     30    us-east-1       us-east-1
4     40    ca-central-1    ca-central-1
5     50    ap-southeast-2  ap-southeast-2
6     60    us-east-1       us-east-1
7     70    ap-southeast-2  NULL

statement ok
UPDATE child SET x = 3, y = 30 WHERE x IS NULL;

query IITT colnames
SELECT * FROM display_child() ORDER BY x, y, child_region
----
x  y   child_region    parent_region
0  0   ap-southeast-2  NULL
1  10  ca-central-1    ca-central-1
2  20  ap-southeast-2  ap-southeast-2
3  30  us-east-1       us-east-1
3  30  us-east-1       us-east-1
3  30  us-east-1       us-east-1
4  40  ca-central-1    ca-central-1
5  50  ap-southeast-2  ap-southeast-2
6  60  us-east-1       us-east-1
7  70  ap-southeast-2  NULL

statement ok
UPDATE child SET x = NULL WHERE x = 3;

query IITT colnames
SELECT * FROM display_child() ORDER BY x, y, child_region
----
x     y   child_region    parent_region
NULL  30  us-east-1       NULL
NULL  30  us-east-1       NULL
NULL  30  us-east-1       NULL
0     0   ap-southeast-2  NULL
1     10  ca-central-1    ca-central-1
2     20  ap-southeast-2  ap-southeast-2
4     40  ca-central-1    ca-central-1
5     50  ap-southeast-2  ap-southeast-2
6     60  us-east-1       us-east-1
7     70  ap-southeast-2  NULL

statement ok
DROP FUNCTION display_child;

statement ok
DROP TABLE child;

subtest end

# ==============================================================================
# Test interaction with computed columns.
# ==============================================================================

subtest rbr_computed_columns

# Create a child table with a computed column in the foreign key constraint.
statement ok
CREATE TABLE child (
  x INT,
  y INT GENERATED ALWAYS AS (x * 10) STORED,
  z INT AS (-x) VIRTUAL,
  CONSTRAINT foo FOREIGN KEY (crdb_region, x, y) REFERENCES parent_unique_nullable (crdb_region, x, y)
) WITH (infer_rbr_region_col_using_constraint = 'foo') LOCALITY REGIONAL BY ROW;

statement ok
CREATE FUNCTION display_child() RETURNS TABLE (
  x INT,
  y INT,
  z INT,
  child_region crdb_internal_region,
  parent_region crdb_internal_region
) AS $$
  SELECT c.x, c.y, c.z, c.crdb_region, p.crdb_region
  FROM child c LEFT JOIN parent_unique_nullable p ON c.x = p.x AND c.y = p.y;
$$ LANGUAGE SQL STABLE;

statement ok
INSERT INTO child (VALUES (1), (2), (3), (4), (5), (6), (NULL), (NULL));

query IIITT colnames
SELECT * FROM display_child() ORDER BY x, y, z, child_region
----
x     y     z     child_region    parent_region
NULL  NULL  NULL  ap-southeast-2  NULL
NULL  NULL  NULL  ap-southeast-2  NULL
1     10    -1    ca-central-1    ca-central-1
2     20    -2    ap-southeast-2  ap-southeast-2
3     30    -3    us-east-1       us-east-1
4     40    -4    ca-central-1    ca-central-1
5     50    -5    ap-southeast-2  ap-southeast-2
6     60    -6    us-east-1       us-east-1

statement ok
UPDATE child SET x = 4 WHERE x IS NULL;

query IIITT colnames
SELECT * FROM display_child() ORDER BY x, y, z, child_region
----
x  y   z   child_region    parent_region
1  10  -1  ca-central-1    ca-central-1
2  20  -2  ap-southeast-2  ap-southeast-2
3  30  -3  us-east-1       us-east-1
4  40  -4  ca-central-1    ca-central-1
4  40  -4  ca-central-1    ca-central-1
4  40  -4  ca-central-1    ca-central-1
5  50  -5  ap-southeast-2  ap-southeast-2
6  60  -6  us-east-1       us-east-1

statement ok
UPDATE child SET x = NULL WHERE x = 4 OR x = 2;

query IIITT colnames
SELECT * FROM display_child() ORDER BY x, y, z, child_region
----
x     y     z     child_region    parent_region
NULL  NULL  NULL  ap-southeast-2  NULL
NULL  NULL  NULL  ca-central-1    NULL
NULL  NULL  NULL  ca-central-1    NULL
NULL  NULL  NULL  ca-central-1    NULL
1     10    -1    ca-central-1    ca-central-1
3     30    -3    us-east-1       us-east-1
5     50    -5    ap-southeast-2  ap-southeast-2
6     60    -6    us-east-1       us-east-1

statement ok
DROP FUNCTION display_child;

statement ok
DROP TABLE child;

subtest end

# ==============================================================================
# Test interaction with check constraints.
# ==============================================================================

subtest rbr_check_constraints

# Create a child table with a check constraint that references the region column.
statement ok
CREATE TABLE child (
  k INT,
  CONSTRAINT foo FOREIGN KEY (crdb_region, k) REFERENCES parent_rbr (crdb_region, k),
  CONSTRAINT check_region CHECK (crdb_region IN ('ap-southeast-2', 'ca-central-1'))
) WITH (infer_rbr_region_col_using_constraint = 'foo') LOCALITY REGIONAL BY ROW;

statement ok
CREATE FUNCTION display_child() RETURNS TABLE (
  k INT,
  child_region crdb_internal_region,
  parent_region crdb_internal_region
) AS $$
  SELECT c.k, c.crdb_region, p.crdb_region
  FROM child c LEFT JOIN parent_rbr p ON c.k = p.k;
$$ LANGUAGE SQL STABLE;

statement ok
INSERT INTO child (VALUES (1), (2), (4), (5), (NULL), (NULL));

# The check constraint prevents inserting rows in the 'us-east-1' region.
statement error pgcode 23514 pq: failed to satisfy CHECK constraint \(crdb_region IN \('ap-southeast-2':::public.crdb_internal_region, 'ca-central-1':::public.crdb_internal_region\)\)
INSERT INTO child (VALUES (3), (6));

query ITT colnames
SELECT * FROM display_child() ORDER BY k, child_region
----
k     child_region    parent_region
NULL  ap-southeast-2  NULL
NULL  ap-southeast-2  NULL
1     ca-central-1    ca-central-1
2     ap-southeast-2  ap-southeast-2
4     ca-central-1    ca-central-1
5     ap-southeast-2  ap-southeast-2

statement ok
DROP FUNCTION display_child;

statement ok
DROP TABLE child;

subtest end

# ==============================================================================
# Test interaction with row-level security.
# ==============================================================================

subtest rbr_row_level_security

# Create a child table with a row-level security policy that references the region column.
statement ok
CREATE TABLE child (
  k INT,
  CONSTRAINT foo FOREIGN KEY (crdb_region, k) REFERENCES parent_rbr (crdb_region, k)
) WITH (infer_rbr_region_col_using_constraint = 'foo') LOCALITY REGIONAL BY ROW;

statement ok
CREATE FUNCTION display_child() RETURNS TABLE (
  k INT,
  child_region crdb_internal_region,
  parent_region crdb_internal_region
) AS $$
  SELECT c.k, c.crdb_region, p.crdb_region
  FROM child c LEFT JOIN parent_rbr p ON c.k = p.k;
$$ LANGUAGE SQL STABLE;

statement ok
ALTER TABLE child FORCE ROW LEVEL SECURITY, ENABLE ROW LEVEL SECURITY;

# Create a row-level security policy that allows access only to rows in the
# (primary) 'ap-southeast-2' region.
statement ok
CREATE POLICY rls_policy ON child FOR ALL TO PUBLIC
USING (crdb_region = 'ap-southeast-2') WITH CHECK (crdb_region = 'ap-southeast-2');

statement ok
CREATE USER test_user;

statement ok
GRANT SELECT, INSERT, UPDATE, DELETE ON child TO test_user;

statement ok
GRANT SELECT, INSERT, UPDATE, DELETE ON parent_rbr TO test_user;

statement ok
GRANT ALL ON FUNCTION display_child TO test_user;

statement ok
SET ROLE test_user;

statement ok
INSERT INTO child (VALUES (2), (5), (NULL), (NULL));

query ITT colnames
SELECT * FROM display_child() ORDER BY k, child_region
----
k     child_region    parent_region
NULL  ap-southeast-2  NULL
NULL  ap-southeast-2  NULL
2     ap-southeast-2  ap-southeast-2
5     ap-southeast-2  ap-southeast-2

statement error pgcode 42501 pq: new row violates row-level security policy for table "child"
INSERT INTO child (VALUES (1), (3), (4), (6));

statement ok
SET ROLE root

statement ok
DROP FUNCTION display_child;

statement ok
DROP TABLE child;

# ==============================================================================
# Test interaction with partial indexes.
# ==============================================================================

subtest partial_indexes

# Create a child table with a partial index that references the region column.
statement ok
CREATE TABLE child (
  k INT,
  CONSTRAINT foo FOREIGN KEY (crdb_region, k) REFERENCES parent_rbr (crdb_region, k),
  INDEX idx_partial (k) WHERE crdb_region = 'ap-southeast-2'
) WITH (infer_rbr_region_col_using_constraint = 'foo') LOCALITY REGIONAL BY ROW;

statement ok
CREATE FUNCTION display_child() RETURNS TABLE (
  k INT,
  child_region crdb_internal_region,
  parent_region crdb_internal_region
) AS $$
  SELECT c.k, c.crdb_region, p.crdb_region
  FROM child c LEFT JOIN parent_rbr p ON c.k = p.k;
$$ LANGUAGE SQL STABLE;

statement ok
INSERT INTO child (VALUES (1), (2), (3), (4), (5), (6), (NULL), (NULL));

query ITT colnames
SELECT * FROM display_child() ORDER BY k, child_region
----
k     child_region    parent_region
NULL  ap-southeast-2  NULL
NULL  ap-southeast-2  NULL
1     ca-central-1    ca-central-1
2     ap-southeast-2  ap-southeast-2
3     us-east-1       us-east-1
4     ca-central-1    ca-central-1
5     ap-southeast-2  ap-southeast-2
6     us-east-1       us-east-1

query I
SELECT k FROM child@idx_partial WHERE crdb_region = 'ap-southeast-2' ORDER BY k
----
NULL
NULL
2
5

statement ok
UPDATE child SET k = 2 WHERE k = 1 OR k = 3;

query ITT colnames
SELECT * FROM display_child() ORDER BY k, child_region
----
k     child_region    parent_region
NULL  ap-southeast-2  NULL
NULL  ap-southeast-2  NULL
2     ap-southeast-2  ap-southeast-2
2     ap-southeast-2  ap-southeast-2
2     ap-southeast-2  ap-southeast-2
4     ca-central-1    ca-central-1
5     ap-southeast-2  ap-southeast-2
6     us-east-1       us-east-1

query I
SELECT k FROM child@idx_partial WHERE crdb_region = 'ap-southeast-2' ORDER BY k
----
NULL
NULL
2
2
2
5

statement ok
DROP FUNCTION display_child;

statement ok
DROP TABLE child;

subtest end

# ==============================================================================
# Test interaction with triggers.
# ==============================================================================

subtest rbr_triggers

# Create a child table with BEFORE and AFTER triggers that reference the
# region column. NOTE: until #133331 is addressed, the crdb_region column
# must be made visible for it to be displayed by a trigger.
statement ok
CREATE TABLE child (
  k INT,
  crdb_region crdb_internal_region NOT NULL DEFAULT gateway_region()::crdb_internal_region,
  CONSTRAINT foo FOREIGN KEY (crdb_region, k) REFERENCES parent_rbr (crdb_region, k)
) WITH (infer_rbr_region_col_using_constraint = 'foo') LOCALITY REGIONAL BY ROW;

statement ok
CREATE FUNCTION trigger_fn() RETURNS TRIGGER AS $$
  BEGIN
    RAISE NOTICE '% trigger: old: % -> new: %', TG_WHEN, OLD, NEW;
    RETURN NEW;
  END;
$$ LANGUAGE PLpgSQL;

statement ok
CREATE TRIGGER before_trigger BEFORE INSERT OR UPDATE ON child FOR EACH ROW EXECUTE FUNCTION trigger_fn();

statement ok
CREATE TRIGGER after_trigger AFTER INSERT OR UPDATE ON child FOR EACH ROW EXECUTE FUNCTION trigger_fn();

# The region-column lookup happens after BEFORE triggers execute, so the
# looked-up value is only visible to AFTER triggers. BEFORE triggers see the
# default value 'ap-southeast-2' instead.
query T noticetrace
INSERT INTO child (VALUES (1), (2), (3), (NULL));
----
NOTICE: BEFORE trigger: old: <NULL> -> new: (1,ap-southeast-2)
NOTICE: BEFORE trigger: old: <NULL> -> new: (2,ap-southeast-2)
NOTICE: BEFORE trigger: old: <NULL> -> new: (3,ap-southeast-2)
NOTICE: BEFORE trigger: old: <NULL> -> new: (,ap-southeast-2)
NOTICE: AFTER trigger: old: <NULL> -> new: (2,ap-southeast-2)
NOTICE: AFTER trigger: old: <NULL> -> new: (1,ca-central-1)
NOTICE: AFTER trigger: old: <NULL> -> new: (3,us-east-1)
NOTICE: AFTER trigger: old: <NULL> -> new: (,ap-southeast-2)

query T noticetrace
UPDATE child SET k = 4 WHERE k IS NULL;
----
NOTICE: BEFORE trigger: old: (,ap-southeast-2) -> new: (4,ap-southeast-2)
NOTICE: AFTER trigger: old: (,ap-southeast-2) -> new: (4,ca-central-1)

query T noticetrace
UPDATE child SET k = NULL WHERE k = 4 OR k = 2;
----
NOTICE: BEFORE trigger: old: (2,ap-southeast-2) -> new: (,ap-southeast-2)
NOTICE: BEFORE trigger: old: (4,ca-central-1) -> new: (,ca-central-1)
NOTICE: AFTER trigger: old: (2,ap-southeast-2) -> new: (,ap-southeast-2)
NOTICE: AFTER trigger: old: (4,ca-central-1) -> new: (,ca-central-1)

query ITT colnames
SELECT c.k, c.crdb_region AS child_region, p.crdb_region AS parent_region
FROM child c LEFT JOIN parent_rbr p ON c.k = p.k
ORDER BY c.k, c.crdb_region;
----
k     child_region    parent_region
NULL  ap-southeast-2  NULL
NULL  ca-central-1    NULL
1     ca-central-1    ca-central-1
3     us-east-1       us-east-1

statement ok
DROP TABLE child;

statement ok
DROP FUNCTION trigger_fn;

subtest end

# ==============================================================================
# Show interaction with cascade actions.
# ==============================================================================

subtest rbr_cascade_actions

statement error pgcode 42830 pq: cannot add a SET NULL cascading action on column "multi_region_test_db.public.child.crdb_region" which has a NOT NULL constraint
CREATE TABLE child (
  k INT,
  v INT,
  CONSTRAINT foo FOREIGN KEY (crdb_region, k) REFERENCES parent_rbr (crdb_region, k) ON UPDATE SET NULL ON DELETE SET NULL
) WITH (infer_rbr_region_col_using_constraint = 'foo') LOCALITY REGIONAL BY ROW;

statement ok
CREATE TABLE parent_cascade (k INT PRIMARY KEY) LOCALITY REGIONAL BY ROW;

statement ok
INSERT INTO parent_cascade (k, crdb_region) (SELECT k, crdb_region FROM parent_rbr);

statement ok
CREATE TABLE child (
  k INT,
  v INT DEFAULT 1000,
  CONSTRAINT foo FOREIGN KEY (crdb_region, k) REFERENCES parent_cascade (crdb_region, k) ON UPDATE SET DEFAULT ON DELETE SET DEFAULT
) WITH (infer_rbr_region_col_using_constraint = 'foo') LOCALITY REGIONAL BY ROW;

statement ok
CREATE FUNCTION display_child() RETURNS TABLE (
  k INT,
  v INT,
  child_region crdb_internal_region,
  parent_cascade_region crdb_internal_region
) AS $$
  SELECT c.k, c.v, c.crdb_region, cd.crdb_region
  FROM child c LEFT JOIN parent_cascade cd ON c.k = cd.k;
$$ LANGUAGE SQL STABLE;

statement ok
INSERT INTO child (VALUES (1, 10), (2, 20), (3, 30), (4, 40), (5, 50), (6, 60));

query IITT colnames
SELECT * FROM display_child() ORDER BY k, v, child_region
----
k  v   child_region    parent_cascade_region
1  10  ca-central-1    ca-central-1
2  20  ap-southeast-2  ap-southeast-2
3  30  us-east-1       us-east-1
4  40  ca-central-1    ca-central-1
5  50  ap-southeast-2  ap-southeast-2
6  60  us-east-1       us-east-1

statement count 2
DELETE FROM parent_cascade WHERE k = 3 OR k = 4;

query IITT colnames
SELECT * FROM display_child() ORDER BY k, v, child_region
----
k     v   child_region    parent_cascade_region
NULL  30  ap-southeast-2  NULL
NULL  40  ap-southeast-2  NULL
1     10  ca-central-1    ca-central-1
2     20  ap-southeast-2  ap-southeast-2
5     50  ap-southeast-2  ap-southeast-2
6     60  us-east-1       us-east-1

statement ok
UPDATE parent_cascade SET k = k + 2 WHERE k = 1 OR k = 2;

query IITT colnames
SELECT * FROM display_child() ORDER BY k, v, child_region
----
k     v   child_region    parent_cascade_region
NULL  10  ap-southeast-2  NULL
NULL  20  ap-southeast-2  NULL
NULL  30  ap-southeast-2  NULL
NULL  40  ap-southeast-2  NULL
5     50  ap-southeast-2  ap-southeast-2
6     60  us-east-1       us-east-1

statement ok
DROP FUNCTION display_child;

statement ok
DROP TABLE child;

statement count 4
DELETE FROM parent_cascade WHERE true;

statement ok
INSERT INTO parent_cascade (k, crdb_region) (SELECT k, crdb_region FROM parent_rbr);

statement ok
CREATE TABLE child (
  k1 INT,
  k2 INT,
  v INT DEFAULT 1000,
  CONSTRAINT foo FOREIGN KEY (crdb_region, k1) REFERENCES parent_rbr (crdb_region, k) ON UPDATE CASCADE ON DELETE CASCADE,
  CONSTRAINT bar FOREIGN KEY (crdb_region, k2) REFERENCES parent_cascade (crdb_region, k) ON UPDATE CASCADE ON DELETE CASCADE
) WITH (infer_rbr_region_col_using_constraint = 'foo') LOCALITY REGIONAL BY ROW;

statement ok
CREATE FUNCTION display_child() RETURNS TABLE (
  k1 INT,
  k2 INT,
  v INT,
  child_region crdb_internal_region,
  parent_rbr_region crdb_internal_region,
  parent_cascade_region crdb_internal_region
) AS $$
  SELECT c.k1, c.k2, c.v, c.crdb_region, rbr.crdb_region, cd.crdb_region
  FROM child c LEFT JOIN parent_rbr rbr ON c.k1 = rbr.k LEFT JOIN parent_cascade cd ON c.k2 = cd.k;
$$ LANGUAGE SQL STABLE;

statement ok
INSERT INTO child (VALUES (1, 1, 10), (2, 2, 20), (3, 3, 30), (4, 4, 40), (5, 5, 50), (6, 6, 60));

query IIITTT colnames
SELECT * FROM display_child() ORDER BY k1, k2, v, child_region
----
k1  k2  v   child_region    parent_rbr_region  parent_cascade_region
1   1   10  ca-central-1    ca-central-1       ca-central-1
2   2   20  ap-southeast-2  ap-southeast-2     ap-southeast-2
3   3   30  us-east-1       us-east-1          us-east-1
4   4   40  ca-central-1    ca-central-1       ca-central-1
5   5   50  ap-southeast-2  ap-southeast-2     ap-southeast-2
6   6   60  us-east-1       us-east-1          us-east-1

statement count 2
DELETE FROM parent_cascade WHERE k = 3 OR k = 4;

query IIITTT colnames
SELECT * FROM display_child() ORDER BY k1, k2, v, child_region
----
k1  k2  v   child_region    parent_rbr_region  parent_cascade_region
1   1   10  ca-central-1    ca-central-1       ca-central-1
2   2   20  ap-southeast-2  ap-southeast-2     ap-southeast-2
5   5   50  ap-southeast-2  ap-southeast-2     ap-southeast-2
6   6   60  us-east-1       us-east-1          us-east-1

statement ok
UPDATE parent_cascade SET k = k + 2 WHERE k = 1 OR k = 2;

query IIITTT colnames
SELECT * FROM display_child() ORDER BY k1, k2, v, child_region
----
k1  k2  v   child_region    parent_rbr_region  parent_cascade_region
1   3   10  ca-central-1    ca-central-1       ca-central-1
2   4   20  ap-southeast-2  ap-southeast-2     ap-southeast-2
5   5   50  ap-southeast-2  ap-southeast-2     ap-southeast-2
6   6   60  us-east-1       us-east-1          us-east-1

statement ok
DROP FUNCTION display_child;

statement ok
DROP TABLE child;

statement ok
DROP TABLE parent_cascade;

subtest end

# ==============================================================================
# Show implicit locking behavior.
# ==============================================================================

# TODO(yuzefovich): EXPLAIN tests should be moved to execbuilder.

subtest rbr_implicit_locking

# TODO(drewk): we could push the implicit locking below the LeftJoin added for
# region column lookup, since it doesn't filter any child rows.
statement ok
CREATE TABLE child (
  k INT,
  INDEX (k),
  CONSTRAINT foo FOREIGN KEY (crdb_region, k) REFERENCES parent_rbr (crdb_region, k),
  FAMILY (k, crdb_region, rowid)
) WITH (infer_rbr_region_col_using_constraint = 'foo') LOCALITY REGIONAL BY ROW;

onlyif config multiregion-9node-3region-3azs
query T
EXPLAIN (VERBOSE) UPSERT INTO child (k) VALUES (4);
----
distribution: local
vectorized: true

 root
 columns: ()

  upsert
    columns: ()
    estimated row count: 0 (missing stats)
    into: child(k, crdb_region, rowid)
    arbiter constraints: child_pkey
   
     buffer
        columns: (column1, fk_lookup_crdb_region, rowid_default, k, crdb_region, rowid, column1, fk_lookup_crdb_region, crdb_region, check1)
        label: buffer 1
       
         project
            columns: (column1, fk_lookup_crdb_region, rowid_default, k, crdb_region, rowid, column1, fk_lookup_crdb_region, crdb_region, check1)
           
             render
                columns: (check1, column1, rowid_default, k, crdb_region, rowid, fk_lookup_crdb_region)
                render check1: fk_lookup_crdb_region IN ('ap-southeast-2', 'ca-central-1', 'us-east-1')
                render column1: column1
                render rowid_default: rowid_default
                render k: k
                render crdb_region: crdb_region
                render rowid: rowid
                render fk_lookup_crdb_region: fk_lookup_crdb_region
               
                 render
                    columns: (fk_lookup_crdb_region, column1, rowid_default, k, crdb_region, rowid)
                    render fk_lookup_crdb_region: CASE WHEN crdb_region IS NOT DISTINCT FROM CAST(NULL AS public.crdb_internal_region) THEN crdb_region ELSE crdb_region END
                    render column1: column1
                    render rowid_default: rowid_default
                    render k: k
                    render crdb_region: crdb_region
                    render rowid: rowid
                   
                     lookup join (left outer)
                        columns: (column1, rowid_default, k, crdb_region, k, crdb_region, rowid)
                        estimated row count: 1 (missing stats)
                        table: child@child_pkey
                        equality cols are key
                        lookup condition: (crdb_region IN ('ap-southeast-2', 'ca-central-1', 'us-east-1')) AND (rowid_default = rowid)
                        parallel
                       
                         lookup join (left outer)
                            columns: (column1, rowid_default, k, crdb_region)
                            estimated row count: 1 (missing stats)
                            table: parent_rbr@parent_rbr_pkey
                            equality cols are key
                            lookup condition: (crdb_region = 'ap-southeast-2') AND (column1 = k)
                            remote lookup condition: (crdb_region IN ('ca-central-1', 'us-east-1')) AND (column1 = k)
                            parallel
                           
                             values
                                 columns: (column1, rowid_default)
                                 size: 2 columns, 1 row
                                 row 0, expr 0: 4
                                 row 0, expr 1: unique_rowid()

  constraint-check
    
      error if rows
         columns: ()
        
          lookup join (anti)
             columns: (fk_lookup_crdb_region, column1)
             estimated row count: 1 (missing stats)
             table: parent_rbr@parent_rbr_pkey
             equality: (fk_lookup_crdb_region, column1) = (crdb_region, k)
             equality cols are key
             parallel
            
              project
                 columns: (fk_lookup_crdb_region, column1)
                
                  scan buffer
                      columns: (column1, fk_lookup_crdb_region, rowid_default, k, crdb_region, rowid, column1, fk_lookup_crdb_region, crdb_region, check1)
                      estimated row count: 1 (missing stats)
                      label: buffer 1

onlyif config multiregion-9node-3region-3azs
query T
EXPLAIN (VERBOSE) UPDATE child SET k = 4 WHERE k = 3;
----
distribution: local
vectorized: true

 root
 columns: ()

  update
    columns: ()
    estimated row count: 0 (missing stats)
    table: child
    set: k, crdb_region
   
     buffer
        columns: (k, crdb_region, rowid, k_new, fk_lookup_crdb_region, check1)
        label: buffer 1
       
         render
            columns: (k, crdb_region, rowid, k_new, fk_lookup_crdb_region, check1)
            render check1: fk_lookup_crdb_region IN ('ap-southeast-2', 'ca-central-1', 'us-east-1')
            render k: k
            render crdb_region: crdb_region
            render rowid: rowid
            render k_new: k_new
            render fk_lookup_crdb_region: fk_lookup_crdb_region
           
             render
                columns: (fk_lookup_crdb_region, k_new, k, crdb_region, rowid)
                render fk_lookup_crdb_region: CASE WHEN crdb_region IS NOT DISTINCT FROM CAST(NULL AS public.crdb_internal_region) THEN crdb_region ELSE crdb_region END
                render k_new: 4
                render k: k
                render crdb_region: crdb_region
                render rowid: rowid
               
                 cross join (left outer)
                    columns: (k, crdb_region, rowid, k, crdb_region)
                    estimated row count: 10 (missing stats)
                   
                     scan
                        columns: (k, crdb_region, rowid)
                        estimated row count: 10 (missing stats)
                        table: child@child_k_idx
                        spans: /"@"/3-/"@"/4 /"\x80"/3-/"\x80"/4 /"\xc0"/3-/"\xc0"/4
                   
                     union all
                        columns: (k, crdb_region)
                        estimated row count: 1 (missing stats)
                        limit: 1
                       
                         scan
                            columns: (k, crdb_region)
                            estimated row count: 1 (missing stats)
                            table: parent_rbr@parent_rbr_pkey
                            spans: /"@"/4/0
                       
                         scan
                             columns: (k, crdb_region)
                             estimated row count: 1 (missing stats)
                             table: parent_rbr@parent_rbr_pkey
                             spans: /"\x80"/4/0 /"\xc0"/4/0
                             parallel

  constraint-check
    
      error if rows
         columns: ()
        
          lookup join (anti)
             columns: (fk_lookup_crdb_region, k_new)
             estimated row count: 1 (missing stats)
             table: parent_rbr@parent_rbr_pkey
             equality: (fk_lookup_crdb_region, k_new) = (crdb_region, k)
             equality cols are key
             parallel
            
              project
                 columns: (fk_lookup_crdb_region, k_new)
                
                  scan buffer
                      columns: (k, crdb_region, rowid, k_new, fk_lookup_crdb_region, check1)
                      estimated row count: 10 (missing stats)
                      label: buffer 1

statement ok
DROP TABLE child;

subtest end

# ==============================================================================
# Show interaction with read committed isolation.
# ==============================================================================

subtest rbr_read_committed

statement ok
CREATE TABLE child (
  x INT,
  y INT,
  CONSTRAINT foo FOREIGN KEY (crdb_region, x, y) REFERENCES parent_unique_nullable (crdb_region, x, y),
  FAMILY (x, y, crdb_region, rowid)
) WITH (infer_rbr_region_col_using_constraint = 'foo') LOCALITY REGIONAL BY ROW;

statement ok
CREATE FUNCTION display_child() RETURNS TABLE (
  x INT,
  y INT,
  child_region crdb_internal_region,
  parent_region crdb_internal_region
) AS $$
  SELECT c.x, c.y, c.crdb_region, p.crdb_region
  FROM child c LEFT JOIN parent_unique_nullable p ON c.x = p.x AND c.y = p.y;
$$ LANGUAGE SQL STABLE;

statement ok
BEGIN ISOLATION LEVEL READ COMMITTED;

# Running in read-committed isolation causes the lookup to use shared locking.
onlyif config multiregion-9node-3region-3azs
query T
EXPLAIN (VERBOSE) INSERT INTO child (VALUES (1, 2));
----
distribution: local
vectorized: true

 root
 columns: ()

  insert
    columns: ()
    estimated row count: 0 (missing stats)
    into: child(x, y, crdb_region, rowid)
    uniqueness checks (tombstones): child_pkey
   
     buffer
        columns: (column1, column2, fk_lookup_crdb_region, rowid_default, check1, crdb_region_default)
        label: buffer 1
       
         render
            columns: (column1, column2, fk_lookup_crdb_region, rowid_default, check1, crdb_region_default)
            render check1: fk_lookup_crdb_region IN ('ap-southeast-2', 'ca-central-1', 'us-east-1')
            render column1: column1
            render column2: column2
            render crdb_region_default: crdb_region_default
            render rowid_default: rowid_default
            render fk_lookup_crdb_region: fk_lookup_crdb_region
           
             render
                columns: (fk_lookup_crdb_region, column1, column2, crdb_region_default, rowid_default)
                render fk_lookup_crdb_region: CASE WHEN crdb_region IS NOT DISTINCT FROM CAST(NULL AS public.crdb_internal_region) THEN crdb_region_default ELSE crdb_region END
                render column1: column1
                render column2: column2
                render crdb_region_default: crdb_region_default
                render rowid_default: rowid_default
               
                 cross join (left outer)
                    columns: (column1, column2, crdb_region_default, rowid_default, x, y, crdb_region)
                    estimated row count: 1 (missing stats)
                   
                     values
                        columns: (column1, column2, crdb_region_default, rowid_default)
                        size: 4 columns, 1 row
                        row 0, expr 0: 1
                        row 0, expr 1: 2
                        row 0, expr 2: 'ap-southeast-2'
                        row 0, expr 3: unique_rowid()
                   
                     union all
                        columns: (x, y, crdb_region)
                        estimated row count: 1 (missing stats)
                        limit: 1
                       
                         scan
                            columns: (x, y, crdb_region)
                            estimated row count: 1 (missing stats)
                            table: parent_unique_nullable@parent_unique_nullable_x_y_key
                            spans: /"@"/1/2/0
                            locking strength: for share
                            locking durability: guaranteed
                       
                         scan
                             columns: (x, y, crdb_region)
                             estimated row count: 1 (missing stats)
                             table: parent_unique_nullable@parent_unique_nullable_x_y_key
                             spans: /"\x80"/1/2/0 /"\xc0"/1/2/0
                             parallel
                             locking strength: for share
                             locking durability: guaranteed

  constraint-check
    
      error if rows
         columns: ()
        
          lookup join (anti)
             columns: (fk_lookup_crdb_region, column1, column2)
             estimated row count: 1 (missing stats)
             table: parent_unique_nullable@parent_unique_nullable_x_y_key
             equality: (fk_lookup_crdb_region, column1, column2) = (crdb_region, x, y)
             equality cols are key
             locking strength: for share
             locking durability: guaranteed
             parallel
            
              project
                 columns: (fk_lookup_crdb_region, column1, column2)
                
                  scan buffer
                      columns: (column1, column2, fk_lookup_crdb_region, rowid_default, check1, crdb_region_default)
                      estimated row count: 1 (missing stats)
                      label: buffer 1

statement ok
INSERT INTO child (VALUES (1, NULL), (2, 20), (3, 30), (4, 40), (5, 50), (NULL, 60), (NULL, NULL), (NULL, NULL))

query IITT colnames
SELECT * FROM display_child() ORDER BY x, y, child_region
----
x     y     child_region    parent_region
NULL  NULL  ap-southeast-2  NULL
NULL  NULL  ap-southeast-2  NULL
NULL  60    ap-southeast-2  NULL
1     NULL  ap-southeast-2  NULL
2     20    ap-southeast-2  ap-southeast-2
3     30    us-east-1       us-east-1
4     40    ca-central-1    ca-central-1
5     50    ap-southeast-2  ap-southeast-2

statement ok
COMMIT;

query IITT colnames
SELECT * FROM display_child() ORDER BY x, y, child_region
----
x     y     child_region    parent_region
NULL  NULL  ap-southeast-2  NULL
NULL  NULL  ap-southeast-2  NULL
NULL  60    ap-southeast-2  NULL
1     NULL  ap-southeast-2  NULL
2     20    ap-southeast-2  ap-southeast-2
3     30    us-east-1       us-east-1
4     40    ca-central-1    ca-central-1
5     50    ap-southeast-2  ap-southeast-2

statement ok
BEGIN ISOLATION LEVEL READ COMMITTED;

# Running in read-committed isolation causes the lookup to use shared locking.
onlyif config multiregion-9node-3region-3azs
query T
EXPLAIN (VERBOSE) UPDATE child SET y = x * 10 WHERE y IS NULL
----
distribution: local
vectorized: true

 root
 columns: ()

  update
    columns: ()
    estimated row count: 0 (missing stats)
    table: child
    set: y, crdb_region
   
     buffer
        columns: (x, y, crdb_region, rowid, y_new, fk_lookup_crdb_region, check1)
        label: buffer 1
       
         render
            columns: (x, y, crdb_region, rowid, y_new, fk_lookup_crdb_region, check1)
            render check1: fk_lookup_crdb_region IN ('ap-southeast-2', 'ca-central-1', 'us-east-1')
            render x: x
            render y: y
            render crdb_region: crdb_region
            render rowid: rowid
            render y_new: y_new
            render fk_lookup_crdb_region: fk_lookup_crdb_region
           
             render
                columns: (fk_lookup_crdb_region, x, y, crdb_region, rowid, y_new)
                render fk_lookup_crdb_region: CASE WHEN crdb_region IS NOT DISTINCT FROM CAST(NULL AS public.crdb_internal_region) THEN crdb_region ELSE crdb_region END
                render x: x
                render y: y
                render crdb_region: crdb_region
                render rowid: rowid
                render y_new: y_new
               
                 lookup join (left outer)
                    columns: (y_new, x, y, crdb_region, rowid, x, y, crdb_region)
                    estimated row count: 10 (missing stats)
                    table: parent_unique_nullable@parent_unique_nullable_x_y_key
                    equality cols are key
                    lookup condition: ((crdb_region = 'ap-southeast-2') AND (x = x)) AND (y_new = y)
                    remote lookup condition: ((crdb_region IN ('ca-central-1', 'us-east-1')) AND (x = x)) AND (y_new = y)
                    locking strength: for share
                    locking durability: guaranteed
                    parallel
                   
                     render
                        columns: (y_new, x, y, crdb_region, rowid)
                        render y_new: x * 10
                        render x: x
                        render y: y
                        render crdb_region: crdb_region
                        render rowid: rowid
                       
                         filter
                            columns: (x, y, crdb_region, rowid)
                            estimated row count: 10 (missing stats)
                            filter: y IS NULL
                           
                             scan
                                 columns: (x, y, crdb_region, rowid)
                                 estimated row count: 1,000 (missing stats)
                                 table: child@child_pkey
                                 spans: FULL SCAN

  constraint-check
    
      error if rows
         columns: ()
        
          lookup join (anti)
             columns: (fk_lookup_crdb_region, x, y_new)
             estimated row count: 1 (missing stats)
             table: parent_unique_nullable@parent_unique_nullable_x_y_key
             equality: (fk_lookup_crdb_region, x, y_new) = (crdb_region, x, y)
             equality cols are key
             locking strength: for share
             locking durability: guaranteed
             parallel
            
              filter
                 columns: (fk_lookup_crdb_region, x, y_new)
                 estimated row count: 10 (missing stats)
                 filter: (x IS NOT NULL) AND (y_new IS NOT NULL)
                
                  project
                     columns: (fk_lookup_crdb_region, x, y_new)
                    
                      scan buffer
                          columns: (x, y, crdb_region, rowid, y_new, fk_lookup_crdb_region, check1)
                          estimated row count: 10 (missing stats)
                          label: buffer 1

statement ok
UPDATE child SET y = x * 10 WHERE y IS NULL

query IITT colnames
SELECT * FROM display_child() ORDER BY x, y, child_region
----
x     y     child_region    parent_region
NULL  NULL  ap-southeast-2  NULL
NULL  NULL  ap-southeast-2  NULL
NULL  60    ap-southeast-2  NULL
1     10    ca-central-1    ca-central-1
2     20    ap-southeast-2  ap-southeast-2
3     30    us-east-1       us-east-1
4     40    ca-central-1    ca-central-1
5     50    ap-southeast-2  ap-southeast-2

statement ok
COMMIT;

query IITT colnames
SELECT * FROM display_child() ORDER BY x, y, child_region
----
x     y     child_region    parent_region
NULL  NULL  ap-southeast-2  NULL
NULL  NULL  ap-southeast-2  NULL
NULL  60    ap-southeast-2  NULL
1     10    ca-central-1    ca-central-1
2     20    ap-southeast-2  ap-southeast-2
3     30    us-east-1       us-east-1
4     40    ca-central-1    ca-central-1
5     50    ap-southeast-2  ap-southeast-2

statement ok
DROP FUNCTION display_child;

statement ok
DROP TABLE child;

subtest end

# ==============================================================================
# Show interaction with routines.
# ==============================================================================

subtest rbr_routines

statement ok
CREATE TABLE child (
  x INT,
  y INT,
  CONSTRAINT foo FOREIGN KEY (crdb_region, x, y) REFERENCES parent_unique_nullable (crdb_region, x, y)
) WITH (infer_rbr_region_col_using_constraint = 'foo') LOCALITY REGIONAL BY ROW;

# Create a function that inserts a row into the child table.
statement ok
CREATE FUNCTION insert_child(x INT, y INT) RETURNS VOID AS $$
  INSERT INTO child (x, y) VALUES ($1, $2);
$$ LANGUAGE SQL;

# Create a function that updates a row in the child table.
statement ok
CREATE FUNCTION update_child(x INT, y INT) RETURNS VOID AS $$
  UPDATE child SET y = $2 WHERE x = $1;
$$ LANGUAGE SQL;

statement ok
CREATE FUNCTION display_child() RETURNS TABLE (
  x INT,
  y INT,
  child_region crdb_internal_region,
  parent_region crdb_internal_region
) AS $$
  SELECT c.x, c.y, c.crdb_region, p.crdb_region
  FROM child c LEFT JOIN parent_unique_nullable p ON c.x = p.x AND c.y = p.y;
$$ LANGUAGE SQL STABLE;

statement ok
SELECT insert_child(a, b) FROM (
  VALUES (1, NULL), (2, 20), (3, 30), (4, 40), (5, 50), (NULL, 60), (NULL, NULL), (NULL, NULL)
) AS t(a, b);

query IITT colnames
SELECT * FROM display_child() ORDER BY x, y, child_region
----
x     y     child_region    parent_region
NULL  NULL  ap-southeast-2  NULL
NULL  NULL  ap-southeast-2  NULL
NULL  60    ap-southeast-2  NULL
1     NULL  ap-southeast-2  NULL
2     20    ap-southeast-2  ap-southeast-2
3     30    us-east-1       us-east-1
4     40    ca-central-1    ca-central-1
5     50    ap-southeast-2  ap-southeast-2

statement ok
SELECT update_child(x, x * 10) FROM child WHERE y IS NULL;

query IITT colnames
SELECT * FROM display_child() ORDER BY x, y, child_region
----
x     y     child_region    parent_region
NULL  NULL  ap-southeast-2  NULL
NULL  NULL  ap-southeast-2  NULL
NULL  60    ap-southeast-2  NULL
1     10    ca-central-1    ca-central-1
2     20    ap-southeast-2  ap-southeast-2
3     30    us-east-1       us-east-1
4     40    ca-central-1    ca-central-1
5     50    ap-southeast-2  ap-southeast-2

statement ok
DROP FUNCTION insert_child;
DROP FUNCTION update_child;
DROP FUNCTION display_child;
DROP TABLE child;

subtest end

# ==============================================================================
# Verify that a foreign key violation causes the addition of the
# rbr_using_constraint to be reverted properly.
# ==============================================================================

subtest revert_fk_violation

statement ok
SET create_table_with_schema_locked = false;

statement ok
CREATE TABLE a (
  id uuid NOT NULL PRIMARY KEY
) LOCALITY REGIONAL BY ROW

statement ok
CREATE TABLE b (
  id uuid NOT NULL,
  a_id uuid NULL,
  CONSTRAINT b_pkey PRIMARY KEY (id ASC),
  CONSTRAINT a_id_fk FOREIGN KEY (a_id) REFERENCES a (id)
) LOCALITY REGIONAL BY ROW

# Insert data that will cause a foreign key violation when we try to add the composite FK.
statement ok
INSERT INTO a (id, crdb_region) VALUES ('4227eceb-71d6-422c-808b-6a12ec8a1e54', 'us-east-1')

statement ok
INSERT INTO b (id, a_id, crdb_region) VALUES ('8f6ce660-423e-4823-8e41-bf001a007b46', '4227eceb-71d6-422c-808b-6a12ec8a1e54', 'ca-central-1')

# This statement should fail with a foreign key violation, and the schema change
# should properly revert without causing infinite retries due to the missing RBRUsingConstraint.
# Prior to the bugfix, the rollback logic would would drop the constraint but
# not clear the RBRUsingConstraint field, causing validation to fail during
# the rollback.
statement error pgcode 23503 pq: foreign key violation: "b" row crdb_region='ca-central-1', a_id='4227eceb-71d6-422c-808b-6a12ec8a1e54', id='8f6ce660-423e-4823-8e41-bf001a007b46' has no match in "a"
ALTER TABLE b
  DROP CONSTRAINT a_id_fk,
  ADD CONSTRAINT a_crdb_region_id_fk
    FOREIGN KEY (crdb_region, a_id) REFERENCES a (crdb_region, id) ON UPDATE CASCADE ON DELETE CASCADE,
  SET (infer_rbr_region_col_using_constraint = a_crdb_region_id_fk)

# Verify the tables are still functional after the failed schema change.
query I
SELECT count(*) FROM a
----
1

query I
SELECT count(*) FROM b
----
1

statement ok
DROP TABLE b CASCADE

statement ok
DROP TABLE a CASCADE

statement ok
RESET create_table_with_schema_locked;

subtest end

# Test foreign keys with implicit column references on regional by row tables.
# This verifies implicit FK references correctly skip the crdb_region column.
subtest fk_implicit_rbr

statement ok
CREATE TABLE parent_rbr_implicit (
  k INT PRIMARY KEY,
  v INT
) LOCALITY REGIONAL BY ROW

statement ok
INSERT INTO parent_rbr_implicit (k, v, crdb_region) VALUES
  (1, 10, 'ca-central-1'),
  (2, 20, 'ap-southeast-2'),
  (3, 30, 'us-east-1')

# FK without explicit column list should skip crdb_region implicit column
statement ok
CREATE TABLE child_rbr_implicit (
  k INT PRIMARY KEY,
  parent_k INT,
  FOREIGN KEY (parent_k) REFERENCES parent_rbr_implicit
) LOCALITY REGIONAL BY ROW

statement ok
INSERT INTO child_rbr_implicit (k, parent_k, crdb_region) VALUES
  (1, 1, 'ca-central-1'),
  (2, 2, 'ap-southeast-2')

# Verify FK constraint enforcement
statement error pq: insert on table "child_rbr_implicit" violates foreign key constraint
INSERT INTO child_rbr_implicit (k, parent_k, crdb_region) VALUES (99, 99, 'ca-central-1')

# Cleanup
statement ok
DROP TABLE child_rbr_implicit

statement ok
DROP TABLE parent_rbr_implicit

subtest end

# Test implicit keys with a combination of features that result in the
# primary key index having internal/implicit columns.
subtest fk_implicit_rbr_hash_sharded_combined

# Parent table is regional by row with a hash-sharded primary key
statement ok
CREATE TABLE parent_combined (
  k INT NOT NULL,
  v INT NOT NULL,
  data INT,
  PRIMARY KEY (k, v) USING HASH
) LOCALITY REGIONAL BY ROW

statement ok
INSERT INTO parent_combined (k, v, data, crdb_region) VALUES
  (1, 1, 100, 'ca-central-1'),
  (2, 2, 200, 'ap-southeast-2'),
  (3, 3, 300, 'us-east-1')

statement ok
CREATE TABLE child_combined (
  k INT,
  v INT,
  FOREIGN KEY (k, v) REFERENCES parent_combined
) LOCALITY REGIONAL BY ROW

statement ok
INSERT INTO child_combined (k, v, crdb_region) VALUES
  (1, 1, 'ca-central-1'),
  (2, 2, 'ap-southeast-2')

# Verify FK constraint enforcement
statement error pq: insert on table "child_combined" violates foreign key constraint
INSERT INTO child_combined (k, v, crdb_region) VALUES (99, 99, 'ca-central-1')

# Verify this also works using ALTER TABLE
statement ok
CREATE TABLE child_combined2 (
  k INT,
  v INT
) LOCALITY REGIONAL BY ROW

statement ok
ALTER TABLE child_combined2 ADD FOREIGN KEY (k, v) REFERENCES parent_combined

statement ok
INSERT INTO child_combined2 (k, v, crdb_region) VALUES
  (1, 1, 'ca-central-1'),
  (2, 2, 'ap-southeast-2')

# Verify FK constraint enforcement
statement error pq: insert on table "child_combined2" violates foreign key constraint
INSERT INTO child_combined2 (k, v, crdb_region) VALUES (99, 99, 'ca-central-1')

# Cleanup
statement ok
DROP TABLE child_combined

statement ok
DROP TABLE child_combined2

statement ok
DROP TABLE parent_combined

subtest end
