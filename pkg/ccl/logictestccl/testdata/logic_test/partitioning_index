# LogicTest: local

statement ok
CREATE TABLE ok1 (
    a INT PRIMARY KEY, b INT,
    INDEX (b) PARTITION BY LIST (b) (
        PARTITION p1 VALUES IN (1),
        PARTITION pu VALUES IN (NULL)
    ),
    FAMILY "primary" (a, b)
)

query TT
SHOW CREATE TABLE ok1
----
ok1  CREATE TABLE public.ok1 (
     a INT8 NOT NULL,
     b INT8 NULL,
     CONSTRAINT "primary" PRIMARY KEY (a ASC),
     INDEX ok1_b_idx (b ASC) PARTITION BY LIST (b) (
       PARTITION p1 VALUES IN ((1)),
       PARTITION pu VALUES IN ((NULL))
     ),
     FAMILY "primary" (a, b)
)
-- Warning: Partitioned table with no zone configurations.

# Verify that secondary indexes with a partition for NULLs can actually store
# NULLs.
statement ok
INSERT INTO ok1 (a, b) VALUES (1, NULL), (2, NULL)

statement ok
CREATE TABLE ok2 (
    a INT PRIMARY KEY, b INT,
    UNIQUE (b) PARTITION BY LIST (b) (
        PARTITION p1 VALUES IN (1)
    ),
    FAMILY "primary" (a, b)
)

query TT
SHOW CREATE TABLE ok2
----
ok2  CREATE TABLE public.ok2 (
     a INT8 NOT NULL,
     b INT8 NULL,
     CONSTRAINT "primary" PRIMARY KEY (a ASC),
     UNIQUE INDEX ok2_b_key (b ASC) PARTITION BY LIST (b) (
       PARTITION p1 VALUES IN ((1))
     ),
     FAMILY "primary" (a, b)
)
-- Warning: Partitioned table with no zone configurations.

statement ok
CREATE TABLE ok3 (
    a INT PRIMARY KEY, b INT,
    UNIQUE INDEX (b) PARTITION BY LIST (b) (
        PARTITION p1 VALUES IN (1)
    ),
    FAMILY "primary" (a, b)
)

statement ok
INSERT INTO ok3 VALUES (1,1), (2,2), (3,3)

statement ok
CREATE UNIQUE INDEX ok3_b_key2 ON ok3 (b ASC) PARTITION BY LIST (b) (
       PARTITION p2 VALUES IN ((1))
)

query TT
SHOW CREATE TABLE ok3
----
ok3  CREATE TABLE public.ok3 (
     a INT8 NOT NULL,
     b INT8 NULL,
     CONSTRAINT "primary" PRIMARY KEY (a ASC),
     UNIQUE INDEX ok3_b_key (b ASC) PARTITION BY LIST (b) (
       PARTITION p1 VALUES IN ((1))
     ),
     UNIQUE INDEX ok3_b_key2 (b ASC) PARTITION BY LIST (b) (
       PARTITION p2 VALUES IN ((1))
     ),
     FAMILY "primary" (a, b)
)
-- Warning: Partitioned table with no zone configurations.

statement ok
CREATE TABLE indexes (a INT PRIMARY KEY, b INT, FAMILY "primary" (a, b))

statement ok
INSERT INTO indexes VALUES (1,1), (2,2), (3,3)

statement ok
CREATE INDEX i1 ON indexes (b) PARTITION BY LIST (b) (
    PARTITION p1 VALUES IN (1)
)

statement ok
CREATE UNIQUE INDEX i2 ON indexes (b) PARTITION BY LIST (b) (
    PARTITION p2 VALUES IN (1)
)

statement ok
CREATE INDEX IF NOT EXISTS i3 ON indexes (b) PARTITION BY LIST (b) (
    PARTITION p3 VALUES IN (1)
)

statement ok
CREATE UNIQUE INDEX IF NOT EXISTS i4 ON indexes (b) PARTITION BY LIST (b) (
    PARTITION p4 VALUES IN (1)
)

statement error PARTITION p1: name must be unique \(used twice in index "i5"\)
CREATE INDEX i5 ON indexes (b) PARTITION BY LIST (b) (
    PARTITION p1 VALUES IN (1),
    PARTITION p1 VALUES IN (2)
)

# Partition names can be reused across indexes.
statement ok
CREATE INDEX i5 ON indexes (b) PARTITION BY LIST (b) (
    PARTITION p1 VALUES IN (1)
)

query TT
SHOW CREATE TABLE indexes
----
indexes  CREATE TABLE public.indexes (
         a INT8 NOT NULL,
         b INT8 NULL,
         CONSTRAINT "primary" PRIMARY KEY (a ASC),
         INDEX i1 (b ASC) PARTITION BY LIST (b) (
           PARTITION p1 VALUES IN ((1))
         ),
         UNIQUE INDEX i2 (b ASC) PARTITION BY LIST (b) (
           PARTITION p2 VALUES IN ((1))
         ),
         INDEX i3 (b ASC) PARTITION BY LIST (b) (
           PARTITION p3 VALUES IN ((1))
         ),
         UNIQUE INDEX i4 (b ASC) PARTITION BY LIST (b) (
           PARTITION p4 VALUES IN ((1))
         ),
         INDEX i5 (b ASC) PARTITION BY LIST (b) (
           PARTITION p1 VALUES IN ((1))
         ),
         FAMILY "primary" (a, b)
)
-- Warning: Partitioned table with no zone configurations.

statement ok
CREATE TABLE inverted (
    a INT PRIMARY KEY, b INT, j JSON,
    INVERTED INDEX (b, j) PARTITION BY LIST (b) (
        PARTITION p1 VALUES IN (1),
        PARTITION pu VALUES IN (NULL)
    ),
    FAMILY "primary" (a, b, j)
)

statement ok
CREATE INVERTED INDEX inv_idx ON inverted (b, j) PARTITION BY LIST (b) (
    PARTITION p1 VALUES IN (1)
)

query TT
SHOW CREATE TABLE inverted
----
inverted  CREATE TABLE public.inverted (
          a INT8 NOT NULL,
          b INT8 NULL,
          j JSONB NULL,
          CONSTRAINT "primary" PRIMARY KEY (a ASC),
          INVERTED INDEX inverted_b_j_idx (b, j) PARTITION BY LIST (b) (
            PARTITION p1 VALUES IN ((1)),
            PARTITION pu VALUES IN ((NULL))
          ),
          INVERTED INDEX inv_idx (b, j) PARTITION BY LIST (b) (
            PARTITION p1 VALUES IN ((1))
          ),
          FAMILY "primary" (a, b, j)
)
-- Warning: Partitioned table with no zone configurations.

# Regression test for #60019. The index predicate should be formatted after the
# PARTITION BY clause to match the syntax that is accepted.
statement ok
CREATE TABLE t60019 (
  pk INT PRIMARY KEY,
  a INT,
  b INT,
  INDEX (a, b) PARTITION BY LIST (a) (
    PARTITION c_implicit VALUES IN (3)
  ) WHERE b > 0,
  FAMILY (pk, a, b)
)

query T
SELECT create_statement FROM [SHOW CREATE TABLE t60019]
----
CREATE TABLE public.t60019 (
  pk INT8 NOT NULL,
  a INT8 NULL,
  b INT8 NULL,
  CONSTRAINT "primary" PRIMARY KEY (pk ASC),
  INDEX t60019_a_b_idx (a ASC, b ASC) PARTITION BY LIST (a) (
    PARTITION c_implicit VALUES IN ((3))
  ) WHERE b > 0:::INT8,
  FAMILY fam_0_pk_a_b (pk, a, b)
)
-- Warning: Partitioned table with no zone configurations.

# Regression test for #60699. Do not allow creation of interleaved partitioned
# indexes.
statement ok
SET CLUSTER SETTING sql.defaults.interleaved_tables.enabled = true;
CREATE TABLE t60699_a (a INT PRIMARY KEY);
CREATE TABLE t60699_b (b INT PRIMARY KEY, a INT REFERENCES t60699_a (a));

statement error interleaved indexes cannot be partitioned
CREATE INDEX i ON t60699_b (a) INTERLEAVE IN PARENT t60699_a (a) PARTITION BY LIST (a) (
  partition part1 VALUES IN (1)
)
