# LogicTest: !local-mixed-23.1

statement ok
CREATE SEQUENCE seq;

statement ok
CREATE TYPE weekday AS ENUM ('monday', 'tuesday', 'wednesday', 'thursday', 'friday');

statement ok
CREATE TABLE t_rewrite (
  v INT DEFAULT 0,
  w weekday DEFAULT 'monday'::weekday
);

# Need to turn declarative schema changer off because function `get_body_str`
# created below would resolve a descriptorless public schema "system.public"
# which is not supported in declarative schema changer. Declarative schema
# changer falls back to legacy schema changer, and the descriptor id counter is
# increased twice. It cause the test to fail due to id inconsistency.
skipif config local-legacy-schema-changer
statement ok
SET use_declarative_schema_changer = 'off'

statement ok
CREATE FUNCTION get_body_str(fn_name STRING) RETURNS STRING
LANGUAGE SQL
AS $$
  SELECT crdb_internal.pb_to_json(
    'cockroach.sql.sqlbase.Descriptor', descriptor, false
  )->'function'->'functionBody'
  FROM system.descriptor WHERE id = fn_name::regproc::int - 100000;
$$;

skipif config local-legacy-schema-changer
statement ok
SET use_declarative_schema_changer = 'on'

subtest rewrite_plpgsql

statement ok
CREATE OR REPLACE FUNCTION f_rewrite() RETURNS INT AS
$$
  DECLARE
    i INT := nextval('seq');
    curs REFCURSOR := nextval('seq')::STRING;
    curs2 CURSOR FOR SELECT nextval('seq');
  BEGIN
    RAISE NOTICE USING MESSAGE = format('next val: %d',nextval('seq'));
    RAISE NOTICE 'val1: %, val2: %', nextval('seq'), nextval('seq');
    WHILE nextval('seq') < 10 LOOP
      i = nextval('seq');
      SELECT nextval('seq');
      IF nextval('seq') = 1 THEN
        CONTINUE;
      ELSIF nextval('seq') = 2 THEN
        SELECT v INTO i FROM nextval('seq') AS v(INT);
      END IF;
    END LOOP;
    OPEN curs FOR SELECT nextval('seq');
    RETURN nextval('seq');
  END
$$ LANGUAGE PLPGSQL;

query T
SELECT get_body_str('f_rewrite');
----
"DECLARE\ni INT8 := nextval(106:::REGCLASS);\ncurs REFCURSOR := nextval(106:::REGCLASS)::STRING;\ncurs2 CURSOR FOR SELECT nextval(106:::REGCLASS);\nBEGIN\nRAISE notice\nUSING MESSAGE = format('next val: %d':::STRING, nextval(106:::REGCLASS));\nRAISE notice 'val1: %, val2: %', nextval(106:::REGCLASS), nextval(106:::REGCLASS);\nWHILE nextval(106:::REGCLASS) < 10:::INT8 LOOP\ni := nextval(106:::REGCLASS);\nSELECT nextval(106:::REGCLASS);\nIF nextval(106:::REGCLASS) = 1:::INT8 THEN\n\tCONTINUE;\nELSIF nextval(106:::REGCLASS) = 2:::INT8 THEN\n\tSELECT v FROM ROWS FROM (nextval(106:::REGCLASS)) AS v (\"int\") INTO i;\nEND IF;\nEND LOOP;\nOPEN curs FOR SELECT nextval(106:::REGCLASS);\nRETURN nextval(106:::REGCLASS);\nEND\n"

query TT
SHOW CREATE FUNCTION f_rewrite;
----
                f_rewrite  CREATE FUNCTION public.f_rewrite()
                             RETURNS INT8
                             VOLATILE
                             NOT LEAKPROOF
                             CALLED ON NULL INPUT
                             LANGUAGE plpgsql
                             AS $$
                             DECLARE
                             i INT8 := nextval(106:::REGCLASS);
                             curs REFCURSOR := nextval(106:::REGCLASS)::STRING;
                             curs2 CURSOR FOR SELECT nextval(106:::REGCLASS);
                             BEGIN
                             RAISE notice
                             USING MESSAGE = format('next val: %d':::STRING, nextval(106:::REGCLASS));
                             RAISE notice 'val1: %, val2: %', nextval(106:::REGCLASS), nextval(106:::REGCLASS);
                             WHILE nextval(106:::REGCLASS) < 10:::INT8 LOOP
                             i := nextval(106:::REGCLASS);
                             SELECT nextval(106:::REGCLASS);
                             IF nextval(106:::REGCLASS) = 1:::INT8 THEN
                               CONTINUE;
                             ELSIF nextval(106:::REGCLASS) = 2:::INT8 THEN
                               SELECT v FROM ROWS FROM (nextval(106:::REGCLASS)) AS v ("int") INTO i;
                             END IF;
                             END LOOP;
                             OPEN curs FOR SELECT nextval(106:::REGCLASS);
                             RETURN nextval(106:::REGCLASS);
                             END
                           $$

statement ok
DROP FUNCTION f_rewrite();

statement ok
CREATE OR REPLACE FUNCTION f_rewrite() RETURNS weekday AS
$$
  BEGIN
    SELECT 'wednesday'::weekday;
  END
$$ LANGUAGE PLPGSQL

query T
SELECT get_body_str('f_rewrite');
----
"BEGIN\nSELECT 'wednesday'::@100107;\nEND\n"

statement ok
CREATE OR REPLACE FUNCTION f_rewrite() RETURNS weekday AS
$$
  BEGIN
    UPDATE t_rewrite SET w = 'thursday'::weekday WHERE w = 'wednesday'::weekday RETURNING w;
  END
$$ LANGUAGE PLPGSQL

query T
SELECT get_body_str('f_rewrite');
----
"BEGIN\nUPDATE test.public.t_rewrite SET w = 'thursday'::@100107 WHERE w = 'wednesday'::@100107 RETURNING w;\nEND\n"

subtest end

subtest rewrite_proc

statement ok
CREATE OR REPLACE PROCEDURE p_rewrite() AS
$$
  BEGIN
    INSERT INTO t_rewrite(v) VALUES (nextval('seq')) RETURNING v;
  END
$$ LANGUAGE PLPGSQL

query T
SELECT get_body_str('p_rewrite');
----
"BEGIN\nINSERT INTO test.public.t_rewrite(v) VALUES (nextval(106:::REGCLASS)) RETURNING v;\nEND\n"

statement ok
DROP PROCEDURE p_rewrite();

statement ok
CREATE OR REPLACE PROCEDURE p_rewrite() AS
$$
  BEGIN
    UPDATE t_rewrite SET w = 'thursday'::weekday WHERE w = 'wednesday'::weekday RETURNING w;
  END
$$ LANGUAGE PLPGSQL

query T
SELECT get_body_str('p_rewrite');
----
"BEGIN\nUPDATE test.public.t_rewrite SET w = 'thursday'::@100107 WHERE w = 'wednesday'::@100107 RETURNING w;\nEND\n"

subtest end
