// Copyright 2020 The Cockroach Authors.
//
// Licensed as a CockroachDB Enterprise file under the Cockroach Community
// License (the "License"); you may not use this file except in compliance with
// the License. You may obtain a copy of the License at
//
//     https://github.com/cockroachdb/cockroach/blob/master/licenses/CCL.txt

package streamclient

import (
	"context"
	"fmt"
	"math/rand"
	"net/url"
	"strconv"
	"time"

	"github.com/cockroachdb/cockroach/pkg/ccl/streamingccl"
	"github.com/cockroachdb/cockroach/pkg/keys"
	"github.com/cockroachdb/cockroach/pkg/roachpb"
	"github.com/cockroachdb/cockroach/pkg/sql"
	"github.com/cockroachdb/cockroach/pkg/sql/catalog/catalogkeys"
	"github.com/cockroachdb/cockroach/pkg/sql/catalog/descpb"
	"github.com/cockroachdb/cockroach/pkg/sql/catalog/systemschema"
	"github.com/cockroachdb/cockroach/pkg/sql/catalog/tabledesc"
	"github.com/cockroachdb/cockroach/pkg/sql/rowenc"
	"github.com/cockroachdb/cockroach/pkg/sql/sem/tree"
	"github.com/cockroachdb/cockroach/pkg/util/hlc"
	"github.com/cockroachdb/cockroach/pkg/util/randutil"
	"github.com/cockroachdb/cockroach/pkg/util/syncutil"
	"github.com/cockroachdb/cockroach/pkg/util/timeutil"
)

const (
	// RandomStreamSchemaPlaceholder is the schema of the KVs emitted by the
	// random stream client.
	RandomStreamSchemaPlaceholder = "CREATE TABLE %s (k INT PRIMARY KEY, v INT)"

	// TestScheme is the URI scheme used to create a test load.
	TestScheme = "test"
	// ValueRangeKey controls the range of the randomly generated values produced
	// by this workload. The workload will generate between 0 and this value.
	ValueRangeKey = "VALUE_RANGE"
	// EventFrequency is the frequency in nanoseconds that the stream will emit
	// randomly generated KV events.
	EventFrequency = "EVENT_FREQUENCY"
	// KVsPerCheckpoint controls approximately how many KV events should be emitted
	// between checkpoint events.
	KVsPerCheckpoint = "KVS_PER_CHECKPOINT"
	// NumPartitions controls the number of partitions the client will stream data
	// back on. Each partition will encompass a single table span.
	NumPartitions = "NUM_PARTITIONS"
	// DupProbability controls the probability with which we emit duplicate KV
	// events.
	DupProbability = "DUP_PROBABILITY"
	// IngestionDatabaseID is the ID used in the generated table descriptor.
	IngestionDatabaseID = 50 /* defaultDB */
	// IngestionTablePrefix is the prefix of the table name used in the generated
	// table descriptor.
	IngestionTablePrefix = "foo"
)

type interceptFn func(event streamingccl.Event, pa streamingccl.PartitionAddress)

// InterceptableStreamClient wraps a Client, and provides a method to register
// interceptor methods that are run on every streamed Event.
type InterceptableStreamClient interface {
	Client

	RegisterInterception(fn interceptFn)
}

// randomStreamConfig specifies the variables that controls the rate and type of
// events that the generated stream emits.
type randomStreamConfig struct {
	valueRange       int
	eventFrequency   time.Duration
	kvsPerCheckpoint int
	numPartitions    int
	dupProbability   float64
}

func parseRandomStreamConfig(streamURL *url.URL) (randomStreamConfig, error) {
	c := randomStreamConfig{
		valueRange:       100,
		eventFrequency:   10 * time.Microsecond,
		kvsPerCheckpoint: 100,
		numPartitions:    1,
		dupProbability:   0.5,
	}

	var err error
	if valueRangeStr := streamURL.Query().Get(ValueRangeKey); valueRangeStr != "" {
		c.valueRange, err = strconv.Atoi(valueRangeStr)
		if err != nil {
			return c, err
		}
	}

	if kvFreqStr := streamURL.Query().Get(EventFrequency); kvFreqStr != "" {
		kvFreq, err := strconv.Atoi(kvFreqStr)
		c.eventFrequency = time.Duration(kvFreq)
		if err != nil {
			return c, err
		}
	}

	if kvsPerCheckpointStr := streamURL.Query().Get(KVsPerCheckpoint); kvsPerCheckpointStr != "" {
		c.kvsPerCheckpoint, err = strconv.Atoi(kvsPerCheckpointStr)
		if err != nil {
			return c, err
		}
	}

	if numPartitionsStr := streamURL.Query().Get(NumPartitions); numPartitionsStr != "" {
		c.numPartitions, err = strconv.Atoi(numPartitionsStr)
		if err != nil {
			return c, err
		}
	}

	if dupProbStr := streamURL.Query().Get(DupProbability); dupProbStr != "" {
		c.dupProbability, err = strconv.ParseFloat(dupProbStr, 32)
		if err != nil {
			return c, err
		}
	}
	return c, nil
}

// randomStreamClient is a temporary stream client implementation that generates
// random events.
//
// The client can be configured to return more than one partition via the stream
// URL. Each partition covers a single table span.
//
// TODO: Move this over to a _test file in the ingestion package when there is a
// real stream client implementation.
type randomStreamClient struct {
	config randomStreamConfig

	// mu is used to provide a threadsafe interface to interceptors.
	mu struct {
		syncutil.Mutex

		// interceptors can be registered to peek at every event generated by this
		// client.
		interceptors []func(streamingccl.Event, streamingccl.PartitionAddress)
	}
}

var _ Client = &randomStreamClient{}
var _ InterceptableStreamClient = &randomStreamClient{}

// newRandomStreamClient returns a stream client that generates a random set of
// events on a table with an integer key and integer value for the table with
// the given ID.
func newRandomStreamClient(streamURL *url.URL) (Client, error) {
	streamConfig, err := parseRandomStreamConfig(streamURL)
	if err != nil {
		return nil, err
	}

	return &randomStreamClient{
		config: streamConfig,
	}, nil
}

var testTableID = 52

func getNextTableID() int {
	ret := testTableID
	testTableID++
	return ret
}

// GetTopology implements the Client interface.
func (m *randomStreamClient) GetTopology(
	_ streamingccl.StreamAddress,
) (streamingccl.Topology, error) {
	topology := streamingccl.Topology{Partitions: make([]streamingccl.PartitionAddress,
		0, m.config.numPartitions)}

	// Allocate table IDs and return one per partition address in the topology.
	for i := 0; i < m.config.numPartitions; i++ {
		tableID := descpb.ID(getNextTableID())
		partitionURI := url.URL{
			Scheme: TestScheme,
			Host:   strconv.Itoa(int(tableID)),
		}
		topology.Partitions = append(topology.Partitions,
			streamingccl.PartitionAddress(partitionURI.String()))
	}

	return topology, nil
}

// getDescriptorAndNamespaceKVForTableID returns the namespace and descriptor
// KVs for the table with tableID.
func (m *randomStreamClient) getDescriptorAndNamespaceKVForTableID(
	tableID descpb.ID,
) (*tabledesc.Mutable, []roachpb.KeyValue, error) {
	tableName := fmt.Sprintf("%s%d", IngestionTablePrefix, tableID)
	testTable, err := sql.CreateTestTableDescriptor(
		context.Background(),
		IngestionDatabaseID,
		tableID,
		fmt.Sprintf(RandomStreamSchemaPlaceholder, tableName),
		systemschema.JobsTable.GetPrivileges(),
	)
	if err != nil {
		return nil, nil, err
	}

	// Generate namespace entry.
	key := catalogkeys.NewTableKey(50, keys.PublicSchemaID, testTable.Name)
	var value roachpb.Value
	value.SetInt(int64(testTable.GetID()))
	namespaceKV := roachpb.KeyValue{
		Key:   key.Key(keys.TODOSQLCodec),
		Value: value,
	}

	// Generate descriptor entry.
	descKey := catalogkeys.MakeDescMetadataKey(keys.TODOSQLCodec, testTable.GetID())
	descDesc := testTable.DescriptorProto()
	var descValue roachpb.Value
	if err := descValue.SetProto(descDesc); err != nil {
		panic(err)
	}
	descKV := roachpb.KeyValue{
		Key:   descKey,
		Value: descValue,
	}

	return testTable, []roachpb.KeyValue{namespaceKV, descKV}, nil
}

// ConsumePartition implements the Client interface.
func (m *randomStreamClient) ConsumePartition(
	ctx context.Context, partitionAddress streamingccl.PartitionAddress, startTime time.Time,
) (chan streamingccl.Event, error) {
	eventCh := make(chan streamingccl.Event)
	now := timeutil.Now()
	if startTime.After(now) {
		panic("cannot start random stream client event stream in the future")
	}

	partitionURL, err := partitionAddress.URL()
	if err != nil {
		return nil, err
	}
	var partitionTableID int
	partitionTableID, err = strconv.Atoi(partitionURL.Host)
	if err != nil {
		return nil, err
	}

	tableDesc, systemKVs, err := m.getDescriptorAndNamespaceKVForTableID(descpb.ID(partitionTableID))
	if err != nil {
		return nil, err
	}
	go func() {
		defer close(eventCh)

		// rand is not thread safe, so create a random source for each partition.
		r := rand.New(rand.NewSource(timeutil.Now().UnixNano()))
		kvInterval := m.config.eventFrequency

		numKVEventsSinceLastResolved := 0

		rng, _ := randutil.NewPseudoRand()
		var dupKVEvent streamingccl.Event

		for {
			var event streamingccl.Event
			if numKVEventsSinceLastResolved == m.config.kvsPerCheckpoint {
				// Emit a CheckpointEvent.
				resolvedTime := timeutil.Now()
				hlcResolvedTime := hlc.Timestamp{WallTime: resolvedTime.UnixNano()}
				event = streamingccl.MakeCheckpointEvent(hlcResolvedTime)

				numKVEventsSinceLastResolved = 0
			} else {
				// If there are system KVs to emit, prioritize those.
				if len(systemKVs) > 0 {
					systemKV := systemKVs[0]
					systemKV.Value.Timestamp = hlc.Timestamp{WallTime: timeutil.Now().UnixNano()}
					event = streamingccl.MakeKVEvent(systemKV)
					systemKVs = systemKVs[1:]
				} else {
					numKVEventsSinceLastResolved++
					// Generate a duplicate KVEvent.
					if rng.Float64() < m.config.dupProbability && dupKVEvent != nil {
						dupKV := dupKVEvent.GetKV()
						event = streamingccl.MakeKVEvent(*dupKV)
					} else {
						event = streamingccl.MakeKVEvent(m.makeRandomKey(r, tableDesc))
						dupKVEvent = event
					}
				}
			}

			select {
			case eventCh <- event:
			case <-ctx.Done():
				return
			}

			func() {
				m.mu.Lock()
				defer m.mu.Unlock()

				if len(m.mu.interceptors) > 0 {
					for _, interceptor := range m.mu.interceptors {
						if interceptor != nil {
							interceptor(event, partitionAddress)
						}
					}
				}
			}()

			time.Sleep(kvInterval)
		}
	}()

	return eventCh, nil
}

func (m *randomStreamClient) makeRandomKey(
	r *rand.Rand, tableDesc *tabledesc.Mutable,
) roachpb.KeyValue {
	// Create a key holding a random integer.
	k, err := rowenc.TestingMakePrimaryIndexKey(tableDesc, r.Intn(m.config.valueRange))
	if err != nil {
		panic(err)
	}
	k = keys.MakeFamilyKey(k, uint32(tableDesc.Families[0].ID))

	// Create a value holding a random integer.
	valueDatum := tree.NewDInt(tree.DInt(r.Intn(m.config.valueRange)))
	valueBuf, err := rowenc.EncodeTableValue(
		[]byte(nil), tableDesc.Columns[1].ID, valueDatum, []byte(nil))
	if err != nil {
		panic(err)
	}
	var v roachpb.Value
	v.SetTuple(valueBuf)
	v.ClearChecksum()
	v.InitChecksum(k)

	v.Timestamp = hlc.Timestamp{WallTime: timeutil.Now().UnixNano()}

	return roachpb.KeyValue{
		Key:   k,
		Value: v,
	}
}

// RegisterInterception implements streamingest.interceptableStreamClient.
func (m *randomStreamClient) RegisterInterception(fn interceptFn) {
	m.mu.Lock()
	defer m.mu.Unlock()
	m.mu.interceptors = append(m.mu.interceptors, fn)
}
