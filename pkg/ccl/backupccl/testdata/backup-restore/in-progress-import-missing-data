# This test inspects and restores backups that were affected by the
# bug described in
# https://github.com/cockroachdb/cockroach/issues/88042
# and ensures that RESTORE now fails with an expected error message.
# The exact timeline that induces the bug is the following:
#
# - t0: begin import jobs and pause it
# - t1: wildcard table or database backup with revision history
# - t2: cancel an import job, and continue a different one
# - t3: run an incremental backup with revision history
#       - the testing knob will induce this incremental backup to skip the
#         introduction of the imported tables
# - t4: restore the tables.
#       - If we restore AOST after the imports completed/failed, the restore should fail as it now
#         detects that the incremental backup at t3 forgot to re-introduce the span.
#       - If we restore AOST before the import completed/failed, the restore should succeed, as the
#         skipped span introduction is irrelevant.
#
# The test also ensures that similar backup/restore/import scenarios are safe from corruption:
#  - the timeline above with table/database backups w/o revision history
#  - revision history cluster backups
#  - revision history table/database backups which includes an incremental backup between t1 and t2

new-server name=s1 allow-implicit-access
----

# Link 4 backup chains:
# 1. A corrupt database backup chain with revision history
link-backup server=s1 src-path=restore_importing_tables,database dest-path=database
----

# 2. A clean database backup chain with revision history which includes two
#    backups that observe the offline descriptors.
link-backup server=s1 src-path=restore_importing_tables,database_double_inc dest-path=database_double_inc
----

# 3. A clean data database backup chain without revision history
link-backup server=s1 src-path=restore_importing_tables,database_no_hist dest-path=database_no_hist
----

# 4. A clean cluster backup chain with revision history
link-backup server=s1 src-path=restore_importing_tables,cluster dest-path=cluster
----

# Note that we're purposely skipping the reintroduction of foo, foofoo, goodfoo in the
# incremental to simulate the bug.

query-sql
SELECT
  database_name, object_name, object_type, rows, backup_type
FROM
  [SHOW BACKUP LATEST IN 'nodelocal://0/database']
WHERE
  object_name = 'foo' or object_name = 'foofoo' or object_name = 'goodfoo'
ORDER BY
  start_time, database_name;
----
d foo table 0 incremental
d foofoo table 0 incremental
d goodfoo table 0 incremental

# In all show backups below, the foo,foofoo, and goodfoo should get introduced
query-sql
SELECT
  database_name, object_name, object_type, rows, backup_type
FROM
  [SHOW BACKUP LATEST IN 'nodelocal://0/database_double_inc/']
WHERE
  object_name = 'foo' or object_name = 'foofoo' or object_name = 'goodfoo'
ORDER BY
  start_time, database_name;
----
d foo table 0 incremental
d foofoo table 1 incremental
d goodfoo table 3 incremental

query-sql
SELECT
  database_name, object_name, object_type, rows, backup_type
FROM
  [SHOW BACKUP LATEST IN 'nodelocal://0/database_no_hist/']
ORDER BY
  start_time, database_name;
----
d foo table 0 incremental
d foofoo table 1 incremental
d goodfoo table 3 incremental

# Note that the cluster level SHOW BACKUP includes foo and foofoo in the full
# backup while the database ones do not. This is because CLUSTER
# backup manifests includes these in the Descriptors field (i.e. cluster backups
# explicitly backup offline tables, see #88043), while database
# backups only include these descriptors in manifest.DescriptorChanges (see
# #88042).
query-sql
SELECT
  database_name, object_name, object_type, rows, backup_type
FROM
  [SHOW BACKUP LATEST IN 'nodelocal://0/cluster/']
WHERE
  object_name = 'foo' or object_name = 'foofoo' or object_name = 'goodfoo'
ORDER BY
  start_time, database_name;
----
d foo table 3 full
d foofoo table 4 full
d goodfoo table 3 full
d foo table 0 incremental
d foofoo table 1 incremental
d goodfoo table 3 incremental


############
# Restore validation
############

# check that RESTORE will fail if any corrupt table restore is attempted
exec-sql expect-error-regex='table "foo" cannot be safely restored from this backup .*'
RESTORE DATABASE d FROM LATEST IN 'nodelocal://0/database/' with new_db_name = d_fail;
----
regex matches error

exec-sql expect-error-regex='table "goodfoo" cannot be safely restored from this backup .*'
RESTORE TABLE d.goodfoo FROM LATEST IN 'nodelocal://0/database/' with into_db = defaultdb;
----
regex matches error

exec-sql expect-error-regex='table "foofoo" cannot be safely restored from this backup .*'
RESTORE TABLE d.foofoo FROM LATEST IN 'nodelocal://0/database/' with into_db = defaultdb;
----
regex matches error


# Ensure the restore succeeds if there are no corrupt tables in the target
exec-sql
RESTORE TABLE d.baz FROM LATEST IN 'nodelocal://0/database/' with into_db = defaultdb;
----


# Check that the wildcard restore encounters the same errors

exec-sql
CREATE DATABASE defaultdb2;
----

exec-sql expect-error-regex='table "foo" cannot be safely restored from this backup .*'
RESTORE TABLE d.* FROM LATEST IN 'nodelocal://0/table/' with into_db = defaultdb2;
----
regex matches error

exec-sql expect-error-regex='table "foofoo" cannot be safely restored from this backup .*'
RESTORE TABLE d.foofoo FROM LATEST IN 'nodelocal://0/table/' with into_db = defaultdb2;
----
regex matches error

# Ensure the restore succeeds if there are no corrupt tables in the target
exec-sql
RESTORE TABLE d.baz FROM LATEST IN 'nodelocal://0/table/' with into_db = defaultdb2;
----

######################
# Check that you can restore AOST while the tables are offline
exec-sql
RESTORE DATABASE d FROM LATEST IN 'nodelocal://0/database/' AS OF SYSTEM TIME t0;
----


query-sql
SELECT table_name FROM [SHOW TABLES FROM d];
----
baz


###########################
# Check the alternative scenarios
###########################
exec-sql
DROP DATABASE d CASCADE;
----

# Check that a backup chain with the intermediate incremental backup restores properly
exec-sql
RESTORE DATABASE d FROM LATEST IN 'nodelocal://0/database_double_inc/';
----

query-sql
SELECT count(*) FROM d.foo;
----
0


query-sql
SELECT count(*) FROM d.foofoo;
----
1

query-sql
SELECT count(*) FROM d.goodfoo;
----
3


# Check that that backup chain with the intermediate incremental backup restores properly
exec-sql
DROP DATABASE d CASCADE;
----

exec-sql
RESTORE DATABASE d FROM LATEST IN 'nodelocal://0/database_no_hist/';
----

query-sql
SELECT count(*) FROM d.foo;
----
0


query-sql
SELECT count(*) FROM d.foofoo;
----
1

query-sql
SELECT count(*) FROM d.goodfoo;
----
3


# Check the cluster level restore
new-server name=s2 share-io-dir=s1 allow-implicit-access
----

link-backup server=s1 src-path=restore_importing_tables,cluster dest-path=cluster
----

exec-sql
RESTORE FROM LATEST IN 'nodelocal://0/cluster/';
----

query-sql
SELECT count(*) FROM d.foo;
----
0


query-sql
SELECT count(*) FROM d.foofoo;
----
1


query-sql
SELECT count(*) FROM d.goodfoo;
----
3
