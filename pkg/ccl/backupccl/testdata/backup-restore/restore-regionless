# disabled to run within tenant because multiregion primitives are not supported within tenant
subtest mrbackup
new-cluster name=s1 allow-implicit-access disable-tenant localities=us-east-1,us-west-1,eu-central-1
----

exec-sql
CREATE DATABASE d PRIMARY REGION "us-east-1" REGIONS "us-west-1", "eu-central-1";
CREATE TABLE d.t (x INT);
INSERT INTO d.t VALUES (1), (2), (3);
----

query-sql
SELECT crdb_region FROM d.t;
----
pq: column "crdb_region" does not exist

query-sql
SELECT region FROM [SHOW REGIONS FROM DATABASE d] ORDER BY 1;
----
eu-central-1
us-east-1
us-west-1

# backup a MR database, table, and cluster
exec-sql
BACKUP DATABASE d INTO 'nodelocal://1/database_backup/';
----

exec-sql
BACKUP TABLE d.t INTO 'nodelocal://1/table_backup/';
----

exec-sql
BACKUP INTO 'nodelocal://1/cluster_backup/';
----

# make our table regional by row
exec-sql
ALTER TABLE d.t SET LOCALITY REGIONAL BY ROW;
----
NOTICE: LOCALITY changes will be finalized asynchronously; further schema changes on this table may be restricted until the job completes

query-sql
SELECT crdb_region FROM d.t;
----
us-east-1
us-east-1
us-east-1

# backup db, table, and cluster with regional by row table
exec-sql
BACKUP DATABASE d INTO 'nodelocal://1/rbr_database_backup/';
----

exec-sql
BACKUP TABLE d.t INTO 'nodelocal://1/rbr_table_backup/';
----

exec-sql
BACKUP INTO 'nodelocal://1/rbr_cluster_backup/';
----

subtest end

# create regionless cluster
subtest restore_regionless_on_regionless
new-cluster name=s2 share-io-dir=s1 allow-implicit-access
----

exec-sql
RESTORE FROM LATEST IN 'nodelocal://1/cluster_backup/' WITH strip_localities;
----

# check cluster's regions
query-sql
SHOW REGIONS FROM CLUSTER;
----
test {}

# TODO (before merge) - why does data show up?
query-sql
SHOW DATABASES;
----
d root <nil> <nil> {} <nil>
data root <nil> <nil> {} <nil>
defaultdb root <nil> <nil> {} <nil>
postgres root <nil> <nil> {} <nil>
system node <nil> <nil> {} <nil>

# ensure that database d is regionless
query-sql
SELECT region FROM [SHOW REGIONS FROM DATABASE d] ORDER BY 1;
----

# show tables - make sure these are regionless as well
query-sql
SHOW TABLES FROM d;
----
public t table root <nil> <nil>

# ensure that tables belonging to d can be modified & have the correct values
exec-sql
INSERT INTO d.t VALUES (4), (5);
----

query-sql
SELECT * FROM d.t;
----
1
2
3
4
5

exec-sql
DROP DATABASE d;
DROP DATABASE data;
----

exec-sql
RESTORE DATABASE d FROM LATEST IN 'nodelocal://1/database_backup/' WITH strip_localities;
----

# check to see if restored database, d, shows up
query-sql
SHOW DATABASES;
----
d root <nil> <nil> {} <nil>
defaultdb root <nil> <nil> {} <nil>
postgres root <nil> <nil> {} <nil>
system node <nil> <nil> {} <nil>

# ensure that database d is regionless
query-sql
SELECT region FROM [SHOW REGIONS FROM DATABASE d] ORDER BY 1;
----

# show tables - make sure these are regionless as well
query-sql
SHOW TABLES FROM d;
----
public t table root <nil> <nil>

# ensure that tables belonging to d can be modified & have the correct values
exec-sql
INSERT INTO d.t VALUES (4), (5);
----

query-sql
SELECT * FROM d.t;
----
1
2
3
4
5

# backup up the restored, regionless db and table
exec-sql
BACKUP DATABASE d INTO 'nodelocal://1/regionless_database_backup/';
----

exec-sql
BACKUP TABLE d.t INTO 'nodelocal://1/regionless_table_backup/';
----

exec-sql
DROP TABLE d.t;
----

# ensure that restoring just the table itself works
exec-sql
RESTORE TABLE d.t FROM LATEST IN 'nodelocal://1/table_backup/' WITH strip_localities;
----

query-sql
SHOW TABLES FROM d;
----
public t table root <nil> <nil>

# ensure that tables belonging to d can be modified & have the correct values
exec-sql
INSERT INTO d.t VALUES (4), (5);
----

query-sql
SELECT * FROM d.t;
----
1
2
3
4
5

exec-sql
DROP DATABASE d;
----

# restore the stripped database
exec-sql
RESTORE DATABASE d FROM LATEST IN 'nodelocal://1/regionless_database_backup/';
----

# check to see if restored database, d, shows up
query-sql
SHOW DATABASES;
----
d root <nil> <nil> {} <nil>
defaultdb root <nil> <nil> {} <nil>
postgres root <nil> <nil> {} <nil>
system node <nil> <nil> {} <nil>

# ensure that database d is regionless
query-sql
SELECT region FROM [SHOW REGIONS FROM DATABASE d] ORDER BY 1;
----

# show tables - make sure these are regionless as well
query-sql
SHOW TABLES FROM d;
----
public t table root <nil> <nil>

# ensure that tables belonging to d can be modified & have the correct values
exec-sql
INSERT INTO d.t VALUES (6), (7);
----

query-sql
SELECT * FROM d.t;
----
1
2
3
4
5
6
7

exec-sql
DROP TABLE d.t;
----

# ensure that restoring just the table itself works
exec-sql
RESTORE TABLE d.t FROM LATEST IN 'nodelocal://1/regionless_table_backup/';
----

query-sql
SHOW TABLES FROM d;
----
public t table root <nil> <nil>

# ensure that tables belonging to d can be modified & have the correct values
exec-sql
INSERT INTO d.t VALUES (6), (7);
----

query-sql
SELECT * FROM d.t;
----
1
2
3
4
5
6
7

subtest end

# create a non-MR cluster with a region
subtest restore_regionless_on_single_region
new-cluster name=s3 share-io-dir=s1 allow-implicit-access localities=us-east-1
----

exec-sql
RESTORE DATABASE d FROM LATEST IN 'nodelocal://1/database_backup/' WITH strip_localities;
----

# check to see if restored database, d, shows up
query-sql
SHOW DATABASES;
----
d root <nil> <nil> {} <nil>
defaultdb root <nil> <nil> {} <nil>
postgres root <nil> <nil> {} <nil>
system node <nil> <nil> {} <nil>

# ensure that database d is regionless
query-sql
SELECT region FROM [SHOW REGIONS FROM DATABASE d] ORDER BY 1;
----

# show tables - make sure these are regionless as well
query-sql
SHOW TABLES FROM d;
----
public t table root <nil> <nil>

# ensure that tables belonging to d can be modified & have the correct values
exec-sql
INSERT INTO d.t VALUES (4), (5);
----

query-sql
SELECT * FROM d.t;
----
1
2
3
4
5

exec-sql
DROP TABLE d.t;
----

# ensure that restoring just the table itself works
exec-sql
RESTORE TABLE d.t FROM LATEST IN 'nodelocal://1/table_backup/' WITH strip_localities;
----

query-sql
SHOW TABLES FROM d;
----
public t table root <nil> <nil>

# ensure that tables belonging to d can be modified & have the correct values
exec-sql
INSERT INTO d.t VALUES (4), (5);
----

query-sql
SELECT * FROM d.t;
----
1
2
3
4
5

# ensure we can't add a regular region
# this is due to a validation that ensures a primary region exists
# before a "regular" region exists
exec-sql
ALTER DATABASE d ADD REGION "us-east-1";
----
pq: cannot add region "us-east-1" to database d
HINT: you must add a PRIMARY REGION first using ALTER DATABASE d PRIMARY REGION "us-east-1"

# we also can't add a primary region to our regionless database out-of-the-box now...
exec-sql
ALTER DATABASE d PRIMARY REGION "us-east-1";
----
pq: type "d.public.crdb_internal_region" already exists
DETAIL: multi-region databases employ an internal enum called crdb_internal_region to manage regions which conflicts with the existing object
HINT: object "crdb_internal_regions" must be renamed or dropped before adding the primary region

# ...let's listen to the error message
exec-sql
DROP TYPE d.public.crdb_internal_region;
----

exec-sql
ALTER DATABASE d PRIMARY REGION "us-east-1";
----

query-sql
SELECT region FROM [SHOW REGIONS FROM DATABASE d] ORDER BY 1;
----
us-east-1

query-sql
SHOW TABLES FROM d;
----
public t table root <nil> REGIONAL BY TABLE IN PRIMARY REGION

# ensure that tables belonging to d can be modified & have the correct values
exec-sql
INSERT INTO d.t VALUES (6), (7);
----

query-sql
SELECT * FROM d.t;
----
1
2
3
4
5
6
7

subtest end

# now we ensure that we can restore regionless db & table to a multi-region cluster
subtest restore_regionless_on_mr
new-cluster name=s4 share-io-dir=s1 allow-implicit-access disable-tenant localities=us-east-1,us-west-1,eu-central-1
----

exec-sql
RESTORE DATABASE d FROM LATEST IN 'nodelocal://1/regionless_database_backup/';
----

query-sql
SHOW DATABASES;
----
d root <nil> <nil> {} <nil>
defaultdb root <nil> <nil> {} <nil>
postgres root <nil> <nil> {} <nil>
system node <nil> <nil> {} <nil>

# ensure that database d is regionless
query-sql
SELECT region FROM [SHOW REGIONS FROM DATABASE d] ORDER BY 1;
----

# show tables - make sure these are regionless as well
query-sql
SHOW TABLES FROM d;
----
public t table root <nil> <nil>

# ensure that tables belonging to d can be modified & have the correct values
exec-sql
INSERT INTO d.t VALUES (6), (7);
----

query-sql
SELECT * FROM d.t;
----
1
2
3
4
5
6
7

exec-sql
DROP TABLE d.t;
----

# ensure that restoring just the table itself works
exec-sql
RESTORE TABLE d.t FROM LATEST IN 'nodelocal://1/regionless_table_backup/';
----

query-sql
SHOW TABLES FROM d;
----
public t table root <nil> <nil>

# ensure that tables belonging to d can be modified & have the correct values
exec-sql
INSERT INTO d.t VALUES (6), (7);
----

query-sql
SELECT * FROM d.t;
----
1
2
3
4
5
6
7

subtest end

# restoring a database with a table that has regional by row
subtest restore_regional_by_row
new-cluster name=s5 share-io-dir=s1 allow-implicit-access localities=us-west-1
----

exec-sql
RESTORE FROM LATEST IN 'nodelocal://1/rbr_cluster_backup/' WITH strip_localities;
----

# check cluster's regions
# TODO (before merge) - do we expect a cluster restore with stripped localities to override this?
query-sql
SHOW REGIONS FROM CLUSTER;
----
us-west-1 {us-west1}

# TODO (before merge) - why does data show up?
query-sql
SHOW DATABASES;
----
d root <nil> <nil> {} <nil>
data root <nil> <nil> {} <nil>
defaultdb root <nil> <nil> {} <nil>
postgres root <nil> <nil> {} <nil>
system node <nil> <nil> {} <nil>

# ensure that database d is regionless
query-sql
SELECT region FROM [SHOW REGIONS FROM DATABASE d] ORDER BY 1;
----

# show tables - make sure these are regionless as well
query-sql
SHOW TABLES FROM d;
----
public t table root <nil> <nil>

# ensure that tables belonging to d can be modified & have the correct values
# TODO (before merge)
exec-sql
INSERT INTO d.t VALUES (4), (5);
----
pq: default_to_database_primary_region(): current database defaultdb is not multi-region enabled

# query-sql
# SELECT * FROM d.t;
# ----
# 1
# 2
# 3
# 4
# 5

exec-sql
DROP DATABASE d;
DROP DATABASE data;
----

exec-sql
RESTORE DATABASE d FROM LATEST IN 'nodelocal://1/rbr_database_backup/' WITH strip_localities;
----

query-sql
SHOW DATABASES;
----
d root <nil> <nil> {} <nil>
defaultdb root <nil> <nil> {} <nil>
postgres root <nil> <nil> {} <nil>
system node <nil> <nil> {} <nil>

# ensure that database d is regionless
query-sql
SELECT region FROM [SHOW REGIONS FROM DATABASE d] ORDER BY 1;
----

# show tables - make sure these are regionless as well
query-sql
SHOW TABLES FROM d;
----
public t table root <nil> <nil>

# ensure that tables belonging to d can be modified & have the correct values
# TODO (before merge)
exec-sql
INSERT INTO d.t VALUES (4), (5);
----
pq: default_to_database_primary_region(): current database defaultdb is not multi-region enabled

# query-sql
# SELECT * FROM d.t;
# ----
# 1
# 2
# 3
# 4
# 5

# ensure we can't add a regular region
# this is due to a validation that ensures a primary region exists
# before a "regular" region exists
exec-sql
ALTER DATABASE d ADD REGION "us-west-1";
----
pq: cannot add region "us-west-1" to database d
HINT: you must add a PRIMARY REGION first using ALTER DATABASE d PRIMARY REGION "us-west-1"

# we also can't add a primary region to our regionless database now
# TODO (before merge)
exec-sql
ALTER DATABASE d PRIMARY REGION "us-west-1";
----
pq: cannot convert database d to a multi-region database
DETAIL: cannot convert table t to a multi-region table as it is partitioned

exec-sql
DROP TABLE d.t;
----

# ensure that restoring just the table itself works
# TODO (before merge)
exec-sql
RESTORE TABLE d.t FROM LATEST IN 'nodelocal://1/rbr_table_backup/' WITH strip_localities;
----
pq: "crdb_internal_region" is not compatible with type "crdb_internal_region" existing in cluster: "crdb_internal_region" of type "ENUM" is not compatible with type "MULTIREGION_ENUM"

# query-sql
# SHOW TABLES FROM d;
# ----
# public t table root <nil> <nil>
#
# # ensure that tables belonging to d can be modified & have the correct values
# exec-sql
# INSERT INTO d.t VALUES (4), (5);
# ----
#
# query-sql
# SELECT * FROM d.t;
# ----
# 1
# 2
# 3
# 4
# 5

subtest end
