// Copyright 2022 The Cockroach Authors.
//
// Licensed as a CockroachDB Enterprise file under the Cockroach Community
// License (the "License"); you may not use this file except in compliance with
// the License. You may obtain a copy of the License at
//
//     https://github.com/cockroachdb/cockroach/blob/master/licenses/CCL.txt

package sqlproxyccl

import (
	"encoding/binary"
	"net"

	"github.com/cockroachdb/cockroach/pkg/util/randutil"
	"github.com/cockroachdb/cockroach/pkg/util/syncutil"
	pgproto3 "github.com/jackc/pgproto3/v2"
)

// cancelInfo contains the information that sqlproxy needs in order to cancel
// a query using the pgwire cancellationo protocol.
type cancelInfo struct {
	// origBackendKeyData is the cancel key originally generated by a SQL node.
	origBackendKeyData *pgproto3.BackendKeyData
	// proxyBackendKeyData is the cancel key generated by sqlproxy, which is
	// sent to the client.
	proxyBackendKeyData *pgproto3.BackendKeyData
	// crdbAddr is the address of the SQL node that generated origBackendKeyData.
	crdbAddr net.Addr
	// clientAddr is the address where proxyBackendKeyData is sent to.
	clientAddr net.Addr
}

// makeCancelInfo creates a new cancelInfo struct based on the provided data.
func makeCancelInfo(
	origKeyData *pgproto3.BackendKeyData, localAddr, crdbAddr, clientAddr net.Addr,
) *cancelInfo {
	proxySecretID := randutil.FastUint32()
	localIP := localAddr.(*net.TCPAddr).IP.To4()
	if localIP == nil {
		// IP may be nil if the local address was an IPv6 address.
		localIP = make([]byte, 4)
	}
	proxyKeyData := &pgproto3.BackendKeyData{
		ProcessID: binary.BigEndian.Uint32(localIP),
		SecretKey: proxySecretID,
	}
	return &cancelInfo{
		origBackendKeyData:  origKeyData,
		proxyBackendKeyData: proxyKeyData,
		crdbAddr:            crdbAddr,
		clientAddr:          clientAddr,
	}
}

// proxyIP returns the IP address that is embedded in the given CancelRequest.
func toProxyIP(req *pgproto3.CancelRequest) net.IP {
	ip := make(net.IP, 4)
	binary.BigEndian.PutUint32(ip, req.ProcessID)
	return ip
}

// proxySecretID returns the random secret that was generated to make this
// cancelInfo.
func (c *cancelInfo) proxySecretID() uint32 {
	return c.proxyBackendKeyData.SecretKey
}

// cancelInfoMap contains all the cancelInfo objects that this proxy instance
// is aware of. It is safe for concurrent use, and is keyed by a secret that
// is shared between the proxy and the client.
type cancelInfoMap struct {
	syncutil.RWMutex
	m map[uint32]*cancelInfo
}

func makeCancelInfoMap() *cancelInfoMap {
	return &cancelInfoMap{
		m: make(map[uint32]*cancelInfo),
	}
}

func (c *cancelInfoMap) addCancelInfo(proxySecretID uint32, info *cancelInfo) {
	c.Lock()
	defer c.Unlock()
	c.m[proxySecretID] = info
}

func (c *cancelInfoMap) deleteCancelInfo(proxySecretID uint32) {
	c.Lock()
	defer c.Unlock()
	delete(c.m, proxySecretID)
}

func (c *cancelInfoMap) getCancelInfo(proxySecretID uint32) (*cancelInfo, bool) {
	c.RLock()
	defer c.RUnlock()
	i, ok := c.m[proxySecretID]
	return i, ok
}
