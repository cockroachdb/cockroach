// Copyright 2022 The Cockroach Authors.
//
// Licensed as a CockroachDB Enterprise file under the Cockroach Community
// License (the "License"); you may not use this file except in compliance with
// the License. You may obtain a copy of the License at
//
//     https://github.com/cockroachdb/cockroach/blob/master/licenses/CCL.txt

package sqlproxyccl

import (
	"encoding/binary"
	"net"

	"github.com/cockroachdb/cockroach/pkg/util/randutil"
	"github.com/cockroachdb/cockroach/pkg/util/syncutil"
	pgproto3 "github.com/jackc/pgproto3/v2"
)

// cancelInfo contains the information that sqlproxy needs in order to cancel
// a query using the pgwire cancellationo protocol.
type cancelInfo struct {
	// proxyBackendKeyData is the cancel key generated by sqlproxy, which is
	// sent to the client.
	proxyBackendKeyData *pgproto3.BackendKeyData
	// clientAddr is the address where proxyBackendKeyData is sent to.
	clientAddr *net.TCPAddr

	// mu protects the fields of cancelInfo that can be modified as a result of
	// a session transfer.
	mu struct {
		syncutil.RWMutex
		// origBackendKeyData is the cancel key originally generated by a SQL node.
		origBackendKeyData *pgproto3.BackendKeyData
		// crdbAddr is the address of the SQL node that generated origBackendKeyData.
		crdbAddr net.Addr
	}
}

// makeCancelInfo creates a new cancelInfo struct based on the provided data.
// The caller of the connector is responsible for setting the backend address
// and cancel key.
func makeCancelInfo(localAddr, clientAddr net.Addr) *cancelInfo {
	proxySecretID := randutil.FastUint32()
	localIP := localAddr.(*net.TCPAddr).IP.To4()
	if localIP == nil {
		// IP may be nil if the local address was an IPv6 address.
		localIP = make([]byte, 4)
	}
	proxyKeyData := &pgproto3.BackendKeyData{
		ProcessID: binary.BigEndian.Uint32(localIP),
		SecretKey: proxySecretID,
	}
	return &cancelInfo{
		proxyBackendKeyData: proxyKeyData,
		clientAddr:          clientAddr.(*net.TCPAddr),
	}
}

// proxyIP returns the IP address of the sqlproxy instance that created this
// cancelInfo.
func (c *cancelInfo) proxyIP() net.IP {
	ip := make(net.IP, 4)
	binary.BigEndian.PutUint32(ip, c.proxyBackendKeyData.ProcessID)
	return ip
}

// proxySecretID returns the random secret that was generated to make this
// cancelInfo.
func (c *cancelInfo) proxySecretID() uint32 {
	return c.proxyBackendKeyData.SecretKey
}

// setNewBackend atomically sets a new backend cancel key and address.
func (c *cancelInfo) setNewBackend(
	newBackendKeyData *pgproto3.BackendKeyData, newCrdbAddr *net.TCPAddr,
) {
	c.mu.Lock()
	defer c.mu.Unlock()
	c.mu.origBackendKeyData = newBackendKeyData
	c.mu.crdbAddr = newCrdbAddr
}

// cancelInfoMap contains all the cancelInfo objects that this proxy instance
// is aware of. It is safe for concurrent use, and is keyed by a secret that
// is shared between the proxy and the client.
type cancelInfoMap struct {
	syncutil.RWMutex
	m map[uint32]*cancelInfo
}

func makeCancelInfoMap() *cancelInfoMap {
	return &cancelInfoMap{
		m: make(map[uint32]*cancelInfo),
	}
}

func (c *cancelInfoMap) addCancelInfo(proxySecretID uint32, info *cancelInfo) {
	c.Lock()
	defer c.Unlock()
	c.m[proxySecretID] = info
}

func (c *cancelInfoMap) deleteCancelInfo(proxySecretID uint32) {
	c.Lock()
	defer c.Unlock()
	delete(c.m, proxySecretID)
}

func (c *cancelInfoMap) getCancelInfo(proxySecretID uint32) (*cancelInfo, bool) {
	c.RLock()
	defer c.RUnlock()
	i, ok := c.m[proxySecretID]
	return i, ok
}
