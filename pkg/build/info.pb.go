// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: build/info.proto

package build

import (
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// Info describes build information for this CockroachDB binary.
type Info struct {
	// go_version is the version of the Go toolchain used to compile this executable.
	GoVersion string `protobuf:"bytes,1,opt,name=go_version,json=goVersion" json:"go_version"`
	// tag is the git tag for the revision of the source code for this executable.
	Tag string `protobuf:"bytes,2,opt,name=tag" json:"tag"`
	// time is the time at which the build started.
	Time string `protobuf:"bytes,3,opt,name=time" json:"time"`
	// revision is the git commit identifier for the source code of this executable.
	Revision string `protobuf:"bytes,4,opt,name=revision" json:"revision"`
	// cgo_compiler is the C/C++ compiler used to build non-go dependencies.
	CgoCompiler string `protobuf:"bytes,5,opt,name=cgo_compiler,json=cgoCompiler" json:"cgo_compiler"`
	// cgo_target_triple is the platform identifier that identifies the cross-compilation target for C/C++ components.
	CgoTargetTriple string `protobuf:"bytes,10,opt,name=cgo_target_triple,json=cgoTargetTriple" json:"cgo_target_triple"`
	// platform is the platform identifiers that identifies the cross-compilation target for Go code.
	Platform string `protobuf:"bytes,6,opt,name=platform" json:"platform"`
	// distribution indicates which licensing conditions apply (OSS: full open source; CCL: includes CCL code).
	Distribution string `protobuf:"bytes,7,opt,name=distribution" json:"distribution"`
	// type indicates whether this is a development or release build.
	Type string `protobuf:"bytes,8,opt,name=type" json:"type"`
	// channel identifies through which product channel the executable was released.
	Channel string `protobuf:"bytes,9,opt,name=channel" json:"channel"`
	// env_channel identifies the product channel as overridden by the COCKROACH_CHANNEL environment variable.
	EnvChannel string `protobuf:"bytes,11,opt,name=env_channel,json=envChannel" json:"env_channel"`
	// go_plus identifies whether the binary was produced against a customized go runtime.
	// See: github.com/cockroachdb/go-plus.
	GoPlus bool `protobuf:"varint,12,opt,name=go_plus,json=goPlus" json:"go_plus"`
	// dependencies exists to allow tests that run against old clusters
	// to unmarshal JSON containing this field. The tag is unimportant,
	// but the field name must remain unchanged.
	//
	// alternatively, we could set jsonpb.Unmarshaler.AllowUnknownFields
	// to true in httputil.doJSONRequest, but that comes at the expense
	// of run-time type checking, which is nice to have.
	Dependencies *string `protobuf:"bytes,10000,opt,name=dependencies" json:"dependencies,omitempty"`
}

func (m *Info) Reset()         { *m = Info{} }
func (m *Info) String() string { return proto.CompactTextString(m) }
func (*Info) ProtoMessage()    {}
func (*Info) Descriptor() ([]byte, []int) {
	return fileDescriptor_4e07f274d5866c11, []int{0}
}
func (m *Info) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Info) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *Info) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Info.Merge(m, src)
}
func (m *Info) XXX_Size() int {
	return m.Size()
}
func (m *Info) XXX_DiscardUnknown() {
	xxx_messageInfo_Info.DiscardUnknown(m)
}

var xxx_messageInfo_Info proto.InternalMessageInfo

func init() {
	proto.RegisterType((*Info)(nil), "cockroach.build.Info")
}

func init() { proto.RegisterFile("build/info.proto", fileDescriptor_4e07f274d5866c11) }

var fileDescriptor_4e07f274d5866c11 = []byte{
	// 360 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x54, 0x92, 0xc1, 0x8a, 0xdb, 0x30,
	0x10, 0x40, 0xed, 0xc6, 0xbb, 0x49, 0x26, 0x86, 0x6d, 0x45, 0x29, 0xa2, 0x50, 0x35, 0x74, 0x29,
	0x9b, 0xd3, 0x6e, 0xbf, 0x61, 0x73, 0xea, 0xa5, 0x94, 0x10, 0x7a, 0xe8, 0xc5, 0x38, 0xb2, 0xa2,
	0x88, 0x3a, 0x1a, 0x21, 0xcb, 0x86, 0xfc, 0x45, 0x3e, 0x2b, 0xd0, 0x4b, 0x8e, 0x39, 0x95, 0xd6,
	0xf9, 0x91, 0x62, 0x25, 0x59, 0x94, 0x9b, 0x79, 0xef, 0x31, 0xe3, 0x01, 0xc1, 0xeb, 0x45, 0xad,
	0xca, 0xe2, 0x49, 0xe9, 0x25, 0x3e, 0x1a, 0x8b, 0x0e, 0xc9, 0x1d, 0x47, 0xfe, 0xcb, 0x62, 0xce,
	0x57, 0x8f, 0xde, 0xbd, 0x7f, 0x2b, 0x51, 0xa2, 0x77, 0x4f, 0xdd, 0xd7, 0x29, 0xfb, 0xf4, 0xbb,
	0x07, 0xc9, 0x57, 0xbd, 0x44, 0x72, 0x0f, 0x20, 0x31, 0x6b, 0x84, 0xad, 0x14, 0x6a, 0x1a, 0x8f,
	0xe3, 0xc9, 0xf0, 0x39, 0xd9, 0xfd, 0xf9, 0x18, 0xcd, 0x86, 0x12, 0x7f, 0x9c, 0x30, 0x79, 0x07,
	0x3d, 0x97, 0x4b, 0xfa, 0x2a, 0xb0, 0x1d, 0x20, 0x14, 0x12, 0xa7, 0xd6, 0x82, 0xf6, 0x02, 0xe1,
	0x09, 0x19, 0xc3, 0xc0, 0x8a, 0x46, 0xf9, 0xa1, 0x49, 0x60, 0x5f, 0x28, 0x79, 0x80, 0x94, 0x4b,
	0xcc, 0x38, 0xae, 0x8d, 0x2a, 0x85, 0xa5, 0x37, 0x41, 0x35, 0xe2, 0x12, 0xa7, 0x67, 0x41, 0xbe,
	0xc0, 0x9b, 0x2e, 0x74, 0xb9, 0x95, 0xc2, 0x65, 0xce, 0x2a, 0x53, 0x0a, 0x0a, 0x41, 0x7d, 0xc7,
	0x25, 0xce, 0xbd, 0x9d, 0x7b, 0xd9, 0x2d, 0x37, 0x65, 0xee, 0x96, 0x68, 0xd7, 0xf4, 0x36, 0x5c,
	0x7e, 0xa1, 0x64, 0x02, 0x69, 0xa1, 0x2a, 0x67, 0xd5, 0xa2, 0x76, 0xdd, 0x2f, 0xf6, 0x83, 0xea,
	0xca, 0xf8, 0x13, 0x37, 0x46, 0xd0, 0xc1, 0xd5, 0x89, 0x1b, 0x23, 0x08, 0x83, 0x3e, 0x5f, 0xe5,
	0x5a, 0x8b, 0x92, 0x0e, 0x03, 0x79, 0x81, 0xe4, 0x33, 0x8c, 0x84, 0x6e, 0xb2, 0x4b, 0x33, 0x0a,
	0x1a, 0x10, 0xba, 0x99, 0x9e, 0xb3, 0x0f, 0xd0, 0x97, 0x98, 0x99, 0xb2, 0xae, 0x68, 0x3a, 0x8e,
	0x27, 0x83, 0x73, 0x72, 0x2b, 0xf1, 0x7b, 0x59, 0x57, 0xe4, 0x1e, 0xd2, 0x42, 0x18, 0xa1, 0x0b,
	0xa1, 0xb9, 0x12, 0x15, 0xdd, 0x7e, 0xeb, 0xe6, 0xcc, 0xae, 0xe0, 0xf3, 0xc3, 0xee, 0x1f, 0x8b,
	0x76, 0x2d, 0x8b, 0xf7, 0x2d, 0x8b, 0x0f, 0x2d, 0x8b, 0xff, 0xb6, 0x2c, 0xde, 0x1e, 0x59, 0xb4,
	0x3f, 0xb2, 0xe8, 0x70, 0x64, 0xd1, 0xcf, 0x1b, 0xff, 0x18, 0xfe, 0x07, 0x00, 0x00, 0xff, 0xff,
	0x91, 0xe9, 0x2f, 0x57, 0x30, 0x02, 0x00, 0x00,
}

func (m *Info) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Info) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Info) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Dependencies != nil {
		i -= len(*m.Dependencies)
		copy(dAtA[i:], *m.Dependencies)
		i = encodeVarintInfo(dAtA, i, uint64(len(*m.Dependencies)))
		i--
		dAtA[i] = 0x4
		i--
		dAtA[i] = 0xf1
		i--
		dAtA[i] = 0x82
	}
	i--
	if m.GoPlus {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x60
	i -= len(m.EnvChannel)
	copy(dAtA[i:], m.EnvChannel)
	i = encodeVarintInfo(dAtA, i, uint64(len(m.EnvChannel)))
	i--
	dAtA[i] = 0x5a
	i -= len(m.CgoTargetTriple)
	copy(dAtA[i:], m.CgoTargetTriple)
	i = encodeVarintInfo(dAtA, i, uint64(len(m.CgoTargetTriple)))
	i--
	dAtA[i] = 0x52
	i -= len(m.Channel)
	copy(dAtA[i:], m.Channel)
	i = encodeVarintInfo(dAtA, i, uint64(len(m.Channel)))
	i--
	dAtA[i] = 0x4a
	i -= len(m.Type)
	copy(dAtA[i:], m.Type)
	i = encodeVarintInfo(dAtA, i, uint64(len(m.Type)))
	i--
	dAtA[i] = 0x42
	i -= len(m.Distribution)
	copy(dAtA[i:], m.Distribution)
	i = encodeVarintInfo(dAtA, i, uint64(len(m.Distribution)))
	i--
	dAtA[i] = 0x3a
	i -= len(m.Platform)
	copy(dAtA[i:], m.Platform)
	i = encodeVarintInfo(dAtA, i, uint64(len(m.Platform)))
	i--
	dAtA[i] = 0x32
	i -= len(m.CgoCompiler)
	copy(dAtA[i:], m.CgoCompiler)
	i = encodeVarintInfo(dAtA, i, uint64(len(m.CgoCompiler)))
	i--
	dAtA[i] = 0x2a
	i -= len(m.Revision)
	copy(dAtA[i:], m.Revision)
	i = encodeVarintInfo(dAtA, i, uint64(len(m.Revision)))
	i--
	dAtA[i] = 0x22
	i -= len(m.Time)
	copy(dAtA[i:], m.Time)
	i = encodeVarintInfo(dAtA, i, uint64(len(m.Time)))
	i--
	dAtA[i] = 0x1a
	i -= len(m.Tag)
	copy(dAtA[i:], m.Tag)
	i = encodeVarintInfo(dAtA, i, uint64(len(m.Tag)))
	i--
	dAtA[i] = 0x12
	i -= len(m.GoVersion)
	copy(dAtA[i:], m.GoVersion)
	i = encodeVarintInfo(dAtA, i, uint64(len(m.GoVersion)))
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func encodeVarintInfo(dAtA []byte, offset int, v uint64) int {
	offset -= sovInfo(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Info) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.GoVersion)
	n += 1 + l + sovInfo(uint64(l))
	l = len(m.Tag)
	n += 1 + l + sovInfo(uint64(l))
	l = len(m.Time)
	n += 1 + l + sovInfo(uint64(l))
	l = len(m.Revision)
	n += 1 + l + sovInfo(uint64(l))
	l = len(m.CgoCompiler)
	n += 1 + l + sovInfo(uint64(l))
	l = len(m.Platform)
	n += 1 + l + sovInfo(uint64(l))
	l = len(m.Distribution)
	n += 1 + l + sovInfo(uint64(l))
	l = len(m.Type)
	n += 1 + l + sovInfo(uint64(l))
	l = len(m.Channel)
	n += 1 + l + sovInfo(uint64(l))
	l = len(m.CgoTargetTriple)
	n += 1 + l + sovInfo(uint64(l))
	l = len(m.EnvChannel)
	n += 1 + l + sovInfo(uint64(l))
	n += 2
	if m.Dependencies != nil {
		l = len(*m.Dependencies)
		n += 3 + l + sovInfo(uint64(l))
	}
	return n
}

func sovInfo(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozInfo(x uint64) (n int) {
	return sovInfo(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Info) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInfo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Info: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Info: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GoVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInfo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInfo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInfo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GoVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tag", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInfo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInfo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInfo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tag = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInfo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInfo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInfo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Time = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Revision", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInfo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInfo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInfo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Revision = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CgoCompiler", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInfo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInfo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInfo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CgoCompiler = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Platform", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInfo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInfo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInfo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Platform = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Distribution", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInfo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInfo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInfo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Distribution = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInfo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInfo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInfo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Channel", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInfo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInfo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInfo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Channel = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CgoTargetTriple", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInfo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInfo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInfo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CgoTargetTriple = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnvChannel", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInfo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInfo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInfo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EnvChannel = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GoPlus", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInfo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.GoPlus = bool(v != 0)
		case 10000:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dependencies", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInfo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInfo
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInfo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Dependencies = &s
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipInfo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthInfo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipInfo(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowInfo
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowInfo
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowInfo
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthInfo
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupInfo
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthInfo
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthInfo        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowInfo          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupInfo = fmt.Errorf("proto: unexpected end of group")
)
