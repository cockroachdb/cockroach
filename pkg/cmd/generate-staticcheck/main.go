// Copyright 2021 The Cockroach Authors.
//
// Use of this software is governed by the Business Source License
// included in the file licenses/BSL.txt.
//
// As of the Change Date specified in that file, in accordance with
// the Business Source License, use of this software will be governed
// by the Apache License, Version 2.0, included in the file
// licenses/APL.txt.
package main

import (
	"os"
	"path/filepath"
	"sort"
	"strings"
	"text/template"

	"honnef.co/go/tools/analysis/lint"
	"honnef.co/go/tools/simple"
	"honnef.co/go/tools/staticcheck"
	"honnef.co/go/tools/stylecheck"
	"honnef.co/go/tools/unused"
)

const (
	readmeContent = `All of the code in this directory is generated by generate-staticcheck for use in Bazel.
`
	buildBazelContent    = `exports_files(["def.bzl"])`
	analysisFileTemplate = `// Code generated by generate-staticcheck; DO NOT EDIT.

//go:build bazel
// +build bazel

package {{ .Package }}

import ({{ if ne .CheckType "unused" }}
	util "github.com/cockroachdb/cockroach/pkg/testutils/lint/passes/staticcheck"{{ end }}
	"golang.org/x/tools/go/analysis"
	"honnef.co/go/tools/{{ .CheckType }}"
)

var Analyzer *analysis.Analyzer

func init() {
{{ if eq .CheckType "unused" }}	Analyzer = {{ .CheckType }}.Analyzer.Analyzer
{{ else }}	for _, analyzer := range {{ .CheckType }}.Analyzers {
		if analyzer.Analyzer.Name == "{{ .Check }}" {
			Analyzer = analyzer.Analyzer
			break
		}
	}
	util.MungeAnalyzer(Analyzer)
{{ end }}}
`
	defBzlFileTemplate = `# Code generated by generate-staticcheck; DO NOT EDIT.

STATICCHECK_CHECKS = [
{{range $i,$a := .AllAnalyzers}}    "{{.}}",
{{end}}]
`
)

func main() {
	fileTpl := template.Must(template.New("source").Parse(analysisFileTemplate))
	rootDir := "build/bazelutil/staticcheckanalyzers"
	err := os.RemoveAll(rootDir)
	if err != nil {
		panic(err)
	}
	err = os.MkdirAll(rootDir, 0755)
	if err != nil {
		panic(err)
	}
	err = os.WriteFile(filepath.Join(rootDir, "README.md"), []byte(readmeContent), 0644)
	if err != nil {
		panic(err)
	}
	err = os.WriteFile(filepath.Join(rootDir, "BUILD.bazel"), []byte(buildBazelContent), 0644)
	if err != nil {
		panic(err)
	}
	// All of these analyzers will be written to def.bzl.
	var allAnalyzers []string
	for _, check := range []struct {
		Analyzers []*lint.Analyzer
		CheckType string
	}{
		// TODO: Consider adding quickfix checks.
		{Analyzers: staticcheck.Analyzers, CheckType: "staticcheck"},
		{Analyzers: stylecheck.Analyzers, CheckType: "stylecheck"},
		{Analyzers: simple.Analyzers, CheckType: "simple"},
		{Analyzers: []*lint.Analyzer{unused.Analyzer}, CheckType: "unused"},
	} {
		for _, v := range check.Analyzers {
			analyzer := v.Analyzer
			pkgname := strings.ToLower(analyzer.Name)
			dirname := filepath.Join(rootDir, pkgname)
			err := os.MkdirAll(dirname, 0755)
			if err != nil {
				panic(err)
			}
			outFile, err := os.Create(filepath.Join(dirname, "analyzer.go"))
			if err != nil {
				panic(err)
			}
			err = fileTpl.Execute(outFile, struct {
				Package   string
				Check     string
				CheckType string
			}{Package: pkgname, Check: analyzer.Name, CheckType: check.CheckType})
			if err != nil {
				panic(err)
			}
			err = outFile.Close()
			if err != nil {
				panic(err)
			}
			allAnalyzers = append(allAnalyzers, "//"+dirname)
		}
	}
	sort.Strings(allAnalyzers)
	fileTpl = template.Must(template.New("defbzl").Parse(defBzlFileTemplate))
	defBzlFile, err := os.Create(filepath.Join(rootDir, "def.bzl"))
	if err != nil {
		panic(err)
	}
	err = fileTpl.Execute(defBzlFile, struct{ AllAnalyzers []string }{AllAnalyzers: allAnalyzers})
	if err != nil {
		panic(err)
	}
}
