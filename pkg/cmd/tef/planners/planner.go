// Copyright 2026 The Cockroach Authors.
//
// Use of this software is governed by the CockroachDB Software License
// included in the /LICENSE file.

// Package planners provide the BasePlanner implementation, which is the core
// framework-agnostic planner for TEF. BasePlanner manages task registration,
// executor registration, and performs comprehensive validation of task execution
// graphs, including cycle detection and convergence checks.
package planners

import (
	"context"
	"reflect"
	"strings"

	"github.com/cockroachdb/errors"
)

// BasePlanner represents the core planner implementation that manages task execution flows.
// It maintains registries of tasks and executors and tracks the first and output tasks
// in the execution chain.
type BasePlanner struct {
	Name            string
	Description     string
	WorkflowVersion int // Current version of the workflow definition (default: 1)
	First           Task
	// Output is optional and specifies the task whose return value should be the return value of the workflow.
	// It is not the EndTask; rather, it identifies which task's output should be captured as the plan's result.
	// Only set this field if the plan needs to provide an output value.
	Output           Task
	TasksRegistry    map[string]Task
	ExecutorRegistry map[string]*Executor
	Registered       bool
}

// The BasePlanner type implements the Planner interface.
var _ Planner = &BasePlanner{}

// NewBasePlanner creates a new BasePlanner instance from a registry.
// The plan is generated by calling the registry's GeneratePlan method, and then
// the entire plan structure is validated before being returned.
func NewBasePlanner(ctx context.Context, r Registry) (*BasePlanner, error) {
	workflowVersion := r.GetPlanVersion()
	// Workflow version must be at least 1
	if workflowVersion < 1 {
		return nil, errors.Newf("workflow version %d is less than 1 for plan <%s>", workflowVersion, r.GetPlanName())
	}
	p := &BasePlanner{
		Name:             r.GetPlanName(),
		Description:      r.GetPlanDescription(),
		WorkflowVersion:  workflowVersion,
		TasksRegistry:    make(map[string]Task),
		ExecutorRegistry: make(map[string]*Executor),
	}
	r.GeneratePlan(ctx, p)
	return p, p.validate(ctx)
}

// RegisterPlan marks the planner as registered and sets the first and output tasks.
// This method must be called during plan generation to complete the plan setup.
func (bp *BasePlanner) RegisterPlan(_ context.Context, first, output Task) {
	bp.First = first
	bp.Output = output
	bp.Registered = true
}

// NewEndTask creates and registers a new end task with the given name.
// An end task marks the termination point of a task execution chain.
func (bp *BasePlanner) NewEndTask(ctx context.Context, name string) *EndTask {
	task := &EndTask{}
	task.taskName = name
	bp.registerTask(ctx, task)
	return task
}

// RegisterExecutor adds an executor to the planner's executor registry.
// If an executor with the same name is already registered, it panics.
func (bp *BasePlanner) RegisterExecutor(_ context.Context, executor *Executor) {
	if _, exists := bp.ExecutorRegistry[executor.Name]; exists {
		panic(errors.AssertionFailedf("executor <%s> is already registered for plan <%s>", executor.Name, bp.Name))
	}
	bp.ExecutorRegistry[executor.Name] = executor
}

// NewExecutionTask creates and registers a new execution task with the given name.
// An execution task runs a specific executor as part of the workflow.
func (bp *BasePlanner) NewExecutionTask(ctx context.Context, name string) *ExecutionTask {
	task := &ExecutionTask{}
	task.taskName = name
	bp.registerTask(ctx, task)
	return task
}

// NewForkTask creates and registers a new fork task with the given name.
// A fork task allows parallel execution of multiple task branches.
func (bp *BasePlanner) NewForkTask(ctx context.Context, name string) *ForkTask {
	task := &ForkTask{}
	task.taskName = name
	bp.registerTask(ctx, task)
	return task
}

// NewForkJoinTask creates and registers a new fork join task with the given name.
// A fork join task acts as a synchronization point where parallel fork branches converge.
func (bp *BasePlanner) NewForkJoinTask(ctx context.Context, name string) *ForkJoinTask {
	task := &ForkJoinTask{}
	task.taskName = name
	bp.registerTask(ctx, task)
	return task
}

// NewConditionTask creates and registers a new condition task with the given name.
// A condition task provides conditional branching based on executor results.
func (bp *BasePlanner) NewConditionTask(ctx context.Context, name string) *ConditionTask {
	task := &ConditionTask{}
	task.taskName = name
	bp.registerTask(ctx, task)
	return task
}

// NewCallbackTask creates and registers a new callback task with the given name.
// A callback task starts an operation and waits for external completion via signal.
func (bp *BasePlanner) NewCallbackTask(ctx context.Context, name string) *CallbackTask {
	task := &CallbackTask{}
	task.taskName = name
	bp.registerTask(ctx, task)
	return task
}

// NewChildWorkflowTask creates and registers a new child task with the given name.
// A child task executes a child plan synchronously and waits for completion.
func (bp *BasePlanner) NewChildPlanTask(ctx context.Context, name string) *ChildPlanTask {
	task := &ChildPlanTask{}
	task.taskName = name
	bp.registerTask(ctx, task)
	return task
}

// registerTask adds a task to the planner's task registry.
// If a task with the same name is already registered, it panics,
// ensuring task names remain unique within a plan.
func (bp *BasePlanner) registerTask(_ context.Context, task Task) {
	if _, ok := bp.TasksRegistry[task.Name()]; ok {
		panic(errors.AssertionFailedf("task with name <%s> is already registered for the plan <%s>", task.Name(), bp.Name))
	}
	bp.TasksRegistry[task.Name()] = task
}

// validate performs comprehensive validation of the planner and its task chain. The
// plan name is checked for invalid characters (whitespace and dots), registration
// status is verified, and the entire task chain is validated for structural
// correctness and cycle detection.
func (bp *BasePlanner) validate(ctx context.Context) error {
	// The plan name must not contain whitespace characters or dots.
	// Dots are reserved as separators in plan IDs (e.g., "tef.planName.variant").
	if strings.ContainsAny(bp.Name, " \t\n\r.") {
		return errors.Newf("plan name <%s> cannot contain whitespace, new line, or dots", bp.Name)
	}
	// The plan must be registered before validation.
	if !bp.Registered {
		return errors.Newf("the plan <%s> is not registered", bp.Name)
	}
	// The plan must have a defined starting task.
	if bp.First == nil {
		return errors.Newf("planner <%s> has no first task", bp.Name)
	}

	// The visited map tracks which tasks have been validated and their termination points.
	// Key format: "taskName:failedPath" to distinguish normal vs failure path contexts.
	// Termination points can be EndTask (actual termination) or ForkJoinTask (synchronization).
	visited := make(map[string]Task)
	// The currentPath map is used for cycle detection during traversal.
	currentPath := make(map[string]bool)
	_, err := bp.validateTaskChain(ctx, bp.First, visited, currentPath, false)
	// Note: Output task is optional and not validated here. It specifies the task whose return value
	// should be the return value of the workflow (not the EndTask). Only needed if the plan provides an output.
	return err
}

// makeValidationKey generates a composite cache key that distinguishes tasks by both name and context.
// This prevents cache poisoning where the same task is reached via both normal and failure paths.
func makeValidationKey(taskName string, failedPath bool) string {
	if failedPath {
		return taskName + ":failed"
	}
	return taskName + ":normal"
}

// validateTaskChain recursively validates a task and its entire downstream chain.
// It detects cycles by tracking the current execution path, allows valid convergence
// where multiple branches lead to the same task, and ensures all paths terminate at
// compatible termination points (EndTask or ForkJoinTask). The visited map caches
// validation results, while currentPath tracks the active traversal path for cycle detection.
func (bp *BasePlanner) validateTaskChain(
	ctx context.Context,
	task Task,
	visited map[string]Task,
	currentPath map[string]bool,
	failedPath bool,
) (Task, error) {
	// Nil tasks in the chain are invalid.
	if task == nil {
		return nil, errors.New("task chain has nil task")
	}

	// A task appearing in the current path indicates a cyclic dependency.
	if currentPath[task.Name()] {
		return nil, errors.Newf("cyclic dependency detected: task <%s> appears in its own execution path", task.Name())
	}

	// A task already visited in the same context (normal vs failure path) represents valid convergence,
	// where multiple execution branches lead to the same task. Use composite key to distinguish contexts.
	cacheKey := makeValidationKey(task.Name(), failedPath)
	if endTask, ok := visited[cacheKey]; ok {
		return endTask, nil
	}

	// The task's internal validation is performed after cache check to avoid redundant validation.
	// The failedPath parameter is passed to validate() to enable parameter count checks for failure handlers.
	if err := task.validate(failedPath); err != nil {
		return nil, err
	}

	// Validate that ExecutorFn is registered in the ExecutorRegistry for tasks that use executors.
	if err := bp.validateExecutorRegistration(task); err != nil {
		return nil, err
	}

	// The task is added to the current path for cycle detection.
	currentPath[task.Name()] = true
	// The task is removed from the current path when this function returns,
	// allowing the same task to appear in different branches (convergence).
	defer delete(currentPath, task.Name())

	switch task.Type() {
	case TaskTypeEndTask:
		// An EndTask represents a valid termination point for the task chain.
		endTask := task.(*EndTask)
		visited[cacheKey] = endTask
		return endTask, nil

	case TaskTypeForkJoinTask:
		// A ForkJoinTask is a synchronization point for fork branches.
		// It does not have Next or Fail paths - it only acts as a barrier.
		// Fork branches terminate at this join point, then the parent ForkTask continues.
		visited[cacheKey] = task
		return task, nil

	case TaskTypeExecution:
		// An ExecutionTask runs an executor and has Next and optional Fail paths.
		execTask := task.(*ExecutionTask)
		endTask, err := bp.validateStepTaskPaths(ctx, task.Name(), &execTask.stepTask, visited, currentPath, failedPath)
		if err != nil {
			return nil, err
		}
		visited[cacheKey] = endTask
		return endTask, nil

	case TaskTypeFork:
		// Fork tasks are not allowed in failure paths.
		if failedPath {
			return nil, errors.Newf("fork task <%s> is not allowed for the failure flow.", task.Name())
		}
		forkTask := task.(*ForkTask)

		// All parallel branches in a ForkTask must converge to the specified Join point.
		// The Join point acts as a synchronization barrier.
		for i, forkedTask := range forkTask.Tasks {
			if forkedTask == nil {
				return nil, errors.Newf("fork task <%s> has nil task at index %d", task.Name(), i)
			}
			forkedEnd, err := bp.validateTaskChain(ctx, forkedTask, visited, currentPath, failedPath)
			if err != nil {
				return nil, err
			}
			// Check that the branch converges to the Join point.
			// Each branch must terminate at the ForkJoinTask specified by Join.
			if forkedEnd == nil || forkedEnd.Name() != forkTask.Join.Name() {
				expectedName := forkTask.Join.Name()
				actualName := "nil"
				if forkedEnd != nil {
					actualName = forkedEnd.Name()
				}
				return nil, errors.Newf("fork task <%s> branch %d converges to <%s> instead of the specified Join point <%s>",
					task.Name(), i, actualName, expectedName)
			}
		}

		// The ForkTask's Next and Fail paths are validated after the parallel branches.
		endTask, err := bp.validateStepTaskPaths(ctx, task.Name(), &forkTask.stepTask, visited, currentPath, failedPath)
		if err != nil {
			return nil, err
		}
		visited[cacheKey] = endTask
		return endTask, nil

	case TaskTypeConditionTask:
		// A ConditionTask requires both Then and Else branches to be defined.
		conditionTask := task.(*ConditionTask)
		// The Then branch is validated first.
		thenEnd, err := bp.validateTaskChain(ctx, conditionTask.Then, visited, currentPath, failedPath)
		if err != nil {
			return nil, err
		}

		// The Else branch is validated next.
		elseEnd, err := bp.validateTaskChain(ctx, conditionTask.Else, visited, currentPath, failedPath)
		if err != nil {
			return nil, err
		}

		// Both the Then and Else branches must converge to the same EndTask.
		if thenEnd != elseEnd {
			return nil, errors.Newf("condition task <%s> has Then and Else branches that converge to different EndTasks (<%s> vs <%s>)",
				task.Name(), thenEnd.Name(), elseEnd.Name())
		}

		visited[cacheKey] = thenEnd
		return thenEnd, nil

	case TaskTypeCallbackTask:
		// A CallbackTask runs an executor that starts an operation and waits for external completion.
		callbackTask := task.(*CallbackTask)
		endTask, err := bp.validateStepTaskPaths(ctx, task.Name(), &callbackTask.stepTask, visited, currentPath, failedPath)
		if err != nil {
			return nil, err
		}
		visited[cacheKey] = endTask
		return endTask, nil

	case TaskTypeChildPlanTask:
		// A ChildPlanTask executes a child plan synchronously and has Next and optional Fail paths.
		childTask := task.(*ChildPlanTask)
		endTask, err := bp.validateStepTaskPaths(ctx, task.Name(), &childTask.stepTask, visited, currentPath, failedPath)
		if err != nil {
			return nil, err
		}
		visited[cacheKey] = endTask
		return endTask, nil

	default:
		return nil, errors.Newf("unknown task type <%s> for task <%s>", task.Type(), task.Name())
	}
}

// validateStepTaskPaths validates the Next and Fail paths for stepTask types.
// When in a failure path, only the Fail path is validated. Otherwise, the Next path
// is validated, and if a Fail path exists, it must converge to the same termination
// point as the Next path to ensure a consistent execution flow.
func (bp *BasePlanner) validateStepTaskPaths(
	ctx context.Context,
	taskName string,
	st *stepTask,
	visited map[string]Task,
	currentPath map[string]bool,
	failedPath bool,
) (Task, error) {
	if failedPath {
		// In a failure path, the Fail task must be defined.
		if st.Fail == nil {
			return nil, errors.Newf("task <%s> has no Fail task and doesn't end with a termination point in the failure flow", taskName)
		}
		// The Fail path is validated recursively with failedPath=true.
		// The failedPath flag is "sticky" - once in a failure path, all subsequent tasks
		// (including nested Fail handlers) remain in the failure path. This matches
		// runtime behavior where hasFailed=true is propagated throughout the entire chain.
		return bp.validateTaskChain(ctx, st.Fail, visited, currentPath, true)
	}

	// In a normal path, the Next task must be defined.
	if st.Next == nil {
		return nil, errors.Newf("task <%s> has no Next task and doesn't end with a termination point", taskName)
	}

	// The Next path is validated recursively.
	nextEnd, err := bp.validateTaskChain(ctx, st.Next, visited, currentPath, failedPath)
	if err != nil {
		return nil, err
	}

	// If a Fail path exists, it must converge to the same termination point as the Next path.
	if st.Fail != nil {
		failEnd, err := bp.validateTaskChain(ctx, st.Fail, visited, currentPath, true)
		if err != nil {
			return nil, err
		}
		if failEnd != nextEnd {
			return nil, errors.Newf("task <%s> has Next and Fail paths that converge to different termination points (<%s> vs <%s>)",
				taskName, nextEnd.Name(), failEnd.Name())
		}
	}
	return nextEnd, nil
}

// validateExecutorRegistration checks that ExecutorFn used in tasks is registered in ExecutorRegistry.
// This validation ensures that all executors referenced by tasks have been properly registered with the planner.
func (bp *BasePlanner) validateExecutorRegistration(task Task) error {
	var executorFns []interface{}

	// Extract the ExecutorFn based on a task type.
	switch task.Type() {
	case TaskTypeExecution:
		executorFns = []interface{}{task.(*ExecutionTask).ExecutorFn}
	case TaskTypeConditionTask:
		executorFns = []interface{}{task.(*ConditionTask).ExecutorFn}
	case TaskTypeCallbackTask:
		callbackTask := task.(*CallbackTask)
		executorFns = []interface{}{callbackTask.ExecutionFn, callbackTask.ResultProcessorFn}
	case TaskTypeChildPlanTask:
		executorFns = []interface{}{task.(*ChildPlanTask).ChildTaskInfoFn}
	default:
		// Other task types don't use executors, so no validation needed.
		return nil
	}

	// Check if each executor function is registered in the ExecutorRegistry.
	for _, executorFn := range executorFns {
		// Use reflection to compare function pointers since functions are not directly comparable.
		var matchedExecutor *Executor
		for _, executor := range bp.ExecutorRegistry {
			if reflect.ValueOf(executor.Func).Pointer() == reflect.ValueOf(executorFn).Pointer() {
				matchedExecutor = executor
				break
			}
		}

		if matchedExecutor == nil {
			return errors.Newf("executor function for task <%s> is not registered in ExecutorRegistry", task.Name())
		}

		// Check if the executor is deprecated.
		if matchedExecutor.Deprecated {
			return errors.Newf("task <%s> uses deprecated executor <%s>", task.Name(), matchedExecutor.Name)
		}
	}

	return nil
}
