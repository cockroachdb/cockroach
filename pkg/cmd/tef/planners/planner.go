// Copyright 2026 The Cockroach Authors.
//
// Use of this software is governed by the CockroachDB Software License
// included in the /LICENSE file.

// Package planners provide the BasePlanner implementation, which is the core
// framework-agnostic planner for TEF. BasePlanner manages task registration,
// executor registration, and performs comprehensive validation of task execution
// graphs, including cycle detection and convergence checks.
package planners

import (
	"context"
	"fmt"
	"reflect"
	"strings"

	"github.com/cockroachdb/errors"
)

// BasePlanner represents the core planner implementation that manages task execution flows.
// It maintains registries of tasks and executors and tracks the first and output tasks
// in the execution chain.
type BasePlanner struct {
	Name             string
	Description      string
	WorkflowVersion  int // Current version of the workflow definition (default: 1)
	First            Task
	Output           Task
	TasksRegistry    map[string]Task
	ExecutorRegistry map[string]*Executor
	Registered       bool
}

// The BasePlanner type implements the Planner interface.
var _ Planner = &BasePlanner{}

// NewBasePlanner creates a new BasePlanner instance from a registry.
// The plan is generated by calling the registry's GeneratePlan method, and then
// the entire plan structure is validated before being returned.
func NewBasePlanner(ctx context.Context, r Registry) (*BasePlanner, error) {
	workflowVersion := r.GetWorkflowVersion()
	// Workflow version must be at least 1
	if workflowVersion < 1 {
		panic(fmt.Sprintf("workflow version %d is less than 1 for plan <%s>", workflowVersion, r.GetPlanName()))
	}
	p := &BasePlanner{
		Name:             r.GetPlanName(),
		Description:      r.GetPlanDescription(),
		WorkflowVersion:  workflowVersion,
		TasksRegistry:    make(map[string]Task),
		ExecutorRegistry: make(map[string]*Executor),
	}
	r.GeneratePlan(ctx, p)
	return p, p.validate(ctx)
}

// RegisterPlan marks the planner as registered and sets the first and output tasks.
// This method must be called during plan generation to complete the plan setup.
func (sr *BasePlanner) RegisterPlan(_ context.Context, first, output Task) {
	sr.First = first
	sr.Output = output
	sr.Registered = true
}

// NewEndTask creates and registers a new end task with the given name.
// An end task marks the termination point of a task execution chain.
func (sr *BasePlanner) NewEndTask(ctx context.Context, name string) *EndTask {
	task := &EndTask{}
	task.taskName = name
	sr.registerTask(ctx, task)
	return task
}

// RegisterExecutor adds an executor to the planner's executor registry.
// A panic is triggered if an executor with the same name is already registered.
func (sr *BasePlanner) RegisterExecutor(_ context.Context, executor *Executor) {
	if _, exists := sr.ExecutorRegistry[executor.Name]; exists {
		panic(fmt.Sprintf("executor <%s> is already registered for plan <%s>", executor.Name, sr.Name))
	}
	sr.ExecutorRegistry[executor.Name] = executor
}

// NewExecutionTask creates and registers a new execution task with the given name.
// An execution task runs a specific executor as part of the workflow.
func (sr *BasePlanner) NewExecutionTask(ctx context.Context, name string) *ExecutionTask {
	task := &ExecutionTask{}
	task.taskName = name
	sr.registerTask(ctx, task)
	return task
}

// NewForkTask creates and registers a new fork task with the given name.
// A fork task allows parallel execution of multiple task branches.
func (sr *BasePlanner) NewForkTask(ctx context.Context, name string) *ForkTask {
	task := &ForkTask{}
	task.taskName = name
	sr.registerTask(ctx, task)
	return task
}

// NewIfTask creates and registers a new if task with the given name.
// An if task provides conditional branching based on executor results.
func (sr *BasePlanner) NewIfTask(ctx context.Context, name string) *IfTask {
	task := &IfTask{}
	task.taskName = name
	sr.registerTask(ctx, task)
	return task
}

// NewSleepTask creates and registers a new sleep task with the given name.
// A sleep task sleeps for a duration returned by an executor before continuing.
func (sr *BasePlanner) NewSleepTask(ctx context.Context, name string) *SleepTask {
	task := &SleepTask{}
	task.taskName = name
	sr.registerTask(ctx, task)
	return task
}

// NewAsyncTask creates and registers a new async task with the given name.
// An async task starts an async operation and waits for external completion via signal.
func (sr *BasePlanner) NewAsyncTask(ctx context.Context, name string) *AsyncTask {
	task := &AsyncTask{}
	task.taskName = name
	sr.registerTask(ctx, task)
	return task
}

// NewChildWorkflowTask creates and registers a new child task with the given name.
// A child task executes a child plan synchronously and waits for completion.
func (sr *BasePlanner) NewChildWorkflowTask(ctx context.Context, name string) *ChildWorkflowTask {
	task := &ChildWorkflowTask{}
	task.taskName = name
	sr.registerTask(ctx, task)
	return task
}

// registerTask adds a task to the planner's task registry.
// A panic is triggered if a task with the same name is already registered,
// ensuring task names remain unique within a plan.
func (sr *BasePlanner) registerTask(_ context.Context, task Task) {
	if _, ok := sr.TasksRegistry[task.Name()]; !ok {
		sr.TasksRegistry[task.Name()] = task
		return
	}
	panic(fmt.Sprintf("task with name <%s> is already registered for the plan <%s>", task.Name(), sr.Name))
}

// validate performs comprehensive validation of the planner and its task chain. The
// plan name is checked for whitespace, registration status is verified, and
// the entire task chain is validated for structural correctness and cycle detection.
func (sr *BasePlanner) validate(ctx context.Context) error {
	// The plan name must not contain whitespace characters.
	if strings.ContainsAny(sr.Name, " \t\n\r") {
		return errors.Newf("plan name <%s> cannot contain whitespace or new line", sr.Name)
	}
	// The plan must be registered before validation.
	if !sr.Registered {
		return errors.Newf("the plan <%s> is not registered", sr.Name)
	}
	// The plan must have a defined starting task.
	if sr.First == nil {
		return errors.Newf("planner <%s> has no first task", sr.Name)
	}

	// The visited map tracks which tasks have been validated and their end tasks.
	visited := make(map[string]*EndTask)
	// The currentPath map is used for cycle detection during traversal.
	currentPath := make(map[string]bool)
	_, err := sr.validateTaskChain(ctx, sr.First, visited, currentPath, false)
	return err
}

// validateTaskChain recursively validates a task and its entire downstream chain.
// It detects cycles by tracking the current execution path, allows valid convergence
// where multiple branches lead to the same task, and ensures all paths terminate at
// compatible EndTasks. The visited map caches validation results, while currentPath
// tracks the active traversal path for cycle detection.
func (sr *BasePlanner) validateTaskChain(
	ctx context.Context,
	task Task,
	visited map[string]*EndTask,
	currentPath map[string]bool,
	failedPath bool,
) (*EndTask, error) {
	// Nil tasks in the chain are invalid.
	if task == nil {
		return nil, errors.New("task chain has nil task")
	}
	// The task's internal validation is performed first.
	if err := task.validate(); err != nil {
		return nil, err
	}

	// Validate that ExecutorFn is registered in the ExecutorRegistry for tasks that use executors.
	if err := sr.validateExecutorRegistration(task); err != nil {
		return nil, err
	}

	// A task appearing in the current path indicates a cyclic dependency.
	if currentPath[task.Name()] {
		return nil, errors.Newf("cyclic dependency detected: task <%s> appears in its own execution path", task.Name())
	}

	// A task already visited but not in the current path represents valid convergence,
	// where multiple execution branches lead to the same task.
	if endTask, ok := visited[task.Name()]; ok {
		return endTask, nil
	}

	// The task is added to the current path for cycle detection.
	currentPath[task.Name()] = true
	// The task is removed from the current path when this function returns,
	// allowing the same task to appear in different branches (convergence).
	defer delete(currentPath, task.Name())

	switch task.Type() {
	case TaskTypeEndTask:
		// An EndTask represents a valid termination point for the task chain.
		endTask := task.(*EndTask)
		visited[task.Name()] = endTask
		return endTask, nil

	case TaskTypeExecution:
		// An ExecutionTask runs an executor and has Next and optional Fail paths.
		execTask := task.(*ExecutionTask)
		endTask, err := sr.validateStepTaskPaths(ctx, task.Name(), &execTask.stepTask, visited, currentPath, failedPath)
		if err != nil {
			return nil, err
		}
		visited[task.Name()] = endTask
		return endTask, nil

	case TaskTypeFork:
		// Fork tasks are not allowed in failure paths.
		if failedPath {
			return nil, errors.Newf("fork task <%s> is not allowed for the failure flow.", task.Name())
		}
		forkTask := task.(*ForkTask)

		// All parallel branches in a ForkTask must converge to the same EndTask.
		var commonEnd *EndTask
		for i, forkedTask := range forkTask.Tasks {
			if forkedTask == nil {
				return nil, errors.Newf("fork task <%s> has nil task at index %d", task.Name(), i)
			}
			forkedEnd, err := sr.validateTaskChain(ctx, forkedTask, visited, currentPath, failedPath)
			if err != nil {
				return nil, err
			}
			if commonEnd == nil {
				commonEnd = forkedEnd
			} else if commonEnd != forkedEnd {
				return nil, errors.Newf("fork task <%s> has forked tasks that converge to different EndTasks (<%s> vs <%s>)",
					task.Name(), commonEnd.Name(), forkedEnd.Name())
			}
		}

		// The ForkTask's Next and Fail paths are validated after the parallel branches.
		endTask, err := sr.validateStepTaskPaths(ctx, task.Name(), &forkTask.stepTask, visited, currentPath, failedPath)
		if err != nil {
			return nil, err
		}
		visited[task.Name()] = endTask
		return endTask, nil

	case TaskTypeIfTask:
		// An IfTask requires both Then and Else branches to be defined.
		ifTask := task.(*IfTask)
		// The Then branch is validated first.
		thenEnd, err := sr.validateTaskChain(ctx, ifTask.Then, visited, currentPath, failedPath)
		if err != nil {
			return nil, err
		}

		// The Else branch is validated next.
		elseEnd, err := sr.validateTaskChain(ctx, ifTask.Else, visited, currentPath, failedPath)
		if err != nil {
			return nil, err
		}

		// Both the Then and Else branches must converge to the same EndTask.
		if thenEnd != elseEnd {
			return nil, errors.Newf("if task <%s> has Then and Else branches that converge to different EndTasks (<%s> vs <%s>)",
				task.Name(), thenEnd.Name(), elseEnd.Name())
		}

		visited[task.Name()] = thenEnd
		return thenEnd, nil

	case TaskTypeSleepTask:
		// A SleepTask runs an executor that returns a duration and has Next and optional Fail paths.
		sleepTask := task.(*SleepTask)
		endTask, err := sr.validateStepTaskPaths(ctx, task.Name(), &sleepTask.stepTask, visited, currentPath, failedPath)
		if err != nil {
			return nil, err
		}
		visited[task.Name()] = endTask
		return endTask, nil

	case TaskTypeAsyncTask:
		// An AsyncTask runs an executor that starts an async operation and waits for external completion.
		asyncTask := task.(*AsyncTask)
		endTask, err := sr.validateStepTaskPaths(ctx, task.Name(), &asyncTask.stepTask, visited, currentPath, failedPath)
		if err != nil {
			return nil, err
		}
		visited[task.Name()] = endTask
		return endTask, nil

	case TaskTypeChildWorkflowTask:
		// A ChildWorkflowTask executes a child plan synchronously and has Next and optional Fail paths.
		childTask := task.(*ChildWorkflowTask)
		endTask, err := sr.validateStepTaskPaths(ctx, task.Name(), &childTask.stepTask, visited, currentPath, failedPath)
		if err != nil {
			return nil, err
		}
		visited[task.Name()] = endTask
		return endTask, nil

	default:
		return nil, errors.Newf("unknown task type <%s> for task <%s>", task.Type(), task.Name())
	}
}

// validateStepTaskPaths validates the Next and Fail paths for stepTask types.
// When in a failure path, only the Fail path is validated. Otherwise, the Next path
// is validated, and if a Fail path exists, it must converge to the same EndTask as
// the Next path to ensure a consistent execution flow.
func (sr *BasePlanner) validateStepTaskPaths(
	ctx context.Context,
	taskName string,
	st *stepTask,
	visited map[string]*EndTask,
	currentPath map[string]bool,
	failedPath bool,
) (nextEnd *EndTask, err error) {
	if failedPath {
		// In a failure path, the Fail task must be defined.
		if st.Fail == nil {
			return nil, errors.Newf("task <%s> has no Fail task and doesn't end with EndTask in the failure flow", taskName)
		}
		// The Fail path is validated recursively.
		nextEnd, err = sr.validateTaskChain(ctx, st.Fail, visited, currentPath, failedPath)
		if err != nil {
			return nil, err
		}
	} else {
		// In a normal path, the Next task must be defined.
		if st.Next == nil {
			return nil, errors.Newf("task <%s> has no Next task and doesn't end with EndTask", taskName)
		}

		// The Next path is validated recursively.
		nextEnd, err = sr.validateTaskChain(ctx, st.Next, visited, currentPath, failedPath)
		if err != nil {
			return nil, err
		}

		// If a Fail path exists, it must converge to the same EndTask as the Next path.
		if st.Fail != nil {
			failEnd, err := sr.validateTaskChain(ctx, st.Fail, visited, currentPath, true)
			if err != nil {
				return nil, err
			}
			if failEnd != nextEnd {
				return nil, errors.Newf("task <%s> has Next and Fail paths that converge to different EndTasks (<%s> vs <%s>)",
					taskName, nextEnd.Name(), failEnd.Name())
			}
		}
	}
	return nextEnd, nil
}

// validateExecutorRegistration checks that ExecutorFn used in tasks is registered in ExecutorRegistry.
// This validation ensures that all executors referenced by tasks have been properly registered with the planner.
func (sr *BasePlanner) validateExecutorRegistration(task Task) error {
	var executorFns []interface{}

	// Extract the ExecutorFn based on a task type.
	switch task.Type() {
	case TaskTypeExecution:
		executorFns = []interface{}{task.(*ExecutionTask).ExecutorFn}
	case TaskTypeIfTask:
		executorFns = []interface{}{task.(*IfTask).ExecutorFn}
	case TaskTypeSleepTask:
		executorFns = []interface{}{task.(*SleepTask).ExecutorFn}
	case TaskTypeAsyncTask:
		asyncTask := task.(*AsyncTask)
		executorFns = []interface{}{asyncTask.ExecutionFn, asyncTask.ResultProcessorFn}
	default:
		// Other task types don't use executors, so no validation needed.
		return nil
	}

	// Check if each executor function is registered in the ExecutorRegistry.
	for _, executorFn := range executorFns {
		// Use reflection to compare function pointers since functions are not directly comparable.
		var matchedExecutor *Executor
		for _, executor := range sr.ExecutorRegistry {
			if reflect.ValueOf(executor.Func).Pointer() == reflect.ValueOf(executorFn).Pointer() {
				matchedExecutor = executor
				break
			}
		}

		if matchedExecutor == nil {
			return errors.Newf("executor function for task <%s> is not registered in ExecutorRegistry", task.Name())
		}

		// Check if the executor is deprecated.
		if matchedExecutor.Deprecated {
			return errors.Newf("task <%s> uses deprecated executor <%s>", task.Name(), matchedExecutor.Name)
		}
	}

	return nil
}
