// Copyright 2021 The Cockroach Authors.
//
// Use of this software is governed by the Business Source License
// included in the file licenses/BSL.txt.
//
// As of the Change Date specified in that file, in accordance with
// the Business Source License, use of this software will be governed
// by the Apache License, Version 2.0, included in the file
// licenses/APL.txt.

package main

import (
	"errors"
	"fmt"
	"io/ioutil"
	"log"
	"os"
	"os/exec"
	"sort"
	"strings"

	"github.com/alessio/shellescape"
)

func main() {
	// First list all test and binary targets.
	infos, err := ioutil.ReadDir("pkg")
	if err != nil {
		panic(err)
	}
	var packagesToQuery []string
	for _, info := range infos {
		// We don't want to query into pkg/ui because it never contains any Go tests and
		// because doing so causes a pull from `npm`.
		if !info.IsDir() || info.Name() == "ui" {
			continue
		}
		packagesToQuery = append(packagesToQuery, fmt.Sprintf("//pkg/%s/...", info.Name()))
	}
	allPackages := strings.Join(packagesToQuery, "+")
	cmd := exec.Command(
		"bazel", "query",
		fmt.Sprintf(`kind("(go|sh)_(binary|test|transition_test|library)", %s)`, allPackages),
		"--output=label_kind",
	)
	buf, err := cmd.Output()
	if err != nil {
		log.Printf("Could not query Bazel tests: got error %v", err)
		var cmderr *exec.ExitError
		if errors.As(err, &cmderr) {
			log.Printf("Got error output: %s", string(cmderr.Stderr))
		} else {
			log.Printf("Run `%s` to reproduce the failure", shellescape.QuoteCommand(cmd.Args))
		}
		os.Exit(1)
	}
	var binaryLabels, libraryLabels, goTestLabels, goTransitionTestLabels, shTestLabels []string
	shTestLabels = []string{"//build/bazelutil/unused_checker:unused_test"}
	for _, line := range strings.Split(string(buf[:]), "\n") {
		fields := strings.Fields(line)
		if len(fields) != 3 {
			continue
		}
		kind := fields[0]
		label := fields[2]
		if kind == "go_library" && !strings.Contains(label, "TxnStateTransition") {
			libraryLabels = append(libraryLabels, label)
		} else if kind == "go_test" {
			goTestLabels = append(goTestLabels, label)
		} else if kind == "go_transition_test" {
			goTransitionTestLabels = append(goTransitionTestLabels, label)
		} else if kind == "sh_test" {
			shTestLabels = append(shTestLabels, label)
		} else if kind == "go_binary" && !strings.HasSuffix(label, "_gomock_prog_bin") && !strings.Contains(label, "TxnStateTransitions") {
			binaryLabels = append(binaryLabels, label)
		}
	}
	sort.Strings(binaryLabels)
	sort.Strings(libraryLabels)
	sort.Strings(goTestLabels)
	sort.Strings(goTransitionTestLabels)
	sort.Strings(shTestLabels)

	targetsBzl, err := os.Create("build/bazelutil/targets.bzl")
	if err != nil {
		panic(err)
	}
	defer func() { _ = targetsBzl.Close() }()
	fmt.Fprintln(targetsBzl, `# Code generated by generate-test-suites, DO NOT EDIT.

GO_TESTS = [`)
	for _, label := range goTestLabels {
		fmt.Fprintf(targetsBzl, "    %q,\n", label)
	}
	fmt.Fprintln(targetsBzl, `]

GO_TRANSITION_TESTS = [`)
	for _, label := range goTransitionTestLabels {
		fmt.Fprintf(targetsBzl, "    %q,\n", label)
	}
	fmt.Fprintln(targetsBzl, `]

SH_TESTS = [`)
	for _, label := range shTestLabels {
		fmt.Fprintf(targetsBzl, "    %q,\n", label)
	}
	fmt.Fprintln(targetsBzl, `]

ALL_TESTS = GO_TESTS + SH_TESTS

ALL_LIBRARIES = [`)
	for _, label := range libraryLabels {
		fmt.Fprintf(targetsBzl, "    %q,\n", label)
	}
	fmt.Fprintln(targetsBzl, `]

ALL_BINARIES = [`)
	for _, label := range binaryLabels {
		fmt.Fprintf(targetsBzl, "    %q,\n", label)
	}

	fmt.Fprintln(targetsBzl, `]

ALL_TARGETS = ALL_BINARIES + ALL_LIBRARIES + ALL_TESTS + GO_TRANSITION_TESTS`)

	buildFile, err := os.Create("pkg/BUILD.bazel")
	if err != nil {
		panic(err)
	}
	defer func() { _ = buildFile.Close() }()

	fmt.Fprintln(buildFile, `# Code generated by generate-test-suites, DO NOT EDIT.
load("//build/bazelutil:targets.bzl", "ALL_TESTS")
# gazelle:proto_strip_import_prefix /pkg

# These suites run only the tests with the appropriate "size" (excepting those
# tagged "broken_in_bazel", "flaky", or "integration") [1]. Note that tests have
# a default timeout depending on the size [2].

# [1] https://docs.bazel.build/versions/master/be/general.html#test_suite
# [2] https://docs.bazel.build/versions/master/be/common-definitions.html#common-attributes-tests`)

	fmt.Fprintln(buildFile, `
test_suite(
    name = "all_tests",
    tags = [
        "-broken_in_bazel",
        "-integration",
    ],
    tests = ALL_TESTS,
)`)

	for _, size := range []string{"small", "medium", "large", "enormous"} {
		fmt.Fprintf(buildFile, `
test_suite(
    name = "%[1]s_tests",
    tags = [
        "-broken_in_bazel",
        "-flaky",
        "-integration",
        "%[1]s",
    ],
    tests = ALL_TESTS,
)
`, size)
	}

	// Use buildozer to make sure all the tests are visible to the unused_checker.
	// NB: We expect buildozer to have been built by build/bazelutil/bazel-generate.sh.
	buildozer := "_bazel/bin/external/com_github_bazelbuild_buildtools/buildozer/buildozer_/buildozer"
	args := []string{"remove visibility //visibility:private //visibility:public"}
	args = append(args, binaryLabels...)
	args = append(args, goTestLabels...)
	args = append(args, goTransitionTestLabels...)
	cmd = exec.Command(buildozer, args...)
	output, err := cmd.CombinedOutput()
	if err != nil {
		var cmderr *exec.ExitError
		// NB: buildozer returns an exit status of 3 if the command was successful
		// but no files were changed.
		if !errors.As(err, &cmderr) || cmderr.ProcessState.ExitCode() != 3 {
			fmt.Printf("failed to run buildozer, got output: %s", string(output))
			panic(err)
		}
	}
	args = []string{"add visibility //build/bazelutil/unused_checker:__pkg__"}
	args = append(args, binaryLabels...)
	args = append(args, goTestLabels...)
	args = append(args, goTransitionTestLabels...)
	cmd = exec.Command(buildozer, args...)
	output, err = cmd.CombinedOutput()
	if err != nil {
		var cmderr *exec.ExitError
		if !errors.As(err, &cmderr) || cmderr.ProcessState.ExitCode() != 3 {
			fmt.Printf("failed to run buildozer, got output: %s", string(output))
			panic(err)
		}
	}
}
