// Copyright 2022 The Cockroach Authors.
//
// Use of this software is governed by the Business Source License
// included in the file licenses/BSL.txt.
//
// As of the Change Date specified in that file, in accordance with
// the Business Source License, use of this software will be governed
// by the Apache License, Version 2.0, included in the file
// licenses/APL.txt.

package main

import (
	"flag"
	"fmt"
	"io"
	"os"
	"path/filepath"
	"strings"
	"text/template"

	"github.com/cockroachdb/cockroach/pkg/build/bazel"
	"github.com/cockroachdb/cockroach/pkg/sql/logictest/logictestbase"
	"github.com/cockroachdb/cockroach/pkg/sql/sqlitelogictest"
)

const testFileTemplate = `{{ if .Ccl }}// Copyright 2012 The Cockroach Authors.
//
// Licensed as a CockroachDB Enterprise file under the Cockroach Community
// License (the "License"); you may not use this file except in compliance with
// the License. You may obtain a copy of the License at
//
//     https://github.com/cockroachdb/cockroach/blob/master/licenses/CCL.txt{{ else }}// Copyright 2022 The Cockroach Authors.
//
// Use of this software is governed by the Business Source License
// included in the file licenses/BSL.txt.
//
// As of the Change Date specified in that file, in accordance with
// the Business Source License, use of this software will be governed
// by the Apache License, Version 2.0, included in the file
// licenses/APL.txt.{{ end }}

// Code generated by generate-logictest, DO NOT EDIT.

package test{{ .Package }}

import (
	"os"
	"path/filepath"
	"testing"

	"github.com/cockroachdb/cockroach/pkg/build/bazel"{{ if .Ccl }}
	_ "github.com/cockroachdb/cockroach/pkg/ccl"
	"github.com/cockroachdb/cockroach/pkg/ccl/utilccl"{{ end }}
	"github.com/cockroachdb/cockroach/pkg/security/securityassets"
	"github.com/cockroachdb/cockroach/pkg/security/securitytest"
	"github.com/cockroachdb/cockroach/pkg/server"{{ if .ExecBuildLogicTest }}
	"github.com/cockroachdb/cockroach/pkg/sql"{{ end }}
	"github.com/cockroachdb/cockroach/pkg/sql/logictest"{{ if .SqliteLogicTest }}
	"github.com/cockroachdb/cockroach/pkg/sql/sqlitelogictest"{{ end }}
	"github.com/cockroachdb/cockroach/pkg/testutils/serverutils"
	"github.com/cockroachdb/cockroach/pkg/testutils/skip"
	"github.com/cockroachdb/cockroach/pkg/testutils/testcluster"
	"github.com/cockroachdb/cockroach/pkg/util/leaktest"
	"github.com/cockroachdb/cockroach/pkg/util/randutil"
)

const configIdx = {{ .ConfigIdx }}

{{ if .LogicTest }}var logicTestDir string
{{ end }}{{ if .CclLogicTest }}var cclLogicTestDir string
{{ end }}{{ if .ExecBuildLogicTest }}var execBuildLogicTestDir string
{{ end }}{{ if .SqliteLogicTest }}var sqliteLogicTestDir string
{{ end }}
func init() {
{{ if .LogicTest }}	if bazel.BuiltWithBazel() {
		var err error
		logicTestDir, err = bazel.Runfile("pkg/sql/logictest/testdata/logic_test")
		if err != nil {
			panic(err)
		}
	} else {
		logicTestDir = "{{ .RelDir }}/sql/logictest/testdata/logic_test"
	}
{{ end }}{{ if .CclLogicTest }}	if bazel.BuiltWithBazel() {
		var err error
		cclLogicTestDir, err = bazel.Runfile("pkg/ccl/logictestccl/testdata/logic_test")
		if err != nil {
			panic(err)
		}
	} else {
		cclLogicTestDir = "{{ .RelDir }}/ccl/logictestccl/testdata/logic_test"
	}
{{ end }}{{ if .ExecBuildLogicTest }}	if bazel.BuiltWithBazel() {
		var err error
		execBuildLogicTestDir, err = bazel.Runfile("pkg/sql/opt/exec/execbuilder/testdata")
		if err != nil {
			panic(err)
		}
	} else {
		execBuildLogicTestDir = "{{ .RelDir }}/sql/opt/exec/execbuilder/testdata"
	}
{{ end }}{{ if .SqliteLogicTest }}	if *logictest.Bigtest {
		if bazel.BuiltWithBazel() {
			var err error
			sqliteLogicTestDir, err = bazel.Runfile("external/com_github_cockroachdb_sqllogictest")
			if err != nil {
				panic(err)
			}
		} else {
			var err error
			sqliteLogicTestDir, err = sqlitelogictest.FindLocalLogicTestClone()
			if err != nil {
				panic(err)
			}
		}
	}
{{ end }}
}

func TestMain(m *testing.M) {
	{{ if .Ccl }}defer utilccl.TestingEnableEnterprise()()
	{{ end }}securityassets.SetLoader(securitytest.EmbeddedAssets)
	randutil.SeedForTests()
	serverutils.InitTestServerFactory(server.TestServerFactory)
	serverutils.InitTestClusterFactory(testcluster.TestClusterFactory)
	os.Exit(m.Run())
}

{{ if .LogicTest }}func runLogicTest(t *testing.T, file string) {
	skip.UnderDeadlock(t, "times out and/or hangs")
	logictest.RunLogicTest(t, logictest.TestServerArgs{}, configIdx, filepath.Join(logicTestDir, file))
}
{{ end }}{{ if .CclLogicTest }}func runCCLLogicTest(t *testing.T, file string) {
	skip.UnderDeadlock(t, "times out and/or hangs")
	logictest.RunLogicTest(t, logictest.TestServerArgs{}, configIdx, filepath.Join(cclLogicTestDir, file))
}
{{ end }}{{ if .ExecBuildLogicTest }}func runExecBuildLogicTest(t *testing.T, file string) {
	defer sql.TestingOverrideExplainEnvVersion("CockroachDB execbuilder test version")()
	skip.UnderDeadlock(t, "times out and/or hangs")
	serverArgs := logictest.TestServerArgs{
		DisableWorkmemRandomization: true,{{ if .ForceProductionValues }}
		ForceProductionValues:       true,{{end}}
	}
	logictest.RunLogicTest(t, serverArgs, configIdx, filepath.Join(execBuildLogicTestDir, file))
}
{{ end }}{{ if .SqliteLogicTest }}func runSqliteLogicTest(t *testing.T, file string) {
	skip.UnderDeadlock(t, "times out and/or hangs")
	if !*logictest.Bigtest {
		skip.IgnoreLint(t, "-bigtest flag must be specified to run this test")
	}
	// SQLLite logic tests can be very memory intensive, so we give them larger
	// limit than other logic tests get.
	serverArgs := logictest.TestServerArgs{
		MaxSQLMemoryLimit: 512 << 20, // 512 MiB
	}
	logictest.RunLogicTest(t, serverArgs, configIdx, filepath.Join(sqliteLogicTestDir, file))
}
{{ end }}`

// NB: The BUILD.bazel file we're going to construct with this template won't be
// complete or functional. After `generate-logictest` runs we're going to run
// `gazelle` which will fill in the rest of the gaps for us.
//
// There is probably room for optimization here. Among other things:
// some tests may declare a testdata dependency they don't actually need, and
// the sizes for some of these tests can probably be smaller than "enormous".
const buildFileTemplate = `load("@io_bazel_rules_go//go:def.bzl", "go_test")

go_test(
    name = "{{ .Package }}_test",
    size = "enormous",
    data = [
        {{ if .SqliteLogicTest }}"@com_github_cockroachdb_sqllogictest//:testfiles",  # keep
{{ end }}        "//c-deps:libgeos",  # keep
{{ if .CclLogicTest }}        "//pkg/ccl/logictestccl:testdata",  # keep
{{ end }}{{ if .LogicTest }}        "//pkg/sql/logictest:testdata",  # keep
{{ end }}{{ if .ExecBuildLogicTest }}        "//pkg/sql/opt/exec/execbuilder:testdata",  # keep
{{ end }}
    ],
    shard_count = {{ if gt .TestCount 16 }}16{{ else }}{{ .TestCount }}{{end}},
)
`

type testFileTemplateConfig struct {
	LogicTest, CclLogicTest, ExecBuildLogicTest, SqliteLogicTest bool
	Ccl, ForceProductionValues                                   bool
	Package, RelDir                                              string
	ConfigIdx                                                    int
	TestCount                                                    int
}

var outDir = flag.String("out-dir", "", "path to the root of the cockroach workspace")

func dumpTestForFile(f io.Writer, prefix, cfgName, file string, whichFunc string) {
	mungedConfig := logictestbase.RemoveSpecialCharacters(cfgName)
	mungedFile := logictestbase.RemoveSpecialCharacters(file)
	fmt.Fprintf(f, "\nfunc %s_%s_%s(\n", prefix, mungedConfig, mungedFile)
	fmt.Fprintln(f, "\tt *testing.T,\n) {")
	fmt.Fprintln(f, "\tdefer leaktest.AfterTest(t)()")
	fmt.Fprintf(f, "\t%s(t, \"%s\")\n", whichFunc, file)
	fmt.Fprintln(f, "}")
}

func prepDir(rel string) (string, error) {
	abs := filepath.Join(*outDir, rel)
	err := os.RemoveAll(abs)
	if err != nil {
		return "", err
	}
	err = os.MkdirAll(abs, 0777)
	if err != nil {
		return "", err
	}
	return abs, err
}

func openTestSubdir(dir string) (testFile, buildFile *os.File, cleanup func(), err error) {
	err = os.Mkdir(dir, 0777)
	if err != nil {
		return
	}
	testFile, err = os.Create(filepath.Join(dir, "generated_test.go"))
	if err != nil {
		return
	}
	buildFile, err = os.Create(filepath.Join(dir, "BUILD.bazel"))
	if err != nil {
		_ = testFile.Close()
		return
	}
	cleanup = func() {
		err := testFile.Close()
		if err != nil {
			panic(err)
		}
		err = buildFile.Close()
		if err != nil {
			panic(err)
		}
	}
	return
}

func generate() error {
	if *outDir == "" {
		cwd, err := os.Getwd()
		if err != nil {
			return err
		}
		*outDir = cwd
	}
	var cclLogicTestsGlob, execBuildLogicTestsGlob, logicTestsGlob, sqliteLogicTestsPath string
	if bazel.BuiltWithBazel() {
		runfiles, err := bazel.Runfile("pkg/ccl/logictestccl/testdata/logic_test")
		if err != nil {
			return err
		}
		cclLogicTestsGlob = filepath.Join(runfiles, "[^.]*")
		runfiles, err = bazel.Runfile("pkg/sql/opt/exec/execbuilder/testdata/")
		if err != nil {
			return err
		}
		execBuildLogicTestsGlob = filepath.Join(runfiles, "[^.]*")
		runfiles, err = bazel.Runfile("pkg/sql/logictest/testdata/logic_test")
		if err != nil {
			return err
		}
		logicTestsGlob = filepath.Join(runfiles, "[^.]*")
		sqliteLogicTestsPath, err = bazel.Runfile("external/com_github_cockroachdb_sqllogictest")
		if err != nil {
			return err
		}
	} else {
		cclLogicTestsGlob = "pkg/ccl/logictestccl/testdata/logic_test/[^.]*"
		logicTestsGlob = "pkg/sql/logictest/testdata/logic_test/[^.]*"
		execBuildLogicTestsGlob = "pkg/sql/opt/exec/execbuilder/testdata/[^.]*"
		var err error
		sqliteLogicTestsPath, err = sqlitelogictest.FindLocalLogicTestClone()
		if err != nil {
			return err
		}
	}
	// Prefix the globs with the sqliteLogicTestsPath.
	sqliteLogicTestsGlobs := make([]string, len(sqlitelogictest.Globs))
	for i, glob := range sqlitelogictest.Globs {
		sqliteLogicTestsGlobs[i] = sqliteLogicTestsPath + glob
	}

	testFileTpl := template.Must(template.New("source").Parse(testFileTemplate))
	buildFileTpl := template.Must(template.New("source").Parse(buildFileTemplate))

	// Populate tests in pkg/sql/logictest.
	{
		configPaths, err := logictestbase.ConfigCalculator{}.Enumerate(logicTestsGlob)
		if err != nil {
			return err
		}
		logicTestDir, err := prepDir("pkg/sql/logictest/tests")
		if err != nil {
			return err
		}
		for configIdx, paths := range configPaths {
			if len(paths) == 0 {
				continue
			}
			cfg := logictestbase.LogicTestConfigs[configIdx]
			cfgNameMunged := logictestbase.RemoveSpecialCharacters(cfg.Name)
			subdir := filepath.Join(logicTestDir, cfgNameMunged)
			f, buildF, cleanup, err := openTestSubdir(subdir)
			if err != nil {
				return err
			}
			defer cleanup()
			tplCfg := testFileTemplateConfig{
				ConfigIdx: configIdx,
				LogicTest: true,
				Package:   cfgNameMunged,
				RelDir:    "../../../..",
				TestCount: len(paths),
			}
			err = testFileTpl.Execute(f, tplCfg)
			if err != nil {
				return err
			}
			for _, file := range paths {
				dumpTestForFile(f, "TestLogic", cfg.Name, filepath.Base(file), "runLogicTest")
			}

			err = buildFileTpl.Execute(buildF, tplCfg)
			if err != nil {
				return err
			}
		}
	}

	// Populate tests in pkg/sql/sqlitelogictest.
	{
		configPaths, err := logictestbase.ConfigCalculator{RunCCLConfigs: true}.Enumerate(sqliteLogicTestsGlobs...)
		if err != nil {
			return err
		}
		sqliteLogicTestDir, err := prepDir("pkg/sql/sqlitelogictest/tests")
		if err != nil {
			return err
		}
		for configIdx, paths := range configPaths {
			if len(paths) == 0 {
				continue
			}
			cfg := logictestbase.LogicTestConfigs[configIdx]
			cfgNameMunged := logictestbase.RemoveSpecialCharacters(cfg.Name)
			subdir := filepath.Join(sqliteLogicTestDir, cfgNameMunged)
			f, buildF, cleanup, err := openTestSubdir(subdir)
			if err != nil {
				return err
			}
			defer cleanup()
			tplCfg := testFileTemplateConfig{
				ConfigIdx:       configIdx,
				SqliteLogicTest: true,
				Package:         cfgNameMunged,
				RelDir:          "../../../..",
				TestCount:       len(paths),
			}
			err = testFileTpl.Execute(f, tplCfg)
			if err != nil {
				return err
			}
			for _, file := range paths {
				dumpTestForFile(f, "TestSqlLiteLogic", cfg.Name, strings.TrimPrefix(file, sqliteLogicTestsPath), "runSqliteLogicTest")
			}
			err = buildFileTpl.Execute(buildF, tplCfg)
			if err != nil {
				return err
			}
		}
	}

	// Populate tests in pkg/ccl/logictestccl.
	{
		cclConfigPaths, err := logictestbase.ConfigCalculator{}.Enumerate(cclLogicTestsGlob)
		if err != nil {
			return err
		}
		tenantCalc := logictestbase.ConfigCalculator{
			ConfigOverrides:       []string{"3node-tenant"},
			ConfigFilterOverrides: []string{"3node-tenant-multiregion"},
			RunCCLConfigs:         true,
		}
		cclConfigPathsForTenant, err := tenantCalc.Enumerate(cclLogicTestsGlob)
		if err != nil {
			return err
		}
		cclLogicTestConfigPaths, err := tenantCalc.Enumerate(logicTestsGlob)
		if err != nil {
			return err
		}
		execBuildConfigPaths, err := tenantCalc.Enumerate(execBuildLogicTestsGlob)
		if err != nil {
			return err
		}
		cclLogicTestDir, err := prepDir("pkg/ccl/logictestccl/tests")
		if err != nil {
			return err
		}
		for configIdx := range logictestbase.LogicTestConfigs {
			testCount := len(cclConfigPaths[configIdx]) + len(cclConfigPathsForTenant[configIdx]) + len(cclLogicTestConfigPaths[configIdx]) + len(execBuildConfigPaths[configIdx])
			if testCount == 0 {
				continue
			}
			cfg := logictestbase.LogicTestConfigs[configIdx]
			cfgNameMunged := logictestbase.RemoveSpecialCharacters(cfg.Name)
			subdir := filepath.Join(cclLogicTestDir, cfgNameMunged)
			f, buildF, cleanup, err := openTestSubdir(subdir)
			if err != nil {
				return err
			}
			defer cleanup()
			tplCfg := testFileTemplateConfig{
				Ccl:                true,
				CclLogicTest:       len(cclConfigPaths[configIdx])+len(cclConfigPathsForTenant) > 0,
				ConfigIdx:          configIdx,
				ExecBuildLogicTest: len(execBuildConfigPaths[configIdx]) > 0,
				LogicTest:          len(cclLogicTestConfigPaths[configIdx]) > 0,
				Package:            cfgNameMunged,
				RelDir:             "../../../..",
				TestCount:          testCount,
			}
			err = testFileTpl.Execute(f, tplCfg)
			if err != nil {
				return err
			}
			for _, file := range cclConfigPaths[configIdx] {
				dumpTestForFile(f, "TestCCLLogic", cfg.Name, filepath.Base(file), "runCCLLogicTest")
			}
			for _, file := range cclConfigPathsForTenant[configIdx] {
				dumpTestForFile(f, "TestTenantLogicCCL", cfg.Name, filepath.Base(file), "runCCLLogicTest")
			}
			for _, file := range cclLogicTestConfigPaths[configIdx] {
				dumpTestForFile(f, "TestTenantLogic", cfg.Name, filepath.Base(file), "runLogicTest")
			}
			for _, file := range execBuildConfigPaths[configIdx] {
				dumpTestForFile(f, "TestTenantExecBuild", cfg.Name, filepath.Base(file), "runExecBuildLogicTest")
			}
			err = buildFileTpl.Execute(buildF, tplCfg)
			if err != nil {
				return err
			}
		}
	}

	// Populate tests in pkg/ccl/sqlitelogictestccl.
	{
		configPaths, err := logictestbase.ConfigCalculator{
			RunCCLConfigs:   true,
			ConfigOverrides: []string{"3node-tenant"},
		}.Enumerate(sqliteLogicTestsGlobs...)
		if err != nil {
			return err
		}
		sqliteLogicTestDir, err := prepDir("pkg/ccl/sqlitelogictestccl/tests")
		if err != nil {
			return err
		}
		for configIdx, paths := range configPaths {
			if len(paths) == 0 {
				continue
			}
			cfg := logictestbase.LogicTestConfigs[configIdx]
			cfgNameMunged := logictestbase.RemoveSpecialCharacters(cfg.Name)
			subdir := filepath.Join(sqliteLogicTestDir, cfgNameMunged)
			f, buildF, cleanup, err := openTestSubdir(subdir)
			if err != nil {
				return err
			}
			defer cleanup()
			tplCfg := testFileTemplateConfig{
				Ccl:             true,
				ConfigIdx:       configIdx,
				SqliteLogicTest: true,
				Package:         cfgNameMunged,
				RelDir:          "../../../..",
				TestCount:       len(paths),
			}
			err = testFileTpl.Execute(f, tplCfg)
			if err != nil {
				return err
			}
			for _, file := range paths {
				dumpTestForFile(f, "TestTenantSQLLiteLogic", cfg.Name, strings.TrimPrefix(file, sqliteLogicTestsPath), "runSqliteLogicTest")
			}
			err = buildFileTpl.Execute(buildF, tplCfg)
			if err != nil {
				return err
			}
		}
	}

	// Populate tests in pkg/sql/opt/exec/execbuilder.
	{
		configPaths, err := logictestbase.ConfigCalculator{}.Enumerate(execBuildLogicTestsGlob)
		if err != nil {
			return err
		}
		execBuildLogicTestDir, err := prepDir("pkg/sql/opt/exec/execbuilder/tests")
		if err != nil {
			return err
		}
		for configIdx, paths := range configPaths {
			if len(paths) == 0 {
				continue
			}
			cfg := logictestbase.LogicTestConfigs[configIdx]
			cfgNameMunged := logictestbase.RemoveSpecialCharacters(cfg.Name)
			subdir := filepath.Join(execBuildLogicTestDir, cfgNameMunged)
			f, buildF, cleanup, err := openTestSubdir(subdir)
			if err != nil {
				return err
			}
			defer cleanup()
			tplCfg := testFileTemplateConfig{
				ConfigIdx:             configIdx,
				ExecBuildLogicTest:    true,
				ForceProductionValues: true,
				Package:               cfgNameMunged,
				RelDir:                "../../../../../..",
				TestCount:             len(paths),
			}
			err = testFileTpl.Execute(f, tplCfg)
			if err != nil {
				return err
			}
			for _, file := range paths {
				dumpTestForFile(f, "TestExecBuild", cfg.Name, filepath.Base(file), "runExecBuildLogicTest")
			}

			err = buildFileTpl.Execute(buildF, tplCfg)
			if err != nil {
				return err
			}
		}
	}
	return nil
}

func main() {
	flag.Parse()
	if err := generate(); err != nil {
		panic(err)
	}
}
