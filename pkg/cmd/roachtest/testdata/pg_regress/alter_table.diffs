diff -U3 --label=/mnt/data1/postgres/src/test/regress/expected/alter_table.out --label=/mnt/data1/postgres/src/test/regress/results/alter_table.out /mnt/data1/postgres/src/test/regress/expected/alter_table.out /mnt/data1/postgres/src/test/regress/results/alter_table.out
--- /mnt/data1/postgres/src/test/regress/expected/alter_table.out
+++ /mnt/data1/postgres/src/test/regress/results/alter_table.out
@@ -15,7 +15,6 @@
 COMMENT ON TABLE attmp IS 'table comment';
 COMMENT ON TABLE attmp IS NULL;
 ALTER TABLE attmp ADD COLUMN xmin integer; -- fails
-ERROR:  column name "xmin" conflicts with a system column name
 ALTER TABLE attmp ADD COLUMN a int4 default 3;
 ALTER TABLE attmp ADD COLUMN b name;
 ALTER TABLE attmp ADD COLUMN c text;
@@ -23,17 +22,50 @@
 ALTER TABLE attmp ADD COLUMN e float4;
 ALTER TABLE attmp ADD COLUMN f int2;
 ALTER TABLE attmp ADD COLUMN g polygon;
+ERROR:  at or near "EOF": syntax error: unimplemented: this syntax
+DETAIL:  source SQL:
+ALTER TABLE attmp ADD COLUMN g polygon
+                                      ^
+HINT:  You have attempted to use a feature that is not yet implemented.
+See: https://go.crdb.dev/issue-v/21286/_version_
 ALTER TABLE attmp ADD COLUMN i char;
 ALTER TABLE attmp ADD COLUMN k int4;
 ALTER TABLE attmp ADD COLUMN l tid;
+ERROR:  type "tid" does not exist
 ALTER TABLE attmp ADD COLUMN m xid;
+ERROR:  type "xid" does not exist
 ALTER TABLE attmp ADD COLUMN n oidvector;
+ERROR:  VECTOR column types are unsupported
 --ALTER TABLE attmp ADD COLUMN o lock;
 ALTER TABLE attmp ADD COLUMN p boolean;
 ALTER TABLE attmp ADD COLUMN q point;
+ERROR:  at or near "EOF": syntax error: unimplemented: this syntax
+DETAIL:  source SQL:
+ALTER TABLE attmp ADD COLUMN q point
+                                    ^
+HINT:  You have attempted to use a feature that is not yet implemented.
+See: https://go.crdb.dev/issue-v/21286/_version_
 ALTER TABLE attmp ADD COLUMN r lseg;
+ERROR:  at or near "EOF": syntax error: unimplemented: this syntax
+DETAIL:  source SQL:
+ALTER TABLE attmp ADD COLUMN r lseg
+                                   ^
+HINT:  You have attempted to use a feature that is not yet implemented.
+See: https://go.crdb.dev/issue-v/21286/_version_
 ALTER TABLE attmp ADD COLUMN s path;
+ERROR:  at or near "EOF": syntax error: unimplemented: this syntax
+DETAIL:  source SQL:
+ALTER TABLE attmp ADD COLUMN s path
+                                   ^
+HINT:  You have attempted to use a feature that is not yet implemented.
+See: https://go.crdb.dev/issue-v/21286/_version_
 ALTER TABLE attmp ADD COLUMN t box;
+ERROR:  at or near "EOF": syntax error: unimplemented: this syntax
+DETAIL:  source SQL:
+ALTER TABLE attmp ADD COLUMN t box
+                                  ^
+HINT:  You have attempted to use a feature that is not yet implemented.
+See: https://go.crdb.dev/issue-v/21286/_version_
 ALTER TABLE attmp ADD COLUMN v timestamp;
 ALTER TABLE attmp ADD COLUMN w interval;
 ALTER TABLE attmp ADD COLUMN x float8[];
@@ -47,11 +79,11 @@
 	'1 2 3 4 5 6 7 8', true, '(1.1,1.1)', '(4.1,4.1,3.1,3.1)',
 	'(0,2,4.1,4.1,3.1,3.1)', '(4.1,4.1,3.1,3.1)',
 	'epoch', '01:00:10', '{1.0,2.0,3.0,4.0}', '{1.0,2.0,3.0,4.0}', '{1,2,3,4}');
+ERROR:  column "g" does not exist
 SELECT * FROM attmp;
- initial | a |  b   |  c   |  d  |  e  | f |           g           | i |   k    |   l   |  m  |        n        | p |     q     |           r           |              s              |          t          |            v             |        w         |     x     |     y     |     z     
----------+---+------+------+-----+-----+---+-----------------------+---+--------+-------+-----+-----------------+---+-----------+-----------------------+-----------------------------+---------------------+--------------------------+------------------+-----------+-----------+-----------
-         | 4 | name | text | 4.1 | 4.1 | 2 | ((4.1,4.1),(3.1,3.1)) | c | 314159 | (1,1) | 512 | 1 2 3 4 5 6 7 8 | t | (1.1,1.1) | [(4.1,4.1),(3.1,3.1)] | ((0,2),(4.1,4.1),(3.1,3.1)) | (4.1,4.1),(3.1,3.1) | Thu Jan 01 00:00:00 1970 | @ 1 hour 10 secs | {1,2,3,4} | {1,2,3,4} | {1,2,3,4}
-(1 row)
+ initial | xmin | a | b | c | d | e | f | i | k | p | v | w | x | y | z 
+---------+------+---+---+---+---+---+---+---+---+---+---+---+---+---+---
+(0 rows)
 
 DROP TABLE attmp;
 -- the wolf bug - schema mods caused inconsistent row descriptors
@@ -65,17 +97,50 @@
 ALTER TABLE attmp ADD COLUMN e float4;
 ALTER TABLE attmp ADD COLUMN f int2;
 ALTER TABLE attmp ADD COLUMN g polygon;
+ERROR:  at or near "EOF": syntax error: unimplemented: this syntax
+DETAIL:  source SQL:
+ALTER TABLE attmp ADD COLUMN g polygon
+                                      ^
+HINT:  You have attempted to use a feature that is not yet implemented.
+See: https://go.crdb.dev/issue-v/21286/_version_
 ALTER TABLE attmp ADD COLUMN i char;
 ALTER TABLE attmp ADD COLUMN k int4;
 ALTER TABLE attmp ADD COLUMN l tid;
+ERROR:  type "tid" does not exist
 ALTER TABLE attmp ADD COLUMN m xid;
+ERROR:  type "xid" does not exist
 ALTER TABLE attmp ADD COLUMN n oidvector;
+ERROR:  VECTOR column types are unsupported
 --ALTER TABLE attmp ADD COLUMN o lock;
 ALTER TABLE attmp ADD COLUMN p boolean;
 ALTER TABLE attmp ADD COLUMN q point;
+ERROR:  at or near "EOF": syntax error: unimplemented: this syntax
+DETAIL:  source SQL:
+ALTER TABLE attmp ADD COLUMN q point
+                                    ^
+HINT:  You have attempted to use a feature that is not yet implemented.
+See: https://go.crdb.dev/issue-v/21286/_version_
 ALTER TABLE attmp ADD COLUMN r lseg;
+ERROR:  at or near "EOF": syntax error: unimplemented: this syntax
+DETAIL:  source SQL:
+ALTER TABLE attmp ADD COLUMN r lseg
+                                   ^
+HINT:  You have attempted to use a feature that is not yet implemented.
+See: https://go.crdb.dev/issue-v/21286/_version_
 ALTER TABLE attmp ADD COLUMN s path;
+ERROR:  at or near "EOF": syntax error: unimplemented: this syntax
+DETAIL:  source SQL:
+ALTER TABLE attmp ADD COLUMN s path
+                                   ^
+HINT:  You have attempted to use a feature that is not yet implemented.
+See: https://go.crdb.dev/issue-v/21286/_version_
 ALTER TABLE attmp ADD COLUMN t box;
+ERROR:  at or near "EOF": syntax error: unimplemented: this syntax
+DETAIL:  source SQL:
+ALTER TABLE attmp ADD COLUMN t box
+                                  ^
+HINT:  You have attempted to use a feature that is not yet implemented.
+See: https://go.crdb.dev/issue-v/21286/_version_
 ALTER TABLE attmp ADD COLUMN v timestamp;
 ALTER TABLE attmp ADD COLUMN w interval;
 ALTER TABLE attmp ADD COLUMN x float8[];
@@ -89,36 +154,59 @@
 	'1 2 3 4 5 6 7 8', true, '(1.1,1.1)', '(4.1,4.1,3.1,3.1)',
 	'(0,2,4.1,4.1,3.1,3.1)', '(4.1,4.1,3.1,3.1)',
 	'epoch', '01:00:10', '{1.0,2.0,3.0,4.0}', '{1.0,2.0,3.0,4.0}', '{1,2,3,4}');
+ERROR:  column "g" does not exist
 SELECT * FROM attmp;
- initial | a |  b   |  c   |  d  |  e  | f |           g           | i |   k    |   l   |  m  |        n        | p |     q     |           r           |              s              |          t          |            v             |        w         |     x     |     y     |     z     
----------+---+------+------+-----+-----+---+-----------------------+---+--------+-------+-----+-----------------+---+-----------+-----------------------+-----------------------------+---------------------+--------------------------+------------------+-----------+-----------+-----------
-         | 4 | name | text | 4.1 | 4.1 | 2 | ((4.1,4.1),(3.1,3.1)) | c | 314159 | (1,1) | 512 | 1 2 3 4 5 6 7 8 | t | (1.1,1.1) | [(4.1,4.1),(3.1,3.1)] | ((0,2),(4.1,4.1),(3.1,3.1)) | (4.1,4.1),(3.1,3.1) | Thu Jan 01 00:00:00 1970 | @ 1 hour 10 secs | {1,2,3,4} | {1,2,3,4} | {1,2,3,4}
-(1 row)
+ initial | a | b | c | d | e | f | i | k | p | v | w | x | y | z 
+---------+---+---+---+---+---+---+---+---+---+---+---+---+---+---
+(0 rows)
 
 CREATE INDEX attmp_idx ON attmp (a, (d + e), b);
 ALTER INDEX attmp_idx ALTER COLUMN 0 SET STATISTICS 1000;
-ERROR:  column number must be in range from 1 to 32767
-LINE 1: ALTER INDEX attmp_idx ALTER COLUMN 0 SET STATISTICS 1000;
-                                           ^
+ERROR:  at or near "alter": syntax error
+DETAIL:  source SQL:
+ALTER INDEX attmp_idx ALTER COLUMN 0 SET STATISTICS 1000
+                      ^
+HINT:  try \h ALTER INDEX
 ALTER INDEX attmp_idx ALTER COLUMN 1 SET STATISTICS 1000;
-ERROR:  cannot alter statistics on non-expression column "a" of index "attmp_idx"
-HINT:  Alter statistics on table column instead.
+ERROR:  at or near "alter": syntax error
+DETAIL:  source SQL:
+ALTER INDEX attmp_idx ALTER COLUMN 1 SET STATISTICS 1000
+                      ^
+HINT:  try \h ALTER INDEX
 ALTER INDEX attmp_idx ALTER COLUMN 2 SET STATISTICS 1000;
+ERROR:  at or near "alter": syntax error
+DETAIL:  source SQL:
+ALTER INDEX attmp_idx ALTER COLUMN 2 SET STATISTICS 1000
+                      ^
+HINT:  try \h ALTER INDEX
 \d+ attmp_idx
-                        Index "public.attmp_idx"
- Column |       Type       | Key? | Definition | Storage | Stats target 
---------+------------------+------+------------+---------+--------------
- a      | integer          | yes  | a          | plain   | 
- expr   | double precision | yes  | (d + e)    | plain   | 1000
- b      | cstring          | yes  | b          | plain   | 
-btree, for table "public.attmp"
-
+ERROR:  at or near ".": syntax error
+DETAIL:  source SQL:
+SELECT c.oid,
+  n.nspname,
+  c.relname
+FROM pg_catalog.pg_class c
+     LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace
+WHERE c.relname OPERATOR(pg_catalog.~) '^(attmp_idx)$' COLLATE pg_catalog.default
+                                                                         ^
 ALTER INDEX attmp_idx ALTER COLUMN 3 SET STATISTICS 1000;
-ERROR:  cannot alter statistics on non-expression column "b" of index "attmp_idx"
-HINT:  Alter statistics on table column instead.
+ERROR:  at or near "alter": syntax error
+DETAIL:  source SQL:
+ALTER INDEX attmp_idx ALTER COLUMN 3 SET STATISTICS 1000
+                      ^
+HINT:  try \h ALTER INDEX
 ALTER INDEX attmp_idx ALTER COLUMN 4 SET STATISTICS 1000;
-ERROR:  column number 4 of relation "attmp_idx" does not exist
+ERROR:  at or near "alter": syntax error
+DETAIL:  source SQL:
+ALTER INDEX attmp_idx ALTER COLUMN 4 SET STATISTICS 1000
+                      ^
+HINT:  try \h ALTER INDEX
 ALTER INDEX attmp_idx ALTER COLUMN 2 SET STATISTICS -1;
+ERROR:  at or near "alter": syntax error
+DETAIL:  source SQL:
+ALTER INDEX attmp_idx ALTER COLUMN 2 SET STATISTICS -1
+                      ^
+HINT:  try \h ALTER INDEX
 DROP TABLE attmp;
 --
 -- rename - check on both non-temp and temp tables
@@ -139,8 +227,6 @@
 ALTER TABLE attmp RENAME TO attmp_new2;
 SELECT * FROM attmp;		-- should fail
 ERROR:  relation "attmp" does not exist
-LINE 1: SELECT * FROM attmp;
-                      ^
 SELECT * FROM attmp_new;
  attmptable 
 ------------
@@ -155,22 +241,37 @@
 DROP TABLE attmp_new2;
 -- check rename of partitioned tables and indexes also
 CREATE TABLE part_attmp (a int primary key) partition by range (a);
+ERROR:  at or near "EOF": syntax error
+DETAIL:  source SQL:
+CREATE TABLE part_attmp (a int primary key) partition by range (a)
+                                                                  ^
+HINT:  try \h CREATE TABLE
 CREATE TABLE part_attmp1 PARTITION OF part_attmp FOR VALUES FROM (0) TO (100);
+ERROR:  at or near "partition": syntax error
+DETAIL:  source SQL:
+CREATE TABLE part_attmp1 PARTITION OF part_attmp FOR VALUES FROM (0) TO (100)
+                         ^
+HINT:  try \h CREATE TABLE
 ALTER INDEX part_attmp_pkey RENAME TO part_attmp_index;
+ERROR:  index "part_attmp_pkey" does not exist
 ALTER INDEX part_attmp1_pkey RENAME TO part_attmp1_index;
+ERROR:  index "part_attmp1_pkey" does not exist
 ALTER TABLE part_attmp RENAME TO part_at2tmp;
+ERROR:  relation "part_attmp" does not exist
 ALTER TABLE part_attmp1 RENAME TO part_at2tmp1;
+ERROR:  relation "part_attmp1" does not exist
 SET ROLE regress_alter_table_user1;
 ALTER INDEX part_attmp_index RENAME TO fail;
-ERROR:  must be owner of index part_attmp_index
+ERROR:  index "part_attmp_index" does not exist
 ALTER INDEX part_attmp1_index RENAME TO fail;
-ERROR:  must be owner of index part_attmp1_index
+ERROR:  index "part_attmp1_index" does not exist
 ALTER TABLE part_at2tmp RENAME TO fail;
-ERROR:  must be owner of table part_at2tmp
+ERROR:  relation "part_at2tmp" does not exist
 ALTER TABLE part_at2tmp1 RENAME TO fail;
-ERROR:  must be owner of table part_at2tmp1
+ERROR:  relation "part_at2tmp1" does not exist
 RESET ROLE;
 DROP TABLE part_at2tmp;
+ERROR:  relation "part_at2tmp" does not exist
 --
 -- check renaming to a table's array type's autogenerated name
 -- (the array type's name should get out of the way)
@@ -178,28 +279,28 @@
 CREATE TABLE attmp_array (id int);
 CREATE TABLE attmp_array2 (id int);
 SELECT typname FROM pg_type WHERE oid = 'attmp_array[]'::regtype;
-   typname    
---------------
- _attmp_array
+ typname 
+---------
+ _record
 (1 row)
 
 SELECT typname FROM pg_type WHERE oid = 'attmp_array2[]'::regtype;
-    typname    
----------------
- _attmp_array2
+ typname 
+---------
+ _record
 (1 row)
 
 ALTER TABLE attmp_array2 RENAME TO _attmp_array;
 SELECT typname FROM pg_type WHERE oid = 'attmp_array[]'::regtype;
-    typname    
----------------
- __attmp_array
+ typname 
+---------
+ _record
 (1 row)
 
 SELECT typname FROM pg_type WHERE oid = '_attmp_array[]'::regtype;
-     typname     
------------------
- __attmp_array_1
+ typname 
+---------
+ _record
 (1 row)
 
 DROP TABLE _attmp_array;
@@ -207,110 +308,153 @@
 -- renaming to table's own array type's name is an interesting corner case
 CREATE TABLE attmp_array (id int);
 SELECT typname FROM pg_type WHERE oid = 'attmp_array[]'::regtype;
-   typname    
---------------
- _attmp_array
+ typname 
+---------
+ _record
 (1 row)
 
 ALTER TABLE attmp_array RENAME TO _attmp_array;
 SELECT typname FROM pg_type WHERE oid = '_attmp_array[]'::regtype;
-    typname    
----------------
- __attmp_array
+ typname 
+---------
+ _record
 (1 row)
 
 DROP TABLE _attmp_array;
 -- ALTER TABLE ... RENAME on non-table relations
 -- renaming indexes (FIXME: this should probably test the index's functionality)
 ALTER INDEX IF EXISTS __onek_unique1 RENAME TO attmp_onek_unique1;
-NOTICE:  relation "__onek_unique1" does not exist, skipping
 ALTER INDEX IF EXISTS __attmp_onek_unique1 RENAME TO onek_unique1;
-NOTICE:  relation "__attmp_onek_unique1" does not exist, skipping
 ALTER INDEX onek_unique1 RENAME TO attmp_onek_unique1;
+ERROR:  index "onek_unique1" does not exist
 ALTER INDEX attmp_onek_unique1 RENAME TO onek_unique1;
+ERROR:  index "attmp_onek_unique1" does not exist
 SET ROLE regress_alter_table_user1;
 ALTER INDEX onek_unique1 RENAME TO fail;  -- permission denied
-ERROR:  must be owner of index onek_unique1
+ERROR:  index "onek_unique1" does not exist
 RESET ROLE;
 -- rename statements with mismatching statement and object types
 CREATE TABLE alter_idx_rename_test (a INT);
 CREATE INDEX alter_idx_rename_test_idx ON alter_idx_rename_test (a);
 CREATE TABLE alter_idx_rename_test_parted (a INT) PARTITION BY LIST (a);
+ERROR:  at or near "EOF": syntax error
+DETAIL:  source SQL:
+CREATE TABLE alter_idx_rename_test_parted (a INT) PARTITION BY LIST (a)
+                                                                       ^
+HINT:  try \h CREATE TABLE
 CREATE INDEX alter_idx_rename_test_parted_idx ON alter_idx_rename_test_parted (a);
+ERROR:  relation "alter_idx_rename_test_parted" does not exist
 BEGIN;
 ALTER INDEX alter_idx_rename_test RENAME TO alter_idx_rename_test_2;
+NOTICE:  auto-committing transaction before processing DDL due to autocommit_before_ddl setting
+ERROR:  index "alter_idx_rename_test" does not exist
 ALTER INDEX alter_idx_rename_test_parted RENAME TO alter_idx_rename_test_parted_2;
+ERROR:  index "alter_idx_rename_test_parted" does not exist
 SELECT relation::regclass, mode FROM pg_locks
 WHERE pid = pg_backend_pid() AND locktype = 'relation'
   AND relation::regclass::text LIKE 'alter\_idx%'
 ORDER BY relation::regclass::text COLLATE "C";
-            relation            |        mode         
---------------------------------+---------------------
- alter_idx_rename_test_2        | AccessExclusiveLock
- alter_idx_rename_test_parted_2 | AccessExclusiveLock
-(2 rows)
+ relation | mode 
+----------+------
+(0 rows)
 
 COMMIT;
+WARNING:  there is no transaction in progress
 BEGIN;
 ALTER INDEX alter_idx_rename_test_idx RENAME TO alter_idx_rename_test_idx_2;
+NOTICE:  auto-committing transaction before processing DDL due to autocommit_before_ddl setting
 ALTER INDEX alter_idx_rename_test_parted_idx RENAME TO alter_idx_rename_test_parted_idx_2;
+ERROR:  index "alter_idx_rename_test_parted_idx" does not exist
 SELECT relation::regclass, mode FROM pg_locks
 WHERE pid = pg_backend_pid() AND locktype = 'relation'
   AND relation::regclass::text LIKE 'alter\_idx%'
 ORDER BY relation::regclass::text COLLATE "C";
-              relation              |           mode           
-------------------------------------+--------------------------
- alter_idx_rename_test_idx_2        | ShareUpdateExclusiveLock
- alter_idx_rename_test_parted_idx_2 | ShareUpdateExclusiveLock
-(2 rows)
+ relation | mode 
+----------+------
+(0 rows)
 
 COMMIT;
+WARNING:  there is no transaction in progress
 BEGIN;
 ALTER TABLE alter_idx_rename_test_idx_2 RENAME TO alter_idx_rename_test_idx_3;
+NOTICE:  auto-committing transaction before processing DDL due to autocommit_before_ddl setting
+ERROR:  relation "alter_idx_rename_test_idx_2" does not exist
 ALTER TABLE alter_idx_rename_test_parted_idx_2 RENAME TO alter_idx_rename_test_parted_idx_3;
+ERROR:  relation "alter_idx_rename_test_parted_idx_2" does not exist
 SELECT relation::regclass, mode FROM pg_locks
 WHERE pid = pg_backend_pid() AND locktype = 'relation'
   AND relation::regclass::text LIKE 'alter\_idx%'
 ORDER BY relation::regclass::text COLLATE "C";
-              relation              |        mode         
-------------------------------------+---------------------
- alter_idx_rename_test_idx_3        | AccessExclusiveLock
- alter_idx_rename_test_parted_idx_3 | AccessExclusiveLock
-(2 rows)
+ relation | mode 
+----------+------
+(0 rows)
 
 COMMIT;
+WARNING:  there is no transaction in progress
 DROP TABLE alter_idx_rename_test_2;
+ERROR:  relation "alter_idx_rename_test_2" does not exist
 -- renaming views
 CREATE VIEW attmp_view (unique1) AS SELECT unique1 FROM tenk1;
 ALTER TABLE attmp_view RENAME TO attmp_view_new;
 SET ROLE regress_alter_table_user1;
 ALTER VIEW attmp_view_new RENAME TO fail;  -- permission denied
-ERROR:  must be owner of view attmp_view_new
+ERROR:  user regress_alter_table_user1 does not have DROP privilege on relation attmp_view_new
 RESET ROLE;
 -- hack to ensure we get an indexscan here
 set enable_seqscan to off;
+WARNING:  setting session var "enable_seqscan" is a no-op
 set enable_bitmapscan to off;
+ERROR:  unimplemented: the configuration setting "enable_bitmapscan" is not supported
+HINT:  You have attempted to use a feature that is not yet implemented.
+
+Please check the public issue tracker to check whether this problem is
+already tracked. If you cannot find it there, please report the error
+with details by creating a new issue.
+
+If you would rather not post publicly, please contact us directly
+using the support form.
+
+We appreciate your feedback.
+
 -- 5 values, sorted
 SELECT unique1 FROM tenk1 WHERE unique1 < 5;
  unique1 
 ---------
-       0
-       1
+       4
        2
+       1
        3
-       4
+       0
 (5 rows)
 
 reset enable_seqscan;
+WARNING:  setting session var "enable_seqscan" is a no-op
 reset enable_bitmapscan;
+ERROR:  unimplemented: the configuration setting "enable_bitmapscan" is not supported
+HINT:  You have attempted to use a feature that is not yet implemented.
+
+Please check the public issue tracker to check whether this problem is
+already tracked. If you cannot find it there, please report the error
+with details by creating a new issue.
+
+If you would rather not post publicly, please contact us directly
+using the support form.
+
+We appreciate your feedback.
+
 DROP VIEW attmp_view_new;
 -- toast-like relation name
 alter table stud_emp rename to pg_toast_stud_emp;
+ERROR:  relation "stud_emp" does not exist
 alter table pg_toast_stud_emp rename to stud_emp;
+ERROR:  relation "pg_toast_stud_emp" does not exist
 -- renaming index should rename constraint as well
 ALTER TABLE onek ADD CONSTRAINT onek_unique1_constraint UNIQUE (unique1);
 ALTER INDEX onek_unique1_constraint RENAME TO onek_unique1_constraint_foo;
 ALTER TABLE onek DROP CONSTRAINT onek_unique1_constraint_foo;
+ERROR:  unimplemented: cannot drop UNIQUE constraint "onek_unique1_constraint_foo" using ALTER TABLE DROP CONSTRAINT, use DROP INDEX CASCADE instead
+HINT:  You have attempted to use a feature that is not yet implemented.
+See: https://go.crdb.dev/issue-v/42840/_version_
 -- renaming constraint
 ALTER TABLE onek ADD CONSTRAINT onek_check_constraint CHECK (unique1 >= 0);
 ALTER TABLE onek RENAME CONSTRAINT onek_check_constraint TO onek_check_constraint_foo;
@@ -318,129 +462,127 @@
 -- renaming constraint should rename index as well
 ALTER TABLE onek ADD CONSTRAINT onek_unique1_constraint UNIQUE (unique1);
 DROP INDEX onek_unique1_constraint;  -- to see whether it's there
-ERROR:  cannot drop index onek_unique1_constraint because constraint onek_unique1_constraint on table onek requires it
-HINT:  You can drop constraint onek_unique1_constraint on table onek instead.
+NOTICE:  the data for dropped indexes is reclaimed asynchronously
+HINT:  The reclamation delay can be customized in the zone configuration for the table.
 ALTER TABLE onek RENAME CONSTRAINT onek_unique1_constraint TO onek_unique1_constraint_foo;
+ERROR:  constraint "onek_unique1_constraint" of relation "onek" does not exist
 DROP INDEX onek_unique1_constraint_foo;  -- to see whether it's there
-ERROR:  cannot drop index onek_unique1_constraint_foo because constraint onek_unique1_constraint_foo on table onek requires it
-HINT:  You can drop constraint onek_unique1_constraint_foo on table onek instead.
+NOTICE:  the data for dropped indexes is reclaimed asynchronously
+HINT:  The reclamation delay can be customized in the zone configuration for the table.
 ALTER TABLE onek DROP CONSTRAINT onek_unique1_constraint_foo;
+ERROR:  constraint "onek_unique1_constraint_foo" of relation "onek" does not exist
 -- renaming constraints vs. inheritance
 CREATE TABLE constraint_rename_test (a int CONSTRAINT con1 CHECK (a > 0), b int, c int);
 \d constraint_rename_test
-       Table "public.constraint_rename_test"
- Column |  Type   | Collation | Nullable | Default 
---------+---------+-----------+----------+---------
- a      | integer |           |          | 
- b      | integer |           |          | 
- c      | integer |           |          | 
-Check constraints:
-    "con1" CHECK (a > 0)
-
+ERROR:  at or near ".": syntax error
+DETAIL:  source SQL:
+SELECT c.oid,
+  n.nspname,
+  c.relname
+FROM pg_catalog.pg_class c
+     LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace
+WHERE c.relname OPERATOR(pg_catalog.~) '^(constraint_rename_test)$' COLLATE pg_catalog.default
+                                                                                      ^
 CREATE TABLE constraint_rename_test2 (a int CONSTRAINT con1 CHECK (a > 0), d int) INHERITS (constraint_rename_test);
-NOTICE:  merging column "a" with inherited definition
-NOTICE:  merging constraint "con1" with inherited definition
+ERROR:  at or near "(": syntax error: unimplemented: this syntax
+DETAIL:  source SQL:
+CREATE TABLE constraint_rename_test2 (a int CONSTRAINT con1 CHECK (a > 0), d int) INHERITS (constraint_rename_test)
+                                                                                           ^
+HINT:  You have attempted to use a feature that is not yet implemented.
+See: https://go.crdb.dev/issue-v/22456/_version_
 \d constraint_rename_test2
-      Table "public.constraint_rename_test2"
- Column |  Type   | Collation | Nullable | Default 
---------+---------+-----------+----------+---------
- a      | integer |           |          | 
- b      | integer |           |          | 
- c      | integer |           |          | 
- d      | integer |           |          | 
-Check constraints:
-    "con1" CHECK (a > 0)
-Inherits: constraint_rename_test
-
+ERROR:  at or near ".": syntax error
+DETAIL:  source SQL:
+SELECT c.oid,
+  n.nspname,
+  c.relname
+FROM pg_catalog.pg_class c
+     LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace
+WHERE c.relname OPERATOR(pg_catalog.~) '^(constraint_rename_test2)$' COLLATE pg_catalog.default
+                                                                                       ^
 ALTER TABLE constraint_rename_test2 RENAME CONSTRAINT con1 TO con1foo; -- fail
-ERROR:  cannot rename inherited constraint "con1"
+ERROR:  relation "constraint_rename_test2" does not exist
 ALTER TABLE ONLY constraint_rename_test RENAME CONSTRAINT con1 TO con1foo; -- fail
-ERROR:  inherited constraint "con1" must be renamed in child tables too
 ALTER TABLE constraint_rename_test RENAME CONSTRAINT con1 TO con1foo; -- ok
+ERROR:  constraint "con1" of relation "constraint_rename_test" does not exist
 \d constraint_rename_test
-       Table "public.constraint_rename_test"
- Column |  Type   | Collation | Nullable | Default 
---------+---------+-----------+----------+---------
- a      | integer |           |          | 
- b      | integer |           |          | 
- c      | integer |           |          | 
-Check constraints:
-    "con1foo" CHECK (a > 0)
-Number of child tables: 1 (Use \d+ to list them.)
-
+ERROR:  at or near ".": syntax error
+DETAIL:  source SQL:
+SELECT c.oid,
+  n.nspname,
+  c.relname
+FROM pg_catalog.pg_class c
+     LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace
+WHERE c.relname OPERATOR(pg_catalog.~) '^(constraint_rename_test)$' COLLATE pg_catalog.default
+                                                                                      ^
 \d constraint_rename_test2
-      Table "public.constraint_rename_test2"
- Column |  Type   | Collation | Nullable | Default 
---------+---------+-----------+----------+---------
- a      | integer |           |          | 
- b      | integer |           |          | 
- c      | integer |           |          | 
- d      | integer |           |          | 
-Check constraints:
-    "con1foo" CHECK (a > 0)
-Inherits: constraint_rename_test
-
+ERROR:  at or near ".": syntax error
+DETAIL:  source SQL:
+SELECT c.oid,
+  n.nspname,
+  c.relname
+FROM pg_catalog.pg_class c
+     LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace
+WHERE c.relname OPERATOR(pg_catalog.~) '^(constraint_rename_test2)$' COLLATE pg_catalog.default
+                                                                                       ^
 ALTER TABLE constraint_rename_test ADD CONSTRAINT con2 CHECK (b > 0) NO INHERIT;
+ERROR:  at or near "no": syntax error
+DETAIL:  source SQL:
+ALTER TABLE constraint_rename_test ADD CONSTRAINT con2 CHECK (b > 0) NO INHERIT
+                                                                     ^
 ALTER TABLE ONLY constraint_rename_test RENAME CONSTRAINT con2 TO con2foo; -- ok
+ERROR:  constraint "con2" of relation "constraint_rename_test" does not exist
 ALTER TABLE constraint_rename_test RENAME CONSTRAINT con2foo TO con2bar; -- ok
+ERROR:  constraint "con2foo" of relation "constraint_rename_test" does not exist
 \d constraint_rename_test
-       Table "public.constraint_rename_test"
- Column |  Type   | Collation | Nullable | Default 
---------+---------+-----------+----------+---------
- a      | integer |           |          | 
- b      | integer |           |          | 
- c      | integer |           |          | 
-Check constraints:
-    "con1foo" CHECK (a > 0)
-    "con2bar" CHECK (b > 0) NO INHERIT
-Number of child tables: 1 (Use \d+ to list them.)
-
+ERROR:  at or near ".": syntax error
+DETAIL:  source SQL:
+SELECT c.oid,
+  n.nspname,
+  c.relname
+FROM pg_catalog.pg_class c
+     LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace
+WHERE c.relname OPERATOR(pg_catalog.~) '^(constraint_rename_test)$' COLLATE pg_catalog.default
+                                                                                      ^
 \d constraint_rename_test2
-      Table "public.constraint_rename_test2"
- Column |  Type   | Collation | Nullable | Default 
---------+---------+-----------+----------+---------
- a      | integer |           |          | 
- b      | integer |           |          | 
- c      | integer |           |          | 
- d      | integer |           |          | 
-Check constraints:
-    "con1foo" CHECK (a > 0)
-Inherits: constraint_rename_test
-
+ERROR:  at or near ".": syntax error
+DETAIL:  source SQL:
+SELECT c.oid,
+  n.nspname,
+  c.relname
+FROM pg_catalog.pg_class c
+     LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace
+WHERE c.relname OPERATOR(pg_catalog.~) '^(constraint_rename_test2)$' COLLATE pg_catalog.default
+                                                                                       ^
 ALTER TABLE constraint_rename_test ADD CONSTRAINT con3 PRIMARY KEY (a);
+ERROR:  cannot use nullable column "a" in primary key
 ALTER TABLE constraint_rename_test RENAME CONSTRAINT con3 TO con3foo; -- ok
+ERROR:  constraint "con3" of relation "constraint_rename_test" does not exist
 \d constraint_rename_test
-       Table "public.constraint_rename_test"
- Column |  Type   | Collation | Nullable | Default 
---------+---------+-----------+----------+---------
- a      | integer |           | not null | 
- b      | integer |           |          | 
- c      | integer |           |          | 
-Indexes:
-    "con3foo" PRIMARY KEY, btree (a)
-Check constraints:
-    "con1foo" CHECK (a > 0)
-    "con2bar" CHECK (b > 0) NO INHERIT
-Number of child tables: 1 (Use \d+ to list them.)
-
+ERROR:  at or near ".": syntax error
+DETAIL:  source SQL:
+SELECT c.oid,
+  n.nspname,
+  c.relname
+FROM pg_catalog.pg_class c
+     LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace
+WHERE c.relname OPERATOR(pg_catalog.~) '^(constraint_rename_test)$' COLLATE pg_catalog.default
+                                                                                      ^
 \d constraint_rename_test2
-      Table "public.constraint_rename_test2"
- Column |  Type   | Collation | Nullable | Default 
---------+---------+-----------+----------+---------
- a      | integer |           | not null | 
- b      | integer |           |          | 
- c      | integer |           |          | 
- d      | integer |           |          | 
-Check constraints:
-    "con1foo" CHECK (a > 0)
-Inherits: constraint_rename_test
-
+ERROR:  at or near ".": syntax error
+DETAIL:  source SQL:
+SELECT c.oid,
+  n.nspname,
+  c.relname
+FROM pg_catalog.pg_class c
+     LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace
+WHERE c.relname OPERATOR(pg_catalog.~) '^(constraint_rename_test2)$' COLLATE pg_catalog.default
+                                                                                       ^
 DROP TABLE constraint_rename_test2;
+ERROR:  relation "constraint_rename_test2" does not exist
 DROP TABLE constraint_rename_test;
 ALTER TABLE IF EXISTS constraint_not_exist RENAME CONSTRAINT con3 TO con3foo; -- ok
-NOTICE:  relation "constraint_not_exist" does not exist, skipping
 ALTER TABLE IF EXISTS constraint_rename_test ADD CONSTRAINT con4 UNIQUE (a);
-NOTICE:  relation "constraint_rename_test" does not exist, skipping
 -- renaming constraints with cache reset of target relation
 CREATE TABLE constraint_rename_cache (a int,
   CONSTRAINT chk_a CHECK (a > 0),
@@ -452,15 +594,15 @@
 CREATE TABLE like_constraint_rename_cache
   (LIKE constraint_rename_cache INCLUDING ALL);
 \d like_constraint_rename_cache
-    Table "public.like_constraint_rename_cache"
- Column |  Type   | Collation | Nullable | Default 
---------+---------+-----------+----------+---------
- a      | integer |           | not null | 
-Indexes:
-    "like_constraint_rename_cache_pkey" PRIMARY KEY, btree (a)
-Check constraints:
-    "chk_a_new" CHECK (a > 0)
-
+ERROR:  at or near ".": syntax error
+DETAIL:  source SQL:
+SELECT c.oid,
+  n.nspname,
+  c.relname
+FROM pg_catalog.pg_class c
+     LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace
+WHERE c.relname OPERATOR(pg_catalog.~) '^(like_constraint_rename_cache)$' COLLATE pg_catalog.default
+                                                                                            ^
 DROP TABLE constraint_rename_cache;
 DROP TABLE like_constraint_rename_cache;
 -- FOREIGN KEY CONSTRAINT adding TEST
@@ -479,14 +621,12 @@
 INSERT INTO attmp3 values (5,50);
 -- Try (and fail) to add constraint due to invalid source columns
 ALTER TABLE attmp3 add constraint attmpconstr foreign key(c) references attmp2 match full;
-ERROR:  column "c" referenced in foreign key constraint does not exist
+ERROR:  column "c" does not exist
 -- Try (and fail) to add constraint due to invalid destination columns explicitly given
 ALTER TABLE attmp3 add constraint attmpconstr foreign key(a) references attmp2(b) match full;
-ERROR:  column "b" referenced in foreign key constraint does not exist
+ERROR:  column "b" does not exist
 -- Try (and fail) to add constraint due to invalid data
-ALTER TABLE attmp3 add constraint attmpconstr foreign key (a) references attmp2 match full;
-ERROR:  insert or update on table "attmp3" violates foreign key constraint "attmpconstr"
-DETAIL:  Key (a)=(5) is not present in table "attmp2".
+-- ALTER TABLE attmp3 add constraint attmpconstr foreign key (a) references attmp2 match full;
 -- Delete failing row
 DELETE FROM attmp3 where a=5;
 -- Try (and succeed)
@@ -495,20 +635,16 @@
 INSERT INTO attmp3 values (5,50);
 -- Try NOT VALID and then VALIDATE CONSTRAINT, but fails. Delete failure then re-validate
 ALTER TABLE attmp3 add constraint attmpconstr foreign key (a) references attmp2 match full NOT VALID;
-ALTER TABLE attmp3 validate constraint attmpconstr;
-ERROR:  insert or update on table "attmp3" violates foreign key constraint "attmpconstr"
-DETAIL:  Key (a)=(5) is not present in table "attmp2".
+-- ALTER TABLE attmp3 validate constraint attmpconstr;
 -- Delete failing row
 DELETE FROM attmp3 where a=5;
 -- Try (and succeed) and repeat to show it works on already valid constraint
 ALTER TABLE attmp3 validate constraint attmpconstr;
 ALTER TABLE attmp3 validate constraint attmpconstr;
 -- Try a non-verified CHECK constraint
-ALTER TABLE attmp3 ADD CONSTRAINT b_greater_than_ten CHECK (b > 10); -- fail
-ERROR:  check constraint "b_greater_than_ten" of relation "attmp3" is violated by some row
+-- ALTER TABLE attmp3 ADD CONSTRAINT b_greater_than_ten CHECK (b > 10); -- fail
 ALTER TABLE attmp3 ADD CONSTRAINT b_greater_than_ten CHECK (b > 10) NOT VALID; -- succeeds
-ALTER TABLE attmp3 VALIDATE CONSTRAINT b_greater_than_ten; -- fails
-ERROR:  check constraint "b_greater_than_ten" of relation "attmp3" is violated by some row
+-- ALTER TABLE attmp3 VALIDATE CONSTRAINT b_greater_than_ten; -- fails
 DELETE FROM attmp3 WHERE NOT b > 10;
 ALTER TABLE attmp3 VALIDATE CONSTRAINT b_greater_than_ten; -- succeeds
 ALTER TABLE attmp3 VALIDATE CONSTRAINT b_greater_than_ten; -- succeeds
@@ -520,49 +656,77 @@
 (1 row)
 
 CREATE TABLE attmp6 () INHERITS (attmp3);
+ERROR:  at or near "(": syntax error: unimplemented: this syntax
+DETAIL:  source SQL:
+CREATE TABLE attmp6 () INHERITS (attmp3)
+                                ^
+HINT:  You have attempted to use a feature that is not yet implemented.
+See: https://go.crdb.dev/issue-v/22456/_version_
 CREATE TABLE attmp7 () INHERITS (attmp3);
+ERROR:  at or near "(": syntax error: unimplemented: this syntax
+DETAIL:  source SQL:
+CREATE TABLE attmp7 () INHERITS (attmp3)
+                                ^
+HINT:  You have attempted to use a feature that is not yet implemented.
+See: https://go.crdb.dev/issue-v/22456/_version_
 INSERT INTO attmp6 VALUES (6, 30), (7, 16);
+ERROR:  relation "attmp6" does not exist
 ALTER TABLE attmp3 ADD CONSTRAINT b_le_20 CHECK (b <= 20) NOT VALID;
 ALTER TABLE attmp3 VALIDATE CONSTRAINT b_le_20;	-- fails
-ERROR:  check constraint "b_le_20" of relation "attmp6" is violated by some row
 DELETE FROM attmp6 WHERE b > 20;
+ERROR:  relation "attmp6" does not exist
 ALTER TABLE attmp3 VALIDATE CONSTRAINT b_le_20;	-- succeeds
 -- An already validated constraint must not be revalidated
 CREATE FUNCTION boo(int) RETURNS int IMMUTABLE STRICT LANGUAGE plpgsql AS $$ BEGIN RAISE NOTICE 'boo: %', $1; RETURN $1; END; $$;
+ERROR:  no value provided for placeholder: $1
 INSERT INTO attmp7 VALUES (8, 18);
+ERROR:  relation "attmp7" does not exist
 ALTER TABLE attmp7 ADD CONSTRAINT identity CHECK (b = boo(b));
-NOTICE:  boo: 18
+ERROR:  relation "attmp7" does not exist
 ALTER TABLE attmp3 ADD CONSTRAINT IDENTITY check (b = boo(b)) NOT VALID;
-NOTICE:  merging constraint "identity" with inherited definition
+ERROR:  unknown function: boo()
 ALTER TABLE attmp3 VALIDATE CONSTRAINT identity;
-NOTICE:  boo: 20
-NOTICE:  boo: 16
+ERROR:  constraint "identity" of relation "attmp3" does not exist
 -- A NO INHERIT constraint should not be looked for in children during VALIDATE CONSTRAINT
 create table parent_noinh_convalid (a int);
 create table child_noinh_convalid () inherits (parent_noinh_convalid);
+ERROR:  at or near "(": syntax error: unimplemented: this syntax
+DETAIL:  source SQL:
+create table child_noinh_convalid () inherits (parent_noinh_convalid)
+                                              ^
+HINT:  You have attempted to use a feature that is not yet implemented.
+See: https://go.crdb.dev/issue-v/22456/_version_
 insert into parent_noinh_convalid values (1);
 insert into child_noinh_convalid values (1);
+ERROR:  relation "child_noinh_convalid" does not exist
 alter table parent_noinh_convalid add constraint check_a_is_2 check (a = 2) no inherit not valid;
+ERROR:  at or near "no": syntax error
+DETAIL:  source SQL:
+alter table parent_noinh_convalid add constraint check_a_is_2 check (a = 2) no inherit not valid
+                                                                            ^
 -- fail, because of the row in parent
 alter table parent_noinh_convalid validate constraint check_a_is_2;
-ERROR:  check constraint "check_a_is_2" of relation "parent_noinh_convalid" is violated by some row
+ERROR:  constraint "check_a_is_2" of relation "parent_noinh_convalid" does not exist
 delete from only parent_noinh_convalid;
 -- ok (parent itself contains no violating rows)
 alter table parent_noinh_convalid validate constraint check_a_is_2;
+ERROR:  constraint "check_a_is_2" of relation "parent_noinh_convalid" does not exist
 select convalidated from pg_constraint where conrelid = 'parent_noinh_convalid'::regclass and conname = 'check_a_is_2';
  convalidated 
 --------------
- t
-(1 row)
+(0 rows)
 
 -- cleanup
 drop table parent_noinh_convalid, child_noinh_convalid;
+ERROR:  relation "child_noinh_convalid" does not exist
 -- Try (and fail) to create constraint from attmp5(a) to attmp4(a) - unique constraint on
 -- attmp4 is a,b
 ALTER TABLE attmp5 add constraint attmpconstr foreign key(a) references attmp4(a) match full;
-ERROR:  there is no unique constraint matching given keys for referenced table "attmp4"
+ERROR:  there is no unique constraint matching given keys for referenced table attmp4
 DROP TABLE attmp7;
+ERROR:  relation "attmp7" does not exist
 DROP TABLE attmp6;
+ERROR:  relation "attmp6" does not exist
 DROP TABLE attmp5;
 DROP TABLE attmp4;
 DROP TABLE attmp3;
@@ -570,85 +734,100 @@
 -- NOT VALID with plan invalidation -- ensure we don't use a constraint for
 -- exclusion until validated
 set constraint_exclusion TO 'partition';
+ERROR:  unimplemented: the configuration setting "constraint_exclusion" is not supported
+HINT:  You have attempted to use a feature that is not yet implemented.
+
+Please check the public issue tracker to check whether this problem is
+already tracked. If you cannot find it there, please report the error
+with details by creating a new issue.
+
+If you would rather not post publicly, please contact us directly
+using the support form.
+
+We appreciate your feedback.
+
 create table nv_parent (d date, check (false) no inherit not valid);
+ERROR:  at or near "no": syntax error
+DETAIL:  source SQL:
+create table nv_parent (d date, check (false) no inherit not valid)
+                                              ^
+HINT:  try \h CREATE TABLE
 -- not valid constraint added at creation time should automatically become valid
 \d nv_parent
-            Table "public.nv_parent"
- Column | Type | Collation | Nullable | Default 
---------+------+-----------+----------+---------
- d      | date |           |          | 
-Check constraints:
-    "nv_parent_check" CHECK (false) NO INHERIT
-
+ERROR:  at or near ".": syntax error
+DETAIL:  source SQL:
+SELECT c.oid,
+  n.nspname,
+  c.relname
+FROM pg_catalog.pg_class c
+     LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace
+WHERE c.relname OPERATOR(pg_catalog.~) '^(nv_parent)$' COLLATE pg_catalog.default
+                                                                         ^
 create table nv_child_2010 () inherits (nv_parent);
+ERROR:  at or near "(": syntax error: unimplemented: this syntax
+DETAIL:  source SQL:
+create table nv_child_2010 () inherits (nv_parent)
+                                       ^
+HINT:  You have attempted to use a feature that is not yet implemented.
+See: https://go.crdb.dev/issue-v/22456/_version_
 create table nv_child_2011 () inherits (nv_parent);
+ERROR:  at or near "(": syntax error: unimplemented: this syntax
+DETAIL:  source SQL:
+create table nv_child_2011 () inherits (nv_parent)
+                                       ^
+HINT:  You have attempted to use a feature that is not yet implemented.
+See: https://go.crdb.dev/issue-v/22456/_version_
 alter table nv_child_2010 add check (d between '2010-01-01'::date and '2010-12-31'::date) not valid;
+ERROR:  relation "nv_child_2010" does not exist
 alter table nv_child_2011 add check (d between '2011-01-01'::date and '2011-12-31'::date) not valid;
+ERROR:  relation "nv_child_2011" does not exist
 explain (costs off) select * from nv_parent where d between '2011-08-01' and '2011-08-31';
-                                QUERY PLAN                                 
----------------------------------------------------------------------------
- Append
-   ->  Seq Scan on nv_parent nv_parent_1
-         Filter: ((d >= '08-01-2011'::date) AND (d <= '08-31-2011'::date))
-   ->  Seq Scan on nv_child_2010 nv_parent_2
-         Filter: ((d >= '08-01-2011'::date) AND (d <= '08-31-2011'::date))
-   ->  Seq Scan on nv_child_2011 nv_parent_3
-         Filter: ((d >= '08-01-2011'::date) AND (d <= '08-31-2011'::date))
-(7 rows)
-
+ERROR:  at or near "off": syntax error
+DETAIL:  source SQL:
+explain (costs off) select * from nv_parent where d between '2011-08-01' and '2011-08-31'
+               ^
+HINT:  try \h <SELECTCLAUSE>
 create table nv_child_2009 (check (d between '2009-01-01'::date and '2009-12-31'::date)) inherits (nv_parent);
+ERROR:  at or near "(": syntax error: unimplemented: this syntax
+DETAIL:  source SQL:
+create table nv_child_2009 (check (d between '2009-01-01'::date and '2009-12-31'::date)) inherits (nv_parent)
+                                                                                                  ^
+HINT:  You have attempted to use a feature that is not yet implemented.
+See: https://go.crdb.dev/issue-v/22456/_version_
 explain (costs off) select * from nv_parent where d between '2011-08-01'::date and '2011-08-31'::date;
-                                QUERY PLAN                                 
----------------------------------------------------------------------------
- Append
-   ->  Seq Scan on nv_parent nv_parent_1
-         Filter: ((d >= '08-01-2011'::date) AND (d <= '08-31-2011'::date))
-   ->  Seq Scan on nv_child_2010 nv_parent_2
-         Filter: ((d >= '08-01-2011'::date) AND (d <= '08-31-2011'::date))
-   ->  Seq Scan on nv_child_2011 nv_parent_3
-         Filter: ((d >= '08-01-2011'::date) AND (d <= '08-31-2011'::date))
-(7 rows)
-
+ERROR:  at or near "off": syntax error
+DETAIL:  source SQL:
+explain (costs off) select * from nv_parent where d between '2011-08-01'::date and '2011-08-31'::date
+               ^
+HINT:  try \h <SELECTCLAUSE>
 explain (costs off) select * from nv_parent where d between '2009-08-01'::date and '2009-08-31'::date;
-                                QUERY PLAN                                 
----------------------------------------------------------------------------
- Append
-   ->  Seq Scan on nv_parent nv_parent_1
-         Filter: ((d >= '08-01-2009'::date) AND (d <= '08-31-2009'::date))
-   ->  Seq Scan on nv_child_2010 nv_parent_2
-         Filter: ((d >= '08-01-2009'::date) AND (d <= '08-31-2009'::date))
-   ->  Seq Scan on nv_child_2011 nv_parent_3
-         Filter: ((d >= '08-01-2009'::date) AND (d <= '08-31-2009'::date))
-   ->  Seq Scan on nv_child_2009 nv_parent_4
-         Filter: ((d >= '08-01-2009'::date) AND (d <= '08-31-2009'::date))
-(9 rows)
-
+ERROR:  at or near "off": syntax error
+DETAIL:  source SQL:
+explain (costs off) select * from nv_parent where d between '2009-08-01'::date and '2009-08-31'::date
+               ^
+HINT:  try \h <SELECTCLAUSE>
 -- after validation, the constraint should be used
 alter table nv_child_2011 VALIDATE CONSTRAINT nv_child_2011_d_check;
+ERROR:  relation "nv_child_2011" does not exist
 explain (costs off) select * from nv_parent where d between '2009-08-01'::date and '2009-08-31'::date;
-                                QUERY PLAN                                 
----------------------------------------------------------------------------
- Append
-   ->  Seq Scan on nv_parent nv_parent_1
-         Filter: ((d >= '08-01-2009'::date) AND (d <= '08-31-2009'::date))
-   ->  Seq Scan on nv_child_2010 nv_parent_2
-         Filter: ((d >= '08-01-2009'::date) AND (d <= '08-31-2009'::date))
-   ->  Seq Scan on nv_child_2009 nv_parent_3
-         Filter: ((d >= '08-01-2009'::date) AND (d <= '08-31-2009'::date))
-(7 rows)
-
+ERROR:  at or near "off": syntax error
+DETAIL:  source SQL:
+explain (costs off) select * from nv_parent where d between '2009-08-01'::date and '2009-08-31'::date
+               ^
+HINT:  try \h <SELECTCLAUSE>
 -- add an inherited NOT VALID constraint
 alter table nv_parent add check (d between '2001-01-01'::date and '2099-12-31'::date) not valid;
+ERROR:  relation "nv_parent" does not exist
 \d nv_child_2009
-          Table "public.nv_child_2009"
- Column | Type | Collation | Nullable | Default 
---------+------+-----------+----------+---------
- d      | date |           |          | 
-Check constraints:
-    "nv_child_2009_d_check" CHECK (d >= '01-01-2009'::date AND d <= '12-31-2009'::date)
-    "nv_parent_d_check" CHECK (d >= '01-01-2001'::date AND d <= '12-31-2099'::date) NOT VALID
-Inherits: nv_parent
-
+ERROR:  at or near ".": syntax error
+DETAIL:  source SQL:
+SELECT c.oid,
+  n.nspname,
+  c.relname
+FROM pg_catalog.pg_class c
+     LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace
+WHERE c.relname OPERATOR(pg_catalog.~) '^(nv_child_2009)$' COLLATE pg_catalog.default
+                                                                             ^
 -- we leave nv_parent and children around to help test pg_dump logic
 -- Foreign key adding test with mixed types
 -- Note: these tables are TEMP to avoid name conflicts when this test
@@ -658,13 +837,11 @@
 CREATE TEMP TABLE FKTABLE (ftest1 inet);
 -- This next should fail, because int=inet does not exist
 ALTER TABLE FKTABLE ADD FOREIGN KEY(ftest1) references pktable;
-ERROR:  foreign key constraint "fktable_ftest1_fkey" cannot be implemented
-DETAIL:  Key columns "ftest1" and "ptest1" are of incompatible types: inet and integer.
+ERROR:  type of "ftest1" (inet) does not match foreign key "pktable"."ptest1" (int)
 -- This should also fail for the same reason, but here we
 -- give the column name
 ALTER TABLE FKTABLE ADD FOREIGN KEY(ftest1) references pktable(ptest1);
-ERROR:  foreign key constraint "fktable_ftest1_fkey" cannot be implemented
-DETAIL:  Key columns "ftest1" and "ptest1" are of incompatible types: inet and integer.
+ERROR:  type of "ftest1" (inet) does not match foreign key "pktable"."ptest1" (int)
 DROP TABLE FKTABLE;
 -- This should succeed, even though they are different types,
 -- because int=int8 exists and is a member of the integer opfamily
@@ -673,7 +850,7 @@
 -- Check it actually works
 INSERT INTO FKTABLE VALUES(42);		-- should succeed
 INSERT INTO FKTABLE VALUES(43);		-- should fail
-ERROR:  insert or update on table "fktable" violates foreign key constraint "fktable_ftest1_fkey"
+ERROR:  insert on table "fktable" violates foreign key constraint "fktable_ftest1_fkey"
 DETAIL:  Key (ftest1)=(43) is not present in table "pktable".
 DROP TABLE FKTABLE;
 -- This should fail, because we'd have to cast numeric to int which is
@@ -681,8 +858,7 @@
 -- of the integer opfamily)
 CREATE TEMP TABLE FKTABLE (ftest1 numeric);
 ALTER TABLE FKTABLE ADD FOREIGN KEY(ftest1) references pktable;
-ERROR:  foreign key constraint "fktable_ftest1_fkey" cannot be implemented
-DETAIL:  Key columns "ftest1" and "ptest1" are of incompatible types: numeric and integer.
+ERROR:  type of "ftest1" (decimal) does not match foreign key "pktable"."ptest1" (int)
 DROP TABLE FKTABLE;
 DROP TABLE PKTABLE;
 -- On the other hand, this should work because int implicitly promotes to
@@ -691,39 +867,48 @@
 INSERT INTO PKTABLE VALUES(42);
 CREATE TEMP TABLE FKTABLE (ftest1 int);
 ALTER TABLE FKTABLE ADD FOREIGN KEY(ftest1) references pktable;
+ERROR:  type of "ftest1" (int) does not match foreign key "pktable"."ptest1" (decimal)
 -- Check it actually works
 INSERT INTO FKTABLE VALUES(42);		-- should succeed
 INSERT INTO FKTABLE VALUES(43);		-- should fail
-ERROR:  insert or update on table "fktable" violates foreign key constraint "fktable_ftest1_fkey"
-DETAIL:  Key (ftest1)=(43) is not present in table "pktable".
 DROP TABLE FKTABLE;
 DROP TABLE PKTABLE;
 CREATE TEMP TABLE PKTABLE (ptest1 int, ptest2 inet,
                            PRIMARY KEY(ptest1, ptest2));
 -- This should fail, because we just chose really odd types
 CREATE TEMP TABLE FKTABLE (ftest1 cidr, ftest2 timestamp);
+ERROR:  at or near ",": syntax error: unimplemented: this syntax
+DETAIL:  source SQL:
+CREATE TEMP TABLE FKTABLE (ftest1 cidr, ftest2 timestamp)
+                                      ^
+HINT:  You have attempted to use a feature that is not yet implemented.
+See: https://go.crdb.dev/issue-v/18846/_version_
 ALTER TABLE FKTABLE ADD FOREIGN KEY(ftest1, ftest2) references pktable;
-ERROR:  foreign key constraint "fktable_ftest1_ftest2_fkey" cannot be implemented
-DETAIL:  Key columns "ftest1" and "ptest1" are of incompatible types: cidr and integer.
+ERROR:  relation "fktable" does not exist
 DROP TABLE FKTABLE;
+ERROR:  relation "fktable" does not exist
 -- Again, so should this...
 CREATE TEMP TABLE FKTABLE (ftest1 cidr, ftest2 timestamp);
+ERROR:  at or near ",": syntax error: unimplemented: this syntax
+DETAIL:  source SQL:
+CREATE TEMP TABLE FKTABLE (ftest1 cidr, ftest2 timestamp)
+                                      ^
+HINT:  You have attempted to use a feature that is not yet implemented.
+See: https://go.crdb.dev/issue-v/18846/_version_
 ALTER TABLE FKTABLE ADD FOREIGN KEY(ftest1, ftest2)
      references pktable(ptest1, ptest2);
-ERROR:  foreign key constraint "fktable_ftest1_ftest2_fkey" cannot be implemented
-DETAIL:  Key columns "ftest1" and "ptest1" are of incompatible types: cidr and integer.
+ERROR:  relation "fktable" does not exist
 DROP TABLE FKTABLE;
+ERROR:  relation "fktable" does not exist
 -- This fails because we mixed up the column ordering
 CREATE TEMP TABLE FKTABLE (ftest1 int, ftest2 inet);
 ALTER TABLE FKTABLE ADD FOREIGN KEY(ftest1, ftest2)
      references pktable(ptest2, ptest1);
-ERROR:  foreign key constraint "fktable_ftest1_ftest2_fkey" cannot be implemented
-DETAIL:  Key columns "ftest1" and "ptest2" are of incompatible types: integer and inet.
+ERROR:  type of "ftest1" (int) does not match foreign key "pktable"."ptest2" (inet)
 -- As does this...
 ALTER TABLE FKTABLE ADD FOREIGN KEY(ftest2, ftest1)
      references pktable(ptest1, ptest2);
-ERROR:  foreign key constraint "fktable_ftest2_ftest1_fkey" cannot be implemented
-DETAIL:  Key columns "ftest2" and "ptest1" are of incompatible types: inet and integer.
+ERROR:  type of "ftest2" (inet) does not match foreign key "pktable"."ptest1" (int)
 DROP TABLE FKTABLE;
 DROP TABLE PKTABLE;
 -- Test that ALTER CONSTRAINT updates trigger deferrability properly
@@ -731,58 +916,91 @@
 CREATE TEMP TABLE FKTABLE (ftest1 int);
 ALTER TABLE FKTABLE ADD CONSTRAINT fknd FOREIGN KEY(ftest1) REFERENCES pktable
   ON DELETE CASCADE ON UPDATE NO ACTION NOT DEFERRABLE;
+ERROR:  at or near "deferrable": syntax error
+DETAIL:  source SQL:
+ALTER TABLE FKTABLE ADD CONSTRAINT fknd FOREIGN KEY(ftest1) REFERENCES pktable
+  ON DELETE CASCADE ON UPDATE NO ACTION NOT DEFERRABLE
+                                            ^
+HINT:  try \h ALTER TABLE
 ALTER TABLE FKTABLE ADD CONSTRAINT fkdd FOREIGN KEY(ftest1) REFERENCES pktable
   ON DELETE CASCADE ON UPDATE NO ACTION DEFERRABLE INITIALLY DEFERRED;
+ERROR:  at or near "deferred": syntax error: unimplemented: this syntax
+DETAIL:  source SQL:
+ALTER TABLE FKTABLE ADD CONSTRAINT fkdd FOREIGN KEY(ftest1) REFERENCES pktable
+  ON DELETE CASCADE ON UPDATE NO ACTION DEFERRABLE INITIALLY DEFERRED
+                                                             ^
+HINT:  You have attempted to use a feature that is not yet implemented.
+See: https://go.crdb.dev/issue-v/31632/_version_
 ALTER TABLE FKTABLE ADD CONSTRAINT fkdi FOREIGN KEY(ftest1) REFERENCES pktable
   ON DELETE CASCADE ON UPDATE NO ACTION DEFERRABLE INITIALLY IMMEDIATE;
+ERROR:  at or near "immediate": syntax error: unimplemented: this syntax
+DETAIL:  source SQL:
+ALTER TABLE FKTABLE ADD CONSTRAINT fkdi FOREIGN KEY(ftest1) REFERENCES pktable
+  ON DELETE CASCADE ON UPDATE NO ACTION DEFERRABLE INITIALLY IMMEDIATE
+                                                             ^
+HINT:  You have attempted to use a feature that is not yet implemented.
+See: https://go.crdb.dev/issue-v/31632/_version_
 ALTER TABLE FKTABLE ADD CONSTRAINT fknd2 FOREIGN KEY(ftest1) REFERENCES pktable
   ON DELETE CASCADE ON UPDATE NO ACTION DEFERRABLE INITIALLY DEFERRED;
+ERROR:  at or near "deferred": syntax error: unimplemented: this syntax
+DETAIL:  source SQL:
+ALTER TABLE FKTABLE ADD CONSTRAINT fknd2 FOREIGN KEY(ftest1) REFERENCES pktable
+  ON DELETE CASCADE ON UPDATE NO ACTION DEFERRABLE INITIALLY DEFERRED
+                                                             ^
+HINT:  You have attempted to use a feature that is not yet implemented.
+See: https://go.crdb.dev/issue-v/31632/_version_
 ALTER TABLE FKTABLE ALTER CONSTRAINT fknd2 NOT DEFERRABLE;
+ERROR:  at or near "not": syntax error: unimplemented: this syntax
+DETAIL:  source SQL:
+ALTER TABLE FKTABLE ALTER CONSTRAINT fknd2 NOT DEFERRABLE
+                                           ^
+HINT:  You have attempted to use a feature that is not yet implemented.
+See: https://go.crdb.dev/issue-v/31632/_version_
 ALTER TABLE FKTABLE ADD CONSTRAINT fkdd2 FOREIGN KEY(ftest1) REFERENCES pktable
   ON DELETE CASCADE ON UPDATE NO ACTION NOT DEFERRABLE;
+ERROR:  at or near "deferrable": syntax error
+DETAIL:  source SQL:
+ALTER TABLE FKTABLE ADD CONSTRAINT fkdd2 FOREIGN KEY(ftest1) REFERENCES pktable
+  ON DELETE CASCADE ON UPDATE NO ACTION NOT DEFERRABLE
+                                            ^
+HINT:  try \h ALTER TABLE
 ALTER TABLE FKTABLE ALTER CONSTRAINT fkdd2 DEFERRABLE INITIALLY DEFERRED;
+ERROR:  at or near "deferrable": syntax error: unimplemented: this syntax
+DETAIL:  source SQL:
+ALTER TABLE FKTABLE ALTER CONSTRAINT fkdd2 DEFERRABLE INITIALLY DEFERRED
+                                           ^
+HINT:  You have attempted to use a feature that is not yet implemented.
+See: https://go.crdb.dev/issue-v/31632/_version_
 ALTER TABLE FKTABLE ADD CONSTRAINT fkdi2 FOREIGN KEY(ftest1) REFERENCES pktable
   ON DELETE CASCADE ON UPDATE NO ACTION NOT DEFERRABLE;
+ERROR:  at or near "deferrable": syntax error
+DETAIL:  source SQL:
+ALTER TABLE FKTABLE ADD CONSTRAINT fkdi2 FOREIGN KEY(ftest1) REFERENCES pktable
+  ON DELETE CASCADE ON UPDATE NO ACTION NOT DEFERRABLE
+                                            ^
+HINT:  try \h ALTER TABLE
 ALTER TABLE FKTABLE ALTER CONSTRAINT fkdi2 DEFERRABLE INITIALLY IMMEDIATE;
+ERROR:  at or near "deferrable": syntax error: unimplemented: this syntax
+DETAIL:  source SQL:
+ALTER TABLE FKTABLE ALTER CONSTRAINT fkdi2 DEFERRABLE INITIALLY IMMEDIATE
+                                           ^
+HINT:  You have attempted to use a feature that is not yet implemented.
+See: https://go.crdb.dev/issue-v/31632/_version_
 SELECT conname, tgfoid::regproc, tgtype, tgdeferrable, tginitdeferred
 FROM pg_trigger JOIN pg_constraint con ON con.oid = tgconstraint
 WHERE tgrelid = 'pktable'::regclass
 ORDER BY 1,2,3;
- conname |         tgfoid         | tgtype | tgdeferrable | tginitdeferred 
----------+------------------------+--------+--------------+----------------
- fkdd    | "RI_FKey_cascade_del"  |      9 | f            | f
- fkdd    | "RI_FKey_noaction_upd" |     17 | t            | t
- fkdd2   | "RI_FKey_cascade_del"  |      9 | f            | f
- fkdd2   | "RI_FKey_noaction_upd" |     17 | t            | t
- fkdi    | "RI_FKey_cascade_del"  |      9 | f            | f
- fkdi    | "RI_FKey_noaction_upd" |     17 | t            | f
- fkdi2   | "RI_FKey_cascade_del"  |      9 | f            | f
- fkdi2   | "RI_FKey_noaction_upd" |     17 | t            | f
- fknd    | "RI_FKey_cascade_del"  |      9 | f            | f
- fknd    | "RI_FKey_noaction_upd" |     17 | f            | f
- fknd2   | "RI_FKey_cascade_del"  |      9 | f            | f
- fknd2   | "RI_FKey_noaction_upd" |     17 | f            | f
-(12 rows)
+ conname | tgfoid | tgtype | tgdeferrable | tginitdeferred 
+---------+--------+--------+--------------+----------------
+(0 rows)
 
 SELECT conname, tgfoid::regproc, tgtype, tgdeferrable, tginitdeferred
 FROM pg_trigger JOIN pg_constraint con ON con.oid = tgconstraint
 WHERE tgrelid = 'fktable'::regclass
 ORDER BY 1,2,3;
- conname |       tgfoid        | tgtype | tgdeferrable | tginitdeferred 
----------+---------------------+--------+--------------+----------------
- fkdd    | "RI_FKey_check_ins" |      5 | t            | t
- fkdd    | "RI_FKey_check_upd" |     17 | t            | t
- fkdd2   | "RI_FKey_check_ins" |      5 | t            | t
- fkdd2   | "RI_FKey_check_upd" |     17 | t            | t
- fkdi    | "RI_FKey_check_ins" |      5 | t            | f
- fkdi    | "RI_FKey_check_upd" |     17 | t            | f
- fkdi2   | "RI_FKey_check_ins" |      5 | t            | f
- fkdi2   | "RI_FKey_check_upd" |     17 | t            | f
- fknd    | "RI_FKey_check_ins" |      5 | f            | f
- fknd    | "RI_FKey_check_upd" |     17 | f            | f
- fknd2   | "RI_FKey_check_ins" |      5 | f            | f
- fknd2   | "RI_FKey_check_upd" |     17 | f            | f
-(12 rows)
+ conname | tgfoid | tgtype | tgdeferrable | tginitdeferred 
+---------+--------+--------+--------------+----------------
+(0 rows)
 
 -- temp tables should go away by themselves, need not drop them.
 -- test check constraint adding
@@ -791,8 +1009,7 @@
 alter table atacc1 add constraint atacc_test1 check (test>3);
 -- should fail
 insert into atacc1 (test) values (2);
-ERROR:  new row for relation "atacc1" violates check constraint "atacc_test1"
-DETAIL:  Failing row contains (2).
+ERROR:  failed to satisfy CHECK constraint (test > 3:::INT8)
 -- should succeed
 insert into atacc1 (test) values (4);
 drop table atacc1;
@@ -801,8 +1018,7 @@
 -- insert a soon to be failing row
 insert into atacc1 (test) values (2);
 -- add a check constraint (fails)
-alter table atacc1 add constraint atacc_test1 check (test>3);
-ERROR:  check constraint "atacc_test1" of relation "atacc1" is violated by some row
+-- alter table atacc1 add constraint atacc_test1 check (test>3);
 insert into atacc1 (test) values (4);
 drop table atacc1;
 -- let's do one where the check fails because the column doesn't exist
@@ -810,7 +1026,6 @@
 -- add a check constraint (fails)
 alter table atacc1 add constraint atacc_test1 check (test1>3);
 ERROR:  column "test1" does not exist
-HINT:  Perhaps you meant to reference the column "atacc1.test".
 drop table atacc1;
 -- something a little more complicated
 create table atacc1 ( test int, test2 int, test3 int);
@@ -818,8 +1033,7 @@
 alter table atacc1 add constraint atacc_test1 check (test+test2<test3*4);
 -- should fail
 insert into atacc1 (test,test2,test3) values (4,4,2);
-ERROR:  new row for relation "atacc1" violates check constraint "atacc_test1"
-DETAIL:  Failing row contains (4, 4, 2).
+ERROR:  failed to satisfy CHECK constraint ((test + test2) < (test3 * 4:::INT8))
 -- should succeed
 insert into atacc1 (test,test2,test3) values (4,4,5);
 drop table atacc1;
@@ -828,37 +1042,58 @@
 alter table atacc1 add check (test2>test);
 -- should fail for $2
 insert into atacc1 (test2, test) values (3, 4);
-ERROR:  new row for relation "atacc1" violates check constraint "atacc1_check"
-DETAIL:  Failing row contains (4, 3).
+ERROR:  failed to satisfy CHECK constraint (test2 > test)
 drop table atacc1;
 -- inheritance related tests
 create table atacc1 (test int);
 create table atacc2 (test2 int);
 create table atacc3 (test3 int) inherits (atacc1, atacc2);
+ERROR:  at or near "(": syntax error: unimplemented: this syntax
+DETAIL:  source SQL:
+create table atacc3 (test3 int) inherits (atacc1, atacc2)
+                                         ^
+HINT:  You have attempted to use a feature that is not yet implemented.
+See: https://go.crdb.dev/issue-v/22456/_version_
 alter table atacc2 add constraint foo check (test2>0);
 -- fail and then succeed on atacc2
 insert into atacc2 (test2) values (-3);
-ERROR:  new row for relation "atacc2" violates check constraint "foo"
-DETAIL:  Failing row contains (-3).
+ERROR:  failed to satisfy CHECK constraint (test2 > 0:::INT8)
 insert into atacc2 (test2) values (3);
 -- fail and then succeed on atacc3
 insert into atacc3 (test2) values (-3);
-ERROR:  new row for relation "atacc3" violates check constraint "foo"
-DETAIL:  Failing row contains (null, -3, null).
+ERROR:  relation "atacc3" does not exist
 insert into atacc3 (test2) values (3);
+ERROR:  relation "atacc3" does not exist
 drop table atacc3;
+ERROR:  relation "atacc3" does not exist
 drop table atacc2;
 drop table atacc1;
 -- same things with one created with INHERIT
 create table atacc1 (test int);
 create table atacc2 (test2 int);
 create table atacc3 (test3 int) inherits (atacc1, atacc2);
+ERROR:  at or near "(": syntax error: unimplemented: this syntax
+DETAIL:  source SQL:
+create table atacc3 (test3 int) inherits (atacc1, atacc2)
+                                         ^
+HINT:  You have attempted to use a feature that is not yet implemented.
+See: https://go.crdb.dev/issue-v/22456/_version_
 alter table atacc3 no inherit atacc2;
+ERROR:  at or near "inherit": syntax error
+DETAIL:  source SQL:
+alter table atacc3 no inherit atacc2
+                      ^
+HINT:  try \h ALTER TABLE
 -- fail
 alter table atacc3 no inherit atacc2;
-ERROR:  relation "atacc2" is not a parent of relation "atacc3"
+ERROR:  at or near "inherit": syntax error
+DETAIL:  source SQL:
+alter table atacc3 no inherit atacc2
+                      ^
+HINT:  try \h ALTER TABLE
 -- make sure it really isn't a child
 insert into atacc3 (test2) values (3);
+ERROR:  relation "atacc3" does not exist
 select test2 from atacc2;
  test2 
 -------
@@ -867,56 +1102,100 @@
 -- fail due to missing constraint
 alter table atacc2 add constraint foo check (test2>0);
 alter table atacc3 inherit atacc2;
-ERROR:  child table is missing constraint "foo"
+ERROR:  at or near "inherit": syntax error
+DETAIL:  source SQL:
+alter table atacc3 inherit atacc2
+                   ^
+HINT:  try \h ALTER TABLE
 -- fail due to missing column
 alter table atacc3 rename test2 to testx;
+ERROR:  relation "atacc3" does not exist
 alter table atacc3 inherit atacc2;
-ERROR:  child table is missing column "test2"
+ERROR:  at or near "inherit": syntax error
+DETAIL:  source SQL:
+alter table atacc3 inherit atacc2
+                   ^
+HINT:  try \h ALTER TABLE
 -- fail due to mismatched data type
 alter table atacc3 add test2 bool;
+ERROR:  relation "atacc3" does not exist
 alter table atacc3 inherit atacc2;
-ERROR:  child table "atacc3" has different type for column "test2"
+ERROR:  at or near "inherit": syntax error
+DETAIL:  source SQL:
+alter table atacc3 inherit atacc2
+                   ^
+HINT:  try \h ALTER TABLE
 alter table atacc3 drop test2;
+ERROR:  relation "atacc3" does not exist
 -- succeed
 alter table atacc3 add test2 int;
+ERROR:  relation "atacc3" does not exist
 update atacc3 set test2 = 4 where test2 is null;
+ERROR:  relation "atacc3" does not exist
 alter table atacc3 add constraint foo check (test2>0);
+ERROR:  relation "atacc3" does not exist
 alter table atacc3 inherit atacc2;
+ERROR:  at or near "inherit": syntax error
+DETAIL:  source SQL:
+alter table atacc3 inherit atacc2
+                   ^
+HINT:  try \h ALTER TABLE
 -- fail due to duplicates and circular inheritance
 alter table atacc3 inherit atacc2;
-ERROR:  relation "atacc2" would be inherited from more than once
+ERROR:  at or near "inherit": syntax error
+DETAIL:  source SQL:
+alter table atacc3 inherit atacc2
+                   ^
+HINT:  try \h ALTER TABLE
 alter table atacc2 inherit atacc3;
-ERROR:  circular inheritance not allowed
-DETAIL:  "atacc3" is already a child of "atacc2".
+ERROR:  at or near "inherit": syntax error
+DETAIL:  source SQL:
+alter table atacc2 inherit atacc3
+                   ^
+HINT:  try \h ALTER TABLE
 alter table atacc2 inherit atacc2;
-ERROR:  circular inheritance not allowed
-DETAIL:  "atacc2" is already a child of "atacc2".
+ERROR:  at or near "inherit": syntax error
+DETAIL:  source SQL:
+alter table atacc2 inherit atacc2
+                   ^
+HINT:  try \h ALTER TABLE
 -- test that we really are a child now (should see 4 not 3 and cascade should go through)
 select test2 from atacc2;
  test2 
 -------
-     4
-(1 row)
+(0 rows)
 
 drop table atacc2 cascade;
-NOTICE:  drop cascades to table atacc3
 drop table atacc1;
 -- adding only to a parent is allowed as of 9.2
 create table atacc1 (test int);
 create table atacc2 (test2 int) inherits (atacc1);
+ERROR:  at or near "(": syntax error: unimplemented: this syntax
+DETAIL:  source SQL:
+create table atacc2 (test2 int) inherits (atacc1)
+                                         ^
+HINT:  You have attempted to use a feature that is not yet implemented.
+See: https://go.crdb.dev/issue-v/22456/_version_
 -- ok:
 alter table atacc1 add constraint foo check (test>0) no inherit;
+ERROR:  at or near "no": syntax error
+DETAIL:  source SQL:
+alter table atacc1 add constraint foo check (test>0) no inherit
+                                                     ^
 -- check constraint is not there on child
 insert into atacc2 (test) values (-3);
+ERROR:  relation "atacc2" does not exist
 -- check constraint is there on parent
 insert into atacc1 (test) values (-3);
-ERROR:  new row for relation "atacc1" violates check constraint "foo"
-DETAIL:  Failing row contains (-3).
 insert into atacc1 (test) values (3);
 -- fail, violating row:
 alter table atacc2 add constraint foo check (test>0) no inherit;
-ERROR:  check constraint "foo" of relation "atacc2" is violated by some row
+ERROR:  at or near "no": syntax error
+DETAIL:  source SQL:
+alter table atacc2 add constraint foo check (test>0) no inherit
+                                                     ^
 drop table atacc2;
+ERROR:  relation "atacc2" does not exist
 drop table atacc1;
 -- test unique constraint adding
 create table atacc1 ( test int ) ;
@@ -932,8 +1211,11 @@
 insert into atacc1 (test) values (4);
 -- try to create duplicates via alter table using - should fail
 alter table atacc1 alter column test type integer using 0;
-ERROR:  could not create unique index "atacc_test1"
-DETAIL:  Key (test)=(0) is duplicated.
+ERROR:  unimplemented: ALTER COLUMN TYPE requiring rewrite of on-disk data is currently not supported for columns that are part of an index
+HINT:  You have attempted to use a feature that is not yet implemented.
+See: https://go.crdb.dev/issue-v/47636/_version_
+--
+Consider modifying the index.
 drop table atacc1;
 -- let's do one where the unique constraint fails when added
 create table atacc1 ( test int );
@@ -942,8 +1224,8 @@
 insert into atacc1 (test) values (2);
 -- add a unique constraint (fails)
 alter table atacc1 add constraint atacc_test1 unique (test);
-ERROR:  could not create unique index "atacc_test1"
-DETAIL:  Key (test)=(2) is duplicated.
+ERROR:  failed to ingest index entries during backfill: duplicate key value violates unique constraint "atacc_test1"
+DETAIL:  Key (test)=(2) already exists.
 insert into atacc1 (test) values (3);
 drop table atacc1;
 -- let's do one where the unique constraint fails
@@ -951,7 +1233,7 @@
 create table atacc1 ( test int );
 -- add a unique constraint (fails)
 alter table atacc1 add constraint atacc_test1 unique (test1);
-ERROR:  column "test1" named in key does not exist
+ERROR:  column "test1" does not exist
 drop table atacc1;
 -- something a little more complicated
 create table atacc1 ( test int, test2 int);
@@ -981,25 +1263,23 @@
 create table atacc1 ( id serial, test int) ;
 -- add a primary key constraint
 alter table atacc1 add constraint atacc_test1 primary key (test);
+ERROR:  cannot use nullable column "test" in primary key
 -- insert first value
 insert into atacc1 (test) values (2);
 -- should fail
 insert into atacc1 (test) values (2);
-ERROR:  duplicate key value violates unique constraint "atacc_test1"
-DETAIL:  Key (test)=(2) already exists.
 -- should succeed
 insert into atacc1 (test) values (4);
 -- inserting NULL should fail
 insert into atacc1 (test) values(NULL);
-ERROR:  null value in column "test" of relation "atacc1" violates not-null constraint
-DETAIL:  Failing row contains (4, null).
 -- try adding a second primary key (should fail)
 alter table atacc1 add constraint atacc_oid1 primary key(id);
-ERROR:  multiple primary keys for table "atacc1" are not allowed
 -- drop first primary key constraint
 alter table atacc1 drop constraint atacc_test1 restrict;
+ERROR:  constraint "atacc_test1" of relation "atacc1" does not exist
 -- try adding a primary key on oid (should succeed)
 alter table atacc1 add constraint atacc_oid1 primary key(id);
+ERROR:  multiple primary keys for table "atacc1" are not allowed
 drop table atacc1;
 -- let's do one where the primary key constraint fails when added
 create table atacc1 ( test int );
@@ -1008,8 +1288,7 @@
 insert into atacc1 (test) values (2);
 -- add a primary key (fails)
 alter table atacc1 add constraint atacc_test1 primary key (test);
-ERROR:  could not create unique index "atacc_test1"
-DETAIL:  Key (test)=(2) is duplicated.
+ERROR:  cannot use nullable column "test" in primary key
 insert into atacc1 (test) values (3);
 drop table atacc1;
 -- let's do another one where the primary key constraint fails when added
@@ -1018,7 +1297,7 @@
 insert into atacc1 (test) values (NULL);
 -- add a primary key (fails)
 alter table atacc1 add constraint atacc_test1 primary key (test);
-ERROR:  column "test" of relation "atacc1" contains null values
+ERROR:  cannot use nullable column "test" in primary key
 insert into atacc1 (test) values (3);
 drop table atacc1;
 -- let's do one where the primary key constraint fails
@@ -1026,7 +1305,7 @@
 create table atacc1 ( test int );
 -- add a primary key constraint (fails)
 alter table atacc1 add constraint atacc_test1 primary key (test1);
-ERROR:  column "test1" of relation "atacc1" does not exist
+ERROR:  column "test1" does not exist
 drop table atacc1;
 -- adding a new column as primary key to a non-empty table.
 -- should fail unless the column has a non-null default value.
@@ -1034,9 +1313,10 @@
 insert into atacc1 (test) values (0);
 -- add a primary key column without a default (fails).
 alter table atacc1 add column test2 int primary key;
-ERROR:  column "test2" of relation "atacc1" contains null values
+ERROR:  multiple primary keys for table "atacc1" are not allowed
 -- now add a primary key column with a default (succeeds).
 alter table atacc1 add column test2 int default 0 primary key;
+ERROR:  multiple primary keys for table "atacc1" are not allowed
 drop table atacc1;
 -- this combination used to have order-of-execution problems (bug #15580)
 create table atacc1 (a int);
@@ -1044,6 +1324,7 @@
 alter table atacc1
   add column b float8 not null default random(),
   add primary key(a);
+ERROR:  cannot use nullable column "a" in primary key
 drop table atacc1;
 -- additionally, we've seen issues with foreign key validation not being
 -- properly delayed until after a table rewrite.  Check that works ok.
@@ -1062,31 +1343,23 @@
 create table atacc1 (a bigint, b int);
 insert into atacc1 values(1,2);
 alter table atacc1 add constraint atacc1_chk check(b = 1) not valid;
-alter table atacc1 validate constraint atacc1_chk, alter a type int;
-ERROR:  check constraint "atacc1_chk" of relation "atacc1" is violated by some row
+-- alter table atacc1 validate constraint atacc1_chk, alter a type int;
 drop table atacc1;
 -- something a little more complicated
 create table atacc1 ( test int, test2 int);
 -- add a primary key constraint
 alter table atacc1 add constraint atacc_test1 primary key (test, test2);
+ERROR:  cannot use nullable column "test" in primary key
 -- try adding a second primary key - should fail
 alter table atacc1 add constraint atacc_test2 primary key (test);
-ERROR:  multiple primary keys for table "atacc1" are not allowed
+ERROR:  cannot use nullable column "test" in primary key
 -- insert initial value
 insert into atacc1 (test,test2) values (4,4);
 -- should fail
 insert into atacc1 (test,test2) values (4,4);
-ERROR:  duplicate key value violates unique constraint "atacc_test1"
-DETAIL:  Key (test, test2)=(4, 4) already exists.
 insert into atacc1 (test,test2) values (NULL,3);
-ERROR:  null value in column "test" of relation "atacc1" violates not-null constraint
-DETAIL:  Failing row contains (null, 3).
 insert into atacc1 (test,test2) values (3, NULL);
-ERROR:  null value in column "test2" of relation "atacc1" violates not-null constraint
-DETAIL:  Failing row contains (3, null).
 insert into atacc1 (test,test2) values (NULL,NULL);
-ERROR:  null value in column "test" of relation "atacc1" violates not-null constraint
-DETAIL:  Failing row contains (null, null).
 -- should all succeed
 insert into atacc1 (test,test2) values (4,5);
 insert into atacc1 (test,test2) values (5,4);
@@ -1100,15 +1373,14 @@
 ERROR:  duplicate key value violates unique constraint "atacc1_pkey"
 DETAIL:  Key (test)=(3) already exists.
 insert into atacc1 (test2, test) values (1, NULL);
-ERROR:  null value in column "test" of relation "atacc1" violates not-null constraint
-DETAIL:  Failing row contains (null, 1).
+ERROR:  null value in column "test" violates not-null constraint
 drop table atacc1;
 -- alter table / alter column [set/drop] not null tests
 -- try altering system catalogs, should fail
 alter table pg_class alter column relname drop not null;
-ERROR:  permission denied: "pg_class" is a system catalog
+ERROR:  pg_class is a system catalog
 alter table pg_class alter relname set not null;
-ERROR:  permission denied: "pg_class" is a system catalog
+ERROR:  pg_class is a system catalog
 -- try altering non-existent table, should fail
 alter table non_existent alter column bar set not null;
 ERROR:  relation "non_existent" does not exist
@@ -1119,27 +1391,29 @@
 create table atacc1 (test int not null);
 alter table atacc1 add constraint "atacc1_pkey" primary key (test);
 alter table atacc1 alter column test drop not null;
-ERROR:  column "test" is in a primary key
+ERROR:  column "test" is in a primary index
 alter table atacc1 drop constraint "atacc1_pkey";
+ERROR:  relation "atacc1": unimplemented: primary key dropped without subsequent addition of new primary key in same transaction
+HINT:  You have attempted to use a feature that is not yet implemented.
+See: https://go.crdb.dev/issue-v/48026/_version_
 alter table atacc1 alter column test drop not null;
+ERROR:  column "test" is in a primary index
 insert into atacc1 values (null);
+ERROR:  null value in column "test" violates not-null constraint
 alter table atacc1 alter test set not null;
-ERROR:  column "test" of relation "atacc1" contains null values
 delete from atacc1;
 alter table atacc1 alter test set not null;
 -- try altering a non-existent column, should fail
 alter table atacc1 alter bar set not null;
-ERROR:  column "bar" of relation "atacc1" does not exist
+ERROR:  column "bar" does not exist
 alter table atacc1 alter bar drop not null;
-ERROR:  column "bar" of relation "atacc1" does not exist
+ERROR:  column "bar" does not exist
 -- try creating a view and altering that, should fail
 create view myview as select * from atacc1;
 alter table myview alter column test drop not null;
-ERROR:  ALTER action ALTER COLUMN ... DROP NOT NULL cannot be performed on relation "myview"
-DETAIL:  This operation is not supported for views.
+ERROR:  "myview" is not a table
 alter table myview alter column test set not null;
-ERROR:  ALTER action ALTER COLUMN ... SET NOT NULL cannot be performed on relation "myview"
-DETAIL:  This operation is not supported for views.
+ERROR:  "myview" is not a table
 drop view myview;
 drop table atacc1;
 -- set not null verified by constraints
@@ -1147,13 +1421,11 @@
 insert into atacc1 values (null, 1);
 -- constraint not cover all values, should fail
 alter table atacc1 add constraint atacc1_constr_or check(test_a is not null or test_b < 10);
-alter table atacc1 alter test_a set not null;
-ERROR:  column "test_a" of relation "atacc1" contains null values
+-- alter table atacc1 alter test_a set not null;
 alter table atacc1 drop constraint atacc1_constr_or;
 -- not valid constraint, should fail
 alter table atacc1 add constraint atacc1_constr_invalid check(test_a is not null) not valid;
-alter table atacc1 alter test_a set not null;
-ERROR:  column "test_a" of relation "atacc1" contains null values
+-- alter table atacc1 alter test_a set not null;
 alter table atacc1 drop constraint atacc1_constr_invalid;
 -- with valid constraint
 update atacc1 set test_a = 1;
@@ -1164,11 +1436,9 @@
 alter table atacc1 alter test_a drop not null;
 -- test multiple set not null at same time
 -- test_a checked by atacc1_constr_a_valid, test_b should fail by table scan
-alter table atacc1 alter test_a set not null, alter test_b set not null;
-ERROR:  column "test_b" of relation "atacc1" contains null values
+-- alter table atacc1 alter test_a set not null, alter test_b set not null;
 -- commands order has no importance
-alter table atacc1 alter test_b set not null, alter test_a set not null;
-ERROR:  column "test_b" of relation "atacc1" contains null values
+-- alter table atacc1 alter test_b set not null, alter test_a set not null;
 -- valid one by table scan, one by check constraints
 update atacc1 set test_b = 1;
 alter table atacc1 alter test_b set not null, alter test_a set not null;
@@ -1179,36 +1449,41 @@
 drop table atacc1;
 -- test inheritance
 create table parent (a int);
+ERROR:  relation "root.public.parent" already exists
 create table child (b varchar(255)) inherits (parent);
+ERROR:  at or near "(": syntax error: unimplemented: this syntax
+DETAIL:  source SQL:
+create table child (b varchar(255)) inherits (parent)
+                                             ^
+HINT:  You have attempted to use a feature that is not yet implemented.
+See: https://go.crdb.dev/issue-v/22456/_version_
 alter table parent alter a set not null;
 insert into parent values (NULL);
-ERROR:  null value in column "a" of relation "parent" violates not-null constraint
-DETAIL:  Failing row contains (null).
+ERROR:  null value in column "a" violates not-null constraint
 insert into child (a, b) values (NULL, 'foo');
-ERROR:  null value in column "a" of relation "child" violates not-null constraint
-DETAIL:  Failing row contains (null, foo).
+ERROR:  relation "child" does not exist
 alter table parent alter a drop not null;
 insert into parent values (NULL);
 insert into child (a, b) values (NULL, 'foo');
-alter table only parent alter a set not null;
-ERROR:  column "a" of relation "parent" contains null values
+ERROR:  relation "child" does not exist
+-- alter table only parent alter a set not null;
 alter table child alter a set not null;
-ERROR:  column "a" of relation "child" contains null values
+ERROR:  relation "child" does not exist
 delete from parent;
-alter table only parent alter a set not null;
+-- alter table only parent alter a set not null;
 insert into parent values (NULL);
-ERROR:  null value in column "a" of relation "parent" violates not-null constraint
-DETAIL:  Failing row contains (null).
 alter table child alter a set not null;
+ERROR:  relation "child" does not exist
 insert into child (a, b) values (NULL, 'foo');
-ERROR:  null value in column "a" of relation "child" violates not-null constraint
-DETAIL:  Failing row contains (null, foo).
+ERROR:  relation "child" does not exist
 delete from child;
+ERROR:  relation "child" does not exist
 alter table child alter a set not null;
+ERROR:  relation "child" does not exist
 insert into child (a, b) values (NULL, 'foo');
-ERROR:  null value in column "a" of relation "child" violates not-null constraint
-DETAIL:  Failing row contains (null, foo).
+ERROR:  relation "child" does not exist
 drop table child;
+ERROR:  relation "child" does not exist
 drop table parent;
 -- test setting and removing default values
 create table def_test (
@@ -1234,11 +1509,12 @@
 
 -- set defaults to an incorrect type: this should fail
 alter table def_test alter column c1 set default 'wrong_datatype';
-ERROR:  invalid input syntax for type integer: "wrong_datatype"
+ERROR:  could not parse "wrong_datatype" as type int: strconv.ParseInt: parsing "wrong_datatype": invalid syntax
 alter table def_test alter column c2 set default 20;
+ERROR:  expected DEFAULT (in SET DEFAULT) expression to have type string, but '20' has type int
 -- set defaults on a non-existent column: this should fail
 alter table def_test alter column c3 set default 30;
-ERROR:  column "c3" of relation "def_test" does not exist
+ERROR:  column "c3" does not exist
 -- set defaults on views: we need to create a view, add a rule
 -- to allow insertions into it, and then alter the view to add
 -- a default
@@ -1246,11 +1522,31 @@
 create rule def_view_test_ins as
 	on insert to def_view_test
 	do instead insert into def_test select new.*;
+ERROR:  at or near "def_view_test_ins": syntax error: unimplemented: this syntax
+DETAIL:  source SQL:
+create rule def_view_test_ins as
+            ^
+HINT:  You have attempted to use a feature that is not yet implemented.
+
+Please check the public issue tracker to check whether this problem is
+already tracked. If you cannot find it there, please report the error
+with details by creating a new issue.
+
+If you would rather not post publicly, please contact us directly
+using the support form.
+
+We appreciate your feedback.
+
 insert into def_view_test default values;
+ERROR:  "def_view_test" is not a table
 alter table def_view_test alter column c1 set default 45;
+ERROR:  "def_view_test" is not a table
 insert into def_view_test default values;
+ERROR:  "def_view_test" is not a table
 alter table def_view_test alter column c2 set default 'view_default';
+ERROR:  "def_view_test" is not a table
 insert into def_view_test default values;
+ERROR:  "def_view_test" is not a table
 select * from def_view_test;
  c1 |       c2        
 ----+-----------------
@@ -1258,18 +1554,30 @@
     | initial_default
     | 
  10 | new_default
-    | 
- 45 | 
- 45 | view_default
-(7 rows)
+(4 rows)
 
 drop rule def_view_test_ins on def_view_test;
+ERROR:  at or near "def_view_test_ins": syntax error: unimplemented: this syntax
+DETAIL:  source SQL:
+drop rule def_view_test_ins on def_view_test
+          ^
+HINT:  You have attempted to use a feature that is not yet implemented.
+
+Please check the public issue tracker to check whether this problem is
+already tracked. If you cannot find it there, please report the error
+with details by creating a new issue.
+
+If you would rather not post publicly, please contact us directly
+using the support form.
+
+We appreciate your feedback.
+
 drop view def_view_test;
 drop table def_test;
 -- alter table / drop column tests
 -- try altering system catalogs, should fail
 alter table pg_class drop column relname;
-ERROR:  permission denied: "pg_class" is a system catalog
+ERROR:  pg_class is a system catalog
 -- try altering non-existent table, should fail
 alter table nosuchtable drop column bar;
 ERROR:  relation "nosuchtable" does not exist
@@ -1278,7 +1586,7 @@
 insert into atacc1 values (1, 2, 3, 4);
 alter table atacc1 drop a;
 alter table atacc1 drop a;
-ERROR:  column "a" of relation "atacc1" does not exist
+ERROR:  column "a" does not exist
 -- SELECTs
 select * from atacc1;
  b | c | d 
@@ -1288,20 +1596,12 @@
 
 select * from atacc1 order by a;
 ERROR:  column "a" does not exist
-LINE 1: select * from atacc1 order by a;
-                                      ^
 select * from atacc1 order by "........pg.dropped.1........";
 ERROR:  column "........pg.dropped.1........" does not exist
-LINE 1: select * from atacc1 order by "........pg.dropped.1........"...
-                                      ^
 select * from atacc1 group by a;
 ERROR:  column "a" does not exist
-LINE 1: select * from atacc1 group by a;
-                                      ^
 select * from atacc1 group by "........pg.dropped.1........";
 ERROR:  column "........pg.dropped.1........" does not exist
-LINE 1: select * from atacc1 group by "........pg.dropped.1........"...
-                                      ^
 select atacc1.* from atacc1;
  b | c | d 
 ---+---+---
@@ -1310,12 +1610,8 @@
 
 select a from atacc1;
 ERROR:  column "a" does not exist
-LINE 1: select a from atacc1;
-               ^
 select atacc1.a from atacc1;
-ERROR:  column atacc1.a does not exist
-LINE 1: select atacc1.a from atacc1;
-               ^
+ERROR:  column "atacc1.a" does not exist
 select b,c,d from atacc1;
  b | c | d 
 ---+---+---
@@ -1324,111 +1620,74 @@
 
 select a,b,c,d from atacc1;
 ERROR:  column "a" does not exist
-LINE 1: select a,b,c,d from atacc1;
-               ^
 select * from atacc1 where a = 1;
 ERROR:  column "a" does not exist
-LINE 1: select * from atacc1 where a = 1;
-                                   ^
 select "........pg.dropped.1........" from atacc1;
 ERROR:  column "........pg.dropped.1........" does not exist
-LINE 1: select "........pg.dropped.1........" from atacc1;
-               ^
 select atacc1."........pg.dropped.1........" from atacc1;
-ERROR:  column atacc1.........pg.dropped.1........ does not exist
-LINE 1: select atacc1."........pg.dropped.1........" from atacc1;
-               ^
+ERROR:  column "atacc1.........pg.dropped.1........" does not exist
 select "........pg.dropped.1........",b,c,d from atacc1;
 ERROR:  column "........pg.dropped.1........" does not exist
-LINE 1: select "........pg.dropped.1........",b,c,d from atacc1;
-               ^
 select * from atacc1 where "........pg.dropped.1........" = 1;
 ERROR:  column "........pg.dropped.1........" does not exist
-LINE 1: select * from atacc1 where "........pg.dropped.1........" = ...
-                                   ^
 -- UPDATEs
 update atacc1 set a = 3;
-ERROR:  column "a" of relation "atacc1" does not exist
-LINE 1: update atacc1 set a = 3;
-                          ^
+ERROR:  column "a" does not exist
 update atacc1 set b = 2 where a = 3;
 ERROR:  column "a" does not exist
-LINE 1: update atacc1 set b = 2 where a = 3;
-                                      ^
 update atacc1 set "........pg.dropped.1........" = 3;
-ERROR:  column "........pg.dropped.1........" of relation "atacc1" does not exist
-LINE 1: update atacc1 set "........pg.dropped.1........" = 3;
-                          ^
+ERROR:  column "........pg.dropped.1........" does not exist
 update atacc1 set b = 2 where "........pg.dropped.1........" = 3;
 ERROR:  column "........pg.dropped.1........" does not exist
-LINE 1: update atacc1 set b = 2 where "........pg.dropped.1........"...
-                                      ^
 -- INSERTs
 insert into atacc1 values (10, 11, 12, 13);
-ERROR:  INSERT has more expressions than target columns
-LINE 1: insert into atacc1 values (10, 11, 12, 13);
-                                               ^
+ERROR:  INSERT has more expressions than target columns, 4 expressions for 3 targets
 insert into atacc1 values (default, 11, 12, 13);
-ERROR:  INSERT has more expressions than target columns
-LINE 1: insert into atacc1 values (default, 11, 12, 13);
-                                                    ^
+ERROR:  INSERT has more expressions than target columns, 4 expressions for 3 targets
 insert into atacc1 values (11, 12, 13);
 insert into atacc1 (a) values (10);
-ERROR:  column "a" of relation "atacc1" does not exist
-LINE 1: insert into atacc1 (a) values (10);
-                            ^
+ERROR:  column "a" does not exist
 insert into atacc1 (a) values (default);
-ERROR:  column "a" of relation "atacc1" does not exist
-LINE 1: insert into atacc1 (a) values (default);
-                            ^
+ERROR:  column "a" does not exist
 insert into atacc1 (a,b,c,d) values (10,11,12,13);
-ERROR:  column "a" of relation "atacc1" does not exist
-LINE 1: insert into atacc1 (a,b,c,d) values (10,11,12,13);
-                            ^
+ERROR:  column "a" does not exist
 insert into atacc1 (a,b,c,d) values (default,11,12,13);
-ERROR:  column "a" of relation "atacc1" does not exist
-LINE 1: insert into atacc1 (a,b,c,d) values (default,11,12,13);
-                            ^
+ERROR:  column "a" does not exist
 insert into atacc1 (b,c,d) values (11,12,13);
 insert into atacc1 ("........pg.dropped.1........") values (10);
-ERROR:  column "........pg.dropped.1........" of relation "atacc1" does not exist
-LINE 1: insert into atacc1 ("........pg.dropped.1........") values (...
-                            ^
+ERROR:  column "........pg.dropped.1........" does not exist
 insert into atacc1 ("........pg.dropped.1........") values (default);
-ERROR:  column "........pg.dropped.1........" of relation "atacc1" does not exist
-LINE 1: insert into atacc1 ("........pg.dropped.1........") values (...
-                            ^
+ERROR:  column "........pg.dropped.1........" does not exist
 insert into atacc1 ("........pg.dropped.1........",b,c,d) values (10,11,12,13);
-ERROR:  column "........pg.dropped.1........" of relation "atacc1" does not exist
-LINE 1: insert into atacc1 ("........pg.dropped.1........",b,c,d) va...
-                            ^
+ERROR:  column "........pg.dropped.1........" does not exist
 insert into atacc1 ("........pg.dropped.1........",b,c,d) values (default,11,12,13);
-ERROR:  column "........pg.dropped.1........" of relation "atacc1" does not exist
-LINE 1: insert into atacc1 ("........pg.dropped.1........",b,c,d) va...
-                            ^
+ERROR:  column "........pg.dropped.1........" does not exist
 -- DELETEs
 delete from atacc1 where a = 3;
 ERROR:  column "a" does not exist
-LINE 1: delete from atacc1 where a = 3;
-                                 ^
 delete from atacc1 where "........pg.dropped.1........" = 3;
 ERROR:  column "........pg.dropped.1........" does not exist
-LINE 1: delete from atacc1 where "........pg.dropped.1........" = 3;
-                                 ^
 delete from atacc1;
 -- try dropping a non-existent column, should fail
 alter table atacc1 drop bar;
-ERROR:  column "bar" of relation "atacc1" does not exist
+ERROR:  column "bar" does not exist
 -- try removing an oid column, should succeed (as it's nonexistent)
 alter table atacc1 SET WITHOUT OIDS;
+ERROR:  at or near "without": syntax error
+DETAIL:  source SQL:
+alter table atacc1 SET WITHOUT OIDS
+                       ^
+HINT:  try \h ALTER TABLE
 -- try adding an oid column, should fail (not supported)
 alter table atacc1 SET WITH OIDS;
-ERROR:  syntax error at or near "WITH"
-LINE 1: alter table atacc1 SET WITH OIDS;
-                               ^
+ERROR:  at or near "with": syntax error
+DETAIL:  source SQL:
+alter table atacc1 SET WITH OIDS
+                       ^
+HINT:  try \h ALTER TABLE
 -- try dropping the xmin column, should fail
 alter table atacc1 drop xmin;
-ERROR:  cannot drop system column "xmin"
+ERROR:  column "xmin" does not exist
 -- try creating a view and altering that, should fail
 create view myview as select * from atacc1;
 select * from myview;
@@ -1437,71 +1696,98 @@
 (0 rows)
 
 alter table myview drop d;
-ERROR:  ALTER action DROP COLUMN cannot be performed on relation "myview"
-DETAIL:  This operation is not supported for views.
+ERROR:  "myview" is not a table
 drop view myview;
 -- test some commands to make sure they fail on the dropped column
 analyze atacc1(a);
-ERROR:  column "a" of relation "atacc1" does not exist
+ERROR:  at or near "(": syntax error
+DETAIL:  source SQL:
+analyze atacc1(a)
+              ^
 analyze atacc1("........pg.dropped.1........");
-ERROR:  column "........pg.dropped.1........" of relation "atacc1" does not exist
+ERROR:  at or near "(": syntax error
+DETAIL:  source SQL:
+analyze atacc1("........pg.dropped.1........")
+              ^
 vacuum analyze atacc1(a);
-ERROR:  column "a" of relation "atacc1" does not exist
+ERROR:  at or near "vacuum": syntax error
+DETAIL:  source SQL:
+vacuum analyze atacc1(a)
+^
 vacuum analyze atacc1("........pg.dropped.1........");
-ERROR:  column "........pg.dropped.1........" of relation "atacc1" does not exist
+ERROR:  at or near "vacuum": syntax error
+DETAIL:  source SQL:
+vacuum analyze atacc1("........pg.dropped.1........")
+^
 comment on column atacc1.a is 'testing';
-ERROR:  column "a" of relation "atacc1" does not exist
+ERROR:  column "a" does not exist
 comment on column atacc1."........pg.dropped.1........" is 'testing';
-ERROR:  column "........pg.dropped.1........" of relation "atacc1" does not exist
+ERROR:  column "........pg.dropped.1........" does not exist
 alter table atacc1 alter a set storage plain;
-ERROR:  column "a" of relation "atacc1" does not exist
+ERROR:  at or near "storage": syntax error
+DETAIL:  source SQL:
+alter table atacc1 alter a set storage plain
+                               ^
+HINT:  try \h ALTER TABLE
 alter table atacc1 alter "........pg.dropped.1........" set storage plain;
-ERROR:  column "........pg.dropped.1........" of relation "atacc1" does not exist
+ERROR:  at or near "storage": syntax error
+DETAIL:  source SQL:
+alter table atacc1 alter "........pg.dropped.1........" set storage plain
+                                                            ^
+HINT:  try \h ALTER TABLE
 alter table atacc1 alter a set statistics 0;
-ERROR:  column "a" of relation "atacc1" does not exist
+ERROR:  at or near "statistics": syntax error
+DETAIL:  source SQL:
+alter table atacc1 alter a set statistics 0
+                               ^
+HINT:  try \h ALTER TABLE
 alter table atacc1 alter "........pg.dropped.1........" set statistics 0;
-ERROR:  column "........pg.dropped.1........" of relation "atacc1" does not exist
+ERROR:  at or near "statistics": syntax error
+DETAIL:  source SQL:
+alter table atacc1 alter "........pg.dropped.1........" set statistics 0
+                                                            ^
+HINT:  try \h ALTER TABLE
 alter table atacc1 alter a set default 3;
-ERROR:  column "a" of relation "atacc1" does not exist
+ERROR:  column "a" does not exist
 alter table atacc1 alter "........pg.dropped.1........" set default 3;
-ERROR:  column "........pg.dropped.1........" of relation "atacc1" does not exist
+ERROR:  column "........pg.dropped.1........" does not exist
 alter table atacc1 alter a drop default;
-ERROR:  column "a" of relation "atacc1" does not exist
+ERROR:  column "a" does not exist
 alter table atacc1 alter "........pg.dropped.1........" drop default;
-ERROR:  column "........pg.dropped.1........" of relation "atacc1" does not exist
+ERROR:  column "........pg.dropped.1........" does not exist
 alter table atacc1 alter a set not null;
-ERROR:  column "a" of relation "atacc1" does not exist
+ERROR:  column "a" does not exist
 alter table atacc1 alter "........pg.dropped.1........" set not null;
-ERROR:  column "........pg.dropped.1........" of relation "atacc1" does not exist
+ERROR:  column "........pg.dropped.1........" does not exist
 alter table atacc1 alter a drop not null;
-ERROR:  column "a" of relation "atacc1" does not exist
+ERROR:  column "a" does not exist
 alter table atacc1 alter "........pg.dropped.1........" drop not null;
-ERROR:  column "........pg.dropped.1........" of relation "atacc1" does not exist
+ERROR:  column "........pg.dropped.1........" does not exist
 alter table atacc1 rename a to x;
 ERROR:  column "a" does not exist
 alter table atacc1 rename "........pg.dropped.1........" to x;
 ERROR:  column "........pg.dropped.1........" does not exist
 alter table atacc1 add primary key(a);
-ERROR:  column "a" of relation "atacc1" does not exist
+ERROR:  column "a" does not exist
 alter table atacc1 add primary key("........pg.dropped.1........");
-ERROR:  column "........pg.dropped.1........" of relation "atacc1" does not exist
+ERROR:  column "........pg.dropped.1........" does not exist
 alter table atacc1 add unique(a);
-ERROR:  column "a" named in key does not exist
+ERROR:  column "a" does not exist
 alter table atacc1 add unique("........pg.dropped.1........");
-ERROR:  column "........pg.dropped.1........" named in key does not exist
+ERROR:  column "........pg.dropped.1........" does not exist
 alter table atacc1 add check (a > 3);
 ERROR:  column "a" does not exist
 alter table atacc1 add check ("........pg.dropped.1........" > 3);
 ERROR:  column "........pg.dropped.1........" does not exist
 create table atacc2 (id int4 unique);
 alter table atacc1 add foreign key (a) references atacc2(id);
-ERROR:  column "a" referenced in foreign key constraint does not exist
+ERROR:  column "a" does not exist
 alter table atacc1 add foreign key ("........pg.dropped.1........") references atacc2(id);
-ERROR:  column "........pg.dropped.1........" referenced in foreign key constraint does not exist
+ERROR:  column "........pg.dropped.1........" does not exist
 alter table atacc2 add foreign key (id) references atacc1(a);
-ERROR:  column "a" referenced in foreign key constraint does not exist
+ERROR:  column "a" does not exist
 alter table atacc2 add foreign key (id) references atacc1("........pg.dropped.1........");
-ERROR:  column "........pg.dropped.1........" referenced in foreign key constraint does not exist
+ERROR:  column "........pg.dropped.1........" does not exist
 drop table atacc2;
 create index "testing_idx" on atacc1(a);
 ERROR:  column "a" does not exist
@@ -1510,6 +1796,7 @@
 -- test create as and select into
 insert into atacc1 values (21, 22, 23);
 create table attest1 as select * from atacc1;
+NOTICE:  CREATE TABLE ... AS does not copy over indexes, default expressions, or constraints; the new table has a hidden rowid primary key column
 select * from attest1;
  b  | c  | d  
 ----+----+----
@@ -1518,13 +1805,14 @@
 
 drop table attest1;
 select * into attest2 from atacc1;
+ERROR:  at or near "into": syntax error
+DETAIL:  source SQL:
+select * into attest2 from atacc1
+         ^
 select * from attest2;
- b  | c  | d  
-----+----+----
- 21 | 22 | 23
-(1 row)
-
+ERROR:  relation "attest2" does not exist
 drop table attest2;
+ERROR:  relation "attest2" does not exist
 -- try dropping all columns
 alter table atacc1 drop c;
 alter table atacc1 drop d;
@@ -1536,74 +1824,85 @@
 drop table atacc1;
 -- test constraint error reporting in presence of dropped columns
 create table atacc1 (id serial primary key, value int check (value < 10));
+NOTICE:  using sequential values in a primary key does not perform as well as using random UUIDs. See https://www.cockroachlabs.com/docs/_version_/serial.html
 insert into atacc1(value) values (100);
-ERROR:  new row for relation "atacc1" violates check constraint "atacc1_value_check"
-DETAIL:  Failing row contains (1, 100).
+ERROR:  failed to satisfy CHECK constraint (value < 10:::INT8)
 alter table atacc1 drop column value;
 alter table atacc1 add column value int check (value < 10);
 insert into atacc1(value) values (100);
-ERROR:  new row for relation "atacc1" violates check constraint "atacc1_value_check"
-DETAIL:  Failing row contains (2, 100).
+ERROR:  failed to satisfy CHECK constraint (value < 10:::INT8)
 insert into atacc1(id, value) values (null, 0);
-ERROR:  null value in column "id" of relation "atacc1" violates not-null constraint
-DETAIL:  Failing row contains (null, 0).
+ERROR:  null value in column "id" violates not-null constraint
 drop table atacc1;
 -- test inheritance
 create table parent (a int, b int, c int);
 insert into parent values (1, 2, 3);
 alter table parent drop a;
 create table child (d varchar(255)) inherits (parent);
+ERROR:  at or near "(": syntax error: unimplemented: this syntax
+DETAIL:  source SQL:
+create table child (d varchar(255)) inherits (parent)
+                                             ^
+HINT:  You have attempted to use a feature that is not yet implemented.
+See: https://go.crdb.dev/issue-v/22456/_version_
 insert into child values (12, 13, 'testing');
+ERROR:  relation "child" does not exist
 select * from parent;
- b  | c  
-----+----
-  2 |  3
- 12 | 13
-(2 rows)
-
-select * from child;
- b  | c  |    d    
-----+----+---------
- 12 | 13 | testing
+ b | c 
+---+---
+ 2 | 3
 (1 row)
 
+select * from child;
+ERROR:  relation "child" does not exist
 alter table parent drop c;
 select * from parent;
- b  
-----
-  2
- 12
-(2 rows)
-
-select * from child;
- b  |    d    
-----+---------
- 12 | testing
+ b 
+---
+ 2
 (1 row)
 
+select * from child;
+ERROR:  relation "child" does not exist
 drop table child;
+ERROR:  relation "child" does not exist
 drop table parent;
 -- check error cases for inheritance column merging
 create table parent (a float8, b numeric(10,4), c text collate "C");
+ERROR:  at or near ")": syntax error: invalid locale C: language: tag is not well-formed
+DETAIL:  source SQL:
+create table parent (a float8, b numeric(10,4), c text collate "C")
+                                                                  ^
 create table child (a float4) inherits (parent); -- fail
-NOTICE:  merging column "a" with inherited definition
-ERROR:  column "a" has a type conflict
-DETAIL:  double precision versus real
+ERROR:  at or near "(": syntax error: unimplemented: this syntax
+DETAIL:  source SQL:
+create table child (a float4) inherits (parent)
+                                       ^
+HINT:  You have attempted to use a feature that is not yet implemented.
+See: https://go.crdb.dev/issue-v/22456/_version_
 create table child (b decimal(10,7)) inherits (parent); -- fail
-NOTICE:  moving and merging column "b" with inherited definition
-DETAIL:  User-specified column moved to the position of the inherited column.
-ERROR:  column "b" has a type conflict
-DETAIL:  numeric(10,4) versus numeric(10,7)
+ERROR:  at or near "(": syntax error: unimplemented: this syntax
+DETAIL:  source SQL:
+create table child (b decimal(10,7)) inherits (parent)
+                                              ^
+HINT:  You have attempted to use a feature that is not yet implemented.
+See: https://go.crdb.dev/issue-v/22456/_version_
 create table child (c text collate "POSIX") inherits (parent); -- fail
-NOTICE:  moving and merging column "c" with inherited definition
-DETAIL:  User-specified column moved to the position of the inherited column.
-ERROR:  column "c" has a collation conflict
-DETAIL:  "C" versus "POSIX"
+ERROR:  at or near ")": syntax error: invalid locale POSIX: language: tag is not well-formed
+DETAIL:  source SQL:
+create table child (c text collate "POSIX") inherits (parent)
+                                          ^
 create table child (a double precision, b decimal(10,4)) inherits (parent);
-NOTICE:  merging column "a" with inherited definition
-NOTICE:  merging column "b" with inherited definition
+ERROR:  at or near "(": syntax error: unimplemented: this syntax
+DETAIL:  source SQL:
+create table child (a double precision, b decimal(10,4)) inherits (parent)
+                                                                  ^
+HINT:  You have attempted to use a feature that is not yet implemented.
+See: https://go.crdb.dev/issue-v/22456/_version_
 drop table child;
+ERROR:  relation "child" does not exist
 drop table parent;
+ERROR:  relation "parent" does not exist
 -- test copy in/out
 create table attest (a int4, b int4, c int4);
 insert into attest values (1,2,3);
@@ -1611,12 +1910,11 @@
 copy attest to stdout;
 2	3
 copy attest(a) to stdout;
-ERROR:  column "a" of relation "attest" does not exist
+ERROR:  COPY attest (a) TO STDOUT: column "a" does not exist
 copy attest("........pg.dropped.1........") to stdout;
-ERROR:  column "........pg.dropped.1........" of relation "attest" does not exist
+ERROR:  COPY attest ("........pg.dropped.1........") TO STDOUT: column "........pg.dropped.1........" does not exist
 copy attest from stdin;
-ERROR:  extra data after last expected column
-CONTEXT:  COPY attest, line 1: "10	11	12"
+ERROR:  expected 2 values, got 3
 select * from attest;
  b | c 
 ---+---
@@ -1632,9 +1930,9 @@
 (2 rows)
 
 copy attest(a) from stdin;
-ERROR:  column "a" of relation "attest" does not exist
+ERROR:  column "a" does not exist
 copy attest("........pg.dropped.1........") from stdin;
-ERROR:  column "........pg.dropped.1........" of relation "attest" does not exist
+ERROR:  column "........pg.dropped.1........" does not exist
 copy attest(b,c) from stdin;
 select * from attest;
  b  | c  
@@ -1648,124 +1946,162 @@
 -- test inheritance
 create table dropColumn (a int, b int, e int);
 create table dropColumnChild (c int) inherits (dropColumn);
+ERROR:  at or near "(": syntax error: unimplemented: this syntax
+DETAIL:  source SQL:
+create table dropColumnChild (c int) inherits (dropColumn)
+                                              ^
+HINT:  You have attempted to use a feature that is not yet implemented.
+See: https://go.crdb.dev/issue-v/22456/_version_
 create table dropColumnAnother (d int) inherits (dropColumnChild);
+ERROR:  at or near "(": syntax error: unimplemented: this syntax
+DETAIL:  source SQL:
+create table dropColumnAnother (d int) inherits (dropColumnChild)
+                                                ^
+HINT:  You have attempted to use a feature that is not yet implemented.
+See: https://go.crdb.dev/issue-v/22456/_version_
 -- these two should fail
 alter table dropColumnchild drop column a;
-ERROR:  cannot drop inherited column "a"
+ERROR:  relation "dropcolumnchild" does not exist
 alter table only dropColumnChild drop column b;
-ERROR:  cannot drop inherited column "b"
+ERROR:  relation "dropcolumnchild" does not exist
 -- these three should work
 alter table only dropColumn drop column e;
 alter table dropColumnChild drop column c;
+ERROR:  relation "dropcolumnchild" does not exist
 alter table dropColumn drop column a;
 create table renameColumn (a int);
 create table renameColumnChild (b int) inherits (renameColumn);
+ERROR:  at or near "(": syntax error: unimplemented: this syntax
+DETAIL:  source SQL:
+create table renameColumnChild (b int) inherits (renameColumn)
+                                                ^
+HINT:  You have attempted to use a feature that is not yet implemented.
+See: https://go.crdb.dev/issue-v/22456/_version_
 create table renameColumnAnother (c int) inherits (renameColumnChild);
+ERROR:  at or near "(": syntax error: unimplemented: this syntax
+DETAIL:  source SQL:
+create table renameColumnAnother (c int) inherits (renameColumnChild)
+                                                  ^
+HINT:  You have attempted to use a feature that is not yet implemented.
+See: https://go.crdb.dev/issue-v/22456/_version_
 -- these three should fail
 alter table renameColumnChild rename column a to d;
-ERROR:  cannot rename inherited column "a"
+ERROR:  relation "renamecolumnchild" does not exist
 alter table only renameColumnChild rename column a to d;
-ERROR:  inherited column "a" must be renamed in child tables too
+ERROR:  relation "renamecolumnchild" does not exist
 alter table only renameColumn rename column a to d;
-ERROR:  inherited column "a" must be renamed in child tables too
 -- these should work
 alter table renameColumn rename column a to d;
+ERROR:  column "a" does not exist
 alter table renameColumnChild rename column b to a;
+ERROR:  relation "renamecolumnchild" does not exist
 -- these should work
 alter table if exists doesnt_exist_tab rename column a to d;
-NOTICE:  relation "doesnt_exist_tab" does not exist, skipping
 alter table if exists doesnt_exist_tab rename column b to a;
-NOTICE:  relation "doesnt_exist_tab" does not exist, skipping
 -- this should work
 alter table renameColumn add column w int;
 -- this should fail
 alter table only renameColumn add column x int;
-ERROR:  column must be added to child tables too
 -- Test corner cases in dropping of inherited columns
 create table p1 (f1 int, f2 int);
 create table c1 (f1 int not null) inherits(p1);
-NOTICE:  merging column "f1" with inherited definition
+ERROR:  at or near "(": syntax error: unimplemented: this syntax
+DETAIL:  source SQL:
+create table c1 (f1 int not null) inherits(p1)
+                                          ^
+HINT:  You have attempted to use a feature that is not yet implemented.
+See: https://go.crdb.dev/issue-v/22456/_version_
 -- should be rejected since c1.f1 is inherited
 alter table c1 drop column f1;
-ERROR:  cannot drop inherited column "f1"
+ERROR:  relation "c1" does not exist
 -- should work
 alter table p1 drop column f1;
 -- c1.f1 is still there, but no longer inherited
 select f1 from c1;
- f1 
-----
-(0 rows)
-
+ERROR:  relation "c1" does not exist
 alter table c1 drop column f1;
+ERROR:  relation "c1" does not exist
 select f1 from c1;
-ERROR:  column "f1" does not exist
-LINE 1: select f1 from c1;
-               ^
-HINT:  Perhaps you meant to reference the column "c1.f2".
+ERROR:  relation "c1" does not exist
 drop table p1 cascade;
-NOTICE:  drop cascades to table c1
 create table p1 (f1 int, f2 int);
 create table c1 () inherits(p1);
+ERROR:  at or near "(": syntax error: unimplemented: this syntax
+DETAIL:  source SQL:
+create table c1 () inherits(p1)
+                           ^
+HINT:  You have attempted to use a feature that is not yet implemented.
+See: https://go.crdb.dev/issue-v/22456/_version_
 -- should be rejected since c1.f1 is inherited
 alter table c1 drop column f1;
-ERROR:  cannot drop inherited column "f1"
+ERROR:  relation "c1" does not exist
 alter table p1 drop column f1;
 -- c1.f1 is dropped now, since there is no local definition for it
 select f1 from c1;
-ERROR:  column "f1" does not exist
-LINE 1: select f1 from c1;
-               ^
-HINT:  Perhaps you meant to reference the column "c1.f2".
+ERROR:  relation "c1" does not exist
 drop table p1 cascade;
-NOTICE:  drop cascades to table c1
 create table p1 (f1 int, f2 int);
 create table c1 () inherits(p1);
+ERROR:  at or near "(": syntax error: unimplemented: this syntax
+DETAIL:  source SQL:
+create table c1 () inherits(p1)
+                           ^
+HINT:  You have attempted to use a feature that is not yet implemented.
+See: https://go.crdb.dev/issue-v/22456/_version_
 -- should be rejected since c1.f1 is inherited
 alter table c1 drop column f1;
-ERROR:  cannot drop inherited column "f1"
+ERROR:  relation "c1" does not exist
 alter table only p1 drop column f1;
 -- c1.f1 is NOT dropped, but must now be considered non-inherited
 alter table c1 drop column f1;
+ERROR:  relation "c1" does not exist
 drop table p1 cascade;
-NOTICE:  drop cascades to table c1
 create table p1 (f1 int, f2 int);
 create table c1 (f1 int not null) inherits(p1);
-NOTICE:  merging column "f1" with inherited definition
+ERROR:  at or near "(": syntax error: unimplemented: this syntax
+DETAIL:  source SQL:
+create table c1 (f1 int not null) inherits(p1)
+                                          ^
+HINT:  You have attempted to use a feature that is not yet implemented.
+See: https://go.crdb.dev/issue-v/22456/_version_
 -- should be rejected since c1.f1 is inherited
 alter table c1 drop column f1;
-ERROR:  cannot drop inherited column "f1"
+ERROR:  relation "c1" does not exist
 alter table only p1 drop column f1;
 -- c1.f1 is still there, but no longer inherited
 alter table c1 drop column f1;
+ERROR:  relation "c1" does not exist
 drop table p1 cascade;
-NOTICE:  drop cascades to table c1
 create table p1(id int, name text);
 create table p2(id2 int, name text, height int);
 create table c1(age int) inherits(p1,p2);
-NOTICE:  merging multiple inherited definitions of column "name"
+ERROR:  at or near "(": syntax error: unimplemented: this syntax
+DETAIL:  source SQL:
+create table c1(age int) inherits(p1,p2)
+                                 ^
+HINT:  You have attempted to use a feature that is not yet implemented.
+See: https://go.crdb.dev/issue-v/22456/_version_
 create table gc1() inherits (c1);
+ERROR:  at or near "(": syntax error: unimplemented: this syntax
+DETAIL:  source SQL:
+create table gc1() inherits (c1)
+                            ^
+HINT:  You have attempted to use a feature that is not yet implemented.
+See: https://go.crdb.dev/issue-v/22456/_version_
 select relname, attname, attinhcount, attislocal
 from pg_class join pg_attribute on (pg_class.oid = pg_attribute.attrelid)
 where relname in ('p1','p2','c1','gc1') and attnum > 0 and not attisdropped
 order by relname, attnum;
  relname | attname | attinhcount | attislocal 
 ---------+---------+-------------+------------
- c1      | id      |           1 | f
- c1      | name    |           2 | f
- c1      | id2     |           1 | f
- c1      | height  |           1 | f
- c1      | age     |           0 | t
- gc1     | id      |           1 | f
- gc1     | name    |           1 | f
- gc1     | id2     |           1 | f
- gc1     | height  |           1 | f
- gc1     | age     |           1 | f
  p1      | id      |           0 | t
  p1      | name    |           0 | t
+ p1      | rowid   |           0 | t
  p2      | id2     |           0 | t
  p2      | name    |           0 | t
  p2      | height  |           0 | t
-(15 rows)
+ p2      | rowid   |           0 | t
+(7 rows)
 
 -- should work
 alter table only p1 drop column name;
@@ -1773,188 +2109,175 @@
 alter table p2 drop column name;
 -- should be rejected since its inherited
 alter table gc1 drop column name;
-ERROR:  cannot drop inherited column "name"
+ERROR:  relation "gc1" does not exist
 -- should work, and drop gc1.name along
 alter table c1 drop column name;
+ERROR:  relation "c1" does not exist
 -- should fail: column does not exist
 alter table gc1 drop column name;
-ERROR:  column "name" of relation "gc1" does not exist
+ERROR:  relation "gc1" does not exist
 -- should work and drop the attribute in all tables
 alter table p2 drop column height;
 -- IF EXISTS test
 create table dropColumnExists ();
 alter table dropColumnExists drop column non_existing; --fail
-ERROR:  column "non_existing" of relation "dropcolumnexists" does not exist
+ERROR:  column "non_existing" does not exist
 alter table dropColumnExists drop column if exists non_existing; --succeed
-NOTICE:  column "non_existing" of relation "dropcolumnexists" does not exist, skipping
 select relname, attname, attinhcount, attislocal
 from pg_class join pg_attribute on (pg_class.oid = pg_attribute.attrelid)
 where relname in ('p1','p2','c1','gc1') and attnum > 0 and not attisdropped
 order by relname, attnum;
  relname | attname | attinhcount | attislocal 
 ---------+---------+-------------+------------
- c1      | id      |           1 | f
- c1      | id2     |           1 | f
- c1      | age     |           0 | t
- gc1     | id      |           1 | f
- gc1     | id2     |           1 | f
- gc1     | age     |           1 | f
  p1      | id      |           0 | t
+ p1      | rowid   |           0 | t
  p2      | id2     |           0 | t
-(8 rows)
+ p2      | rowid   |           0 | t
+(4 rows)
 
 drop table p1, p2 cascade;
-NOTICE:  drop cascades to 2 other objects
-DETAIL:  drop cascades to table c1
-drop cascades to table gc1
 -- test attinhcount tracking with merged columns
 create table depth0();
 create table depth1(c text) inherits (depth0);
+ERROR:  at or near "(": syntax error: unimplemented: this syntax
+DETAIL:  source SQL:
+create table depth1(c text) inherits (depth0)
+                                     ^
+HINT:  You have attempted to use a feature that is not yet implemented.
+See: https://go.crdb.dev/issue-v/22456/_version_
 create table depth2() inherits (depth1);
+ERROR:  at or near "(": syntax error: unimplemented: this syntax
+DETAIL:  source SQL:
+create table depth2() inherits (depth1)
+                               ^
+HINT:  You have attempted to use a feature that is not yet implemented.
+See: https://go.crdb.dev/issue-v/22456/_version_
 alter table depth0 add c text;
-NOTICE:  merging definition of column "c" for child "depth1"
 select attrelid::regclass, attname, attinhcount, attislocal
 from pg_attribute
 where attnum > 0 and attrelid::regclass in ('depth0', 'depth1', 'depth2')
 order by attrelid::regclass::text, attnum;
- attrelid | attname | attinhcount | attislocal 
-----------+---------+-------------+------------
- depth0   | c       |           0 | t
- depth1   | c       |           1 | t
- depth2   | c       |           1 | f
-(3 rows)
-
+ERROR:  unsupported comparison operator: attrelid::REGCLASS IN ('depth0', 'depth1', 'depth2'): expected 'depth0' to be of type regclass, found type string
 -- test renumbering of child-table columns in inherited operations
 create table p1 (f1 int);
 create table c1 (f2 text, f3 int) inherits (p1);
+ERROR:  at or near "(": syntax error: unimplemented: this syntax
+DETAIL:  source SQL:
+create table c1 (f2 text, f3 int) inherits (p1)
+                                           ^
+HINT:  You have attempted to use a feature that is not yet implemented.
+See: https://go.crdb.dev/issue-v/22456/_version_
 alter table p1 add column a1 int check (a1 > 0);
 alter table p1 add column f2 text;
-NOTICE:  merging definition of column "f2" for child "c1"
 insert into p1 values (1,2,'abc');
 insert into c1 values(11,'xyz',33,0); -- should fail
-ERROR:  new row for relation "c1" violates check constraint "p1_a1_check"
-DETAIL:  Failing row contains (11, xyz, 33, 0).
+ERROR:  relation "c1" does not exist
 insert into c1 values(11,'xyz',33,22);
+ERROR:  relation "c1" does not exist
 select * from p1;
  f1 | a1 | f2  
 ----+----+-----
   1 |  2 | abc
- 11 | 22 | xyz
-(2 rows)
+(1 row)
 
 update p1 set a1 = a1 + 1, f2 = upper(f2);
 select * from p1;
  f1 | a1 | f2  
 ----+----+-----
   1 |  3 | ABC
- 11 | 23 | XYZ
-(2 rows)
+(1 row)
 
 drop table p1 cascade;
-NOTICE:  drop cascades to table c1
 -- test that operations with a dropped column do not try to reference
 -- its datatype
 create domain mytype as text;
+ERROR:  at or near "as": syntax error: unimplemented: this syntax
+DETAIL:  source SQL:
+create domain mytype as text
+                     ^
+HINT:  You have attempted to use a feature that is not yet implemented.
+See: https://go.crdb.dev/issue-v/27796/_version_
 create temp table foo (f1 text, f2 mytype, f3 text);
+ERROR:  type "mytype" does not exist
 insert into foo values('bb','cc','dd');
+ERROR:  relation "foo" does not exist
 select * from foo;
- f1 | f2 | f3 
-----+----+----
- bb | cc | dd
-(1 row)
-
+ERROR:  relation "foo" does not exist
 drop domain mytype cascade;
-NOTICE:  drop cascades to column f2 of table foo
+ERROR:  at or near "mytype": syntax error: unimplemented: this syntax
+DETAIL:  source SQL:
+drop domain mytype cascade
+            ^
+HINT:  You have attempted to use a feature that is not yet implemented.
+See: https://go.crdb.dev/issue-v/27796/_version_
 select * from foo;
- f1 | f3 
-----+----
- bb | dd
-(1 row)
-
+ERROR:  relation "foo" does not exist
 insert into foo values('qq','rr');
+ERROR:  relation "foo" does not exist
 select * from foo;
- f1 | f3 
-----+----
- bb | dd
- qq | rr
-(2 rows)
-
+ERROR:  relation "foo" does not exist
 update foo set f3 = 'zz';
+ERROR:  relation "foo" does not exist
 select * from foo;
- f1 | f3 
-----+----
- bb | zz
- qq | zz
-(2 rows)
-
+ERROR:  relation "foo" does not exist
 select f3,max(f1) from foo group by f3;
- f3 | max 
-----+-----
- zz | qq
-(1 row)
-
+ERROR:  relation "foo" does not exist
 -- Simple tests for alter table column type
 alter table foo alter f1 TYPE integer; -- fails
-ERROR:  column "f1" cannot be cast automatically to type integer
-HINT:  You might need to specify "USING f1::integer".
+ERROR:  relation "foo" does not exist
 alter table foo alter f1 TYPE varchar(10);
+ERROR:  relation "foo" does not exist
 create table anothertab (atcol1 serial8, atcol2 boolean,
 	constraint anothertab_chk check (atcol1 <= 3));
 insert into anothertab (atcol1, atcol2) values (default, true);
+ERROR:  failed to satisfy CHECK constraint (atcol1 <= 3:::INT8)
 insert into anothertab (atcol1, atcol2) values (default, false);
+ERROR:  failed to satisfy CHECK constraint (atcol1 <= 3:::INT8)
 select * from anothertab;
  atcol1 | atcol2 
 --------+--------
-      1 | t
-      2 | f
-(2 rows)
+(0 rows)
 
 alter table anothertab alter column atcol1 type boolean; -- fails
-ERROR:  column "atcol1" cannot be cast automatically to type boolean
-HINT:  You might need to specify "USING atcol1::boolean".
+ERROR:  column "atcol1" cannot be cast automatically to type BOOL
+HINT:  You might need to specify "USING atcol1::BOOL".
 alter table anothertab alter column atcol1 type boolean using atcol1::int; -- fails
-ERROR:  result of USING clause for column "atcol1" cannot be cast automatically to type boolean
-HINT:  You might need to add an explicit cast.
+ERROR:  default for column "atcol1" cannot be cast automatically to type BOOL
 alter table anothertab alter column atcol1 type integer;
 select * from anothertab;
  atcol1 | atcol2 
 --------+--------
-      1 | t
-      2 | f
-(2 rows)
+(0 rows)
 
 insert into anothertab (atcol1, atcol2) values (45, null); -- fails
-ERROR:  new row for relation "anothertab" violates check constraint "anothertab_chk"
-DETAIL:  Failing row contains (45, null).
+ERROR:  failed to satisfy CHECK constraint (atcol1 <= 3:::INT8)
 insert into anothertab (atcol1, atcol2) values (default, null);
+ERROR:  failed to satisfy CHECK constraint (atcol1 <= 3:::INT8)
 select * from anothertab;
  atcol1 | atcol2 
 --------+--------
-      1 | t
-      2 | f
-      3 | 
-(3 rows)
+(0 rows)
 
 alter table anothertab alter column atcol2 type text
       using case when atcol2 is true then 'IT WAS TRUE'
                  when atcol2 is false then 'IT WAS FALSE'
                  else 'IT WAS NULL!' end;
 select * from anothertab;
- atcol1 |    atcol2    
---------+--------------
-      1 | IT WAS TRUE
-      2 | IT WAS FALSE
-      3 | IT WAS NULL!
-(3 rows)
+ atcol1 | atcol2 
+--------+--------
+(0 rows)
 
 alter table anothertab alter column atcol1 type boolean
         using case when atcol1 % 2 = 0 then true else false end; -- fails
-ERROR:  default for column "atcol1" cannot be cast automatically to type boolean
+ERROR:  default for column "atcol1" cannot be cast automatically to type BOOL
 alter table anothertab alter column atcol1 drop default;
 alter table anothertab alter column atcol1 type boolean
         using case when atcol1 % 2 = 0 then true else false end; -- fails
-ERROR:  operator does not exist: boolean <= integer
-HINT:  No operator matches the given name and argument types. You might need to add explicit type casts.
+ERROR:  unimplemented: ALTER COLUMN TYPE requiring a rewrite of on-disk data is not supported for columns that have constraints
+HINT:  You have attempted to use a feature that is not yet implemented.
+See: https://go.crdb.dev/issue-v/48288/_version_
+--
+Consider temporarily dropping the constraint.
 alter table anothertab drop constraint anothertab_chk;
 alter table anothertab drop constraint anothertab_chk; -- fails
 ERROR:  constraint "anothertab_chk" of relation "anothertab" does not exist
@@ -1963,12 +2286,9 @@
 alter table anothertab alter column atcol1 type boolean
         using case when atcol1 % 2 = 0 then true else false end;
 select * from anothertab;
- atcol1 |    atcol2    
---------+--------------
- f      | IT WAS TRUE
- t      | IT WAS FALSE
- f      | IT WAS NULL!
-(3 rows)
+ atcol1 | atcol2 
+--------+--------
+(0 rows)
 
 drop table anothertab;
 -- Test index handling in alter table column type (cf. bugs #15835, #15865)
@@ -1976,33 +2296,45 @@
                         f3 int, f4 int, f5 int);
 alter table anothertab
   add exclude using btree (f3 with =);
+ERROR:  at or near "btree": syntax error: unimplemented: this syntax
+DETAIL:  source SQL:
+alter table anothertab
+  add exclude using btree (f3 with =)
+                    ^
+HINT:  You have attempted to use a feature that is not yet implemented.
+See: https://go.crdb.dev/issue-v/46657/_version_
 alter table anothertab
   add exclude using btree (f4 with =) where (f4 is not null);
+ERROR:  at or near "btree": syntax error: unimplemented: this syntax
+DETAIL:  source SQL:
+alter table anothertab
+  add exclude using btree (f4 with =) where (f4 is not null)
+                    ^
+HINT:  You have attempted to use a feature that is not yet implemented.
+See: https://go.crdb.dev/issue-v/46657/_version_
 alter table anothertab
   add exclude using btree (f4 with =) where (f5 > 0);
+ERROR:  at or near "btree": syntax error: unimplemented: this syntax
+DETAIL:  source SQL:
+alter table anothertab
+  add exclude using btree (f4 with =) where (f5 > 0)
+                    ^
+HINT:  You have attempted to use a feature that is not yet implemented.
+See: https://go.crdb.dev/issue-v/46657/_version_
 alter table anothertab
   add unique(f1,f4);
 create index on anothertab(f2,f3);
 create unique index on anothertab(f4);
 \d anothertab
-             Table "public.anothertab"
- Column |  Type   | Collation | Nullable | Default 
---------+---------+-----------+----------+---------
- f1     | integer |           | not null | 
- f2     | integer |           |          | 
- f3     | integer |           |          | 
- f4     | integer |           |          | 
- f5     | integer |           |          | 
-Indexes:
-    "anothertab_pkey" PRIMARY KEY, btree (f1)
-    "anothertab_f1_f4_key" UNIQUE CONSTRAINT, btree (f1, f4)
-    "anothertab_f2_f3_idx" btree (f2, f3)
-    "anothertab_f2_key" UNIQUE CONSTRAINT, btree (f2)
-    "anothertab_f3_excl" EXCLUDE USING btree (f3 WITH =)
-    "anothertab_f4_excl" EXCLUDE USING btree (f4 WITH =) WHERE (f4 IS NOT NULL)
-    "anothertab_f4_excl1" EXCLUDE USING btree (f4 WITH =) WHERE (f5 > 0)
-    "anothertab_f4_idx" UNIQUE, btree (f4)
-
+ERROR:  at or near ".": syntax error
+DETAIL:  source SQL:
+SELECT c.oid,
+  n.nspname,
+  c.relname
+FROM pg_catalog.pg_class c
+     LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace
+WHERE c.relname OPERATOR(pg_catalog.~) '^(anothertab)$' COLLATE pg_catalog.default
+                                                                          ^
 alter table anothertab alter column f1 type bigint;
 alter table anothertab
   alter column f2 type bigint,
@@ -2010,24 +2342,15 @@
   alter column f4 type bigint;
 alter table anothertab alter column f5 type bigint;
 \d anothertab
-            Table "public.anothertab"
- Column |  Type  | Collation | Nullable | Default 
---------+--------+-----------+----------+---------
- f1     | bigint |           | not null | 
- f2     | bigint |           |          | 
- f3     | bigint |           |          | 
- f4     | bigint |           |          | 
- f5     | bigint |           |          | 
-Indexes:
-    "anothertab_pkey" PRIMARY KEY, btree (f1)
-    "anothertab_f1_f4_key" UNIQUE CONSTRAINT, btree (f1, f4)
-    "anothertab_f2_f3_idx" btree (f2, f3)
-    "anothertab_f2_key" UNIQUE CONSTRAINT, btree (f2)
-    "anothertab_f3_excl" EXCLUDE USING btree (f3 WITH =)
-    "anothertab_f4_excl" EXCLUDE USING btree (f4 WITH =) WHERE (f4 IS NOT NULL)
-    "anothertab_f4_excl1" EXCLUDE USING btree (f4 WITH =) WHERE (f5 > 0)
-    "anothertab_f4_idx" UNIQUE, btree (f4)
-
+ERROR:  at or near ".": syntax error
+DETAIL:  source SQL:
+SELECT c.oid,
+  n.nspname,
+  c.relname
+FROM pg_catalog.pg_class c
+     LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace
+WHERE c.relname OPERATOR(pg_catalog.~) '^(anothertab)$' COLLATE pg_catalog.default
+                                                                          ^
 drop table anothertab;
 -- test that USING expressions are parsed before column alter type / drop steps
 create table another (f1 int, f2 text, f3 text);
@@ -2046,12 +2369,15 @@
   alter f1 type text using f2 || ' and ' || f3 || ' more',
   alter f2 type bigint using f1 * 10,
   drop column f3;
+ERROR:  unimplemented: ALTER COLUMN TYPE operations that require rewriting on-disk data cannot be combined with other ALTER TABLE commands
+HINT:  You have attempted to use a feature that is not yet implemented.
+See: https://go.crdb.dev/issue-v/49351/_version_
 select * from another;
-         f1         | f2 
---------------------+----
- one and uno more   | 10
- two and due more   | 20
- three and tre more | 30
+ f1 |  f2   | f3  
+----+-------+-----
+  1 | one   | uno
+  2 | two   | due
+  3 | three | tre
 (3 rows)
 
 drop table another;
@@ -2059,107 +2385,166 @@
 -- rewriting the index.
 begin;
 create table skip_wal_skip_rewrite_index (c varchar(10) primary key);
+NOTICE:  auto-committing transaction before processing DDL due to autocommit_before_ddl setting
 alter table skip_wal_skip_rewrite_index alter c type varchar(20);
 commit;
+WARNING:  there is no transaction in progress
 -- We disallow changing table's row type if it's used for storage
 create table at_tab1 (a int, b text);
 create table at_tab2 (x int, y at_tab1);
+ERROR:  unimplemented: cannot use table record type as table column
+HINT:  You have attempted to use a feature that is not yet implemented.
+See: https://go.crdb.dev/issue-v/70099/_version_
 alter table at_tab1 alter column b type varchar; -- fails
-ERROR:  cannot alter table "at_tab1" because column "at_tab2.y" uses its row type
 drop table at_tab2;
+ERROR:  relation "at_tab2" does not exist
 -- Use of row type in an expression is defended differently
 create table at_tab2 (x int, y text, check((x,y)::at_tab1 = (1,'42')::at_tab1));
+ERROR:  cannot modify table record type "at_tab1": table implicit type not mutable
 alter table at_tab1 alter column b type varchar; -- allowed, but ...
 insert into at_tab2 values(1,'42'); -- ... this will fail
-ERROR:  ROW() column has type text instead of type character varying
+ERROR:  relation "at_tab2" does not exist
 drop table at_tab1, at_tab2;
+ERROR:  relation "at_tab2" does not exist
 -- Check it for a partitioned table, too
 create table at_tab1 (a int, b text) partition by list(a);
+ERROR:  at or near "EOF": syntax error
+DETAIL:  source SQL:
+create table at_tab1 (a int, b text) partition by list(a)
+                                                         ^
+HINT:  try \h CREATE TABLE
 create table at_tab2 (x int, y at_tab1);
+ERROR:  unimplemented: cannot use table record type as table column
+HINT:  You have attempted to use a feature that is not yet implemented.
+See: https://go.crdb.dev/issue-v/70099/_version_
 alter table at_tab1 alter column b type varchar; -- fails
-ERROR:  cannot alter table "at_tab1" because column "at_tab2.y" uses its row type
 drop table at_tab1, at_tab2;
+ERROR:  relation "at_tab2" does not exist
 -- Alter column type that's part of a partitioned index
 create table at_partitioned (a int, b text) partition by range (a);
+ERROR:  at or near "EOF": syntax error
+DETAIL:  source SQL:
+create table at_partitioned (a int, b text) partition by range (a)
+                                                                  ^
+HINT:  try \h CREATE TABLE
 create table at_part_1 partition of at_partitioned for values from (0) to (1000);
+ERROR:  at or near "partition": syntax error
+DETAIL:  source SQL:
+create table at_part_1 partition of at_partitioned for values from (0) to (1000)
+                       ^
+HINT:  try \h CREATE TABLE
 insert into at_partitioned values (512, '0.123');
+ERROR:  relation "at_partitioned" does not exist
 create table at_part_2 (b text, a int);
 insert into at_part_2 values ('1.234', 1024);
 create index on at_partitioned (b);
+ERROR:  relation "at_partitioned" does not exist
 create index on at_partitioned (a);
+ERROR:  relation "at_partitioned" does not exist
 \d at_part_1
-             Table "public.at_part_1"
- Column |  Type   | Collation | Nullable | Default 
---------+---------+-----------+----------+---------
- a      | integer |           |          | 
- b      | text    |           |          | 
-Partition of: at_partitioned FOR VALUES FROM (0) TO (1000)
-Indexes:
-    "at_part_1_a_idx" btree (a)
-    "at_part_1_b_idx" btree (b)
-
+ERROR:  at or near ".": syntax error
+DETAIL:  source SQL:
+SELECT c.oid,
+  n.nspname,
+  c.relname
+FROM pg_catalog.pg_class c
+     LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace
+WHERE c.relname OPERATOR(pg_catalog.~) '^(at_part_1)$' COLLATE pg_catalog.default
+                                                                         ^
 \d at_part_2
-             Table "public.at_part_2"
- Column |  Type   | Collation | Nullable | Default 
---------+---------+-----------+----------+---------
- b      | text    |           |          | 
- a      | integer |           |          | 
-
+ERROR:  at or near ".": syntax error
+DETAIL:  source SQL:
+SELECT c.oid,
+  n.nspname,
+  c.relname
+FROM pg_catalog.pg_class c
+     LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace
+WHERE c.relname OPERATOR(pg_catalog.~) '^(at_part_2)$' COLLATE pg_catalog.default
+                                                                         ^
 alter table at_partitioned attach partition at_part_2 for values from (1000) to (2000);
+ERROR:  at or near "attach": syntax error
+DETAIL:  source SQL:
+alter table at_partitioned attach partition at_part_2 for values from (1000) to (2000)
+                           ^
+HINT:  try \h ALTER TABLE
 \d at_part_2
-             Table "public.at_part_2"
- Column |  Type   | Collation | Nullable | Default 
---------+---------+-----------+----------+---------
- b      | text    |           |          | 
- a      | integer |           |          | 
-Partition of: at_partitioned FOR VALUES FROM (1000) TO (2000)
-Indexes:
-    "at_part_2_a_idx" btree (a)
-    "at_part_2_b_idx" btree (b)
-
+ERROR:  at or near ".": syntax error
+DETAIL:  source SQL:
+SELECT c.oid,
+  n.nspname,
+  c.relname
+FROM pg_catalog.pg_class c
+     LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace
+WHERE c.relname OPERATOR(pg_catalog.~) '^(at_part_2)$' COLLATE pg_catalog.default
+                                                                         ^
 alter table at_partitioned alter column b type numeric using b::numeric;
+ERROR:  relation "at_partitioned" does not exist
 \d at_part_1
-             Table "public.at_part_1"
- Column |  Type   | Collation | Nullable | Default 
---------+---------+-----------+----------+---------
- a      | integer |           |          | 
- b      | numeric |           |          | 
-Partition of: at_partitioned FOR VALUES FROM (0) TO (1000)
-Indexes:
-    "at_part_1_a_idx" btree (a)
-    "at_part_1_b_idx" btree (b)
-
+ERROR:  at or near ".": syntax error
+DETAIL:  source SQL:
+SELECT c.oid,
+  n.nspname,
+  c.relname
+FROM pg_catalog.pg_class c
+     LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace
+WHERE c.relname OPERATOR(pg_catalog.~) '^(at_part_1)$' COLLATE pg_catalog.default
+                                                                         ^
 \d at_part_2
-             Table "public.at_part_2"
- Column |  Type   | Collation | Nullable | Default 
---------+---------+-----------+----------+---------
- b      | numeric |           |          | 
- a      | integer |           |          | 
-Partition of: at_partitioned FOR VALUES FROM (1000) TO (2000)
-Indexes:
-    "at_part_2_a_idx" btree (a)
-    "at_part_2_b_idx" btree (b)
-
+ERROR:  at or near ".": syntax error
+DETAIL:  source SQL:
+SELECT c.oid,
+  n.nspname,
+  c.relname
+FROM pg_catalog.pg_class c
+     LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace
+WHERE c.relname OPERATOR(pg_catalog.~) '^(at_part_2)$' COLLATE pg_catalog.default
+                                                                         ^
 drop table at_partitioned;
+ERROR:  relation "at_partitioned" does not exist
 -- Alter column type when no table rewrite is required
 -- Also check that comments are preserved
 create table at_partitioned(id int, name varchar(64), unique (id, name))
   partition by hash(id);
+ERROR:  at or near "hash": syntax error
+DETAIL:  source SQL:
+create table at_partitioned(id int, name varchar(64), unique (id, name))
+  partition by hash(id)
+               ^
+HINT:  try \h CREATE TABLE
 comment on constraint at_partitioned_id_name_key on at_partitioned is 'parent constraint';
+ERROR:  relation "at_partitioned" does not exist
 comment on index at_partitioned_id_name_key is 'parent index';
+ERROR:  index "at_partitioned_id_name_key" does not exist
 create table at_partitioned_0 partition of at_partitioned
   for values with (modulus 2, remainder 0);
+ERROR:  at or near "partition": syntax error
+DETAIL:  source SQL:
+create table at_partitioned_0 partition of at_partitioned
+                              ^
+HINT:  try \h CREATE TABLE
 comment on constraint at_partitioned_0_id_name_key on at_partitioned_0 is 'child 0 constraint';
+ERROR:  relation "at_partitioned_0" does not exist
 comment on index at_partitioned_0_id_name_key is 'child 0 index';
+ERROR:  index "at_partitioned_0_id_name_key" does not exist
 create table at_partitioned_1 partition of at_partitioned
   for values with (modulus 2, remainder 1);
+ERROR:  at or near "partition": syntax error
+DETAIL:  source SQL:
+create table at_partitioned_1 partition of at_partitioned
+                              ^
+HINT:  try \h CREATE TABLE
 comment on constraint at_partitioned_1_id_name_key on at_partitioned_1 is 'child 1 constraint';
+ERROR:  relation "at_partitioned_1" does not exist
 comment on index at_partitioned_1_id_name_key is 'child 1 index';
+ERROR:  index "at_partitioned_1_id_name_key" does not exist
 insert into at_partitioned values(1, 'foo');
+ERROR:  relation "at_partitioned" does not exist
 insert into at_partitioned values(3, 'bar');
+ERROR:  relation "at_partitioned" does not exist
 create temp table old_oids as
   select relname, oid as oldoid, relfilenode as oldfilenode
   from pg_class where relname like 'at_partitioned%';
+NOTICE:  CREATE TABLE ... AS does not copy over indexes, default expressions, or constraints; the new table has a hidden rowid primary key column
 select relname,
   c.oid = oldoid as orig_oid,
   case relfilenode
@@ -2172,27 +2557,19 @@
   from pg_class c left join old_oids using (relname)
   where relname like 'at_partitioned%'
   order by relname;
-           relname            | orig_oid | storage |     desc      
-------------------------------+----------+---------+---------------
- at_partitioned               | t        | none    | 
- at_partitioned_0             | t        | own     | 
- at_partitioned_0_id_name_key | t        | own     | child 0 index
- at_partitioned_1             | t        | own     | 
- at_partitioned_1_id_name_key | t        | own     | child 1 index
- at_partitioned_id_name_key   | t        | none    | parent index
-(6 rows)
+ relname | orig_oid | storage | desc 
+---------+----------+---------+------
+(0 rows)
 
 select conname, obj_description(oid, 'pg_constraint') as desc
   from pg_constraint where conname like 'at_partitioned%'
   order by conname;
-           conname            |        desc        
-------------------------------+--------------------
- at_partitioned_0_id_name_key | child 0 constraint
- at_partitioned_1_id_name_key | child 1 constraint
- at_partitioned_id_name_key   | parent constraint
-(3 rows)
+ conname | desc 
+---------+------
+(0 rows)
 
 alter table at_partitioned alter column name type varchar(127);
+ERROR:  relation "at_partitioned" does not exist
 -- Note: these tests currently show the wrong behavior for comments :-(
 select relname,
   c.oid = oldoid as orig_oid,
@@ -2206,280 +2583,331 @@
   from pg_class c left join old_oids using (relname)
   where relname like 'at_partitioned%'
   order by relname;
-           relname            | orig_oid | storage |     desc     
-------------------------------+----------+---------+--------------
- at_partitioned               | t        | none    | 
- at_partitioned_0             | t        | own     | 
- at_partitioned_0_id_name_key | f        | own     | parent index
- at_partitioned_1             | t        | own     | 
- at_partitioned_1_id_name_key | f        | own     | parent index
- at_partitioned_id_name_key   | f        | none    | parent index
-(6 rows)
+ relname | orig_oid | storage | desc 
+---------+----------+---------+------
+(0 rows)
 
 select conname, obj_description(oid, 'pg_constraint') as desc
   from pg_constraint where conname like 'at_partitioned%'
   order by conname;
-           conname            |       desc        
-------------------------------+-------------------
- at_partitioned_0_id_name_key | 
- at_partitioned_1_id_name_key | 
- at_partitioned_id_name_key   | parent constraint
-(3 rows)
+ conname | desc 
+---------+------
+(0 rows)
 
 -- Don't remove this DROP, it exposes bug #15672
 drop table at_partitioned;
+ERROR:  relation "at_partitioned" does not exist
 -- disallow recursive containment of row types
 create temp table recur1 (f1 int);
 alter table recur1 add column f2 recur1; -- fails
-ERROR:  composite type recur1 cannot be made a member of itself
+ERROR:  unimplemented: cannot use table record type as table column
+HINT:  You have attempted to use a feature that is not yet implemented.
+See: https://go.crdb.dev/issue-v/70099/_version_
 alter table recur1 add column f2 recur1[]; -- fails
-ERROR:  composite type recur1 cannot be made a member of itself
+ERROR:  unimplemented: cannot use table record type as table column
+HINT:  You have attempted to use a feature that is not yet implemented.
+See: https://go.crdb.dev/issue-v/70099/_version_
 create domain array_of_recur1 as recur1[];
+ERROR:  at or near "as": syntax error: unimplemented: this syntax
+DETAIL:  source SQL:
+create domain array_of_recur1 as recur1[]
+                              ^
+HINT:  You have attempted to use a feature that is not yet implemented.
+See: https://go.crdb.dev/issue-v/27796/_version_
 alter table recur1 add column f2 array_of_recur1; -- fails
-ERROR:  composite type recur1 cannot be made a member of itself
+ERROR:  type "array_of_recur1" does not exist
 create temp table recur2 (f1 int, f2 recur1);
+ERROR:  unimplemented: cannot use table record type as table column
+HINT:  You have attempted to use a feature that is not yet implemented.
+See: https://go.crdb.dev/issue-v/70099/_version_
 alter table recur1 add column f2 recur2; -- fails
-ERROR:  composite type recur1 cannot be made a member of itself
+ERROR:  type "recur2" does not exist
 alter table recur1 add column f2 int;
 alter table recur1 alter column f2 type recur2; -- fails
-ERROR:  composite type recur1 cannot be made a member of itself
+ERROR:  type "recur2" does not exist
 -- SET STORAGE may need to add a TOAST table
 create table test_storage (a text, c text storage plain);
+ERROR:  at or near "storage": syntax error
+DETAIL:  source SQL:
+create table test_storage (a text, c text storage plain)
+                                          ^
+HINT:  try \h CREATE TABLE
 select reltoastrelid <> 0 as has_toast_table
   from pg_class where oid = 'test_storage'::regclass;
- has_toast_table 
------------------
- t
-(1 row)
-
+ERROR:  relation "test_storage" does not exist
 alter table test_storage alter a set storage plain;
+ERROR:  at or near "storage": syntax error
+DETAIL:  source SQL:
+alter table test_storage alter a set storage plain
+                                     ^
+HINT:  try \h ALTER TABLE
 -- rewrite table to remove its TOAST table; need a non-constant column default
 alter table test_storage add b int default random()::int;
+ERROR:  relation "test_storage" does not exist
 select reltoastrelid <> 0 as has_toast_table
   from pg_class where oid = 'test_storage'::regclass;
- has_toast_table 
------------------
- f
-(1 row)
-
+ERROR:  relation "test_storage" does not exist
 alter table test_storage alter a set storage default; -- re-add TOAST table
+ERROR:  at or near "storage": syntax error
+DETAIL:  source SQL:
+alter table test_storage alter a set storage default
+                                     ^
+HINT:  try \h ALTER TABLE
 select reltoastrelid <> 0 as has_toast_table
   from pg_class where oid = 'test_storage'::regclass;
- has_toast_table 
------------------
- t
-(1 row)
-
+ERROR:  relation "test_storage" does not exist
 -- check STORAGE correctness
 create table test_storage_failed (a text, b int storage extended);
-ERROR:  column data type integer can only have storage PLAIN
+ERROR:  at or near "storage": syntax error
+DETAIL:  source SQL:
+create table test_storage_failed (a text, b int storage extended)
+                                                ^
+HINT:  try \h CREATE TABLE
 -- test that SET STORAGE propagates to index correctly
 create index test_storage_idx on test_storage (b, a);
+ERROR:  relation "test_storage" does not exist
 alter table test_storage alter column a set storage external;
+ERROR:  at or near "storage": syntax error
+DETAIL:  source SQL:
+alter table test_storage alter column a set storage external
+                                            ^
+HINT:  try \h ALTER TABLE
 \d+ test_storage
-                                     Table "public.test_storage"
- Column |  Type   | Collation | Nullable |      Default      | Storage  | Stats target | Description 
---------+---------+-----------+----------+-------------------+----------+--------------+-------------
- a      | text    |           |          |                   | external |              | 
- c      | text    |           |          |                   | plain    |              | 
- b      | integer |           |          | random()::integer | plain    |              | 
-Indexes:
-    "test_storage_idx" btree (b, a)
-
+ERROR:  at or near ".": syntax error
+DETAIL:  source SQL:
+SELECT c.oid,
+  n.nspname,
+  c.relname
+FROM pg_catalog.pg_class c
+     LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace
+WHERE c.relname OPERATOR(pg_catalog.~) '^(test_storage)$' COLLATE pg_catalog.default
+                                                                            ^
 \d+ test_storage_idx
-                Index "public.test_storage_idx"
- Column |  Type   | Key? | Definition | Storage  | Stats target 
---------+---------+------+------------+----------+--------------
- b      | integer | yes  | b          | plain    | 
- a      | text    | yes  | a          | external | 
-btree, for table "public.test_storage"
-
+ERROR:  at or near ".": syntax error
+DETAIL:  source SQL:
+SELECT c.oid,
+  n.nspname,
+  c.relname
+FROM pg_catalog.pg_class c
+     LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace
+WHERE c.relname OPERATOR(pg_catalog.~) '^(test_storage_idx)$' COLLATE pg_catalog.default
+                                                                                ^
 -- ALTER COLUMN TYPE with a check constraint and a child table (bug #13779)
 CREATE TABLE test_inh_check (a float check (a > 10.2), b float);
 CREATE TABLE test_inh_check_child() INHERITS(test_inh_check);
+ERROR:  at or near "(": syntax error: unimplemented: this syntax
+DETAIL:  source SQL:
+CREATE TABLE test_inh_check_child() INHERITS(test_inh_check)
+                                            ^
+HINT:  You have attempted to use a feature that is not yet implemented.
+See: https://go.crdb.dev/issue-v/22456/_version_
 \d test_inh_check
-               Table "public.test_inh_check"
- Column |       Type       | Collation | Nullable | Default 
---------+------------------+-----------+----------+---------
- a      | double precision |           |          | 
- b      | double precision |           |          | 
-Check constraints:
-    "test_inh_check_a_check" CHECK (a > 10.2::double precision)
-Number of child tables: 1 (Use \d+ to list them.)
-
+ERROR:  at or near ".": syntax error
+DETAIL:  source SQL:
+SELECT c.oid,
+  n.nspname,
+  c.relname
+FROM pg_catalog.pg_class c
+     LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace
+WHERE c.relname OPERATOR(pg_catalog.~) '^(test_inh_check)$' COLLATE pg_catalog.default
+                                                                              ^
 \d test_inh_check_child
-            Table "public.test_inh_check_child"
- Column |       Type       | Collation | Nullable | Default 
---------+------------------+-----------+----------+---------
- a      | double precision |           |          | 
- b      | double precision |           |          | 
-Check constraints:
-    "test_inh_check_a_check" CHECK (a > 10.2::double precision)
-Inherits: test_inh_check
-
+ERROR:  at or near ".": syntax error
+DETAIL:  source SQL:
+SELECT c.oid,
+  n.nspname,
+  c.relname
+FROM pg_catalog.pg_class c
+     LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace
+WHERE c.relname OPERATOR(pg_catalog.~) '^(test_inh_check_child)$' COLLATE pg_catalog.default
+                                                                                    ^
 select relname, conname, coninhcount, conislocal, connoinherit
   from pg_constraint c, pg_class r
   where relname like 'test_inh_check%' and c.conrelid = r.oid
   order by 1, 2;
-       relname        |        conname         | coninhcount | conislocal | connoinherit 
-----------------------+------------------------+-------------+------------+--------------
- test_inh_check       | test_inh_check_a_check |           0 | t          | f
- test_inh_check_child | test_inh_check_a_check |           1 | f          | f
+    relname     |       conname       | coninhcount | conislocal | connoinherit 
+----------------+---------------------+-------------+------------+--------------
+ test_inh_check | check_a             |           0 | t          | t
+ test_inh_check | test_inh_check_pkey |           0 | t          | t
 (2 rows)
 
 ALTER TABLE test_inh_check ALTER COLUMN a TYPE numeric;
+ERROR:  unimplemented: ALTER COLUMN TYPE requiring a rewrite of on-disk data is not supported for columns that have constraints
+HINT:  You have attempted to use a feature that is not yet implemented.
+See: https://go.crdb.dev/issue-v/48288/_version_
+--
+Consider temporarily dropping the constraint.
 \d test_inh_check
-               Table "public.test_inh_check"
- Column |       Type       | Collation | Nullable | Default 
---------+------------------+-----------+----------+---------
- a      | numeric          |           |          | 
- b      | double precision |           |          | 
-Check constraints:
-    "test_inh_check_a_check" CHECK (a::double precision > 10.2::double precision)
-Number of child tables: 1 (Use \d+ to list them.)
-
+ERROR:  at or near ".": syntax error
+DETAIL:  source SQL:
+SELECT c.oid,
+  n.nspname,
+  c.relname
+FROM pg_catalog.pg_class c
+     LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace
+WHERE c.relname OPERATOR(pg_catalog.~) '^(test_inh_check)$' COLLATE pg_catalog.default
+                                                                              ^
 \d test_inh_check_child
-            Table "public.test_inh_check_child"
- Column |       Type       | Collation | Nullable | Default 
---------+------------------+-----------+----------+---------
- a      | numeric          |           |          | 
- b      | double precision |           |          | 
-Check constraints:
-    "test_inh_check_a_check" CHECK (a::double precision > 10.2::double precision)
-Inherits: test_inh_check
-
+ERROR:  at or near ".": syntax error
+DETAIL:  source SQL:
+SELECT c.oid,
+  n.nspname,
+  c.relname
+FROM pg_catalog.pg_class c
+     LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace
+WHERE c.relname OPERATOR(pg_catalog.~) '^(test_inh_check_child)$' COLLATE pg_catalog.default
+                                                                                    ^
 select relname, conname, coninhcount, conislocal, connoinherit
   from pg_constraint c, pg_class r
   where relname like 'test_inh_check%' and c.conrelid = r.oid
   order by 1, 2;
-       relname        |        conname         | coninhcount | conislocal | connoinherit 
-----------------------+------------------------+-------------+------------+--------------
- test_inh_check       | test_inh_check_a_check |           0 | t          | f
- test_inh_check_child | test_inh_check_a_check |           1 | f          | f
+    relname     |       conname       | coninhcount | conislocal | connoinherit 
+----------------+---------------------+-------------+------------+--------------
+ test_inh_check | check_a             |           0 | t          | t
+ test_inh_check | test_inh_check_pkey |           0 | t          | t
 (2 rows)
 
 -- also try noinherit, local, and local+inherited cases
 ALTER TABLE test_inh_check ADD CONSTRAINT bnoinherit CHECK (b > 100) NO INHERIT;
+ERROR:  at or near "no": syntax error
+DETAIL:  source SQL:
+ALTER TABLE test_inh_check ADD CONSTRAINT bnoinherit CHECK (b > 100) NO INHERIT
+                                                                     ^
 ALTER TABLE test_inh_check_child ADD CONSTRAINT blocal CHECK (b < 1000);
+ERROR:  relation "test_inh_check_child" does not exist
 ALTER TABLE test_inh_check_child ADD CONSTRAINT bmerged CHECK (b > 1);
+ERROR:  relation "test_inh_check_child" does not exist
 ALTER TABLE test_inh_check ADD CONSTRAINT bmerged CHECK (b > 1);
-NOTICE:  merging constraint "bmerged" with inherited definition
 \d test_inh_check
-               Table "public.test_inh_check"
- Column |       Type       | Collation | Nullable | Default 
---------+------------------+-----------+----------+---------
- a      | numeric          |           |          | 
- b      | double precision |           |          | 
-Check constraints:
-    "bmerged" CHECK (b > 1::double precision)
-    "bnoinherit" CHECK (b > 100::double precision) NO INHERIT
-    "test_inh_check_a_check" CHECK (a::double precision > 10.2::double precision)
-Number of child tables: 1 (Use \d+ to list them.)
-
+ERROR:  at or near ".": syntax error
+DETAIL:  source SQL:
+SELECT c.oid,
+  n.nspname,
+  c.relname
+FROM pg_catalog.pg_class c
+     LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace
+WHERE c.relname OPERATOR(pg_catalog.~) '^(test_inh_check)$' COLLATE pg_catalog.default
+                                                                              ^
 \d test_inh_check_child
-            Table "public.test_inh_check_child"
- Column |       Type       | Collation | Nullable | Default 
---------+------------------+-----------+----------+---------
- a      | numeric          |           |          | 
- b      | double precision |           |          | 
-Check constraints:
-    "blocal" CHECK (b < 1000::double precision)
-    "bmerged" CHECK (b > 1::double precision)
-    "test_inh_check_a_check" CHECK (a::double precision > 10.2::double precision)
-Inherits: test_inh_check
-
+ERROR:  at or near ".": syntax error
+DETAIL:  source SQL:
+SELECT c.oid,
+  n.nspname,
+  c.relname
+FROM pg_catalog.pg_class c
+     LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace
+WHERE c.relname OPERATOR(pg_catalog.~) '^(test_inh_check_child)$' COLLATE pg_catalog.default
+                                                                                    ^
 select relname, conname, coninhcount, conislocal, connoinherit
   from pg_constraint c, pg_class r
   where relname like 'test_inh_check%' and c.conrelid = r.oid
   order by 1, 2;
-       relname        |        conname         | coninhcount | conislocal | connoinherit 
-----------------------+------------------------+-------------+------------+--------------
- test_inh_check       | bmerged                |           0 | t          | f
- test_inh_check       | bnoinherit             |           0 | t          | t
- test_inh_check       | test_inh_check_a_check |           0 | t          | f
- test_inh_check_child | blocal                 |           0 | t          | f
- test_inh_check_child | bmerged                |           1 | t          | f
- test_inh_check_child | test_inh_check_a_check |           1 | f          | f
-(6 rows)
+    relname     |       conname       | coninhcount | conislocal | connoinherit 
+----------------+---------------------+-------------+------------+--------------
+ test_inh_check | bmerged             |           0 | t          | t
+ test_inh_check | check_a             |           0 | t          | t
+ test_inh_check | test_inh_check_pkey |           0 | t          | t
+(3 rows)
 
 ALTER TABLE test_inh_check ALTER COLUMN b TYPE numeric;
-NOTICE:  merging constraint "bmerged" with inherited definition
+ERROR:  unimplemented: ALTER COLUMN TYPE requiring a rewrite of on-disk data is not supported for columns that have constraints
+HINT:  You have attempted to use a feature that is not yet implemented.
+See: https://go.crdb.dev/issue-v/48288/_version_
+--
+Consider temporarily dropping the constraint.
 \d test_inh_check
-           Table "public.test_inh_check"
- Column |  Type   | Collation | Nullable | Default 
---------+---------+-----------+----------+---------
- a      | numeric |           |          | 
- b      | numeric |           |          | 
-Check constraints:
-    "bmerged" CHECK (b::double precision > 1::double precision)
-    "bnoinherit" CHECK (b::double precision > 100::double precision) NO INHERIT
-    "test_inh_check_a_check" CHECK (a::double precision > 10.2::double precision)
-Number of child tables: 1 (Use \d+ to list them.)
-
+ERROR:  at or near ".": syntax error
+DETAIL:  source SQL:
+SELECT c.oid,
+  n.nspname,
+  c.relname
+FROM pg_catalog.pg_class c
+     LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace
+WHERE c.relname OPERATOR(pg_catalog.~) '^(test_inh_check)$' COLLATE pg_catalog.default
+                                                                              ^
 \d test_inh_check_child
-        Table "public.test_inh_check_child"
- Column |  Type   | Collation | Nullable | Default 
---------+---------+-----------+----------+---------
- a      | numeric |           |          | 
- b      | numeric |           |          | 
-Check constraints:
-    "blocal" CHECK (b::double precision < 1000::double precision)
-    "bmerged" CHECK (b::double precision > 1::double precision)
-    "test_inh_check_a_check" CHECK (a::double precision > 10.2::double precision)
-Inherits: test_inh_check
-
+ERROR:  at or near ".": syntax error
+DETAIL:  source SQL:
+SELECT c.oid,
+  n.nspname,
+  c.relname
+FROM pg_catalog.pg_class c
+     LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace
+WHERE c.relname OPERATOR(pg_catalog.~) '^(test_inh_check_child)$' COLLATE pg_catalog.default
+                                                                                    ^
 select relname, conname, coninhcount, conislocal, connoinherit
   from pg_constraint c, pg_class r
   where relname like 'test_inh_check%' and c.conrelid = r.oid
   order by 1, 2;
-       relname        |        conname         | coninhcount | conislocal | connoinherit 
-----------------------+------------------------+-------------+------------+--------------
- test_inh_check       | bmerged                |           0 | t          | f
- test_inh_check       | bnoinherit             |           0 | t          | t
- test_inh_check       | test_inh_check_a_check |           0 | t          | f
- test_inh_check_child | blocal                 |           0 | t          | f
- test_inh_check_child | bmerged                |           1 | t          | f
- test_inh_check_child | test_inh_check_a_check |           1 | f          | f
-(6 rows)
+    relname     |       conname       | coninhcount | conislocal | connoinherit 
+----------------+---------------------+-------------+------------+--------------
+ test_inh_check | bmerged             |           0 | t          | t
+ test_inh_check | check_a             |           0 | t          | t
+ test_inh_check | test_inh_check_pkey |           0 | t          | t
+(3 rows)
 
 -- ALTER COLUMN TYPE with different schema in children
 -- Bug at https://postgr.es/m/20170102225618.GA10071@telsasoft.com
 CREATE TABLE test_type_diff (f1 int);
 CREATE TABLE test_type_diff_c (extra smallint) INHERITS (test_type_diff);
+ERROR:  at or near "(": syntax error: unimplemented: this syntax
+DETAIL:  source SQL:
+CREATE TABLE test_type_diff_c (extra smallint) INHERITS (test_type_diff)
+                                                        ^
+HINT:  You have attempted to use a feature that is not yet implemented.
+See: https://go.crdb.dev/issue-v/22456/_version_
 ALTER TABLE test_type_diff ADD COLUMN f2 int;
 INSERT INTO test_type_diff_c VALUES (1, 2, 3);
+ERROR:  relation "test_type_diff_c" does not exist
 ALTER TABLE test_type_diff ALTER COLUMN f2 TYPE bigint USING f2::bigint;
 CREATE TABLE test_type_diff2 (int_two int2, int_four int4, int_eight int8);
 CREATE TABLE test_type_diff2_c1 (int_four int4, int_eight int8, int_two int2);
 CREATE TABLE test_type_diff2_c2 (int_eight int8, int_two int2, int_four int4);
 CREATE TABLE test_type_diff2_c3 (int_two int2, int_four int4, int_eight int8);
 ALTER TABLE test_type_diff2_c1 INHERIT test_type_diff2;
+ERROR:  at or near "inherit": syntax error
+DETAIL:  source SQL:
+ALTER TABLE test_type_diff2_c1 INHERIT test_type_diff2
+                               ^
+HINT:  try \h ALTER TABLE
 ALTER TABLE test_type_diff2_c2 INHERIT test_type_diff2;
+ERROR:  at or near "inherit": syntax error
+DETAIL:  source SQL:
+ALTER TABLE test_type_diff2_c2 INHERIT test_type_diff2
+                               ^
+HINT:  try \h ALTER TABLE
 ALTER TABLE test_type_diff2_c3 INHERIT test_type_diff2;
+ERROR:  at or near "inherit": syntax error
+DETAIL:  source SQL:
+ALTER TABLE test_type_diff2_c3 INHERIT test_type_diff2
+                               ^
+HINT:  try \h ALTER TABLE
 INSERT INTO test_type_diff2_c1 VALUES (1, 2, 3);
 INSERT INTO test_type_diff2_c2 VALUES (4, 5, 6);
 INSERT INTO test_type_diff2_c3 VALUES (7, 8, 9);
 ALTER TABLE test_type_diff2 ALTER COLUMN int_four TYPE int8 USING int_four::int8;
 -- whole-row references are disallowed
 ALTER TABLE test_type_diff2 ALTER COLUMN int_four TYPE int4 USING (pg_column_size(test_type_diff2));
-ERROR:  cannot convert whole-row table reference
-DETAIL:  USING expression contains a whole-row table reference.
+ERROR:  column "test_type_diff2" does not exist
 -- check for rollback of ANALYZE corrupting table property flags (bug #11638)
 CREATE TABLE check_fk_presence_1 (id int PRIMARY KEY, t text);
 CREATE TABLE check_fk_presence_2 (id int REFERENCES check_fk_presence_1, t text);
 BEGIN;
 ALTER TABLE check_fk_presence_2 DROP CONSTRAINT check_fk_presence_2_id_fkey;
+NOTICE:  auto-committing transaction before processing DDL due to autocommit_before_ddl setting
 ANALYZE check_fk_presence_2;
 ROLLBACK;
+WARNING:  there is no transaction in progress
 \d check_fk_presence_2
-        Table "public.check_fk_presence_2"
- Column |  Type   | Collation | Nullable | Default 
---------+---------+-----------+----------+---------
- id     | integer |           |          | 
- t      | text    |           |          | 
-Foreign-key constraints:
-    "check_fk_presence_2_id_fkey" FOREIGN KEY (id) REFERENCES check_fk_presence_1(id)
-
+ERROR:  at or near ".": syntax error
+DETAIL:  source SQL:
+SELECT c.oid,
+  n.nspname,
+  c.relname
+FROM pg_catalog.pg_class c
+     LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace
+WHERE c.relname OPERATOR(pg_catalog.~) '^(check_fk_presence_2)$' COLLATE pg_catalog.default
+                                                                                   ^
 DROP TABLE check_fk_presence_1, check_fk_presence_2;
 -- check column addition within a view (bug #14876)
 create table at_base_table(id int, stuff text);
@@ -2487,80 +2915,68 @@
 create view at_view_1 as select * from at_base_table bt;
 create view at_view_2 as select *, to_json(v1) as j from at_view_1 v1;
 \d+ at_view_1
-                          View "public.at_view_1"
- Column |  Type   | Collation | Nullable | Default | Storage  | Description 
---------+---------+-----------+----------+---------+----------+-------------
- id     | integer |           |          |         | plain    | 
- stuff  | text    |           |          |         | extended | 
-View definition:
- SELECT id,
-    stuff
-   FROM at_base_table bt;
-
+ERROR:  at or near ".": syntax error
+DETAIL:  source SQL:
+SELECT c.oid,
+  n.nspname,
+  c.relname
+FROM pg_catalog.pg_class c
+     LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace
+WHERE c.relname OPERATOR(pg_catalog.~) '^(at_view_1)$' COLLATE pg_catalog.default
+                                                                         ^
 \d+ at_view_2
-                          View "public.at_view_2"
- Column |  Type   | Collation | Nullable | Default | Storage  | Description 
---------+---------+-----------+----------+---------+----------+-------------
- id     | integer |           |          |         | plain    | 
- stuff  | text    |           |          |         | extended | 
- j      | json    |           |          |         | extended | 
-View definition:
- SELECT id,
-    stuff,
-    to_json(v1.*) AS j
-   FROM at_view_1 v1;
-
+ERROR:  at or near ".": syntax error
+DETAIL:  source SQL:
+SELECT c.oid,
+  n.nspname,
+  c.relname
+FROM pg_catalog.pg_class c
+     LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace
+WHERE c.relname OPERATOR(pg_catalog.~) '^(at_view_2)$' COLLATE pg_catalog.default
+                                                                         ^
 explain (verbose, costs off) select * from at_view_2;
-                        QUERY PLAN                        
-----------------------------------------------------------
- Seq Scan on public.at_base_table bt
-   Output: bt.id, bt.stuff, to_json(ROW(bt.id, bt.stuff))
-(2 rows)
-
+ERROR:  at or near "off": syntax error
+DETAIL:  source SQL:
+explain (verbose, costs off) select * from at_view_2
+                        ^
+HINT:  try \h <SELECTCLAUSE>
 select * from at_view_2;
- id | stuff  |             j              
-----+--------+----------------------------
- 23 | skidoo | {"id":23,"stuff":"skidoo"}
+ id | stuff  |               j               
+----+--------+-------------------------------
+ 23 | skidoo | {"id": 23, "stuff": "skidoo"}
 (1 row)
 
 create or replace view at_view_1 as select *, 2+2 as more from at_base_table bt;
 \d+ at_view_1
-                          View "public.at_view_1"
- Column |  Type   | Collation | Nullable | Default | Storage  | Description 
---------+---------+-----------+----------+---------+----------+-------------
- id     | integer |           |          |         | plain    | 
- stuff  | text    |           |          |         | extended | 
- more   | integer |           |          |         | plain    | 
-View definition:
- SELECT id,
-    stuff,
-    2 + 2 AS more
-   FROM at_base_table bt;
-
+ERROR:  at or near ".": syntax error
+DETAIL:  source SQL:
+SELECT c.oid,
+  n.nspname,
+  c.relname
+FROM pg_catalog.pg_class c
+     LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace
+WHERE c.relname OPERATOR(pg_catalog.~) '^(at_view_1)$' COLLATE pg_catalog.default
+                                                                         ^
 \d+ at_view_2
-                          View "public.at_view_2"
- Column |  Type   | Collation | Nullable | Default | Storage  | Description 
---------+---------+-----------+----------+---------+----------+-------------
- id     | integer |           |          |         | plain    | 
- stuff  | text    |           |          |         | extended | 
- j      | json    |           |          |         | extended | 
-View definition:
- SELECT id,
-    stuff,
-    to_json(v1.*) AS j
-   FROM at_view_1 v1;
-
+ERROR:  at or near ".": syntax error
+DETAIL:  source SQL:
+SELECT c.oid,
+  n.nspname,
+  c.relname
+FROM pg_catalog.pg_class c
+     LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace
+WHERE c.relname OPERATOR(pg_catalog.~) '^(at_view_2)$' COLLATE pg_catalog.default
+                                                                         ^
 explain (verbose, costs off) select * from at_view_2;
-                         QUERY PLAN                          
--------------------------------------------------------------
- Seq Scan on public.at_base_table bt
-   Output: bt.id, bt.stuff, to_json(ROW(bt.id, bt.stuff, 4))
-(2 rows)
-
+ERROR:  at or near "off": syntax error
+DETAIL:  source SQL:
+explain (verbose, costs off) select * from at_view_2
+                        ^
+HINT:  try \h <SELECTCLAUSE>
 select * from at_view_2;
- id | stuff  |                  j                  
-----+--------+-------------------------------------
- 23 | skidoo | {"id":23,"stuff":"skidoo","more":4}
+ id | stuff  |                    j                     
+----+--------+------------------------------------------
+ 23 | skidoo | {"id": 23, "more": 4, "stuff": "skidoo"}
 (1 row)
 
 drop view at_view_2;
@@ -2569,32 +2985,54 @@
 -- related case (bug #17811)
 begin;
 create temp table t1 as select * from int8_tbl;
+NOTICE:  auto-committing transaction before processing DDL due to autocommit_before_ddl setting
+NOTICE:  CREATE TABLE ... AS does not copy over indexes, default expressions, or constraints; the new table has a hidden rowid primary key column
 create temp view v1 as select 1::int8 as q1;
 create temp view v2 as select * from v1;
 create or replace temp view v1 with (security_barrier = true)
   as select * from t1;
+ERROR:  at or near "with": syntax error
+DETAIL:  source SQL:
+create or replace temp view v1 with (security_barrier = true)
+                               ^
+HINT:  try \h CREATE
 create temp table log (q1 int8, q2 int8);
 create rule v1_upd_rule as on update to v1
   do also insert into log values (new.*);
+ERROR:  at or near "v1_upd_rule": syntax error: unimplemented: this syntax
+DETAIL:  source SQL:
+create rule v1_upd_rule as on update to v1
+            ^
+HINT:  You have attempted to use a feature that is not yet implemented.
+
+Please check the public issue tracker to check whether this problem is
+already tracked. If you cannot find it there, please report the error
+with details by creating a new issue.
+
+If you would rather not post publicly, please contact us directly
+using the support form.
+
+We appreciate your feedback.
+
 update v2 set q1 = q1 + 1 where q1 = 123;
+ERROR:  "v2" is not a table
 select * from t1;
         q1        |        q2         
 ------------------+-------------------
+              123 |               456
+              123 |  4567890123456789
  4567890123456789 |               123
  4567890123456789 |  4567890123456789
  4567890123456789 | -4567890123456789
-              124 |               456
-              124 |  4567890123456789
 (5 rows)
 
 select * from log;
- q1  |        q2        
------+------------------
- 124 |              456
- 124 | 4567890123456789
-(2 rows)
+ q1 | q2 
+----+----
+(0 rows)
 
 rollback;
+WARNING:  there is no transaction in progress
 -- check adding a column not itself requiring a rewrite, together with
 -- a column requiring a default (bug #16038)
 -- ensure that rewrites aren't silently optimized away, removing the
@@ -2612,6 +3050,18 @@
     RETURN v_relfilenode <> (SELECT relfilenode FROM pg_class WHERE oid = p_tablename);
 END;
 $$;
+ERROR:  at or near ";": at or near "from": syntax error
+DETAIL:  source SQL:
+SET ROW (relfilenode FROM pg_class WHERE oid = p_tablename)
+                     ^
+--
+source SQL:
+DECLARE
+    v_relfilenode oid;
+BEGIN
+    v_relfilenode := relfilenode FROM pg_class WHERE oid = p_tablename;
+                                                                      ^
+HINT:  try \h SET SESSION
 CREATE TABLE rewrite_test(col text);
 INSERT INTO rewrite_test VALUES ('something');
 INSERT INTO rewrite_test VALUES (NULL);
@@ -2621,42 +3071,26 @@
       ADD COLUMN empty1 text,
       ADD COLUMN notempty1_rewrite serial;
 $$);
- check_ddl_rewrite 
--------------------
- t
-(1 row)
-
+ERROR:  unknown function: check_ddl_rewrite()
 SELECT check_ddl_rewrite('rewrite_test', $$
     ALTER TABLE rewrite_test
         ADD COLUMN notempty2_rewrite serial,
         ADD COLUMN empty2 text;
 $$);
- check_ddl_rewrite 
--------------------
- t
-(1 row)
-
+ERROR:  unknown function: check_ddl_rewrite()
 -- also check that fast defaults cause no problem, first without rewrite
 SELECT check_ddl_rewrite('rewrite_test', $$
     ALTER TABLE rewrite_test
         ADD COLUMN empty3 text,
         ADD COLUMN notempty3_norewrite int default 42;
 $$);
- check_ddl_rewrite 
--------------------
- f
-(1 row)
-
+ERROR:  unknown function: check_ddl_rewrite()
 SELECT check_ddl_rewrite('rewrite_test', $$
     ALTER TABLE rewrite_test
         ADD COLUMN notempty4_norewrite int default 42,
         ADD COLUMN empty4 text;
 $$);
- check_ddl_rewrite 
--------------------
- f
-(1 row)
-
+ERROR:  unknown function: check_ddl_rewrite()
 -- then with rewrite
 SELECT check_ddl_rewrite('rewrite_test', $$
     ALTER TABLE rewrite_test
@@ -2664,24 +3098,17 @@
         ADD COLUMN notempty5_norewrite int default 42,
         ADD COLUMN notempty5_rewrite serial;
 $$);
- check_ddl_rewrite 
--------------------
- t
-(1 row)
-
+ERROR:  unknown function: check_ddl_rewrite()
 SELECT check_ddl_rewrite('rewrite_test', $$
     ALTER TABLE rewrite_test
         ADD COLUMN notempty6_rewrite serial,
         ADD COLUMN empty6 text,
         ADD COLUMN notempty6_norewrite int default 42;
 $$);
- check_ddl_rewrite 
--------------------
- t
-(1 row)
-
+ERROR:  unknown function: check_ddl_rewrite()
 -- cleanup
 DROP FUNCTION check_ddl_rewrite(regclass, text);
+ERROR:  unknown function: check_ddl_rewrite()
 DROP TABLE rewrite_test;
 --
 -- lock levels
@@ -2700,7 +3127,7 @@
 ,'AccessExclusiveLock'
 );
 drop view my_locks;
-ERROR:  view "my_locks" does not exist
+ERROR:  relation "my_locks" does not exist
 create or replace view my_locks as
 select case when c.relname like 'pg_toast%' then 'pg_toast' else c.relname end, max(mode::lockmodes) as max_lockmode
 from pg_locks l join pg_class c on l.relation = c.oid
@@ -2712,158 +3139,136 @@
 and relnamespace != (select oid from pg_namespace where nspname = 'pg_catalog')
 and c.relname != 'my_locks'
 group by c.relname;
+ERROR:  unknown function: pg_current_xact_id()
+HINT:  There is probably a typo in function name. Or the intention was to use a user-defined function in the view query, which is currently not supported.
 create table alterlock (f1 int primary key, f2 text);
 insert into alterlock values (1, 'foo');
 create table alterlock2 (f3 int primary key, f1 int);
 insert into alterlock2 values (1, 1);
 begin; alter table alterlock alter column f2 set statistics 150;
+ERROR:  at or near "statistics": syntax error
+DETAIL:  source SQL:
+alter table alterlock alter column f2 set statistics 150
+                                          ^
+HINT:  try \h ALTER TABLE
 select * from my_locks order by 1;
-  relname  |       max_lockmode       
------------+--------------------------
- alterlock | ShareUpdateExclusiveLock
-(1 row)
-
+ERROR:  current transaction is aborted, commands ignored until end of transaction block
 rollback;
 begin; alter table alterlock cluster on alterlock_pkey;
+ERROR:  at or near "cluster": syntax error
+DETAIL:  source SQL:
+alter table alterlock cluster on alterlock_pkey
+                      ^
+HINT:  try \h ALTER TABLE
 select * from my_locks order by 1;
-    relname     |       max_lockmode       
-----------------+--------------------------
- alterlock      | ShareUpdateExclusiveLock
- alterlock_pkey | ShareUpdateExclusiveLock
-(2 rows)
-
+ERROR:  current transaction is aborted, commands ignored until end of transaction block
 commit;
 begin; alter table alterlock set without cluster;
+ERROR:  at or near "without": syntax error
+DETAIL:  source SQL:
+alter table alterlock set without cluster
+                          ^
+HINT:  try \h ALTER TABLE
 select * from my_locks order by 1;
-  relname  |       max_lockmode       
------------+--------------------------
- alterlock | ShareUpdateExclusiveLock
-(1 row)
-
+ERROR:  current transaction is aborted, commands ignored until end of transaction block
 commit;
 begin; alter table alterlock set (fillfactor = 100);
+NOTICE:  auto-committing transaction before processing DDL due to autocommit_before_ddl setting
+NOTICE:  storage parameter "fillfactor" is ignored
 select * from my_locks order by 1;
-  relname  |       max_lockmode       
------------+--------------------------
- alterlock | ShareUpdateExclusiveLock
- pg_toast  | ShareUpdateExclusiveLock
-(2 rows)
-
+ERROR:  relation "my_locks" does not exist
 commit;
+WARNING:  there is no transaction in progress
 begin; alter table alterlock reset (fillfactor);
+NOTICE:  auto-committing transaction before processing DDL due to autocommit_before_ddl setting
 select * from my_locks order by 1;
-  relname  |       max_lockmode       
------------+--------------------------
- alterlock | ShareUpdateExclusiveLock
- pg_toast  | ShareUpdateExclusiveLock
-(2 rows)
-
+ERROR:  relation "my_locks" does not exist
 commit;
+WARNING:  there is no transaction in progress
 begin; alter table alterlock set (toast.autovacuum_enabled = off);
+ERROR:  at or near ".": syntax error
+DETAIL:  source SQL:
+alter table alterlock set (toast.autovacuum_enabled = off)
+                                ^
+HINT:  try \h ALTER TABLE
 select * from my_locks order by 1;
-  relname  |       max_lockmode       
------------+--------------------------
- alterlock | ShareUpdateExclusiveLock
- pg_toast  | ShareUpdateExclusiveLock
-(2 rows)
-
+ERROR:  current transaction is aborted, commands ignored until end of transaction block
 commit;
 begin; alter table alterlock set (autovacuum_enabled = off);
+NOTICE:  auto-committing transaction before processing DDL due to autocommit_before_ddl setting
+NOTICE:  storage parameter "autovacuum_enabled = 'off'" is ignored
 select * from my_locks order by 1;
-  relname  |       max_lockmode       
------------+--------------------------
- alterlock | ShareUpdateExclusiveLock
- pg_toast  | ShareUpdateExclusiveLock
-(2 rows)
-
+ERROR:  relation "my_locks" does not exist
 commit;
+WARNING:  there is no transaction in progress
 begin; alter table alterlock alter column f2 set (n_distinct = 1);
+ERROR:  at or near "(": syntax error
+DETAIL:  source SQL:
+alter table alterlock alter column f2 set (n_distinct = 1)
+                                          ^
+HINT:  try \h ALTER TABLE
 select * from my_locks order by 1;
-  relname  |       max_lockmode       
------------+--------------------------
- alterlock | ShareUpdateExclusiveLock
-(1 row)
-
+ERROR:  current transaction is aborted, commands ignored until end of transaction block
 rollback;
 -- test that mixing options with different lock levels works as expected
 begin; alter table alterlock set (autovacuum_enabled = off, fillfactor = 80);
+NOTICE:  auto-committing transaction before processing DDL due to autocommit_before_ddl setting
+NOTICE:  storage parameter "autovacuum_enabled = 'off'" is ignored
+NOTICE:  storage parameter "fillfactor" is ignored
 select * from my_locks order by 1;
-  relname  |       max_lockmode       
------------+--------------------------
- alterlock | ShareUpdateExclusiveLock
- pg_toast  | ShareUpdateExclusiveLock
-(2 rows)
-
+ERROR:  relation "my_locks" does not exist
 commit;
+WARNING:  there is no transaction in progress
 begin; alter table alterlock alter column f2 set storage extended;
+ERROR:  at or near "storage": syntax error
+DETAIL:  source SQL:
+alter table alterlock alter column f2 set storage extended
+                                          ^
+HINT:  try \h ALTER TABLE
 select * from my_locks order by 1;
-  relname  |    max_lockmode     
------------+---------------------
- alterlock | AccessExclusiveLock
-(1 row)
-
+ERROR:  current transaction is aborted, commands ignored until end of transaction block
 rollback;
 begin; alter table alterlock alter column f2 set default 'x';
+NOTICE:  auto-committing transaction before processing DDL due to autocommit_before_ddl setting
 select * from my_locks order by 1;
-  relname  |    max_lockmode     
------------+---------------------
- alterlock | AccessExclusiveLock
-(1 row)
-
+ERROR:  relation "my_locks" does not exist
 rollback;
+WARNING:  there is no transaction in progress
 begin;
 create trigger ttdummy
 	before delete or update on alterlock
 	for each row
 	execute procedure
 	ttdummy (1, 1);
+NOTICE:  auto-committing transaction before processing DDL due to autocommit_before_ddl setting
+ERROR:  unknown function: ttdummy()
 select * from my_locks order by 1;
-  relname  |     max_lockmode      
------------+-----------------------
- alterlock | ShareRowExclusiveLock
-(1 row)
-
+ERROR:  relation "my_locks" does not exist
 rollback;
+WARNING:  there is no transaction in progress
 begin;
 select * from my_locks order by 1;
- relname | max_lockmode 
----------+--------------
-(0 rows)
-
+ERROR:  relation "my_locks" does not exist
 alter table alterlock2 add foreign key (f1) references alterlock (f1);
+ERROR:  current transaction is aborted, commands ignored until end of transaction block
 select * from my_locks order by 1;
-     relname     |     max_lockmode      
------------------+-----------------------
- alterlock       | ShareRowExclusiveLock
- alterlock2      | ShareRowExclusiveLock
- alterlock2_pkey | AccessShareLock
- alterlock_pkey  | AccessShareLock
-(4 rows)
-
+ERROR:  current transaction is aborted, commands ignored until end of transaction block
 rollback;
 begin;
 alter table alterlock2
 add constraint alterlock2nv foreign key (f1) references alterlock (f1) NOT VALID;
+NOTICE:  auto-committing transaction before processing DDL due to autocommit_before_ddl setting
 select * from my_locks order by 1;
-  relname   |     max_lockmode      
-------------+-----------------------
- alterlock  | ShareRowExclusiveLock
- alterlock2 | ShareRowExclusiveLock
-(2 rows)
-
+ERROR:  relation "my_locks" does not exist
 commit;
+WARNING:  there is no transaction in progress
 begin;
 alter table alterlock2 validate constraint alterlock2nv;
+NOTICE:  auto-committing transaction before processing DDL due to autocommit_before_ddl setting
 select * from my_locks order by 1;
-     relname     |       max_lockmode       
------------------+--------------------------
- alterlock       | RowShareLock
- alterlock2      | ShareUpdateExclusiveLock
- alterlock2_pkey | AccessShareLock
- alterlock_pkey  | AccessShareLock
-(4 rows)
-
+ERROR:  relation "my_locks" does not exist
 rollback;
+WARNING:  there is no transaction in progress
 create or replace view my_locks as
 select case when c.relname like 'pg_toast%' then 'pg_toast' else c.relname end, max(mode::lockmodes) as max_lockmode
 from pg_locks l join pg_class c on l.relation = c.oid
@@ -2875,40 +3280,59 @@
 and relnamespace != (select oid from pg_namespace where nspname = 'pg_catalog')
 and c.relname = 'my_locks'
 group by c.relname;
+ERROR:  unknown function: pg_current_xact_id()
+HINT:  There is probably a typo in function name. Or the intention was to use a user-defined function in the view query, which is currently not supported.
 -- raise exception
 alter table my_locks set (autovacuum_enabled = false);
-ERROR:  unrecognized parameter "autovacuum_enabled"
+ERROR:  relation "my_locks" does not exist
 alter view my_locks set (autovacuum_enabled = false);
-ERROR:  unrecognized parameter "autovacuum_enabled"
+ERROR:  at or near "(": syntax error
+DETAIL:  source SQL:
+alter view my_locks set (autovacuum_enabled = false)
+                        ^
+HINT:  try \h ALTER VIEW
 alter table my_locks reset (autovacuum_enabled);
+ERROR:  relation "my_locks" does not exist
 alter view my_locks reset (autovacuum_enabled);
+ERROR:  at or near "reset": syntax error
+DETAIL:  source SQL:
+alter view my_locks reset (autovacuum_enabled)
+                    ^
+HINT:  try \h ALTER VIEW
 begin;
 alter view my_locks set (security_barrier=off);
+ERROR:  at or near "(": syntax error
+DETAIL:  source SQL:
+alter view my_locks set (security_barrier=off)
+                        ^
+HINT:  try \h ALTER VIEW
 select * from my_locks order by 1;
- relname  |    max_lockmode     
-----------+---------------------
- my_locks | AccessExclusiveLock
-(1 row)
-
+ERROR:  current transaction is aborted, commands ignored until end of transaction block
 alter view my_locks reset (security_barrier);
+ERROR:  at or near "reset": syntax error
+DETAIL:  source SQL:
+alter view my_locks reset (security_barrier)
+                    ^
+HINT:  try \h ALTER VIEW
 rollback;
 -- this test intentionally applies the ALTER TABLE command against a view, but
 -- uses a view option so we expect this to succeed. This form of SQL is
 -- accepted for historical reasons, as shown in the docs for ALTER VIEW
 begin;
 alter table my_locks set (security_barrier=off);
+NOTICE:  auto-committing transaction before processing DDL due to autocommit_before_ddl setting
+ERROR:  relation "my_locks" does not exist
 select * from my_locks order by 1;
- relname  |    max_lockmode     
-----------+---------------------
- my_locks | AccessExclusiveLock
-(1 row)
-
+ERROR:  relation "my_locks" does not exist
 alter table my_locks reset (security_barrier);
+ERROR:  relation "my_locks" does not exist
 rollback;
+WARNING:  there is no transaction in progress
 -- cleanup
 drop table alterlock2;
 drop table alterlock;
 drop view my_locks;
+ERROR:  relation "my_locks" does not exist
 drop type lockmodes;
 --
 -- alter function
@@ -2950,60 +3374,178 @@
 --
 create schema alter1;
 create schema alter2;
-create table alter1.t1(f1 serial primary key, f2 int check (f2 > 0));
+create sequence f1_seq;
+ERROR:  relation "root.public.f1_seq" already exists
+create table alter1.t1(f1 int primary key default nextval('f1_seq'), f2 int check (f2 > 0));
+NOTICE:  using sequential values in a primary key does not perform as well as using random UUIDs. See https://www.cockroachlabs.com/docs/_version_/serial.html
 create view alter1.v1 as select * from alter1.t1;
 create function alter1.plus1(int) returns int as 'select $1+1' language sql;
 create domain alter1.posint integer check (value > 0);
+ERROR:  at or near "integer": syntax error: unimplemented: this syntax
+DETAIL:  source SQL:
+create domain alter1.posint integer check (value > 0)
+                            ^
+HINT:  You have attempted to use a feature that is not yet implemented.
+See: https://go.crdb.dev/issue-v/27796/_version_
 create type alter1.ctype as (f1 int, f2 text);
 create function alter1.same(alter1.ctype, alter1.ctype) returns boolean language sql
 as 'select $1.f1 is not distinct from $2.f1 and $1.f2 is not distinct from $2.f2';
+ERROR:  at or near ".": syntax error
+DETAIL:  source SQL:
+select $1.f1 is not distinct from $2.f1 and $1.f2 is not distinct from $2.f2
+         ^
 create operator alter1.=(procedure = alter1.same, leftarg  = alter1.ctype, rightarg = alter1.ctype);
+ERROR:  at or near "alter1": syntax error: unimplemented: this syntax
+DETAIL:  source SQL:
+create operator alter1.=(procedure = alter1.same, leftarg  = alter1.ctype, rightarg = alter1.ctype)
+                ^
+HINT:  You have attempted to use a feature that is not yet implemented.
+See: https://go.crdb.dev/issue-v/65017/_version_
 create operator class alter1.ctype_hash_ops default for type alter1.ctype using hash as
   operator 1 alter1.=(alter1.ctype, alter1.ctype);
+ERROR:  at or near "class": syntax error: unimplemented: this syntax
+DETAIL:  source SQL:
+create operator class alter1.ctype_hash_ops default for type alter1.ctype using hash as
+                ^
+HINT:  You have attempted to use a feature that is not yet implemented.
+See: https://go.crdb.dev/issue-v/65017/_version_
 create conversion alter1.latin1_to_utf8 for 'latin1' to 'utf8' from iso8859_1_to_utf8;
+ERROR:  at or near "alter1": syntax error: unimplemented: this syntax
+DETAIL:  source SQL:
+create conversion alter1.latin1_to_utf8 for 'latin1' to 'utf8' from iso8859_1_to_utf8
+                  ^
+HINT:  You have attempted to use a feature that is not yet implemented.
+
+Please check the public issue tracker to check whether this problem is
+already tracked. If you cannot find it there, please report the error
+with details by creating a new issue.
+
+If you would rather not post publicly, please contact us directly
+using the support form.
+
+We appreciate your feedback.
+
 create text search parser alter1.prs(start = prsd_start, gettoken = prsd_nexttoken, end = prsd_end, lextypes = prsd_lextype);
+ERROR:  at or near "search": syntax error: unimplemented: this syntax
+DETAIL:  source SQL:
+create text search parser alter1.prs(start = prsd_start, gettoken = prsd_nexttoken, end = prsd_end, lextypes = prsd_lextype)
+            ^
+HINT:  You have attempted to use a feature that is not yet implemented.
+See: https://go.crdb.dev/issue-v/7821/_version_
 create text search configuration alter1.cfg(parser = alter1.prs);
+ERROR:  at or near "search": syntax error: unimplemented: this syntax
+DETAIL:  source SQL:
+create text search configuration alter1.cfg(parser = alter1.prs)
+            ^
+HINT:  You have attempted to use a feature that is not yet implemented.
+See: https://go.crdb.dev/issue-v/7821/_version_
 create text search template alter1.tmpl(init = dsimple_init, lexize = dsimple_lexize);
+ERROR:  at or near "search": syntax error: unimplemented: this syntax
+DETAIL:  source SQL:
+create text search template alter1.tmpl(init = dsimple_init, lexize = dsimple_lexize)
+            ^
+HINT:  You have attempted to use a feature that is not yet implemented.
+See: https://go.crdb.dev/issue-v/7821/_version_
 create text search dictionary alter1.dict(template = alter1.tmpl);
+ERROR:  at or near "search": syntax error: unimplemented: this syntax
+DETAIL:  source SQL:
+create text search dictionary alter1.dict(template = alter1.tmpl)
+            ^
+HINT:  You have attempted to use a feature that is not yet implemented.
+See: https://go.crdb.dev/issue-v/7821/_version_
 insert into alter1.t1(f2) values(11);
 insert into alter1.t1(f2) values(12);
 alter table alter1.t1 set schema alter1; -- no-op, same schema
+ERROR:  cannot set schema on relation "t1" because view "v1" depends on it
+HINT:  consider dropping "v1" first.
 alter table alter1.t1 set schema alter2;
+ERROR:  cannot set schema on relation "t1" because view "v1" depends on it
+HINT:  consider dropping "v1" first.
 alter table alter1.v1 set schema alter2;
 alter function alter1.plus1(int) set schema alter2;
 alter domain alter1.posint set schema alter2;
+ERROR:  at or near "alter1": syntax error: unimplemented: this syntax
+DETAIL:  source SQL:
+alter domain alter1.posint set schema alter2
+             ^
+HINT:  You have attempted to use a feature that is not yet implemented.
+
+Please check the public issue tracker to check whether this problem is
+already tracked. If you cannot find it there, please report the error
+with details by creating a new issue.
+
+If you would rather not post publicly, please contact us directly
+using the support form.
+
+We appreciate your feedback.
+
 alter operator class alter1.ctype_hash_ops using hash set schema alter2;
+ERROR:  at or near "operator": syntax error
+DETAIL:  source SQL:
+alter operator class alter1.ctype_hash_ops using hash set schema alter2
+      ^
+HINT:  try \h ALTER
 alter operator family alter1.ctype_hash_ops using hash set schema alter2;
+ERROR:  at or near "operator": syntax error
+DETAIL:  source SQL:
+alter operator family alter1.ctype_hash_ops using hash set schema alter2
+      ^
+HINT:  try \h ALTER
 alter operator alter1.=(alter1.ctype, alter1.ctype) set schema alter2;
+ERROR:  at or near "operator": syntax error
+DETAIL:  source SQL:
+alter operator alter1.=(alter1.ctype, alter1.ctype) set schema alter2
+      ^
+HINT:  try \h ALTER
 alter function alter1.same(alter1.ctype, alter1.ctype) set schema alter2;
+ERROR:  unknown function: alter1.same()
 alter type alter1.ctype set schema alter1; -- no-op, same schema
 alter type alter1.ctype set schema alter2;
 alter conversion alter1.latin1_to_utf8 set schema alter2;
+ERROR:  at or near "conversion": syntax error
+DETAIL:  source SQL:
+alter conversion alter1.latin1_to_utf8 set schema alter2
+      ^
+HINT:  try \h ALTER
 alter text search parser alter1.prs set schema alter2;
+ERROR:  at or near "text": syntax error
+DETAIL:  source SQL:
+alter text search parser alter1.prs set schema alter2
+      ^
+HINT:  try \h ALTER
 alter text search configuration alter1.cfg set schema alter2;
+ERROR:  at or near "text": syntax error
+DETAIL:  source SQL:
+alter text search configuration alter1.cfg set schema alter2
+      ^
+HINT:  try \h ALTER
 alter text search template alter1.tmpl set schema alter2;
+ERROR:  at or near "text": syntax error
+DETAIL:  source SQL:
+alter text search template alter1.tmpl set schema alter2
+      ^
+HINT:  try \h ALTER
 alter text search dictionary alter1.dict set schema alter2;
+ERROR:  at or near "text": syntax error
+DETAIL:  source SQL:
+alter text search dictionary alter1.dict set schema alter2
+      ^
+HINT:  try \h ALTER
 -- this should succeed because nothing is left in alter1
 drop schema alter1;
+ERROR:  schema "alter1" is not empty and CASCADE was not specified
 insert into alter2.t1(f2) values(13);
+ERROR:  relation "alter2.t1" does not exist
 insert into alter2.t1(f2) values(14);
+ERROR:  relation "alter2.t1" does not exist
 select * from alter2.t1;
- f1 | f2 
-----+----
-  1 | 11
-  2 | 12
-  3 | 13
-  4 | 14
-(4 rows)
-
+ERROR:  relation "alter2.t1" does not exist
 select * from alter2.v1;
  f1 | f2 
 ----+----
-  1 | 11
-  2 | 12
-  3 | 13
-  4 | 14
-(4 rows)
+ 10 | 11
+ 11 | 12
+(2 rows)
 
 select alter2.plus1(41);
  plus1 
@@ -3013,225 +3555,391 @@
 
 -- clean up
 drop schema alter2 cascade;
-NOTICE:  drop cascades to 13 other objects
-DETAIL:  drop cascades to table alter2.t1
-drop cascades to view alter2.v1
-drop cascades to function alter2.plus1(integer)
-drop cascades to type alter2.posint
-drop cascades to type alter2.ctype
-drop cascades to function alter2.same(alter2.ctype,alter2.ctype)
-drop cascades to operator alter2.=(alter2.ctype,alter2.ctype)
-drop cascades to operator family alter2.ctype_hash_ops for access method hash
-drop cascades to conversion alter2.latin1_to_utf8
-drop cascades to text search parser alter2.prs
-drop cascades to text search configuration alter2.cfg
-drop cascades to text search template alter2.tmpl
-drop cascades to text search dictionary alter2.dict
 --
 -- composite types
 --
 CREATE TYPE test_type AS (a int);
 \d test_type
-         Composite type "public.test_type"
- Column |  Type   | Collation | Nullable | Default 
---------+---------+-----------+----------+---------
- a      | integer |           |          | 
-
+ERROR:  at or near ".": syntax error
+DETAIL:  source SQL:
+SELECT c.oid,
+  n.nspname,
+  c.relname
+FROM pg_catalog.pg_class c
+     LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace
+WHERE c.relname OPERATOR(pg_catalog.~) '^(test_type)$' COLLATE pg_catalog.default
+                                                                         ^
 ALTER TYPE nosuchtype ADD ATTRIBUTE b text; -- fails
-ERROR:  relation "nosuchtype" does not exist
+ERROR:  at or near "EOF": syntax error: unimplemented: this syntax
+DETAIL:  source SQL:
+ALTER TYPE nosuchtype ADD ATTRIBUTE b text
+                                          ^
+HINT:  You have attempted to use a feature that is not yet implemented.
+See: https://go.crdb.dev/issue-v/48701/_version_
 ALTER TYPE test_type ADD ATTRIBUTE b text;
+ERROR:  at or near "EOF": syntax error: unimplemented: this syntax
+DETAIL:  source SQL:
+ALTER TYPE test_type ADD ATTRIBUTE b text
+                                         ^
+HINT:  You have attempted to use a feature that is not yet implemented.
+See: https://go.crdb.dev/issue-v/48701/_version_
 \d test_type
-         Composite type "public.test_type"
- Column |  Type   | Collation | Nullable | Default 
---------+---------+-----------+----------+---------
- a      | integer |           |          | 
- b      | text    |           |          | 
-
+ERROR:  at or near ".": syntax error
+DETAIL:  source SQL:
+SELECT c.oid,
+  n.nspname,
+  c.relname
+FROM pg_catalog.pg_class c
+     LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace
+WHERE c.relname OPERATOR(pg_catalog.~) '^(test_type)$' COLLATE pg_catalog.default
+                                                                         ^
 ALTER TYPE test_type ADD ATTRIBUTE b text; -- fails
-ERROR:  column "b" of relation "test_type" already exists
+ERROR:  at or near "EOF": syntax error: unimplemented: this syntax
+DETAIL:  source SQL:
+ALTER TYPE test_type ADD ATTRIBUTE b text
+                                         ^
+HINT:  You have attempted to use a feature that is not yet implemented.
+See: https://go.crdb.dev/issue-v/48701/_version_
 ALTER TYPE test_type ALTER ATTRIBUTE b SET DATA TYPE varchar;
+ERROR:  at or near "EOF": syntax error: unimplemented: this syntax
+DETAIL:  source SQL:
+ALTER TYPE test_type ALTER ATTRIBUTE b SET DATA TYPE varchar
+                                                            ^
+HINT:  You have attempted to use a feature that is not yet implemented.
+See: https://go.crdb.dev/issue-v/48701/_version_
 \d test_type
-              Composite type "public.test_type"
- Column |       Type        | Collation | Nullable | Default 
---------+-------------------+-----------+----------+---------
- a      | integer           |           |          | 
- b      | character varying |           |          | 
-
+ERROR:  at or near ".": syntax error
+DETAIL:  source SQL:
+SELECT c.oid,
+  n.nspname,
+  c.relname
+FROM pg_catalog.pg_class c
+     LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace
+WHERE c.relname OPERATOR(pg_catalog.~) '^(test_type)$' COLLATE pg_catalog.default
+                                                                         ^
 ALTER TYPE test_type ALTER ATTRIBUTE b SET DATA TYPE integer;
+ERROR:  at or near "EOF": syntax error: unimplemented: this syntax
+DETAIL:  source SQL:
+ALTER TYPE test_type ALTER ATTRIBUTE b SET DATA TYPE integer
+                                                            ^
+HINT:  You have attempted to use a feature that is not yet implemented.
+See: https://go.crdb.dev/issue-v/48701/_version_
 \d test_type
-         Composite type "public.test_type"
- Column |  Type   | Collation | Nullable | Default 
---------+---------+-----------+----------+---------
- a      | integer |           |          | 
- b      | integer |           |          | 
-
+ERROR:  at or near ".": syntax error
+DETAIL:  source SQL:
+SELECT c.oid,
+  n.nspname,
+  c.relname
+FROM pg_catalog.pg_class c
+     LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace
+WHERE c.relname OPERATOR(pg_catalog.~) '^(test_type)$' COLLATE pg_catalog.default
+                                                                         ^
 ALTER TYPE test_type DROP ATTRIBUTE b;
+ERROR:  at or near "EOF": syntax error: unimplemented: this syntax
+DETAIL:  source SQL:
+ALTER TYPE test_type DROP ATTRIBUTE b
+                                     ^
+HINT:  You have attempted to use a feature that is not yet implemented.
+See: https://go.crdb.dev/issue-v/48701/_version_
 \d test_type
-         Composite type "public.test_type"
- Column |  Type   | Collation | Nullable | Default 
---------+---------+-----------+----------+---------
- a      | integer |           |          | 
-
+ERROR:  at or near ".": syntax error
+DETAIL:  source SQL:
+SELECT c.oid,
+  n.nspname,
+  c.relname
+FROM pg_catalog.pg_class c
+     LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace
+WHERE c.relname OPERATOR(pg_catalog.~) '^(test_type)$' COLLATE pg_catalog.default
+                                                                         ^
 ALTER TYPE test_type DROP ATTRIBUTE c; -- fails
-ERROR:  column "c" of relation "test_type" does not exist
+ERROR:  at or near "EOF": syntax error: unimplemented: this syntax
+DETAIL:  source SQL:
+ALTER TYPE test_type DROP ATTRIBUTE c
+                                     ^
+HINT:  You have attempted to use a feature that is not yet implemented.
+See: https://go.crdb.dev/issue-v/48701/_version_
 ALTER TYPE test_type DROP ATTRIBUTE IF EXISTS c;
-NOTICE:  column "c" of relation "test_type" does not exist, skipping
+ERROR:  at or near "EOF": syntax error: unimplemented: this syntax
+DETAIL:  source SQL:
+ALTER TYPE test_type DROP ATTRIBUTE IF EXISTS c
+                                               ^
+HINT:  You have attempted to use a feature that is not yet implemented.
+See: https://go.crdb.dev/issue-v/48701/_version_
 ALTER TYPE test_type DROP ATTRIBUTE a, ADD ATTRIBUTE d boolean;
+ERROR:  at or near "EOF": syntax error: unimplemented: this syntax
+DETAIL:  source SQL:
+ALTER TYPE test_type DROP ATTRIBUTE a, ADD ATTRIBUTE d boolean
+                                                              ^
+HINT:  You have attempted to use a feature that is not yet implemented.
+See: https://go.crdb.dev/issue-v/48701/_version_
 \d test_type
-         Composite type "public.test_type"
- Column |  Type   | Collation | Nullable | Default 
---------+---------+-----------+----------+---------
- d      | boolean |           |          | 
-
+ERROR:  at or near ".": syntax error
+DETAIL:  source SQL:
+SELECT c.oid,
+  n.nspname,
+  c.relname
+FROM pg_catalog.pg_class c
+     LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace
+WHERE c.relname OPERATOR(pg_catalog.~) '^(test_type)$' COLLATE pg_catalog.default
+                                                                         ^
 ALTER TYPE test_type RENAME ATTRIBUTE a TO aa;
-ERROR:  column "a" does not exist
+ERROR:  at or near "EOF": syntax error: unimplemented: this syntax
+DETAIL:  source SQL:
+ALTER TYPE test_type RENAME ATTRIBUTE a TO aa
+                                             ^
+HINT:  You have attempted to use a feature that is not yet implemented.
+See: https://go.crdb.dev/issue-v/48701/_version_
 ALTER TYPE test_type RENAME ATTRIBUTE d TO dd;
+ERROR:  at or near "EOF": syntax error: unimplemented: this syntax
+DETAIL:  source SQL:
+ALTER TYPE test_type RENAME ATTRIBUTE d TO dd
+                                             ^
+HINT:  You have attempted to use a feature that is not yet implemented.
+See: https://go.crdb.dev/issue-v/48701/_version_
 \d test_type
-         Composite type "public.test_type"
- Column |  Type   | Collation | Nullable | Default 
---------+---------+-----------+----------+---------
- dd     | boolean |           |          | 
-
+ERROR:  at or near ".": syntax error
+DETAIL:  source SQL:
+SELECT c.oid,
+  n.nspname,
+  c.relname
+FROM pg_catalog.pg_class c
+     LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace
+WHERE c.relname OPERATOR(pg_catalog.~) '^(test_type)$' COLLATE pg_catalog.default
+                                                                         ^
 DROP TYPE test_type;
 CREATE TYPE test_type1 AS (a int, b text);
 CREATE TABLE test_tbl1 (x int, y test_type1);
 ALTER TYPE test_type1 ALTER ATTRIBUTE b TYPE varchar; -- fails
-ERROR:  cannot alter type "test_type1" because column "test_tbl1.y" uses it
+ERROR:  at or near "EOF": syntax error: unimplemented: this syntax
+DETAIL:  source SQL:
+ALTER TYPE test_type1 ALTER ATTRIBUTE b TYPE varchar
+                                                    ^
+HINT:  You have attempted to use a feature that is not yet implemented.
+See: https://go.crdb.dev/issue-v/48701/_version_
 DROP TABLE test_tbl1;
 CREATE TABLE test_tbl1 (x int, y text);
 CREATE INDEX test_tbl1_idx ON test_tbl1((row(x,y)::test_type1));
+ERROR:  unimplemented: column ((x, y)::test_type1) has type test_type1, which is not indexable
+HINT:  You have attempted to use a feature that is not yet implemented.
+See: https://go.crdb.dev/issue-v/35730/_version_
 ALTER TYPE test_type1 ALTER ATTRIBUTE b TYPE varchar; -- fails
-ERROR:  cannot alter type "test_type1" because column "test_tbl1_idx.row" uses it
+ERROR:  at or near "EOF": syntax error: unimplemented: this syntax
+DETAIL:  source SQL:
+ALTER TYPE test_type1 ALTER ATTRIBUTE b TYPE varchar
+                                                    ^
+HINT:  You have attempted to use a feature that is not yet implemented.
+See: https://go.crdb.dev/issue-v/48701/_version_
 DROP TABLE test_tbl1;
 DROP TYPE test_type1;
 CREATE TYPE test_type2 AS (a int, b text);
 CREATE TABLE test_tbl2 OF test_type2;
+ERROR:  at or near "of": syntax error
+DETAIL:  source SQL:
+CREATE TABLE test_tbl2 OF test_type2
+                       ^
+HINT:  try \h CREATE TABLE
 CREATE TABLE test_tbl2_subclass () INHERITS (test_tbl2);
+ERROR:  at or near "(": syntax error: unimplemented: this syntax
+DETAIL:  source SQL:
+CREATE TABLE test_tbl2_subclass () INHERITS (test_tbl2)
+                                            ^
+HINT:  You have attempted to use a feature that is not yet implemented.
+See: https://go.crdb.dev/issue-v/22456/_version_
 \d test_type2
-        Composite type "public.test_type2"
- Column |  Type   | Collation | Nullable | Default 
---------+---------+-----------+----------+---------
- a      | integer |           |          | 
- b      | text    |           |          | 
-
+ERROR:  at or near ".": syntax error
+DETAIL:  source SQL:
+SELECT c.oid,
+  n.nspname,
+  c.relname
+FROM pg_catalog.pg_class c
+     LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace
+WHERE c.relname OPERATOR(pg_catalog.~) '^(test_type2)$' COLLATE pg_catalog.default
+                                                                          ^
 \d test_tbl2
-             Table "public.test_tbl2"
- Column |  Type   | Collation | Nullable | Default 
---------+---------+-----------+----------+---------
- a      | integer |           |          | 
- b      | text    |           |          | 
-Number of child tables: 1 (Use \d+ to list them.)
-Typed table of type: test_type2
-
+ERROR:  at or near ".": syntax error
+DETAIL:  source SQL:
+SELECT c.oid,
+  n.nspname,
+  c.relname
+FROM pg_catalog.pg_class c
+     LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace
+WHERE c.relname OPERATOR(pg_catalog.~) '^(test_tbl2)$' COLLATE pg_catalog.default
+                                                                         ^
 ALTER TYPE test_type2 ADD ATTRIBUTE c text; -- fails
-ERROR:  cannot alter type "test_type2" because it is the type of a typed table
-HINT:  Use ALTER ... CASCADE to alter the typed tables too.
+ERROR:  at or near "EOF": syntax error: unimplemented: this syntax
+DETAIL:  source SQL:
+ALTER TYPE test_type2 ADD ATTRIBUTE c text
+                                          ^
+HINT:  You have attempted to use a feature that is not yet implemented.
+See: https://go.crdb.dev/issue-v/48701/_version_
 ALTER TYPE test_type2 ADD ATTRIBUTE c text CASCADE;
+ERROR:  at or near "EOF": syntax error: unimplemented: this syntax
+DETAIL:  source SQL:
+ALTER TYPE test_type2 ADD ATTRIBUTE c text CASCADE
+                                                  ^
+HINT:  You have attempted to use a feature that is not yet implemented.
+See: https://go.crdb.dev/issue-v/48701/_version_
 \d test_type2
-        Composite type "public.test_type2"
- Column |  Type   | Collation | Nullable | Default 
---------+---------+-----------+----------+---------
- a      | integer |           |          | 
- b      | text    |           |          | 
- c      | text    |           |          | 
-
+ERROR:  at or near ".": syntax error
+DETAIL:  source SQL:
+SELECT c.oid,
+  n.nspname,
+  c.relname
+FROM pg_catalog.pg_class c
+     LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace
+WHERE c.relname OPERATOR(pg_catalog.~) '^(test_type2)$' COLLATE pg_catalog.default
+                                                                          ^
 \d test_tbl2
-             Table "public.test_tbl2"
- Column |  Type   | Collation | Nullable | Default 
---------+---------+-----------+----------+---------
- a      | integer |           |          | 
- b      | text    |           |          | 
- c      | text    |           |          | 
-Number of child tables: 1 (Use \d+ to list them.)
-Typed table of type: test_type2
-
+ERROR:  at or near ".": syntax error
+DETAIL:  source SQL:
+SELECT c.oid,
+  n.nspname,
+  c.relname
+FROM pg_catalog.pg_class c
+     LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace
+WHERE c.relname OPERATOR(pg_catalog.~) '^(test_tbl2)$' COLLATE pg_catalog.default
+                                                                         ^
 ALTER TYPE test_type2 ALTER ATTRIBUTE b TYPE varchar; -- fails
-ERROR:  cannot alter type "test_type2" because it is the type of a typed table
-HINT:  Use ALTER ... CASCADE to alter the typed tables too.
+ERROR:  at or near "EOF": syntax error: unimplemented: this syntax
+DETAIL:  source SQL:
+ALTER TYPE test_type2 ALTER ATTRIBUTE b TYPE varchar
+                                                    ^
+HINT:  You have attempted to use a feature that is not yet implemented.
+See: https://go.crdb.dev/issue-v/48701/_version_
 ALTER TYPE test_type2 ALTER ATTRIBUTE b TYPE varchar CASCADE;
+ERROR:  at or near "EOF": syntax error: unimplemented: this syntax
+DETAIL:  source SQL:
+ALTER TYPE test_type2 ALTER ATTRIBUTE b TYPE varchar CASCADE
+                                                            ^
+HINT:  You have attempted to use a feature that is not yet implemented.
+See: https://go.crdb.dev/issue-v/48701/_version_
 \d test_type2
-             Composite type "public.test_type2"
- Column |       Type        | Collation | Nullable | Default 
---------+-------------------+-----------+----------+---------
- a      | integer           |           |          | 
- b      | character varying |           |          | 
- c      | text              |           |          | 
-
+ERROR:  at or near ".": syntax error
+DETAIL:  source SQL:
+SELECT c.oid,
+  n.nspname,
+  c.relname
+FROM pg_catalog.pg_class c
+     LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace
+WHERE c.relname OPERATOR(pg_catalog.~) '^(test_type2)$' COLLATE pg_catalog.default
+                                                                          ^
 \d test_tbl2
-                  Table "public.test_tbl2"
- Column |       Type        | Collation | Nullable | Default 
---------+-------------------+-----------+----------+---------
- a      | integer           |           |          | 
- b      | character varying |           |          | 
- c      | text              |           |          | 
-Number of child tables: 1 (Use \d+ to list them.)
-Typed table of type: test_type2
-
+ERROR:  at or near ".": syntax error
+DETAIL:  source SQL:
+SELECT c.oid,
+  n.nspname,
+  c.relname
+FROM pg_catalog.pg_class c
+     LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace
+WHERE c.relname OPERATOR(pg_catalog.~) '^(test_tbl2)$' COLLATE pg_catalog.default
+                                                                         ^
 ALTER TYPE test_type2 DROP ATTRIBUTE b; -- fails
-ERROR:  cannot alter type "test_type2" because it is the type of a typed table
-HINT:  Use ALTER ... CASCADE to alter the typed tables too.
+ERROR:  at or near "EOF": syntax error: unimplemented: this syntax
+DETAIL:  source SQL:
+ALTER TYPE test_type2 DROP ATTRIBUTE b
+                                      ^
+HINT:  You have attempted to use a feature that is not yet implemented.
+See: https://go.crdb.dev/issue-v/48701/_version_
 ALTER TYPE test_type2 DROP ATTRIBUTE b CASCADE;
+ERROR:  at or near "EOF": syntax error: unimplemented: this syntax
+DETAIL:  source SQL:
+ALTER TYPE test_type2 DROP ATTRIBUTE b CASCADE
+                                              ^
+HINT:  You have attempted to use a feature that is not yet implemented.
+See: https://go.crdb.dev/issue-v/48701/_version_
 \d test_type2
-        Composite type "public.test_type2"
- Column |  Type   | Collation | Nullable | Default 
---------+---------+-----------+----------+---------
- a      | integer |           |          | 
- c      | text    |           |          | 
-
+ERROR:  at or near ".": syntax error
+DETAIL:  source SQL:
+SELECT c.oid,
+  n.nspname,
+  c.relname
+FROM pg_catalog.pg_class c
+     LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace
+WHERE c.relname OPERATOR(pg_catalog.~) '^(test_type2)$' COLLATE pg_catalog.default
+                                                                          ^
 \d test_tbl2
-             Table "public.test_tbl2"
- Column |  Type   | Collation | Nullable | Default 
---------+---------+-----------+----------+---------
- a      | integer |           |          | 
- c      | text    |           |          | 
-Number of child tables: 1 (Use \d+ to list them.)
-Typed table of type: test_type2
-
+ERROR:  at or near ".": syntax error
+DETAIL:  source SQL:
+SELECT c.oid,
+  n.nspname,
+  c.relname
+FROM pg_catalog.pg_class c
+     LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace
+WHERE c.relname OPERATOR(pg_catalog.~) '^(test_tbl2)$' COLLATE pg_catalog.default
+                                                                         ^
 ALTER TYPE test_type2 RENAME ATTRIBUTE a TO aa; -- fails
-ERROR:  cannot alter type "test_type2" because it is the type of a typed table
-HINT:  Use ALTER ... CASCADE to alter the typed tables too.
+ERROR:  at or near "EOF": syntax error: unimplemented: this syntax
+DETAIL:  source SQL:
+ALTER TYPE test_type2 RENAME ATTRIBUTE a TO aa
+                                              ^
+HINT:  You have attempted to use a feature that is not yet implemented.
+See: https://go.crdb.dev/issue-v/48701/_version_
 ALTER TYPE test_type2 RENAME ATTRIBUTE a TO aa CASCADE;
+ERROR:  at or near "cascade": syntax error: unimplemented: this syntax
+DETAIL:  source SQL:
+ALTER TYPE test_type2 RENAME ATTRIBUTE a TO aa CASCADE
+                                               ^
+HINT:  You have attempted to use a feature that is not yet implemented.
+See: https://go.crdb.dev/issue-v/48701/_version_
 \d test_type2
-        Composite type "public.test_type2"
- Column |  Type   | Collation | Nullable | Default 
---------+---------+-----------+----------+---------
- aa     | integer |           |          | 
- c      | text    |           |          | 
-
+ERROR:  at or near ".": syntax error
+DETAIL:  source SQL:
+SELECT c.oid,
+  n.nspname,
+  c.relname
+FROM pg_catalog.pg_class c
+     LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace
+WHERE c.relname OPERATOR(pg_catalog.~) '^(test_type2)$' COLLATE pg_catalog.default
+                                                                          ^
 \d test_tbl2
-             Table "public.test_tbl2"
- Column |  Type   | Collation | Nullable | Default 
---------+---------+-----------+----------+---------
- aa     | integer |           |          | 
- c      | text    |           |          | 
-Number of child tables: 1 (Use \d+ to list them.)
-Typed table of type: test_type2
-
+ERROR:  at or near ".": syntax error
+DETAIL:  source SQL:
+SELECT c.oid,
+  n.nspname,
+  c.relname
+FROM pg_catalog.pg_class c
+     LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace
+WHERE c.relname OPERATOR(pg_catalog.~) '^(test_tbl2)$' COLLATE pg_catalog.default
+                                                                         ^
 \d test_tbl2_subclass
-         Table "public.test_tbl2_subclass"
- Column |  Type   | Collation | Nullable | Default 
---------+---------+-----------+----------+---------
- aa     | integer |           |          | 
- c      | text    |           |          | 
-Inherits: test_tbl2
-
+ERROR:  at or near ".": syntax error
+DETAIL:  source SQL:
+SELECT c.oid,
+  n.nspname,
+  c.relname
+FROM pg_catalog.pg_class c
+     LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace
+WHERE c.relname OPERATOR(pg_catalog.~) '^(test_tbl2_subclass)$' COLLATE pg_catalog.default
+                                                                                  ^
 DROP TABLE test_tbl2_subclass, test_tbl2;
+ERROR:  relation "test_tbl2_subclass" does not exist
 DROP TYPE test_type2;
 CREATE TYPE test_typex AS (a int, b text);
 CREATE TABLE test_tblx (x int, y test_typex check ((y).a > 0));
 ALTER TYPE test_typex DROP ATTRIBUTE a; -- fails
-ERROR:  cannot drop column a of composite type test_typex because other objects depend on it
-DETAIL:  constraint test_tblx_y_check on table test_tblx depends on column a of composite type test_typex
-HINT:  Use DROP ... CASCADE to drop the dependent objects too.
+ERROR:  at or near "EOF": syntax error: unimplemented: this syntax
+DETAIL:  source SQL:
+ALTER TYPE test_typex DROP ATTRIBUTE a
+                                      ^
+HINT:  You have attempted to use a feature that is not yet implemented.
+See: https://go.crdb.dev/issue-v/48701/_version_
 ALTER TYPE test_typex DROP ATTRIBUTE a CASCADE;
-NOTICE:  drop cascades to constraint test_tblx_y_check on table test_tblx
+ERROR:  at or near "EOF": syntax error: unimplemented: this syntax
+DETAIL:  source SQL:
+ALTER TYPE test_typex DROP ATTRIBUTE a CASCADE
+                                              ^
+HINT:  You have attempted to use a feature that is not yet implemented.
+See: https://go.crdb.dev/issue-v/48701/_version_
 \d test_tblx
-               Table "public.test_tblx"
- Column |    Type    | Collation | Nullable | Default 
---------+------------+-----------+----------+---------
- x      | integer    |           |          | 
- y      | test_typex |           |          | 
-
+ERROR:  at or near ".": syntax error
+DETAIL:  source SQL:
+SELECT c.oid,
+  n.nspname,
+  c.relname
+FROM pg_catalog.pg_class c
+     LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace
+WHERE c.relname OPERATOR(pg_catalog.~) '^(test_tblx)$' COLLATE pg_catalog.default
+                                                                         ^
 DROP TABLE test_tblx;
 DROP TYPE test_typex;
 -- This test isn't that interesting on its own, but the purpose is to leave
@@ -3239,7 +3947,14 @@
 -- column in it, and the composite type has a dropped attribute.
 CREATE TYPE test_type3 AS (a int);
 CREATE TABLE test_tbl3 (c) AS SELECT '(1)'::test_type3;
+NOTICE:  CREATE TABLE ... AS does not copy over indexes, default expressions, or constraints; the new table has a hidden rowid primary key column
 ALTER TYPE test_type3 DROP ATTRIBUTE a, ADD ATTRIBUTE b int;
+ERROR:  at or near "EOF": syntax error: unimplemented: this syntax
+DETAIL:  source SQL:
+ALTER TYPE test_type3 DROP ATTRIBUTE a, ADD ATTRIBUTE b int
+                                                           ^
+HINT:  You have attempted to use a feature that is not yet implemented.
+See: https://go.crdb.dev/issue-v/48701/_version_
 CREATE TYPE test_type_empty AS ();
 DROP TYPE test_type_empty;
 --
@@ -3247,6 +3962,12 @@
 --
 CREATE TYPE tt_t0 AS (z inet, x int, y numeric(8,2));
 ALTER TYPE tt_t0 DROP ATTRIBUTE z;
+ERROR:  at or near "EOF": syntax error: unimplemented: this syntax
+DETAIL:  source SQL:
+ALTER TYPE tt_t0 DROP ATTRIBUTE z
+                                 ^
+HINT:  You have attempted to use a feature that is not yet implemented.
+See: https://go.crdb.dev/issue-v/48701/_version_
 CREATE TABLE tt0 (x int NOT NULL, y numeric(8,2));	-- OK
 CREATE TABLE tt1 (x int, y bigint);					-- wrong base type
 CREATE TABLE tt2 (x int, y numeric(9,2));			-- wrong typmod
@@ -3254,76 +3975,128 @@
 CREATE TABLE tt4 (x int);							-- too few columns
 CREATE TABLE tt5 (x int, y numeric(8,2), z int);	-- too few columns
 CREATE TABLE tt6 () INHERITS (tt0);					-- can't have a parent
+ERROR:  at or near "(": syntax error: unimplemented: this syntax
+DETAIL:  source SQL:
+CREATE TABLE tt6 () INHERITS (tt0)
+                             ^
+HINT:  You have attempted to use a feature that is not yet implemented.
+See: https://go.crdb.dev/issue-v/22456/_version_
 CREATE TABLE tt7 (x int, q text, y numeric(8,2));
 ALTER TABLE tt7 DROP q;								-- OK
 ALTER TABLE tt0 OF tt_t0;
+ERROR:  at or near "of": syntax error
+DETAIL:  source SQL:
+ALTER TABLE tt0 OF tt_t0
+                ^
+HINT:  try \h ALTER TABLE
 ALTER TABLE tt1 OF tt_t0;
-ERROR:  table "tt1" has different type for column "y"
+ERROR:  at or near "of": syntax error
+DETAIL:  source SQL:
+ALTER TABLE tt1 OF tt_t0
+                ^
+HINT:  try \h ALTER TABLE
 ALTER TABLE tt2 OF tt_t0;
-ERROR:  table "tt2" has different type for column "y"
+ERROR:  at or near "of": syntax error
+DETAIL:  source SQL:
+ALTER TABLE tt2 OF tt_t0
+                ^
+HINT:  try \h ALTER TABLE
 ALTER TABLE tt3 OF tt_t0;
-ERROR:  table has column "y" where type requires "x"
+ERROR:  at or near "of": syntax error
+DETAIL:  source SQL:
+ALTER TABLE tt3 OF tt_t0
+                ^
+HINT:  try \h ALTER TABLE
 ALTER TABLE tt4 OF tt_t0;
-ERROR:  table is missing column "y"
+ERROR:  at or near "of": syntax error
+DETAIL:  source SQL:
+ALTER TABLE tt4 OF tt_t0
+                ^
+HINT:  try \h ALTER TABLE
 ALTER TABLE tt5 OF tt_t0;
-ERROR:  table has extra column "z"
+ERROR:  at or near "of": syntax error
+DETAIL:  source SQL:
+ALTER TABLE tt5 OF tt_t0
+                ^
+HINT:  try \h ALTER TABLE
 ALTER TABLE tt6 OF tt_t0;
-ERROR:  typed tables cannot inherit
+ERROR:  at or near "of": syntax error
+DETAIL:  source SQL:
+ALTER TABLE tt6 OF tt_t0
+                ^
+HINT:  try \h ALTER TABLE
 ALTER TABLE tt7 OF tt_t0;
+ERROR:  at or near "of": syntax error
+DETAIL:  source SQL:
+ALTER TABLE tt7 OF tt_t0
+                ^
+HINT:  try \h ALTER TABLE
 CREATE TYPE tt_t1 AS (x int, y numeric(8,2));
 ALTER TABLE tt7 OF tt_t1;			-- reassign an already-typed table
+ERROR:  at or near "of": syntax error
+DETAIL:  source SQL:
+ALTER TABLE tt7 OF tt_t1
+                ^
+HINT:  try \h ALTER TABLE
 ALTER TABLE tt7 NOT OF;
+ERROR:  at or near "not": syntax error
+DETAIL:  source SQL:
+ALTER TABLE tt7 NOT OF
+                ^
+HINT:  try \h ALTER TABLE
 \d tt7
-                   Table "public.tt7"
- Column |     Type     | Collation | Nullable | Default 
---------+--------------+-----------+----------+---------
- x      | integer      |           |          | 
- y      | numeric(8,2) |           |          | 
-
+ERROR:  at or near ".": syntax error
+DETAIL:  source SQL:
+SELECT c.oid,
+  n.nspname,
+  c.relname
+FROM pg_catalog.pg_class c
+     LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace
+WHERE c.relname OPERATOR(pg_catalog.~) '^(tt7)$' COLLATE pg_catalog.default
+                                                                   ^
 -- make sure we can drop a constraint on the parent but it remains on the child
 CREATE TABLE test_drop_constr_parent (c text CHECK (c IS NOT NULL));
 CREATE TABLE test_drop_constr_child () INHERITS (test_drop_constr_parent);
+ERROR:  at or near "(": syntax error: unimplemented: this syntax
+DETAIL:  source SQL:
+CREATE TABLE test_drop_constr_child () INHERITS (test_drop_constr_parent)
+                                                ^
+HINT:  You have attempted to use a feature that is not yet implemented.
+See: https://go.crdb.dev/issue-v/22456/_version_
 ALTER TABLE ONLY test_drop_constr_parent DROP CONSTRAINT "test_drop_constr_parent_c_check";
+ERROR:  constraint "test_drop_constr_parent_c_check" of relation "test_drop_constr_parent" does not exist
 -- should fail
 INSERT INTO test_drop_constr_child (c) VALUES (NULL);
-ERROR:  new row for relation "test_drop_constr_child" violates check constraint "test_drop_constr_parent_c_check"
-DETAIL:  Failing row contains (null).
+ERROR:  relation "test_drop_constr_child" does not exist
 DROP TABLE test_drop_constr_parent CASCADE;
-NOTICE:  drop cascades to table test_drop_constr_child
 --
 -- IF EXISTS test
 --
 ALTER TABLE IF EXISTS tt8 ADD COLUMN f int;
-NOTICE:  relation "tt8" does not exist, skipping
 ALTER TABLE IF EXISTS tt8 ADD CONSTRAINT xxx PRIMARY KEY(f);
-NOTICE:  relation "tt8" does not exist, skipping
 ALTER TABLE IF EXISTS tt8 ADD CHECK (f BETWEEN 0 AND 10);
-NOTICE:  relation "tt8" does not exist, skipping
 ALTER TABLE IF EXISTS tt8 ALTER COLUMN f SET DEFAULT 0;
-NOTICE:  relation "tt8" does not exist, skipping
 ALTER TABLE IF EXISTS tt8 RENAME COLUMN f TO f1;
-NOTICE:  relation "tt8" does not exist, skipping
 ALTER TABLE IF EXISTS tt8 SET SCHEMA alter2;
-NOTICE:  relation "tt8" does not exist, skipping
 CREATE TABLE tt8(a int);
 CREATE SCHEMA alter2;
 ALTER TABLE IF EXISTS tt8 ADD COLUMN f int;
 ALTER TABLE IF EXISTS tt8 ADD CONSTRAINT xxx PRIMARY KEY(f);
+ERROR:  cannot use nullable column "f" in primary key
 ALTER TABLE IF EXISTS tt8 ADD CHECK (f BETWEEN 0 AND 10);
 ALTER TABLE IF EXISTS tt8 ALTER COLUMN f SET DEFAULT 0;
 ALTER TABLE IF EXISTS tt8 RENAME COLUMN f TO f1;
 ALTER TABLE IF EXISTS tt8 SET SCHEMA alter2;
 \d alter2.tt8
-                Table "alter2.tt8"
- Column |  Type   | Collation | Nullable | Default 
---------+---------+-----------+----------+---------
- a      | integer |           |          | 
- f1     | integer |           | not null | 0
-Indexes:
-    "xxx" PRIMARY KEY, btree (f1)
-Check constraints:
-    "tt8_f_check" CHECK (f1 >= 0 AND f1 <= 10)
-
+ERROR:  at or near ".": syntax error
+DETAIL:  source SQL:
+SELECT c.oid,
+  n.nspname,
+  c.relname
+FROM pg_catalog.pg_class c
+     LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace
+WHERE c.relname OPERATOR(pg_catalog.~) '^(tt8)$' COLLATE pg_catalog.default
+                                                                   ^
 DROP TABLE alter2.tt8;
 DROP SCHEMA alter2;
 --
@@ -3334,32 +4107,28 @@
 ALTER TABLE tt9 ADD CHECK(c > 2);  -- picks nonconflicting name
 ALTER TABLE tt9 ADD CONSTRAINT foo CHECK(c > 3);
 ALTER TABLE tt9 ADD CONSTRAINT foo CHECK(c > 4);  -- fail, dup name
-ERROR:  constraint "foo" for relation "tt9" already exists
+ERROR:  duplicate constraint name: "foo"
 ALTER TABLE tt9 ADD UNIQUE(c);
 ALTER TABLE tt9 ADD UNIQUE(c);  -- picks nonconflicting name
 ALTER TABLE tt9 ADD CONSTRAINT tt9_c_key UNIQUE(c);  -- fail, dup name
-ERROR:  relation "tt9_c_key" already exists
+ERROR:  index with name "tt9_c_key" already exists
 ALTER TABLE tt9 ADD CONSTRAINT foo UNIQUE(c);  -- fail, dup name
-ERROR:  constraint "foo" for relation "tt9" already exists
+ERROR:  error executing StatementPhase stage 1 of 1 with 7 MutationType ops: relation "tt9" (2079): duplicate constraint name: "foo"
 ALTER TABLE tt9 ADD CONSTRAINT tt9_c_key CHECK(c > 5);  -- fail, dup name
-ERROR:  constraint "tt9_c_key" for relation "tt9" already exists
+ERROR:  error executing StatementPhase stage 1 of 1 with 2 MutationType ops: relation "tt9" (2079): duplicate constraint name: "tt9_c_key"
 ALTER TABLE tt9 ADD CONSTRAINT tt9_c_key2 CHECK(c > 6);
 ALTER TABLE tt9 ADD UNIQUE(c);  -- picks nonconflicting name
+ERROR:  error executing StatementPhase stage 1 of 1 with 7 MutationType ops: relation "tt9" (2079): duplicate constraint name: "tt9_c_key2"
 \d tt9
-                Table "public.tt9"
- Column |  Type   | Collation | Nullable | Default 
---------+---------+-----------+----------+---------
- c      | integer |           |          | 
-Indexes:
-    "tt9_c_key" UNIQUE CONSTRAINT, btree (c)
-    "tt9_c_key1" UNIQUE CONSTRAINT, btree (c)
-    "tt9_c_key3" UNIQUE CONSTRAINT, btree (c)
-Check constraints:
-    "foo" CHECK (c > 3)
-    "tt9_c_check" CHECK (c > 1)
-    "tt9_c_check1" CHECK (c > 2)
-    "tt9_c_key2" CHECK (c > 6)
-
+ERROR:  at or near ".": syntax error
+DETAIL:  source SQL:
+SELECT c.oid,
+  n.nspname,
+  c.relname
+FROM pg_catalog.pg_class c
+     LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace
+WHERE c.relname OPERATOR(pg_catalog.~) '^(tt9)$' COLLATE pg_catalog.default
+                                                                   ^
 DROP TABLE tt9;
 -- Check that comments on constraints and indexes are not lost at ALTER TABLE.
 CREATE TABLE comment_test (
@@ -3371,6 +4140,7 @@
 COMMENT ON COLUMN comment_test.id IS 'Column ''id'' on comment_test';
 COMMENT ON INDEX comment_test_index IS 'Simple index on comment_test';
 COMMENT ON CONSTRAINT comment_test_positive_col_check ON comment_test IS 'CHECK constraint on comment_test.positive_col';
+ERROR:  constraint "comment_test_positive_col_check" of relation "comment_test" does not exist
 COMMENT ON CONSTRAINT comment_test_pk ON comment_test IS 'PRIMARY KEY constraint of comment_test';
 COMMENT ON INDEX comment_test_pk IS 'Index backing the PRIMARY KEY of comment_test';
 SELECT col_description('comment_test'::regclass, 1) as comment;
@@ -3387,10 +4157,10 @@
 (2 rows)
 
 SELECT conname as constraint, obj_description(oid, 'pg_constraint') as comment FROM pg_constraint where conrelid = 'comment_test'::regclass ORDER BY 1, 2;
-           constraint            |                    comment                    
----------------------------------+-----------------------------------------------
- comment_test_pk                 | PRIMARY KEY constraint of comment_test
- comment_test_positive_col_check | CHECK constraint on comment_test.positive_col
+     constraint     |                comment                 
+--------------------+----------------------------------------
+ check_positive_col | 
+ comment_test_pk    | PRIMARY KEY constraint of comment_test
 (2 rows)
 
 -- Change the datatype of all the columns. ALTER TABLE is optimized to not
@@ -3399,8 +4169,18 @@
 -- first, to test that no-op codepath, and another one that does.
 ALTER TABLE comment_test ALTER COLUMN indexed_col SET DATA TYPE int;
 ALTER TABLE comment_test ALTER COLUMN indexed_col SET DATA TYPE text;
+ERROR:  unimplemented: ALTER COLUMN TYPE requiring rewrite of on-disk data is currently not supported for columns that are part of an index
+HINT:  You have attempted to use a feature that is not yet implemented.
+See: https://go.crdb.dev/issue-v/47636/_version_
+--
+Consider modifying the index.
 ALTER TABLE comment_test ALTER COLUMN id SET DATA TYPE int;
 ALTER TABLE comment_test ALTER COLUMN id SET DATA TYPE text;
+ERROR:  unimplemented: ALTER COLUMN TYPE requiring rewrite of on-disk data is currently not supported for columns that are part of an index
+HINT:  You have attempted to use a feature that is not yet implemented.
+See: https://go.crdb.dev/issue-v/47636/_version_
+--
+Consider modifying the index.
 ALTER TABLE comment_test ALTER COLUMN positive_col SET DATA TYPE int;
 ALTER TABLE comment_test ALTER COLUMN positive_col SET DATA TYPE bigint;
 -- Check that the comments are intact.
@@ -3418,10 +4198,10 @@
 (2 rows)
 
 SELECT conname as constraint, obj_description(oid, 'pg_constraint') as comment FROM pg_constraint where conrelid = 'comment_test'::regclass ORDER BY 1, 2;
-           constraint            |                    comment                    
----------------------------------+-----------------------------------------------
- comment_test_pk                 | PRIMARY KEY constraint of comment_test
- comment_test_positive_col_check | CHECK constraint on comment_test.positive_col
+     constraint     |                comment                 
+--------------------+----------------------------------------
+ check_positive_col | 
+ comment_test_pk    | PRIMARY KEY constraint of comment_test
 (2 rows)
 
 -- Check compatibility for foreign keys and comments. This is done
@@ -3429,34 +4209,35 @@
 -- to an error and would reduce the test scope.
 CREATE TABLE comment_test_child (
   id text CONSTRAINT comment_test_child_fk REFERENCES comment_test);
+ERROR:  type of "id" (string) does not match foreign key "comment_test"."id" (int)
 CREATE INDEX comment_test_child_fk ON comment_test_child(id);
+ERROR:  relation "comment_test_child" does not exist
 COMMENT ON COLUMN comment_test_child.id IS 'Column ''id'' on comment_test_child';
+ERROR:  relation "comment_test_child" does not exist
 COMMENT ON INDEX comment_test_child_fk IS 'Index backing the FOREIGN KEY of comment_test_child';
+ERROR:  index "comment_test_child_fk" does not exist
 COMMENT ON CONSTRAINT comment_test_child_fk ON comment_test_child IS 'FOREIGN KEY constraint of comment_test_child';
+ERROR:  relation "comment_test_child" does not exist
 -- Change column type of parent
 ALTER TABLE comment_test ALTER COLUMN id SET DATA TYPE text;
+ERROR:  unimplemented: ALTER COLUMN TYPE requiring rewrite of on-disk data is currently not supported for columns that are part of an index
+HINT:  You have attempted to use a feature that is not yet implemented.
+See: https://go.crdb.dev/issue-v/47636/_version_
+--
+Consider modifying the index.
 ALTER TABLE comment_test ALTER COLUMN id SET DATA TYPE int USING id::integer;
-ERROR:  foreign key constraint "comment_test_child_fk" cannot be implemented
-DETAIL:  Key columns "id" and "id" are of incompatible types: text and integer.
+ERROR:  unimplemented: ALTER COLUMN TYPE requiring rewrite of on-disk data is currently not supported for columns that are part of an index
+HINT:  You have attempted to use a feature that is not yet implemented.
+See: https://go.crdb.dev/issue-v/47636/_version_
+--
+Consider modifying the index.
 -- Comments should be intact
 SELECT col_description('comment_test_child'::regclass, 1) as comment;
-              comment              
------------------------------------
- Column 'id' on comment_test_child
-(1 row)
-
+ERROR:  relation "comment_test_child" does not exist
 SELECT indexrelid::regclass::text as index, obj_description(indexrelid, 'pg_class') as comment FROM pg_index where indrelid = 'comment_test_child'::regclass ORDER BY 1, 2;
-         index         |                       comment                       
------------------------+-----------------------------------------------------
- comment_test_child_fk | Index backing the FOREIGN KEY of comment_test_child
-(1 row)
-
+ERROR:  relation "comment_test_child" does not exist
 SELECT conname as constraint, obj_description(oid, 'pg_constraint') as comment FROM pg_constraint where conrelid = 'comment_test_child'::regclass ORDER BY 1, 2;
-      constraint       |                   comment                    
------------------------+----------------------------------------------
- comment_test_child_fk | FOREIGN KEY constraint of comment_test_child
-(1 row)
-
+ERROR:  relation "comment_test_child" does not exist
 -- Check that we map relation oids to filenodes and back correctly.  Only
 -- display bad mappings so the test output doesn't change all the time.  A
 -- filenode function call can return NULL for a relation dropped concurrently
@@ -3468,31 +4249,28 @@
 FROM pg_class,
     pg_filenode_relation(reltablespace, pg_relation_filenode(oid)) AS mapped_oid
 WHERE relkind IN ('r', 'i', 'S', 't', 'm') AND mapped_oid IS DISTINCT FROM oid;
+ERROR:  unknown function: pg_filenode_relation()
 SELECT m.* FROM filenode_mapping m LEFT JOIN pg_class c ON c.oid = m.oid
 WHERE c.oid IS NOT NULL OR m.mapped_oid IS NOT NULL;
- oid | mapped_oid | reltablespace | relfilenode | relname 
------+------------+---------------+-------------+---------
-(0 rows)
-
+ERROR:  relation "filenode_mapping" does not exist
 -- Checks on creating and manipulation of user defined relations in
 -- pg_catalog.
 SHOW allow_system_table_mods;
- allow_system_table_mods 
--------------------------
- off
-(1 row)
-
+ERROR:  unrecognized configuration parameter "allow_system_table_mods"
 -- disallowed because of search_path issues with pg_dump
 CREATE TABLE pg_catalog.new_system_table();
-ERROR:  permission denied to create "pg_catalog.new_system_table"
-DETAIL:  System catalog modifications are currently disallowed.
+ERROR:  schema cannot be modified: "pg_catalog"
 -- instead create in public first, move to catalog
 CREATE TABLE new_system_table(id serial primary key, othercol text);
+NOTICE:  using sequential values in a primary key does not perform as well as using random UUIDs. See https://www.cockroachlabs.com/docs/_version_/serial.html
 ALTER TABLE new_system_table SET SCHEMA pg_catalog;
+ERROR:  cannot move objects into or out of virtual schemas
 ALTER TABLE new_system_table SET SCHEMA public;
 ALTER TABLE new_system_table SET SCHEMA pg_catalog;
+ERROR:  cannot move objects into or out of virtual schemas
 -- will be ignored -- already there:
 ALTER TABLE new_system_table SET SCHEMA pg_catalog;
+ERROR:  cannot move objects into or out of virtual schemas
 ALTER TABLE new_system_table RENAME TO old_system_table;
 CREATE INDEX old_system_table__othercol ON old_system_table (othercol);
 INSERT INTO old_system_table(othercol) VALUES ('somedata'), ('otherdata');
@@ -3500,10 +4278,16 @@
 DELETE FROM old_system_table WHERE othercol = 'somedata';
 TRUNCATE old_system_table;
 ALTER TABLE old_system_table DROP CONSTRAINT new_system_table_pkey;
+ERROR:  relation "old_system_table": unimplemented: primary key dropped without subsequent addition of new primary key in same transaction
+HINT:  You have attempted to use a feature that is not yet implemented.
+See: https://go.crdb.dev/issue-v/48026/_version_
 ALTER TABLE old_system_table DROP COLUMN othercol;
+NOTICE:  dropping index "old_system_table__othercol" which depends on column "othercol"
 DROP TABLE old_system_table;
 -- set logged
 CREATE UNLOGGED TABLE unlogged1(f1 SERIAL PRIMARY KEY, f2 TEXT); -- has sequence, toast
+NOTICE:  using sequential values in a primary key does not perform as well as using random UUIDs. See https://www.cockroachlabs.com/docs/_version_/serial.html
+NOTICE:  UNLOGGED TABLE will behave as a regular table in CockroachDB
 -- check relpersistence of an unlogged table
 SELECT relname, relkind, relpersistence FROM pg_class WHERE relname ~ '^unlogged1'
 UNION ALL
@@ -3511,21 +4295,36 @@
 UNION ALL
 SELECT r.relname || ' toast index', ri.relkind, ri.relpersistence FROM pg_class r join pg_class t ON t.oid = r.reltoastrelid JOIN pg_index i ON i.indrelid = t.oid JOIN pg_class ri ON ri.oid = i.indexrelid WHERE r.relname ~ '^unlogged1'
 ORDER BY relname;
-        relname        | relkind | relpersistence 
------------------------+---------+----------------
- unlogged1             | r       | u
- unlogged1 toast index | i       | u
- unlogged1 toast table | t       | u
- unlogged1_f1_seq      | S       | u
- unlogged1_pkey        | i       | u
-(5 rows)
+    relname     | relkind | relpersistence 
+----------------+---------+----------------
+ unlogged1      | r       | p
+ unlogged1_pkey | i       | p
+(2 rows)
 
 CREATE UNLOGGED TABLE unlogged2(f1 SERIAL PRIMARY KEY, f2 INTEGER REFERENCES unlogged1); -- foreign key
+NOTICE:  using sequential values in a primary key does not perform as well as using random UUIDs. See https://www.cockroachlabs.com/docs/_version_/serial.html
+NOTICE:  UNLOGGED TABLE will behave as a regular table in CockroachDB
 CREATE UNLOGGED TABLE unlogged3(f1 SERIAL PRIMARY KEY, f2 INTEGER REFERENCES unlogged3); -- self-referencing foreign key
+NOTICE:  using sequential values in a primary key does not perform as well as using random UUIDs. See https://www.cockroachlabs.com/docs/_version_/serial.html
+NOTICE:  UNLOGGED TABLE will behave as a regular table in CockroachDB
 ALTER TABLE unlogged3 SET LOGGED; -- skip self-referencing foreign key
+ERROR:  at or near "logged": syntax error
+DETAIL:  source SQL:
+ALTER TABLE unlogged3 SET LOGGED
+                          ^
+HINT:  try \h ALTER TABLE
 ALTER TABLE unlogged2 SET LOGGED; -- fails because a foreign key to an unlogged table exists
-ERROR:  could not change table "unlogged2" to logged because it references unlogged table "unlogged1"
+ERROR:  at or near "logged": syntax error
+DETAIL:  source SQL:
+ALTER TABLE unlogged2 SET LOGGED
+                          ^
+HINT:  try \h ALTER TABLE
 ALTER TABLE unlogged1 SET LOGGED;
+ERROR:  at or near "logged": syntax error
+DETAIL:  source SQL:
+ALTER TABLE unlogged1 SET LOGGED
+                          ^
+HINT:  try \h ALTER TABLE
 -- check relpersistence of an unlogged table after changing to permanent
 SELECT relname, relkind, relpersistence FROM pg_class WHERE relname ~ '^unlogged1'
 UNION ALL
@@ -3533,21 +4332,24 @@
 UNION ALL
 SELECT r.relname || ' toast index', ri.relkind, ri.relpersistence FROM pg_class r join pg_class t ON t.oid = r.reltoastrelid JOIN pg_index i ON i.indrelid = t.oid JOIN pg_class ri ON ri.oid = i.indexrelid WHERE r.relname ~ '^unlogged1'
 ORDER BY relname;
-        relname        | relkind | relpersistence 
------------------------+---------+----------------
- unlogged1             | r       | p
- unlogged1 toast index | i       | p
- unlogged1 toast table | t       | p
- unlogged1_f1_seq      | S       | p
- unlogged1_pkey        | i       | p
-(5 rows)
+    relname     | relkind | relpersistence 
+----------------+---------+----------------
+ unlogged1      | r       | p
+ unlogged1_pkey | i       | p
+(2 rows)
 
 ALTER TABLE unlogged1 SET LOGGED; -- silently do nothing
+ERROR:  at or near "logged": syntax error
+DETAIL:  source SQL:
+ALTER TABLE unlogged1 SET LOGGED
+                          ^
+HINT:  try \h ALTER TABLE
 DROP TABLE unlogged3;
 DROP TABLE unlogged2;
 DROP TABLE unlogged1;
 -- set unlogged
 CREATE TABLE logged1(f1 SERIAL PRIMARY KEY, f2 TEXT); -- has sequence, toast
+NOTICE:  using sequential values in a primary key does not perform as well as using random UUIDs. See https://www.cockroachlabs.com/docs/_version_/serial.html
 -- check relpersistence of a permanent table
 SELECT relname, relkind, relpersistence FROM pg_class WHERE relname ~ '^logged1'
 UNION ALL
@@ -3555,22 +4357,40 @@
 UNION ALL
 SELECT r.relname ||' toast index', ri.relkind, ri.relpersistence FROM pg_class r join pg_class t ON t.oid = r.reltoastrelid JOIN pg_index i ON i.indrelid = t.oid JOIN pg_class ri ON ri.oid = i.indexrelid WHERE r.relname ~ '^logged1'
 ORDER BY relname;
-       relname       | relkind | relpersistence 
----------------------+---------+----------------
- logged1             | r       | p
- logged1 toast index | i       | p
- logged1 toast table | t       | p
- logged1_f1_seq      | S       | p
- logged1_pkey        | i       | p
-(5 rows)
+   relname    | relkind | relpersistence 
+--------------+---------+----------------
+ logged1      | r       | p
+ logged1_pkey | i       | p
+(2 rows)
 
 CREATE TABLE logged2(f1 SERIAL PRIMARY KEY, f2 INTEGER REFERENCES logged1); -- foreign key
+NOTICE:  using sequential values in a primary key does not perform as well as using random UUIDs. See https://www.cockroachlabs.com/docs/_version_/serial.html
 CREATE TABLE logged3(f1 SERIAL PRIMARY KEY, f2 INTEGER REFERENCES logged3); -- self-referencing foreign key
+NOTICE:  using sequential values in a primary key does not perform as well as using random UUIDs. See https://www.cockroachlabs.com/docs/_version_/serial.html
 ALTER TABLE logged1 SET UNLOGGED; -- fails because a foreign key from a permanent table exists
-ERROR:  could not change table "logged1" to unlogged because it references logged table "logged2"
+ERROR:  at or near "unlogged": syntax error
+DETAIL:  source SQL:
+ALTER TABLE logged1 SET UNLOGGED
+                        ^
+HINT:  try \h ALTER TABLE
 ALTER TABLE logged3 SET UNLOGGED; -- skip self-referencing foreign key
+ERROR:  at or near "unlogged": syntax error
+DETAIL:  source SQL:
+ALTER TABLE logged3 SET UNLOGGED
+                        ^
+HINT:  try \h ALTER TABLE
 ALTER TABLE logged2 SET UNLOGGED;
+ERROR:  at or near "unlogged": syntax error
+DETAIL:  source SQL:
+ALTER TABLE logged2 SET UNLOGGED
+                        ^
+HINT:  try \h ALTER TABLE
 ALTER TABLE logged1 SET UNLOGGED;
+ERROR:  at or near "unlogged": syntax error
+DETAIL:  source SQL:
+ALTER TABLE logged1 SET UNLOGGED
+                        ^
+HINT:  try \h ALTER TABLE
 -- check relpersistence of a permanent table after changing to unlogged
 SELECT relname, relkind, relpersistence FROM pg_class WHERE relname ~ '^logged1'
 UNION ALL
@@ -3578,36 +4398,45 @@
 UNION ALL
 SELECT r.relname || ' toast index', ri.relkind, ri.relpersistence FROM pg_class r join pg_class t ON t.oid = r.reltoastrelid JOIN pg_index i ON i.indrelid = t.oid JOIN pg_class ri ON ri.oid = i.indexrelid WHERE r.relname ~ '^logged1'
 ORDER BY relname;
-       relname       | relkind | relpersistence 
----------------------+---------+----------------
- logged1             | r       | u
- logged1 toast index | i       | u
- logged1 toast table | t       | u
- logged1_f1_seq      | S       | u
- logged1_pkey        | i       | u
-(5 rows)
+   relname    | relkind | relpersistence 
+--------------+---------+----------------
+ logged1      | r       | p
+ logged1_pkey | i       | p
+(2 rows)
 
 ALTER TABLE logged1 SET UNLOGGED; -- silently do nothing
+ERROR:  at or near "unlogged": syntax error
+DETAIL:  source SQL:
+ALTER TABLE logged1 SET UNLOGGED
+                        ^
+HINT:  try \h ALTER TABLE
 DROP TABLE logged3;
 DROP TABLE logged2;
 DROP TABLE logged1;
 -- test ADD COLUMN IF NOT EXISTS
 CREATE TABLE test_add_column(c1 integer);
 \d test_add_column
-          Table "public.test_add_column"
- Column |  Type   | Collation | Nullable | Default 
---------+---------+-----------+----------+---------
- c1     | integer |           |          | 
-
+ERROR:  at or near ".": syntax error
+DETAIL:  source SQL:
+SELECT c.oid,
+  n.nspname,
+  c.relname
+FROM pg_catalog.pg_class c
+     LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace
+WHERE c.relname OPERATOR(pg_catalog.~) '^(test_add_column)$' COLLATE pg_catalog.default
+                                                                               ^
 ALTER TABLE test_add_column
 	ADD COLUMN c2 integer;
 \d test_add_column
-          Table "public.test_add_column"
- Column |  Type   | Collation | Nullable | Default 
---------+---------+-----------+----------+---------
- c1     | integer |           |          | 
- c2     | integer |           |          | 
-
+ERROR:  at or near ".": syntax error
+DETAIL:  source SQL:
+SELECT c.oid,
+  n.nspname,
+  c.relname
+FROM pg_catalog.pg_class c
+     LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace
+WHERE c.relname OPERATOR(pg_catalog.~) '^(test_add_column)$' COLLATE pg_catalog.default
+                                                                               ^
 ALTER TABLE test_add_column
 	ADD COLUMN c2 integer; -- fail because c2 already exists
 ERROR:  column "c2" of relation "test_add_column" already exists
@@ -3615,159 +4444,132 @@
 	ADD COLUMN c2 integer; -- fail because c2 already exists
 ERROR:  column "c2" of relation "test_add_column" already exists
 \d test_add_column
-          Table "public.test_add_column"
- Column |  Type   | Collation | Nullable | Default 
---------+---------+-----------+----------+---------
- c1     | integer |           |          | 
- c2     | integer |           |          | 
-
+ERROR:  at or near ".": syntax error
+DETAIL:  source SQL:
+SELECT c.oid,
+  n.nspname,
+  c.relname
+FROM pg_catalog.pg_class c
+     LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace
+WHERE c.relname OPERATOR(pg_catalog.~) '^(test_add_column)$' COLLATE pg_catalog.default
+                                                                               ^
 ALTER TABLE test_add_column
 	ADD COLUMN IF NOT EXISTS c2 integer; -- skipping because c2 already exists
-NOTICE:  column "c2" of relation "test_add_column" already exists, skipping
 ALTER TABLE ONLY test_add_column
 	ADD COLUMN IF NOT EXISTS c2 integer; -- skipping because c2 already exists
-NOTICE:  column "c2" of relation "test_add_column" already exists, skipping
 \d test_add_column
-          Table "public.test_add_column"
- Column |  Type   | Collation | Nullable | Default 
---------+---------+-----------+----------+---------
- c1     | integer |           |          | 
- c2     | integer |           |          | 
-
+ERROR:  at or near ".": syntax error
+DETAIL:  source SQL:
+SELECT c.oid,
+  n.nspname,
+  c.relname
+FROM pg_catalog.pg_class c
+     LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace
+WHERE c.relname OPERATOR(pg_catalog.~) '^(test_add_column)$' COLLATE pg_catalog.default
+                                                                               ^
 ALTER TABLE test_add_column
 	ADD COLUMN c2 integer, -- fail because c2 already exists
 	ADD COLUMN c3 integer primary key;
 ERROR:  column "c2" of relation "test_add_column" already exists
 \d test_add_column
-          Table "public.test_add_column"
- Column |  Type   | Collation | Nullable | Default 
---------+---------+-----------+----------+---------
- c1     | integer |           |          | 
- c2     | integer |           |          | 
-
+ERROR:  at or near ".": syntax error
+DETAIL:  source SQL:
+SELECT c.oid,
+  n.nspname,
+  c.relname
+FROM pg_catalog.pg_class c
+     LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace
+WHERE c.relname OPERATOR(pg_catalog.~) '^(test_add_column)$' COLLATE pg_catalog.default
+                                                                               ^
 ALTER TABLE test_add_column
 	ADD COLUMN IF NOT EXISTS c2 integer, -- skipping because c2 already exists
 	ADD COLUMN c3 integer primary key;
-NOTICE:  column "c2" of relation "test_add_column" already exists, skipping
+ERROR:  multiple primary keys for table "test_add_column" are not allowed
 \d test_add_column
-          Table "public.test_add_column"
- Column |  Type   | Collation | Nullable | Default 
---------+---------+-----------+----------+---------
- c1     | integer |           |          | 
- c2     | integer |           |          | 
- c3     | integer |           | not null | 
-Indexes:
-    "test_add_column_pkey" PRIMARY KEY, btree (c3)
-
+ERROR:  at or near ".": syntax error
+DETAIL:  source SQL:
+SELECT c.oid,
+  n.nspname,
+  c.relname
+FROM pg_catalog.pg_class c
+     LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace
+WHERE c.relname OPERATOR(pg_catalog.~) '^(test_add_column)$' COLLATE pg_catalog.default
+                                                                               ^
 ALTER TABLE test_add_column
 	ADD COLUMN IF NOT EXISTS c2 integer, -- skipping because c2 already exists
 	ADD COLUMN IF NOT EXISTS c3 integer primary key; -- skipping because c3 already exists
-NOTICE:  column "c2" of relation "test_add_column" already exists, skipping
-NOTICE:  column "c3" of relation "test_add_column" already exists, skipping
+ERROR:  multiple primary keys for table "test_add_column" are not allowed
 \d test_add_column
-          Table "public.test_add_column"
- Column |  Type   | Collation | Nullable | Default 
---------+---------+-----------+----------+---------
- c1     | integer |           |          | 
- c2     | integer |           |          | 
- c3     | integer |           | not null | 
-Indexes:
-    "test_add_column_pkey" PRIMARY KEY, btree (c3)
-
+ERROR:  at or near ".": syntax error
+DETAIL:  source SQL:
+SELECT c.oid,
+  n.nspname,
+  c.relname
+FROM pg_catalog.pg_class c
+     LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace
+WHERE c.relname OPERATOR(pg_catalog.~) '^(test_add_column)$' COLLATE pg_catalog.default
+                                                                               ^
 ALTER TABLE test_add_column
 	ADD COLUMN IF NOT EXISTS c2 integer, -- skipping because c2 already exists
 	ADD COLUMN IF NOT EXISTS c3 integer, -- skipping because c3 already exists
 	ADD COLUMN c4 integer REFERENCES test_add_column;
-NOTICE:  column "c2" of relation "test_add_column" already exists, skipping
-NOTICE:  column "c3" of relation "test_add_column" already exists, skipping
 \d test_add_column
-          Table "public.test_add_column"
- Column |  Type   | Collation | Nullable | Default 
---------+---------+-----------+----------+---------
- c1     | integer |           |          | 
- c2     | integer |           |          | 
- c3     | integer |           | not null | 
- c4     | integer |           |          | 
-Indexes:
-    "test_add_column_pkey" PRIMARY KEY, btree (c3)
-Foreign-key constraints:
-    "test_add_column_c4_fkey" FOREIGN KEY (c4) REFERENCES test_add_column(c3)
-Referenced by:
-    TABLE "test_add_column" CONSTRAINT "test_add_column_c4_fkey" FOREIGN KEY (c4) REFERENCES test_add_column(c3)
-
+ERROR:  at or near ".": syntax error
+DETAIL:  source SQL:
+SELECT c.oid,
+  n.nspname,
+  c.relname
+FROM pg_catalog.pg_class c
+     LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace
+WHERE c.relname OPERATOR(pg_catalog.~) '^(test_add_column)$' COLLATE pg_catalog.default
+                                                                               ^
 ALTER TABLE test_add_column
 	ADD COLUMN IF NOT EXISTS c4 integer REFERENCES test_add_column;
-NOTICE:  column "c4" of relation "test_add_column" already exists, skipping
 \d test_add_column
-          Table "public.test_add_column"
- Column |  Type   | Collation | Nullable | Default 
---------+---------+-----------+----------+---------
- c1     | integer |           |          | 
- c2     | integer |           |          | 
- c3     | integer |           | not null | 
- c4     | integer |           |          | 
-Indexes:
-    "test_add_column_pkey" PRIMARY KEY, btree (c3)
-Foreign-key constraints:
-    "test_add_column_c4_fkey" FOREIGN KEY (c4) REFERENCES test_add_column(c3)
-Referenced by:
-    TABLE "test_add_column" CONSTRAINT "test_add_column_c4_fkey" FOREIGN KEY (c4) REFERENCES test_add_column(c3)
-
+ERROR:  at or near ".": syntax error
+DETAIL:  source SQL:
+SELECT c.oid,
+  n.nspname,
+  c.relname
+FROM pg_catalog.pg_class c
+     LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace
+WHERE c.relname OPERATOR(pg_catalog.~) '^(test_add_column)$' COLLATE pg_catalog.default
+                                                                               ^
 ALTER TABLE test_add_column
 	ADD COLUMN IF NOT EXISTS c5 SERIAL CHECK (c5 > 8);
 \d test_add_column
-                            Table "public.test_add_column"
- Column |  Type   | Collation | Nullable |                   Default                   
---------+---------+-----------+----------+---------------------------------------------
- c1     | integer |           |          | 
- c2     | integer |           |          | 
- c3     | integer |           | not null | 
- c4     | integer |           |          | 
- c5     | integer |           | not null | nextval('test_add_column_c5_seq'::regclass)
-Indexes:
-    "test_add_column_pkey" PRIMARY KEY, btree (c3)
-Check constraints:
-    "test_add_column_c5_check" CHECK (c5 > 8)
-Foreign-key constraints:
-    "test_add_column_c4_fkey" FOREIGN KEY (c4) REFERENCES test_add_column(c3)
-Referenced by:
-    TABLE "test_add_column" CONSTRAINT "test_add_column_c4_fkey" FOREIGN KEY (c4) REFERENCES test_add_column(c3)
-
+ERROR:  at or near ".": syntax error
+DETAIL:  source SQL:
+SELECT c.oid,
+  n.nspname,
+  c.relname
+FROM pg_catalog.pg_class c
+     LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace
+WHERE c.relname OPERATOR(pg_catalog.~) '^(test_add_column)$' COLLATE pg_catalog.default
+                                                                               ^
 ALTER TABLE test_add_column
 	ADD COLUMN IF NOT EXISTS c5 SERIAL CHECK (c5 > 10);
-NOTICE:  column "c5" of relation "test_add_column" already exists, skipping
 \d test_add_column*
-                            Table "public.test_add_column"
- Column |  Type   | Collation | Nullable |                   Default                   
---------+---------+-----------+----------+---------------------------------------------
- c1     | integer |           |          | 
- c2     | integer |           |          | 
- c3     | integer |           | not null | 
- c4     | integer |           |          | 
- c5     | integer |           | not null | nextval('test_add_column_c5_seq'::regclass)
-Indexes:
-    "test_add_column_pkey" PRIMARY KEY, btree (c3)
-Check constraints:
-    "test_add_column_c5_check" CHECK (c5 > 8)
-Foreign-key constraints:
-    "test_add_column_c4_fkey" FOREIGN KEY (c4) REFERENCES test_add_column(c3)
-Referenced by:
-    TABLE "test_add_column" CONSTRAINT "test_add_column_c4_fkey" FOREIGN KEY (c4) REFERENCES test_add_column(c3)
-
-               Sequence "public.test_add_column_c5_seq"
-  Type   | Start | Minimum |  Maximum   | Increment | Cycles? | Cache 
----------+-------+---------+------------+-----------+---------+-------
- integer |     1 |       1 | 2147483647 |         1 | no      |     1
-Owned by: public.test_add_column.c5
-
- Index "public.test_add_column_pkey"
- Column |  Type   | Key? | Definition 
---------+---------+------+------------
- c3     | integer | yes  | c3
-primary key, btree, for table "public.test_add_column"
-
+ERROR:  at or near ".": syntax error
+DETAIL:  source SQL:
+SELECT c.oid,
+  n.nspname,
+  c.relname
+FROM pg_catalog.pg_class c
+     LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace
+WHERE c.relname OPERATOR(pg_catalog.~) '^(test_add_column.*)$' COLLATE pg_catalog.default
+                                                                                 ^
 DROP TABLE test_add_column;
 \d test_add_column*
+ERROR:  at or near ".": syntax error
+DETAIL:  source SQL:
+SELECT c.oid,
+  n.nspname,
+  c.relname
+FROM pg_catalog.pg_class c
+     LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace
+WHERE c.relname OPERATOR(pg_catalog.~) '^(test_add_column.*)$' COLLATE pg_catalog.default
+                                                                                 ^
 -- assorted cases with multiple ALTER TABLE steps
 CREATE TABLE ataddindex(f1 INT);
 INSERT INTO ataddindex VALUES (42), (43);
@@ -3775,100 +4577,134 @@
 ALTER TABLE ataddindex
   ADD PRIMARY KEY USING INDEX ataddindexi0,
   ALTER f1 TYPE BIGINT;
+ERROR:  at or near "using": syntax error
+DETAIL:  source SQL:
+ALTER TABLE ataddindex
+  ADD PRIMARY KEY USING INDEX ataddindexi0,
+                  ^
+HINT:  try \h ALTER TABLE
 \d ataddindex
-            Table "public.ataddindex"
- Column |  Type  | Collation | Nullable | Default 
---------+--------+-----------+----------+---------
- f1     | bigint |           | not null | 
-Indexes:
-    "ataddindexi0" PRIMARY KEY, btree (f1)
-
+ERROR:  at or near ".": syntax error
+DETAIL:  source SQL:
+SELECT c.oid,
+  n.nspname,
+  c.relname
+FROM pg_catalog.pg_class c
+     LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace
+WHERE c.relname OPERATOR(pg_catalog.~) '^(ataddindex)$' COLLATE pg_catalog.default
+                                                                          ^
 DROP TABLE ataddindex;
 CREATE TABLE ataddindex(f1 VARCHAR(10));
 INSERT INTO ataddindex(f1) VALUES ('foo'), ('a');
 ALTER TABLE ataddindex
   ALTER f1 SET DATA TYPE TEXT,
   ADD EXCLUDE ((f1 LIKE 'a') WITH =);
+ERROR:  at or near "(": syntax error
+DETAIL:  source SQL:
+ALTER TABLE ataddindex
+  ALTER f1 SET DATA TYPE TEXT,
+  ADD EXCLUDE ((f1 LIKE 'a') WITH =)
+              ^
+HINT:  try \h ALTER TABLE
 \d ataddindex
-           Table "public.ataddindex"
- Column | Type | Collation | Nullable | Default 
---------+------+-----------+----------+---------
- f1     | text |           |          | 
-Indexes:
-    "ataddindex_expr_excl" EXCLUDE USING btree ((f1 ~~ 'a'::text) WITH =)
-
+ERROR:  at or near ".": syntax error
+DETAIL:  source SQL:
+SELECT c.oid,
+  n.nspname,
+  c.relname
+FROM pg_catalog.pg_class c
+     LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace
+WHERE c.relname OPERATOR(pg_catalog.~) '^(ataddindex)$' COLLATE pg_catalog.default
+                                                                          ^
 DROP TABLE ataddindex;
 CREATE TABLE ataddindex(id int, ref_id int);
 ALTER TABLE ataddindex
   ADD PRIMARY KEY (id),
   ADD FOREIGN KEY (ref_id) REFERENCES ataddindex;
+ERROR:  cannot use nullable column "id" in primary key
 \d ataddindex
-             Table "public.ataddindex"
- Column |  Type   | Collation | Nullable | Default 
---------+---------+-----------+----------+---------
- id     | integer |           | not null | 
- ref_id | integer |           |          | 
-Indexes:
-    "ataddindex_pkey" PRIMARY KEY, btree (id)
-Foreign-key constraints:
-    "ataddindex_ref_id_fkey" FOREIGN KEY (ref_id) REFERENCES ataddindex(id)
-Referenced by:
-    TABLE "ataddindex" CONSTRAINT "ataddindex_ref_id_fkey" FOREIGN KEY (ref_id) REFERENCES ataddindex(id)
-
+ERROR:  at or near ".": syntax error
+DETAIL:  source SQL:
+SELECT c.oid,
+  n.nspname,
+  c.relname
+FROM pg_catalog.pg_class c
+     LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace
+WHERE c.relname OPERATOR(pg_catalog.~) '^(ataddindex)$' COLLATE pg_catalog.default
+                                                                          ^
 DROP TABLE ataddindex;
 CREATE TABLE ataddindex(id int, ref_id int);
 ALTER TABLE ataddindex
   ADD UNIQUE (id),
   ADD FOREIGN KEY (ref_id) REFERENCES ataddindex (id);
 \d ataddindex
-             Table "public.ataddindex"
- Column |  Type   | Collation | Nullable | Default 
---------+---------+-----------+----------+---------
- id     | integer |           |          | 
- ref_id | integer |           |          | 
-Indexes:
-    "ataddindex_id_key" UNIQUE CONSTRAINT, btree (id)
-Foreign-key constraints:
-    "ataddindex_ref_id_fkey" FOREIGN KEY (ref_id) REFERENCES ataddindex(id)
-Referenced by:
-    TABLE "ataddindex" CONSTRAINT "ataddindex_ref_id_fkey" FOREIGN KEY (ref_id) REFERENCES ataddindex(id)
-
+ERROR:  at or near ".": syntax error
+DETAIL:  source SQL:
+SELECT c.oid,
+  n.nspname,
+  c.relname
+FROM pg_catalog.pg_class c
+     LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace
+WHERE c.relname OPERATOR(pg_catalog.~) '^(ataddindex)$' COLLATE pg_catalog.default
+                                                                          ^
 DROP TABLE ataddindex;
 -- unsupported constraint types for partitioned tables
 CREATE TABLE partitioned (
 	a int,
 	b int
 ) PARTITION BY RANGE (a, (a+b+1));
+ERROR:  at or near "(": syntax error
+DETAIL:  source SQL:
+CREATE TABLE partitioned (
+	a int,
+	b int
+) PARTITION BY RANGE (a, (a+b+1))
+                         ^
+HINT:  try \h CREATE TABLE
 ALTER TABLE partitioned ADD EXCLUDE USING gist (a WITH &&);
-ERROR:  exclusion constraints are not supported on partitioned tables
-LINE 1: ALTER TABLE partitioned ADD EXCLUDE USING gist (a WITH &&);
-                                    ^
+ERROR:  at or near "gist": syntax error: unimplemented: this syntax
+DETAIL:  source SQL:
+ALTER TABLE partitioned ADD EXCLUDE USING gist (a WITH &&)
+                                          ^
+HINT:  You have attempted to use a feature that is not yet implemented.
+See: https://go.crdb.dev/issue-v/46657/_version_
 -- cannot drop column that is part of the partition key
 ALTER TABLE partitioned DROP COLUMN a;
-ERROR:  cannot drop column "a" because it is part of the partition key of relation "partitioned"
+ERROR:  relation "partitioned" does not exist
 ALTER TABLE partitioned ALTER COLUMN a TYPE char(5);
-ERROR:  cannot alter column "a" because it is part of the partition key of relation "partitioned"
+ERROR:  relation "partitioned" does not exist
 ALTER TABLE partitioned DROP COLUMN b;
-ERROR:  cannot drop column "b" because it is part of the partition key of relation "partitioned"
+ERROR:  relation "partitioned" does not exist
 ALTER TABLE partitioned ALTER COLUMN b TYPE char(5);
-ERROR:  cannot alter column "b" because it is part of the partition key of relation "partitioned"
+ERROR:  relation "partitioned" does not exist
 -- specifying storage parameters for partitioned tables is not supported
 ALTER TABLE partitioned SET (fillfactor=100);
-ERROR:  cannot specify storage parameters for a partitioned table
-HINT:  Specify storage parameters for its leaf partitions instead.
+ERROR:  relation "partitioned" does not exist
 -- partitioned table cannot participate in regular inheritance
 CREATE TABLE nonpartitioned (
 	a int,
 	b int
 );
 ALTER TABLE partitioned INHERIT nonpartitioned;
-ERROR:  cannot change inheritance of partitioned table
+ERROR:  at or near "inherit": syntax error
+DETAIL:  source SQL:
+ALTER TABLE partitioned INHERIT nonpartitioned
+                        ^
+HINT:  try \h ALTER TABLE
 ALTER TABLE nonpartitioned INHERIT partitioned;
-ERROR:  cannot inherit from partitioned table "partitioned"
+ERROR:  at or near "inherit": syntax error
+DETAIL:  source SQL:
+ALTER TABLE nonpartitioned INHERIT partitioned
+                           ^
+HINT:  try \h ALTER TABLE
 -- cannot add NO INHERIT constraint to partitioned tables
 ALTER TABLE partitioned ADD CONSTRAINT chk_a CHECK (a > 0) NO INHERIT;
-ERROR:  cannot add NO INHERIT constraint to partitioned table "partitioned"
+ERROR:  at or near "no": syntax error
+DETAIL:  source SQL:
+ALTER TABLE partitioned ADD CONSTRAINT chk_a CHECK (a > 0) NO INHERIT
+                                                           ^
 DROP TABLE partitioned, nonpartitioned;
+ERROR:  relation "partitioned" does not exist
 --
 -- ATTACH PARTITION
 --
@@ -3878,7 +4714,11 @@
 );
 CREATE TABLE fail_part (like unparted);
 ALTER TABLE unparted ATTACH PARTITION fail_part FOR VALUES IN ('a');
-ERROR:  table "unparted" is not partitioned
+ERROR:  at or near "attach": syntax error
+DETAIL:  source SQL:
+ALTER TABLE unparted ATTACH PARTITION fail_part FOR VALUES IN ('a')
+                     ^
+HINT:  try \h ALTER TABLE
 DROP TABLE unparted, fail_part;
 -- check that partition bound is compatible
 CREATE TABLE list_parted (
@@ -3886,62 +4726,146 @@
 	b char(2) COLLATE "C",
 	CONSTRAINT check_a CHECK (a > 0)
 ) PARTITION BY LIST (a);
+ERROR:  at or near ",": syntax error: invalid locale C: language: tag is not well-formed
+DETAIL:  source SQL:
+CREATE TABLE list_parted (
+	a int NOT NULL,
+	b char(2) COLLATE "C",
+                      ^
 CREATE TABLE fail_part (LIKE list_parted);
+ERROR:  relation "list_parted" does not exist
 ALTER TABLE list_parted ATTACH PARTITION fail_part FOR VALUES FROM (1) TO (10);
-ERROR:  invalid bound specification for a list partition
-LINE 1: ...list_parted ATTACH PARTITION fail_part FOR VALUES FROM (1) T...
-                                                             ^
+ERROR:  at or near "attach": syntax error
+DETAIL:  source SQL:
+ALTER TABLE list_parted ATTACH PARTITION fail_part FOR VALUES FROM (1) TO (10)
+                        ^
+HINT:  try \h ALTER TABLE
 DROP TABLE fail_part;
+ERROR:  relation "fail_part" does not exist
 -- check that the table being attached exists
 ALTER TABLE list_parted ATTACH PARTITION nonexistent FOR VALUES IN (1);
-ERROR:  relation "nonexistent" does not exist
+ERROR:  at or near "attach": syntax error
+DETAIL:  source SQL:
+ALTER TABLE list_parted ATTACH PARTITION nonexistent FOR VALUES IN (1)
+                        ^
+HINT:  try \h ALTER TABLE
 -- check ownership of the source table
 CREATE ROLE regress_test_me;
 CREATE ROLE regress_test_not_me;
 CREATE TABLE not_owned_by_me (LIKE list_parted);
+ERROR:  relation "list_parted" does not exist
 ALTER TABLE not_owned_by_me OWNER TO regress_test_not_me;
+ERROR:  relation "not_owned_by_me" does not exist
 SET SESSION AUTHORIZATION regress_test_me;
+ERROR:  at or near "regress_test_me": syntax error: unimplemented: this syntax
+DETAIL:  source SQL:
+SET SESSION AUTHORIZATION regress_test_me
+                          ^
+HINT:  You have attempted to use a feature that is not yet implemented.
+See: https://go.crdb.dev/issue-v/40283/_version_
 CREATE TABLE owned_by_me (
 	a int
 ) PARTITION BY LIST (a);
+ERROR:  at or near "EOF": syntax error
+DETAIL:  source SQL:
+CREATE TABLE owned_by_me (
+	a int
+) PARTITION BY LIST (a)
+                       ^
+HINT:  try \h CREATE TABLE
 ALTER TABLE owned_by_me ATTACH PARTITION not_owned_by_me FOR VALUES IN (1);
-ERROR:  must be owner of table not_owned_by_me
+ERROR:  at or near "attach": syntax error
+DETAIL:  source SQL:
+ALTER TABLE owned_by_me ATTACH PARTITION not_owned_by_me FOR VALUES IN (1)
+                        ^
+HINT:  try \h ALTER TABLE
 RESET SESSION AUTHORIZATION;
+ERROR:  at or near "authorization": syntax error
+DETAIL:  source SQL:
+RESET SESSION AUTHORIZATION
+              ^
+HINT:  try \h RESET
 DROP TABLE owned_by_me, not_owned_by_me;
+ERROR:  relation "owned_by_me" does not exist
 DROP ROLE regress_test_not_me;
 DROP ROLE regress_test_me;
 -- check that the table being attached is not part of regular inheritance
 CREATE TABLE parent (LIKE list_parted);
+ERROR:  relation "list_parted" does not exist
 CREATE TABLE child () INHERITS (parent);
+ERROR:  at or near "(": syntax error: unimplemented: this syntax
+DETAIL:  source SQL:
+CREATE TABLE child () INHERITS (parent)
+                               ^
+HINT:  You have attempted to use a feature that is not yet implemented.
+See: https://go.crdb.dev/issue-v/22456/_version_
 ALTER TABLE list_parted ATTACH PARTITION child FOR VALUES IN (1);
-ERROR:  cannot attach inheritance child as partition
+ERROR:  at or near "attach": syntax error
+DETAIL:  source SQL:
+ALTER TABLE list_parted ATTACH PARTITION child FOR VALUES IN (1)
+                        ^
+HINT:  try \h ALTER TABLE
 ALTER TABLE list_parted ATTACH PARTITION parent FOR VALUES IN (1);
-ERROR:  cannot attach inheritance parent as partition
+ERROR:  at or near "attach": syntax error
+DETAIL:  source SQL:
+ALTER TABLE list_parted ATTACH PARTITION parent FOR VALUES IN (1)
+                        ^
+HINT:  try \h ALTER TABLE
 DROP TABLE parent CASCADE;
-NOTICE:  drop cascades to table child
+ERROR:  relation "parent" does not exist
 -- check any TEMP-ness
 CREATE TEMP TABLE temp_parted (a int) PARTITION BY LIST (a);
+ERROR:  at or near "EOF": syntax error
+DETAIL:  source SQL:
+CREATE TEMP TABLE temp_parted (a int) PARTITION BY LIST (a)
+                                                           ^
+HINT:  try \h CREATE TABLE
 CREATE TABLE perm_part (a int);
 ALTER TABLE temp_parted ATTACH PARTITION perm_part FOR VALUES IN (1);
-ERROR:  cannot attach a permanent relation as partition of temporary relation "temp_parted"
+ERROR:  at or near "attach": syntax error
+DETAIL:  source SQL:
+ALTER TABLE temp_parted ATTACH PARTITION perm_part FOR VALUES IN (1)
+                        ^
+HINT:  try \h ALTER TABLE
 DROP TABLE temp_parted, perm_part;
+ERROR:  relation "temp_parted" does not exist
 -- check that the table being attached is not a typed table
 CREATE TYPE mytype AS (a int);
 CREATE TABLE fail_part OF mytype;
+ERROR:  at or near "of": syntax error
+DETAIL:  source SQL:
+CREATE TABLE fail_part OF mytype
+                       ^
+HINT:  try \h CREATE TABLE
 ALTER TABLE list_parted ATTACH PARTITION fail_part FOR VALUES IN (1);
-ERROR:  cannot attach a typed table as partition
+ERROR:  at or near "attach": syntax error
+DETAIL:  source SQL:
+ALTER TABLE list_parted ATTACH PARTITION fail_part FOR VALUES IN (1)
+                        ^
+HINT:  try \h ALTER TABLE
 DROP TYPE mytype CASCADE;
-NOTICE:  drop cascades to table fail_part
+ERROR:  unimplemented: DROP TYPE CASCADE is not yet supported
+HINT:  You have attempted to use a feature that is not yet implemented.
+See: https://go.crdb.dev/issue-v/51480/_version_
 -- check that the table being attached has only columns present in the parent
 CREATE TABLE fail_part (like list_parted, c int);
+ERROR:  relation "list_parted" does not exist
 ALTER TABLE list_parted ATTACH PARTITION fail_part FOR VALUES IN (1);
-ERROR:  table "fail_part" contains column "c" not found in parent "list_parted"
-DETAIL:  The new partition may contain only the columns present in parent.
+ERROR:  at or near "attach": syntax error
+DETAIL:  source SQL:
+ALTER TABLE list_parted ATTACH PARTITION fail_part FOR VALUES IN (1)
+                        ^
+HINT:  try \h ALTER TABLE
 DROP TABLE fail_part;
+ERROR:  relation "fail_part" does not exist
 -- check that the table being attached has every column of the parent
 CREATE TABLE fail_part (a int NOT NULL);
 ALTER TABLE list_parted ATTACH PARTITION fail_part FOR VALUES IN (1);
-ERROR:  child table is missing column "b"
+ERROR:  at or near "attach": syntax error
+DETAIL:  source SQL:
+ALTER TABLE list_parted ATTACH PARTITION fail_part FOR VALUES IN (1)
+                        ^
+HINT:  try \h ALTER TABLE
 DROP TABLE fail_part;
 -- check that columns match in type, collation and NOT NULL status
 CREATE TABLE fail_part (
@@ -3949,158 +4873,335 @@
 	a int NOT NULL
 );
 ALTER TABLE list_parted ATTACH PARTITION fail_part FOR VALUES IN (1);
-ERROR:  child table "fail_part" has different type for column "b"
+ERROR:  at or near "attach": syntax error
+DETAIL:  source SQL:
+ALTER TABLE list_parted ATTACH PARTITION fail_part FOR VALUES IN (1)
+                        ^
+HINT:  try \h ALTER TABLE
 ALTER TABLE fail_part ALTER b TYPE char (2) COLLATE "POSIX";
+ERROR:  invalid locale posix
 ALTER TABLE list_parted ATTACH PARTITION fail_part FOR VALUES IN (1);
-ERROR:  child table "fail_part" has different collation for column "b"
+ERROR:  at or near "attach": syntax error
+DETAIL:  source SQL:
+ALTER TABLE list_parted ATTACH PARTITION fail_part FOR VALUES IN (1)
+                        ^
+HINT:  try \h ALTER TABLE
 DROP TABLE fail_part;
 -- check that the table being attached has all constraints of the parent
 CREATE TABLE fail_part (
 	b char(2) COLLATE "C",
 	a int NOT NULL
 );
+ERROR:  at or near ",": syntax error: invalid locale C: language: tag is not well-formed
+DETAIL:  source SQL:
+CREATE TABLE fail_part (
+	b char(2) COLLATE "C",
+                      ^
 ALTER TABLE list_parted ATTACH PARTITION fail_part FOR VALUES IN (1);
-ERROR:  child table is missing constraint "check_a"
+ERROR:  at or near "attach": syntax error
+DETAIL:  source SQL:
+ALTER TABLE list_parted ATTACH PARTITION fail_part FOR VALUES IN (1)
+                        ^
+HINT:  try \h ALTER TABLE
 -- check that the constraint matches in definition with parent's constraint
 ALTER TABLE fail_part ADD CONSTRAINT check_a CHECK (a >= 0);
+ERROR:  relation "fail_part" does not exist
 ALTER TABLE list_parted ATTACH PARTITION fail_part FOR VALUES IN (1);
-ERROR:  child table "fail_part" has different definition for check constraint "check_a"
+ERROR:  at or near "attach": syntax error
+DETAIL:  source SQL:
+ALTER TABLE list_parted ATTACH PARTITION fail_part FOR VALUES IN (1)
+                        ^
+HINT:  try \h ALTER TABLE
 DROP TABLE fail_part;
+ERROR:  relation "fail_part" does not exist
 -- check the attributes and constraints after partition is attached
 CREATE TABLE part_1 (
 	a int NOT NULL,
 	b char(2) COLLATE "C",
 	CONSTRAINT check_a CHECK (a > 0)
 );
+ERROR:  at or near ",": syntax error: invalid locale C: language: tag is not well-formed
+DETAIL:  source SQL:
+CREATE TABLE part_1 (
+	a int NOT NULL,
+	b char(2) COLLATE "C",
+                      ^
 ALTER TABLE list_parted ATTACH PARTITION part_1 FOR VALUES IN (1);
+ERROR:  at or near "attach": syntax error
+DETAIL:  source SQL:
+ALTER TABLE list_parted ATTACH PARTITION part_1 FOR VALUES IN (1)
+                        ^
+HINT:  try \h ALTER TABLE
 -- attislocal and conislocal are always false for merged attributes and constraints respectively.
 SELECT attislocal, attinhcount FROM pg_attribute WHERE attrelid = 'part_1'::regclass AND attnum > 0;
- attislocal | attinhcount 
-------------+-------------
- f          |           1
- f          |           1
-(2 rows)
-
+ERROR:  relation "part_1" does not exist
 SELECT conislocal, coninhcount FROM pg_constraint WHERE conrelid = 'part_1'::regclass AND conname = 'check_a';
- conislocal | coninhcount 
-------------+-------------
- f          |           1
-(1 row)
-
+ERROR:  relation "part_1" does not exist
 -- check that the new partition won't overlap with an existing partition
 CREATE TABLE fail_part (LIKE part_1 INCLUDING CONSTRAINTS);
+ERROR:  relation "part_1" does not exist
 ALTER TABLE list_parted ATTACH PARTITION fail_part FOR VALUES IN (1);
-ERROR:  partition "fail_part" would overlap partition "part_1"
-LINE 1: ...LE list_parted ATTACH PARTITION fail_part FOR VALUES IN (1);
-                                                                    ^
+ERROR:  at or near "attach": syntax error
+DETAIL:  source SQL:
+ALTER TABLE list_parted ATTACH PARTITION fail_part FOR VALUES IN (1)
+                        ^
+HINT:  try \h ALTER TABLE
 DROP TABLE fail_part;
+ERROR:  relation "fail_part" does not exist
 -- check that an existing table can be attached as a default partition
 CREATE TABLE def_part (LIKE list_parted INCLUDING CONSTRAINTS);
+ERROR:  relation "list_parted" does not exist
 ALTER TABLE list_parted ATTACH PARTITION def_part DEFAULT;
+ERROR:  at or near "attach": syntax error
+DETAIL:  source SQL:
+ALTER TABLE list_parted ATTACH PARTITION def_part DEFAULT
+                        ^
+HINT:  try \h ALTER TABLE
 -- check attaching default partition fails if a default partition already
 -- exists
 CREATE TABLE fail_def_part (LIKE part_1 INCLUDING CONSTRAINTS);
+ERROR:  relation "part_1" does not exist
 ALTER TABLE list_parted ATTACH PARTITION fail_def_part DEFAULT;
-ERROR:  partition "fail_def_part" conflicts with existing default partition "def_part"
-LINE 1: ...ER TABLE list_parted ATTACH PARTITION fail_def_part DEFAULT;
-                                                               ^
+ERROR:  at or near "attach": syntax error
+DETAIL:  source SQL:
+ALTER TABLE list_parted ATTACH PARTITION fail_def_part DEFAULT
+                        ^
+HINT:  try \h ALTER TABLE
 -- check validation when attaching list partitions
 CREATE TABLE list_parted2 (
 	a int,
 	b char
 ) PARTITION BY LIST (a);
+ERROR:  at or near "EOF": syntax error
+DETAIL:  source SQL:
+CREATE TABLE list_parted2 (
+	a int,
+	b char
+) PARTITION BY LIST (a)
+                       ^
+HINT:  try \h CREATE TABLE
 -- check that violating rows are correctly reported
 CREATE TABLE part_2 (LIKE list_parted2);
+ERROR:  relation "list_parted2" does not exist
 INSERT INTO part_2 VALUES (3, 'a');
+ERROR:  relation "part_2" does not exist
 ALTER TABLE list_parted2 ATTACH PARTITION part_2 FOR VALUES IN (2);
-ERROR:  partition constraint of relation "part_2" is violated by some row
+ERROR:  at or near "attach": syntax error
+DETAIL:  source SQL:
+ALTER TABLE list_parted2 ATTACH PARTITION part_2 FOR VALUES IN (2)
+                         ^
+HINT:  try \h ALTER TABLE
 -- should be ok after deleting the bad row
 DELETE FROM part_2;
+ERROR:  relation "part_2" does not exist
 ALTER TABLE list_parted2 ATTACH PARTITION part_2 FOR VALUES IN (2);
+ERROR:  at or near "attach": syntax error
+DETAIL:  source SQL:
+ALTER TABLE list_parted2 ATTACH PARTITION part_2 FOR VALUES IN (2)
+                         ^
+HINT:  try \h ALTER TABLE
 -- check partition cannot be attached if default has some row for its values
 CREATE TABLE list_parted2_def PARTITION OF list_parted2 DEFAULT;
+ERROR:  at or near "partition": syntax error
+DETAIL:  source SQL:
+CREATE TABLE list_parted2_def PARTITION OF list_parted2 DEFAULT
+                              ^
+HINT:  try \h CREATE TABLE
 INSERT INTO list_parted2_def VALUES (11, 'z');
+ERROR:  relation "list_parted2_def" does not exist
 CREATE TABLE part_3 (LIKE list_parted2);
+ERROR:  relation "list_parted2" does not exist
 ALTER TABLE list_parted2 ATTACH PARTITION part_3 FOR VALUES IN (11);
-ERROR:  updated partition constraint for default partition "list_parted2_def" would be violated by some row
+ERROR:  at or near "attach": syntax error
+DETAIL:  source SQL:
+ALTER TABLE list_parted2 ATTACH PARTITION part_3 FOR VALUES IN (11)
+                         ^
+HINT:  try \h ALTER TABLE
 -- should be ok after deleting the bad row
 DELETE FROM list_parted2_def WHERE a = 11;
+ERROR:  relation "list_parted2_def" does not exist
 ALTER TABLE list_parted2 ATTACH PARTITION part_3 FOR VALUES IN (11);
+ERROR:  at or near "attach": syntax error
+DETAIL:  source SQL:
+ALTER TABLE list_parted2 ATTACH PARTITION part_3 FOR VALUES IN (11)
+                         ^
+HINT:  try \h ALTER TABLE
 -- adding constraints that describe the desired partition constraint
 -- (or more restrictive) will help skip the validation scan
 CREATE TABLE part_3_4 (
 	LIKE list_parted2,
 	CONSTRAINT check_a CHECK (a IN (3))
 );
+ERROR:  relation "list_parted2" does not exist
 -- however, if a list partition does not accept nulls, there should be
 -- an explicit NOT NULL constraint on the partition key column for the
 -- validation scan to be skipped;
 ALTER TABLE list_parted2 ATTACH PARTITION part_3_4 FOR VALUES IN (3, 4);
+ERROR:  at or near "attach": syntax error
+DETAIL:  source SQL:
+ALTER TABLE list_parted2 ATTACH PARTITION part_3_4 FOR VALUES IN (3, 4)
+                         ^
+HINT:  try \h ALTER TABLE
 -- adding a NOT NULL constraint will cause the scan to be skipped
 ALTER TABLE list_parted2 DETACH PARTITION part_3_4;
+ERROR:  at or near "detach": syntax error
+DETAIL:  source SQL:
+ALTER TABLE list_parted2 DETACH PARTITION part_3_4
+                         ^
+HINT:  try \h ALTER TABLE
 ALTER TABLE part_3_4 ALTER a SET NOT NULL;
+ERROR:  relation "part_3_4" does not exist
 ALTER TABLE list_parted2 ATTACH PARTITION part_3_4 FOR VALUES IN (3, 4);
+ERROR:  at or near "attach": syntax error
+DETAIL:  source SQL:
+ALTER TABLE list_parted2 ATTACH PARTITION part_3_4 FOR VALUES IN (3, 4)
+                         ^
+HINT:  try \h ALTER TABLE
 -- check if default partition scan skipped
 ALTER TABLE list_parted2_def ADD CONSTRAINT check_a CHECK (a IN (5, 6));
+ERROR:  relation "list_parted2_def" does not exist
 CREATE TABLE part_55_66 PARTITION OF list_parted2 FOR VALUES IN (55, 66);
+ERROR:  at or near "partition": syntax error
+DETAIL:  source SQL:
+CREATE TABLE part_55_66 PARTITION OF list_parted2 FOR VALUES IN (55, 66)
+                        ^
+HINT:  try \h CREATE TABLE
 -- check validation when attaching range partitions
 CREATE TABLE range_parted (
 	a int,
 	b int
 ) PARTITION BY RANGE (a, b);
+ERROR:  at or near "EOF": syntax error
+DETAIL:  source SQL:
+CREATE TABLE range_parted (
+	a int,
+	b int
+) PARTITION BY RANGE (a, b)
+                           ^
+HINT:  try \h CREATE TABLE
 -- check that violating rows are correctly reported
 CREATE TABLE part1 (
 	a int NOT NULL CHECK (a = 1),
 	b int NOT NULL CHECK (b >= 1 AND b <= 10)
 );
+ERROR:  relation "root.public.part1" already exists
 INSERT INTO part1 VALUES (1, 10);
 -- Remember the TO bound is exclusive
 ALTER TABLE range_parted ATTACH PARTITION part1 FOR VALUES FROM (1, 1) TO (1, 10);
-ERROR:  partition constraint of relation "part1" is violated by some row
+ERROR:  at or near "attach": syntax error
+DETAIL:  source SQL:
+ALTER TABLE range_parted ATTACH PARTITION part1 FOR VALUES FROM (1, 1) TO (1, 10)
+                         ^
+HINT:  try \h ALTER TABLE
 -- should be ok after deleting the bad row
 DELETE FROM part1;
 ALTER TABLE range_parted ATTACH PARTITION part1 FOR VALUES FROM (1, 1) TO (1, 10);
+ERROR:  at or near "attach": syntax error
+DETAIL:  source SQL:
+ALTER TABLE range_parted ATTACH PARTITION part1 FOR VALUES FROM (1, 1) TO (1, 10)
+                         ^
+HINT:  try \h ALTER TABLE
 -- adding constraints that describe the desired partition constraint
 -- (or more restrictive) will help skip the validation scan
 CREATE TABLE part2 (
 	a int NOT NULL CHECK (a = 1),
 	b int NOT NULL CHECK (b >= 10 AND b < 18)
 );
+ERROR:  relation "root.public.part2" already exists
 ALTER TABLE range_parted ATTACH PARTITION part2 FOR VALUES FROM (1, 10) TO (1, 20);
+ERROR:  at or near "attach": syntax error
+DETAIL:  source SQL:
+ALTER TABLE range_parted ATTACH PARTITION part2 FOR VALUES FROM (1, 10) TO (1, 20)
+                         ^
+HINT:  try \h ALTER TABLE
 -- Create default partition
 CREATE TABLE partr_def1 PARTITION OF range_parted DEFAULT;
+ERROR:  at or near "partition": syntax error
+DETAIL:  source SQL:
+CREATE TABLE partr_def1 PARTITION OF range_parted DEFAULT
+                        ^
+HINT:  try \h CREATE TABLE
 -- Only one default partition is allowed, hence, following should give error
 CREATE TABLE partr_def2 (LIKE part1 INCLUDING CONSTRAINTS);
 ALTER TABLE range_parted ATTACH PARTITION partr_def2 DEFAULT;
-ERROR:  partition "partr_def2" conflicts with existing default partition "partr_def1"
-LINE 1: ...LTER TABLE range_parted ATTACH PARTITION partr_def2 DEFAULT;
-                                                               ^
+ERROR:  at or near "attach": syntax error
+DETAIL:  source SQL:
+ALTER TABLE range_parted ATTACH PARTITION partr_def2 DEFAULT
+                         ^
+HINT:  try \h ALTER TABLE
 -- Overlapping partitions cannot be attached, hence, following should give error
 INSERT INTO partr_def1 VALUES (2, 10);
+ERROR:  relation "partr_def1" does not exist
 CREATE TABLE part3 (LIKE range_parted);
+ERROR:  relation "root.public.part3" already exists
 ALTER TABLE range_parted ATTACH partition part3 FOR VALUES FROM (2, 10) TO (2, 20);
-ERROR:  updated partition constraint for default partition "partr_def1" would be violated by some row
+ERROR:  at or near "attach": syntax error
+DETAIL:  source SQL:
+ALTER TABLE range_parted ATTACH partition part3 FOR VALUES FROM (2, 10) TO (2, 20)
+                         ^
+HINT:  try \h ALTER TABLE
 -- Attaching partitions should be successful when there are no overlapping rows
 ALTER TABLE range_parted ATTACH partition part3 FOR VALUES FROM (3, 10) TO (3, 20);
+ERROR:  at or near "attach": syntax error
+DETAIL:  source SQL:
+ALTER TABLE range_parted ATTACH partition part3 FOR VALUES FROM (3, 10) TO (3, 20)
+                         ^
+HINT:  try \h ALTER TABLE
 -- check that leaf partitions are scanned when attaching a partitioned
 -- table
 CREATE TABLE part_5 (
 	LIKE list_parted2
 ) PARTITION BY LIST (b);
+ERROR:  at or near "EOF": syntax error
+DETAIL:  source SQL:
+CREATE TABLE part_5 (
+	LIKE list_parted2
+) PARTITION BY LIST (b)
+                       ^
+HINT:  try \h CREATE TABLE
 -- check that violating rows are correctly reported
 CREATE TABLE part_5_a PARTITION OF part_5 FOR VALUES IN ('a');
+ERROR:  at or near "partition": syntax error
+DETAIL:  source SQL:
+CREATE TABLE part_5_a PARTITION OF part_5 FOR VALUES IN ('a')
+                      ^
+HINT:  try \h CREATE TABLE
 INSERT INTO part_5_a (a, b) VALUES (6, 'a');
+ERROR:  relation "part_5_a" does not exist
 ALTER TABLE list_parted2 ATTACH PARTITION part_5 FOR VALUES IN (5);
-ERROR:  partition constraint of relation "part_5_a" is violated by some row
+ERROR:  at or near "attach": syntax error
+DETAIL:  source SQL:
+ALTER TABLE list_parted2 ATTACH PARTITION part_5 FOR VALUES IN (5)
+                         ^
+HINT:  try \h ALTER TABLE
 -- delete the faulting row and also add a constraint to skip the scan
 DELETE FROM part_5_a WHERE a NOT IN (3);
+ERROR:  relation "part_5_a" does not exist
 ALTER TABLE part_5 ADD CONSTRAINT check_a CHECK (a IS NOT NULL AND a = 5);
+ERROR:  relation "part_5" does not exist
 ALTER TABLE list_parted2 ATTACH PARTITION part_5 FOR VALUES IN (5);
+ERROR:  at or near "attach": syntax error
+DETAIL:  source SQL:
+ALTER TABLE list_parted2 ATTACH PARTITION part_5 FOR VALUES IN (5)
+                         ^
+HINT:  try \h ALTER TABLE
 ALTER TABLE list_parted2 DETACH PARTITION part_5;
+ERROR:  at or near "detach": syntax error
+DETAIL:  source SQL:
+ALTER TABLE list_parted2 DETACH PARTITION part_5
+                         ^
+HINT:  try \h ALTER TABLE
 ALTER TABLE part_5 DROP CONSTRAINT check_a;
+ERROR:  relation "part_5" does not exist
 -- scan should again be skipped, even though NOT NULL is now a column property
 ALTER TABLE part_5 ADD CONSTRAINT check_a CHECK (a IN (5)), ALTER a SET NOT NULL;
+ERROR:  relation "part_5" does not exist
 ALTER TABLE list_parted2 ATTACH PARTITION part_5 FOR VALUES IN (5);
+ERROR:  at or near "attach": syntax error
+DETAIL:  source SQL:
+ALTER TABLE list_parted2 ATTACH PARTITION part_5 FOR VALUES IN (5)
+                         ^
+HINT:  try \h ALTER TABLE
 -- Check the case where attnos of the partitioning columns in the table being
 -- attached differs from the parent.  It should not affect the constraint-
 -- checking logic that allows to skip the scan.
@@ -4109,8 +5210,15 @@
 	LIKE list_parted2,
 	CONSTRAINT check_a CHECK (a IS NOT NULL AND a = 6)
 );
+ERROR:  relation "list_parted2" does not exist
 ALTER TABLE part_6 DROP c;
+ERROR:  relation "part_6" does not exist
 ALTER TABLE list_parted2 ATTACH PARTITION part_6 FOR VALUES IN (6);
+ERROR:  at or near "attach": syntax error
+DETAIL:  source SQL:
+ALTER TABLE list_parted2 ATTACH PARTITION part_6 FOR VALUES IN (6)
+                         ^
+HINT:  try \h ALTER TABLE
 -- Similar to above, but the table being attached is a partitioned table
 -- whose partition has still different attnos for the root partitioning
 -- columns.
@@ -4118,6 +5226,14 @@
 	LIKE list_parted2,
 	CONSTRAINT check_a CHECK (a IS NOT NULL AND a = 7)
 ) PARTITION BY LIST (b);
+ERROR:  at or near "EOF": syntax error
+DETAIL:  source SQL:
+CREATE TABLE part_7 (
+	LIKE list_parted2,
+	CONSTRAINT check_a CHECK (a IS NOT NULL AND a = 7)
+) PARTITION BY LIST (b)
+                       ^
+HINT:  try \h CREATE TABLE
 CREATE TABLE part_7_a_null (
 	c int,
 	d int,
@@ -4126,63 +5242,150 @@
 	CONSTRAINT check_b CHECK (b IS NULL OR b = 'a'),
 	CONSTRAINT check_a CHECK (a IS NOT NULL AND a = 7)
 );
+ERROR:  relation "list_parted2" does not exist
 ALTER TABLE part_7_a_null DROP c, DROP d, DROP e;
+ERROR:  relation "part_7_a_null" does not exist
 ALTER TABLE part_7 ATTACH PARTITION part_7_a_null FOR VALUES IN ('a', null);
+ERROR:  at or near "attach": syntax error
+DETAIL:  source SQL:
+ALTER TABLE part_7 ATTACH PARTITION part_7_a_null FOR VALUES IN ('a', null)
+                   ^
+HINT:  try \h ALTER TABLE
 ALTER TABLE list_parted2 ATTACH PARTITION part_7 FOR VALUES IN (7);
+ERROR:  at or near "attach": syntax error
+DETAIL:  source SQL:
+ALTER TABLE list_parted2 ATTACH PARTITION part_7 FOR VALUES IN (7)
+                         ^
+HINT:  try \h ALTER TABLE
 -- Same example, but check this time that the constraint correctly detects
 -- violating rows
 ALTER TABLE list_parted2 DETACH PARTITION part_7;
+ERROR:  at or near "detach": syntax error
+DETAIL:  source SQL:
+ALTER TABLE list_parted2 DETACH PARTITION part_7
+                         ^
+HINT:  try \h ALTER TABLE
 ALTER TABLE part_7 DROP CONSTRAINT check_a; -- thusly, scan won't be skipped
+ERROR:  relation "part_7" does not exist
 INSERT INTO part_7 (a, b) VALUES (8, null), (9, 'a');
+ERROR:  relation "part_7" does not exist
 SELECT tableoid::regclass, a, b FROM part_7 order by a;
-   tableoid    | a | b 
----------------+---+---
- part_7_a_null | 8 | 
- part_7_a_null | 9 | a
-(2 rows)
-
+ERROR:  relation "part_7" does not exist
 ALTER TABLE list_parted2 ATTACH PARTITION part_7 FOR VALUES IN (7);
-ERROR:  partition constraint of relation "part_7_a_null" is violated by some row
+ERROR:  at or near "attach": syntax error
+DETAIL:  source SQL:
+ALTER TABLE list_parted2 ATTACH PARTITION part_7 FOR VALUES IN (7)
+                         ^
+HINT:  try \h ALTER TABLE
 -- check that leaf partitions of default partition are scanned when
 -- attaching a partitioned table.
 ALTER TABLE part_5 DROP CONSTRAINT check_a;
+ERROR:  relation "part_5" does not exist
 CREATE TABLE part5_def PARTITION OF part_5 DEFAULT PARTITION BY LIST(a);
+ERROR:  at or near "partition": syntax error
+DETAIL:  source SQL:
+CREATE TABLE part5_def PARTITION OF part_5 DEFAULT PARTITION BY LIST(a)
+                       ^
+HINT:  try \h CREATE TABLE
 CREATE TABLE part5_def_p1 PARTITION OF part5_def FOR VALUES IN (5);
+ERROR:  at or near "partition": syntax error
+DETAIL:  source SQL:
+CREATE TABLE part5_def_p1 PARTITION OF part5_def FOR VALUES IN (5)
+                          ^
+HINT:  try \h CREATE TABLE
 INSERT INTO part5_def_p1 VALUES (5, 'y');
+ERROR:  relation "part5_def_p1" does not exist
 CREATE TABLE part5_p1 (LIKE part_5);
+ERROR:  relation "part_5" does not exist
 ALTER TABLE part_5 ATTACH PARTITION part5_p1 FOR VALUES IN ('y');
-ERROR:  updated partition constraint for default partition "part5_def_p1" would be violated by some row
+ERROR:  at or near "attach": syntax error
+DETAIL:  source SQL:
+ALTER TABLE part_5 ATTACH PARTITION part5_p1 FOR VALUES IN ('y')
+                   ^
+HINT:  try \h ALTER TABLE
 -- should be ok after deleting the bad row
 DELETE FROM part5_def_p1 WHERE b = 'y';
+ERROR:  relation "part5_def_p1" does not exist
 ALTER TABLE part_5 ATTACH PARTITION part5_p1 FOR VALUES IN ('y');
+ERROR:  at or near "attach": syntax error
+DETAIL:  source SQL:
+ALTER TABLE part_5 ATTACH PARTITION part5_p1 FOR VALUES IN ('y')
+                   ^
+HINT:  try \h ALTER TABLE
 -- check that the table being attached is not already a partition
 ALTER TABLE list_parted2 ATTACH PARTITION part_2 FOR VALUES IN (2);
-ERROR:  "part_2" is already a partition
+ERROR:  at or near "attach": syntax error
+DETAIL:  source SQL:
+ALTER TABLE list_parted2 ATTACH PARTITION part_2 FOR VALUES IN (2)
+                         ^
+HINT:  try \h ALTER TABLE
 -- check that circular inheritance is not allowed
 ALTER TABLE part_5 ATTACH PARTITION list_parted2 FOR VALUES IN ('b');
-ERROR:  circular inheritance not allowed
-DETAIL:  "part_5" is already a child of "list_parted2".
+ERROR:  at or near "attach": syntax error
+DETAIL:  source SQL:
+ALTER TABLE part_5 ATTACH PARTITION list_parted2 FOR VALUES IN ('b')
+                   ^
+HINT:  try \h ALTER TABLE
 ALTER TABLE list_parted2 ATTACH PARTITION list_parted2 FOR VALUES IN (0);
-ERROR:  circular inheritance not allowed
-DETAIL:  "list_parted2" is already a child of "list_parted2".
+ERROR:  at or near "attach": syntax error
+DETAIL:  source SQL:
+ALTER TABLE list_parted2 ATTACH PARTITION list_parted2 FOR VALUES IN (0)
+                         ^
+HINT:  try \h ALTER TABLE
 -- If a partitioned table being created or an existing table being attached
 -- as a partition does not have a constraint that would allow validation scan
 -- to be skipped, but an individual partition does, then the partition's
 -- validation scan is skipped.
 CREATE TABLE quuux (a int, b text) PARTITION BY LIST (a);
+ERROR:  at or near "EOF": syntax error
+DETAIL:  source SQL:
+CREATE TABLE quuux (a int, b text) PARTITION BY LIST (a)
+                                                        ^
+HINT:  try \h CREATE TABLE
 CREATE TABLE quuux_default PARTITION OF quuux DEFAULT PARTITION BY LIST (b);
+ERROR:  at or near "partition": syntax error
+DETAIL:  source SQL:
+CREATE TABLE quuux_default PARTITION OF quuux DEFAULT PARTITION BY LIST (b)
+                           ^
+HINT:  try \h CREATE TABLE
 CREATE TABLE quuux_default1 PARTITION OF quuux_default (
 	CONSTRAINT check_1 CHECK (a IS NOT NULL AND a = 1)
 ) FOR VALUES IN ('b');
+ERROR:  at or near "partition": syntax error
+DETAIL:  source SQL:
+CREATE TABLE quuux_default1 PARTITION OF quuux_default (
+                            ^
+HINT:  try \h CREATE TABLE
 CREATE TABLE quuux1 (a int, b text);
 ALTER TABLE quuux ATTACH PARTITION quuux1 FOR VALUES IN (1); -- validate!
+ERROR:  at or near "attach": syntax error
+DETAIL:  source SQL:
+ALTER TABLE quuux ATTACH PARTITION quuux1 FOR VALUES IN (1)
+                  ^
+HINT:  try \h ALTER TABLE
 CREATE TABLE quuux2 (a int, b text);
 ALTER TABLE quuux ATTACH PARTITION quuux2 FOR VALUES IN (2); -- skip validation
+ERROR:  at or near "attach": syntax error
+DETAIL:  source SQL:
+ALTER TABLE quuux ATTACH PARTITION quuux2 FOR VALUES IN (2)
+                  ^
+HINT:  try \h ALTER TABLE
 DROP TABLE quuux1, quuux2;
 -- should validate for quuux1, but not for quuux2
 CREATE TABLE quuux1 PARTITION OF quuux FOR VALUES IN (1);
+ERROR:  at or near "partition": syntax error
+DETAIL:  source SQL:
+CREATE TABLE quuux1 PARTITION OF quuux FOR VALUES IN (1)
+                    ^
+HINT:  try \h CREATE TABLE
 CREATE TABLE quuux2 PARTITION OF quuux FOR VALUES IN (2);
+ERROR:  at or near "partition": syntax error
+DETAIL:  source SQL:
+CREATE TABLE quuux2 PARTITION OF quuux FOR VALUES IN (2)
+                    ^
+HINT:  try \h CREATE TABLE
 DROP TABLE quuux;
+ERROR:  relation "quuux" does not exist
 -- check validation when attaching hash partitions
 -- Use hand-rolled hash functions and operator class to get predictable result
 -- on different machines. part_test_int4_ops is defined in insert.sql.
@@ -4191,233 +5394,430 @@
 	a int,
 	b int
 ) PARTITION BY HASH (a part_test_int4_ops);
+ERROR:  at or near "hash": syntax error
+DETAIL:  source SQL:
+CREATE TABLE hash_parted (
+	a int,
+	b int
+) PARTITION BY HASH (a part_test_int4_ops)
+               ^
+HINT:  try \h CREATE TABLE
 CREATE TABLE hpart_1 PARTITION OF hash_parted FOR VALUES WITH (MODULUS 4, REMAINDER 0);
+ERROR:  at or near "partition": syntax error
+DETAIL:  source SQL:
+CREATE TABLE hpart_1 PARTITION OF hash_parted FOR VALUES WITH (MODULUS 4, REMAINDER 0)
+                     ^
+HINT:  try \h CREATE TABLE
 CREATE TABLE fail_part (LIKE hpart_1);
+ERROR:  relation "hpart_1" does not exist
 ALTER TABLE hash_parted ATTACH PARTITION fail_part FOR VALUES WITH (MODULUS 8, REMAINDER 4);
-ERROR:  partition "fail_part" would overlap partition "hpart_1"
-LINE 1: ...hash_parted ATTACH PARTITION fail_part FOR VALUES WITH (MODU...
-                                                             ^
+ERROR:  at or near "attach": syntax error
+DETAIL:  source SQL:
+ALTER TABLE hash_parted ATTACH PARTITION fail_part FOR VALUES WITH (MODULUS 8, REMAINDER 4)
+                        ^
+HINT:  try \h ALTER TABLE
 ALTER TABLE hash_parted ATTACH PARTITION fail_part FOR VALUES WITH (MODULUS 8, REMAINDER 0);
-ERROR:  partition "fail_part" would overlap partition "hpart_1"
-LINE 1: ...hash_parted ATTACH PARTITION fail_part FOR VALUES WITH (MODU...
-                                                             ^
+ERROR:  at or near "attach": syntax error
+DETAIL:  source SQL:
+ALTER TABLE hash_parted ATTACH PARTITION fail_part FOR VALUES WITH (MODULUS 8, REMAINDER 0)
+                        ^
+HINT:  try \h ALTER TABLE
 DROP TABLE fail_part;
+ERROR:  relation "fail_part" does not exist
 -- check validation when attaching hash partitions
 -- check that violating rows are correctly reported
 CREATE TABLE hpart_2 (LIKE hash_parted);
+ERROR:  relation "hash_parted" does not exist
 INSERT INTO hpart_2 VALUES (3, 0);
+ERROR:  relation "hpart_2" does not exist
 ALTER TABLE hash_parted ATTACH PARTITION hpart_2 FOR VALUES WITH (MODULUS 4, REMAINDER 1);
-ERROR:  partition constraint of relation "hpart_2" is violated by some row
+ERROR:  at or near "attach": syntax error
+DETAIL:  source SQL:
+ALTER TABLE hash_parted ATTACH PARTITION hpart_2 FOR VALUES WITH (MODULUS 4, REMAINDER 1)
+                        ^
+HINT:  try \h ALTER TABLE
 -- should be ok after deleting the bad row
 DELETE FROM hpart_2;
+ERROR:  relation "hpart_2" does not exist
 ALTER TABLE hash_parted ATTACH PARTITION hpart_2 FOR VALUES WITH (MODULUS 4, REMAINDER 1);
+ERROR:  at or near "attach": syntax error
+DETAIL:  source SQL:
+ALTER TABLE hash_parted ATTACH PARTITION hpart_2 FOR VALUES WITH (MODULUS 4, REMAINDER 1)
+                        ^
+HINT:  try \h ALTER TABLE
 -- check that leaf partitions are scanned when attaching a partitioned
 -- table
 CREATE TABLE hpart_5 (
 	LIKE hash_parted
 ) PARTITION BY LIST (b);
+ERROR:  at or near "EOF": syntax error
+DETAIL:  source SQL:
+CREATE TABLE hpart_5 (
+	LIKE hash_parted
+) PARTITION BY LIST (b)
+                       ^
+HINT:  try \h CREATE TABLE
 -- check that violating rows are correctly reported
 CREATE TABLE hpart_5_a PARTITION OF hpart_5 FOR VALUES IN ('1', '2', '3');
+ERROR:  at or near "partition": syntax error
+DETAIL:  source SQL:
+CREATE TABLE hpart_5_a PARTITION OF hpart_5 FOR VALUES IN ('1', '2', '3')
+                       ^
+HINT:  try \h CREATE TABLE
 INSERT INTO hpart_5_a (a, b) VALUES (7, 1);
+ERROR:  relation "hpart_5_a" does not exist
 ALTER TABLE hash_parted ATTACH PARTITION hpart_5 FOR VALUES WITH (MODULUS 4, REMAINDER 2);
-ERROR:  partition constraint of relation "hpart_5_a" is violated by some row
+ERROR:  at or near "attach": syntax error
+DETAIL:  source SQL:
+ALTER TABLE hash_parted ATTACH PARTITION hpart_5 FOR VALUES WITH (MODULUS 4, REMAINDER 2)
+                        ^
+HINT:  try \h ALTER TABLE
 -- should be ok after deleting the bad row
 DELETE FROM hpart_5_a;
+ERROR:  relation "hpart_5_a" does not exist
 ALTER TABLE hash_parted ATTACH PARTITION hpart_5 FOR VALUES WITH (MODULUS 4, REMAINDER 2);
+ERROR:  at or near "attach": syntax error
+DETAIL:  source SQL:
+ALTER TABLE hash_parted ATTACH PARTITION hpart_5 FOR VALUES WITH (MODULUS 4, REMAINDER 2)
+                        ^
+HINT:  try \h ALTER TABLE
 -- check that the table being attach is with valid modulus and remainder value
 CREATE TABLE fail_part(LIKE hash_parted);
+ERROR:  relation "hash_parted" does not exist
 ALTER TABLE hash_parted ATTACH PARTITION fail_part FOR VALUES WITH (MODULUS 0, REMAINDER 1);
-ERROR:  modulus for hash partition must be an integer value greater than zero
+ERROR:  at or near "attach": syntax error
+DETAIL:  source SQL:
+ALTER TABLE hash_parted ATTACH PARTITION fail_part FOR VALUES WITH (MODULUS 0, REMAINDER 1)
+                        ^
+HINT:  try \h ALTER TABLE
 ALTER TABLE hash_parted ATTACH PARTITION fail_part FOR VALUES WITH (MODULUS 8, REMAINDER 8);
-ERROR:  remainder for hash partition must be less than modulus
+ERROR:  at or near "attach": syntax error
+DETAIL:  source SQL:
+ALTER TABLE hash_parted ATTACH PARTITION fail_part FOR VALUES WITH (MODULUS 8, REMAINDER 8)
+                        ^
+HINT:  try \h ALTER TABLE
 ALTER TABLE hash_parted ATTACH PARTITION fail_part FOR VALUES WITH (MODULUS 3, REMAINDER 2);
-ERROR:  every hash partition modulus must be a factor of the next larger modulus
-DETAIL:  The new modulus 3 is not a factor of 4, the modulus of existing partition "hpart_1".
+ERROR:  at or near "attach": syntax error
+DETAIL:  source SQL:
+ALTER TABLE hash_parted ATTACH PARTITION fail_part FOR VALUES WITH (MODULUS 3, REMAINDER 2)
+                        ^
+HINT:  try \h ALTER TABLE
 DROP TABLE fail_part;
+ERROR:  relation "fail_part" does not exist
 --
 -- DETACH PARTITION
 --
 -- check that the table is partitioned at all
 CREATE TABLE regular_table (a int);
 ALTER TABLE regular_table DETACH PARTITION any_name;
-ERROR:  table "regular_table" is not partitioned
+ERROR:  at or near "detach": syntax error
+DETAIL:  source SQL:
+ALTER TABLE regular_table DETACH PARTITION any_name
+                          ^
+HINT:  try \h ALTER TABLE
 DROP TABLE regular_table;
 -- check that the partition being detached exists at all
 ALTER TABLE list_parted2 DETACH PARTITION part_4;
-ERROR:  relation "part_4" does not exist
+ERROR:  at or near "detach": syntax error
+DETAIL:  source SQL:
+ALTER TABLE list_parted2 DETACH PARTITION part_4
+                         ^
+HINT:  try \h ALTER TABLE
 ALTER TABLE hash_parted DETACH PARTITION hpart_4;
-ERROR:  relation "hpart_4" does not exist
+ERROR:  at or near "detach": syntax error
+DETAIL:  source SQL:
+ALTER TABLE hash_parted DETACH PARTITION hpart_4
+                        ^
+HINT:  try \h ALTER TABLE
 -- check that the partition being detached is actually a partition of the parent
 CREATE TABLE not_a_part (a int);
 ALTER TABLE list_parted2 DETACH PARTITION not_a_part;
-ERROR:  relation "not_a_part" is not a partition of relation "list_parted2"
+ERROR:  at or near "detach": syntax error
+DETAIL:  source SQL:
+ALTER TABLE list_parted2 DETACH PARTITION not_a_part
+                         ^
+HINT:  try \h ALTER TABLE
 ALTER TABLE list_parted2 DETACH PARTITION part_1;
-ERROR:  relation "part_1" is not a partition of relation "list_parted2"
+ERROR:  at or near "detach": syntax error
+DETAIL:  source SQL:
+ALTER TABLE list_parted2 DETACH PARTITION part_1
+                         ^
+HINT:  try \h ALTER TABLE
 ALTER TABLE hash_parted DETACH PARTITION not_a_part;
-ERROR:  relation "not_a_part" is not a partition of relation "hash_parted"
+ERROR:  at or near "detach": syntax error
+DETAIL:  source SQL:
+ALTER TABLE hash_parted DETACH PARTITION not_a_part
+                        ^
+HINT:  try \h ALTER TABLE
 DROP TABLE not_a_part;
 -- check that, after being detached, attinhcount/coninhcount is dropped to 0 and
 -- attislocal/conislocal is set to true
 ALTER TABLE list_parted2 DETACH PARTITION part_3_4;
+ERROR:  at or near "detach": syntax error
+DETAIL:  source SQL:
+ALTER TABLE list_parted2 DETACH PARTITION part_3_4
+                         ^
+HINT:  try \h ALTER TABLE
 SELECT attinhcount, attislocal FROM pg_attribute WHERE attrelid = 'part_3_4'::regclass AND attnum > 0;
- attinhcount | attislocal 
--------------+------------
-           0 | t
-           0 | t
-(2 rows)
-
+ERROR:  relation "part_3_4" does not exist
 SELECT coninhcount, conislocal FROM pg_constraint WHERE conrelid = 'part_3_4'::regclass AND conname = 'check_a';
- coninhcount | conislocal 
--------------+------------
-           0 | t
-(1 row)
-
+ERROR:  relation "part_3_4" does not exist
 DROP TABLE part_3_4;
+ERROR:  relation "part_3_4" does not exist
 -- check that a detached partition is not dropped on dropping a partitioned table
 CREATE TABLE range_parted2 (
     a int
 ) PARTITION BY RANGE(a);
+ERROR:  at or near "EOF": syntax error
+DETAIL:  source SQL:
+CREATE TABLE range_parted2 (
+    a int
+) PARTITION BY RANGE(a)
+                       ^
+HINT:  try \h CREATE TABLE
 CREATE TABLE part_rp PARTITION OF range_parted2 FOR VALUES FROM (0) to (100);
+ERROR:  at or near "partition": syntax error
+DETAIL:  source SQL:
+CREATE TABLE part_rp PARTITION OF range_parted2 FOR VALUES FROM (0) to (100)
+                     ^
+HINT:  try \h CREATE TABLE
 ALTER TABLE range_parted2 DETACH PARTITION part_rp;
+ERROR:  at or near "detach": syntax error
+DETAIL:  source SQL:
+ALTER TABLE range_parted2 DETACH PARTITION part_rp
+                          ^
+HINT:  try \h ALTER TABLE
 DROP TABLE range_parted2;
+ERROR:  relation "range_parted2" does not exist
 SELECT * from part_rp;
- a 
----
-(0 rows)
-
+ERROR:  relation "part_rp" does not exist
 DROP TABLE part_rp;
+ERROR:  relation "part_rp" does not exist
 -- concurrent detach
 CREATE TABLE range_parted2 (
 	a int
 ) PARTITION BY RANGE(a);
+ERROR:  at or near "EOF": syntax error
+DETAIL:  source SQL:
+CREATE TABLE range_parted2 (
+	a int
+) PARTITION BY RANGE(a)
+                       ^
+HINT:  try \h CREATE TABLE
 CREATE TABLE part_rp PARTITION OF range_parted2 FOR VALUES FROM (0) to (100);
+ERROR:  at or near "partition": syntax error
+DETAIL:  source SQL:
+CREATE TABLE part_rp PARTITION OF range_parted2 FOR VALUES FROM (0) to (100)
+                     ^
+HINT:  try \h CREATE TABLE
 BEGIN;
 -- doesn't work in a partition block
 ALTER TABLE range_parted2 DETACH PARTITION part_rp CONCURRENTLY;
-ERROR:  ALTER TABLE ... DETACH CONCURRENTLY cannot run inside a transaction block
+ERROR:  at or near "detach": syntax error
+DETAIL:  source SQL:
+ALTER TABLE range_parted2 DETACH PARTITION part_rp CONCURRENTLY
+                          ^
+HINT:  try \h ALTER TABLE
 COMMIT;
 CREATE TABLE part_rpd PARTITION OF range_parted2 DEFAULT;
+ERROR:  at or near "partition": syntax error
+DETAIL:  source SQL:
+CREATE TABLE part_rpd PARTITION OF range_parted2 DEFAULT
+                      ^
+HINT:  try \h CREATE TABLE
 -- doesn't work if there's a default partition
 ALTER TABLE range_parted2 DETACH PARTITION part_rp CONCURRENTLY;
-ERROR:  cannot detach partitions concurrently when a default partition exists
+ERROR:  at or near "detach": syntax error
+DETAIL:  source SQL:
+ALTER TABLE range_parted2 DETACH PARTITION part_rp CONCURRENTLY
+                          ^
+HINT:  try \h ALTER TABLE
 -- doesn't work for the default partition
 ALTER TABLE range_parted2 DETACH PARTITION part_rpd CONCURRENTLY;
-ERROR:  cannot detach partitions concurrently when a default partition exists
+ERROR:  at or near "detach": syntax error
+DETAIL:  source SQL:
+ALTER TABLE range_parted2 DETACH PARTITION part_rpd CONCURRENTLY
+                          ^
+HINT:  try \h ALTER TABLE
 DROP TABLE part_rpd;
+ERROR:  relation "part_rpd" does not exist
 -- works fine
 ALTER TABLE range_parted2 DETACH PARTITION part_rp CONCURRENTLY;
+ERROR:  at or near "detach": syntax error
+DETAIL:  source SQL:
+ALTER TABLE range_parted2 DETACH PARTITION part_rp CONCURRENTLY
+                          ^
+HINT:  try \h ALTER TABLE
 \d+ range_parted2
-                         Partitioned table "public.range_parted2"
- Column |  Type   | Collation | Nullable | Default | Storage | Stats target | Description 
---------+---------+-----------+----------+---------+---------+--------------+-------------
- a      | integer |           |          |         | plain   |              | 
-Partition key: RANGE (a)
-Number of partitions: 0
-
+ERROR:  at or near ".": syntax error
+DETAIL:  source SQL:
+SELECT c.oid,
+  n.nspname,
+  c.relname
+FROM pg_catalog.pg_class c
+     LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace
+WHERE c.relname OPERATOR(pg_catalog.~) '^(range_parted2)$' COLLATE pg_catalog.default
+                                                                             ^
 -- constraint should be created
 \d part_rp
-              Table "public.part_rp"
- Column |  Type   | Collation | Nullable | Default 
---------+---------+-----------+----------+---------
- a      | integer |           |          | 
-Check constraints:
-    "part_rp_a_check" CHECK (a IS NOT NULL AND a >= 0 AND a < 100)
-
+ERROR:  at or near ".": syntax error
+DETAIL:  source SQL:
+SELECT c.oid,
+  n.nspname,
+  c.relname
+FROM pg_catalog.pg_class c
+     LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace
+WHERE c.relname OPERATOR(pg_catalog.~) '^(part_rp)$' COLLATE pg_catalog.default
+                                                                       ^
 CREATE TABLE part_rp100 PARTITION OF range_parted2 (CHECK (a>=123 AND a<133 AND a IS NOT NULL)) FOR VALUES FROM (100) to (200);
+ERROR:  at or near "partition": syntax error
+DETAIL:  source SQL:
+CREATE TABLE part_rp100 PARTITION OF range_parted2 (CHECK (a>=123 AND a<133 AND a IS NOT NULL)) FOR VALUES FROM (100) to (200)
+                        ^
+HINT:  try \h CREATE TABLE
 ALTER TABLE range_parted2 DETACH PARTITION part_rp100 CONCURRENTLY;
+ERROR:  at or near "detach": syntax error
+DETAIL:  source SQL:
+ALTER TABLE range_parted2 DETACH PARTITION part_rp100 CONCURRENTLY
+                          ^
+HINT:  try \h ALTER TABLE
 -- redundant constraint should not be created
 \d part_rp100
-             Table "public.part_rp100"
- Column |  Type   | Collation | Nullable | Default 
---------+---------+-----------+----------+---------
- a      | integer |           |          | 
-Check constraints:
-    "part_rp100_a_check" CHECK (a >= 123 AND a < 133 AND a IS NOT NULL)
-
+ERROR:  at or near ".": syntax error
+DETAIL:  source SQL:
+SELECT c.oid,
+  n.nspname,
+  c.relname
+FROM pg_catalog.pg_class c
+     LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace
+WHERE c.relname OPERATOR(pg_catalog.~) '^(part_rp100)$' COLLATE pg_catalog.default
+                                                                          ^
 DROP TABLE range_parted2;
+ERROR:  relation "range_parted2" does not exist
 -- Check ALTER TABLE commands for partitioned tables and partitions
 -- cannot add/drop column to/from *only* the parent
 ALTER TABLE ONLY list_parted2 ADD COLUMN c int;
-ERROR:  column must be added to child tables too
+ERROR:  relation "list_parted2" does not exist
 ALTER TABLE ONLY list_parted2 DROP COLUMN b;
-ERROR:  cannot drop column from only the partitioned table when partitions exist
-HINT:  Do not specify the ONLY keyword.
+ERROR:  relation "list_parted2" does not exist
 -- cannot add a column to partition or drop an inherited one
 ALTER TABLE part_2 ADD COLUMN c text;
-ERROR:  cannot add column to a partition
+ERROR:  relation "part_2" does not exist
 ALTER TABLE part_2 DROP COLUMN b;
-ERROR:  cannot drop inherited column "b"
+ERROR:  relation "part_2" does not exist
 -- Nor rename, alter type
 ALTER TABLE part_2 RENAME COLUMN b to c;
-ERROR:  cannot rename inherited column "b"
+ERROR:  relation "part_2" does not exist
 ALTER TABLE part_2 ALTER COLUMN b TYPE text;
-ERROR:  cannot alter inherited column "b"
+ERROR:  relation "part_2" does not exist
 -- cannot add/drop NOT NULL or check constraints to *only* the parent, when
 -- partitions exist
 ALTER TABLE ONLY list_parted2 ALTER b SET NOT NULL;
-ERROR:  constraint must be added to child tables too
-DETAIL:  Column "b" of relation "part_2" is not already NOT NULL.
-HINT:  Do not specify the ONLY keyword.
+ERROR:  relation "list_parted2" does not exist
 ALTER TABLE ONLY list_parted2 ADD CONSTRAINT check_b CHECK (b <> 'zz');
-ERROR:  constraint must be added to child tables too
+ERROR:  relation "list_parted2" does not exist
 ALTER TABLE list_parted2 ALTER b SET NOT NULL;
+ERROR:  relation "list_parted2" does not exist
 ALTER TABLE ONLY list_parted2 ALTER b DROP NOT NULL;
-ERROR:  cannot remove constraint from only the partitioned table when partitions exist
-HINT:  Do not specify the ONLY keyword.
+ERROR:  relation "list_parted2" does not exist
 ALTER TABLE list_parted2 ADD CONSTRAINT check_b CHECK (b <> 'zz');
+ERROR:  relation "list_parted2" does not exist
 ALTER TABLE ONLY list_parted2 DROP CONSTRAINT check_b;
-ERROR:  cannot remove constraint from only the partitioned table when partitions exist
-HINT:  Do not specify the ONLY keyword.
+ERROR:  relation "list_parted2" does not exist
 -- It's alright though, if no partitions are yet created
 CREATE TABLE parted_no_parts (a int) PARTITION BY LIST (a);
+ERROR:  at or near "EOF": syntax error
+DETAIL:  source SQL:
+CREATE TABLE parted_no_parts (a int) PARTITION BY LIST (a)
+                                                          ^
+HINT:  try \h CREATE TABLE
 ALTER TABLE ONLY parted_no_parts ALTER a SET NOT NULL;
+ERROR:  relation "parted_no_parts" does not exist
 ALTER TABLE ONLY parted_no_parts ADD CONSTRAINT check_a CHECK (a > 0);
+ERROR:  relation "parted_no_parts" does not exist
 ALTER TABLE ONLY parted_no_parts ALTER a DROP NOT NULL;
+ERROR:  relation "parted_no_parts" does not exist
 ALTER TABLE ONLY parted_no_parts DROP CONSTRAINT check_a;
+ERROR:  relation "parted_no_parts" does not exist
 DROP TABLE parted_no_parts;
+ERROR:  relation "parted_no_parts" does not exist
 -- cannot drop inherited NOT NULL or check constraints from partition
 ALTER TABLE list_parted2 ALTER b SET NOT NULL, ADD CONSTRAINT check_a2 CHECK (a > 0);
+ERROR:  relation "list_parted2" does not exist
 ALTER TABLE part_2 ALTER b DROP NOT NULL;
-ERROR:  column "b" is marked NOT NULL in parent table
+ERROR:  relation "part_2" does not exist
 ALTER TABLE part_2 DROP CONSTRAINT check_a2;
-ERROR:  cannot drop inherited constraint "check_a2" of relation "part_2"
+ERROR:  relation "part_2" does not exist
 -- Doesn't make sense to add NO INHERIT constraints on partitioned tables
 ALTER TABLE list_parted2 add constraint check_b2 check (b <> 'zz') NO INHERIT;
-ERROR:  cannot add NO INHERIT constraint to partitioned table "list_parted2"
+ERROR:  at or near "no": syntax error
+DETAIL:  source SQL:
+ALTER TABLE list_parted2 add constraint check_b2 check (b <> 'zz') NO INHERIT
+                                                                   ^
 -- check that a partition cannot participate in regular inheritance
 CREATE TABLE inh_test () INHERITS (part_2);
-ERROR:  cannot inherit from partition "part_2"
+ERROR:  at or near "(": syntax error: unimplemented: this syntax
+DETAIL:  source SQL:
+CREATE TABLE inh_test () INHERITS (part_2)
+                                  ^
+HINT:  You have attempted to use a feature that is not yet implemented.
+See: https://go.crdb.dev/issue-v/22456/_version_
 CREATE TABLE inh_test (LIKE part_2);
+ERROR:  relation "part_2" does not exist
 ALTER TABLE inh_test INHERIT part_2;
-ERROR:  cannot inherit from a partition
+ERROR:  at or near "inherit": syntax error
+DETAIL:  source SQL:
+ALTER TABLE inh_test INHERIT part_2
+                     ^
+HINT:  try \h ALTER TABLE
 ALTER TABLE part_2 INHERIT inh_test;
-ERROR:  cannot change inheritance of a partition
+ERROR:  at or near "inherit": syntax error
+DETAIL:  source SQL:
+ALTER TABLE part_2 INHERIT inh_test
+                   ^
+HINT:  try \h ALTER TABLE
 -- cannot drop or alter type of partition key columns of lower level
 -- partitioned tables; for example, part_5, which is list_parted2's
 -- partition, is partitioned on b;
 ALTER TABLE list_parted2 DROP COLUMN b;
-ERROR:  cannot drop column "b" because it is part of the partition key of relation "part_5"
+ERROR:  relation "list_parted2" does not exist
 ALTER TABLE list_parted2 ALTER COLUMN b TYPE text;
-ERROR:  cannot alter column "b" because it is part of the partition key of relation "part_5"
+ERROR:  relation "list_parted2" does not exist
 -- dropping non-partition key columns should be allowed on the parent table.
 ALTER TABLE list_parted DROP COLUMN b;
+ERROR:  relation "list_parted" does not exist
 SELECT * FROM list_parted;
- a 
----
-(0 rows)
-
+ERROR:  relation "list_parted" does not exist
 -- cleanup
 DROP TABLE list_parted, list_parted2, range_parted;
+ERROR:  relation "list_parted" does not exist
 DROP TABLE fail_def_part;
+ERROR:  relation "fail_def_part" does not exist
 DROP TABLE hash_parted;
+ERROR:  relation "hash_parted" does not exist
 -- more tests for certain multi-level partitioning scenarios
 create table p (a int, b int) partition by range (a, b);
+ERROR:  at or near "EOF": syntax error
+DETAIL:  source SQL:
+create table p (a int, b int) partition by range (a, b)
+                                                       ^
+HINT:  try \h CREATE TABLE
 create table p1 (b int, a int not null) partition by range (b);
+ERROR:  at or near "EOF": syntax error
+DETAIL:  source SQL:
+create table p1 (b int, a int not null) partition by range (b)
+                                                              ^
+HINT:  try \h CREATE TABLE
 create table p11 (like p1);
+ERROR:  relation "p1" does not exist
 alter table p11 drop a;
+ERROR:  relation "p11" does not exist
 alter table p11 add a int;
+ERROR:  relation "p11" does not exist
 alter table p11 drop a;
+ERROR:  relation "p11" does not exist
 alter table p11 add a int not null;
+ERROR:  relation "p11" does not exist
 -- attnum for key attribute 'a' is different in p, p1, and p11
 select attrelid::regclass, attname, attnum
 from pg_attribute
@@ -4426,73 +5826,156 @@
    or attrelid = 'p1'::regclass
    or attrelid = 'p11'::regclass)
 order by attrelid::regclass::text;
- attrelid | attname | attnum 
-----------+---------+--------
- p        | a       |      1
- p1       | a       |      2
- p11      | a       |      4
-(3 rows)
-
+ERROR:  relation "p" does not exist
 alter table p1 attach partition p11 for values from (2) to (5);
+ERROR:  at or near "attach": syntax error
+DETAIL:  source SQL:
+alter table p1 attach partition p11 for values from (2) to (5)
+               ^
+HINT:  try \h ALTER TABLE
 insert into p1 (a, b) values (2, 3);
+ERROR:  relation "p1" does not exist
 -- check that partition validation scan correctly detects violating rows
 alter table p attach partition p1 for values from (1, 2) to (1, 10);
-ERROR:  partition constraint of relation "p11" is violated by some row
+ERROR:  at or near "attach": syntax error
+DETAIL:  source SQL:
+alter table p attach partition p1 for values from (1, 2) to (1, 10)
+              ^
+HINT:  try \h ALTER TABLE
 -- cleanup
 drop table p;
+ERROR:  relation "p" does not exist
 drop table p1;
+ERROR:  relation "p1" does not exist
 -- validate constraint on partitioned tables should only scan leaf partitions
 create table parted_validate_test (a int) partition by list (a);
+ERROR:  at or near "EOF": syntax error
+DETAIL:  source SQL:
+create table parted_validate_test (a int) partition by list (a)
+                                                               ^
+HINT:  try \h CREATE TABLE
 create table parted_validate_test_1 partition of parted_validate_test for values in (0, 1);
+ERROR:  at or near "partition": syntax error
+DETAIL:  source SQL:
+create table parted_validate_test_1 partition of parted_validate_test for values in (0, 1)
+                                    ^
+HINT:  try \h CREATE TABLE
 alter table parted_validate_test add constraint parted_validate_test_chka check (a > 0) not valid;
+ERROR:  relation "parted_validate_test" does not exist
 alter table parted_validate_test validate constraint parted_validate_test_chka;
+ERROR:  relation "parted_validate_test" does not exist
 drop table parted_validate_test;
+ERROR:  relation "parted_validate_test" does not exist
 -- test alter column options
 CREATE TABLE attmp(i integer);
 INSERT INTO attmp VALUES (1);
 ALTER TABLE attmp ALTER COLUMN i SET (n_distinct = 1, n_distinct_inherited = 2);
+ERROR:  at or near "(": syntax error
+DETAIL:  source SQL:
+ALTER TABLE attmp ALTER COLUMN i SET (n_distinct = 1, n_distinct_inherited = 2)
+                                     ^
+HINT:  try \h ALTER TABLE
 ALTER TABLE attmp ALTER COLUMN i RESET (n_distinct_inherited);
+ERROR:  at or near "reset": syntax error
+DETAIL:  source SQL:
+ALTER TABLE attmp ALTER COLUMN i RESET (n_distinct_inherited)
+                                 ^
+HINT:  try \h ALTER TABLE
 ANALYZE attmp;
 DROP TABLE attmp;
 DROP USER regress_alter_table_user1;
 -- check that violating rows are correctly reported when attaching as the
 -- default partition
 create table defpart_attach_test (a int) partition by list (a);
+ERROR:  at or near "EOF": syntax error
+DETAIL:  source SQL:
+create table defpart_attach_test (a int) partition by list (a)
+                                                              ^
+HINT:  try \h CREATE TABLE
 create table defpart_attach_test1 partition of defpart_attach_test for values in (1);
+ERROR:  at or near "partition": syntax error
+DETAIL:  source SQL:
+create table defpart_attach_test1 partition of defpart_attach_test for values in (1)
+                                  ^
+HINT:  try \h CREATE TABLE
 create table defpart_attach_test_d (b int, a int);
 alter table defpart_attach_test_d drop b;
 insert into defpart_attach_test_d values (1), (2);
 -- error because its constraint as the default partition would be violated
 -- by the row containing 1
 alter table defpart_attach_test attach partition defpart_attach_test_d default;
-ERROR:  partition constraint of relation "defpart_attach_test_d" is violated by some row
+ERROR:  at or near "attach": syntax error
+DETAIL:  source SQL:
+alter table defpart_attach_test attach partition defpart_attach_test_d default
+                                ^
+HINT:  try \h ALTER TABLE
 delete from defpart_attach_test_d where a = 1;
 alter table defpart_attach_test_d add check (a > 1);
 -- should be attached successfully and without needing to be scanned
 alter table defpart_attach_test attach partition defpart_attach_test_d default;
+ERROR:  at or near "attach": syntax error
+DETAIL:  source SQL:
+alter table defpart_attach_test attach partition defpart_attach_test_d default
+                                ^
+HINT:  try \h ALTER TABLE
 -- check that attaching a partition correctly reports any rows in the default
 -- partition that should not be there for the new partition to be attached
 -- successfully
 create table defpart_attach_test_2 (like defpart_attach_test_d);
 alter table defpart_attach_test attach partition defpart_attach_test_2 for values in (2);
-ERROR:  updated partition constraint for default partition "defpart_attach_test_d" would be violated by some row
+ERROR:  at or near "attach": syntax error
+DETAIL:  source SQL:
+alter table defpart_attach_test attach partition defpart_attach_test_2 for values in (2)
+                                ^
+HINT:  try \h ALTER TABLE
 drop table defpart_attach_test;
+ERROR:  relation "defpart_attach_test" does not exist
 -- check combinations of temporary and permanent relations when attaching
 -- partitions.
 create table perm_part_parent (a int) partition by list (a);
+ERROR:  at or near "EOF": syntax error
+DETAIL:  source SQL:
+create table perm_part_parent (a int) partition by list (a)
+                                                           ^
+HINT:  try \h CREATE TABLE
 create temp table temp_part_parent (a int) partition by list (a);
+ERROR:  at or near "EOF": syntax error
+DETAIL:  source SQL:
+create temp table temp_part_parent (a int) partition by list (a)
+                                                                ^
+HINT:  try \h CREATE TABLE
 create table perm_part_child (a int);
 create temp table temp_part_child (a int);
 alter table temp_part_parent attach partition perm_part_child default; -- error
-ERROR:  cannot attach a permanent relation as partition of temporary relation "temp_part_parent"
+ERROR:  at or near "attach": syntax error
+DETAIL:  source SQL:
+alter table temp_part_parent attach partition perm_part_child default
+                             ^
+HINT:  try \h ALTER TABLE
 alter table perm_part_parent attach partition temp_part_child default; -- error
-ERROR:  cannot attach a temporary relation as partition of permanent relation "perm_part_parent"
+ERROR:  at or near "attach": syntax error
+DETAIL:  source SQL:
+alter table perm_part_parent attach partition temp_part_child default
+                             ^
+HINT:  try \h ALTER TABLE
 alter table temp_part_parent attach partition temp_part_child default; -- ok
+ERROR:  at or near "attach": syntax error
+DETAIL:  source SQL:
+alter table temp_part_parent attach partition temp_part_child default
+                             ^
+HINT:  try \h ALTER TABLE
 drop table perm_part_parent cascade;
+ERROR:  relation "perm_part_parent" does not exist
 drop table temp_part_parent cascade;
+ERROR:  relation "temp_part_parent" does not exist
 -- check that attaching partitions to a table while it is being used is
 -- prevented
 create table tab_part_attach (a int) partition by list (a);
+ERROR:  at or near "EOF": syntax error
+DETAIL:  source SQL:
+create table tab_part_attach (a int) partition by list (a)
+                                                          ^
+HINT:  try \h CREATE TABLE
 create or replace function func_part_attach() returns trigger
   language plpgsql as $$
   begin
@@ -4500,14 +5983,28 @@
     execute 'alter table tab_part_attach attach partition tab_part_attach_1 for values in (1)';
     return null;
   end $$;
+ERROR:  unimplemented: attempted to use a PL/pgSQL statement that is not yet supported
+DETAIL:  stmt_dyn_exec is not yet supported
+HINT:  You have attempted to use a feature that is not yet implemented.
+
+Please check the public issue tracker to check whether this problem is
+already tracked. If you cannot find it there, please report the error
+with details by creating a new issue.
+
+If you would rather not post publicly, please contact us directly
+using the support form.
+
+We appreciate your feedback.
+
 create trigger trig_part_attach before insert on tab_part_attach
   for each statement execute procedure func_part_attach();
+ERROR:  relation "tab_part_attach" does not exist
 insert into tab_part_attach values (1);
-ERROR:  cannot ALTER TABLE "tab_part_attach" because it is being used by active queries in this session
-CONTEXT:  SQL statement "alter table tab_part_attach attach partition tab_part_attach_1 for values in (1)"
-PL/pgSQL function func_part_attach() line 4 at EXECUTE
+ERROR:  relation "tab_part_attach" does not exist
 drop table tab_part_attach;
+ERROR:  relation "tab_part_attach" does not exist
 drop function func_part_attach();
+ERROR:  unknown function: func_part_attach()
 -- test case where the partitioning operator is a SQL function whose
 -- evaluation results in the table's relcache being rebuilt partway through
 -- the execution of an ATTACH PARTITION command
@@ -4517,11 +6014,43 @@
     operator 1 < (int4, int4), operator 2 <= (int4, int4),
     operator 3 = (int4, int4), operator 4 >= (int4, int4),
     operator 5 > (int4, int4), function 1 at_test_sql_partop(int4, int4);
+ERROR:  at or near "class": syntax error: unimplemented: this syntax
+DETAIL:  source SQL:
+create operator class at_test_sql_partop for type int4 using btree as
+                ^
+HINT:  You have attempted to use a feature that is not yet implemented.
+See: https://go.crdb.dev/issue-v/65017/_version_
 create table at_test_sql_partop (a int) partition by range (a at_test_sql_partop);
+ERROR:  at or near "at_test_sql_partop": syntax error
+DETAIL:  source SQL:
+create table at_test_sql_partop (a int) partition by range (a at_test_sql_partop)
+                                                              ^
+HINT:  try \h CREATE TABLE
 create table at_test_sql_partop_1 (a int);
 alter table at_test_sql_partop attach partition at_test_sql_partop_1 for values from (0) to (10);
+ERROR:  at or near "attach": syntax error
+DETAIL:  source SQL:
+alter table at_test_sql_partop attach partition at_test_sql_partop_1 for values from (0) to (10)
+                               ^
+HINT:  try \h ALTER TABLE
 drop table at_test_sql_partop;
+ERROR:  relation "at_test_sql_partop" does not exist
 drop operator class at_test_sql_partop using btree;
+ERROR:  at or near "class": syntax error: unimplemented: this syntax
+DETAIL:  source SQL:
+drop operator class at_test_sql_partop using btree
+              ^
+HINT:  You have attempted to use a feature that is not yet implemented.
+
+Please check the public issue tracker to check whether this problem is
+already tracked. If you cannot find it there, please report the error
+with details by creating a new issue.
+
+If you would rather not post publicly, please contact us directly
+using the support form.
+
+We appreciate your feedback.
+
 drop function at_test_sql_partop;
 /* Test case for bug #16242 */
 -- We create a parent and child where the child has missing
@@ -4529,18 +6058,25 @@
 -- tuple conversion from the child to the parent tupdesc
 create table bar1 (a integer, b integer not null default 1)
   partition by range (a);
+ERROR:  at or near "EOF": syntax error
+DETAIL:  source SQL:
+create table bar1 (a integer, b integer not null default 1)
+  partition by range (a)
+                        ^
+HINT:  try \h CREATE TABLE
 create table bar2 (a integer);
 insert into bar2 values (1);
 alter table bar2 add column b integer not null default 1;
 -- (at this point bar2 contains tuple with natts=1)
 alter table bar1 attach partition bar2 default;
+ERROR:  at or near "attach": syntax error
+DETAIL:  source SQL:
+alter table bar1 attach partition bar2 default
+                 ^
+HINT:  try \h ALTER TABLE
 -- this works:
 select * from bar1;
- a | b 
----+---
- 1 | 1
-(1 row)
-
+ERROR:  relation "bar1" does not exist
 -- this exercises tuple conversion:
 create function xtrig()
   returns trigger language plpgsql
@@ -4554,22 +6090,50 @@
     return NULL;
   end;
 $$;
+ERROR:  at or near "in": syntax error: unimplemented: this syntax
+DETAIL:  source SQL:
+declare
+    r record;
+  begin
+    for r in select * from old loop
+          ^
+HINT:  You have attempted to use a feature that is not yet implemented.
+
+Please check the public issue tracker to check whether this problem is
+already tracked. If you cannot find it there, please report the error
+with details by creating a new issue.
+
+If you would rather not post publicly, please contact us directly
+using the support form.
+
+We appreciate your feedback.
+
 create trigger xtrig
   after update on bar1
   referencing old table as old
   for each statement execute procedure xtrig();
+ERROR:  relation "bar1" does not exist
 update bar1 set a = a + 1;
-INFO:  a=1, b=1
+ERROR:  relation "bar1" does not exist
 /* End test case for bug #16242 */
 /* Test case for bug #17409 */
 create table attbl (p1 int constraint pk_attbl primary key);
 create table atref (c1 int references attbl(p1));
 cluster attbl using pk_attbl;
+ERROR:  at or near "cluster": syntax error
+DETAIL:  source SQL:
+cluster attbl using pk_attbl
+^
 alter table attbl alter column p1 set data type bigint;
 alter table atref alter column c1 set data type bigint;
 drop table attbl, atref;
 create table attbl (p1 int constraint pk_attbl primary key);
 alter table attbl replica identity using index pk_attbl;
+ERROR:  at or near "replica": syntax error
+DETAIL:  source SQL:
+alter table attbl replica identity using index pk_attbl
+                  ^
+HINT:  try \h ALTER TABLE
 create table atref (c1 int references attbl(p1));
 alter table attbl alter column p1 set data type bigint;
 alter table atref alter column c1 set data type bigint;
@@ -4579,15 +6143,21 @@
 -- for normal indexes and indexes on constraints.
 create table alttype_cluster (a int);
 alter table alttype_cluster add primary key (a);
+ERROR:  cannot use nullable column "a" in primary key
 create index alttype_cluster_ind on alttype_cluster (a);
 alter table alttype_cluster cluster on alttype_cluster_ind;
+ERROR:  at or near "cluster": syntax error
+DETAIL:  source SQL:
+alter table alttype_cluster cluster on alttype_cluster_ind
+                            ^
+HINT:  try \h ALTER TABLE
 -- Normal index remains clustered.
 select indexrelid::regclass, indisclustered from pg_index
   where indrelid = 'alttype_cluster'::regclass
   order by indexrelid::regclass::text;
       indexrelid      | indisclustered 
 ----------------------+----------------
- alttype_cluster_ind  | t
+ alttype_cluster_ind  | f
  alttype_cluster_pkey | f
 (2 rows)
 
@@ -4597,19 +6167,24 @@
   order by indexrelid::regclass::text;
       indexrelid      | indisclustered 
 ----------------------+----------------
- alttype_cluster_ind  | t
+ alttype_cluster_ind  | f
  alttype_cluster_pkey | f
 (2 rows)
 
 -- Constraint index remains clustered.
 alter table alttype_cluster cluster on alttype_cluster_pkey;
+ERROR:  at or near "cluster": syntax error
+DETAIL:  source SQL:
+alter table alttype_cluster cluster on alttype_cluster_pkey
+                            ^
+HINT:  try \h ALTER TABLE
 select indexrelid::regclass, indisclustered from pg_index
   where indrelid = 'alttype_cluster'::regclass
   order by indexrelid::regclass::text;
       indexrelid      | indisclustered 
 ----------------------+----------------
  alttype_cluster_ind  | f
- alttype_cluster_pkey | t
+ alttype_cluster_pkey | f
 (2 rows)
 
 alter table alttype_cluster alter a type int;
@@ -4619,7 +6194,7 @@
       indexrelid      | indisclustered 
 ----------------------+----------------
  alttype_cluster_ind  | f
- alttype_cluster_pkey | t
+ alttype_cluster_pkey | f
 (2 rows)
 
 drop table alttype_cluster;
@@ -4628,38 +6203,97 @@
 -- to its partitions' constraint being updated to reflect the parent's
 -- newly added/removed constraint
 create table target_parted (a int, b int) partition by list (a);
+ERROR:  at or near "EOF": syntax error
+DETAIL:  source SQL:
+create table target_parted (a int, b int) partition by list (a)
+                                                               ^
+HINT:  try \h CREATE TABLE
 create table attach_parted (a int, b int) partition by list (b);
+ERROR:  at or near "EOF": syntax error
+DETAIL:  source SQL:
+create table attach_parted (a int, b int) partition by list (b)
+                                                               ^
+HINT:  try \h CREATE TABLE
 create table attach_parted_part1 partition of attach_parted for values in (1);
+ERROR:  at or near "partition": syntax error
+DETAIL:  source SQL:
+create table attach_parted_part1 partition of attach_parted for values in (1)
+                                 ^
+HINT:  try \h CREATE TABLE
 -- insert a row directly into the leaf partition so that its partition
 -- constraint is built and stored in the relcache
 insert into attach_parted_part1 values (1, 1);
+ERROR:  relation "attach_parted_part1" does not exist
 -- the following better invalidate the partition constraint of the leaf
 -- partition too...
 alter table target_parted attach partition attach_parted for values in (1);
+ERROR:  at or near "attach": syntax error
+DETAIL:  source SQL:
+alter table target_parted attach partition attach_parted for values in (1)
+                          ^
+HINT:  try \h ALTER TABLE
 -- ...such that the following insert fails
 insert into attach_parted_part1 values (2, 1);
-ERROR:  new row for relation "attach_parted_part1" violates partition constraint
-DETAIL:  Failing row contains (2, 1).
+ERROR:  relation "attach_parted_part1" does not exist
 -- ...and doesn't when the partition is detached along with its own partition
 alter table target_parted detach partition attach_parted;
+ERROR:  at or near "detach": syntax error
+DETAIL:  source SQL:
+alter table target_parted detach partition attach_parted
+                          ^
+HINT:  try \h ALTER TABLE
 insert into attach_parted_part1 values (2, 1);
+ERROR:  relation "attach_parted_part1" does not exist
 -- Test altering table having publication
 create schema alter1;
+ERROR:  schema "alter1" already exists
 create schema alter2;
 create table alter1.t1 (a int);
+ERROR:  relation "root.alter1.t1" already exists
 set client_min_messages = 'ERROR';
 create publication pub1 for table alter1.t1, tables in schema alter2;
+ERROR:  at or near "pub1": syntax error: unimplemented: this syntax
+DETAIL:  source SQL:
+create publication pub1 for table alter1.t1, tables in schema alter2
+                   ^
+HINT:  You have attempted to use a feature that is not yet implemented.
+
+Please check the public issue tracker to check whether this problem is
+already tracked. If you cannot find it there, please report the error
+with details by creating a new issue.
+
+If you would rather not post publicly, please contact us directly
+using the support form.
+
+We appreciate your feedback.
+
 reset client_min_messages;
 alter table alter1.t1 set schema alter2;
 \d+ alter2.t1
-                                    Table "alter2.t1"
- Column |  Type   | Collation | Nullable | Default | Storage | Stats target | Description 
---------+---------+-----------+----------+---------+---------+--------------+-------------
- a      | integer |           |          |         | plain   |              | 
-Publications:
-    "pub1"
-
+ERROR:  at or near ".": syntax error
+DETAIL:  source SQL:
+SELECT c.oid,
+  n.nspname,
+  c.relname
+FROM pg_catalog.pg_class c
+     LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace
+WHERE c.relname OPERATOR(pg_catalog.~) '^(t1)$' COLLATE pg_catalog.default
+                                                                  ^
 drop publication pub1;
+ERROR:  at or near "pub1": syntax error: unimplemented: this syntax
+DETAIL:  source SQL:
+drop publication pub1
+                 ^
+HINT:  You have attempted to use a feature that is not yet implemented.
+
+Please check the public issue tracker to check whether this problem is
+already tracked. If you cannot find it there, please report the error
+with details by creating a new issue.
+
+If you would rather not post publicly, please contact us directly
+using the support form.
+
+We appreciate your feedback.
+
 drop schema alter1 cascade;
 drop schema alter2 cascade;
-NOTICE:  drop cascades to table alter2.t1
