diff -U3 --label=/mnt/data1/postgres/src/test/regress/expected/create_table.out --label=/mnt/data1/postgres/src/test/regress/results/create_table.out /mnt/data1/postgres/src/test/regress/expected/create_table.out /mnt/data1/postgres/src/test/regress/results/create_table.out
--- /mnt/data1/postgres/src/test/regress/expected/create_table.out
+++ /mnt/data1/postgres/src/test/regress/results/create_table.out
@@ -5,70 +5,87 @@
 CREATE TABLE unknowntab (
 	u unknown    -- fail
 );
-ERROR:  column "u" has pseudo-type unknown
+ERROR:  value type unknown cannot be used for table columns
 CREATE TYPE unknown_comptype AS (
 	u unknown    -- fail
 );
-ERROR:  column "u" has pseudo-type unknown
 -- invalid: non-lowercase quoted reloptions identifiers
 CREATE TABLE tas_case WITH ("Fillfactor" = 10) AS SELECT 1 a;
-ERROR:  unrecognized parameter "Fillfactor"
+ERROR:  invalid storage parameter "Fillfactor"
 CREATE UNLOGGED TABLE unlogged1 (a int primary key);			-- OK
+NOTICE:  UNLOGGED TABLE will behave as a regular table in CockroachDB
 CREATE TEMPORARY TABLE unlogged2 (a int primary key);			-- OK
 SELECT relname, relkind, relpersistence FROM pg_class WHERE relname ~ '^unlogged\d' ORDER BY relname;
     relname     | relkind | relpersistence 
 ----------------+---------+----------------
- unlogged1      | r       | u
- unlogged1_pkey | i       | u
+ unlogged1      | r       | p
+ unlogged1_pkey | i       | p
  unlogged2      | r       | t
- unlogged2_pkey | i       | t
+ unlogged2_pkey | i       | p
 (4 rows)
 
 REINDEX INDEX unlogged1_pkey;
+ERROR:  at or near "unlogged1_pkey": syntax error: unimplemented: this syntax
+DETAIL:  source SQL:
+REINDEX INDEX unlogged1_pkey
+              ^
+HINT:  CockroachDB does not require reindexing.
 REINDEX INDEX unlogged2_pkey;
+ERROR:  at or near "unlogged2_pkey": syntax error: unimplemented: this syntax
+DETAIL:  source SQL:
+REINDEX INDEX unlogged2_pkey
+              ^
+HINT:  CockroachDB does not require reindexing.
 SELECT relname, relkind, relpersistence FROM pg_class WHERE relname ~ '^unlogged\d' ORDER BY relname;
     relname     | relkind | relpersistence 
 ----------------+---------+----------------
- unlogged1      | r       | u
- unlogged1_pkey | i       | u
+ unlogged1      | r       | p
+ unlogged1_pkey | i       | p
  unlogged2      | r       | t
- unlogged2_pkey | i       | t
+ unlogged2_pkey | i       | p
 (4 rows)
 
 DROP TABLE unlogged2;
 INSERT INTO unlogged1 VALUES (42);
 CREATE UNLOGGED TABLE public.unlogged2 (a int primary key);		-- also OK
+NOTICE:  UNLOGGED TABLE will behave as a regular table in CockroachDB
 CREATE UNLOGGED TABLE pg_temp.unlogged3 (a int primary key);	-- not OK
-ERROR:  only temporary relations may be created in temporary schemas
-LINE 1: CREATE UNLOGGED TABLE pg_temp.unlogged3 (a int primary key);
-                              ^
 CREATE TABLE pg_temp.implicitly_temp (a int primary key);		-- OK
 CREATE TEMP TABLE explicitly_temp (a int primary key);			-- also OK
 CREATE TEMP TABLE pg_temp.doubly_temp (a int primary key);		-- also OK
 CREATE TEMP TABLE public.temp_to_perm (a int primary key);		-- not OK
 ERROR:  cannot create temporary relation in non-temporary schema
-LINE 1: CREATE TEMP TABLE public.temp_to_perm (a int primary key);
-                          ^
 DROP TABLE unlogged1, public.unlogged2;
 CREATE TABLE as_select1 AS SELECT * FROM pg_class WHERE relkind = 'r';
+NOTICE:  CREATE TABLE ... AS does not copy over indexes, default expressions, or constraints; the new table has a hidden rowid primary key column
 CREATE TABLE as_select1 AS SELECT * FROM pg_class WHERE relkind = 'r';
-ERROR:  relation "as_select1" already exists
+ERROR:  relation "root.public.as_select1" already exists
 CREATE TABLE IF NOT EXISTS as_select1 AS SELECT * FROM pg_class WHERE relkind = 'r';
 NOTICE:  relation "as_select1" already exists, skipping
 DROP TABLE as_select1;
 PREPARE select1 AS SELECT 1 as a;
 CREATE TABLE as_select1 AS EXECUTE select1;
+ERROR:  at or near "execute": syntax error
+DETAIL:  source SQL:
+CREATE TABLE as_select1 AS EXECUTE select1
+                           ^
+HINT:  try \h CREATE TABLE
 CREATE TABLE as_select1 AS EXECUTE select1;
-ERROR:  relation "as_select1" already exists
+ERROR:  at or near "execute": syntax error
+DETAIL:  source SQL:
+CREATE TABLE as_select1 AS EXECUTE select1
+                           ^
+HINT:  try \h CREATE TABLE
 SELECT * FROM as_select1;
- a 
----
- 1
-(1 row)
-
+ERROR:  relation "as_select1" does not exist
 CREATE TABLE IF NOT EXISTS as_select1 AS EXECUTE select1;
-NOTICE:  relation "as_select1" already exists, skipping
+ERROR:  at or near "execute": syntax error
+DETAIL:  source SQL:
+CREATE TABLE IF NOT EXISTS as_select1 AS EXECUTE select1
+                                         ^
+HINT:  try \h CREATE TABLE
 DROP TABLE as_select1;
+ERROR:  relation "as_select1" does not exist
 DEALLOCATE select1;
 -- create an extra wide table to test for issues related to that
 -- (temporarily hide query, to avoid the long CREATE TABLE stmt)
@@ -82,63 +99,77 @@
 
 -- check that tables with oids cannot be created anymore
 CREATE TABLE withoid() WITH OIDS;
-ERROR:  syntax error at or near "OIDS"
-LINE 1: CREATE TABLE withoid() WITH OIDS;
-                                    ^
+ERROR:  at or near "EOF": syntax error: unimplemented: this syntax
+DETAIL:  source SQL:
+CREATE TABLE withoid() WITH OIDS
+                                ^
+HINT:  You have attempted to use a feature that is not yet implemented.
+
+Please check the public issue tracker to check whether this problem is
+already tracked. If you cannot find it there, please report the error
+with details by creating a new issue.
+
+If you would rather not post publicly, please contact us directly
+using the support form.
+
+We appreciate your feedback.
+
 CREATE TABLE withoid() WITH (oids);
-ERROR:  tables declared WITH OIDS are not supported
+ERROR:  at or near ")": syntax error
+DETAIL:  source SQL:
+CREATE TABLE withoid() WITH (oids)
+                                 ^
+HINT:  try \h CREATE TABLE
 CREATE TABLE withoid() WITH (oids = true);
-ERROR:  tables declared WITH OIDS are not supported
+ERROR:  invalid storage parameter "oids"
 -- but explicitly not adding oids is still supported
 CREATE TEMP TABLE withoutoid() WITHOUT OIDS; DROP TABLE withoutoid;
 CREATE TEMP TABLE withoutoid() WITH (oids = false); DROP TABLE withoutoid;
+ERROR:  invalid storage parameter "oids"
+ERROR:  relation "withoutoid" does not exist
 -- check restriction with default expressions
 -- invalid use of column reference in default expressions
 CREATE TABLE default_expr_column (id int DEFAULT (id));
-ERROR:  cannot use column reference in DEFAULT expression
-LINE 1: CREATE TABLE default_expr_column (id int DEFAULT (id));
-                                                          ^
+ERROR:  variable sub-expressions are not allowed in DEFAULT (in CREATE TABLE)
 CREATE TABLE default_expr_column (id int DEFAULT (bar.id));
-ERROR:  cannot use column reference in DEFAULT expression
-LINE 1: CREATE TABLE default_expr_column (id int DEFAULT (bar.id));
-                                                          ^
+ERROR:  variable sub-expressions are not allowed in DEFAULT (in CREATE TABLE)
 CREATE TABLE default_expr_agg_column (id int DEFAULT (avg(id)));
-ERROR:  cannot use column reference in DEFAULT expression
-LINE 1: ...TE TABLE default_expr_agg_column (id int DEFAULT (avg(id)));
-                                                                 ^
+ERROR:  variable sub-expressions are not allowed in DEFAULT (in CREATE TABLE)
 -- invalid column definition
 CREATE TABLE default_expr_non_column (a int DEFAULT (avg(non_existent)));
-ERROR:  cannot use column reference in DEFAULT expression
-LINE 1: ...TABLE default_expr_non_column (a int DEFAULT (avg(non_existe...
-                                                             ^
+ERROR:  variable sub-expressions are not allowed in DEFAULT (in CREATE TABLE)
 -- invalid use of aggregate
 CREATE TABLE default_expr_agg (a int DEFAULT (avg(1)));
-ERROR:  aggregate functions are not allowed in DEFAULT expressions
-LINE 1: CREATE TABLE default_expr_agg (a int DEFAULT (avg(1)));
-                                                      ^
+ERROR:  avg(): aggregate functions are not allowed in DEFAULT (in CREATE TABLE)
 -- invalid use of subquery
 CREATE TABLE default_expr_agg (a int DEFAULT (select 1));
-ERROR:  cannot use subquery in DEFAULT expression
-LINE 1: CREATE TABLE default_expr_agg (a int DEFAULT (select 1));
-                                                     ^
+ERROR:  variable sub-expressions are not allowed in DEFAULT (in CREATE TABLE)
 -- invalid use of set-returning function
 CREATE TABLE default_expr_agg (a int DEFAULT (generate_series(1,3)));
-ERROR:  set-returning functions are not allowed in DEFAULT expressions
-LINE 1: CREATE TABLE default_expr_agg (a int DEFAULT (generate_serie...
-                                                      ^
+ERROR:  generate_series(): set-returning functions are not allowed in DEFAULT (in CREATE TABLE)
 -- Verify that subtransaction rollback restores rd_createSubid.
 BEGIN;
 CREATE TABLE remember_create_subid (c int);
+NOTICE:  auto-committing transaction before processing DDL due to autocommit_before_ddl setting
 SAVEPOINT q; DROP TABLE remember_create_subid; ROLLBACK TO q;
+WARNING:  there is no transaction in progress
+ERROR:  savepoint "q" does not exist
 COMMIT;
+WARNING:  there is no transaction in progress
 DROP TABLE remember_create_subid;
+ERROR:  relation "remember_create_subid" does not exist
 -- Verify that subtransaction rollback restores rd_firstRelfilenodeSubid.
 CREATE TABLE remember_node_subid (c int);
 BEGIN;
 ALTER TABLE remember_node_subid ALTER c TYPE bigint;
+NOTICE:  auto-committing transaction before processing DDL due to autocommit_before_ddl setting
 SAVEPOINT q; DROP TABLE remember_node_subid; ROLLBACK TO q;
+WARNING:  there is no transaction in progress
+ERROR:  savepoint "q" does not exist
 COMMIT;
+WARNING:  there is no transaction in progress
 DROP TABLE remember_node_subid;
+ERROR:  relation "remember_node_subid" does not exist
 --
 -- Partitioned tables
 --
@@ -146,113 +177,235 @@
 CREATE TABLE partitioned (
 	a int
 ) INHERITS (some_table) PARTITION BY LIST (a);
-ERROR:  cannot create partitioned table as inheritance child
+ERROR:  at or near "(": syntax error: unimplemented: this syntax
+DETAIL:  source SQL:
+CREATE TABLE partitioned (
+	a int
+) INHERITS (some_table) PARTITION BY LIST (a)
+           ^
+HINT:  You have attempted to use a feature that is not yet implemented.
+See: https://go.crdb.dev/issue-v/22456/_version_
 -- cannot use more than 1 column as partition key for list partitioned table
 CREATE TABLE partitioned (
 	a1 int,
 	a2 int
 ) PARTITION BY LIST (a1, a2);	-- fail
-ERROR:  cannot use "list" partition strategy with more than one column
+ERROR:  at or near "EOF": syntax error
+DETAIL:  source SQL:
+CREATE TABLE partitioned (
+	a1 int,
+	a2 int
+) PARTITION BY LIST (a1, a2)
+                            ^
+HINT:  try \h CREATE TABLE
 -- unsupported constraint type for partitioned tables
 CREATE TABLE partitioned (
 	a int,
 	EXCLUDE USING gist (a WITH &&)
 ) PARTITION BY RANGE (a);
-ERROR:  exclusion constraints are not supported on partitioned tables
-LINE 3:  EXCLUDE USING gist (a WITH &&)
-         ^
+ERROR:  at or near "gist": syntax error: unimplemented: this syntax
+DETAIL:  source SQL:
+CREATE TABLE partitioned (
+	a int,
+	EXCLUDE USING gist (a WITH &&)
+               ^
+HINT:  You have attempted to use a feature that is not yet implemented.
+See: https://go.crdb.dev/issue-v/46657/_version_
 -- prevent using prohibited expressions in the key
 CREATE FUNCTION retset (a int) RETURNS SETOF int AS $$ SELECT 1; $$ LANGUAGE SQL IMMUTABLE;
 CREATE TABLE partitioned (
 	a int
 ) PARTITION BY RANGE (retset(a));
-ERROR:  set-returning functions are not allowed in partition key expressions
+ERROR:  at or near "(": syntax error
+DETAIL:  source SQL:
+CREATE TABLE partitioned (
+	a int
+) PARTITION BY RANGE (retset(a))
+                            ^
+HINT:  try \h CREATE TABLE
 DROP FUNCTION retset(int);
 CREATE TABLE partitioned (
 	a int
 ) PARTITION BY RANGE ((avg(a)));
-ERROR:  aggregate functions are not allowed in partition key expressions
+ERROR:  at or near "(": syntax error
+DETAIL:  source SQL:
+CREATE TABLE partitioned (
+	a int
+) PARTITION BY RANGE ((avg(a)))
+                      ^
+HINT:  try \h CREATE TABLE
 CREATE TABLE partitioned (
 	a int,
 	b int
 ) PARTITION BY RANGE ((avg(a) OVER (PARTITION BY b)));
-ERROR:  window functions are not allowed in partition key expressions
+ERROR:  at or near "(": syntax error
+DETAIL:  source SQL:
+CREATE TABLE partitioned (
+	a int,
+	b int
+) PARTITION BY RANGE ((avg(a) OVER (PARTITION BY b)))
+                      ^
+HINT:  try \h CREATE TABLE
 CREATE TABLE partitioned (
 	a int
 ) PARTITION BY LIST ((a LIKE (SELECT 1)));
-ERROR:  cannot use subquery in partition key expression
+ERROR:  at or near "(": syntax error
+DETAIL:  source SQL:
+CREATE TABLE partitioned (
+	a int
+) PARTITION BY LIST ((a LIKE (SELECT 1)))
+                     ^
+HINT:  try \h CREATE TABLE
 CREATE TABLE partitioned (
 	a int
 ) PARTITION BY RANGE ((42));
-ERROR:  cannot use constant expression as partition key
+ERROR:  at or near "(": syntax error
+DETAIL:  source SQL:
+CREATE TABLE partitioned (
+	a int
+) PARTITION BY RANGE ((42))
+                      ^
+HINT:  try \h CREATE TABLE
 CREATE FUNCTION const_func () RETURNS int AS $$ SELECT 1; $$ LANGUAGE SQL IMMUTABLE;
 CREATE TABLE partitioned (
 	a int
 ) PARTITION BY RANGE (const_func());
-ERROR:  cannot use constant expression as partition key
+ERROR:  at or near "(": syntax error
+DETAIL:  source SQL:
+CREATE TABLE partitioned (
+	a int
+) PARTITION BY RANGE (const_func())
+                                ^
+HINT:  try \h CREATE TABLE
 DROP FUNCTION const_func();
 -- only accept valid partitioning strategy
 CREATE TABLE partitioned (
     a int
 ) PARTITION BY MAGIC (a);
-ERROR:  unrecognized partitioning strategy "magic"
+ERROR:  at or near "magic": syntax error
+DETAIL:  source SQL:
+CREATE TABLE partitioned (
+    a int
+) PARTITION BY MAGIC (a)
+               ^
+HINT:  try \h CREATE TABLE
 -- specified column must be present in the table
 CREATE TABLE partitioned (
 	a int
 ) PARTITION BY RANGE (b);
-ERROR:  column "b" named in partition key does not exist
-LINE 3: ) PARTITION BY RANGE (b);
-                              ^
+ERROR:  at or near "EOF": syntax error
+DETAIL:  source SQL:
+CREATE TABLE partitioned (
+	a int
+) PARTITION BY RANGE (b)
+                        ^
+HINT:  try \h CREATE TABLE
 -- cannot use system columns in partition key
 CREATE TABLE partitioned (
 	a int
 ) PARTITION BY RANGE (xmin);
-ERROR:  cannot use system column "xmin" in partition key
-LINE 3: ) PARTITION BY RANGE (xmin);
-                              ^
+ERROR:  at or near "EOF": syntax error
+DETAIL:  source SQL:
+CREATE TABLE partitioned (
+	a int
+) PARTITION BY RANGE (xmin)
+                           ^
+HINT:  try \h CREATE TABLE
 -- cannot use pseudotypes
 CREATE TABLE partitioned (
 	a int,
 	b int
 ) PARTITION BY RANGE (((a, b)));
-ERROR:  partition key column 1 has pseudo-type record
+ERROR:  at or near "(": syntax error
+DETAIL:  source SQL:
+CREATE TABLE partitioned (
+	a int,
+	b int
+) PARTITION BY RANGE (((a, b)))
+                      ^
+HINT:  try \h CREATE TABLE
 CREATE TABLE partitioned (
 	a int,
 	b int
 ) PARTITION BY RANGE (a, ('unknown'));
-ERROR:  partition key column 2 has pseudo-type unknown
+ERROR:  at or near "(": syntax error
+DETAIL:  source SQL:
+CREATE TABLE partitioned (
+	a int,
+	b int
+) PARTITION BY RANGE (a, ('unknown'))
+                         ^
+HINT:  try \h CREATE TABLE
 -- functions in key must be immutable
 CREATE FUNCTION immut_func (a int) RETURNS int AS $$ SELECT a + random()::int; $$ LANGUAGE SQL;
 CREATE TABLE partitioned (
 	a int
 ) PARTITION BY RANGE (immut_func(a));
-ERROR:  functions in partition key expression must be marked IMMUTABLE
+ERROR:  at or near "(": syntax error
+DETAIL:  source SQL:
+CREATE TABLE partitioned (
+	a int
+) PARTITION BY RANGE (immut_func(a))
+                                ^
+HINT:  try \h CREATE TABLE
 DROP FUNCTION immut_func(int);
 -- prevent using columns of unsupported types in key (type must have a btree operator class)
 CREATE TABLE partitioned (
 	a point
 ) PARTITION BY LIST (a);
-ERROR:  data type point has no default operator class for access method "btree"
-HINT:  You must specify a btree operator class or define a default btree operator class for the data type.
+ERROR:  at or near ")": syntax error: unimplemented: this syntax
+DETAIL:  source SQL:
+CREATE TABLE partitioned (
+	a point
+) PARTITION BY LIST (a)
+^
+HINT:  You have attempted to use a feature that is not yet implemented.
+See: https://go.crdb.dev/issue-v/21286/_version_
 CREATE TABLE partitioned (
 	a point
 ) PARTITION BY LIST (a point_ops);
-ERROR:  operator class "point_ops" does not exist for access method "btree"
+ERROR:  at or near ")": syntax error: unimplemented: this syntax
+DETAIL:  source SQL:
+CREATE TABLE partitioned (
+	a point
+) PARTITION BY LIST (a point_ops)
+^
+HINT:  You have attempted to use a feature that is not yet implemented.
+See: https://go.crdb.dev/issue-v/21286/_version_
 CREATE TABLE partitioned (
 	a point
 ) PARTITION BY RANGE (a);
-ERROR:  data type point has no default operator class for access method "btree"
-HINT:  You must specify a btree operator class or define a default btree operator class for the data type.
+ERROR:  at or near ")": syntax error: unimplemented: this syntax
+DETAIL:  source SQL:
+CREATE TABLE partitioned (
+	a point
+) PARTITION BY RANGE (a)
+^
+HINT:  You have attempted to use a feature that is not yet implemented.
+See: https://go.crdb.dev/issue-v/21286/_version_
 CREATE TABLE partitioned (
 	a point
 ) PARTITION BY RANGE (a point_ops);
-ERROR:  operator class "point_ops" does not exist for access method "btree"
+ERROR:  at or near ")": syntax error: unimplemented: this syntax
+DETAIL:  source SQL:
+CREATE TABLE partitioned (
+	a point
+) PARTITION BY RANGE (a point_ops)
+^
+HINT:  You have attempted to use a feature that is not yet implemented.
+See: https://go.crdb.dev/issue-v/21286/_version_
 -- cannot add NO INHERIT constraints to partitioned tables
 CREATE TABLE partitioned (
 	a int,
 	CONSTRAINT check_a CHECK (a > 0) NO INHERIT
 ) PARTITION BY RANGE (a);
-ERROR:  cannot add NO INHERIT constraint to partitioned table "partitioned"
+ERROR:  at or near "no": syntax error
+DETAIL:  source SQL:
+CREATE TABLE partitioned (
+	a int,
+	CONSTRAINT check_a CHECK (a > 0) NO INHERIT
+                                  ^
+HINT:  try \h CREATE TABLE
 -- some checks after successful creation of a partitioned table
 CREATE FUNCTION plusone(a int) RETURNS INT AS $$ SELECT a+1; $$ LANGUAGE SQL;
 CREATE TABLE partitioned (
@@ -261,137 +414,239 @@
 	c text,
 	d text
 ) PARTITION BY RANGE (a oid_ops, plusone(b), c collate "default", d collate "C");
+ERROR:  at or near "oid_ops": syntax error
+DETAIL:  source SQL:
+CREATE TABLE partitioned (
+	a int,
+	b int,
+	c text,
+	d text
+) PARTITION BY RANGE (a oid_ops, plusone(b), c collate "default", d collate "C")
+                        ^
+HINT:  try \h CREATE TABLE
 -- check relkind
 SELECT relkind FROM pg_class WHERE relname = 'partitioned';
  relkind 
 ---------
- p
-(1 row)
+(0 rows)
 
 -- prevent a function referenced in partition key from being dropped
 DROP FUNCTION plusone(int);
-ERROR:  cannot drop function plusone(integer) because other objects depend on it
-DETAIL:  table partitioned depends on function plusone(integer)
-HINT:  Use DROP ... CASCADE to drop the dependent objects too.
 -- partitioned table cannot participate in regular inheritance
 CREATE TABLE partitioned2 (
 	a int,
 	b text
 ) PARTITION BY RANGE ((a+1), substr(b, 1, 5));
+ERROR:  at or near "(": syntax error
+DETAIL:  source SQL:
+CREATE TABLE partitioned2 (
+	a int,
+	b text
+) PARTITION BY RANGE ((a+1), substr(b, 1, 5))
+                      ^
+HINT:  try \h CREATE TABLE
 CREATE TABLE fail () INHERITS (partitioned2);
-ERROR:  cannot inherit from partitioned table "partitioned2"
+ERROR:  at or near "(": syntax error: unimplemented: this syntax
+DETAIL:  source SQL:
+CREATE TABLE fail () INHERITS (partitioned2)
+                              ^
+HINT:  You have attempted to use a feature that is not yet implemented.
+See: https://go.crdb.dev/issue-v/22456/_version_
 -- Partition key in describe output
 \d partitioned
-      Partitioned table "public.partitioned"
- Column |  Type   | Collation | Nullable | Default 
---------+---------+-----------+----------+---------
- a      | integer |           |          | 
- b      | integer |           |          | 
- c      | text    |           |          | 
- d      | text    |           |          | 
-Partition key: RANGE (a oid_ops, plusone(b), c, d COLLATE "C")
-Number of partitions: 0
-
+ERROR:  at or near ".": syntax error
+DETAIL:  source SQL:
+SELECT c.oid,
+  n.nspname,
+  c.relname
+FROM pg_catalog.pg_class c
+     LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace
+WHERE c.relname OPERATOR(pg_catalog.~) '^(partitioned)$' COLLATE pg_catalog.default
+                                                                           ^
 \d+ partitioned2
-                          Partitioned table "public.partitioned2"
- Column |  Type   | Collation | Nullable | Default | Storage  | Stats target | Description 
---------+---------+-----------+----------+---------+----------+--------------+-------------
- a      | integer |           |          |         | plain    |              | 
- b      | text    |           |          |         | extended |              | 
-Partition key: RANGE (((a + 1)), substr(b, 1, 5))
-Number of partitions: 0
-
+ERROR:  at or near ".": syntax error
+DETAIL:  source SQL:
+SELECT c.oid,
+  n.nspname,
+  c.relname
+FROM pg_catalog.pg_class c
+     LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace
+WHERE c.relname OPERATOR(pg_catalog.~) '^(partitioned2)$' COLLATE pg_catalog.default
+                                                                            ^
 INSERT INTO partitioned2 VALUES (1, 'hello');
-ERROR:  no partition of relation "partitioned2" found for row
-DETAIL:  Partition key of the failing row contains ((a + 1), substr(b, 1, 5)) = (2, hello).
+ERROR:  relation "partitioned2" does not exist
 CREATE TABLE part2_1 PARTITION OF partitioned2 FOR VALUES FROM (-1, 'aaaaa') TO (100, 'ccccc');
+ERROR:  at or near "partition": syntax error
+DETAIL:  source SQL:
+CREATE TABLE part2_1 PARTITION OF partitioned2 FOR VALUES FROM (-1, 'aaaaa') TO (100, 'ccccc')
+                     ^
+HINT:  try \h CREATE TABLE
 \d+ part2_1
-                                  Table "public.part2_1"
- Column |  Type   | Collation | Nullable | Default | Storage  | Stats target | Description 
---------+---------+-----------+----------+---------+----------+--------------+-------------
- a      | integer |           |          |         | plain    |              | 
- b      | text    |           |          |         | extended |              | 
-Partition of: partitioned2 FOR VALUES FROM ('-1', 'aaaaa') TO (100, 'ccccc')
-Partition constraint: (((a + 1) IS NOT NULL) AND (substr(b, 1, 5) IS NOT NULL) AND (((a + 1) > '-1'::integer) OR (((a + 1) = '-1'::integer) AND (substr(b, 1, 5) >= 'aaaaa'::text))) AND (((a + 1) < 100) OR (((a + 1) = 100) AND (substr(b, 1, 5) < 'ccccc'::text))))
-
+ERROR:  at or near ".": syntax error
+DETAIL:  source SQL:
+SELECT c.oid,
+  n.nspname,
+  c.relname
+FROM pg_catalog.pg_class c
+     LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace
+WHERE c.relname OPERATOR(pg_catalog.~) '^(part2_1)$' COLLATE pg_catalog.default
+                                                                       ^
 DROP TABLE partitioned, partitioned2;
+ERROR:  relation "partitioned" does not exist
 -- check reference to partitioned table's rowtype in partition descriptor
 create table partitioned (a int, b int)
   partition by list ((row(a, b)::partitioned));
+ERROR:  at or near "(": syntax error
+DETAIL:  source SQL:
+create table partitioned (a int, b int)
+  partition by list ((row(a, b)::partitioned))
+                     ^
+HINT:  try \h CREATE TABLE
 create table partitioned1
   partition of partitioned for values in ('(1,2)'::partitioned);
+ERROR:  at or near "partition": syntax error
+DETAIL:  source SQL:
+create table partitioned1
+  partition of partitioned for values in ('(1,2)'::partitioned)
+  ^
+HINT:  try \h CREATE TABLE
 create table partitioned2
   partition of partitioned for values in ('(2,4)'::partitioned);
+ERROR:  at or near "partition": syntax error
+DETAIL:  source SQL:
+create table partitioned2
+  partition of partitioned for values in ('(2,4)'::partitioned)
+  ^
+HINT:  try \h CREATE TABLE
 explain (costs off)
 select * from partitioned where row(a,b)::partitioned = '(1,2)'::partitioned;
-                        QUERY PLAN                         
------------------------------------------------------------
- Seq Scan on partitioned1 partitioned
-   Filter: (ROW(a, b)::partitioned = '(1,2)'::partitioned)
-(2 rows)
-
+ERROR:  at or near "off": syntax error
+DETAIL:  source SQL:
+explain (costs off)
+               ^
+HINT:  try \h <SELECTCLAUSE>
 drop table partitioned;
+ERROR:  relation "partitioned" does not exist
 -- whole-row Var in partition key works too
 create table partitioned (a int, b int)
   partition by list ((partitioned));
+ERROR:  at or near "(": syntax error
+DETAIL:  source SQL:
+create table partitioned (a int, b int)
+  partition by list ((partitioned))
+                     ^
+HINT:  try \h CREATE TABLE
 create table partitioned1
   partition of partitioned for values in ('(1,2)');
+ERROR:  at or near "partition": syntax error
+DETAIL:  source SQL:
+create table partitioned1
+  partition of partitioned for values in ('(1,2)')
+  ^
+HINT:  try \h CREATE TABLE
 create table partitioned2
   partition of partitioned for values in ('(2,4)');
+ERROR:  at or near "partition": syntax error
+DETAIL:  source SQL:
+create table partitioned2
+  partition of partitioned for values in ('(2,4)')
+  ^
+HINT:  try \h CREATE TABLE
 explain (costs off)
 select * from partitioned where partitioned = '(1,2)'::partitioned;
-                           QUERY PLAN                            
------------------------------------------------------------------
- Seq Scan on partitioned1 partitioned
-   Filter: ((partitioned.*)::partitioned = '(1,2)'::partitioned)
-(2 rows)
-
+ERROR:  at or near "off": syntax error
+DETAIL:  source SQL:
+explain (costs off)
+               ^
+HINT:  try \h <SELECTCLAUSE>
 \d+ partitioned1
-                               Table "public.partitioned1"
- Column |  Type   | Collation | Nullable | Default | Storage | Stats target | Description 
---------+---------+-----------+----------+---------+---------+--------------+-------------
- a      | integer |           |          |         | plain   |              | 
- b      | integer |           |          |         | plain   |              | 
-Partition of: partitioned FOR VALUES IN ('(1,2)')
-Partition constraint: (((partitioned1.*)::partitioned IS DISTINCT FROM NULL) AND ((partitioned1.*)::partitioned = '(1,2)'::partitioned))
-
+ERROR:  at or near ".": syntax error
+DETAIL:  source SQL:
+SELECT c.oid,
+  n.nspname,
+  c.relname
+FROM pg_catalog.pg_class c
+     LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace
+WHERE c.relname OPERATOR(pg_catalog.~) '^(partitioned1)$' COLLATE pg_catalog.default
+                                                                            ^
 drop table partitioned;
+ERROR:  relation "partitioned" does not exist
 -- check that dependencies of partition columns are handled correctly
 create domain intdom1 as int;
+ERROR:  at or near "as": syntax error: unimplemented: this syntax
+DETAIL:  source SQL:
+create domain intdom1 as int
+                      ^
+HINT:  You have attempted to use a feature that is not yet implemented.
+See: https://go.crdb.dev/issue-v/27796/_version_
 create table partitioned (
 	a intdom1,
 	b text
 ) partition by range (a);
+ERROR:  at or near "EOF": syntax error
+DETAIL:  source SQL:
+create table partitioned (
+	a intdom1,
+	b text
+) partition by range (a)
+                        ^
+HINT:  try \h CREATE TABLE
 alter table partitioned drop column a;  -- fail
-ERROR:  cannot drop column "a" because it is part of the partition key of relation "partitioned"
+ERROR:  relation "partitioned" does not exist
 drop domain intdom1;  -- fail, requires cascade
-ERROR:  cannot drop type intdom1 because other objects depend on it
-DETAIL:  table partitioned depends on type intdom1
-HINT:  Use DROP ... CASCADE to drop the dependent objects too.
+ERROR:  at or near "intdom1": syntax error: unimplemented: this syntax
+DETAIL:  source SQL:
+drop domain intdom1
+            ^
+HINT:  You have attempted to use a feature that is not yet implemented.
+See: https://go.crdb.dev/issue-v/27796/_version_
 drop domain intdom1 cascade;
-NOTICE:  drop cascades to table partitioned
+ERROR:  at or near "intdom1": syntax error: unimplemented: this syntax
+DETAIL:  source SQL:
+drop domain intdom1 cascade
+            ^
+HINT:  You have attempted to use a feature that is not yet implemented.
+See: https://go.crdb.dev/issue-v/27796/_version_
 table partitioned;  -- gone
 ERROR:  relation "partitioned" does not exist
-LINE 1: table partitioned;
-              ^
 -- likewise for columns used in partition expressions
 create domain intdom1 as int;
+ERROR:  at or near "as": syntax error: unimplemented: this syntax
+DETAIL:  source SQL:
+create domain intdom1 as int
+                      ^
+HINT:  You have attempted to use a feature that is not yet implemented.
+See: https://go.crdb.dev/issue-v/27796/_version_
 create table partitioned (
 	a intdom1,
 	b text
 ) partition by range (plusone(a));
+ERROR:  at or near "(": syntax error
+DETAIL:  source SQL:
+create table partitioned (
+	a intdom1,
+	b text
+) partition by range (plusone(a))
+                             ^
+HINT:  try \h CREATE TABLE
 alter table partitioned drop column a;  -- fail
-ERROR:  cannot drop column "a" because it is part of the partition key of relation "partitioned"
+ERROR:  relation "partitioned" does not exist
 drop domain intdom1;  -- fail, requires cascade
-ERROR:  cannot drop type intdom1 because other objects depend on it
-DETAIL:  table partitioned depends on type intdom1
-HINT:  Use DROP ... CASCADE to drop the dependent objects too.
+ERROR:  at or near "intdom1": syntax error: unimplemented: this syntax
+DETAIL:  source SQL:
+drop domain intdom1
+            ^
+HINT:  You have attempted to use a feature that is not yet implemented.
+See: https://go.crdb.dev/issue-v/27796/_version_
 drop domain intdom1 cascade;
-NOTICE:  drop cascades to table partitioned
+ERROR:  at or near "intdom1": syntax error: unimplemented: this syntax
+DETAIL:  source SQL:
+drop domain intdom1 cascade
+            ^
+HINT:  You have attempted to use a feature that is not yet implemented.
+See: https://go.crdb.dev/issue-v/27796/_version_
 table partitioned;  -- gone
 ERROR:  relation "partitioned" does not exist
-LINE 1: table partitioned;
-              ^
 --
 -- Partitions
 --
@@ -399,357 +654,739 @@
 CREATE TABLE list_parted (
 	a int
 ) PARTITION BY LIST (a);
+ERROR:  at or near "EOF": syntax error
+DETAIL:  source SQL:
+CREATE TABLE list_parted (
+	a int
+) PARTITION BY LIST (a)
+                       ^
+HINT:  try \h CREATE TABLE
 CREATE TABLE part_p1 PARTITION OF list_parted FOR VALUES IN ('1');
+ERROR:  at or near "partition": syntax error
+DETAIL:  source SQL:
+CREATE TABLE part_p1 PARTITION OF list_parted FOR VALUES IN ('1')
+                     ^
+HINT:  try \h CREATE TABLE
 CREATE TABLE part_p2 PARTITION OF list_parted FOR VALUES IN (2);
+ERROR:  at or near "partition": syntax error
+DETAIL:  source SQL:
+CREATE TABLE part_p2 PARTITION OF list_parted FOR VALUES IN (2)
+                     ^
+HINT:  try \h CREATE TABLE
 CREATE TABLE part_p3 PARTITION OF list_parted FOR VALUES IN ((2+1));
+ERROR:  at or near "partition": syntax error
+DETAIL:  source SQL:
+CREATE TABLE part_p3 PARTITION OF list_parted FOR VALUES IN ((2+1))
+                     ^
+HINT:  try \h CREATE TABLE
 CREATE TABLE part_null PARTITION OF list_parted FOR VALUES IN (null);
+ERROR:  at or near "partition": syntax error
+DETAIL:  source SQL:
+CREATE TABLE part_null PARTITION OF list_parted FOR VALUES IN (null)
+                       ^
+HINT:  try \h CREATE TABLE
 \d+ list_parted
-                          Partitioned table "public.list_parted"
- Column |  Type   | Collation | Nullable | Default | Storage | Stats target | Description 
---------+---------+-----------+----------+---------+---------+--------------+-------------
- a      | integer |           |          |         | plain   |              | 
-Partition key: LIST (a)
-Partitions: part_null FOR VALUES IN (NULL),
-            part_p1 FOR VALUES IN (1),
-            part_p2 FOR VALUES IN (2),
-            part_p3 FOR VALUES IN (3)
-
+ERROR:  at or near ".": syntax error
+DETAIL:  source SQL:
+SELECT c.oid,
+  n.nspname,
+  c.relname
+FROM pg_catalog.pg_class c
+     LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace
+WHERE c.relname OPERATOR(pg_catalog.~) '^(list_parted)$' COLLATE pg_catalog.default
+                                                                           ^
 -- forbidden expressions for partition bound with list partitioned table
 CREATE TABLE part_bogus_expr_fail PARTITION OF list_parted FOR VALUES IN (somename);
-ERROR:  cannot use column reference in partition bound expression
-LINE 1: ...expr_fail PARTITION OF list_parted FOR VALUES IN (somename);
-                                                             ^
+ERROR:  at or near "partition": syntax error
+DETAIL:  source SQL:
+CREATE TABLE part_bogus_expr_fail PARTITION OF list_parted FOR VALUES IN (somename)
+                                  ^
+HINT:  try \h CREATE TABLE
 CREATE TABLE part_bogus_expr_fail PARTITION OF list_parted FOR VALUES IN (somename.somename);
-ERROR:  cannot use column reference in partition bound expression
-LINE 1: ...expr_fail PARTITION OF list_parted FOR VALUES IN (somename.s...
-                                                             ^
+ERROR:  at or near "partition": syntax error
+DETAIL:  source SQL:
+CREATE TABLE part_bogus_expr_fail PARTITION OF list_parted FOR VALUES IN (somename.somename)
+                                  ^
+HINT:  try \h CREATE TABLE
 CREATE TABLE part_bogus_expr_fail PARTITION OF list_parted FOR VALUES IN (a);
-ERROR:  cannot use column reference in partition bound expression
-LINE 1: ..._bogus_expr_fail PARTITION OF list_parted FOR VALUES IN (a);
-                                                                    ^
+ERROR:  at or near "partition": syntax error
+DETAIL:  source SQL:
+CREATE TABLE part_bogus_expr_fail PARTITION OF list_parted FOR VALUES IN (a)
+                                  ^
+HINT:  try \h CREATE TABLE
 CREATE TABLE part_bogus_expr_fail PARTITION OF list_parted FOR VALUES IN (sum(a));
-ERROR:  cannot use column reference in partition bound expression
-LINE 1: ...s_expr_fail PARTITION OF list_parted FOR VALUES IN (sum(a));
-                                                                   ^
+ERROR:  at or near "partition": syntax error
+DETAIL:  source SQL:
+CREATE TABLE part_bogus_expr_fail PARTITION OF list_parted FOR VALUES IN (sum(a))
+                                  ^
+HINT:  try \h CREATE TABLE
 CREATE TABLE part_bogus_expr_fail PARTITION OF list_parted FOR VALUES IN (sum(somename));
-ERROR:  cannot use column reference in partition bound expression
-LINE 1: ..._fail PARTITION OF list_parted FOR VALUES IN (sum(somename))...
-                                                             ^
+ERROR:  at or near "partition": syntax error
+DETAIL:  source SQL:
+CREATE TABLE part_bogus_expr_fail PARTITION OF list_parted FOR VALUES IN (sum(somename))
+                                  ^
+HINT:  try \h CREATE TABLE
 CREATE TABLE part_bogus_expr_fail PARTITION OF list_parted FOR VALUES IN (sum(1));
-ERROR:  aggregate functions are not allowed in partition bound
-LINE 1: ...s_expr_fail PARTITION OF list_parted FOR VALUES IN (sum(1));
-                                                               ^
+ERROR:  at or near "partition": syntax error
+DETAIL:  source SQL:
+CREATE TABLE part_bogus_expr_fail PARTITION OF list_parted FOR VALUES IN (sum(1))
+                                  ^
+HINT:  try \h CREATE TABLE
 CREATE TABLE part_bogus_expr_fail PARTITION OF list_parted FOR VALUES IN ((select 1));
-ERROR:  cannot use subquery in partition bound
-LINE 1: ...expr_fail PARTITION OF list_parted FOR VALUES IN ((select 1)...
-                                                             ^
+ERROR:  at or near "partition": syntax error
+DETAIL:  source SQL:
+CREATE TABLE part_bogus_expr_fail PARTITION OF list_parted FOR VALUES IN ((select 1))
+                                  ^
+HINT:  try \h CREATE TABLE
 CREATE TABLE part_bogus_expr_fail PARTITION OF list_parted FOR VALUES IN (generate_series(4, 6));
-ERROR:  set-returning functions are not allowed in partition bound
-LINE 1: ...expr_fail PARTITION OF list_parted FOR VALUES IN (generate_s...
-                                                             ^
+ERROR:  at or near "partition": syntax error
+DETAIL:  source SQL:
+CREATE TABLE part_bogus_expr_fail PARTITION OF list_parted FOR VALUES IN (generate_series(4, 6))
+                                  ^
+HINT:  try \h CREATE TABLE
 CREATE TABLE part_bogus_expr_fail PARTITION OF list_parted FOR VALUES IN ((1+1) collate "POSIX");
-ERROR:  collations are not supported by type integer
-LINE 1: ...ail PARTITION OF list_parted FOR VALUES IN ((1+1) collate "P...
-                                                             ^
+ERROR:  at or near "partition": syntax error
+DETAIL:  source SQL:
+CREATE TABLE part_bogus_expr_fail PARTITION OF list_parted FOR VALUES IN ((1+1) collate "POSIX")
+                                  ^
+HINT:  try \h CREATE TABLE
 -- syntax does not allow empty list of values for list partitions
 CREATE TABLE fail_part PARTITION OF list_parted FOR VALUES IN ();
-ERROR:  syntax error at or near ")"
-LINE 1: ...E TABLE fail_part PARTITION OF list_parted FOR VALUES IN ();
-                                                                     ^
+ERROR:  at or near "partition": syntax error
+DETAIL:  source SQL:
+CREATE TABLE fail_part PARTITION OF list_parted FOR VALUES IN ()
+                       ^
+HINT:  try \h CREATE TABLE
 -- trying to specify range for list partitioned table
 CREATE TABLE fail_part PARTITION OF list_parted FOR VALUES FROM (1) TO (2);
-ERROR:  invalid bound specification for a list partition
-LINE 1: ...BLE fail_part PARTITION OF list_parted FOR VALUES FROM (1) T...
-                                                             ^
+ERROR:  at or near "partition": syntax error
+DETAIL:  source SQL:
+CREATE TABLE fail_part PARTITION OF list_parted FOR VALUES FROM (1) TO (2)
+                       ^
+HINT:  try \h CREATE TABLE
 -- trying to specify modulus and remainder for list partitioned table
 CREATE TABLE fail_part PARTITION OF list_parted FOR VALUES WITH (MODULUS 10, REMAINDER 1);
-ERROR:  invalid bound specification for a list partition
-LINE 1: ...BLE fail_part PARTITION OF list_parted FOR VALUES WITH (MODU...
-                                                             ^
+ERROR:  at or near "partition": syntax error
+DETAIL:  source SQL:
+CREATE TABLE fail_part PARTITION OF list_parted FOR VALUES WITH (MODULUS 10, REMAINDER 1)
+                       ^
+HINT:  try \h CREATE TABLE
 -- check default partition cannot be created more than once
 CREATE TABLE part_default PARTITION OF list_parted DEFAULT;
+ERROR:  at or near "partition": syntax error
+DETAIL:  source SQL:
+CREATE TABLE part_default PARTITION OF list_parted DEFAULT
+                          ^
+HINT:  try \h CREATE TABLE
 CREATE TABLE fail_default_part PARTITION OF list_parted DEFAULT;
-ERROR:  partition "fail_default_part" conflicts with existing default partition "part_default"
-LINE 1: ...TE TABLE fail_default_part PARTITION OF list_parted DEFAULT;
-                                                               ^
+ERROR:  at or near "partition": syntax error
+DETAIL:  source SQL:
+CREATE TABLE fail_default_part PARTITION OF list_parted DEFAULT
+                               ^
+HINT:  try \h CREATE TABLE
 -- specified literal can't be cast to the partition column data type
 CREATE TABLE bools (
 	a bool
 ) PARTITION BY LIST (a);
+ERROR:  at or near "EOF": syntax error
+DETAIL:  source SQL:
+CREATE TABLE bools (
+	a bool
+) PARTITION BY LIST (a)
+                       ^
+HINT:  try \h CREATE TABLE
 CREATE TABLE bools_true PARTITION OF bools FOR VALUES IN (1);
-ERROR:  specified value cannot be cast to type boolean for column "a"
-LINE 1: ...REATE TABLE bools_true PARTITION OF bools FOR VALUES IN (1);
-                                                                    ^
+ERROR:  at or near "partition": syntax error
+DETAIL:  source SQL:
+CREATE TABLE bools_true PARTITION OF bools FOR VALUES IN (1)
+                        ^
+HINT:  try \h CREATE TABLE
 DROP TABLE bools;
+ERROR:  relation "bools" does not exist
 -- specified literal can be cast, and the cast might not be immutable
 CREATE TABLE moneyp (
 	a money
 ) PARTITION BY LIST (a);
+ERROR:  at or near ")": syntax error: unimplemented: this syntax
+DETAIL:  source SQL:
+CREATE TABLE moneyp (
+	a money
+) PARTITION BY LIST (a)
+^
+HINT:  You have attempted to use a feature that is not yet implemented.
+See: https://go.crdb.dev/issue-v/41578/_version_
 CREATE TABLE moneyp_10 PARTITION OF moneyp FOR VALUES IN (10);
+ERROR:  at or near "partition": syntax error
+DETAIL:  source SQL:
+CREATE TABLE moneyp_10 PARTITION OF moneyp FOR VALUES IN (10)
+                       ^
+HINT:  try \h CREATE TABLE
 CREATE TABLE moneyp_11 PARTITION OF moneyp FOR VALUES IN ('11');
+ERROR:  at or near "partition": syntax error
+DETAIL:  source SQL:
+CREATE TABLE moneyp_11 PARTITION OF moneyp FOR VALUES IN ('11')
+                       ^
+HINT:  try \h CREATE TABLE
 CREATE TABLE moneyp_12 PARTITION OF moneyp FOR VALUES IN (to_char(12, '99')::int);
+ERROR:  at or near "partition": syntax error
+DETAIL:  source SQL:
+CREATE TABLE moneyp_12 PARTITION OF moneyp FOR VALUES IN (to_char(12, '99')::int)
+                       ^
+HINT:  try \h CREATE TABLE
 DROP TABLE moneyp;
+ERROR:  relation "moneyp" does not exist
 -- cast is immutable
 CREATE TABLE bigintp (
 	a bigint
 ) PARTITION BY LIST (a);
+ERROR:  at or near "EOF": syntax error
+DETAIL:  source SQL:
+CREATE TABLE bigintp (
+	a bigint
+) PARTITION BY LIST (a)
+                       ^
+HINT:  try \h CREATE TABLE
 CREATE TABLE bigintp_10 PARTITION OF bigintp FOR VALUES IN (10);
+ERROR:  at or near "partition": syntax error
+DETAIL:  source SQL:
+CREATE TABLE bigintp_10 PARTITION OF bigintp FOR VALUES IN (10)
+                        ^
+HINT:  try \h CREATE TABLE
 -- fails due to overlap:
 CREATE TABLE bigintp_10_2 PARTITION OF bigintp FOR VALUES IN ('10');
-ERROR:  partition "bigintp_10_2" would overlap partition "bigintp_10"
-LINE 1: ...ABLE bigintp_10_2 PARTITION OF bigintp FOR VALUES IN ('10');
-                                                                 ^
+ERROR:  at or near "partition": syntax error
+DETAIL:  source SQL:
+CREATE TABLE bigintp_10_2 PARTITION OF bigintp FOR VALUES IN ('10')
+                          ^
+HINT:  try \h CREATE TABLE
 DROP TABLE bigintp;
+ERROR:  relation "bigintp" does not exist
 CREATE TABLE range_parted (
 	a date
 ) PARTITION BY RANGE (a);
+ERROR:  at or near "EOF": syntax error
+DETAIL:  source SQL:
+CREATE TABLE range_parted (
+	a date
+) PARTITION BY RANGE (a)
+                        ^
+HINT:  try \h CREATE TABLE
 -- forbidden expressions for partition bounds with range partitioned table
 CREATE TABLE part_bogus_expr_fail PARTITION OF range_parted
   FOR VALUES FROM (somename) TO ('2019-01-01');
-ERROR:  cannot use column reference in partition bound expression
-LINE 2:   FOR VALUES FROM (somename) TO ('2019-01-01');
-                           ^
+ERROR:  at or near "partition": syntax error
+DETAIL:  source SQL:
+CREATE TABLE part_bogus_expr_fail PARTITION OF range_parted
+                                  ^
+HINT:  try \h CREATE TABLE
 CREATE TABLE part_bogus_expr_fail PARTITION OF range_parted
   FOR VALUES FROM (somename.somename) TO ('2019-01-01');
-ERROR:  cannot use column reference in partition bound expression
-LINE 2:   FOR VALUES FROM (somename.somename) TO ('2019-01-01');
-                           ^
+ERROR:  at or near "partition": syntax error
+DETAIL:  source SQL:
+CREATE TABLE part_bogus_expr_fail PARTITION OF range_parted
+                                  ^
+HINT:  try \h CREATE TABLE
 CREATE TABLE part_bogus_expr_fail PARTITION OF range_parted
   FOR VALUES FROM (a) TO ('2019-01-01');
-ERROR:  cannot use column reference in partition bound expression
-LINE 2:   FOR VALUES FROM (a) TO ('2019-01-01');
-                           ^
+ERROR:  at or near "partition": syntax error
+DETAIL:  source SQL:
+CREATE TABLE part_bogus_expr_fail PARTITION OF range_parted
+                                  ^
+HINT:  try \h CREATE TABLE
 CREATE TABLE part_bogus_expr_fail PARTITION OF range_parted
   FOR VALUES FROM (max(a)) TO ('2019-01-01');
-ERROR:  cannot use column reference in partition bound expression
-LINE 2:   FOR VALUES FROM (max(a)) TO ('2019-01-01');
-                               ^
+ERROR:  at or near "partition": syntax error
+DETAIL:  source SQL:
+CREATE TABLE part_bogus_expr_fail PARTITION OF range_parted
+                                  ^
+HINT:  try \h CREATE TABLE
 CREATE TABLE part_bogus_expr_fail PARTITION OF range_parted
   FOR VALUES FROM (max(somename)) TO ('2019-01-01');
-ERROR:  cannot use column reference in partition bound expression
-LINE 2:   FOR VALUES FROM (max(somename)) TO ('2019-01-01');
-                               ^
+ERROR:  at or near "partition": syntax error
+DETAIL:  source SQL:
+CREATE TABLE part_bogus_expr_fail PARTITION OF range_parted
+                                  ^
+HINT:  try \h CREATE TABLE
 CREATE TABLE part_bogus_expr_fail PARTITION OF range_parted
   FOR VALUES FROM (max('2019-02-01'::date)) TO ('2019-01-01');
-ERROR:  aggregate functions are not allowed in partition bound
-LINE 2:   FOR VALUES FROM (max('2019-02-01'::date)) TO ('2019-01-01'...
-                           ^
+ERROR:  at or near "partition": syntax error
+DETAIL:  source SQL:
+CREATE TABLE part_bogus_expr_fail PARTITION OF range_parted
+                                  ^
+HINT:  try \h CREATE TABLE
 CREATE TABLE part_bogus_expr_fail PARTITION OF range_parted
   FOR VALUES FROM ((select 1)) TO ('2019-01-01');
-ERROR:  cannot use subquery in partition bound
-LINE 2:   FOR VALUES FROM ((select 1)) TO ('2019-01-01');
-                           ^
+ERROR:  at or near "partition": syntax error
+DETAIL:  source SQL:
+CREATE TABLE part_bogus_expr_fail PARTITION OF range_parted
+                                  ^
+HINT:  try \h CREATE TABLE
 CREATE TABLE part_bogus_expr_fail PARTITION OF range_parted
   FOR VALUES FROM (generate_series(1, 3)) TO ('2019-01-01');
-ERROR:  set-returning functions are not allowed in partition bound
-LINE 2:   FOR VALUES FROM (generate_series(1, 3)) TO ('2019-01-01');
-                           ^
+ERROR:  at or near "partition": syntax error
+DETAIL:  source SQL:
+CREATE TABLE part_bogus_expr_fail PARTITION OF range_parted
+                                  ^
+HINT:  try \h CREATE TABLE
 -- trying to specify list for range partitioned table
 CREATE TABLE fail_part PARTITION OF range_parted FOR VALUES IN ('a');
-ERROR:  invalid bound specification for a range partition
-LINE 1: ...BLE fail_part PARTITION OF range_parted FOR VALUES IN ('a');
-                                                              ^
+ERROR:  at or near "partition": syntax error
+DETAIL:  source SQL:
+CREATE TABLE fail_part PARTITION OF range_parted FOR VALUES IN ('a')
+                       ^
+HINT:  try \h CREATE TABLE
 -- trying to specify modulus and remainder for range partitioned table
 CREATE TABLE fail_part PARTITION OF range_parted FOR VALUES WITH (MODULUS 10, REMAINDER 1);
-ERROR:  invalid bound specification for a range partition
-LINE 1: ...LE fail_part PARTITION OF range_parted FOR VALUES WITH (MODU...
-                                                             ^
+ERROR:  at or near "partition": syntax error
+DETAIL:  source SQL:
+CREATE TABLE fail_part PARTITION OF range_parted FOR VALUES WITH (MODULUS 10, REMAINDER 1)
+                       ^
+HINT:  try \h CREATE TABLE
 -- each of start and end bounds must have same number of values as the
 -- length of the partition key
 CREATE TABLE fail_part PARTITION OF range_parted FOR VALUES FROM ('a', 1) TO ('z');
-ERROR:  FROM must specify exactly one value per partitioning column
+ERROR:  at or near "partition": syntax error
+DETAIL:  source SQL:
+CREATE TABLE fail_part PARTITION OF range_parted FOR VALUES FROM ('a', 1) TO ('z')
+                       ^
+HINT:  try \h CREATE TABLE
 CREATE TABLE fail_part PARTITION OF range_parted FOR VALUES FROM ('a') TO ('z', 1);
-ERROR:  TO must specify exactly one value per partitioning column
+ERROR:  at or near "partition": syntax error
+DETAIL:  source SQL:
+CREATE TABLE fail_part PARTITION OF range_parted FOR VALUES FROM ('a') TO ('z', 1)
+                       ^
+HINT:  try \h CREATE TABLE
 -- cannot specify null values in range bounds
 CREATE TABLE fail_part PARTITION OF range_parted FOR VALUES FROM (null) TO (maxvalue);
-ERROR:  cannot specify NULL in range bound
+ERROR:  at or near "partition": syntax error
+DETAIL:  source SQL:
+CREATE TABLE fail_part PARTITION OF range_parted FOR VALUES FROM (null) TO (maxvalue)
+                       ^
+HINT:  try \h CREATE TABLE
 -- trying to specify modulus and remainder for range partitioned table
 CREATE TABLE fail_part PARTITION OF range_parted FOR VALUES WITH (MODULUS 10, REMAINDER 1);
-ERROR:  invalid bound specification for a range partition
-LINE 1: ...LE fail_part PARTITION OF range_parted FOR VALUES WITH (MODU...
-                                                             ^
+ERROR:  at or near "partition": syntax error
+DETAIL:  source SQL:
+CREATE TABLE fail_part PARTITION OF range_parted FOR VALUES WITH (MODULUS 10, REMAINDER 1)
+                       ^
+HINT:  try \h CREATE TABLE
 -- check partition bound syntax for the hash partition
 CREATE TABLE hash_parted (
 	a int
 ) PARTITION BY HASH (a);
+ERROR:  at or near "hash": syntax error
+DETAIL:  source SQL:
+CREATE TABLE hash_parted (
+	a int
+) PARTITION BY HASH (a)
+               ^
+HINT:  try \h CREATE TABLE
 CREATE TABLE hpart_1 PARTITION OF hash_parted FOR VALUES WITH (MODULUS 10, REMAINDER 0);
+ERROR:  at or near "partition": syntax error
+DETAIL:  source SQL:
+CREATE TABLE hpart_1 PARTITION OF hash_parted FOR VALUES WITH (MODULUS 10, REMAINDER 0)
+                     ^
+HINT:  try \h CREATE TABLE
 CREATE TABLE hpart_2 PARTITION OF hash_parted FOR VALUES WITH (MODULUS 50, REMAINDER 1);
+ERROR:  at or near "partition": syntax error
+DETAIL:  source SQL:
+CREATE TABLE hpart_2 PARTITION OF hash_parted FOR VALUES WITH (MODULUS 50, REMAINDER 1)
+                     ^
+HINT:  try \h CREATE TABLE
 CREATE TABLE hpart_3 PARTITION OF hash_parted FOR VALUES WITH (MODULUS 200, REMAINDER 2);
+ERROR:  at or near "partition": syntax error
+DETAIL:  source SQL:
+CREATE TABLE hpart_3 PARTITION OF hash_parted FOR VALUES WITH (MODULUS 200, REMAINDER 2)
+                     ^
+HINT:  try \h CREATE TABLE
 CREATE TABLE hpart_4 PARTITION OF hash_parted FOR VALUES WITH (MODULUS 10, REMAINDER 3);
+ERROR:  at or near "partition": syntax error
+DETAIL:  source SQL:
+CREATE TABLE hpart_4 PARTITION OF hash_parted FOR VALUES WITH (MODULUS 10, REMAINDER 3)
+                     ^
+HINT:  try \h CREATE TABLE
 -- modulus 25 is factor of modulus of 50 but 10 is not a factor of 25.
 CREATE TABLE fail_part PARTITION OF hash_parted FOR VALUES WITH (MODULUS 25, REMAINDER 3);
-ERROR:  every hash partition modulus must be a factor of the next larger modulus
-DETAIL:  The new modulus 25 is not divisible by 10, the modulus of existing partition "hpart_4".
+ERROR:  at or near "partition": syntax error
+DETAIL:  source SQL:
+CREATE TABLE fail_part PARTITION OF hash_parted FOR VALUES WITH (MODULUS 25, REMAINDER 3)
+                       ^
+HINT:  try \h CREATE TABLE
 -- previous modulus 50 is factor of 150 but this modulus is not a factor of next modulus 200.
 CREATE TABLE fail_part PARTITION OF hash_parted FOR VALUES WITH (MODULUS 150, REMAINDER 3);
-ERROR:  every hash partition modulus must be a factor of the next larger modulus
-DETAIL:  The new modulus 150 is not a factor of 200, the modulus of existing partition "hpart_3".
+ERROR:  at or near "partition": syntax error
+DETAIL:  source SQL:
+CREATE TABLE fail_part PARTITION OF hash_parted FOR VALUES WITH (MODULUS 150, REMAINDER 3)
+                       ^
+HINT:  try \h CREATE TABLE
 -- overlapping remainders
 CREATE TABLE fail_part PARTITION OF hash_parted FOR VALUES WITH (MODULUS 100, REMAINDER 3);
-ERROR:  partition "fail_part" would overlap partition "hpart_4"
-LINE 1: ...BLE fail_part PARTITION OF hash_parted FOR VALUES WITH (MODU...
-                                                             ^
+ERROR:  at or near "partition": syntax error
+DETAIL:  source SQL:
+CREATE TABLE fail_part PARTITION OF hash_parted FOR VALUES WITH (MODULUS 100, REMAINDER 3)
+                       ^
+HINT:  try \h CREATE TABLE
 -- trying to specify range for the hash partitioned table
 CREATE TABLE fail_part PARTITION OF hash_parted FOR VALUES FROM ('a', 1) TO ('z');
-ERROR:  invalid bound specification for a hash partition
-LINE 1: ...BLE fail_part PARTITION OF hash_parted FOR VALUES FROM ('a',...
-                                                             ^
+ERROR:  at or near "partition": syntax error
+DETAIL:  source SQL:
+CREATE TABLE fail_part PARTITION OF hash_parted FOR VALUES FROM ('a', 1) TO ('z')
+                       ^
+HINT:  try \h CREATE TABLE
 -- trying to specify list value for the hash partitioned table
 CREATE TABLE fail_part PARTITION OF hash_parted FOR VALUES IN (1000);
-ERROR:  invalid bound specification for a hash partition
-LINE 1: ...BLE fail_part PARTITION OF hash_parted FOR VALUES IN (1000);
-                                                             ^
+ERROR:  at or near "partition": syntax error
+DETAIL:  source SQL:
+CREATE TABLE fail_part PARTITION OF hash_parted FOR VALUES IN (1000)
+                       ^
+HINT:  try \h CREATE TABLE
 -- trying to create default partition for the hash partitioned table
 CREATE TABLE fail_default_part PARTITION OF hash_parted DEFAULT;
-ERROR:  a hash-partitioned table may not have a default partition
+ERROR:  at or near "partition": syntax error
+DETAIL:  source SQL:
+CREATE TABLE fail_default_part PARTITION OF hash_parted DEFAULT
+                               ^
+HINT:  try \h CREATE TABLE
 -- check if compatible with the specified parent
 -- cannot create as partition of a non-partitioned table
 CREATE TABLE unparted (
 	a int
 );
 CREATE TABLE fail_part PARTITION OF unparted FOR VALUES IN ('a');
-ERROR:  "unparted" is not partitioned
+ERROR:  at or near "partition": syntax error
+DETAIL:  source SQL:
+CREATE TABLE fail_part PARTITION OF unparted FOR VALUES IN ('a')
+                       ^
+HINT:  try \h CREATE TABLE
 CREATE TABLE fail_part PARTITION OF unparted FOR VALUES WITH (MODULUS 2, REMAINDER 1);
-ERROR:  "unparted" is not partitioned
+ERROR:  at or near "partition": syntax error
+DETAIL:  source SQL:
+CREATE TABLE fail_part PARTITION OF unparted FOR VALUES WITH (MODULUS 2, REMAINDER 1)
+                       ^
+HINT:  try \h CREATE TABLE
 DROP TABLE unparted;
 -- cannot create a permanent rel as partition of a temp rel
 CREATE TEMP TABLE temp_parted (
 	a int
 ) PARTITION BY LIST (a);
+ERROR:  at or near "EOF": syntax error
+DETAIL:  source SQL:
+CREATE TEMP TABLE temp_parted (
+	a int
+) PARTITION BY LIST (a)
+                       ^
+HINT:  try \h CREATE TABLE
 CREATE TABLE fail_part PARTITION OF temp_parted FOR VALUES IN ('a');
-ERROR:  cannot create a permanent relation as partition of temporary relation "temp_parted"
+ERROR:  at or near "partition": syntax error
+DETAIL:  source SQL:
+CREATE TABLE fail_part PARTITION OF temp_parted FOR VALUES IN ('a')
+                       ^
+HINT:  try \h CREATE TABLE
 DROP TABLE temp_parted;
+ERROR:  relation "temp_parted" does not exist
 -- check for partition bound overlap and other invalid specifications
 CREATE TABLE list_parted2 (
 	a varchar
 ) PARTITION BY LIST (a);
+ERROR:  at or near "EOF": syntax error
+DETAIL:  source SQL:
+CREATE TABLE list_parted2 (
+	a varchar
+) PARTITION BY LIST (a)
+                       ^
+HINT:  try \h CREATE TABLE
 CREATE TABLE part_null_z PARTITION OF list_parted2 FOR VALUES IN (null, 'z');
+ERROR:  at or near "partition": syntax error
+DETAIL:  source SQL:
+CREATE TABLE part_null_z PARTITION OF list_parted2 FOR VALUES IN (null, 'z')
+                         ^
+HINT:  try \h CREATE TABLE
 CREATE TABLE part_ab PARTITION OF list_parted2 FOR VALUES IN ('a', 'b');
+ERROR:  at or near "partition": syntax error
+DETAIL:  source SQL:
+CREATE TABLE part_ab PARTITION OF list_parted2 FOR VALUES IN ('a', 'b')
+                     ^
+HINT:  try \h CREATE TABLE
 CREATE TABLE list_parted2_def PARTITION OF list_parted2 DEFAULT;
+ERROR:  at or near "partition": syntax error
+DETAIL:  source SQL:
+CREATE TABLE list_parted2_def PARTITION OF list_parted2 DEFAULT
+                              ^
+HINT:  try \h CREATE TABLE
 CREATE TABLE fail_part PARTITION OF list_parted2 FOR VALUES IN (null);
-ERROR:  partition "fail_part" would overlap partition "part_null_z"
-LINE 1: ...LE fail_part PARTITION OF list_parted2 FOR VALUES IN (null);
-                                                                 ^
+ERROR:  at or near "partition": syntax error
+DETAIL:  source SQL:
+CREATE TABLE fail_part PARTITION OF list_parted2 FOR VALUES IN (null)
+                       ^
+HINT:  try \h CREATE TABLE
 CREATE TABLE fail_part PARTITION OF list_parted2 FOR VALUES IN ('b', 'c');
-ERROR:  partition "fail_part" would overlap partition "part_ab"
-LINE 1: ...ail_part PARTITION OF list_parted2 FOR VALUES IN ('b', 'c');
-                                                             ^
+ERROR:  at or near "partition": syntax error
+DETAIL:  source SQL:
+CREATE TABLE fail_part PARTITION OF list_parted2 FOR VALUES IN ('b', 'c')
+                       ^
+HINT:  try \h CREATE TABLE
 -- check default partition overlap
 INSERT INTO list_parted2 VALUES('X');
+ERROR:  relation "list_parted2" does not exist
 CREATE TABLE fail_part PARTITION OF list_parted2 FOR VALUES IN ('W', 'X', 'Y');
-ERROR:  updated partition constraint for default partition "list_parted2_def" would be violated by some row
+ERROR:  at or near "partition": syntax error
+DETAIL:  source SQL:
+CREATE TABLE fail_part PARTITION OF list_parted2 FOR VALUES IN ('W', 'X', 'Y')
+                       ^
+HINT:  try \h CREATE TABLE
 CREATE TABLE range_parted2 (
 	a int
 ) PARTITION BY RANGE (a);
+ERROR:  at or near "EOF": syntax error
+DETAIL:  source SQL:
+CREATE TABLE range_parted2 (
+	a int
+) PARTITION BY RANGE (a)
+                        ^
+HINT:  try \h CREATE TABLE
 -- trying to create range partition with empty range
 CREATE TABLE fail_part PARTITION OF range_parted2 FOR VALUES FROM (1) TO (0);
-ERROR:  empty range bound specified for partition "fail_part"
-LINE 1: ..._part PARTITION OF range_parted2 FOR VALUES FROM (1) TO (0);
-                                                             ^
-DETAIL:  Specified lower bound (1) is greater than or equal to upper bound (0).
+ERROR:  at or near "partition": syntax error
+DETAIL:  source SQL:
+CREATE TABLE fail_part PARTITION OF range_parted2 FOR VALUES FROM (1) TO (0)
+                       ^
+HINT:  try \h CREATE TABLE
 -- note that the range '[1, 1)' has no elements
 CREATE TABLE fail_part PARTITION OF range_parted2 FOR VALUES FROM (1) TO (1);
-ERROR:  empty range bound specified for partition "fail_part"
-LINE 1: ..._part PARTITION OF range_parted2 FOR VALUES FROM (1) TO (1);
-                                                             ^
-DETAIL:  Specified lower bound (1) is greater than or equal to upper bound (1).
+ERROR:  at or near "partition": syntax error
+DETAIL:  source SQL:
+CREATE TABLE fail_part PARTITION OF range_parted2 FOR VALUES FROM (1) TO (1)
+                       ^
+HINT:  try \h CREATE TABLE
 CREATE TABLE part0 PARTITION OF range_parted2 FOR VALUES FROM (minvalue) TO (1);
+ERROR:  at or near "partition": syntax error
+DETAIL:  source SQL:
+CREATE TABLE part0 PARTITION OF range_parted2 FOR VALUES FROM (minvalue) TO (1)
+                   ^
+HINT:  try \h CREATE TABLE
 CREATE TABLE fail_part PARTITION OF range_parted2 FOR VALUES FROM (minvalue) TO (2);
-ERROR:  partition "fail_part" would overlap partition "part0"
-LINE 1: ..._part PARTITION OF range_parted2 FOR VALUES FROM (minvalue) ...
-                                                             ^
+ERROR:  at or near "partition": syntax error
+DETAIL:  source SQL:
+CREATE TABLE fail_part PARTITION OF range_parted2 FOR VALUES FROM (minvalue) TO (2)
+                       ^
+HINT:  try \h CREATE TABLE
 CREATE TABLE part1 PARTITION OF range_parted2 FOR VALUES FROM (1) TO (10);
+ERROR:  at or near "partition": syntax error
+DETAIL:  source SQL:
+CREATE TABLE part1 PARTITION OF range_parted2 FOR VALUES FROM (1) TO (10)
+                   ^
+HINT:  try \h CREATE TABLE
 CREATE TABLE fail_part PARTITION OF range_parted2 FOR VALUES FROM (-1) TO (1);
-ERROR:  partition "fail_part" would overlap partition "part0"
-LINE 1: ..._part PARTITION OF range_parted2 FOR VALUES FROM (-1) TO (1)...
-                                                             ^
+ERROR:  at or near "partition": syntax error
+DETAIL:  source SQL:
+CREATE TABLE fail_part PARTITION OF range_parted2 FOR VALUES FROM (-1) TO (1)
+                       ^
+HINT:  try \h CREATE TABLE
 CREATE TABLE fail_part PARTITION OF range_parted2 FOR VALUES FROM (9) TO (maxvalue);
-ERROR:  partition "fail_part" would overlap partition "part1"
-LINE 1: ..._part PARTITION OF range_parted2 FOR VALUES FROM (9) TO (max...
-                                                             ^
+ERROR:  at or near "partition": syntax error
+DETAIL:  source SQL:
+CREATE TABLE fail_part PARTITION OF range_parted2 FOR VALUES FROM (9) TO (maxvalue)
+                       ^
+HINT:  try \h CREATE TABLE
 CREATE TABLE part2 PARTITION OF range_parted2 FOR VALUES FROM (20) TO (30);
+ERROR:  at or near "partition": syntax error
+DETAIL:  source SQL:
+CREATE TABLE part2 PARTITION OF range_parted2 FOR VALUES FROM (20) TO (30)
+                   ^
+HINT:  try \h CREATE TABLE
 CREATE TABLE part3 PARTITION OF range_parted2 FOR VALUES FROM (30) TO (40);
+ERROR:  at or near "partition": syntax error
+DETAIL:  source SQL:
+CREATE TABLE part3 PARTITION OF range_parted2 FOR VALUES FROM (30) TO (40)
+                   ^
+HINT:  try \h CREATE TABLE
 CREATE TABLE fail_part PARTITION OF range_parted2 FOR VALUES FROM (10) TO (30);
-ERROR:  partition "fail_part" would overlap partition "part2"
-LINE 1: ...art PARTITION OF range_parted2 FOR VALUES FROM (10) TO (30);
-                                                                   ^
+ERROR:  at or near "partition": syntax error
+DETAIL:  source SQL:
+CREATE TABLE fail_part PARTITION OF range_parted2 FOR VALUES FROM (10) TO (30)
+                       ^
+HINT:  try \h CREATE TABLE
 CREATE TABLE fail_part PARTITION OF range_parted2 FOR VALUES FROM (10) TO (50);
-ERROR:  partition "fail_part" would overlap partition "part2"
-LINE 1: ...art PARTITION OF range_parted2 FOR VALUES FROM (10) TO (50);
-                                                                   ^
+ERROR:  at or near "partition": syntax error
+DETAIL:  source SQL:
+CREATE TABLE fail_part PARTITION OF range_parted2 FOR VALUES FROM (10) TO (50)
+                       ^
+HINT:  try \h CREATE TABLE
 -- Create a default partition for range partitioned table
 CREATE TABLE range2_default PARTITION OF range_parted2 DEFAULT;
+ERROR:  at or near "partition": syntax error
+DETAIL:  source SQL:
+CREATE TABLE range2_default PARTITION OF range_parted2 DEFAULT
+                            ^
+HINT:  try \h CREATE TABLE
 -- More than one default partition is not allowed, so this should give error
 CREATE TABLE fail_default_part PARTITION OF range_parted2 DEFAULT;
-ERROR:  partition "fail_default_part" conflicts with existing default partition "range2_default"
-LINE 1: ... TABLE fail_default_part PARTITION OF range_parted2 DEFAULT;
-                                                               ^
+ERROR:  at or near "partition": syntax error
+DETAIL:  source SQL:
+CREATE TABLE fail_default_part PARTITION OF range_parted2 DEFAULT
+                               ^
+HINT:  try \h CREATE TABLE
 -- Check if the range for default partitions overlap
 INSERT INTO range_parted2 VALUES (85);
+ERROR:  relation "range_parted2" does not exist
 CREATE TABLE fail_part PARTITION OF range_parted2 FOR VALUES FROM (80) TO (90);
-ERROR:  updated partition constraint for default partition "range2_default" would be violated by some row
+ERROR:  at or near "partition": syntax error
+DETAIL:  source SQL:
+CREATE TABLE fail_part PARTITION OF range_parted2 FOR VALUES FROM (80) TO (90)
+                       ^
+HINT:  try \h CREATE TABLE
 CREATE TABLE part4 PARTITION OF range_parted2 FOR VALUES FROM (90) TO (100);
+ERROR:  at or near "partition": syntax error
+DETAIL:  source SQL:
+CREATE TABLE part4 PARTITION OF range_parted2 FOR VALUES FROM (90) TO (100)
+                   ^
+HINT:  try \h CREATE TABLE
 -- now check for multi-column range partition key
 CREATE TABLE range_parted3 (
 	a int,
 	b int
 ) PARTITION BY RANGE (a, (b+1));
+ERROR:  at or near "(": syntax error
+DETAIL:  source SQL:
+CREATE TABLE range_parted3 (
+	a int,
+	b int
+) PARTITION BY RANGE (a, (b+1))
+                         ^
+HINT:  try \h CREATE TABLE
 CREATE TABLE part00 PARTITION OF range_parted3 FOR VALUES FROM (0, minvalue) TO (0, maxvalue);
+ERROR:  at or near "partition": syntax error
+DETAIL:  source SQL:
+CREATE TABLE part00 PARTITION OF range_parted3 FOR VALUES FROM (0, minvalue) TO (0, maxvalue)
+                    ^
+HINT:  try \h CREATE TABLE
 CREATE TABLE fail_part PARTITION OF range_parted3 FOR VALUES FROM (0, minvalue) TO (0, 1);
-ERROR:  partition "fail_part" would overlap partition "part00"
-LINE 1: ..._part PARTITION OF range_parted3 FOR VALUES FROM (0, minvalu...
-                                                             ^
+ERROR:  at or near "partition": syntax error
+DETAIL:  source SQL:
+CREATE TABLE fail_part PARTITION OF range_parted3 FOR VALUES FROM (0, minvalue) TO (0, 1)
+                       ^
+HINT:  try \h CREATE TABLE
 CREATE TABLE part10 PARTITION OF range_parted3 FOR VALUES FROM (1, minvalue) TO (1, 1);
+ERROR:  at or near "partition": syntax error
+DETAIL:  source SQL:
+CREATE TABLE part10 PARTITION OF range_parted3 FOR VALUES FROM (1, minvalue) TO (1, 1)
+                    ^
+HINT:  try \h CREATE TABLE
 CREATE TABLE part11 PARTITION OF range_parted3 FOR VALUES FROM (1, 1) TO (1, 10);
+ERROR:  at or near "partition": syntax error
+DETAIL:  source SQL:
+CREATE TABLE part11 PARTITION OF range_parted3 FOR VALUES FROM (1, 1) TO (1, 10)
+                    ^
+HINT:  try \h CREATE TABLE
 CREATE TABLE part12 PARTITION OF range_parted3 FOR VALUES FROM (1, 10) TO (1, maxvalue);
+ERROR:  at or near "partition": syntax error
+DETAIL:  source SQL:
+CREATE TABLE part12 PARTITION OF range_parted3 FOR VALUES FROM (1, 10) TO (1, maxvalue)
+                    ^
+HINT:  try \h CREATE TABLE
 CREATE TABLE fail_part PARTITION OF range_parted3 FOR VALUES FROM (1, 10) TO (1, 20);
-ERROR:  partition "fail_part" would overlap partition "part12"
-LINE 1: ...rt PARTITION OF range_parted3 FOR VALUES FROM (1, 10) TO (1,...
-                                                             ^
+ERROR:  at or near "partition": syntax error
+DETAIL:  source SQL:
+CREATE TABLE fail_part PARTITION OF range_parted3 FOR VALUES FROM (1, 10) TO (1, 20)
+                       ^
+HINT:  try \h CREATE TABLE
 CREATE TABLE range3_default PARTITION OF range_parted3 DEFAULT;
+ERROR:  at or near "partition": syntax error
+DETAIL:  source SQL:
+CREATE TABLE range3_default PARTITION OF range_parted3 DEFAULT
+                            ^
+HINT:  try \h CREATE TABLE
 -- cannot create a partition that says column b is allowed to range
 -- from -infinity to +infinity, while there exist partitions that have
 -- more specific ranges
 CREATE TABLE fail_part PARTITION OF range_parted3 FOR VALUES FROM (1, minvalue) TO (1, maxvalue);
-ERROR:  partition "fail_part" would overlap partition "part10"
-LINE 1: ..._part PARTITION OF range_parted3 FOR VALUES FROM (1, minvalu...
-                                                             ^
+ERROR:  at or near "partition": syntax error
+DETAIL:  source SQL:
+CREATE TABLE fail_part PARTITION OF range_parted3 FOR VALUES FROM (1, minvalue) TO (1, maxvalue)
+                       ^
+HINT:  try \h CREATE TABLE
 -- check for partition bound overlap and other invalid specifications for the hash partition
 CREATE TABLE hash_parted2 (
 	a varchar
 ) PARTITION BY HASH (a);
+ERROR:  at or near "hash": syntax error
+DETAIL:  source SQL:
+CREATE TABLE hash_parted2 (
+	a varchar
+) PARTITION BY HASH (a)
+               ^
+HINT:  try \h CREATE TABLE
 CREATE TABLE h2part_1 PARTITION OF hash_parted2 FOR VALUES WITH (MODULUS 4, REMAINDER 2);
+ERROR:  at or near "partition": syntax error
+DETAIL:  source SQL:
+CREATE TABLE h2part_1 PARTITION OF hash_parted2 FOR VALUES WITH (MODULUS 4, REMAINDER 2)
+                      ^
+HINT:  try \h CREATE TABLE
 CREATE TABLE h2part_2 PARTITION OF hash_parted2 FOR VALUES WITH (MODULUS 8, REMAINDER 0);
+ERROR:  at or near "partition": syntax error
+DETAIL:  source SQL:
+CREATE TABLE h2part_2 PARTITION OF hash_parted2 FOR VALUES WITH (MODULUS 8, REMAINDER 0)
+                      ^
+HINT:  try \h CREATE TABLE
 CREATE TABLE h2part_3 PARTITION OF hash_parted2 FOR VALUES WITH (MODULUS 8, REMAINDER 4);
+ERROR:  at or near "partition": syntax error
+DETAIL:  source SQL:
+CREATE TABLE h2part_3 PARTITION OF hash_parted2 FOR VALUES WITH (MODULUS 8, REMAINDER 4)
+                      ^
+HINT:  try \h CREATE TABLE
 CREATE TABLE h2part_4 PARTITION OF hash_parted2 FOR VALUES WITH (MODULUS 8, REMAINDER 5);
+ERROR:  at or near "partition": syntax error
+DETAIL:  source SQL:
+CREATE TABLE h2part_4 PARTITION OF hash_parted2 FOR VALUES WITH (MODULUS 8, REMAINDER 5)
+                      ^
+HINT:  try \h CREATE TABLE
 -- overlap with part_4
 CREATE TABLE fail_part PARTITION OF hash_parted2 FOR VALUES WITH (MODULUS 2, REMAINDER 1);
-ERROR:  partition "fail_part" would overlap partition "h2part_4"
-LINE 1: ...LE fail_part PARTITION OF hash_parted2 FOR VALUES WITH (MODU...
-                                                             ^
+ERROR:  at or near "partition": syntax error
+DETAIL:  source SQL:
+CREATE TABLE fail_part PARTITION OF hash_parted2 FOR VALUES WITH (MODULUS 2, REMAINDER 1)
+                       ^
+HINT:  try \h CREATE TABLE
 -- modulus must be greater than zero
 CREATE TABLE fail_part PARTITION OF hash_parted2 FOR VALUES WITH (MODULUS 0, REMAINDER 1);
-ERROR:  modulus for hash partition must be an integer value greater than zero
+ERROR:  at or near "partition": syntax error
+DETAIL:  source SQL:
+CREATE TABLE fail_part PARTITION OF hash_parted2 FOR VALUES WITH (MODULUS 0, REMAINDER 1)
+                       ^
+HINT:  try \h CREATE TABLE
 -- remainder must be greater than or equal to zero and less than modulus
 CREATE TABLE fail_part PARTITION OF hash_parted2 FOR VALUES WITH (MODULUS 8, REMAINDER 8);
-ERROR:  remainder for hash partition must be less than modulus
+ERROR:  at or near "partition": syntax error
+DETAIL:  source SQL:
+CREATE TABLE fail_part PARTITION OF hash_parted2 FOR VALUES WITH (MODULUS 8, REMAINDER 8)
+                       ^
+HINT:  try \h CREATE TABLE
 -- check schema propagation from parent
 CREATE TABLE parted (
 	a text,
 	b int NOT NULL DEFAULT 0,
 	CONSTRAINT check_a CHECK (length(a) > 0)
 ) PARTITION BY LIST (a);
+ERROR:  at or near "EOF": syntax error
+DETAIL:  source SQL:
+CREATE TABLE parted (
+	a text,
+	b int NOT NULL DEFAULT 0,
+	CONSTRAINT check_a CHECK (length(a) > 0)
+) PARTITION BY LIST (a)
+                       ^
+HINT:  try \h CREATE TABLE
 CREATE TABLE part_a PARTITION OF parted FOR VALUES IN ('a');
+ERROR:  at or near "partition": syntax error
+DETAIL:  source SQL:
+CREATE TABLE part_a PARTITION OF parted FOR VALUES IN ('a')
+                    ^
+HINT:  try \h CREATE TABLE
 -- only inherited attributes (never local ones)
 SELECT attname, attislocal, attinhcount FROM pg_attribute
   WHERE attrelid = 'part_a'::regclass and attnum > 0
   ORDER BY attnum;
- attname | attislocal | attinhcount 
----------+------------+-------------
- a       | f          |           1
- b       | f          |           1
-(2 rows)
-
+ERROR:  relation "part_a" does not exist
 -- able to specify column default, column constraint, and table constraint
 -- first check the "column specified more than once" error
 CREATE TABLE part_b PARTITION OF parted (
@@ -758,199 +1395,307 @@
 	b CHECK (b >= 0),
 	CONSTRAINT check_a CHECK (length(a) > 0)
 ) FOR VALUES IN ('b');
-ERROR:  column "b" specified more than once
+ERROR:  at or near "partition": syntax error
+DETAIL:  source SQL:
+CREATE TABLE part_b PARTITION OF parted (
+                    ^
+HINT:  try \h CREATE TABLE
 CREATE TABLE part_b PARTITION OF parted (
 	b NOT NULL DEFAULT 1,
 	CONSTRAINT check_a CHECK (length(a) > 0),
 	CONSTRAINT check_b CHECK (b >= 0)
 ) FOR VALUES IN ('b');
-NOTICE:  merging constraint "check_a" with inherited definition
+ERROR:  at or near "partition": syntax error
+DETAIL:  source SQL:
+CREATE TABLE part_b PARTITION OF parted (
+                    ^
+HINT:  try \h CREATE TABLE
 -- conislocal should be false for any merged constraints, true otherwise
 SELECT conislocal, coninhcount FROM pg_constraint WHERE conrelid = 'part_b'::regclass ORDER BY conislocal, coninhcount;
- conislocal | coninhcount 
-------------+-------------
- f          |           1
- t          |           0
-(2 rows)
-
+ERROR:  relation "part_b" does not exist
 -- Once check_b is added to the parent, it should be made non-local for part_b
 ALTER TABLE parted ADD CONSTRAINT check_b CHECK (b >= 0);
-NOTICE:  merging constraint "check_b" with inherited definition
+ERROR:  relation "parted" does not exist
 SELECT conislocal, coninhcount FROM pg_constraint WHERE conrelid = 'part_b'::regclass;
- conislocal | coninhcount 
-------------+-------------
- f          |           1
- f          |           1
-(2 rows)
-
+ERROR:  relation "part_b" does not exist
 -- Neither check_a nor check_b are droppable from part_b
 ALTER TABLE part_b DROP CONSTRAINT check_a;
-ERROR:  cannot drop inherited constraint "check_a" of relation "part_b"
+ERROR:  relation "part_b" does not exist
 ALTER TABLE part_b DROP CONSTRAINT check_b;
-ERROR:  cannot drop inherited constraint "check_b" of relation "part_b"
+ERROR:  relation "part_b" does not exist
 -- And dropping it from parted should leave no trace of them on part_b, unlike
 -- traditional inheritance where they will be left behind, because they would
 -- be local constraints.
 ALTER TABLE parted DROP CONSTRAINT check_a, DROP CONSTRAINT check_b;
+ERROR:  relation "parted" does not exist
 SELECT conislocal, coninhcount FROM pg_constraint WHERE conrelid = 'part_b'::regclass;
- conislocal | coninhcount 
-------------+-------------
-(0 rows)
-
+ERROR:  relation "part_b" does not exist
 -- specify PARTITION BY for a partition
 CREATE TABLE fail_part_col_not_found PARTITION OF parted FOR VALUES IN ('c') PARTITION BY RANGE (c);
-ERROR:  column "c" named in partition key does not exist
-LINE 1: ...TITION OF parted FOR VALUES IN ('c') PARTITION BY RANGE (c);
-                                                                    ^
+ERROR:  at or near "partition": syntax error
+DETAIL:  source SQL:
+CREATE TABLE fail_part_col_not_found PARTITION OF parted FOR VALUES IN ('c') PARTITION BY RANGE (c)
+                                     ^
+HINT:  try \h CREATE TABLE
 CREATE TABLE part_c PARTITION OF parted (b WITH OPTIONS NOT NULL DEFAULT 0) FOR VALUES IN ('c') PARTITION BY RANGE ((b));
+ERROR:  at or near "partition": syntax error
+DETAIL:  source SQL:
+CREATE TABLE part_c PARTITION OF parted (b WITH OPTIONS NOT NULL DEFAULT 0) FOR VALUES IN ('c') PARTITION BY RANGE ((b))
+                    ^
+HINT:  try \h CREATE TABLE
 -- create a level-2 partition
 CREATE TABLE part_c_1_10 PARTITION OF part_c FOR VALUES FROM (1) TO (10);
+ERROR:  at or near "partition": syntax error
+DETAIL:  source SQL:
+CREATE TABLE part_c_1_10 PARTITION OF part_c FOR VALUES FROM (1) TO (10)
+                         ^
+HINT:  try \h CREATE TABLE
 -- check that NOT NULL and default value are inherited correctly
 create table parted_notnull_inh_test (a int default 1, b int not null default 0) partition by list (a);
+ERROR:  at or near "EOF": syntax error
+DETAIL:  source SQL:
+create table parted_notnull_inh_test (a int default 1, b int not null default 0) partition by list (a)
+                                                                                                      ^
+HINT:  try \h CREATE TABLE
 create table parted_notnull_inh_test1 partition of parted_notnull_inh_test (a not null, b default 1) for values in (1);
+ERROR:  at or near "partition": syntax error
+DETAIL:  source SQL:
+create table parted_notnull_inh_test1 partition of parted_notnull_inh_test (a not null, b default 1) for values in (1)
+                                      ^
+HINT:  try \h CREATE TABLE
 insert into parted_notnull_inh_test (b) values (null);
-ERROR:  null value in column "b" of relation "parted_notnull_inh_test1" violates not-null constraint
-DETAIL:  Failing row contains (1, null).
+ERROR:  relation "parted_notnull_inh_test" does not exist
 -- note that while b's default is overridden, a's default is preserved
 \d parted_notnull_inh_test1
-      Table "public.parted_notnull_inh_test1"
- Column |  Type   | Collation | Nullable | Default 
---------+---------+-----------+----------+---------
- a      | integer |           | not null | 1
- b      | integer |           | not null | 1
-Partition of: parted_notnull_inh_test FOR VALUES IN (1)
-
+ERROR:  at or near ".": syntax error
+DETAIL:  source SQL:
+SELECT c.oid,
+  n.nspname,
+  c.relname
+FROM pg_catalog.pg_class c
+     LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace
+WHERE c.relname OPERATOR(pg_catalog.~) '^(parted_notnull_inh_test1)$' COLLATE pg_catalog.default
+                                                                                        ^
 drop table parted_notnull_inh_test;
+ERROR:  relation "parted_notnull_inh_test" does not exist
 -- check that collations are assigned in partition bound expressions
 create table parted_boolean_col (a bool, b text) partition by list(a);
+ERROR:  at or near "EOF": syntax error
+DETAIL:  source SQL:
+create table parted_boolean_col (a bool, b text) partition by list(a)
+                                                                     ^
+HINT:  try \h CREATE TABLE
 create table parted_boolean_less partition of parted_boolean_col
   for values in ('foo' < 'bar');
+ERROR:  at or near "partition": syntax error
+DETAIL:  source SQL:
+create table parted_boolean_less partition of parted_boolean_col
+                                 ^
+HINT:  try \h CREATE TABLE
 create table parted_boolean_greater partition of parted_boolean_col
   for values in ('foo' > 'bar');
+ERROR:  at or near "partition": syntax error
+DETAIL:  source SQL:
+create table parted_boolean_greater partition of parted_boolean_col
+                                    ^
+HINT:  try \h CREATE TABLE
 drop table parted_boolean_col;
+ERROR:  relation "parted_boolean_col" does not exist
 -- check for a conflicting COLLATE clause
 create table parted_collate_must_match (a text collate "C", b text collate "C")
   partition by range (a);
+ERROR:  at or near ",": syntax error: invalid locale C: language: tag is not well-formed
+DETAIL:  source SQL:
+create table parted_collate_must_match (a text collate "C", b text collate "C")
+                                                          ^
 -- on the partition key
 create table parted_collate_must_match1 partition of parted_collate_must_match
   (a collate "POSIX") for values from ('a') to ('m');
+ERROR:  at or near "partition": syntax error
+DETAIL:  source SQL:
+create table parted_collate_must_match1 partition of parted_collate_must_match
+                                        ^
+HINT:  try \h CREATE TABLE
 -- on another column
 create table parted_collate_must_match2 partition of parted_collate_must_match
   (b collate "POSIX") for values from ('m') to ('z');
+ERROR:  at or near "partition": syntax error
+DETAIL:  source SQL:
+create table parted_collate_must_match2 partition of parted_collate_must_match
+                                        ^
+HINT:  try \h CREATE TABLE
 drop table parted_collate_must_match;
+ERROR:  relation "parted_collate_must_match" does not exist
 -- check that non-matching collations for partition bound
 -- expressions are coerced to the right collation
 create table test_part_coll_posix (a text) partition by range (a collate "POSIX");
+ERROR:  at or near "collate": syntax error
+DETAIL:  source SQL:
+create table test_part_coll_posix (a text) partition by range (a collate "POSIX")
+                                                                 ^
+HINT:  try \h CREATE TABLE
 -- ok, collation is implicitly coerced
 create table test_part_coll partition of test_part_coll_posix for values from ('a' collate "C") to ('g');
+ERROR:  at or near "partition": syntax error
+DETAIL:  source SQL:
+create table test_part_coll partition of test_part_coll_posix for values from ('a' collate "C") to ('g')
+                            ^
+HINT:  try \h CREATE TABLE
 -- ok
 create table test_part_coll2 partition of test_part_coll_posix for values from ('g') to ('m');
+ERROR:  at or near "partition": syntax error
+DETAIL:  source SQL:
+create table test_part_coll2 partition of test_part_coll_posix for values from ('g') to ('m')
+                             ^
+HINT:  try \h CREATE TABLE
 -- ok, collation is implicitly coerced
 create table test_part_coll_cast partition of test_part_coll_posix for values from (name 'm' collate "C") to ('s');
+ERROR:  at or near "partition": syntax error
+DETAIL:  source SQL:
+create table test_part_coll_cast partition of test_part_coll_posix for values from (name 'm' collate "C") to ('s')
+                                 ^
+HINT:  try \h CREATE TABLE
 -- ok; partition collation silently overrides the default collation of type 'name'
 create table test_part_coll_cast2 partition of test_part_coll_posix for values from (name 's') to ('z');
+ERROR:  at or near "partition": syntax error
+DETAIL:  source SQL:
+create table test_part_coll_cast2 partition of test_part_coll_posix for values from (name 's') to ('z')
+                                  ^
+HINT:  try \h CREATE TABLE
 drop table test_part_coll_posix;
+ERROR:  relation "test_part_coll_posix" does not exist
 -- Partition bound in describe output
 \d+ part_b
-                                   Table "public.part_b"
- Column |  Type   | Collation | Nullable | Default | Storage  | Stats target | Description 
---------+---------+-----------+----------+---------+----------+--------------+-------------
- a      | text    |           |          |         | extended |              | 
- b      | integer |           | not null | 1       | plain    |              | 
-Partition of: parted FOR VALUES IN ('b')
-Partition constraint: ((a IS NOT NULL) AND (a = 'b'::text))
-
+ERROR:  at or near ".": syntax error
+DETAIL:  source SQL:
+SELECT c.oid,
+  n.nspname,
+  c.relname
+FROM pg_catalog.pg_class c
+     LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace
+WHERE c.relname OPERATOR(pg_catalog.~) '^(part_b)$' COLLATE pg_catalog.default
+                                                                      ^
 -- Both partition bound and partition key in describe output
 \d+ part_c
-                             Partitioned table "public.part_c"
- Column |  Type   | Collation | Nullable | Default | Storage  | Stats target | Description 
---------+---------+-----------+----------+---------+----------+--------------+-------------
- a      | text    |           |          |         | extended |              | 
- b      | integer |           | not null | 0       | plain    |              | 
-Partition of: parted FOR VALUES IN ('c')
-Partition constraint: ((a IS NOT NULL) AND (a = 'c'::text))
-Partition key: RANGE (b)
-Partitions: part_c_1_10 FOR VALUES FROM (1) TO (10)
-
+ERROR:  at or near ".": syntax error
+DETAIL:  source SQL:
+SELECT c.oid,
+  n.nspname,
+  c.relname
+FROM pg_catalog.pg_class c
+     LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace
+WHERE c.relname OPERATOR(pg_catalog.~) '^(part_c)$' COLLATE pg_catalog.default
+                                                                      ^
 -- a level-2 partition's constraint will include the parent's expressions
 \d+ part_c_1_10
-                                Table "public.part_c_1_10"
- Column |  Type   | Collation | Nullable | Default | Storage  | Stats target | Description 
---------+---------+-----------+----------+---------+----------+--------------+-------------
- a      | text    |           |          |         | extended |              | 
- b      | integer |           | not null | 0       | plain    |              | 
-Partition of: part_c FOR VALUES FROM (1) TO (10)
-Partition constraint: ((a IS NOT NULL) AND (a = 'c'::text) AND (b IS NOT NULL) AND (b >= 1) AND (b < 10))
-
+ERROR:  at or near ".": syntax error
+DETAIL:  source SQL:
+SELECT c.oid,
+  n.nspname,
+  c.relname
+FROM pg_catalog.pg_class c
+     LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace
+WHERE c.relname OPERATOR(pg_catalog.~) '^(part_c_1_10)$' COLLATE pg_catalog.default
+                                                                           ^
 -- Show partition count in the parent's describe output
 -- Tempted to include \d+ output listing partitions with bound info but
 -- output could vary depending on the order in which partition oids are
 -- returned.
 \d parted
-         Partitioned table "public.parted"
- Column |  Type   | Collation | Nullable | Default 
---------+---------+-----------+----------+---------
- a      | text    |           |          | 
- b      | integer |           | not null | 0
-Partition key: LIST (a)
-Number of partitions: 3 (Use \d+ to list them.)
-
+ERROR:  at or near ".": syntax error
+DETAIL:  source SQL:
+SELECT c.oid,
+  n.nspname,
+  c.relname
+FROM pg_catalog.pg_class c
+     LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace
+WHERE c.relname OPERATOR(pg_catalog.~) '^(parted)$' COLLATE pg_catalog.default
+                                                                      ^
 \d hash_parted
-      Partitioned table "public.hash_parted"
- Column |  Type   | Collation | Nullable | Default 
---------+---------+-----------+----------+---------
- a      | integer |           |          | 
-Partition key: HASH (a)
-Number of partitions: 4 (Use \d+ to list them.)
-
+ERROR:  at or near ".": syntax error
+DETAIL:  source SQL:
+SELECT c.oid,
+  n.nspname,
+  c.relname
+FROM pg_catalog.pg_class c
+     LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace
+WHERE c.relname OPERATOR(pg_catalog.~) '^(hash_parted)$' COLLATE pg_catalog.default
+                                                                           ^
 -- check that we get the expected partition constraints
 CREATE TABLE range_parted4 (a int, b int, c int) PARTITION BY RANGE (abs(a), abs(b), c);
+ERROR:  at or near "(": syntax error
+DETAIL:  source SQL:
+CREATE TABLE range_parted4 (a int, b int, c int) PARTITION BY RANGE (abs(a), abs(b), c)
+                                                                        ^
+HINT:  try \h CREATE TABLE
 CREATE TABLE unbounded_range_part PARTITION OF range_parted4 FOR VALUES FROM (MINVALUE, MINVALUE, MINVALUE) TO (MAXVALUE, MAXVALUE, MAXVALUE);
+ERROR:  at or near "partition": syntax error
+DETAIL:  source SQL:
+CREATE TABLE unbounded_range_part PARTITION OF range_parted4 FOR VALUES FROM (MINVALUE, MINVALUE, MINVALUE) TO (MAXVALUE, MAXVALUE, MAXVALUE)
+                                  ^
+HINT:  try \h CREATE TABLE
 \d+ unbounded_range_part
-                           Table "public.unbounded_range_part"
- Column |  Type   | Collation | Nullable | Default | Storage | Stats target | Description 
---------+---------+-----------+----------+---------+---------+--------------+-------------
- a      | integer |           |          |         | plain   |              | 
- b      | integer |           |          |         | plain   |              | 
- c      | integer |           |          |         | plain   |              | 
-Partition of: range_parted4 FOR VALUES FROM (MINVALUE, MINVALUE, MINVALUE) TO (MAXVALUE, MAXVALUE, MAXVALUE)
-Partition constraint: ((abs(a) IS NOT NULL) AND (abs(b) IS NOT NULL) AND (c IS NOT NULL))
-
+ERROR:  at or near ".": syntax error
+DETAIL:  source SQL:
+SELECT c.oid,
+  n.nspname,
+  c.relname
+FROM pg_catalog.pg_class c
+     LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace
+WHERE c.relname OPERATOR(pg_catalog.~) '^(unbounded_range_part)$' COLLATE pg_catalog.default
+                                                                                    ^
 DROP TABLE unbounded_range_part;
+ERROR:  relation "unbounded_range_part" does not exist
 CREATE TABLE range_parted4_1 PARTITION OF range_parted4 FOR VALUES FROM (MINVALUE, MINVALUE, MINVALUE) TO (1, MAXVALUE, MAXVALUE);
+ERROR:  at or near "partition": syntax error
+DETAIL:  source SQL:
+CREATE TABLE range_parted4_1 PARTITION OF range_parted4 FOR VALUES FROM (MINVALUE, MINVALUE, MINVALUE) TO (1, MAXVALUE, MAXVALUE)
+                             ^
+HINT:  try \h CREATE TABLE
 \d+ range_parted4_1
-                              Table "public.range_parted4_1"
- Column |  Type   | Collation | Nullable | Default | Storage | Stats target | Description 
---------+---------+-----------+----------+---------+---------+--------------+-------------
- a      | integer |           |          |         | plain   |              | 
- b      | integer |           |          |         | plain   |              | 
- c      | integer |           |          |         | plain   |              | 
-Partition of: range_parted4 FOR VALUES FROM (MINVALUE, MINVALUE, MINVALUE) TO (1, MAXVALUE, MAXVALUE)
-Partition constraint: ((abs(a) IS NOT NULL) AND (abs(b) IS NOT NULL) AND (c IS NOT NULL) AND (abs(a) <= 1))
-
+ERROR:  at or near ".": syntax error
+DETAIL:  source SQL:
+SELECT c.oid,
+  n.nspname,
+  c.relname
+FROM pg_catalog.pg_class c
+     LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace
+WHERE c.relname OPERATOR(pg_catalog.~) '^(range_parted4_1)$' COLLATE pg_catalog.default
+                                                                               ^
 CREATE TABLE range_parted4_2 PARTITION OF range_parted4 FOR VALUES FROM (3, 4, 5) TO (6, 7, MAXVALUE);
+ERROR:  at or near "partition": syntax error
+DETAIL:  source SQL:
+CREATE TABLE range_parted4_2 PARTITION OF range_parted4 FOR VALUES FROM (3, 4, 5) TO (6, 7, MAXVALUE)
+                             ^
+HINT:  try \h CREATE TABLE
 \d+ range_parted4_2
-                              Table "public.range_parted4_2"
- Column |  Type   | Collation | Nullable | Default | Storage | Stats target | Description 
---------+---------+-----------+----------+---------+---------+--------------+-------------
- a      | integer |           |          |         | plain   |              | 
- b      | integer |           |          |         | plain   |              | 
- c      | integer |           |          |         | plain   |              | 
-Partition of: range_parted4 FOR VALUES FROM (3, 4, 5) TO (6, 7, MAXVALUE)
-Partition constraint: ((abs(a) IS NOT NULL) AND (abs(b) IS NOT NULL) AND (c IS NOT NULL) AND ((abs(a) > 3) OR ((abs(a) = 3) AND (abs(b) > 4)) OR ((abs(a) = 3) AND (abs(b) = 4) AND (c >= 5))) AND ((abs(a) < 6) OR ((abs(a) = 6) AND (abs(b) <= 7))))
-
+ERROR:  at or near ".": syntax error
+DETAIL:  source SQL:
+SELECT c.oid,
+  n.nspname,
+  c.relname
+FROM pg_catalog.pg_class c
+     LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace
+WHERE c.relname OPERATOR(pg_catalog.~) '^(range_parted4_2)$' COLLATE pg_catalog.default
+                                                                               ^
 CREATE TABLE range_parted4_3 PARTITION OF range_parted4 FOR VALUES FROM (6, 8, MINVALUE) TO (9, MAXVALUE, MAXVALUE);
+ERROR:  at or near "partition": syntax error
+DETAIL:  source SQL:
+CREATE TABLE range_parted4_3 PARTITION OF range_parted4 FOR VALUES FROM (6, 8, MINVALUE) TO (9, MAXVALUE, MAXVALUE)
+                             ^
+HINT:  try \h CREATE TABLE
 \d+ range_parted4_3
-                              Table "public.range_parted4_3"
- Column |  Type   | Collation | Nullable | Default | Storage | Stats target | Description 
---------+---------+-----------+----------+---------+---------+--------------+-------------
- a      | integer |           |          |         | plain   |              | 
- b      | integer |           |          |         | plain   |              | 
- c      | integer |           |          |         | plain   |              | 
-Partition of: range_parted4 FOR VALUES FROM (6, 8, MINVALUE) TO (9, MAXVALUE, MAXVALUE)
-Partition constraint: ((abs(a) IS NOT NULL) AND (abs(b) IS NOT NULL) AND (c IS NOT NULL) AND ((abs(a) > 6) OR ((abs(a) = 6) AND (abs(b) >= 8))) AND (abs(a) <= 9))
-
+ERROR:  at or near ".": syntax error
+DETAIL:  source SQL:
+SELECT c.oid,
+  n.nspname,
+  c.relname
+FROM pg_catalog.pg_class c
+     LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace
+WHERE c.relname OPERATOR(pg_catalog.~) '^(range_parted4_3)$' COLLATE pg_catalog.default
+                                                                               ^
 DROP TABLE range_parted4;
+ERROR:  relation "range_parted4" does not exist
 -- user-defined operator class in partition key
 CREATE FUNCTION my_int4_sort(int4,int4) RETURNS int LANGUAGE sql
   AS $$ SELECT CASE WHEN $1 = $2 THEN 0 WHEN $1 > $2 THEN 1 ELSE -1 END; $$;
@@ -958,117 +1703,267 @@
   OPERATOR 1 < (int4,int4), OPERATOR 2 <= (int4,int4),
   OPERATOR 3 = (int4,int4), OPERATOR 4 >= (int4,int4),
   OPERATOR 5 > (int4,int4), FUNCTION 1 my_int4_sort(int4,int4);
+ERROR:  at or near "class": syntax error: unimplemented: this syntax
+DETAIL:  source SQL:
+CREATE OPERATOR CLASS test_int4_ops FOR TYPE int4 USING btree AS
+                ^
+HINT:  You have attempted to use a feature that is not yet implemented.
+See: https://go.crdb.dev/issue-v/65017/_version_
 CREATE TABLE partkey_t (a int4) PARTITION BY RANGE (a test_int4_ops);
+ERROR:  at or near "test_int4_ops": syntax error
+DETAIL:  source SQL:
+CREATE TABLE partkey_t (a int4) PARTITION BY RANGE (a test_int4_ops)
+                                                      ^
+HINT:  try \h CREATE TABLE
 CREATE TABLE partkey_t_1 PARTITION OF partkey_t FOR VALUES FROM (0) TO (1000);
+ERROR:  at or near "partition": syntax error
+DETAIL:  source SQL:
+CREATE TABLE partkey_t_1 PARTITION OF partkey_t FOR VALUES FROM (0) TO (1000)
+                         ^
+HINT:  try \h CREATE TABLE
 INSERT INTO partkey_t VALUES (100);
+ERROR:  relation "partkey_t" does not exist
 INSERT INTO partkey_t VALUES (200);
+ERROR:  relation "partkey_t" does not exist
 -- cleanup
 DROP TABLE parted, list_parted, range_parted, list_parted2, range_parted2, range_parted3;
+ERROR:  relation "parted" does not exist
 DROP TABLE partkey_t, hash_parted, hash_parted2;
+ERROR:  relation "partkey_t" does not exist
 DROP OPERATOR CLASS test_int4_ops USING btree;
+ERROR:  at or near "class": syntax error: unimplemented: this syntax
+DETAIL:  source SQL:
+DROP OPERATOR CLASS test_int4_ops USING btree
+              ^
+HINT:  You have attempted to use a feature that is not yet implemented.
+
+Please check the public issue tracker to check whether this problem is
+already tracked. If you cannot find it there, please report the error
+with details by creating a new issue.
+
+If you would rather not post publicly, please contact us directly
+using the support form.
+
+We appreciate your feedback.
+
 DROP FUNCTION my_int4_sort(int4,int4);
 -- comments on partitioned tables columns
 CREATE TABLE parted_col_comment (a int, b text) PARTITION BY LIST (a);
+ERROR:  at or near "EOF": syntax error
+DETAIL:  source SQL:
+CREATE TABLE parted_col_comment (a int, b text) PARTITION BY LIST (a)
+                                                                     ^
+HINT:  try \h CREATE TABLE
 COMMENT ON TABLE parted_col_comment IS 'Am partitioned table';
+ERROR:  relation "parted_col_comment" does not exist
 COMMENT ON COLUMN parted_col_comment.a IS 'Partition key';
+ERROR:  relation "parted_col_comment" does not exist
 SELECT obj_description('parted_col_comment'::regclass);
-   obj_description    
-----------------------
- Am partitioned table
-(1 row)
-
+ERROR:  relation "parted_col_comment" does not exist
 \d+ parted_col_comment
-                        Partitioned table "public.parted_col_comment"
- Column |  Type   | Collation | Nullable | Default | Storage  | Stats target |  Description  
---------+---------+-----------+----------+---------+----------+--------------+---------------
- a      | integer |           |          |         | plain    |              | Partition key
- b      | text    |           |          |         | extended |              | 
-Partition key: LIST (a)
-Number of partitions: 0
-
+ERROR:  at or near ".": syntax error
+DETAIL:  source SQL:
+SELECT c.oid,
+  n.nspname,
+  c.relname
+FROM pg_catalog.pg_class c
+     LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace
+WHERE c.relname OPERATOR(pg_catalog.~) '^(parted_col_comment)$' COLLATE pg_catalog.default
+                                                                                  ^
 DROP TABLE parted_col_comment;
+ERROR:  relation "parted_col_comment" does not exist
 -- specifying storage parameters for partitioned tables is not supported
 CREATE TABLE parted_col_comment (a int, b text) PARTITION BY LIST (a) WITH (fillfactor=100);
-ERROR:  cannot specify storage parameters for a partitioned table
-HINT:  Specify storage parameters for its leaf partitions instead.
+ERROR:  at or near "with": syntax error
+DETAIL:  source SQL:
+CREATE TABLE parted_col_comment (a int, b text) PARTITION BY LIST (a) WITH (fillfactor=100)
+                                                                      ^
+HINT:  try \h CREATE TABLE
 -- list partitioning on array type column
 CREATE TABLE arrlp (a int[]) PARTITION BY LIST (a);
+ERROR:  at or near "EOF": syntax error
+DETAIL:  source SQL:
+CREATE TABLE arrlp (a int[]) PARTITION BY LIST (a)
+                                                  ^
+HINT:  try \h CREATE TABLE
 CREATE TABLE arrlp12 PARTITION OF arrlp FOR VALUES IN ('{1}', '{2}');
+ERROR:  at or near "partition": syntax error
+DETAIL:  source SQL:
+CREATE TABLE arrlp12 PARTITION OF arrlp FOR VALUES IN ('{1}', '{2}')
+                     ^
+HINT:  try \h CREATE TABLE
 \d+ arrlp12
-                                   Table "public.arrlp12"
- Column |   Type    | Collation | Nullable | Default | Storage  | Stats target | Description 
---------+-----------+-----------+----------+---------+----------+--------------+-------------
- a      | integer[] |           |          |         | extended |              | 
-Partition of: arrlp FOR VALUES IN ('{1}', '{2}')
-Partition constraint: ((a IS NOT NULL) AND ((a = '{1}'::integer[]) OR (a = '{2}'::integer[])))
-
+ERROR:  at or near ".": syntax error
+DETAIL:  source SQL:
+SELECT c.oid,
+  n.nspname,
+  c.relname
+FROM pg_catalog.pg_class c
+     LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace
+WHERE c.relname OPERATOR(pg_catalog.~) '^(arrlp12)$' COLLATE pg_catalog.default
+                                                                       ^
 DROP TABLE arrlp;
+ERROR:  relation "arrlp" does not exist
 -- partition on boolean column
 create table boolspart (a bool) partition by list (a);
+ERROR:  at or near "EOF": syntax error
+DETAIL:  source SQL:
+create table boolspart (a bool) partition by list (a)
+                                                     ^
+HINT:  try \h CREATE TABLE
 create table boolspart_t partition of boolspart for values in (true);
+ERROR:  at or near "partition": syntax error
+DETAIL:  source SQL:
+create table boolspart_t partition of boolspart for values in (true)
+                         ^
+HINT:  try \h CREATE TABLE
 create table boolspart_f partition of boolspart for values in (false);
+ERROR:  at or near "partition": syntax error
+DETAIL:  source SQL:
+create table boolspart_f partition of boolspart for values in (false)
+                         ^
+HINT:  try \h CREATE TABLE
 \d+ boolspart
-                           Partitioned table "public.boolspart"
- Column |  Type   | Collation | Nullable | Default | Storage | Stats target | Description 
---------+---------+-----------+----------+---------+---------+--------------+-------------
- a      | boolean |           |          |         | plain   |              | 
-Partition key: LIST (a)
-Partitions: boolspart_f FOR VALUES IN (false),
-            boolspart_t FOR VALUES IN (true)
-
+ERROR:  at or near ".": syntax error
+DETAIL:  source SQL:
+SELECT c.oid,
+  n.nspname,
+  c.relname
+FROM pg_catalog.pg_class c
+     LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace
+WHERE c.relname OPERATOR(pg_catalog.~) '^(boolspart)$' COLLATE pg_catalog.default
+                                                                         ^
 drop table boolspart;
+ERROR:  relation "boolspart" does not exist
 -- partitions mixing temporary and permanent relations
 create table perm_parted (a int) partition by list (a);
+ERROR:  at or near "EOF": syntax error
+DETAIL:  source SQL:
+create table perm_parted (a int) partition by list (a)
+                                                      ^
+HINT:  try \h CREATE TABLE
 create temporary table temp_parted (a int) partition by list (a);
+ERROR:  at or near "EOF": syntax error
+DETAIL:  source SQL:
+create temporary table temp_parted (a int) partition by list (a)
+                                                                ^
+HINT:  try \h CREATE TABLE
 create table perm_part partition of temp_parted default; -- error
-ERROR:  cannot create a permanent relation as partition of temporary relation "temp_parted"
+ERROR:  at or near "partition": syntax error
+DETAIL:  source SQL:
+create table perm_part partition of temp_parted default
+                       ^
+HINT:  try \h CREATE TABLE
 create temp table temp_part partition of perm_parted default; -- error
-ERROR:  cannot create a temporary relation as partition of permanent relation "perm_parted"
+ERROR:  at or near "partition": syntax error
+DETAIL:  source SQL:
+create temp table temp_part partition of perm_parted default
+                            ^
+HINT:  try \h CREATE TABLE
 create temp table temp_part partition of temp_parted default; -- ok
+ERROR:  at or near "partition": syntax error
+DETAIL:  source SQL:
+create temp table temp_part partition of temp_parted default
+                            ^
+HINT:  try \h CREATE TABLE
 drop table perm_parted cascade;
+ERROR:  relation "perm_parted" does not exist
 drop table temp_parted cascade;
+ERROR:  relation "temp_parted" does not exist
 -- check that adding partitions to a table while it is being used is prevented
 create table tab_part_create (a int) partition by list (a);
+ERROR:  at or near "EOF": syntax error
+DETAIL:  source SQL:
+create table tab_part_create (a int) partition by list (a)
+                                                          ^
+HINT:  try \h CREATE TABLE
 create or replace function func_part_create() returns trigger
   language plpgsql as $$
   begin
     execute 'create table tab_part_create_1 partition of tab_part_create for values in (1)';
     return null;
   end $$;
+ERROR:  unimplemented: attempted to use a PL/pgSQL statement that is not yet supported
+DETAIL:  stmt_dyn_exec is not yet supported
+HINT:  You have attempted to use a feature that is not yet implemented.
+
+Please check the public issue tracker to check whether this problem is
+already tracked. If you cannot find it there, please report the error
+with details by creating a new issue.
+
+If you would rather not post publicly, please contact us directly
+using the support form.
+
+We appreciate your feedback.
+
 create trigger trig_part_create before insert on tab_part_create
   for each statement execute procedure func_part_create();
+ERROR:  relation "tab_part_create" does not exist
 insert into tab_part_create values (1);
-ERROR:  cannot CREATE TABLE .. PARTITION OF "tab_part_create" because it is being used by active queries in this session
-CONTEXT:  SQL statement "create table tab_part_create_1 partition of tab_part_create for values in (1)"
-PL/pgSQL function func_part_create() line 3 at EXECUTE
+ERROR:  relation "tab_part_create" does not exist
 drop table tab_part_create;
+ERROR:  relation "tab_part_create" does not exist
 drop function func_part_create();
+ERROR:  unknown function: func_part_create()
 -- test using a volatile expression as partition bound
 create table volatile_partbound_test (partkey timestamp) partition by range (partkey);
+ERROR:  at or near "EOF": syntax error
+DETAIL:  source SQL:
+create table volatile_partbound_test (partkey timestamp) partition by range (partkey)
+                                                                                     ^
+HINT:  try \h CREATE TABLE
 create table volatile_partbound_test1 partition of volatile_partbound_test for values from (minvalue) to (current_timestamp);
+ERROR:  at or near "partition": syntax error
+DETAIL:  source SQL:
+create table volatile_partbound_test1 partition of volatile_partbound_test for values from (minvalue) to (current_timestamp)
+                                      ^
+HINT:  try \h CREATE TABLE
 create table volatile_partbound_test2 partition of volatile_partbound_test for values from (current_timestamp) to (maxvalue);
+ERROR:  at or near "partition": syntax error
+DETAIL:  source SQL:
+create table volatile_partbound_test2 partition of volatile_partbound_test for values from (current_timestamp) to (maxvalue)
+                                      ^
+HINT:  try \h CREATE TABLE
 -- this should go into the partition volatile_partbound_test2
 insert into volatile_partbound_test values (current_timestamp);
+ERROR:  relation "volatile_partbound_test" does not exist
 select tableoid::regclass from volatile_partbound_test;
-         tableoid         
---------------------------
- volatile_partbound_test2
-(1 row)
-
+ERROR:  relation "volatile_partbound_test" does not exist
 drop table volatile_partbound_test;
+ERROR:  relation "volatile_partbound_test" does not exist
 -- test the case where a check constraint on default partition allows
 -- to avoid scanning it when adding a new partition
 create table defcheck (a int, b int) partition by list (b);
+ERROR:  at or near "EOF": syntax error
+DETAIL:  source SQL:
+create table defcheck (a int, b int) partition by list (b)
+                                                          ^
+HINT:  try \h CREATE TABLE
 create table defcheck_def (a int, c int, b int);
 alter table defcheck_def drop c;
 alter table defcheck attach partition defcheck_def default;
+ERROR:  at or near "attach": syntax error
+DETAIL:  source SQL:
+alter table defcheck attach partition defcheck_def default
+                     ^
+HINT:  try \h ALTER TABLE
 alter table defcheck_def add check (b <= 0 and b is not null);
 create table defcheck_1 partition of defcheck for values in (1, null);
+ERROR:  at or near "partition": syntax error
+DETAIL:  source SQL:
+create table defcheck_1 partition of defcheck for values in (1, null)
+                        ^
+HINT:  try \h CREATE TABLE
 -- test that complex default partition constraints are enforced correctly
 insert into defcheck_def values (0, 0);
 create table defcheck_0 partition of defcheck for values in (0);
-ERROR:  updated partition constraint for default partition "defcheck_def" would be violated by some row
+ERROR:  at or near "partition": syntax error
+DETAIL:  source SQL:
+create table defcheck_0 partition of defcheck for values in (0)
+                        ^
+HINT:  try \h CREATE TABLE
 drop table defcheck;
+ERROR:  relation "defcheck" does not exist
 -- tests of column drop with partition tables and indexes using
 -- predicates and expressions.
 create table part_column_drop (
@@ -1079,42 +1974,58 @@
   b int,
   useless_3 int
 ) partition by range (id);
+ERROR:  at or near "EOF": syntax error
+DETAIL:  source SQL:
+create table part_column_drop (
+  useless_1 int,
+  id int,
+  useless_2 int,
+  d int,
+  b int,
+  useless_3 int
+) partition by range (id)
+                         ^
+HINT:  try \h CREATE TABLE
 alter table part_column_drop drop column useless_1;
+ERROR:  relation "part_column_drop" does not exist
 alter table part_column_drop drop column useless_2;
+ERROR:  relation "part_column_drop" does not exist
 alter table part_column_drop drop column useless_3;
+ERROR:  relation "part_column_drop" does not exist
 create index part_column_drop_b_pred on part_column_drop(b) where b = 1;
+ERROR:  relation "part_column_drop" does not exist
 create index part_column_drop_b_expr on part_column_drop((b = 1));
+ERROR:  relation "part_column_drop" does not exist
 create index part_column_drop_d_pred on part_column_drop(d) where d = 2;
+ERROR:  relation "part_column_drop" does not exist
 create index part_column_drop_d_expr on part_column_drop((d = 2));
+ERROR:  relation "part_column_drop" does not exist
 create table part_column_drop_1_10 partition of
   part_column_drop for values from (1) to (10);
+ERROR:  at or near "partition": syntax error
+DETAIL:  source SQL:
+create table part_column_drop_1_10 partition of
+                                   ^
+HINT:  try \h CREATE TABLE
 \d part_column_drop
-    Partitioned table "public.part_column_drop"
- Column |  Type   | Collation | Nullable | Default 
---------+---------+-----------+----------+---------
- id     | integer |           |          | 
- d      | integer |           |          | 
- b      | integer |           |          | 
-Partition key: RANGE (id)
-Indexes:
-    "part_column_drop_b_expr" btree ((b = 1))
-    "part_column_drop_b_pred" btree (b) WHERE b = 1
-    "part_column_drop_d_expr" btree ((d = 2))
-    "part_column_drop_d_pred" btree (d) WHERE d = 2
-Number of partitions: 1 (Use \d+ to list them.)
-
+ERROR:  at or near ".": syntax error
+DETAIL:  source SQL:
+SELECT c.oid,
+  n.nspname,
+  c.relname
+FROM pg_catalog.pg_class c
+     LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace
+WHERE c.relname OPERATOR(pg_catalog.~) '^(part_column_drop)$' COLLATE pg_catalog.default
+                                                                                ^
 \d part_column_drop_1_10
-       Table "public.part_column_drop_1_10"
- Column |  Type   | Collation | Nullable | Default 
---------+---------+-----------+----------+---------
- id     | integer |           |          | 
- d      | integer |           |          | 
- b      | integer |           |          | 
-Partition of: part_column_drop FOR VALUES FROM (1) TO (10)
-Indexes:
-    "part_column_drop_1_10_b_idx" btree (b) WHERE b = 1
-    "part_column_drop_1_10_d_idx" btree (d) WHERE d = 2
-    "part_column_drop_1_10_expr_idx" btree ((b = 1))
-    "part_column_drop_1_10_expr_idx1" btree ((d = 2))
-
+ERROR:  at or near ".": syntax error
+DETAIL:  source SQL:
+SELECT c.oid,
+  n.nspname,
+  c.relname
+FROM pg_catalog.pg_class c
+     LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace
+WHERE c.relname OPERATOR(pg_catalog.~) '^(part_column_drop_1_10)$' COLLATE pg_catalog.default
+                                                                                     ^
 drop table part_column_drop;
+ERROR:  relation "part_column_drop" does not exist
