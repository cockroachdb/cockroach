diff -U3 --label=/mnt/data1/postgres/src/test/regress/expected/create_index.out --label=/mnt/data1/postgres/src/test/regress/results/create_index.out /mnt/data1/postgres/src/test/regress/expected/create_index.out /mnt/data1/postgres/src/test/regress/results/create_index.out
--- /mnt/data1/postgres/src/test/regress/expected/create_index.out
+++ /mnt/data1/postgres/src/test/regress/results/create_index.out
@@ -4,646 +4,637 @@
 --
 -- directory paths are passed to us in environment variables
 \getenv abs_srcdir PG_ABS_SRCDIR
+invalid command \getenv
 --
 -- BTREE
 --
 CREATE INDEX onek_unique1 ON onek USING btree(unique1 int4_ops);
+ERROR:  operator classes are only allowed for the last column of an inverted index
 CREATE INDEX IF NOT EXISTS onek_unique1 ON onek USING btree(unique1 int4_ops);
-NOTICE:  relation "onek_unique1" already exists, skipping
+ERROR:  operator classes are only allowed for the last column of an inverted index
 CREATE INDEX IF NOT EXISTS ON onek USING btree(unique1 int4_ops);
-ERROR:  syntax error at or near "ON"
-LINE 1: CREATE INDEX IF NOT EXISTS ON onek USING btree(unique1 int4_...
-                                   ^
+ERROR:  at or near "onek": syntax error
+DETAIL:  source SQL:
+CREATE INDEX IF NOT EXISTS ON onek USING btree(unique1 int4_ops)
+                              ^
+HINT:  try \h CREATE INDEX
 CREATE INDEX onek_unique2 ON onek USING btree(unique2 int4_ops);
+ERROR:  operator classes are only allowed for the last column of an inverted index
 CREATE INDEX onek_hundred ON onek USING btree(hundred int4_ops);
+ERROR:  operator classes are only allowed for the last column of an inverted index
 CREATE INDEX onek_stringu1 ON onek USING btree(stringu1 name_ops);
+ERROR:  operator classes are only allowed for the last column of an inverted index
 CREATE INDEX tenk1_unique1 ON tenk1 USING btree(unique1 int4_ops);
+ERROR:  operator classes are only allowed for the last column of an inverted index
 CREATE INDEX tenk1_unique2 ON tenk1 USING btree(unique2 int4_ops);
+ERROR:  operator classes are only allowed for the last column of an inverted index
 CREATE INDEX tenk1_hundred ON tenk1 USING btree(hundred int4_ops);
+ERROR:  operator classes are only allowed for the last column of an inverted index
 CREATE INDEX tenk1_thous_tenthous ON tenk1 (thousand, tenthous);
 CREATE INDEX tenk2_unique1 ON tenk2 USING btree(unique1 int4_ops);
+ERROR:  operator classes are only allowed for the last column of an inverted index
 CREATE INDEX tenk2_unique2 ON tenk2 USING btree(unique2 int4_ops);
+ERROR:  operator classes are only allowed for the last column of an inverted index
 CREATE INDEX tenk2_hundred ON tenk2 USING btree(hundred int4_ops);
+ERROR:  operator classes are only allowed for the last column of an inverted index
 CREATE INDEX rix ON road USING btree (name text_ops);
+ERROR:  relation "road" does not exist
 CREATE INDEX iix ON ihighway USING btree (name text_ops);
+ERROR:  relation "ihighway" does not exist
 CREATE INDEX six ON shighway USING btree (name text_ops);
+ERROR:  relation "shighway" does not exist
 -- test comments
 COMMENT ON INDEX six_wrong IS 'bad index';
-ERROR:  relation "six_wrong" does not exist
+ERROR:  index "six_wrong" does not exist
 COMMENT ON INDEX six IS 'good index';
+ERROR:  index "six" does not exist
 COMMENT ON INDEX six IS NULL;
+ERROR:  index "six" does not exist
 --
 -- BTREE partial indices
 --
 CREATE INDEX onek2_u1_prtl ON onek2 USING btree(unique1 int4_ops)
 	where unique1 < 20 or unique1 > 980;
+ERROR:  operator classes are only allowed for the last column of an inverted index
 CREATE INDEX onek2_u2_prtl ON onek2 USING btree(unique2 int4_ops)
 	where stringu1 < 'B';
+ERROR:  operator classes are only allowed for the last column of an inverted index
 CREATE INDEX onek2_stu1_prtl ON onek2 USING btree(stringu1 name_ops)
 	where onek2.stringu1 >= 'J' and onek2.stringu1 < 'K';
+ERROR:  operator classes are only allowed for the last column of an inverted index
 --
 -- GiST (rtree-equivalent opclasses only)
 --
 CREATE TABLE slow_emp4000 (
 	home_base	 box
 );
+ERROR:  at or near ")": syntax error: unimplemented: this syntax
+DETAIL:  source SQL:
+CREATE TABLE slow_emp4000 (
+	home_base	 box
+)
+^
+HINT:  You have attempted to use a feature that is not yet implemented.
+See: https://go.crdb.dev/issue-v/21286/_version_
 CREATE TABLE fast_emp4000 (
 	home_base	 box
 );
+ERROR:  at or near ")": syntax error: unimplemented: this syntax
+DETAIL:  source SQL:
+CREATE TABLE fast_emp4000 (
+	home_base	 box
+)
+^
+HINT:  You have attempted to use a feature that is not yet implemented.
+See: https://go.crdb.dev/issue-v/21286/_version_
 \set filename :abs_srcdir '/data/rect.data'
 COPY slow_emp4000 FROM :'filename';
+ERROR:  at or near ":abs_srcdir/data/rect.data": syntax error: unimplemented: this syntax
+DETAIL:  source SQL:
+COPY slow_emp4000 FROM ':abs_srcdir/data/rect.data'
+                       ^
+HINT:  You have attempted to use a feature that is not yet implemented.
+
+Please check the public issue tracker to check whether this problem is
+already tracked. If you cannot find it there, please report the error
+with details by creating a new issue.
+
+If you would rather not post publicly, please contact us directly
+using the support form.
+
+We appreciate your feedback.
+
 INSERT INTO fast_emp4000 SELECT * FROM slow_emp4000;
+ERROR:  relation "fast_emp4000" does not exist
 ANALYZE slow_emp4000;
+ERROR:  relation "slow_emp4000" does not exist
 ANALYZE fast_emp4000;
+ERROR:  relation "fast_emp4000" does not exist
 CREATE INDEX grect2ind ON fast_emp4000 USING gist (home_base);
+ERROR:  relation "fast_emp4000" does not exist
 -- we want to work with a point_tbl that includes a null
 CREATE TEMP TABLE point_tbl AS SELECT * FROM public.point_tbl;
+ERROR:  relation "public.point_tbl" does not exist
 INSERT INTO POINT_TBL(f1) VALUES (NULL);
+ERROR:  relation "point_tbl" does not exist
 CREATE INDEX gpointind ON point_tbl USING gist (f1);
+ERROR:  relation "point_tbl" does not exist
 CREATE TEMP TABLE gpolygon_tbl AS
     SELECT polygon(home_base) AS f1 FROM slow_emp4000;
+ERROR:  at or near "(": syntax error
+DETAIL:  source SQL:
+CREATE TEMP TABLE gpolygon_tbl AS
+    SELECT polygon(home_base) AS f1 FROM slow_emp4000
+                  ^
 INSERT INTO gpolygon_tbl VALUES ( '(1000,0,0,1000)' );
+ERROR:  relation "gpolygon_tbl" does not exist
 INSERT INTO gpolygon_tbl VALUES ( '(0,1000,1000,1000)' );
+ERROR:  relation "gpolygon_tbl" does not exist
 CREATE TEMP TABLE gcircle_tbl AS
     SELECT circle(home_base) AS f1 FROM slow_emp4000;
+ERROR:  relation "slow_emp4000" does not exist
 CREATE INDEX ggpolygonind ON gpolygon_tbl USING gist (f1);
+ERROR:  relation "gpolygon_tbl" does not exist
 CREATE INDEX ggcircleind ON gcircle_tbl USING gist (f1);
+ERROR:  relation "gcircle_tbl" does not exist
 --
 -- Test GiST indexes
 --
 -- get non-indexed results for comparison purposes
 SET enable_seqscan = ON;
+WARNING:  setting session var "enable_seqscan" is a no-op
 SET enable_indexscan = OFF;
+ERROR:  unimplemented: the configuration setting "enable_indexscan" is not supported
+HINT:  You have attempted to use a feature that is not yet implemented.
+
+Please check the public issue tracker to check whether this problem is
+already tracked. If you cannot find it there, please report the error
+with details by creating a new issue.
+
+If you would rather not post publicly, please contact us directly
+using the support form.
+
+We appreciate your feedback.
+
 SET enable_bitmapscan = OFF;
+ERROR:  unimplemented: the configuration setting "enable_bitmapscan" is not supported
+HINT:  You have attempted to use a feature that is not yet implemented.
+
+Please check the public issue tracker to check whether this problem is
+already tracked. If you cannot find it there, please report the error
+with details by creating a new issue.
+
+If you would rather not post publicly, please contact us directly
+using the support form.
+
+We appreciate your feedback.
+
 SELECT * FROM fast_emp4000
     WHERE home_base <@ '(200,200),(2000,1000)'::box
     ORDER BY (home_base[0])[0];
-       home_base       
------------------------
- (337,455),(240,359)
- (1444,403),(1346,344)
-(2 rows)
-
+ERROR:  at or near "order": syntax error: unimplemented: this syntax
+DETAIL:  source SQL:
+SELECT * FROM fast_emp4000
+    WHERE home_base <@ '(200,200),(2000,1000)'::box
+    ORDER BY (home_base[0])[0]
+    ^
+HINT:  You have attempted to use a feature that is not yet implemented.
+See: https://go.crdb.dev/issue-v/21286/_version_
 SELECT count(*) FROM fast_emp4000 WHERE home_base && '(1000,1000,0,0)'::box;
- count 
--------
-     2
-(1 row)
-
+ERROR:  at or near "EOF": syntax error: unimplemented: this syntax
+DETAIL:  source SQL:
+SELECT count(*) FROM fast_emp4000 WHERE home_base && '(1000,1000,0,0)'::box
+                                                                           ^
+HINT:  You have attempted to use a feature that is not yet implemented.
+See: https://go.crdb.dev/issue-v/21286/_version_
 SELECT count(*) FROM fast_emp4000 WHERE home_base IS NULL;
- count 
--------
-   278
-(1 row)
-
+ERROR:  relation "fast_emp4000" does not exist
 SELECT count(*) FROM gpolygon_tbl WHERE f1 && '(1000,1000,0,0)'::polygon;
- count 
--------
-     2
-(1 row)
-
+ERROR:  at or near "EOF": syntax error: unimplemented: this syntax
+DETAIL:  source SQL:
+SELECT count(*) FROM gpolygon_tbl WHERE f1 && '(1000,1000,0,0)'::polygon
+                                                                        ^
+HINT:  You have attempted to use a feature that is not yet implemented.
+See: https://go.crdb.dev/issue-v/21286/_version_
 SELECT count(*) FROM gcircle_tbl WHERE f1 && '<(500,500),500>'::circle;
- count 
--------
-     2
-(1 row)
-
+ERROR:  at or near "EOF": syntax error: unimplemented: this syntax
+DETAIL:  source SQL:
+SELECT count(*) FROM gcircle_tbl WHERE f1 && '<(500,500),500>'::circle
+                                                                      ^
+HINT:  You have attempted to use a feature that is not yet implemented.
+See: https://go.crdb.dev/issue-v/21286/_version_
 SELECT count(*) FROM point_tbl WHERE f1 <@ box '(0,0,100,100)';
- count 
--------
-     3
-(1 row)
-
+ERROR:  at or near "(0,0,100,100)": syntax error: unimplemented: this syntax
+DETAIL:  source SQL:
+SELECT count(*) FROM point_tbl WHERE f1 <@ box '(0,0,100,100)'
+                                               ^
+HINT:  You have attempted to use a feature that is not yet implemented.
+See: https://go.crdb.dev/issue-v/21286/_version_
 SELECT count(*) FROM point_tbl WHERE box '(0,0,100,100)' @> f1;
- count 
--------
-     3
-(1 row)
-
+ERROR:  at or near "(0,0,100,100)": syntax error: unimplemented: this syntax
+DETAIL:  source SQL:
+SELECT count(*) FROM point_tbl WHERE box '(0,0,100,100)' @> f1
+                                         ^
+HINT:  You have attempted to use a feature that is not yet implemented.
+See: https://go.crdb.dev/issue-v/21286/_version_
 SELECT count(*) FROM point_tbl WHERE f1 <@ polygon '(0,0),(0,100),(100,100),(50,50),(100,0),(0,0)';
- count 
--------
-     5
-(1 row)
-
+ERROR:  at or near "(0,0),(0,100),(100,100),(50,50),(100,0),(0,0)": syntax error
+DETAIL:  source SQL:
+SELECT count(*) FROM point_tbl WHERE f1 <@ polygon '(0,0),(0,100),(100,100),(50,50),(100,0),(0,0)'
+                                                   ^
 SELECT count(*) FROM point_tbl WHERE f1 <@ circle '<(50,50),50>';
- count 
--------
-     1
-(1 row)
-
+ERROR:  at or near "<(50,50),50>": syntax error: unimplemented: this syntax
+DETAIL:  source SQL:
+SELECT count(*) FROM point_tbl WHERE f1 <@ circle '<(50,50),50>'
+                                                  ^
+HINT:  You have attempted to use a feature that is not yet implemented.
+See: https://go.crdb.dev/issue-v/21286/_version_
 SELECT count(*) FROM point_tbl p WHERE p.f1 << '(0.0, 0.0)';
- count 
--------
-     3
-(1 row)
-
+ERROR:  relation "point_tbl" does not exist
 SELECT count(*) FROM point_tbl p WHERE p.f1 >> '(0.0, 0.0)';
- count 
--------
-     4
-(1 row)
-
+ERROR:  relation "point_tbl" does not exist
 SELECT count(*) FROM point_tbl p WHERE p.f1 <<| '(0.0, 0.0)';
- count 
--------
-     1
-(1 row)
-
+ERROR:  at or near "|": syntax error
+DETAIL:  source SQL:
+SELECT count(*) FROM point_tbl p WHERE p.f1 <<| '(0.0, 0.0)'
+                                              ^
 SELECT count(*) FROM point_tbl p WHERE p.f1 |>> '(0.0, 0.0)';
- count 
--------
-     5
-(1 row)
-
+ERROR:  at or near ">": syntax error
+DETAIL:  source SQL:
+SELECT count(*) FROM point_tbl p WHERE p.f1 |>> '(0.0, 0.0)'
+                                             ^
 SELECT count(*) FROM point_tbl p WHERE p.f1 ~= '(-5, -12)';
- count 
--------
-     1
-(1 row)
-
+ERROR:  at or near "=": syntax error
+DETAIL:  source SQL:
+SELECT count(*) FROM point_tbl p WHERE p.f1 ~= '(-5, -12)'
+                                             ^
 SELECT * FROM point_tbl ORDER BY f1 <-> '0,1';
-        f1         
--------------------
- (0,0)
- (1e-300,-1e-300)
- (-3,4)
- (-10,0)
- (10,10)
- (-5,-12)
- (5.1,34.5)
- (Infinity,1e+300)
- (1e+300,Infinity)
- (NaN,NaN)
- 
-(11 rows)
-
+ERROR:  relation "point_tbl" does not exist
 SELECT * FROM point_tbl WHERE f1 IS NULL;
- f1 
-----
- 
-(1 row)
-
+ERROR:  relation "point_tbl" does not exist
 SELECT * FROM point_tbl WHERE f1 IS NOT NULL ORDER BY f1 <-> '0,1';
-        f1         
--------------------
- (0,0)
- (1e-300,-1e-300)
- (-3,4)
- (-10,0)
- (10,10)
- (-5,-12)
- (5.1,34.5)
- (1e+300,Infinity)
- (Infinity,1e+300)
- (NaN,NaN)
-(10 rows)
-
+ERROR:  relation "point_tbl" does not exist
 SELECT * FROM point_tbl WHERE f1 <@ '(-10,-10),(10,10)':: box ORDER BY f1 <-> '0,1';
-        f1        
-------------------
- (0,0)
- (1e-300,-1e-300)
- (-3,4)
- (-10,0)
- (10,10)
-(5 rows)
-
+ERROR:  at or near "order": syntax error: unimplemented: this syntax
+DETAIL:  source SQL:
+SELECT * FROM point_tbl WHERE f1 <@ '(-10,-10),(10,10)':: box ORDER BY f1 <-> '0,1'
+                                                              ^
+HINT:  You have attempted to use a feature that is not yet implemented.
+See: https://go.crdb.dev/issue-v/21286/_version_
 SELECT * FROM gpolygon_tbl ORDER BY f1 <-> '(0,0)'::point LIMIT 10;
-                       f1                        
--------------------------------------------------
- ((240,359),(240,455),(337,455),(337,359))
- ((662,163),(662,187),(759,187),(759,163))
- ((1000,0),(0,1000))
- ((0,1000),(1000,1000))
- ((1346,344),(1346,403),(1444,403),(1444,344))
- ((278,1409),(278,1457),(369,1457),(369,1409))
- ((907,1156),(907,1201),(948,1201),(948,1156))
- ((1517,971),(1517,1043),(1594,1043),(1594,971))
- ((175,1820),(175,1850),(259,1850),(259,1820))
- ((2424,81),(2424,160),(2424,160),(2424,81))
-(10 rows)
-
+ERROR:  at or near "limit": syntax error: unimplemented: this syntax
+DETAIL:  source SQL:
+SELECT * FROM gpolygon_tbl ORDER BY f1 <-> '(0,0)'::point LIMIT 10
+                                                          ^
+HINT:  You have attempted to use a feature that is not yet implemented.
+See: https://go.crdb.dev/issue-v/21286/_version_
 SELECT circle_center(f1), round(radius(f1)) as radius FROM gcircle_tbl ORDER BY f1 <-> '(200,300)'::point LIMIT 10;
- circle_center  | radius 
-----------------+--------
- (288.5,407)    |     68
- (710.5,175)    |     50
- (323.5,1433)   |     51
- (927.5,1178.5) |     30
- (1395,373.5)   |     57
- (1555.5,1007)  |     53
- (217,1835)     |     45
- (489,2421.5)   |     22
- (2424,120.5)   |     40
- (751.5,2655)   |     20
-(10 rows)
-
+ERROR:  at or near "limit": syntax error: unimplemented: this syntax
+DETAIL:  source SQL:
+SELECT circle_center(f1), round(radius(f1)) as radius FROM gcircle_tbl ORDER BY f1 <-> '(200,300)'::point LIMIT 10
+                                                                                                          ^
+HINT:  You have attempted to use a feature that is not yet implemented.
+See: https://go.crdb.dev/issue-v/21286/_version_
 -- Now check the results from plain indexscan
 SET enable_seqscan = OFF;
+WARNING:  setting session var "enable_seqscan" is a no-op
 SET enable_indexscan = ON;
+ERROR:  unimplemented: the configuration setting "enable_indexscan" is not supported
+HINT:  You have attempted to use a feature that is not yet implemented.
+
+Please check the public issue tracker to check whether this problem is
+already tracked. If you cannot find it there, please report the error
+with details by creating a new issue.
+
+If you would rather not post publicly, please contact us directly
+using the support form.
+
+We appreciate your feedback.
+
 SET enable_bitmapscan = OFF;
+ERROR:  unimplemented: the configuration setting "enable_bitmapscan" is not supported
+HINT:  You have attempted to use a feature that is not yet implemented.
+
+Please check the public issue tracker to check whether this problem is
+already tracked. If you cannot find it there, please report the error
+with details by creating a new issue.
+
+If you would rather not post publicly, please contact us directly
+using the support form.
+
+We appreciate your feedback.
+
 EXPLAIN (COSTS OFF)
 SELECT * FROM fast_emp4000
     WHERE home_base <@ '(200,200),(2000,1000)'::box
     ORDER BY (home_base[0])[0];
-                           QUERY PLAN                            
------------------------------------------------------------------
- Sort
-   Sort Key: ((home_base[0])[0])
-   ->  Index Only Scan using grect2ind on fast_emp4000
-         Index Cond: (home_base <@ '(2000,1000),(200,200)'::box)
-(4 rows)
-
+ERROR:  at or near "off": syntax error
+DETAIL:  source SQL:
+EXPLAIN (COSTS OFF)
+               ^
+HINT:  try \h <SELECTCLAUSE>
 SELECT * FROM fast_emp4000
     WHERE home_base <@ '(200,200),(2000,1000)'::box
     ORDER BY (home_base[0])[0];
-       home_base       
------------------------
- (337,455),(240,359)
- (1444,403),(1346,344)
-(2 rows)
-
+ERROR:  at or near "order": syntax error: unimplemented: this syntax
+DETAIL:  source SQL:
+SELECT * FROM fast_emp4000
+    WHERE home_base <@ '(200,200),(2000,1000)'::box
+    ORDER BY (home_base[0])[0]
+    ^
+HINT:  You have attempted to use a feature that is not yet implemented.
+See: https://go.crdb.dev/issue-v/21286/_version_
 EXPLAIN (COSTS OFF)
 SELECT count(*) FROM fast_emp4000 WHERE home_base && '(1000,1000,0,0)'::box;
-                         QUERY PLAN                          
--------------------------------------------------------------
- Aggregate
-   ->  Index Only Scan using grect2ind on fast_emp4000
-         Index Cond: (home_base && '(1000,1000),(0,0)'::box)
-(3 rows)
-
+ERROR:  at or near "off": syntax error
+DETAIL:  source SQL:
+EXPLAIN (COSTS OFF)
+               ^
+HINT:  try \h <SELECTCLAUSE>
 SELECT count(*) FROM fast_emp4000 WHERE home_base && '(1000,1000,0,0)'::box;
- count 
--------
-     2
-(1 row)
-
+ERROR:  at or near "EOF": syntax error: unimplemented: this syntax
+DETAIL:  source SQL:
+SELECT count(*) FROM fast_emp4000 WHERE home_base && '(1000,1000,0,0)'::box
+                                                                           ^
+HINT:  You have attempted to use a feature that is not yet implemented.
+See: https://go.crdb.dev/issue-v/21286/_version_
 EXPLAIN (COSTS OFF)
 SELECT count(*) FROM fast_emp4000 WHERE home_base IS NULL;
-                      QUERY PLAN                       
--------------------------------------------------------
- Aggregate
-   ->  Index Only Scan using grect2ind on fast_emp4000
-         Index Cond: (home_base IS NULL)
-(3 rows)
-
+ERROR:  at or near "off": syntax error
+DETAIL:  source SQL:
+EXPLAIN (COSTS OFF)
+               ^
+HINT:  try \h <SELECTCLAUSE>
 SELECT count(*) FROM fast_emp4000 WHERE home_base IS NULL;
- count 
--------
-   278
-(1 row)
-
+ERROR:  relation "fast_emp4000" does not exist
 EXPLAIN (COSTS OFF)
 SELECT count(*) FROM gpolygon_tbl WHERE f1 && '(1000,1000,0,0)'::polygon;
-                         QUERY PLAN                         
-------------------------------------------------------------
- Aggregate
-   ->  Index Scan using ggpolygonind on gpolygon_tbl
-         Index Cond: (f1 && '((1000,1000),(0,0))'::polygon)
-(3 rows)
-
+ERROR:  at or near "off": syntax error
+DETAIL:  source SQL:
+EXPLAIN (COSTS OFF)
+               ^
+HINT:  try \h <SELECTCLAUSE>
 SELECT count(*) FROM gpolygon_tbl WHERE f1 && '(1000,1000,0,0)'::polygon;
- count 
--------
-     2
-(1 row)
-
+ERROR:  at or near "EOF": syntax error: unimplemented: this syntax
+DETAIL:  source SQL:
+SELECT count(*) FROM gpolygon_tbl WHERE f1 && '(1000,1000,0,0)'::polygon
+                                                                        ^
+HINT:  You have attempted to use a feature that is not yet implemented.
+See: https://go.crdb.dev/issue-v/21286/_version_
 EXPLAIN (COSTS OFF)
 SELECT count(*) FROM gcircle_tbl WHERE f1 && '<(500,500),500>'::circle;
-                      QUERY PLAN                       
--------------------------------------------------------
- Aggregate
-   ->  Index Scan using ggcircleind on gcircle_tbl
-         Index Cond: (f1 && '<(500,500),500>'::circle)
-(3 rows)
-
+ERROR:  at or near "off": syntax error
+DETAIL:  source SQL:
+EXPLAIN (COSTS OFF)
+               ^
+HINT:  try \h <SELECTCLAUSE>
 SELECT count(*) FROM gcircle_tbl WHERE f1 && '<(500,500),500>'::circle;
- count 
--------
-     2
-(1 row)
-
+ERROR:  at or near "EOF": syntax error: unimplemented: this syntax
+DETAIL:  source SQL:
+SELECT count(*) FROM gcircle_tbl WHERE f1 && '<(500,500),500>'::circle
+                                                                      ^
+HINT:  You have attempted to use a feature that is not yet implemented.
+See: https://go.crdb.dev/issue-v/21286/_version_
 EXPLAIN (COSTS OFF)
 SELECT count(*) FROM point_tbl WHERE f1 <@ box '(0,0,100,100)';
-                     QUERY PLAN                     
-----------------------------------------------------
- Aggregate
-   ->  Index Only Scan using gpointind on point_tbl
-         Index Cond: (f1 <@ '(100,100),(0,0)'::box)
-(3 rows)
-
+ERROR:  at or near "off": syntax error
+DETAIL:  source SQL:
+EXPLAIN (COSTS OFF)
+               ^
+HINT:  try \h <SELECTCLAUSE>
 SELECT count(*) FROM point_tbl WHERE f1 <@ box '(0,0,100,100)';
- count 
--------
-     3
-(1 row)
-
+ERROR:  at or near "(0,0,100,100)": syntax error: unimplemented: this syntax
+DETAIL:  source SQL:
+SELECT count(*) FROM point_tbl WHERE f1 <@ box '(0,0,100,100)'
+                                               ^
+HINT:  You have attempted to use a feature that is not yet implemented.
+See: https://go.crdb.dev/issue-v/21286/_version_
 EXPLAIN (COSTS OFF)
 SELECT count(*) FROM point_tbl WHERE box '(0,0,100,100)' @> f1;
-                     QUERY PLAN                     
-----------------------------------------------------
- Aggregate
-   ->  Index Only Scan using gpointind on point_tbl
-         Index Cond: (f1 <@ '(100,100),(0,0)'::box)
-(3 rows)
-
+ERROR:  at or near "off": syntax error
+DETAIL:  source SQL:
+EXPLAIN (COSTS OFF)
+               ^
+HINT:  try \h <SELECTCLAUSE>
 SELECT count(*) FROM point_tbl WHERE box '(0,0,100,100)' @> f1;
- count 
--------
-     3
-(1 row)
-
+ERROR:  at or near "(0,0,100,100)": syntax error: unimplemented: this syntax
+DETAIL:  source SQL:
+SELECT count(*) FROM point_tbl WHERE box '(0,0,100,100)' @> f1
+                                         ^
+HINT:  You have attempted to use a feature that is not yet implemented.
+See: https://go.crdb.dev/issue-v/21286/_version_
 EXPLAIN (COSTS OFF)
 SELECT count(*) FROM point_tbl WHERE f1 <@ polygon '(0,0),(0,100),(100,100),(50,50),(100,0),(0,0)';
-                                       QUERY PLAN                                       
-----------------------------------------------------------------------------------------
- Aggregate
-   ->  Index Only Scan using gpointind on point_tbl
-         Index Cond: (f1 <@ '((0,0),(0,100),(100,100),(50,50),(100,0),(0,0))'::polygon)
-(3 rows)
-
+ERROR:  at or near "off": syntax error
+DETAIL:  source SQL:
+EXPLAIN (COSTS OFF)
+               ^
+HINT:  try \h <SELECTCLAUSE>
 SELECT count(*) FROM point_tbl WHERE f1 <@ polygon '(0,0),(0,100),(100,100),(50,50),(100,0),(0,0)';
- count 
--------
-     4
-(1 row)
-
+ERROR:  at or near "(0,0),(0,100),(100,100),(50,50),(100,0),(0,0)": syntax error
+DETAIL:  source SQL:
+SELECT count(*) FROM point_tbl WHERE f1 <@ polygon '(0,0),(0,100),(100,100),(50,50),(100,0),(0,0)'
+                                                   ^
 EXPLAIN (COSTS OFF)
 SELECT count(*) FROM point_tbl WHERE f1 <@ circle '<(50,50),50>';
-                     QUERY PLAN                     
-----------------------------------------------------
- Aggregate
-   ->  Index Only Scan using gpointind on point_tbl
-         Index Cond: (f1 <@ '<(50,50),50>'::circle)
-(3 rows)
-
+ERROR:  at or near "off": syntax error
+DETAIL:  source SQL:
+EXPLAIN (COSTS OFF)
+               ^
+HINT:  try \h <SELECTCLAUSE>
 SELECT count(*) FROM point_tbl WHERE f1 <@ circle '<(50,50),50>';
- count 
--------
-     1
-(1 row)
-
+ERROR:  at or near "<(50,50),50>": syntax error: unimplemented: this syntax
+DETAIL:  source SQL:
+SELECT count(*) FROM point_tbl WHERE f1 <@ circle '<(50,50),50>'
+                                                  ^
+HINT:  You have attempted to use a feature that is not yet implemented.
+See: https://go.crdb.dev/issue-v/21286/_version_
 EXPLAIN (COSTS OFF)
 SELECT count(*) FROM point_tbl p WHERE p.f1 << '(0.0, 0.0)';
-                      QUERY PLAN                      
-------------------------------------------------------
- Aggregate
-   ->  Index Only Scan using gpointind on point_tbl p
-         Index Cond: (f1 << '(0,0)'::point)
-(3 rows)
-
+ERROR:  at or near "off": syntax error
+DETAIL:  source SQL:
+EXPLAIN (COSTS OFF)
+               ^
+HINT:  try \h <SELECTCLAUSE>
 SELECT count(*) FROM point_tbl p WHERE p.f1 << '(0.0, 0.0)';
- count 
--------
-     3
-(1 row)
-
+ERROR:  relation "point_tbl" does not exist
 EXPLAIN (COSTS OFF)
 SELECT count(*) FROM point_tbl p WHERE p.f1 >> '(0.0, 0.0)';
-                      QUERY PLAN                      
-------------------------------------------------------
- Aggregate
-   ->  Index Only Scan using gpointind on point_tbl p
-         Index Cond: (f1 >> '(0,0)'::point)
-(3 rows)
-
+ERROR:  at or near "off": syntax error
+DETAIL:  source SQL:
+EXPLAIN (COSTS OFF)
+               ^
+HINT:  try \h <SELECTCLAUSE>
 SELECT count(*) FROM point_tbl p WHERE p.f1 >> '(0.0, 0.0)';
- count 
--------
-     4
-(1 row)
-
+ERROR:  relation "point_tbl" does not exist
 EXPLAIN (COSTS OFF)
 SELECT count(*) FROM point_tbl p WHERE p.f1 <<| '(0.0, 0.0)';
-                      QUERY PLAN                      
-------------------------------------------------------
- Aggregate
-   ->  Index Only Scan using gpointind on point_tbl p
-         Index Cond: (f1 <<| '(0,0)'::point)
-(3 rows)
-
+ERROR:  at or near "off": syntax error
+DETAIL:  source SQL:
+EXPLAIN (COSTS OFF)
+               ^
+HINT:  try \h <SELECTCLAUSE>
 SELECT count(*) FROM point_tbl p WHERE p.f1 <<| '(0.0, 0.0)';
- count 
--------
-     1
-(1 row)
-
+ERROR:  at or near "|": syntax error
+DETAIL:  source SQL:
+SELECT count(*) FROM point_tbl p WHERE p.f1 <<| '(0.0, 0.0)'
+                                              ^
 EXPLAIN (COSTS OFF)
 SELECT count(*) FROM point_tbl p WHERE p.f1 |>> '(0.0, 0.0)';
-                      QUERY PLAN                      
-------------------------------------------------------
- Aggregate
-   ->  Index Only Scan using gpointind on point_tbl p
-         Index Cond: (f1 |>> '(0,0)'::point)
-(3 rows)
-
+ERROR:  at or near "off": syntax error
+DETAIL:  source SQL:
+EXPLAIN (COSTS OFF)
+               ^
+HINT:  try \h <SELECTCLAUSE>
 SELECT count(*) FROM point_tbl p WHERE p.f1 |>> '(0.0, 0.0)';
- count 
--------
-     5
-(1 row)
-
+ERROR:  at or near ">": syntax error
+DETAIL:  source SQL:
+SELECT count(*) FROM point_tbl p WHERE p.f1 |>> '(0.0, 0.0)'
+                                             ^
 EXPLAIN (COSTS OFF)
 SELECT count(*) FROM point_tbl p WHERE p.f1 ~= '(-5, -12)';
-                      QUERY PLAN                      
-------------------------------------------------------
- Aggregate
-   ->  Index Only Scan using gpointind on point_tbl p
-         Index Cond: (f1 ~= '(-5,-12)'::point)
-(3 rows)
-
+ERROR:  at or near "off": syntax error
+DETAIL:  source SQL:
+EXPLAIN (COSTS OFF)
+               ^
+HINT:  try \h <SELECTCLAUSE>
 SELECT count(*) FROM point_tbl p WHERE p.f1 ~= '(-5, -12)';
- count 
--------
-     1
-(1 row)
-
+ERROR:  at or near "=": syntax error
+DETAIL:  source SQL:
+SELECT count(*) FROM point_tbl p WHERE p.f1 ~= '(-5, -12)'
+                                             ^
 EXPLAIN (COSTS OFF)
 SELECT * FROM point_tbl ORDER BY f1 <-> '0,1';
-                  QUERY PLAN                  
-----------------------------------------------
- Index Only Scan using gpointind on point_tbl
-   Order By: (f1 <-> '(0,1)'::point)
-(2 rows)
-
+ERROR:  at or near "off": syntax error
+DETAIL:  source SQL:
+EXPLAIN (COSTS OFF)
+               ^
+HINT:  try \h <SELECTCLAUSE>
 SELECT * FROM point_tbl ORDER BY f1 <-> '0,1';
-        f1         
--------------------
- (1e-300,-1e-300)
- (0,0)
- (-3,4)
- (-10,0)
- (10,10)
- (-5,-12)
- (5.1,34.5)
- (Infinity,1e+300)
- (1e+300,Infinity)
- (NaN,NaN)
- 
-(11 rows)
-
+ERROR:  relation "point_tbl" does not exist
 EXPLAIN (COSTS OFF)
 SELECT * FROM point_tbl WHERE f1 IS NULL;
-                  QUERY PLAN                  
-----------------------------------------------
- Index Only Scan using gpointind on point_tbl
-   Index Cond: (f1 IS NULL)
-(2 rows)
-
+ERROR:  at or near "off": syntax error
+DETAIL:  source SQL:
+EXPLAIN (COSTS OFF)
+               ^
+HINT:  try \h <SELECTCLAUSE>
 SELECT * FROM point_tbl WHERE f1 IS NULL;
- f1 
-----
- 
-(1 row)
-
+ERROR:  relation "point_tbl" does not exist
 EXPLAIN (COSTS OFF)
 SELECT * FROM point_tbl WHERE f1 IS NOT NULL ORDER BY f1 <-> '0,1';
-                  QUERY PLAN                  
-----------------------------------------------
- Index Only Scan using gpointind on point_tbl
-   Index Cond: (f1 IS NOT NULL)
-   Order By: (f1 <-> '(0,1)'::point)
-(3 rows)
-
+ERROR:  at or near "off": syntax error
+DETAIL:  source SQL:
+EXPLAIN (COSTS OFF)
+               ^
+HINT:  try \h <SELECTCLAUSE>
 SELECT * FROM point_tbl WHERE f1 IS NOT NULL ORDER BY f1 <-> '0,1';
-        f1         
--------------------
- (1e-300,-1e-300)
- (0,0)
- (-3,4)
- (-10,0)
- (10,10)
- (-5,-12)
- (5.1,34.5)
- (Infinity,1e+300)
- (1e+300,Infinity)
- (NaN,NaN)
-(10 rows)
-
+ERROR:  relation "point_tbl" does not exist
 EXPLAIN (COSTS OFF)
 SELECT * FROM point_tbl WHERE f1 <@ '(-10,-10),(10,10)':: box ORDER BY f1 <-> '0,1';
-                   QUERY PLAN                   
-------------------------------------------------
- Index Only Scan using gpointind on point_tbl
-   Index Cond: (f1 <@ '(10,10),(-10,-10)'::box)
-   Order By: (f1 <-> '(0,1)'::point)
-(3 rows)
-
+ERROR:  at or near "off": syntax error
+DETAIL:  source SQL:
+EXPLAIN (COSTS OFF)
+               ^
+HINT:  try \h <SELECTCLAUSE>
 SELECT * FROM point_tbl WHERE f1 <@ '(-10,-10),(10,10)':: box ORDER BY f1 <-> '0,1';
-        f1        
-------------------
- (1e-300,-1e-300)
- (0,0)
- (-3,4)
- (-10,0)
- (10,10)
-(5 rows)
-
+ERROR:  at or near "order": syntax error: unimplemented: this syntax
+DETAIL:  source SQL:
+SELECT * FROM point_tbl WHERE f1 <@ '(-10,-10),(10,10)':: box ORDER BY f1 <-> '0,1'
+                                                              ^
+HINT:  You have attempted to use a feature that is not yet implemented.
+See: https://go.crdb.dev/issue-v/21286/_version_
 EXPLAIN (COSTS OFF)
 SELECT * FROM gpolygon_tbl ORDER BY f1 <-> '(0,0)'::point LIMIT 10;
-                     QUERY PLAN                      
------------------------------------------------------
- Limit
-   ->  Index Scan using ggpolygonind on gpolygon_tbl
-         Order By: (f1 <-> '(0,0)'::point)
-(3 rows)
-
+ERROR:  at or near "off": syntax error
+DETAIL:  source SQL:
+EXPLAIN (COSTS OFF)
+               ^
+HINT:  try \h <SELECTCLAUSE>
 SELECT * FROM gpolygon_tbl ORDER BY f1 <-> '(0,0)'::point LIMIT 10;
-                       f1                        
--------------------------------------------------
- ((240,359),(240,455),(337,455),(337,359))
- ((662,163),(662,187),(759,187),(759,163))
- ((1000,0),(0,1000))
- ((0,1000),(1000,1000))
- ((1346,344),(1346,403),(1444,403),(1444,344))
- ((278,1409),(278,1457),(369,1457),(369,1409))
- ((907,1156),(907,1201),(948,1201),(948,1156))
- ((1517,971),(1517,1043),(1594,1043),(1594,971))
- ((175,1820),(175,1850),(259,1850),(259,1820))
- ((2424,81),(2424,160),(2424,160),(2424,81))
-(10 rows)
-
+ERROR:  at or near "limit": syntax error: unimplemented: this syntax
+DETAIL:  source SQL:
+SELECT * FROM gpolygon_tbl ORDER BY f1 <-> '(0,0)'::point LIMIT 10
+                                                          ^
+HINT:  You have attempted to use a feature that is not yet implemented.
+See: https://go.crdb.dev/issue-v/21286/_version_
 EXPLAIN (COSTS OFF)
 SELECT circle_center(f1), round(radius(f1)) as radius FROM gcircle_tbl ORDER BY f1 <-> '(200,300)'::point LIMIT 10;
-                    QUERY PLAN                     
----------------------------------------------------
- Limit
-   ->  Index Scan using ggcircleind on gcircle_tbl
-         Order By: (f1 <-> '(200,300)'::point)
-(3 rows)
-
+ERROR:  at or near "off": syntax error
+DETAIL:  source SQL:
+EXPLAIN (COSTS OFF)
+               ^
+HINT:  try \h <SELECTCLAUSE>
 SELECT circle_center(f1), round(radius(f1)) as radius FROM gcircle_tbl ORDER BY f1 <-> '(200,300)'::point LIMIT 10;
- circle_center  | radius 
-----------------+--------
- (288.5,407)    |     68
- (710.5,175)    |     50
- (323.5,1433)   |     51
- (927.5,1178.5) |     30
- (1395,373.5)   |     57
- (1555.5,1007)  |     53
- (217,1835)     |     45
- (489,2421.5)   |     22
- (2424,120.5)   |     40
- (751.5,2655)   |     20
-(10 rows)
-
+ERROR:  at or near "limit": syntax error: unimplemented: this syntax
+DETAIL:  source SQL:
+SELECT circle_center(f1), round(radius(f1)) as radius FROM gcircle_tbl ORDER BY f1 <-> '(200,300)'::point LIMIT 10
+                                                                                                          ^
+HINT:  You have attempted to use a feature that is not yet implemented.
+See: https://go.crdb.dev/issue-v/21286/_version_
 EXPLAIN (COSTS OFF)
 SELECT point(x,x), (SELECT f1 FROM gpolygon_tbl ORDER BY f1 <-> point(x,x) LIMIT 1) as c FROM generate_series(0,10,1) x;
-                                         QUERY PLAN                                         
---------------------------------------------------------------------------------------------
- Function Scan on generate_series x
-   SubPlan 1
-     ->  Limit
-           ->  Index Scan using ggpolygonind on gpolygon_tbl
-                 Order By: (f1 <-> point((x.x)::double precision, (x.x)::double precision))
-(5 rows)
-
+ERROR:  at or near "off": syntax error
+DETAIL:  source SQL:
+EXPLAIN (COSTS OFF)
+               ^
+HINT:  try \h <SELECTCLAUSE>
 SELECT point(x,x), (SELECT f1 FROM gpolygon_tbl ORDER BY f1 <-> point(x,x) LIMIT 1) as c FROM generate_series(0,10,1) x;
-  point  |                     c                     
----------+-------------------------------------------
- (0,0)   | ((240,359),(240,455),(337,455),(337,359))
- (1,1)   | ((240,359),(240,455),(337,455),(337,359))
- (2,2)   | ((240,359),(240,455),(337,455),(337,359))
- (3,3)   | ((240,359),(240,455),(337,455),(337,359))
- (4,4)   | ((240,359),(240,455),(337,455),(337,359))
- (5,5)   | ((240,359),(240,455),(337,455),(337,359))
- (6,6)   | ((240,359),(240,455),(337,455),(337,359))
- (7,7)   | ((240,359),(240,455),(337,455),(337,359))
- (8,8)   | ((240,359),(240,455),(337,455),(337,359))
- (9,9)   | ((240,359),(240,455),(337,455),(337,359))
- (10,10) | ((240,359),(240,455),(337,455),(337,359))
-(11 rows)
-
+ERROR:  at or near "(": syntax error
+DETAIL:  source SQL:
+SELECT point(x,x), (SELECT f1 FROM gpolygon_tbl ORDER BY f1 <-> point(x,x) LIMIT 1) as c FROM generate_series(0,10,1) x
+            ^
 -- Now check the results from bitmap indexscan
 SET enable_seqscan = OFF;
+WARNING:  setting session var "enable_seqscan" is a no-op
 SET enable_indexscan = OFF;
+ERROR:  unimplemented: the configuration setting "enable_indexscan" is not supported
+HINT:  You have attempted to use a feature that is not yet implemented.
+
+Please check the public issue tracker to check whether this problem is
+already tracked. If you cannot find it there, please report the error
+with details by creating a new issue.
+
+If you would rather not post publicly, please contact us directly
+using the support form.
+
+We appreciate your feedback.
+
 SET enable_bitmapscan = ON;
+ERROR:  unimplemented: the configuration setting "enable_bitmapscan" is not supported
+HINT:  You have attempted to use a feature that is not yet implemented.
+
+Please check the public issue tracker to check whether this problem is
+already tracked. If you cannot find it there, please report the error
+with details by creating a new issue.
+
+If you would rather not post publicly, please contact us directly
+using the support form.
+
+We appreciate your feedback.
+
 EXPLAIN (COSTS OFF)
 SELECT * FROM point_tbl WHERE f1 <@ '(-10,-10),(10,10)':: box ORDER BY f1 <-> '0,1';
-                         QUERY PLAN                         
-------------------------------------------------------------
- Sort
-   Sort Key: ((f1 <-> '(0,1)'::point))
-   ->  Bitmap Heap Scan on point_tbl
-         Recheck Cond: (f1 <@ '(10,10),(-10,-10)'::box)
-         ->  Bitmap Index Scan on gpointind
-               Index Cond: (f1 <@ '(10,10),(-10,-10)'::box)
-(6 rows)
-
+ERROR:  at or near "off": syntax error
+DETAIL:  source SQL:
+EXPLAIN (COSTS OFF)
+               ^
+HINT:  try \h <SELECTCLAUSE>
 SELECT * FROM point_tbl WHERE f1 <@ '(-10,-10),(10,10)':: box ORDER BY f1 <-> '0,1';
-        f1        
-------------------
- (0,0)
- (1e-300,-1e-300)
- (-3,4)
- (-10,0)
- (10,10)
-(5 rows)
-
+ERROR:  at or near "order": syntax error: unimplemented: this syntax
+DETAIL:  source SQL:
+SELECT * FROM point_tbl WHERE f1 <@ '(-10,-10),(10,10)':: box ORDER BY f1 <-> '0,1'
+                                                              ^
+HINT:  You have attempted to use a feature that is not yet implemented.
+See: https://go.crdb.dev/issue-v/21286/_version_
 RESET enable_seqscan;
+WARNING:  setting session var "enable_seqscan" is a no-op
 RESET enable_indexscan;
+ERROR:  unimplemented: the configuration setting "enable_indexscan" is not supported
+HINT:  You have attempted to use a feature that is not yet implemented.
+
+Please check the public issue tracker to check whether this problem is
+already tracked. If you cannot find it there, please report the error
+with details by creating a new issue.
+
+If you would rather not post publicly, please contact us directly
+using the support form.
+
+We appreciate your feedback.
+
 RESET enable_bitmapscan;
+ERROR:  unimplemented: the configuration setting "enable_bitmapscan" is not supported
+HINT:  You have attempted to use a feature that is not yet implemented.
+
+Please check the public issue tracker to check whether this problem is
+already tracked. If you cannot find it there, please report the error
+with details by creating a new issue.
+
+If you would rather not post publicly, please contact us directly
+using the support form.
+
+We appreciate your feedback.
+
 --
 -- GIN over int[] and text[]
 --
@@ -656,12 +647,26 @@
 );
 \set filename :abs_srcdir '/data/array.data'
 COPY array_index_op_test FROM :'filename';
+ERROR:  at or near ":abs_srcdir/data/array.data": syntax error: unimplemented: this syntax
+DETAIL:  source SQL:
+COPY array_index_op_test FROM ':abs_srcdir/data/array.data'
+                              ^
+HINT:  You have attempted to use a feature that is not yet implemented.
+
+Please check the public issue tracker to check whether this problem is
+already tracked. If you cannot find it there, please report the error
+with details by creating a new issue.
+
+If you would rather not post publicly, please contact us directly
+using the support form.
+
+We appreciate your feedback.
+
 ANALYZE array_index_op_test;
 SELECT * FROM array_index_op_test WHERE i = '{NULL}' ORDER BY seqno;
- seqno |   i    |   t    
--------+--------+--------
-   102 | {NULL} | {NULL}
-(1 row)
+ seqno | i | t 
+-------+---+---
+(0 rows)
 
 SELECT * FROM array_index_op_test WHERE i @> '{NULL}' ORDER BY seqno;
  seqno | i | t 
@@ -674,226 +679,95 @@
 (0 rows)
 
 SELECT * FROM array_index_op_test WHERE i <@ '{NULL}' ORDER BY seqno;
- seqno | i  | t  
--------+----+----
-   101 | {} | {}
-(1 row)
+ seqno | i | t 
+-------+---+---
+(0 rows)
 
 SET enable_seqscan = OFF;
+WARNING:  setting session var "enable_seqscan" is a no-op
 SET enable_indexscan = OFF;
+ERROR:  unimplemented: the configuration setting "enable_indexscan" is not supported
+HINT:  You have attempted to use a feature that is not yet implemented.
+
+Please check the public issue tracker to check whether this problem is
+already tracked. If you cannot find it there, please report the error
+with details by creating a new issue.
+
+If you would rather not post publicly, please contact us directly
+using the support form.
+
+We appreciate your feedback.
+
 SET enable_bitmapscan = ON;
+ERROR:  unimplemented: the configuration setting "enable_bitmapscan" is not supported
+HINT:  You have attempted to use a feature that is not yet implemented.
+
+Please check the public issue tracker to check whether this problem is
+already tracked. If you cannot find it there, please report the error
+with details by creating a new issue.
+
+If you would rather not post publicly, please contact us directly
+using the support form.
+
+We appreciate your feedback.
+
 CREATE INDEX intarrayidx ON array_index_op_test USING gin (i);
 explain (costs off)
 SELECT * FROM array_index_op_test WHERE i @> '{32}' ORDER BY seqno;
-                     QUERY PLAN                     
-----------------------------------------------------
- Sort
-   Sort Key: seqno
-   ->  Bitmap Heap Scan on array_index_op_test
-         Recheck Cond: (i @> '{32}'::integer[])
-         ->  Bitmap Index Scan on intarrayidx
-               Index Cond: (i @> '{32}'::integer[])
-(6 rows)
-
+ERROR:  at or near "off": syntax error
+DETAIL:  source SQL:
+explain (costs off)
+               ^
+HINT:  try \h <SELECTCLAUSE>
 SELECT * FROM array_index_op_test WHERE i @> '{32}' ORDER BY seqno;
- seqno |                i                |                                                                 t                                                                  
--------+---------------------------------+------------------------------------------------------------------------------------------------------------------------------------
-     6 | {39,35,5,94,17,92,60,32}        | {AAAAAAAAAAAAAAA35875,AAAAAAAAAAAAAAAA23657}
-    74 | {32}                            | {AAAAAAAAAAAAAAAA1729,AAAAAAAAAAAAA22860,AAAAAA99807,AAAAA17383,AAAAAAAAAAAAAAA67062,AAAAAAAAAAA15165,AAAAAAAAAAA50956}
-    77 | {97,15,32,17,55,59,18,37,50,39} | {AAAAAAAAAAAA67946,AAAAAA54032,AAAAAAAA81587,55847,AAAAAAAAAAAAAA28620,AAAAAAAAAAAAAAAAA43052,AAAAAA75463,AAAA49534,AAAAAAAA44066}
-    89 | {40,32,17,6,30,88}              | {AA44673,AAAAAAAAAAA6119,AAAAAAAAAAAAAAAA23657,AAAAAAAAAAAAAAAAAA47955,AAAAAAAAAAAAAAAA33598,AAAAAAAAAAA33576,AA44673}
-    98 | {38,34,32,89}                   | {AAAAAAAAAAAAAAAAAA71621,AAAA8857,AAAAAAAAAAAAAAAAAAA65037,AAAAAAAAAAAAAAAA31334,AAAAAAAAAA48845}
-   100 | {85,32,57,39,49,84,32,3,30}     | {AAAAAAA80240,AAAAAAAAAAAAAAAA1729,AAAAA60038,AAAAAAAAAAA92631,AAAAAAAA9523}
-(6 rows)
+ seqno | i | t 
+-------+---+---
+(0 rows)
 
 SELECT * FROM array_index_op_test WHERE i && '{32}' ORDER BY seqno;
- seqno |                i                |                                                                 t                                                                  
--------+---------------------------------+------------------------------------------------------------------------------------------------------------------------------------
-     6 | {39,35,5,94,17,92,60,32}        | {AAAAAAAAAAAAAAA35875,AAAAAAAAAAAAAAAA23657}
-    74 | {32}                            | {AAAAAAAAAAAAAAAA1729,AAAAAAAAAAAAA22860,AAAAAA99807,AAAAA17383,AAAAAAAAAAAAAAA67062,AAAAAAAAAAA15165,AAAAAAAAAAA50956}
-    77 | {97,15,32,17,55,59,18,37,50,39} | {AAAAAAAAAAAA67946,AAAAAA54032,AAAAAAAA81587,55847,AAAAAAAAAAAAAA28620,AAAAAAAAAAAAAAAAA43052,AAAAAA75463,AAAA49534,AAAAAAAA44066}
-    89 | {40,32,17,6,30,88}              | {AA44673,AAAAAAAAAAA6119,AAAAAAAAAAAAAAAA23657,AAAAAAAAAAAAAAAAAA47955,AAAAAAAAAAAAAAAA33598,AAAAAAAAAAA33576,AA44673}
-    98 | {38,34,32,89}                   | {AAAAAAAAAAAAAAAAAA71621,AAAA8857,AAAAAAAAAAAAAAAAAAA65037,AAAAAAAAAAAAAAAA31334,AAAAAAAAAA48845}
-   100 | {85,32,57,39,49,84,32,3,30}     | {AAAAAAA80240,AAAAAAAAAAAAAAAA1729,AAAAA60038,AAAAAAAAAAA92631,AAAAAAAA9523}
-(6 rows)
+ seqno | i | t 
+-------+---+---
+(0 rows)
 
 SELECT * FROM array_index_op_test WHERE i @> '{17}' ORDER BY seqno;
- seqno |                i                |                                                                 t                                                                  
--------+---------------------------------+------------------------------------------------------------------------------------------------------------------------------------
-     6 | {39,35,5,94,17,92,60,32}        | {AAAAAAAAAAAAAAA35875,AAAAAAAAAAAAAAAA23657}
-    12 | {17,99,18,52,91,72,0,43,96,23}  | {AAAAA33250,AAAAAAAAAAAAAAAAAAA85420,AAAAAAAAAAA33576}
-    15 | {17,14,16,63,67}                | {AA6416,AAAAAAAAAA646,AAAAA95309}
-    19 | {52,82,17,74,23,46,69,51,75}    | {AAAAAAAAAAAAA73084,AAAAA75968,AAAAAAAAAAAAAAAA14047,AAAAAAA80240,AAAAAAAAAAAAAAAAAAA1205,A68938}
-    53 | {38,17}                         | {AAAAAAAAAAA21658}
-    65 | {61,5,76,59,17}                 | {AAAAAA99807,AAAAA64741,AAAAAAAAAAA53908,AA21643,AAAAAAAAA10012}
-    77 | {97,15,32,17,55,59,18,37,50,39} | {AAAAAAAAAAAA67946,AAAAAA54032,AAAAAAAA81587,55847,AAAAAAAAAAAAAA28620,AAAAAAAAAAAAAAAAA43052,AAAAAA75463,AAAA49534,AAAAAAAA44066}
-    89 | {40,32,17,6,30,88}              | {AA44673,AAAAAAAAAAA6119,AAAAAAAAAAAAAAAA23657,AAAAAAAAAAAAAAAAAA47955,AAAAAAAAAAAAAAAA33598,AAAAAAAAAAA33576,AA44673}
-(8 rows)
+ seqno | i | t 
+-------+---+---
+(0 rows)
 
 SELECT * FROM array_index_op_test WHERE i && '{17}' ORDER BY seqno;
- seqno |                i                |                                                                 t                                                                  
--------+---------------------------------+------------------------------------------------------------------------------------------------------------------------------------
-     6 | {39,35,5,94,17,92,60,32}        | {AAAAAAAAAAAAAAA35875,AAAAAAAAAAAAAAAA23657}
-    12 | {17,99,18,52,91,72,0,43,96,23}  | {AAAAA33250,AAAAAAAAAAAAAAAAAAA85420,AAAAAAAAAAA33576}
-    15 | {17,14,16,63,67}                | {AA6416,AAAAAAAAAA646,AAAAA95309}
-    19 | {52,82,17,74,23,46,69,51,75}    | {AAAAAAAAAAAAA73084,AAAAA75968,AAAAAAAAAAAAAAAA14047,AAAAAAA80240,AAAAAAAAAAAAAAAAAAA1205,A68938}
-    53 | {38,17}                         | {AAAAAAAAAAA21658}
-    65 | {61,5,76,59,17}                 | {AAAAAA99807,AAAAA64741,AAAAAAAAAAA53908,AA21643,AAAAAAAAA10012}
-    77 | {97,15,32,17,55,59,18,37,50,39} | {AAAAAAAAAAAA67946,AAAAAA54032,AAAAAAAA81587,55847,AAAAAAAAAAAAAA28620,AAAAAAAAAAAAAAAAA43052,AAAAAA75463,AAAA49534,AAAAAAAA44066}
-    89 | {40,32,17,6,30,88}              | {AA44673,AAAAAAAAAAA6119,AAAAAAAAAAAAAAAA23657,AAAAAAAAAAAAAAAAAA47955,AAAAAAAAAAAAAAAA33598,AAAAAAAAAAA33576,AA44673}
-(8 rows)
+ seqno | i | t 
+-------+---+---
+(0 rows)
 
 SELECT * FROM array_index_op_test WHERE i @> '{32,17}' ORDER BY seqno;
- seqno |                i                |                                                                 t                                                                  
--------+---------------------------------+------------------------------------------------------------------------------------------------------------------------------------
-     6 | {39,35,5,94,17,92,60,32}        | {AAAAAAAAAAAAAAA35875,AAAAAAAAAAAAAAAA23657}
-    77 | {97,15,32,17,55,59,18,37,50,39} | {AAAAAAAAAAAA67946,AAAAAA54032,AAAAAAAA81587,55847,AAAAAAAAAAAAAA28620,AAAAAAAAAAAAAAAAA43052,AAAAAA75463,AAAA49534,AAAAAAAA44066}
-    89 | {40,32,17,6,30,88}              | {AA44673,AAAAAAAAAAA6119,AAAAAAAAAAAAAAAA23657,AAAAAAAAAAAAAAAAAA47955,AAAAAAAAAAAAAAAA33598,AAAAAAAAAAA33576,AA44673}
-(3 rows)
+ seqno | i | t 
+-------+---+---
+(0 rows)
 
 SELECT * FROM array_index_op_test WHERE i && '{32,17}' ORDER BY seqno;
- seqno |                i                |                                                                 t                                                                  
--------+---------------------------------+------------------------------------------------------------------------------------------------------------------------------------
-     6 | {39,35,5,94,17,92,60,32}        | {AAAAAAAAAAAAAAA35875,AAAAAAAAAAAAAAAA23657}
-    12 | {17,99,18,52,91,72,0,43,96,23}  | {AAAAA33250,AAAAAAAAAAAAAAAAAAA85420,AAAAAAAAAAA33576}
-    15 | {17,14,16,63,67}                | {AA6416,AAAAAAAAAA646,AAAAA95309}
-    19 | {52,82,17,74,23,46,69,51,75}    | {AAAAAAAAAAAAA73084,AAAAA75968,AAAAAAAAAAAAAAAA14047,AAAAAAA80240,AAAAAAAAAAAAAAAAAAA1205,A68938}
-    53 | {38,17}                         | {AAAAAAAAAAA21658}
-    65 | {61,5,76,59,17}                 | {AAAAAA99807,AAAAA64741,AAAAAAAAAAA53908,AA21643,AAAAAAAAA10012}
-    74 | {32}                            | {AAAAAAAAAAAAAAAA1729,AAAAAAAAAAAAA22860,AAAAAA99807,AAAAA17383,AAAAAAAAAAAAAAA67062,AAAAAAAAAAA15165,AAAAAAAAAAA50956}
-    77 | {97,15,32,17,55,59,18,37,50,39} | {AAAAAAAAAAAA67946,AAAAAA54032,AAAAAAAA81587,55847,AAAAAAAAAAAAAA28620,AAAAAAAAAAAAAAAAA43052,AAAAAA75463,AAAA49534,AAAAAAAA44066}
-    89 | {40,32,17,6,30,88}              | {AA44673,AAAAAAAAAAA6119,AAAAAAAAAAAAAAAA23657,AAAAAAAAAAAAAAAAAA47955,AAAAAAAAAAAAAAAA33598,AAAAAAAAAAA33576,AA44673}
-    98 | {38,34,32,89}                   | {AAAAAAAAAAAAAAAAAA71621,AAAA8857,AAAAAAAAAAAAAAAAAAA65037,AAAAAAAAAAAAAAAA31334,AAAAAAAAAA48845}
-   100 | {85,32,57,39,49,84,32,3,30}     | {AAAAAAA80240,AAAAAAAAAAAAAAAA1729,AAAAA60038,AAAAAAAAAAA92631,AAAAAAAA9523}
-(11 rows)
+ seqno | i | t 
+-------+---+---
+(0 rows)
 
 SELECT * FROM array_index_op_test WHERE i <@ '{38,34,32,89}' ORDER BY seqno;
- seqno |       i       |                                                             t                                                              
--------+---------------+----------------------------------------------------------------------------------------------------------------------------
-    40 | {34}          | {AAAAAAAAAAAAAA10611,AAAAAAAAAAAAAAAAAAA1205,AAAAAAAAAAA50956,AAAAAAAAAAAAAAAA31334,AAAAA70466,AAAAAAAA81587,AAAAAAA74623}
-    74 | {32}          | {AAAAAAAAAAAAAAAA1729,AAAAAAAAAAAAA22860,AAAAAA99807,AAAAA17383,AAAAAAAAAAAAAAA67062,AAAAAAAAAAA15165,AAAAAAAAAAA50956}
-    98 | {38,34,32,89} | {AAAAAAAAAAAAAAAAAA71621,AAAA8857,AAAAAAAAAAAAAAAAAAA65037,AAAAAAAAAAAAAAAA31334,AAAAAAAAAA48845}
-   101 | {}            | {}
-(4 rows)
+ seqno | i | t 
+-------+---+---
+(0 rows)
 
 SELECT * FROM array_index_op_test WHERE i = '{47,77}' ORDER BY seqno;
- seqno |    i    |                                                        t                                                        
--------+---------+-----------------------------------------------------------------------------------------------------------------
-    95 | {47,77} | {AAAAAAAAAAAAAAAAA764,AAAAAAAAAAA74076,AAAAAAAAAA18107,AAAAA40681,AAAAAAAAAAAAAAA35875,AAAAA60038,AAAAAAA56483}
-(1 row)
+ seqno | i | t 
+-------+---+---
+(0 rows)
 
 SELECT * FROM array_index_op_test WHERE i = '{}' ORDER BY seqno;
- seqno | i  | t  
--------+----+----
-   101 | {} | {}
-(1 row)
+ seqno | i | t 
+-------+---+---
+(0 rows)
 
 SELECT * FROM array_index_op_test WHERE i @> '{}' ORDER BY seqno;
- seqno |                i                |                                                                                                       t                                                                                                        
--------+---------------------------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
-     1 | {92,75,71,52,64,83}             | {AAAAAAAA44066,AAAAAA1059,AAAAAAAAAAA176,AAAAAAA48038}
-     2 | {3,6}                           | {AAAAAA98232,AAAAAAAA79710,AAAAAAAAAAAAAAAAA69675,AAAAAAAAAAAAAAAA55798,AAAAAAAAA12793}
-     3 | {37,64,95,43,3,41,13,30,11,43}  | {AAAAAAAAAA48845,AAAAA75968,AAAAA95309,AAA54451,AAAAAAAAAA22292,AAAAAAA99836,A96617,AA17009,AAAAAAAAAAAAAA95246}
-     4 | {71,39,99,55,33,75,45}          | {AAAAAAAAA53663,AAAAAAAAAAAAAAA67062,AAAAAAAAAA64777,AAA99043,AAAAAAAAAAAAAAAAAAA91804,39557}
-     5 | {50,42,77,50,4}                 | {AAAAAAAAAAAAAAAAA26540,AAAAAAA79710,AAAAAAAAAAAAAAAAAAA1205,AAAAAAAAAAA176,AAAAA95309,AAAAAAAAAAA46154,AAAAAA66777,AAAAAAAAA27249,AAAAAAAAAA64777,AAAAAAAAAAAAAAAAAAA70104}
-     6 | {39,35,5,94,17,92,60,32}        | {AAAAAAAAAAAAAAA35875,AAAAAAAAAAAAAAAA23657}
-     7 | {12,51,88,64,8}                 | {AAAAAAAAAAAAAAAAAA12591,AAAAAAAAAAAAAAAAA50407,AAAAAAAAAAAA67946}
-     8 | {60,84}                         | {AAAAAAA81898,AAAAAA1059,AAAAAAAAAAAA81511,AAAAA961,AAAAAAAAAAAAAAAA31334,AAAAA64741,AA6416,AAAAAAAAAAAAAAAAAA32918,AAAAAAAAAAAAAAAAA50407}
-     9 | {56,52,35,27,80,44,81,22}       | {AAAAAAAAAAAAAAA73034,AAAAAAAAAAAAA7929,AAAAAAA66161,AA88409,39557,A27153,AAAAAAAA9523,AAAAAAAAAAA99000}
-    10 | {71,5,45}                       | {AAAAAAAAAAA21658,AAAAAAAAAAAA21089,AAA54451,AAAAAAAAAAAAAAAAAA54141,AAAAAAAAAAAAAA28620,AAAAAAAAAAA21658,AAAAAAAAAAA74076,AAAAAAAAA27249}
-    11 | {41,86,74,48,22,74,47,50}       | {AAAAAAAA9523,AAAAAAAAAAAA37562,AAAAAAAAAAAAAAAA14047,AAAAAAAAAAA46154,AAAA41702,AAAAAAAAAAAAAAAAA764,AAAAA62737,39557}
-    12 | {17,99,18,52,91,72,0,43,96,23}  | {AAAAA33250,AAAAAAAAAAAAAAAAAAA85420,AAAAAAAAAAA33576}
-    13 | {3,52,34,23}                    | {AAAAAA98232,AAAA49534,AAAAAAAAAAA21658}
-    14 | {78,57,19}                      | {AAAA8857,AAAAAAAAAAAAAAA73034,AAAAAAAA81587,AAAAAAAAAAAAAAA68526,AAAAA75968,AAAAAAAAAAAAAA65909,AAAAAAAAA10012,AAAAAAAAAAAAAA65909}
-    15 | {17,14,16,63,67}                | {AA6416,AAAAAAAAAA646,AAAAA95309}
-    16 | {14,63,85,11}                   | {AAAAAA66777}
-    17 | {7,10,81,85}                    | {AAAAAA43678,AAAAAAA12144,AAAAAAAAAAA50956,AAAAAAAAAAAAAAAAAAA15356}
-    18 | {1}                             | {AAAAAAAAAAA33576,AAAAA95309,64261,AAA59323,AAAAAAAAAAAAAA95246,55847,AAAAAAAAAAAA67946,AAAAAAAAAAAAAAAAAA64374}
-    19 | {52,82,17,74,23,46,69,51,75}    | {AAAAAAAAAAAAA73084,AAAAA75968,AAAAAAAAAAAAAAAA14047,AAAAAAA80240,AAAAAAAAAAAAAAAAAAA1205,A68938}
-    20 | {72,89,70,51,54,37,8,49,79}     | {AAAAAA58494}
-    21 | {2,8,65,10,5,79,43}             | {AAAAAAAAAAAAAAAAA88852,AAAAAAAAAAAAAAAAAAA91804,AAAAA64669,AAAAAAAAAAAAAAAA1443,AAAAAAAAAAAAAAAA23657,AAAAA12179,AAAAAAAAAAAAAAAAA88852,AAAAAAAAAAAAAAAA31334,AAAAAAAAAAAAAAAA41303,AAAAAAAAAAAAAAAAAAA85420}
-    22 | {11,6,56,62,53,30}              | {AAAAAAAA72908}
-    23 | {40,90,5,38,72,40,30,10,43,55}  | {A6053,AAAAAAAAAAA6119,AA44673,AAAAAAAAAAAAAAAAA764,AA17009,AAAAA17383,AAAAA70514,AAAAA33250,AAAAA95309,AAAAAAAAAAAA37562}
-    24 | {94,61,99,35,48}                | {AAAAAAAAAAA50956,AAAAAAAAAAA15165,AAAA85070,AAAAAAAAAAAAAAA36627,AAAAA961,AAAAAAAAAA55219}
-    25 | {31,1,10,11,27,79,38}           | {AAAAAAAAAAAAAAAAAA59334,45449}
-    26 | {71,10,9,69,75}                 | {47735,AAAAAAA21462,AAAAAAAAAAAAAAAAA6897,AAAAAAAAAAAAAAAAAAA91804,AAAAAAAAA72121,AAAAAAAAAAAAAAAAAAA1205,AAAAA41597,AAAA8857,AAAAAAAAAAAAAAAAAAA15356,AA17009}
-    27 | {94}                            | {AA6416,A6053,AAAAAAA21462,AAAAAAA57334,AAAAAAAAAAAAAAAAAA12591,AA88409,AAAAAAAAAAAAA70254}
-    28 | {14,33,6,34,14}                 | {AAAAAAAAAAAAAAA13198,AAAAAAAA69452,AAAAAAAAAAA82945,AAAAAAA12144,AAAAAAAAA72121,AAAAAAAAAA18601}
-    29 | {39,21}                         | {AAAAAAAAAAAAAAAAA6897,AAAAAAAAAAAAAAAAAAA38885,AAAA85070,AAAAAAAAAAAAAAAAAAA70104,AAAAA66674,AAAAAAAAAAAAA62007,AAAAAAAA69452,AAAAAAA1242,AAAAAAAAAAAAAAAA1729,AAAA35194}
-    30 | {26,81,47,91,34}                | {AAAAAAAAAAAAAAAAAAA70104,AAAAAAA80240}
-    31 | {80,24,18,21,54}                | {AAAAAAAAAAAAAAA13198,AAAAAAAAAAAAAAAAAAA70415,A27153,AAAAAAAAA53663,AAAAAAAAAAAAAAAAA50407,A68938}
-    32 | {58,79,82,80,67,75,98,10,41}    | {AAAAAAAAAAAAAAAAAA61286,AAA54451,AAAAAAAAAAAAAAAAAAA87527,A96617,51533}
-    33 | {74,73}                         | {A85417,AAAAAAA56483,AAAAA17383,AAAAAAAAAAAAA62159,AAAAAAAAAAAA52814,AAAAAAAAAAAAA85723,AAAAAAAAAAAAAAAAAA55796}
-    34 | {70,45}                         | {AAAAAAAAAAAAAAAAAA71621,AAAAAAAAAAAAAA28620,AAAAAAAAAA55219,AAAAAAAA23648,AAAAAAAAAA22292,AAAAAAA1242}
-    35 | {23,40}                         | {AAAAAAAAAAAA52814,AAAA48949,AAAAAAAAA34727,AAAA8857,AAAAAAAAAAAAAAAAAAA62179,AAAAAAAAAAAAAAA68526,AAAAAAA99836,AAAAAAAA50094,AAAA91194,AAAAAAAAAAAAA73084}
-    36 | {79,82,14,52,30,5,79}           | {AAAAAAAAA53663,AAAAAAAAAAAAAAAA55798,AAAAAAAAAAAAAAAAAAA89194,AA88409,AAAAAAAAAAAAAAA81326,AAAAAAAAAAAAAAAAA63050,AAAAAAAAAAAAAAAA33598}
-    37 | {53,11,81,39,3,78,58,64,74}     | {AAAAAAAAAAAAAAAAAAA17075,AAAAAAA66161,AAAAAAAA23648,AAAAAAAAAAAAAA10611}
-    38 | {59,5,4,95,28}                  | {AAAAAAAAAAA82945,A96617,47735,AAAAA12179,AAAAA64669,AAAAAA99807,AA74433,AAAAAAAAAAAAAAAAA59387}
-    39 | {82,43,99,16,74}                | {AAAAAAAAAAAAAAA67062,AAAAAAA57334,AAAAAAAAAAAAAA65909,A27153,AAAAAAAAAAAAAAAAAAA17075,AAAAAAAAAAAAAAAAA43052,AAAAAAAAAA64777,AAAAAAAAAAAA81511,AAAAAAAAAAAAAA65909,AAAAAAAAAAAAAA28620}
-    40 | {34}                            | {AAAAAAAAAAAAAA10611,AAAAAAAAAAAAAAAAAAA1205,AAAAAAAAAAA50956,AAAAAAAAAAAAAAAA31334,AAAAA70466,AAAAAAAA81587,AAAAAAA74623}
-    41 | {19,26,63,12,93,73,27,94}       | {AAAAAAA79710,AAAAAAAAAA55219,AAAA41702,AAAAAAAAAAAAAAAAAAA17075,AAAAAAAAAAAAAAAAAA71621,AAAAAAAAAAAAAAAAA63050,AAAAAAA99836,AAAAAAAAAAAAAA8666}
-    42 | {15,76,82,75,8,91}              | {AAAAAAAAAAA176,AAAAAA38063,45449,AAAAAA54032,AAAAAAA81898,AA6416,AAAAAAAAAAAAAAAAAAA62179,45449,AAAAA60038,AAAAAAAA81587}
-    43 | {39,87,91,97,79,28}             | {AAAAAAAAAAA74076,A96617,AAAAAAAAAAAAAAAAAAA89194,AAAAAAAAAAAAAAAAAA55796,AAAAAAAAAAAAAAAA23657,AAAAAAAAAAAA67946}
-    44 | {40,58,68,29,54}                | {AAAAAAA81898,AAAAAA66777,AAAAAA98232}
-    45 | {99,45}                         | {AAAAAAAA72908,AAAAAAAAAAAAAAAAAAA17075,AA88409,AAAAAAAAAAAAAAAAAA36842,AAAAAAA48038,AAAAAAAAAAAAAA10611}
-    46 | {53,24}                         | {AAAAAAAAAAA53908,AAAAAA54032,AAAAA17383,AAAA48949,AAAAAAAAAA18601,AAAAA64669,45449,AAAAAAAAAAA98051,AAAAAAAAAAAAAAAAAA71621}
-    47 | {98,23,64,12,75,61}             | {AAA59323,AAAAA95309,AAAAAAAAAAAAAAAA31334,AAAAAAAAA27249,AAAAA17383,AAAAAAAAAAAA37562,AAAAAA1059,A84822,55847,AAAAA70466}
-    48 | {76,14}                         | {AAAAAAAAAAAAA59671,AAAAAAAAAAAAAAAAAAA91804,AAAAAA66777,AAAAAAAAAAAAAAAAAAA89194,AAAAAAAAAAAAAAA36627,AAAAAAAAAAAAAAAAAAA17075,AAAAAAAAAAAAA73084,AAAAAAA79710,AAAAAAAAAAAAAAA40402,AAAAAAAAAAAAAAAAAAA65037}
-    49 | {56,5,54,37,49}                 | {AA21643,AAAAAAAAAAA92631,AAAAAAAA81587}
-    50 | {20,12,37,64,93}                | {AAAAAAAAAA5483,AAAAAAAAAAAAAAAAAAA1205,AA6416,AAAAAAAAAAAAAAAAA63050,AAAAAAAAAAAAAAAAAA47955}
-    51 | {47}                            | {AAAAAAAAAAAAAA96505,AAAAAAAAAAAAAAAAAA36842,AAAAA95309,AAAAAAAA81587,AA6416,AAAA91194,AAAAAA58494,AAAAAA1059,AAAAAAAA69452}
-    52 | {89,0}                          | {AAAAAAAAAAAAAAAAAA47955,AAAAAAA48038,AAAAAAAAAAAAAAAAA43052,AAAAAAAAAAAAA73084,AAAAA70466,AAAAAAAAAAAAAAAAA764,AAAAAAAAAAA46154,AA66862}
-    53 | {38,17}                         | {AAAAAAAAAAA21658}
-    54 | {70,47}                         | {AAAAAAAAAAAAAAAAAA54141,AAAAA40681,AAAAAAA48038,AAAAAAAAAAAAAAAA29150,AAAAA41597,AAAAAAAAAAAAAAAAAA59334,AA15322}
-    55 | {47,79,47,64,72,25,71,24,93}    | {AAAAAAAAAAAAAAAAAA55796,AAAAA62737}
-    56 | {33,7,60,54,93,90,77,85,39}     | {AAAAAAAAAAAAAAAAAA32918,AA42406}
-    57 | {23,45,10,42,36,21,9,96}        | {AAAAAAAAAAAAAAAAAAA70415}
-    58 | {92}                            | {AAAAAAAAAAAAAAAA98414,AAAAAAAA23648,AAAAAAAAAAAAAAAAAA55796,AA25381,AAAAAAAAAAA6119}
-    59 | {9,69,46,77}                    | {39557,AAAAAAA89932,AAAAAAAAAAAAAAAAA43052,AAAAAAAAAAAAAAAAA26540,AAA20874,AA6416,AAAAAAAAAAAAAAAAAA47955}
-    60 | {62,2,59,38,89}                 | {AAAAAAA89932,AAAAAAAAAAAAAAAAAAA15356,AA99927,AA17009,AAAAAAAAAAAAAAA35875}
-    61 | {72,2,44,95,54,54,13}           | {AAAAAAAAAAAAAAAAAAA91804}
-    62 | {83,72,29,73}                   | {AAAAAAAAAAAAA15097,AAAA8857,AAAAAAAAAAAA35809,AAAAAAAAAAAA52814,AAAAAAAAAAAAAAAAAAA38885,AAAAAAAAAAAAAAAAAA24183,AAAAAA43678,A96617}
-    63 | {11,4,61,87}                    | {AAAAAAAAA27249,AAAAAAAAAAAAAAAAAA32918,AAAAAAAAAAAAAAA13198,AAA20874,39557,51533,AAAAAAAAAAA53908,AAAAAAAAAAAAAA96505,AAAAAAAA78938}
-    64 | {26,19,34,24,81,78}             | {A96617,AAAAAAAAAAAAAAAAAAA70104,A68938,AAAAAAAAAAA53908,AAAAAAAAAAAAAAA453,AA17009,AAAAAAA80240}
-    65 | {61,5,76,59,17}                 | {AAAAAA99807,AAAAA64741,AAAAAAAAAAA53908,AA21643,AAAAAAAAA10012}
-    66 | {31,23,70,52,4,33,48,25}        | {AAAAAAAAAAAAAAAAA69675,AAAAAAAA50094,AAAAAAAAAAA92631,AAAA35194,39557,AAAAAAA99836}
-    67 | {31,94,7,10}                    | {AAAAAA38063,A96617,AAAA35194,AAAAAAAAAAAA67946}
-    68 | {90,43,38}                      | {AA75092,AAAAAAAAAAAAAAAAA69675,AAAAAAAAAAA92631,AAAAAAAAA10012,AAAAAAAAAAAAA7929,AA21643}
-    69 | {67,35,99,85,72,86,44}          | {AAAAAAAAAAAAAAAAAAA1205,AAAAAAAA50094,AAAAAAAAAAAAAAAA1729,AAAAAAAAAAAAAAAAAA47955}
-    70 | {56,70,83}                      | {AAAA41702,AAAAAAAAAAA82945,AA21643,AAAAAAAAAAA99000,A27153,AA25381,AAAAAAAAAAAAAA96505,AAAAAAA1242}
-    71 | {74,26}                         | {AAAAAAAAAAA50956,AA74433,AAAAAAA21462,AAAAAAAAAAAAAAAAAAA17075,AAAAAAAAAAAAAAA36627,AAAAAAAAAAAAA70254,AAAAAAAAAA43419,39557}
-    72 | {22,1,16,78,20,91,83}           | {47735,AAAAAAA56483,AAAAAAAAAAAAA93788,AA42406,AAAAAAAAAAAAA73084,AAAAAAAA72908,AAAAAAAAAAAAAAAAAA61286,AAAAA66674,AAAAAAAAAAAAAAAAA50407}
-    73 | {88,25,96,78,65,15,29,19}       | {AAA54451,AAAAAAAAA27249,AAAAAAA9228,AAAAAAAAAAAAAAA67062,AAAAAAAAAAAAAAAAAAA70415,AAAAA17383,AAAAAAAAAAAAAAAA33598}
-    74 | {32}                            | {AAAAAAAAAAAAAAAA1729,AAAAAAAAAAAAA22860,AAAAAA99807,AAAAA17383,AAAAAAAAAAAAAAA67062,AAAAAAAAAAA15165,AAAAAAAAAAA50956}
-    75 | {12,96,83,24,71,89,55}          | {AAAA48949,AAAAAAAA29716,AAAAAAAAAAAAAAAAAAA1205,AAAAAAAAAAAA67946,AAAAAAAAAAAAAAAA29150,AAA28075,AAAAAAAAAAAAAAAAA43052}
-    76 | {92,55,10,7}                    | {AAAAAAAAAAAAAAA67062}
-    77 | {97,15,32,17,55,59,18,37,50,39} | {AAAAAAAAAAAA67946,AAAAAA54032,AAAAAAAA81587,55847,AAAAAAAAAAAAAA28620,AAAAAAAAAAAAAAAAA43052,AAAAAA75463,AAAA49534,AAAAAAAA44066}
-    78 | {55,89,44,84,34}                | {AAAAAAAAAAA6119,AAAAAAAAAAAAAA8666,AA99927,AA42406,AAAAAAA81898,AAAAAAA9228,AAAAAAAAAAA92631,AA21643,AAAAAAAAAAAAAA28620}
-    79 | {45}                            | {AAAAAAAAAA646,AAAAAAAAAAAAAAAAAAA70415,AAAAAA43678,AAAAAAAA72908}
-    80 | {74,89,44,80,0}                 | {AAAA35194,AAAAAAAA79710,AAA20874,AAAAAAAAAAAAAAAAAAA70104,AAAAAAAAAAAAA73084,AAAAAAA57334,AAAAAAA9228,AAAAAAAAAAAAA62007}
-    81 | {63,77,54,48,61,53,97}          | {AAAAAAAAAAAAAAA81326,AAAAAAAAAA22292,AA25381,AAAAAAAAAAA74076,AAAAAAA81898,AAAAAAAAA72121}
-    82 | {34,60,4,79,78,16,86,89,42,50}  | {AAAAA40681,AAAAAAAAAAAAAAAAAA12591,AAAAAAA80240,AAAAAAAAAAAAAAAA55798,AAAAAAAAAAAAAAAAAAA70104}
-    83 | {14,10}                         | {AAAAAAAAAA22292,AAAAAAAAAAAAA70254,AAAAAAAAAAA6119}
-    84 | {11,83,35,13,96,94}             | {AAAAA95309,AAAAAAAAAAAAAAAAAA32918,AAAAAAAAAAAAAAAAAA24183}
-    85 | {39,60}                         | {AAAAAAAAAAAAAAAA55798,AAAAAAAAAA22292,AAAAAAA66161,AAAAAAA21462,AAAAAAAAAAAAAAAAAA12591,55847,AAAAAA98232,AAAAAAAAAAA46154}
-    86 | {33,81,72,74,45,36,82}          | {AAAAAAAA81587,AAAAAAAAAAAAAA96505,45449,AAAA80176}
-    87 | {57,27,50,12,97,68}             | {AAAAAAAAAAAAAAAAA26540,AAAAAAAAA10012,AAAAAAAAAAAA35809,AAAAAAAAAAAAAAAA29150,AAAAAAAAAAA82945,AAAAAA66777,31228,AAAAAAAAAAAAAAAA23657,AAAAAAAAAAAAAA28620,AAAAAAAAAAAAAA96505}
-    88 | {41,90,77,24,6,24}              | {AAAA35194,AAAA35194,AAAAAAA80240,AAAAAAAAAAA46154,AAAAAA58494,AAAAAAAAAAAAAAAAAAA17075,AAAAAAAAAAAAAAAAAA59334,AAAAAAAAAAAAAAAAAAA91804,AA74433}
-    89 | {40,32,17,6,30,88}              | {AA44673,AAAAAAAAAAA6119,AAAAAAAAAAAAAAAA23657,AAAAAAAAAAAAAAAAAA47955,AAAAAAAAAAAAAAAA33598,AAAAAAAAAAA33576,AA44673}
-    90 | {88,75}                         | {AAAAA60038,AAAAAAAA23648,AAAAAAAAAAA99000,AAAA41702,AAAAAAAAAAAAA22860,AAAAAAAAAAAAAAA68526}
-    91 | {78}                            | {AAAAAAAAAAAAA62007,AAA99043}
-    92 | {85,63,49,45}                   | {AAAAAAA89932,AAAAAAAAAAAAA22860,AAAAAAAAAAAAAAAAAAA1205,AAAAAAAAAAAA21089}
-    93 | {11}                            | {AAAAAAAAAAA176,AAAAAAAAAAAAAA8666,AAAAAAAAAAAAAAA453,AAAAAAAAAAAAA85723,A68938,AAAAAAAAAAAAA9821,AAAAAAA48038,AAAAAAAAAAAAAAAAA59387,AA99927,AAAAA17383}
-    94 | {98,9,85,62,88,91,60,61,38,86}  | {AAAAAAAA81587,AAAAA17383,AAAAAAAA81587}
-    95 | {47,77}                         | {AAAAAAAAAAAAAAAAA764,AAAAAAAAAAA74076,AAAAAAAAAA18107,AAAAA40681,AAAAAAAAAAAAAAA35875,AAAAA60038,AAAAAAA56483}
-    96 | {23,97,43}                      | {AAAAAAAAAA646,A87088}
-    97 | {54,2,86,65}                    | {47735,AAAAAAA99836,AAAAAAAAAAAAAAAAA6897,AAAAAAAAAAAAAAAA29150,AAAAAAA80240,AAAAAAAAAAAAAAAA98414,AAAAAAA56483,AAAAAAAAAAAAAAAA29150,AAAAAAA39692,AA21643}
-    98 | {38,34,32,89}                   | {AAAAAAAAAAAAAAAAAA71621,AAAA8857,AAAAAAAAAAAAAAAAAAA65037,AAAAAAAAAAAAAAAA31334,AAAAAAAAAA48845}
-    99 | {37,86}                         | {AAAAAAAAAAAAAAAAAA32918,AAAAA70514,AAAAAAAAA10012,AAAAAAAAAAAAAAAAA59387,AAAAAAAAAA64777,AAAAAAAAAAAAAAAAAAA15356}
-   100 | {85,32,57,39,49,84,32,3,30}     | {AAAAAAA80240,AAAAAAAAAAAAAAAA1729,AAAAA60038,AAAAAAAAAAA92631,AAAAAAAA9523}
-   101 | {}                              | {}
-   102 | {NULL}                          | {NULL}
-(102 rows)
+ seqno | i | t 
+-------+---+---
+(0 rows)
 
 SELECT * FROM array_index_op_test WHERE i && '{}' ORDER BY seqno;
  seqno | i | t 
@@ -901,201 +775,67 @@
 (0 rows)
 
 SELECT * FROM array_index_op_test WHERE i <@ '{}' ORDER BY seqno;
- seqno | i  | t  
--------+----+----
-   101 | {} | {}
-(1 row)
+ seqno | i | t 
+-------+---+---
+(0 rows)
 
 CREATE INDEX textarrayidx ON array_index_op_test USING gin (t);
 explain (costs off)
 SELECT * FROM array_index_op_test WHERE t @> '{AAAAAAAA72908}' ORDER BY seqno;
-                         QUERY PLAN                         
-------------------------------------------------------------
- Sort
-   Sort Key: seqno
-   ->  Bitmap Heap Scan on array_index_op_test
-         Recheck Cond: (t @> '{AAAAAAAA72908}'::text[])
-         ->  Bitmap Index Scan on textarrayidx
-               Index Cond: (t @> '{AAAAAAAA72908}'::text[])
-(6 rows)
-
+ERROR:  at or near "off": syntax error
+DETAIL:  source SQL:
+explain (costs off)
+               ^
+HINT:  try \h <SELECTCLAUSE>
 SELECT * FROM array_index_op_test WHERE t @> '{AAAAAAAA72908}' ORDER BY seqno;
- seqno |           i           |                                                                     t                                                                      
--------+-----------------------+--------------------------------------------------------------------------------------------------------------------------------------------
-    22 | {11,6,56,62,53,30}    | {AAAAAAAA72908}
-    45 | {99,45}               | {AAAAAAAA72908,AAAAAAAAAAAAAAAAAAA17075,AA88409,AAAAAAAAAAAAAAAAAA36842,AAAAAAA48038,AAAAAAAAAAAAAA10611}
-    72 | {22,1,16,78,20,91,83} | {47735,AAAAAAA56483,AAAAAAAAAAAAA93788,AA42406,AAAAAAAAAAAAA73084,AAAAAAAA72908,AAAAAAAAAAAAAAAAAA61286,AAAAA66674,AAAAAAAAAAAAAAAAA50407}
-    79 | {45}                  | {AAAAAAAAAA646,AAAAAAAAAAAAAAAAAAA70415,AAAAAA43678,AAAAAAAA72908}
-(4 rows)
+ seqno | i | t 
+-------+---+---
+(0 rows)
 
 SELECT * FROM array_index_op_test WHERE t && '{AAAAAAAA72908}' ORDER BY seqno;
- seqno |           i           |                                                                     t                                                                      
--------+-----------------------+--------------------------------------------------------------------------------------------------------------------------------------------
-    22 | {11,6,56,62,53,30}    | {AAAAAAAA72908}
-    45 | {99,45}               | {AAAAAAAA72908,AAAAAAAAAAAAAAAAAAA17075,AA88409,AAAAAAAAAAAAAAAAAA36842,AAAAAAA48038,AAAAAAAAAAAAAA10611}
-    72 | {22,1,16,78,20,91,83} | {47735,AAAAAAA56483,AAAAAAAAAAAAA93788,AA42406,AAAAAAAAAAAAA73084,AAAAAAAA72908,AAAAAAAAAAAAAAAAAA61286,AAAAA66674,AAAAAAAAAAAAAAAAA50407}
-    79 | {45}                  | {AAAAAAAAAA646,AAAAAAAAAAAAAAAAAAA70415,AAAAAA43678,AAAAAAAA72908}
-(4 rows)
+ seqno | i | t 
+-------+---+---
+(0 rows)
 
 SELECT * FROM array_index_op_test WHERE t @> '{AAAAAAAAAA646}' ORDER BY seqno;
- seqno |        i         |                                 t                                  
--------+------------------+--------------------------------------------------------------------
-    15 | {17,14,16,63,67} | {AA6416,AAAAAAAAAA646,AAAAA95309}
-    79 | {45}             | {AAAAAAAAAA646,AAAAAAAAAAAAAAAAAAA70415,AAAAAA43678,AAAAAAAA72908}
-    96 | {23,97,43}       | {AAAAAAAAAA646,A87088}
-(3 rows)
+ seqno | i | t 
+-------+---+---
+(0 rows)
 
 SELECT * FROM array_index_op_test WHERE t && '{AAAAAAAAAA646}' ORDER BY seqno;
- seqno |        i         |                                 t                                  
--------+------------------+--------------------------------------------------------------------
-    15 | {17,14,16,63,67} | {AA6416,AAAAAAAAAA646,AAAAA95309}
-    79 | {45}             | {AAAAAAAAAA646,AAAAAAAAAAAAAAAAAAA70415,AAAAAA43678,AAAAAAAA72908}
-    96 | {23,97,43}       | {AAAAAAAAAA646,A87088}
-(3 rows)
+ seqno | i | t 
+-------+---+---
+(0 rows)
 
 SELECT * FROM array_index_op_test WHERE t @> '{AAAAAAAA72908,AAAAAAAAAA646}' ORDER BY seqno;
- seqno |  i   |                                 t                                  
--------+------+--------------------------------------------------------------------
-    79 | {45} | {AAAAAAAAAA646,AAAAAAAAAAAAAAAAAAA70415,AAAAAA43678,AAAAAAAA72908}
-(1 row)
+ seqno | i | t 
+-------+---+---
+(0 rows)
 
 SELECT * FROM array_index_op_test WHERE t && '{AAAAAAAA72908,AAAAAAAAAA646}' ORDER BY seqno;
- seqno |           i           |                                                                     t                                                                      
--------+-----------------------+--------------------------------------------------------------------------------------------------------------------------------------------
-    15 | {17,14,16,63,67}      | {AA6416,AAAAAAAAAA646,AAAAA95309}
-    22 | {11,6,56,62,53,30}    | {AAAAAAAA72908}
-    45 | {99,45}               | {AAAAAAAA72908,AAAAAAAAAAAAAAAAAAA17075,AA88409,AAAAAAAAAAAAAAAAAA36842,AAAAAAA48038,AAAAAAAAAAAAAA10611}
-    72 | {22,1,16,78,20,91,83} | {47735,AAAAAAA56483,AAAAAAAAAAAAA93788,AA42406,AAAAAAAAAAAAA73084,AAAAAAAA72908,AAAAAAAAAAAAAAAAAA61286,AAAAA66674,AAAAAAAAAAAAAAAAA50407}
-    79 | {45}                  | {AAAAAAAAAA646,AAAAAAAAAAAAAAAAAAA70415,AAAAAA43678,AAAAAAAA72908}
-    96 | {23,97,43}            | {AAAAAAAAAA646,A87088}
-(6 rows)
+ seqno | i | t 
+-------+---+---
+(0 rows)
 
 SELECT * FROM array_index_op_test WHERE t <@ '{AAAAAAAA72908,AAAAAAAAAAAAAAAAAAA17075,AA88409,AAAAAAAAAAAAAAAAAA36842,AAAAAAA48038,AAAAAAAAAAAAAA10611}' ORDER BY seqno;
- seqno |         i          |                                                     t                                                     
--------+--------------------+-----------------------------------------------------------------------------------------------------------
-    22 | {11,6,56,62,53,30} | {AAAAAAAA72908}
-    45 | {99,45}            | {AAAAAAAA72908,AAAAAAAAAAAAAAAAAAA17075,AA88409,AAAAAAAAAAAAAAAAAA36842,AAAAAAA48038,AAAAAAAAAAAAAA10611}
-   101 | {}                 | {}
-(3 rows)
+ seqno | i | t 
+-------+---+---
+(0 rows)
 
 SELECT * FROM array_index_op_test WHERE t = '{AAAAAAAAAA646,A87088}' ORDER BY seqno;
- seqno |     i      |           t            
--------+------------+------------------------
-    96 | {23,97,43} | {AAAAAAAAAA646,A87088}
-(1 row)
+ seqno | i | t 
+-------+---+---
+(0 rows)
 
 SELECT * FROM array_index_op_test WHERE t = '{}' ORDER BY seqno;
- seqno | i  | t  
--------+----+----
-   101 | {} | {}
-(1 row)
+ seqno | i | t 
+-------+---+---
+(0 rows)
 
 SELECT * FROM array_index_op_test WHERE t @> '{}' ORDER BY seqno;
- seqno |                i                |                                                                                                       t                                                                                                        
--------+---------------------------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
-     1 | {92,75,71,52,64,83}             | {AAAAAAAA44066,AAAAAA1059,AAAAAAAAAAA176,AAAAAAA48038}
-     2 | {3,6}                           | {AAAAAA98232,AAAAAAAA79710,AAAAAAAAAAAAAAAAA69675,AAAAAAAAAAAAAAAA55798,AAAAAAAAA12793}
-     3 | {37,64,95,43,3,41,13,30,11,43}  | {AAAAAAAAAA48845,AAAAA75968,AAAAA95309,AAA54451,AAAAAAAAAA22292,AAAAAAA99836,A96617,AA17009,AAAAAAAAAAAAAA95246}
-     4 | {71,39,99,55,33,75,45}          | {AAAAAAAAA53663,AAAAAAAAAAAAAAA67062,AAAAAAAAAA64777,AAA99043,AAAAAAAAAAAAAAAAAAA91804,39557}
-     5 | {50,42,77,50,4}                 | {AAAAAAAAAAAAAAAAA26540,AAAAAAA79710,AAAAAAAAAAAAAAAAAAA1205,AAAAAAAAAAA176,AAAAA95309,AAAAAAAAAAA46154,AAAAAA66777,AAAAAAAAA27249,AAAAAAAAAA64777,AAAAAAAAAAAAAAAAAAA70104}
-     6 | {39,35,5,94,17,92,60,32}        | {AAAAAAAAAAAAAAA35875,AAAAAAAAAAAAAAAA23657}
-     7 | {12,51,88,64,8}                 | {AAAAAAAAAAAAAAAAAA12591,AAAAAAAAAAAAAAAAA50407,AAAAAAAAAAAA67946}
-     8 | {60,84}                         | {AAAAAAA81898,AAAAAA1059,AAAAAAAAAAAA81511,AAAAA961,AAAAAAAAAAAAAAAA31334,AAAAA64741,AA6416,AAAAAAAAAAAAAAAAAA32918,AAAAAAAAAAAAAAAAA50407}
-     9 | {56,52,35,27,80,44,81,22}       | {AAAAAAAAAAAAAAA73034,AAAAAAAAAAAAA7929,AAAAAAA66161,AA88409,39557,A27153,AAAAAAAA9523,AAAAAAAAAAA99000}
-    10 | {71,5,45}                       | {AAAAAAAAAAA21658,AAAAAAAAAAAA21089,AAA54451,AAAAAAAAAAAAAAAAAA54141,AAAAAAAAAAAAAA28620,AAAAAAAAAAA21658,AAAAAAAAAAA74076,AAAAAAAAA27249}
-    11 | {41,86,74,48,22,74,47,50}       | {AAAAAAAA9523,AAAAAAAAAAAA37562,AAAAAAAAAAAAAAAA14047,AAAAAAAAAAA46154,AAAA41702,AAAAAAAAAAAAAAAAA764,AAAAA62737,39557}
-    12 | {17,99,18,52,91,72,0,43,96,23}  | {AAAAA33250,AAAAAAAAAAAAAAAAAAA85420,AAAAAAAAAAA33576}
-    13 | {3,52,34,23}                    | {AAAAAA98232,AAAA49534,AAAAAAAAAAA21658}
-    14 | {78,57,19}                      | {AAAA8857,AAAAAAAAAAAAAAA73034,AAAAAAAA81587,AAAAAAAAAAAAAAA68526,AAAAA75968,AAAAAAAAAAAAAA65909,AAAAAAAAA10012,AAAAAAAAAAAAAA65909}
-    15 | {17,14,16,63,67}                | {AA6416,AAAAAAAAAA646,AAAAA95309}
-    16 | {14,63,85,11}                   | {AAAAAA66777}
-    17 | {7,10,81,85}                    | {AAAAAA43678,AAAAAAA12144,AAAAAAAAAAA50956,AAAAAAAAAAAAAAAAAAA15356}
-    18 | {1}                             | {AAAAAAAAAAA33576,AAAAA95309,64261,AAA59323,AAAAAAAAAAAAAA95246,55847,AAAAAAAAAAAA67946,AAAAAAAAAAAAAAAAAA64374}
-    19 | {52,82,17,74,23,46,69,51,75}    | {AAAAAAAAAAAAA73084,AAAAA75968,AAAAAAAAAAAAAAAA14047,AAAAAAA80240,AAAAAAAAAAAAAAAAAAA1205,A68938}
-    20 | {72,89,70,51,54,37,8,49,79}     | {AAAAAA58494}
-    21 | {2,8,65,10,5,79,43}             | {AAAAAAAAAAAAAAAAA88852,AAAAAAAAAAAAAAAAAAA91804,AAAAA64669,AAAAAAAAAAAAAAAA1443,AAAAAAAAAAAAAAAA23657,AAAAA12179,AAAAAAAAAAAAAAAAA88852,AAAAAAAAAAAAAAAA31334,AAAAAAAAAAAAAAAA41303,AAAAAAAAAAAAAAAAAAA85420}
-    22 | {11,6,56,62,53,30}              | {AAAAAAAA72908}
-    23 | {40,90,5,38,72,40,30,10,43,55}  | {A6053,AAAAAAAAAAA6119,AA44673,AAAAAAAAAAAAAAAAA764,AA17009,AAAAA17383,AAAAA70514,AAAAA33250,AAAAA95309,AAAAAAAAAAAA37562}
-    24 | {94,61,99,35,48}                | {AAAAAAAAAAA50956,AAAAAAAAAAA15165,AAAA85070,AAAAAAAAAAAAAAA36627,AAAAA961,AAAAAAAAAA55219}
-    25 | {31,1,10,11,27,79,38}           | {AAAAAAAAAAAAAAAAAA59334,45449}
-    26 | {71,10,9,69,75}                 | {47735,AAAAAAA21462,AAAAAAAAAAAAAAAAA6897,AAAAAAAAAAAAAAAAAAA91804,AAAAAAAAA72121,AAAAAAAAAAAAAAAAAAA1205,AAAAA41597,AAAA8857,AAAAAAAAAAAAAAAAAAA15356,AA17009}
-    27 | {94}                            | {AA6416,A6053,AAAAAAA21462,AAAAAAA57334,AAAAAAAAAAAAAAAAAA12591,AA88409,AAAAAAAAAAAAA70254}
-    28 | {14,33,6,34,14}                 | {AAAAAAAAAAAAAAA13198,AAAAAAAA69452,AAAAAAAAAAA82945,AAAAAAA12144,AAAAAAAAA72121,AAAAAAAAAA18601}
-    29 | {39,21}                         | {AAAAAAAAAAAAAAAAA6897,AAAAAAAAAAAAAAAAAAA38885,AAAA85070,AAAAAAAAAAAAAAAAAAA70104,AAAAA66674,AAAAAAAAAAAAA62007,AAAAAAAA69452,AAAAAAA1242,AAAAAAAAAAAAAAAA1729,AAAA35194}
-    30 | {26,81,47,91,34}                | {AAAAAAAAAAAAAAAAAAA70104,AAAAAAA80240}
-    31 | {80,24,18,21,54}                | {AAAAAAAAAAAAAAA13198,AAAAAAAAAAAAAAAAAAA70415,A27153,AAAAAAAAA53663,AAAAAAAAAAAAAAAAA50407,A68938}
-    32 | {58,79,82,80,67,75,98,10,41}    | {AAAAAAAAAAAAAAAAAA61286,AAA54451,AAAAAAAAAAAAAAAAAAA87527,A96617,51533}
-    33 | {74,73}                         | {A85417,AAAAAAA56483,AAAAA17383,AAAAAAAAAAAAA62159,AAAAAAAAAAAA52814,AAAAAAAAAAAAA85723,AAAAAAAAAAAAAAAAAA55796}
-    34 | {70,45}                         | {AAAAAAAAAAAAAAAAAA71621,AAAAAAAAAAAAAA28620,AAAAAAAAAA55219,AAAAAAAA23648,AAAAAAAAAA22292,AAAAAAA1242}
-    35 | {23,40}                         | {AAAAAAAAAAAA52814,AAAA48949,AAAAAAAAA34727,AAAA8857,AAAAAAAAAAAAAAAAAAA62179,AAAAAAAAAAAAAAA68526,AAAAAAA99836,AAAAAAAA50094,AAAA91194,AAAAAAAAAAAAA73084}
-    36 | {79,82,14,52,30,5,79}           | {AAAAAAAAA53663,AAAAAAAAAAAAAAAA55798,AAAAAAAAAAAAAAAAAAA89194,AA88409,AAAAAAAAAAAAAAA81326,AAAAAAAAAAAAAAAAA63050,AAAAAAAAAAAAAAAA33598}
-    37 | {53,11,81,39,3,78,58,64,74}     | {AAAAAAAAAAAAAAAAAAA17075,AAAAAAA66161,AAAAAAAA23648,AAAAAAAAAAAAAA10611}
-    38 | {59,5,4,95,28}                  | {AAAAAAAAAAA82945,A96617,47735,AAAAA12179,AAAAA64669,AAAAAA99807,AA74433,AAAAAAAAAAAAAAAAA59387}
-    39 | {82,43,99,16,74}                | {AAAAAAAAAAAAAAA67062,AAAAAAA57334,AAAAAAAAAAAAAA65909,A27153,AAAAAAAAAAAAAAAAAAA17075,AAAAAAAAAAAAAAAAA43052,AAAAAAAAAA64777,AAAAAAAAAAAA81511,AAAAAAAAAAAAAA65909,AAAAAAAAAAAAAA28620}
-    40 | {34}                            | {AAAAAAAAAAAAAA10611,AAAAAAAAAAAAAAAAAAA1205,AAAAAAAAAAA50956,AAAAAAAAAAAAAAAA31334,AAAAA70466,AAAAAAAA81587,AAAAAAA74623}
-    41 | {19,26,63,12,93,73,27,94}       | {AAAAAAA79710,AAAAAAAAAA55219,AAAA41702,AAAAAAAAAAAAAAAAAAA17075,AAAAAAAAAAAAAAAAAA71621,AAAAAAAAAAAAAAAAA63050,AAAAAAA99836,AAAAAAAAAAAAAA8666}
-    42 | {15,76,82,75,8,91}              | {AAAAAAAAAAA176,AAAAAA38063,45449,AAAAAA54032,AAAAAAA81898,AA6416,AAAAAAAAAAAAAAAAAAA62179,45449,AAAAA60038,AAAAAAAA81587}
-    43 | {39,87,91,97,79,28}             | {AAAAAAAAAAA74076,A96617,AAAAAAAAAAAAAAAAAAA89194,AAAAAAAAAAAAAAAAAA55796,AAAAAAAAAAAAAAAA23657,AAAAAAAAAAAA67946}
-    44 | {40,58,68,29,54}                | {AAAAAAA81898,AAAAAA66777,AAAAAA98232}
-    45 | {99,45}                         | {AAAAAAAA72908,AAAAAAAAAAAAAAAAAAA17075,AA88409,AAAAAAAAAAAAAAAAAA36842,AAAAAAA48038,AAAAAAAAAAAAAA10611}
-    46 | {53,24}                         | {AAAAAAAAAAA53908,AAAAAA54032,AAAAA17383,AAAA48949,AAAAAAAAAA18601,AAAAA64669,45449,AAAAAAAAAAA98051,AAAAAAAAAAAAAAAAAA71621}
-    47 | {98,23,64,12,75,61}             | {AAA59323,AAAAA95309,AAAAAAAAAAAAAAAA31334,AAAAAAAAA27249,AAAAA17383,AAAAAAAAAAAA37562,AAAAAA1059,A84822,55847,AAAAA70466}
-    48 | {76,14}                         | {AAAAAAAAAAAAA59671,AAAAAAAAAAAAAAAAAAA91804,AAAAAA66777,AAAAAAAAAAAAAAAAAAA89194,AAAAAAAAAAAAAAA36627,AAAAAAAAAAAAAAAAAAA17075,AAAAAAAAAAAAA73084,AAAAAAA79710,AAAAAAAAAAAAAAA40402,AAAAAAAAAAAAAAAAAAA65037}
-    49 | {56,5,54,37,49}                 | {AA21643,AAAAAAAAAAA92631,AAAAAAAA81587}
-    50 | {20,12,37,64,93}                | {AAAAAAAAAA5483,AAAAAAAAAAAAAAAAAAA1205,AA6416,AAAAAAAAAAAAAAAAA63050,AAAAAAAAAAAAAAAAAA47955}
-    51 | {47}                            | {AAAAAAAAAAAAAA96505,AAAAAAAAAAAAAAAAAA36842,AAAAA95309,AAAAAAAA81587,AA6416,AAAA91194,AAAAAA58494,AAAAAA1059,AAAAAAAA69452}
-    52 | {89,0}                          | {AAAAAAAAAAAAAAAAAA47955,AAAAAAA48038,AAAAAAAAAAAAAAAAA43052,AAAAAAAAAAAAA73084,AAAAA70466,AAAAAAAAAAAAAAAAA764,AAAAAAAAAAA46154,AA66862}
-    53 | {38,17}                         | {AAAAAAAAAAA21658}
-    54 | {70,47}                         | {AAAAAAAAAAAAAAAAAA54141,AAAAA40681,AAAAAAA48038,AAAAAAAAAAAAAAAA29150,AAAAA41597,AAAAAAAAAAAAAAAAAA59334,AA15322}
-    55 | {47,79,47,64,72,25,71,24,93}    | {AAAAAAAAAAAAAAAAAA55796,AAAAA62737}
-    56 | {33,7,60,54,93,90,77,85,39}     | {AAAAAAAAAAAAAAAAAA32918,AA42406}
-    57 | {23,45,10,42,36,21,9,96}        | {AAAAAAAAAAAAAAAAAAA70415}
-    58 | {92}                            | {AAAAAAAAAAAAAAAA98414,AAAAAAAA23648,AAAAAAAAAAAAAAAAAA55796,AA25381,AAAAAAAAAAA6119}
-    59 | {9,69,46,77}                    | {39557,AAAAAAA89932,AAAAAAAAAAAAAAAAA43052,AAAAAAAAAAAAAAAAA26540,AAA20874,AA6416,AAAAAAAAAAAAAAAAAA47955}
-    60 | {62,2,59,38,89}                 | {AAAAAAA89932,AAAAAAAAAAAAAAAAAAA15356,AA99927,AA17009,AAAAAAAAAAAAAAA35875}
-    61 | {72,2,44,95,54,54,13}           | {AAAAAAAAAAAAAAAAAAA91804}
-    62 | {83,72,29,73}                   | {AAAAAAAAAAAAA15097,AAAA8857,AAAAAAAAAAAA35809,AAAAAAAAAAAA52814,AAAAAAAAAAAAAAAAAAA38885,AAAAAAAAAAAAAAAAAA24183,AAAAAA43678,A96617}
-    63 | {11,4,61,87}                    | {AAAAAAAAA27249,AAAAAAAAAAAAAAAAAA32918,AAAAAAAAAAAAAAA13198,AAA20874,39557,51533,AAAAAAAAAAA53908,AAAAAAAAAAAAAA96505,AAAAAAAA78938}
-    64 | {26,19,34,24,81,78}             | {A96617,AAAAAAAAAAAAAAAAAAA70104,A68938,AAAAAAAAAAA53908,AAAAAAAAAAAAAAA453,AA17009,AAAAAAA80240}
-    65 | {61,5,76,59,17}                 | {AAAAAA99807,AAAAA64741,AAAAAAAAAAA53908,AA21643,AAAAAAAAA10012}
-    66 | {31,23,70,52,4,33,48,25}        | {AAAAAAAAAAAAAAAAA69675,AAAAAAAA50094,AAAAAAAAAAA92631,AAAA35194,39557,AAAAAAA99836}
-    67 | {31,94,7,10}                    | {AAAAAA38063,A96617,AAAA35194,AAAAAAAAAAAA67946}
-    68 | {90,43,38}                      | {AA75092,AAAAAAAAAAAAAAAAA69675,AAAAAAAAAAA92631,AAAAAAAAA10012,AAAAAAAAAAAAA7929,AA21643}
-    69 | {67,35,99,85,72,86,44}          | {AAAAAAAAAAAAAAAAAAA1205,AAAAAAAA50094,AAAAAAAAAAAAAAAA1729,AAAAAAAAAAAAAAAAAA47955}
-    70 | {56,70,83}                      | {AAAA41702,AAAAAAAAAAA82945,AA21643,AAAAAAAAAAA99000,A27153,AA25381,AAAAAAAAAAAAAA96505,AAAAAAA1242}
-    71 | {74,26}                         | {AAAAAAAAAAA50956,AA74433,AAAAAAA21462,AAAAAAAAAAAAAAAAAAA17075,AAAAAAAAAAAAAAA36627,AAAAAAAAAAAAA70254,AAAAAAAAAA43419,39557}
-    72 | {22,1,16,78,20,91,83}           | {47735,AAAAAAA56483,AAAAAAAAAAAAA93788,AA42406,AAAAAAAAAAAAA73084,AAAAAAAA72908,AAAAAAAAAAAAAAAAAA61286,AAAAA66674,AAAAAAAAAAAAAAAAA50407}
-    73 | {88,25,96,78,65,15,29,19}       | {AAA54451,AAAAAAAAA27249,AAAAAAA9228,AAAAAAAAAAAAAAA67062,AAAAAAAAAAAAAAAAAAA70415,AAAAA17383,AAAAAAAAAAAAAAAA33598}
-    74 | {32}                            | {AAAAAAAAAAAAAAAA1729,AAAAAAAAAAAAA22860,AAAAAA99807,AAAAA17383,AAAAAAAAAAAAAAA67062,AAAAAAAAAAA15165,AAAAAAAAAAA50956}
-    75 | {12,96,83,24,71,89,55}          | {AAAA48949,AAAAAAAA29716,AAAAAAAAAAAAAAAAAAA1205,AAAAAAAAAAAA67946,AAAAAAAAAAAAAAAA29150,AAA28075,AAAAAAAAAAAAAAAAA43052}
-    76 | {92,55,10,7}                    | {AAAAAAAAAAAAAAA67062}
-    77 | {97,15,32,17,55,59,18,37,50,39} | {AAAAAAAAAAAA67946,AAAAAA54032,AAAAAAAA81587,55847,AAAAAAAAAAAAAA28620,AAAAAAAAAAAAAAAAA43052,AAAAAA75463,AAAA49534,AAAAAAAA44066}
-    78 | {55,89,44,84,34}                | {AAAAAAAAAAA6119,AAAAAAAAAAAAAA8666,AA99927,AA42406,AAAAAAA81898,AAAAAAA9228,AAAAAAAAAAA92631,AA21643,AAAAAAAAAAAAAA28620}
-    79 | {45}                            | {AAAAAAAAAA646,AAAAAAAAAAAAAAAAAAA70415,AAAAAA43678,AAAAAAAA72908}
-    80 | {74,89,44,80,0}                 | {AAAA35194,AAAAAAAA79710,AAA20874,AAAAAAAAAAAAAAAAAAA70104,AAAAAAAAAAAAA73084,AAAAAAA57334,AAAAAAA9228,AAAAAAAAAAAAA62007}
-    81 | {63,77,54,48,61,53,97}          | {AAAAAAAAAAAAAAA81326,AAAAAAAAAA22292,AA25381,AAAAAAAAAAA74076,AAAAAAA81898,AAAAAAAAA72121}
-    82 | {34,60,4,79,78,16,86,89,42,50}  | {AAAAA40681,AAAAAAAAAAAAAAAAAA12591,AAAAAAA80240,AAAAAAAAAAAAAAAA55798,AAAAAAAAAAAAAAAAAAA70104}
-    83 | {14,10}                         | {AAAAAAAAAA22292,AAAAAAAAAAAAA70254,AAAAAAAAAAA6119}
-    84 | {11,83,35,13,96,94}             | {AAAAA95309,AAAAAAAAAAAAAAAAAA32918,AAAAAAAAAAAAAAAAAA24183}
-    85 | {39,60}                         | {AAAAAAAAAAAAAAAA55798,AAAAAAAAAA22292,AAAAAAA66161,AAAAAAA21462,AAAAAAAAAAAAAAAAAA12591,55847,AAAAAA98232,AAAAAAAAAAA46154}
-    86 | {33,81,72,74,45,36,82}          | {AAAAAAAA81587,AAAAAAAAAAAAAA96505,45449,AAAA80176}
-    87 | {57,27,50,12,97,68}             | {AAAAAAAAAAAAAAAAA26540,AAAAAAAAA10012,AAAAAAAAAAAA35809,AAAAAAAAAAAAAAAA29150,AAAAAAAAAAA82945,AAAAAA66777,31228,AAAAAAAAAAAAAAAA23657,AAAAAAAAAAAAAA28620,AAAAAAAAAAAAAA96505}
-    88 | {41,90,77,24,6,24}              | {AAAA35194,AAAA35194,AAAAAAA80240,AAAAAAAAAAA46154,AAAAAA58494,AAAAAAAAAAAAAAAAAAA17075,AAAAAAAAAAAAAAAAAA59334,AAAAAAAAAAAAAAAAAAA91804,AA74433}
-    89 | {40,32,17,6,30,88}              | {AA44673,AAAAAAAAAAA6119,AAAAAAAAAAAAAAAA23657,AAAAAAAAAAAAAAAAAA47955,AAAAAAAAAAAAAAAA33598,AAAAAAAAAAA33576,AA44673}
-    90 | {88,75}                         | {AAAAA60038,AAAAAAAA23648,AAAAAAAAAAA99000,AAAA41702,AAAAAAAAAAAAA22860,AAAAAAAAAAAAAAA68526}
-    91 | {78}                            | {AAAAAAAAAAAAA62007,AAA99043}
-    92 | {85,63,49,45}                   | {AAAAAAA89932,AAAAAAAAAAAAA22860,AAAAAAAAAAAAAAAAAAA1205,AAAAAAAAAAAA21089}
-    93 | {11}                            | {AAAAAAAAAAA176,AAAAAAAAAAAAAA8666,AAAAAAAAAAAAAAA453,AAAAAAAAAAAAA85723,A68938,AAAAAAAAAAAAA9821,AAAAAAA48038,AAAAAAAAAAAAAAAAA59387,AA99927,AAAAA17383}
-    94 | {98,9,85,62,88,91,60,61,38,86}  | {AAAAAAAA81587,AAAAA17383,AAAAAAAA81587}
-    95 | {47,77}                         | {AAAAAAAAAAAAAAAAA764,AAAAAAAAAAA74076,AAAAAAAAAA18107,AAAAA40681,AAAAAAAAAAAAAAA35875,AAAAA60038,AAAAAAA56483}
-    96 | {23,97,43}                      | {AAAAAAAAAA646,A87088}
-    97 | {54,2,86,65}                    | {47735,AAAAAAA99836,AAAAAAAAAAAAAAAAA6897,AAAAAAAAAAAAAAAA29150,AAAAAAA80240,AAAAAAAAAAAAAAAA98414,AAAAAAA56483,AAAAAAAAAAAAAAAA29150,AAAAAAA39692,AA21643}
-    98 | {38,34,32,89}                   | {AAAAAAAAAAAAAAAAAA71621,AAAA8857,AAAAAAAAAAAAAAAAAAA65037,AAAAAAAAAAAAAAAA31334,AAAAAAAAAA48845}
-    99 | {37,86}                         | {AAAAAAAAAAAAAAAAAA32918,AAAAA70514,AAAAAAAAA10012,AAAAAAAAAAAAAAAAA59387,AAAAAAAAAA64777,AAAAAAAAAAAAAAAAAAA15356}
-   100 | {85,32,57,39,49,84,32,3,30}     | {AAAAAAA80240,AAAAAAAAAAAAAAAA1729,AAAAA60038,AAAAAAAAAAA92631,AAAAAAAA9523}
-   101 | {}                              | {}
-   102 | {NULL}                          | {NULL}
-(102 rows)
+ seqno | i | t 
+-------+---+---
+(0 rows)
 
 SELECT * FROM array_index_op_test WHERE t && '{}' ORDER BY seqno;
  seqno | i | t 
@@ -1103,81 +843,78 @@
 (0 rows)
 
 SELECT * FROM array_index_op_test WHERE t <@ '{}' ORDER BY seqno;
- seqno | i  | t  
--------+----+----
-   101 | {} | {}
-(1 row)
+ seqno | i | t 
+-------+---+---
+(0 rows)
 
 -- And try it with a multicolumn GIN index
 DROP INDEX intarrayidx, textarrayidx;
+NOTICE:  the data for dropped indexes is reclaimed asynchronously
+HINT:  The reclamation delay can be customized in the zone configuration for the table.
 CREATE INDEX botharrayidx ON array_index_op_test USING gin (i, t);
 SELECT * FROM array_index_op_test WHERE i @> '{32}' ORDER BY seqno;
- seqno |                i                |                                                                 t                                                                  
--------+---------------------------------+------------------------------------------------------------------------------------------------------------------------------------
-     6 | {39,35,5,94,17,92,60,32}        | {AAAAAAAAAAAAAAA35875,AAAAAAAAAAAAAAAA23657}
-    74 | {32}                            | {AAAAAAAAAAAAAAAA1729,AAAAAAAAAAAAA22860,AAAAAA99807,AAAAA17383,AAAAAAAAAAAAAAA67062,AAAAAAAAAAA15165,AAAAAAAAAAA50956}
-    77 | {97,15,32,17,55,59,18,37,50,39} | {AAAAAAAAAAAA67946,AAAAAA54032,AAAAAAAA81587,55847,AAAAAAAAAAAAAA28620,AAAAAAAAAAAAAAAAA43052,AAAAAA75463,AAAA49534,AAAAAAAA44066}
-    89 | {40,32,17,6,30,88}              | {AA44673,AAAAAAAAAAA6119,AAAAAAAAAAAAAAAA23657,AAAAAAAAAAAAAAAAAA47955,AAAAAAAAAAAAAAAA33598,AAAAAAAAAAA33576,AA44673}
-    98 | {38,34,32,89}                   | {AAAAAAAAAAAAAAAAAA71621,AAAA8857,AAAAAAAAAAAAAAAAAAA65037,AAAAAAAAAAAAAAAA31334,AAAAAAAAAA48845}
-   100 | {85,32,57,39,49,84,32,3,30}     | {AAAAAAA80240,AAAAAAAAAAAAAAAA1729,AAAAA60038,AAAAAAAAAAA92631,AAAAAAAA9523}
-(6 rows)
+ seqno | i | t 
+-------+---+---
+(0 rows)
 
 SELECT * FROM array_index_op_test WHERE i && '{32}' ORDER BY seqno;
- seqno |                i                |                                                                 t                                                                  
--------+---------------------------------+------------------------------------------------------------------------------------------------------------------------------------
-     6 | {39,35,5,94,17,92,60,32}        | {AAAAAAAAAAAAAAA35875,AAAAAAAAAAAAAAAA23657}
-    74 | {32}                            | {AAAAAAAAAAAAAAAA1729,AAAAAAAAAAAAA22860,AAAAAA99807,AAAAA17383,AAAAAAAAAAAAAAA67062,AAAAAAAAAAA15165,AAAAAAAAAAA50956}
-    77 | {97,15,32,17,55,59,18,37,50,39} | {AAAAAAAAAAAA67946,AAAAAA54032,AAAAAAAA81587,55847,AAAAAAAAAAAAAA28620,AAAAAAAAAAAAAAAAA43052,AAAAAA75463,AAAA49534,AAAAAAAA44066}
-    89 | {40,32,17,6,30,88}              | {AA44673,AAAAAAAAAAA6119,AAAAAAAAAAAAAAAA23657,AAAAAAAAAAAAAAAAAA47955,AAAAAAAAAAAAAAAA33598,AAAAAAAAAAA33576,AA44673}
-    98 | {38,34,32,89}                   | {AAAAAAAAAAAAAAAAAA71621,AAAA8857,AAAAAAAAAAAAAAAAAAA65037,AAAAAAAAAAAAAAAA31334,AAAAAAAAAA48845}
-   100 | {85,32,57,39,49,84,32,3,30}     | {AAAAAAA80240,AAAAAAAAAAAAAAAA1729,AAAAA60038,AAAAAAAAAAA92631,AAAAAAAA9523}
-(6 rows)
+ seqno | i | t 
+-------+---+---
+(0 rows)
 
 SELECT * FROM array_index_op_test WHERE t @> '{AAAAAAA80240}' ORDER BY seqno;
- seqno |               i                |                                                                              t                                                                              
--------+--------------------------------+-------------------------------------------------------------------------------------------------------------------------------------------------------------
-    19 | {52,82,17,74,23,46,69,51,75}   | {AAAAAAAAAAAAA73084,AAAAA75968,AAAAAAAAAAAAAAAA14047,AAAAAAA80240,AAAAAAAAAAAAAAAAAAA1205,A68938}
-    30 | {26,81,47,91,34}               | {AAAAAAAAAAAAAAAAAAA70104,AAAAAAA80240}
-    64 | {26,19,34,24,81,78}            | {A96617,AAAAAAAAAAAAAAAAAAA70104,A68938,AAAAAAAAAAA53908,AAAAAAAAAAAAAAA453,AA17009,AAAAAAA80240}
-    82 | {34,60,4,79,78,16,86,89,42,50} | {AAAAA40681,AAAAAAAAAAAAAAAAAA12591,AAAAAAA80240,AAAAAAAAAAAAAAAA55798,AAAAAAAAAAAAAAAAAAA70104}
-    88 | {41,90,77,24,6,24}             | {AAAA35194,AAAA35194,AAAAAAA80240,AAAAAAAAAAA46154,AAAAAA58494,AAAAAAAAAAAAAAAAAAA17075,AAAAAAAAAAAAAAAAAA59334,AAAAAAAAAAAAAAAAAAA91804,AA74433}
-    97 | {54,2,86,65}                   | {47735,AAAAAAA99836,AAAAAAAAAAAAAAAAA6897,AAAAAAAAAAAAAAAA29150,AAAAAAA80240,AAAAAAAAAAAAAAAA98414,AAAAAAA56483,AAAAAAAAAAAAAAAA29150,AAAAAAA39692,AA21643}
-   100 | {85,32,57,39,49,84,32,3,30}    | {AAAAAAA80240,AAAAAAAAAAAAAAAA1729,AAAAA60038,AAAAAAAAAAA92631,AAAAAAAA9523}
-(7 rows)
+ seqno | i | t 
+-------+---+---
+(0 rows)
 
 SELECT * FROM array_index_op_test WHERE t && '{AAAAAAA80240}' ORDER BY seqno;
- seqno |               i                |                                                                              t                                                                              
--------+--------------------------------+-------------------------------------------------------------------------------------------------------------------------------------------------------------
-    19 | {52,82,17,74,23,46,69,51,75}   | {AAAAAAAAAAAAA73084,AAAAA75968,AAAAAAAAAAAAAAAA14047,AAAAAAA80240,AAAAAAAAAAAAAAAAAAA1205,A68938}
-    30 | {26,81,47,91,34}               | {AAAAAAAAAAAAAAAAAAA70104,AAAAAAA80240}
-    64 | {26,19,34,24,81,78}            | {A96617,AAAAAAAAAAAAAAAAAAA70104,A68938,AAAAAAAAAAA53908,AAAAAAAAAAAAAAA453,AA17009,AAAAAAA80240}
-    82 | {34,60,4,79,78,16,86,89,42,50} | {AAAAA40681,AAAAAAAAAAAAAAAAAA12591,AAAAAAA80240,AAAAAAAAAAAAAAAA55798,AAAAAAAAAAAAAAAAAAA70104}
-    88 | {41,90,77,24,6,24}             | {AAAA35194,AAAA35194,AAAAAAA80240,AAAAAAAAAAA46154,AAAAAA58494,AAAAAAAAAAAAAAAAAAA17075,AAAAAAAAAAAAAAAAAA59334,AAAAAAAAAAAAAAAAAAA91804,AA74433}
-    97 | {54,2,86,65}                   | {47735,AAAAAAA99836,AAAAAAAAAAAAAAAAA6897,AAAAAAAAAAAAAAAA29150,AAAAAAA80240,AAAAAAAAAAAAAAAA98414,AAAAAAA56483,AAAAAAAAAAAAAAAA29150,AAAAAAA39692,AA21643}
-   100 | {85,32,57,39,49,84,32,3,30}    | {AAAAAAA80240,AAAAAAAAAAAAAAAA1729,AAAAA60038,AAAAAAAAAAA92631,AAAAAAAA9523}
-(7 rows)
+ seqno | i | t 
+-------+---+---
+(0 rows)
 
 SELECT * FROM array_index_op_test WHERE i @> '{32}' AND t && '{AAAAAAA80240}' ORDER BY seqno;
- seqno |              i              |                                      t                                       
--------+-----------------------------+------------------------------------------------------------------------------
-   100 | {85,32,57,39,49,84,32,3,30} | {AAAAAAA80240,AAAAAAAAAAAAAAAA1729,AAAAA60038,AAAAAAAAAAA92631,AAAAAAAA9523}
-(1 row)
+ seqno | i | t 
+-------+---+---
+(0 rows)
 
 SELECT * FROM array_index_op_test WHERE i && '{32}' AND t @> '{AAAAAAA80240}' ORDER BY seqno;
- seqno |              i              |                                      t                                       
--------+-----------------------------+------------------------------------------------------------------------------
-   100 | {85,32,57,39,49,84,32,3,30} | {AAAAAAA80240,AAAAAAAAAAAAAAAA1729,AAAAA60038,AAAAAAAAAAA92631,AAAAAAAA9523}
-(1 row)
+ seqno | i | t 
+-------+---+---
+(0 rows)
 
 SELECT * FROM array_index_op_test WHERE t = '{}' ORDER BY seqno;
- seqno | i  | t  
--------+----+----
-   101 | {} | {}
-(1 row)
+ seqno | i | t 
+-------+---+---
+(0 rows)
 
 RESET enable_seqscan;
+WARNING:  setting session var "enable_seqscan" is a no-op
 RESET enable_indexscan;
+ERROR:  unimplemented: the configuration setting "enable_indexscan" is not supported
+HINT:  You have attempted to use a feature that is not yet implemented.
+
+Please check the public issue tracker to check whether this problem is
+already tracked. If you cannot find it there, please report the error
+with details by creating a new issue.
+
+If you would rather not post publicly, please contact us directly
+using the support form.
+
+We appreciate your feedback.
+
 RESET enable_bitmapscan;
+ERROR:  unimplemented: the configuration setting "enable_bitmapscan" is not supported
+HINT:  You have attempted to use a feature that is not yet implemented.
+
+Please check the public issue tracker to check whether this problem is
+already tracked. If you cannot find it there, please report the error
+with details by creating a new issue.
+
+If you would rather not post publicly, please contact us directly
+using the support form.
+
+We appreciate your feedback.
+
 --
 -- Try a GIN index with a lot of items with same key. (GIN creates a posting
 -- tree when there are enough duplicates)
@@ -1197,36 +934,80 @@
 --
 CREATE INDEX gin_relopts_test ON array_index_op_test USING gin (i)
   WITH (FASTUPDATE=on, GIN_PENDING_LIST_LIMIT=128);
+ERROR:  unimplemented: storage parameter "fastupdate"
+HINT:  You have attempted to use a feature that is not yet implemented.
+See: https://go.crdb.dev/issue-v/43299/_version_
 \d+ gin_relopts_test
-                Index "public.gin_relopts_test"
- Column |  Type   | Key? | Definition | Storage | Stats target 
---------+---------+------+------------+---------+--------------
- i      | integer | yes  | i          | plain   | 
-gin, for table "public.array_index_op_test"
-Options: fastupdate=on, gin_pending_list_limit=128
-
+ERROR:  at or near ".": syntax error
+DETAIL:  source SQL:
+SELECT c.oid,
+  n.nspname,
+  c.relname
+FROM pg_catalog.pg_class c
+     LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace
+WHERE c.relname OPERATOR(pg_catalog.~) '^(gin_relopts_test)$' COLLATE pg_catalog.default
+                                                                                ^
 --
 -- HASH
 --
 CREATE UNLOGGED TABLE unlogged_hash_table (id int4);
+NOTICE:  UNLOGGED TABLE will behave as a regular table in CockroachDB
 CREATE INDEX unlogged_hash_index ON unlogged_hash_table USING hash (id int4_ops);
+ERROR:  at or near "hash": syntax error: unimplemented: this syntax
+DETAIL:  source SQL:
+CREATE INDEX unlogged_hash_index ON unlogged_hash_table USING hash (id int4_ops)
+                                                              ^
+HINT:  You have attempted to use a feature that is not yet implemented.
+
+Please check the public issue tracker to check whether this problem is
+already tracked. If you cannot find it there, please report the error
+with details by creating a new issue.
+
+If you would rather not post publicly, please contact us directly
+using the support form.
+
+We appreciate your feedback.
+
 DROP TABLE unlogged_hash_table;
 -- CREATE INDEX hash_ovfl_index ON hash_ovfl_heap USING hash (x int4_ops);
 -- Test hash index build tuplesorting.  Force hash tuplesort using low
 -- maintenance_work_mem setting and fillfactor:
 SET maintenance_work_mem = '1MB';
+ERROR:  unimplemented: the configuration setting "maintenance_work_mem" is not supported
+HINT:  You have attempted to use a feature that is not yet implemented.
+
+Please check the public issue tracker to check whether this problem is
+already tracked. If you cannot find it there, please report the error
+with details by creating a new issue.
+
+If you would rather not post publicly, please contact us directly
+using the support form.
+
+We appreciate your feedback.
+
 CREATE INDEX hash_tuplesort_idx ON tenk1 USING hash (stringu1 name_ops) WITH (fillfactor = 10);
+ERROR:  at or near "hash": syntax error: unimplemented: this syntax
+DETAIL:  source SQL:
+CREATE INDEX hash_tuplesort_idx ON tenk1 USING hash (stringu1 name_ops) WITH (fillfactor = 10)
+                                               ^
+HINT:  You have attempted to use a feature that is not yet implemented.
+
+Please check the public issue tracker to check whether this problem is
+already tracked. If you cannot find it there, please report the error
+with details by creating a new issue.
+
+If you would rather not post publicly, please contact us directly
+using the support form.
+
+We appreciate your feedback.
+
 EXPLAIN (COSTS OFF)
 SELECT count(*) FROM tenk1 WHERE stringu1 = 'TVAAAA';
-                      QUERY PLAN                       
--------------------------------------------------------
- Aggregate
-   ->  Bitmap Heap Scan on tenk1
-         Recheck Cond: (stringu1 = 'TVAAAA'::name)
-         ->  Bitmap Index Scan on hash_tuplesort_idx
-               Index Cond: (stringu1 = 'TVAAAA'::name)
-(5 rows)
-
+ERROR:  at or near "off": syntax error
+DETAIL:  source SQL:
+EXPLAIN (COSTS OFF)
+               ^
+HINT:  try \h <SELECTCLAUSE>
 SELECT count(*) FROM tenk1 WHERE stringu1 = 'TVAAAA';
  count 
 -------
@@ -1234,13 +1015,34 @@
 (1 row)
 
 DROP INDEX hash_tuplesort_idx;
+ERROR:  index "hash_tuplesort_idx" does not exist
 RESET maintenance_work_mem;
+ERROR:  unimplemented: the configuration setting "maintenance_work_mem" is not supported
+HINT:  You have attempted to use a feature that is not yet implemented.
+
+Please check the public issue tracker to check whether this problem is
+already tracked. If you cannot find it there, please report the error
+with details by creating a new issue.
+
+If you would rather not post publicly, please contact us directly
+using the support form.
+
+We appreciate your feedback.
+
 --
 -- Test unique null behavior
 --
 CREATE TABLE unique_tbl (i int, t text);
 CREATE UNIQUE INDEX unique_idx1 ON unique_tbl (i) NULLS DISTINCT;
+ERROR:  at or near "nulls": syntax error
+DETAIL:  source SQL:
+CREATE UNIQUE INDEX unique_idx1 ON unique_tbl (i) NULLS DISTINCT
+                                                  ^
 CREATE UNIQUE INDEX unique_idx2 ON unique_tbl (i) NULLS NOT DISTINCT;
+ERROR:  at or near "nulls": syntax error
+DETAIL:  source SQL:
+CREATE UNIQUE INDEX unique_idx2 ON unique_tbl (i) NULLS NOT DISTINCT
+                                                  ^
 INSERT INTO unique_tbl VALUES (1, 'one');
 INSERT INTO unique_tbl VALUES (2, 'two');
 INSERT INTO unique_tbl VALUES (3, 'three');
@@ -1248,120 +1050,135 @@
 INSERT INTO unique_tbl VALUES (5, 'one');
 INSERT INTO unique_tbl (t) VALUES ('six');
 INSERT INTO unique_tbl (t) VALUES ('seven');  -- error from unique_idx2
-ERROR:  duplicate key value violates unique constraint "unique_idx2"
-DETAIL:  Key (i)=(null) already exists.
 DROP INDEX unique_idx1, unique_idx2;
+ERROR:  index "unique_idx1" does not exist
 INSERT INTO unique_tbl (t) VALUES ('seven');
 -- build indexes on filled table
 CREATE UNIQUE INDEX unique_idx3 ON unique_tbl (i) NULLS DISTINCT;  -- ok
+ERROR:  at or near "nulls": syntax error
+DETAIL:  source SQL:
+CREATE UNIQUE INDEX unique_idx3 ON unique_tbl (i) NULLS DISTINCT
+                                                  ^
 CREATE UNIQUE INDEX unique_idx4 ON unique_tbl (i) NULLS NOT DISTINCT;  -- error
-ERROR:  could not create unique index "unique_idx4"
-DETAIL:  Key (i)=(null) is duplicated.
+ERROR:  at or near "nulls": syntax error
+DETAIL:  source SQL:
+CREATE UNIQUE INDEX unique_idx4 ON unique_tbl (i) NULLS NOT DISTINCT
+                                                  ^
 DELETE FROM unique_tbl WHERE t = 'seven';
 CREATE UNIQUE INDEX unique_idx4 ON unique_tbl (i) NULLS NOT DISTINCT;  -- ok now
+ERROR:  at or near "nulls": syntax error
+DETAIL:  source SQL:
+CREATE UNIQUE INDEX unique_idx4 ON unique_tbl (i) NULLS NOT DISTINCT
+                                                  ^
 \d unique_tbl
-             Table "public.unique_tbl"
- Column |  Type   | Collation | Nullable | Default 
---------+---------+-----------+----------+---------
- i      | integer |           |          | 
- t      | text    |           |          | 
-Indexes:
-    "unique_idx3" UNIQUE, btree (i)
-    "unique_idx4" UNIQUE, btree (i) NULLS NOT DISTINCT
-
+ERROR:  at or near ".": syntax error
+DETAIL:  source SQL:
+SELECT c.oid,
+  n.nspname,
+  c.relname
+FROM pg_catalog.pg_class c
+     LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace
+WHERE c.relname OPERATOR(pg_catalog.~) '^(unique_tbl)$' COLLATE pg_catalog.default
+                                                                          ^
 \d unique_idx3
-      Index "public.unique_idx3"
- Column |  Type   | Key? | Definition 
---------+---------+------+------------
- i      | integer | yes  | i
-unique, btree, for table "public.unique_tbl"
-
+ERROR:  at or near ".": syntax error
+DETAIL:  source SQL:
+SELECT c.oid,
+  n.nspname,
+  c.relname
+FROM pg_catalog.pg_class c
+     LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace
+WHERE c.relname OPERATOR(pg_catalog.~) '^(unique_idx3)$' COLLATE pg_catalog.default
+                                                                           ^
 \d unique_idx4
-      Index "public.unique_idx4"
- Column |  Type   | Key? | Definition 
---------+---------+------+------------
- i      | integer | yes  | i
-unique nulls not distinct, btree, for table "public.unique_tbl"
-
+ERROR:  at or near ".": syntax error
+DETAIL:  source SQL:
+SELECT c.oid,
+  n.nspname,
+  c.relname
+FROM pg_catalog.pg_class c
+     LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace
+WHERE c.relname OPERATOR(pg_catalog.~) '^(unique_idx4)$' COLLATE pg_catalog.default
+                                                                           ^
 SELECT pg_get_indexdef('unique_idx3'::regclass);
-                           pg_get_indexdef                            
-----------------------------------------------------------------------
- CREATE UNIQUE INDEX unique_idx3 ON public.unique_tbl USING btree (i)
-(1 row)
-
+ERROR:  relation "unique_idx3" does not exist
 SELECT pg_get_indexdef('unique_idx4'::regclass);
-                                     pg_get_indexdef                                     
------------------------------------------------------------------------------------------
- CREATE UNIQUE INDEX unique_idx4 ON public.unique_tbl USING btree (i) NULLS NOT DISTINCT
-(1 row)
-
+ERROR:  relation "unique_idx4" does not exist
 DROP TABLE unique_tbl;
 --
 -- Test functional index
 --
 CREATE TABLE func_index_heap (f1 text, f2 text);
 CREATE UNIQUE INDEX func_index_index on func_index_heap (textcat(f1,f2));
+ERROR:  unknown function: textcat()
 INSERT INTO func_index_heap VALUES('ABC','DEF');
 INSERT INTO func_index_heap VALUES('AB','CDEFG');
 INSERT INTO func_index_heap VALUES('QWE','RTY');
 -- this should fail because of unique index:
 INSERT INTO func_index_heap VALUES('ABCD', 'EF');
-ERROR:  duplicate key value violates unique constraint "func_index_index"
-DETAIL:  Key (textcat(f1, f2))=(ABCDEF) already exists.
 -- but this shouldn't:
 INSERT INTO func_index_heap VALUES('QWERTY');
 -- while we're here, see that the metadata looks sane
 \d func_index_heap
-         Table "public.func_index_heap"
- Column | Type | Collation | Nullable | Default 
---------+------+-----------+----------+---------
- f1     | text |           |          | 
- f2     | text |           |          | 
-Indexes:
-    "func_index_index" UNIQUE, btree (textcat(f1, f2))
-
+ERROR:  at or near ".": syntax error
+DETAIL:  source SQL:
+SELECT c.oid,
+  n.nspname,
+  c.relname
+FROM pg_catalog.pg_class c
+     LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace
+WHERE c.relname OPERATOR(pg_catalog.~) '^(func_index_heap)$' COLLATE pg_catalog.default
+                                                                               ^
 \d func_index_index
-     Index "public.func_index_index"
- Column  | Type | Key? |   Definition    
----------+------+------+-----------------
- textcat | text | yes  | textcat(f1, f2)
-unique, btree, for table "public.func_index_heap"
-
+ERROR:  at or near ".": syntax error
+DETAIL:  source SQL:
+SELECT c.oid,
+  n.nspname,
+  c.relname
+FROM pg_catalog.pg_class c
+     LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace
+WHERE c.relname OPERATOR(pg_catalog.~) '^(func_index_index)$' COLLATE pg_catalog.default
+                                                                                ^
 --
 -- Same test, expressional index
 --
 DROP TABLE func_index_heap;
 CREATE TABLE func_index_heap (f1 text, f2 text);
 CREATE UNIQUE INDEX func_index_index on func_index_heap ((f1 || f2) text_ops);
+ERROR:  operator classes are only allowed for the last column of an inverted index
 INSERT INTO func_index_heap VALUES('ABC','DEF');
 INSERT INTO func_index_heap VALUES('AB','CDEFG');
 INSERT INTO func_index_heap VALUES('QWE','RTY');
 -- this should fail because of unique index:
 INSERT INTO func_index_heap VALUES('ABCD', 'EF');
-ERROR:  duplicate key value violates unique constraint "func_index_index"
-DETAIL:  Key ((f1 || f2))=(ABCDEF) already exists.
 -- but this shouldn't:
 INSERT INTO func_index_heap VALUES('QWERTY');
 -- while we're here, see that the metadata looks sane
 \d func_index_heap
-         Table "public.func_index_heap"
- Column | Type | Collation | Nullable | Default 
---------+------+-----------+----------+---------
- f1     | text |           |          | 
- f2     | text |           |          | 
-Indexes:
-    "func_index_index" UNIQUE, btree ((f1 || f2))
-
+ERROR:  at or near ".": syntax error
+DETAIL:  source SQL:
+SELECT c.oid,
+  n.nspname,
+  c.relname
+FROM pg_catalog.pg_class c
+     LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace
+WHERE c.relname OPERATOR(pg_catalog.~) '^(func_index_heap)$' COLLATE pg_catalog.default
+                                                                               ^
 \d func_index_index
-  Index "public.func_index_index"
- Column | Type | Key? | Definition 
---------+------+------+------------
- expr   | text | yes  | (f1 || f2)
-unique, btree, for table "public.func_index_heap"
-
+ERROR:  at or near ".": syntax error
+DETAIL:  source SQL:
+SELECT c.oid,
+  n.nspname,
+  c.relname
+FROM pg_catalog.pg_class c
+     LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace
+WHERE c.relname OPERATOR(pg_catalog.~) '^(func_index_index)$' COLLATE pg_catalog.default
+                                                                                ^
 -- this should fail because of unsafe column type (anonymous record)
 create index on func_index_heap ((f1 || f2), (row(f1, f2)));
-ERROR:  column "row" has pseudo-type record
+ERROR:  unimplemented: column ((f1, f2)) has type record, which is not indexable
+HINT:  You have attempted to use a feature that is not yet implemented.
+See: https://go.crdb.dev/issue-v/35730/_version_
 --
 -- Test unique index with included columns
 --
@@ -1380,6 +1197,11 @@
 -- Try to use existing covering index as primary key
 ALTER TABLE covering_index_heap ADD CONSTRAINT covering_pkey PRIMARY KEY USING INDEX
 covering_pkey;
+ERROR:  at or near "using": syntax error
+DETAIL:  source SQL:
+ALTER TABLE covering_index_heap ADD CONSTRAINT covering_pkey PRIMARY KEY USING INDEX
+                                                                         ^
+HINT:  try \h ALTER TABLE
 DROP TABLE covering_index_heap;
 --
 -- Try some concurrent index builds
@@ -1389,32 +1211,37 @@
 CREATE TABLE concur_heap (f1 text, f2 text);
 -- empty table
 CREATE INDEX CONCURRENTLY concur_index1 ON concur_heap(f2,f1);
+NOTICE:  CONCURRENTLY is not required as all indexes are created concurrently
 CREATE INDEX CONCURRENTLY IF NOT EXISTS concur_index1 ON concur_heap(f2,f1);
-NOTICE:  relation "concur_index1" already exists, skipping
 INSERT INTO concur_heap VALUES  ('a','b');
 INSERT INTO concur_heap VALUES  ('b','b');
 -- unique index
 CREATE UNIQUE INDEX CONCURRENTLY concur_index2 ON concur_heap(f1);
+NOTICE:  CONCURRENTLY is not required as all indexes are created concurrently
 CREATE UNIQUE INDEX CONCURRENTLY IF NOT EXISTS concur_index2 ON concur_heap(f1);
-NOTICE:  relation "concur_index2" already exists, skipping
 -- check if constraint is set up properly to be enforced
 INSERT INTO concur_heap VALUES ('b','x');
 ERROR:  duplicate key value violates unique constraint "concur_index2"
-DETAIL:  Key (f1)=(b) already exists.
+DETAIL:  Key (f1)=('b') already exists.
 -- check if constraint is enforced properly at build time
 CREATE UNIQUE INDEX CONCURRENTLY concur_index3 ON concur_heap(f2);
-ERROR:  could not create unique index "concur_index3"
-DETAIL:  Key (f2)=(b) is duplicated.
+ERROR:  failed to ingest index entries during backfill: duplicate key value violates unique constraint "concur_index3"
+DETAIL:  Key (f2)=('b') already exists.
 -- test that expression indexes and partial indexes work concurrently
 CREATE INDEX CONCURRENTLY concur_index4 on concur_heap(f2) WHERE f1='a';
+NOTICE:  CONCURRENTLY is not required as all indexes are created concurrently
 CREATE INDEX CONCURRENTLY concur_index5 on concur_heap(f2) WHERE f1='x';
+NOTICE:  CONCURRENTLY is not required as all indexes are created concurrently
 -- here we also check that you can default the index name
 CREATE INDEX CONCURRENTLY on concur_heap((f2||f1));
+NOTICE:  CONCURRENTLY is not required as all indexes are created concurrently
 -- You can't do a concurrent index build in a transaction
 BEGIN;
 CREATE INDEX CONCURRENTLY concur_index7 ON concur_heap(f1);
-ERROR:  CREATE INDEX CONCURRENTLY cannot run inside a transaction block
+NOTICE:  auto-committing transaction before processing DDL due to autocommit_before_ddl setting
+NOTICE:  CONCURRENTLY is not required as all indexes are created concurrently
 COMMIT;
+WARNING:  there is no transaction in progress
 -- test where predicate is able to do a transactional update during
 -- a concurrent build before switching pg_index state flags.
 CREATE FUNCTION predicate_stable() RETURNS bool IMMUTABLE
@@ -1423,52 +1250,76 @@
   EXECUTE 'SELECT txid_current()';
   RETURN true;
 END; $$;
+ERROR:  unimplemented: attempted to use a PL/pgSQL statement that is not yet supported
+DETAIL:  stmt_dyn_exec is not yet supported
+HINT:  You have attempted to use a feature that is not yet implemented.
+
+Please check the public issue tracker to check whether this problem is
+already tracked. If you cannot find it there, please report the error
+with details by creating a new issue.
+
+If you would rather not post publicly, please contact us directly
+using the support form.
+
+We appreciate your feedback.
+
 CREATE INDEX CONCURRENTLY concur_index8 ON concur_heap (f1)
   WHERE predicate_stable();
+ERROR:  unknown function: predicate_stable()
 DROP INDEX concur_index8;
+ERROR:  index "concur_index8" does not exist
 DROP FUNCTION predicate_stable();
+ERROR:  unknown function: predicate_stable()
 -- But you can do a regular index build in a transaction
 BEGIN;
 CREATE INDEX std_index on concur_heap(f2);
+NOTICE:  auto-committing transaction before processing DDL due to autocommit_before_ddl setting
 COMMIT;
+WARNING:  there is no transaction in progress
 -- Failed builds are left invalid by VACUUM FULL, fixed by REINDEX
 VACUUM FULL concur_heap;
+ERROR:  at or near "vacuum": syntax error
+DETAIL:  source SQL:
+VACUUM FULL concur_heap
+^
 REINDEX TABLE concur_heap;
-ERROR:  could not create unique index "concur_index3"
-DETAIL:  Key (f2)=(b) is duplicated.
+ERROR:  at or near "concur_heap": syntax error: unimplemented: this syntax
+DETAIL:  source SQL:
+REINDEX TABLE concur_heap
+              ^
+HINT:  CockroachDB does not require reindexing.
 DELETE FROM concur_heap WHERE f1 = 'b';
 VACUUM FULL concur_heap;
+ERROR:  at or near "vacuum": syntax error
+DETAIL:  source SQL:
+VACUUM FULL concur_heap
+^
 \d concur_heap
-           Table "public.concur_heap"
- Column | Type | Collation | Nullable | Default 
---------+------+-----------+----------+---------
- f1     | text |           |          | 
- f2     | text |           |          | 
-Indexes:
-    "concur_heap_expr_idx" btree ((f2 || f1))
-    "concur_index1" btree (f2, f1)
-    "concur_index2" UNIQUE, btree (f1)
-    "concur_index3" UNIQUE, btree (f2) INVALID
-    "concur_index4" btree (f2) WHERE f1 = 'a'::text
-    "concur_index5" btree (f2) WHERE f1 = 'x'::text
-    "std_index" btree (f2)
-
+ERROR:  at or near ".": syntax error
+DETAIL:  source SQL:
+SELECT c.oid,
+  n.nspname,
+  c.relname
+FROM pg_catalog.pg_class c
+     LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace
+WHERE c.relname OPERATOR(pg_catalog.~) '^(concur_heap)$' COLLATE pg_catalog.default
+                                                                           ^
 REINDEX TABLE concur_heap;
+ERROR:  at or near "concur_heap": syntax error: unimplemented: this syntax
+DETAIL:  source SQL:
+REINDEX TABLE concur_heap
+              ^
+HINT:  CockroachDB does not require reindexing.
 \d concur_heap
-           Table "public.concur_heap"
- Column | Type | Collation | Nullable | Default 
---------+------+-----------+----------+---------
- f1     | text |           |          | 
- f2     | text |           |          | 
-Indexes:
-    "concur_heap_expr_idx" btree ((f2 || f1))
-    "concur_index1" btree (f2, f1)
-    "concur_index2" UNIQUE, btree (f1)
-    "concur_index3" UNIQUE, btree (f2)
-    "concur_index4" btree (f2) WHERE f1 = 'a'::text
-    "concur_index5" btree (f2) WHERE f1 = 'x'::text
-    "std_index" btree (f2)
-
+ERROR:  at or near ".": syntax error
+DETAIL:  source SQL:
+SELECT c.oid,
+  n.nspname,
+  c.relname
+FROM pg_catalog.pg_class c
+     LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace
+WHERE c.relname OPERATOR(pg_catalog.~) '^(concur_heap)$' COLLATE pg_catalog.default
+                                                                           ^
 -- Temporary tables with concurrent builds and on-commit actions
 -- CONCURRENTLY used with CREATE INDEX and DROP INDEX is ignored.
 -- PRESERVE ROWS, the default.
@@ -1476,52 +1327,92 @@
   ON COMMIT PRESERVE ROWS;
 INSERT INTO concur_temp VALUES (1, 'foo'), (2, 'bar');
 CREATE INDEX CONCURRENTLY concur_temp_ind ON concur_temp(f1);
+NOTICE:  CONCURRENTLY is not required as all indexes are created concurrently
 DROP INDEX CONCURRENTLY concur_temp_ind;
+ERROR:  index "concur_temp_ind" does not exist
 DROP TABLE concur_temp;
 -- ON COMMIT DROP
 BEGIN;
 CREATE TEMP TABLE concur_temp (f1 int, f2 text)
   ON COMMIT DROP;
+ERROR:  at or near "EOF": syntax error: unimplemented: this syntax
+DETAIL:  source SQL:
+CREATE TEMP TABLE concur_temp (f1 int, f2 text)
+  ON COMMIT DROP
+                ^
+HINT:  You have attempted to use a feature that is not yet implemented.
+See: https://go.crdb.dev/issue-v/46556/_version_
 INSERT INTO concur_temp VALUES (1, 'foo'), (2, 'bar');
+ERROR:  current transaction is aborted, commands ignored until end of transaction block
 -- Fails when running in a transaction.
 CREATE INDEX CONCURRENTLY concur_temp_ind ON concur_temp(f1);
-ERROR:  CREATE INDEX CONCURRENTLY cannot run inside a transaction block
+ERROR:  current transaction is aborted, commands ignored until end of transaction block
 COMMIT;
 -- ON COMMIT DELETE ROWS
 CREATE TEMP TABLE concur_temp (f1 int, f2 text)
   ON COMMIT DELETE ROWS;
+ERROR:  at or near "EOF": syntax error: unimplemented: this syntax
+DETAIL:  source SQL:
+CREATE TEMP TABLE concur_temp (f1 int, f2 text)
+  ON COMMIT DELETE ROWS
+                       ^
+HINT:  You have attempted to use a feature that is not yet implemented.
+See: https://go.crdb.dev/issue-v/46556/_version_
 INSERT INTO concur_temp VALUES (1, 'foo'), (2, 'bar');
+ERROR:  relation "concur_temp" does not exist
 CREATE INDEX CONCURRENTLY concur_temp_ind ON concur_temp(f1);
+ERROR:  relation "concur_temp" does not exist
 DROP INDEX CONCURRENTLY concur_temp_ind;
+ERROR:  index "concur_temp_ind" does not exist
 DROP TABLE concur_temp;
+ERROR:  relation "concur_temp" does not exist
 --
 -- Try some concurrent index drops
 --
 DROP INDEX CONCURRENTLY "concur_index2";				-- works
+NOTICE:  CONCURRENTLY is not required as all indexes are dropped concurrently
+NOTICE:  the data for dropped indexes is reclaimed asynchronously
+HINT:  The reclamation delay can be customized in the zone configuration for the table.
 DROP INDEX CONCURRENTLY IF EXISTS "concur_index2";		-- notice
-NOTICE:  index "concur_index2" does not exist, skipping
+NOTICE:  CONCURRENTLY is not required as all indexes are dropped concurrently
 -- failures
 DROP INDEX CONCURRENTLY "concur_index2", "concur_index3";
-ERROR:  DROP INDEX CONCURRENTLY does not support dropping multiple objects
+ERROR:  index "concur_index2" does not exist
 BEGIN;
 DROP INDEX CONCURRENTLY "concur_index5";
-ERROR:  DROP INDEX CONCURRENTLY cannot run inside a transaction block
+NOTICE:  auto-committing transaction before processing DDL due to autocommit_before_ddl setting
+NOTICE:  CONCURRENTLY is not required as all indexes are dropped concurrently
+NOTICE:  the data for dropped indexes is reclaimed asynchronously
+HINT:  The reclamation delay can be customized in the zone configuration for the table.
 ROLLBACK;
+WARNING:  there is no transaction in progress
 -- successes
 DROP INDEX CONCURRENTLY IF EXISTS "concur_index3";
+NOTICE:  CONCURRENTLY is not required as all indexes are dropped concurrently
 DROP INDEX CONCURRENTLY "concur_index4";
+NOTICE:  CONCURRENTLY is not required as all indexes are dropped concurrently
+NOTICE:  the data for dropped indexes is reclaimed asynchronously
+HINT:  The reclamation delay can be customized in the zone configuration for the table.
 DROP INDEX CONCURRENTLY "concur_index5";
+ERROR:  index "concur_index5" does not exist
 DROP INDEX CONCURRENTLY "concur_index1";
+NOTICE:  CONCURRENTLY is not required as all indexes are dropped concurrently
+NOTICE:  the data for dropped indexes is reclaimed asynchronously
+HINT:  The reclamation delay can be customized in the zone configuration for the table.
 DROP INDEX CONCURRENTLY "concur_heap_expr_idx";
+NOTICE:  CONCURRENTLY is not required as all indexes are dropped concurrently
+NOTICE:  the data for dropped indexes is reclaimed asynchronously
+HINT:  The reclamation delay can be customized in the zone configuration for the table.
 \d concur_heap
-           Table "public.concur_heap"
- Column | Type | Collation | Nullable | Default 
---------+------+-----------+----------+---------
- f1     | text |           |          | 
- f2     | text |           |          | 
-Indexes:
-    "std_index" btree (f2)
-
+ERROR:  at or near ".": syntax error
+DETAIL:  source SQL:
+SELECT c.oid,
+  n.nspname,
+  c.relname
+FROM pg_catalog.pg_class c
+     LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace
+WHERE c.relname OPERATOR(pg_catalog.~) '^(concur_heap)$' COLLATE pg_catalog.default
+                                                                           ^
 DROP TABLE concur_heap;
 --
 -- Test ADD CONSTRAINT USING INDEX
@@ -1531,75 +1422,115 @@
 INSERT INTO cwi_test VALUES(1, 2), (3, 4), (5, 6);
 CREATE UNIQUE INDEX cwi_uniq_idx ON cwi_test(a , b);
 ALTER TABLE cwi_test ADD primary key USING INDEX cwi_uniq_idx;
+ERROR:  at or near "using": syntax error
+DETAIL:  source SQL:
+ALTER TABLE cwi_test ADD primary key USING INDEX cwi_uniq_idx
+                                     ^
+HINT:  try \h ALTER TABLE
 \d cwi_test
-                     Table "public.cwi_test"
- Column |         Type          | Collation | Nullable | Default 
---------+-----------------------+-----------+----------+---------
- a      | integer               |           | not null | 
- b      | character varying(10) |           | not null | 
- c      | character(1)          |           |          | 
-Indexes:
-    "cwi_uniq_idx" PRIMARY KEY, btree (a, b)
-
+ERROR:  at or near ".": syntax error
+DETAIL:  source SQL:
+SELECT c.oid,
+  n.nspname,
+  c.relname
+FROM pg_catalog.pg_class c
+     LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace
+WHERE c.relname OPERATOR(pg_catalog.~) '^(cwi_test)$' COLLATE pg_catalog.default
+                                                                        ^
 \d cwi_uniq_idx
-            Index "public.cwi_uniq_idx"
- Column |         Type          | Key? | Definition 
---------+-----------------------+------+------------
- a      | integer               | yes  | a
- b      | character varying(10) | yes  | b
-primary key, btree, for table "public.cwi_test"
-
+ERROR:  at or near ".": syntax error
+DETAIL:  source SQL:
+SELECT c.oid,
+  n.nspname,
+  c.relname
+FROM pg_catalog.pg_class c
+     LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace
+WHERE c.relname OPERATOR(pg_catalog.~) '^(cwi_uniq_idx)$' COLLATE pg_catalog.default
+                                                                            ^
 CREATE UNIQUE INDEX cwi_uniq2_idx ON cwi_test(b , a);
 ALTER TABLE cwi_test DROP CONSTRAINT cwi_uniq_idx,
 	ADD CONSTRAINT cwi_replaced_pkey PRIMARY KEY
 		USING INDEX cwi_uniq2_idx;
-NOTICE:  ALTER TABLE / ADD CONSTRAINT USING INDEX will rename index "cwi_uniq2_idx" to "cwi_replaced_pkey"
+ERROR:  at or near "using": syntax error
+DETAIL:  source SQL:
+ALTER TABLE cwi_test DROP CONSTRAINT cwi_uniq_idx,
+	ADD CONSTRAINT cwi_replaced_pkey PRIMARY KEY
+		USING INDEX cwi_uniq2_idx
+  ^
+HINT:  try \h ALTER TABLE
 \d cwi_test
-                     Table "public.cwi_test"
- Column |         Type          | Collation | Nullable | Default 
---------+-----------------------+-----------+----------+---------
- a      | integer               |           | not null | 
- b      | character varying(10) |           | not null | 
- c      | character(1)          |           |          | 
-Indexes:
-    "cwi_replaced_pkey" PRIMARY KEY, btree (b, a)
-
+ERROR:  at or near ".": syntax error
+DETAIL:  source SQL:
+SELECT c.oid,
+  n.nspname,
+  c.relname
+FROM pg_catalog.pg_class c
+     LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace
+WHERE c.relname OPERATOR(pg_catalog.~) '^(cwi_test)$' COLLATE pg_catalog.default
+                                                                        ^
 \d cwi_replaced_pkey
-          Index "public.cwi_replaced_pkey"
- Column |         Type          | Key? | Definition 
---------+-----------------------+------+------------
- b      | character varying(10) | yes  | b
- a      | integer               | yes  | a
-primary key, btree, for table "public.cwi_test"
-
+ERROR:  at or near ".": syntax error
+DETAIL:  source SQL:
+SELECT c.oid,
+  n.nspname,
+  c.relname
+FROM pg_catalog.pg_class c
+     LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace
+WHERE c.relname OPERATOR(pg_catalog.~) '^(cwi_replaced_pkey)$' COLLATE pg_catalog.default
+                                                                                 ^
 DROP INDEX cwi_replaced_pkey;	-- Should fail; a constraint depends on it
-ERROR:  cannot drop index cwi_replaced_pkey because constraint cwi_replaced_pkey on table cwi_test requires it
-HINT:  You can drop constraint cwi_replaced_pkey on table cwi_test instead.
+ERROR:  index "cwi_replaced_pkey" does not exist
 -- Check that non-default index options are rejected
 CREATE UNIQUE INDEX cwi_uniq3_idx ON cwi_test(a desc);
 ALTER TABLE cwi_test ADD UNIQUE USING INDEX cwi_uniq3_idx;  -- fail
-ERROR:  index "cwi_uniq3_idx" column number 1 does not have default sorting behavior
-LINE 1: ALTER TABLE cwi_test ADD UNIQUE USING INDEX cwi_uniq3_idx;
-                                 ^
-DETAIL:  Cannot create a primary key or unique constraint using such an index.
+ERROR:  at or near "using": syntax error
+DETAIL:  source SQL:
+ALTER TABLE cwi_test ADD UNIQUE USING INDEX cwi_uniq3_idx
+                                ^
+HINT:  try \h ALTER TABLE
 CREATE UNIQUE INDEX cwi_uniq4_idx ON cwi_test(b collate "POSIX");
+ERROR:  at or near "collate": syntax error
+DETAIL:  source SQL:
+CREATE UNIQUE INDEX cwi_uniq4_idx ON cwi_test(b collate "POSIX")
+                                                ^
+HINT:  try \h CREATE INDEX
 ALTER TABLE cwi_test ADD UNIQUE USING INDEX cwi_uniq4_idx;  -- fail
-ERROR:  index "cwi_uniq4_idx" column number 1 does not have default sorting behavior
-LINE 1: ALTER TABLE cwi_test ADD UNIQUE USING INDEX cwi_uniq4_idx;
-                                 ^
-DETAIL:  Cannot create a primary key or unique constraint using such an index.
+ERROR:  at or near "using": syntax error
+DETAIL:  source SQL:
+ALTER TABLE cwi_test ADD UNIQUE USING INDEX cwi_uniq4_idx
+                                ^
+HINT:  try \h ALTER TABLE
 DROP TABLE cwi_test;
 -- ADD CONSTRAINT USING INDEX is forbidden on partitioned tables
 CREATE TABLE cwi_test(a int) PARTITION BY hash (a);
+ERROR:  at or near "hash": syntax error
+DETAIL:  source SQL:
+CREATE TABLE cwi_test(a int) PARTITION BY hash (a)
+                                          ^
+HINT:  try \h CREATE TABLE
 create unique index on cwi_test (a);
+ERROR:  relation "cwi_test" does not exist
 alter table cwi_test add primary key using index cwi_test_a_idx ;
-ERROR:  ALTER TABLE / ADD CONSTRAINT USING INDEX is not supported on partitioned tables
+ERROR:  at or near "using": syntax error
+DETAIL:  source SQL:
+alter table cwi_test add primary key using index cwi_test_a_idx 
+                                     ^
+HINT:  try \h ALTER TABLE
 DROP TABLE cwi_test;
+ERROR:  relation "cwi_test" does not exist
 -- PRIMARY KEY constraint cannot be backed by a NULLS NOT DISTINCT index
 CREATE TABLE cwi_test(a int, b int);
 CREATE UNIQUE INDEX cwi_a_nnd ON cwi_test (a) NULLS NOT DISTINCT;
+ERROR:  at or near "nulls": syntax error
+DETAIL:  source SQL:
+CREATE UNIQUE INDEX cwi_a_nnd ON cwi_test (a) NULLS NOT DISTINCT
+                                              ^
 ALTER TABLE cwi_test ADD PRIMARY KEY USING INDEX cwi_a_nnd;
-ERROR:  primary keys cannot use NULLS NOT DISTINCT indexes
+ERROR:  at or near "using": syntax error
+DETAIL:  source SQL:
+ALTER TABLE cwi_test ADD PRIMARY KEY USING INDEX cwi_a_nnd
+                                     ^
+HINT:  try \h ALTER TABLE
 DROP TABLE cwi_test;
 --
 -- Check handling of indexes on system columns
@@ -1610,20 +1541,46 @@
 ERROR:  relation "syscolcol_table" does not exist
 -- nor used in expressions
 CREATE INDEX ON syscol_table ((ctid >= '(1000,0)'));
-ERROR:  index creation on system columns is not supported
+ERROR:  column "ctid" does not exist, referenced in "ctid >= '(1000,0)'"
 -- nor used in predicates
 CREATE INDEX ON syscol_table (a) WHERE ctid >= '(1000,0)';
-ERROR:  index creation on system columns is not supported
+ERROR:  column "ctid" does not exist
 DROP TABLE syscol_table;
 --
 -- Tests for IS NULL/IS NOT NULL with b-tree indexes
 --
 CREATE TABLE onek_with_null AS SELECT unique1, unique2 FROM onek;
+NOTICE:  CREATE TABLE ... AS does not copy over indexes, default expressions, or constraints; the new table has a hidden rowid primary key column
 INSERT INTO onek_with_null (unique1,unique2) VALUES (NULL, -1), (NULL, NULL);
 CREATE UNIQUE INDEX onek_nulltest ON onek_with_null (unique2,unique1);
 SET enable_seqscan = OFF;
+WARNING:  setting session var "enable_seqscan" is a no-op
 SET enable_indexscan = ON;
+ERROR:  unimplemented: the configuration setting "enable_indexscan" is not supported
+HINT:  You have attempted to use a feature that is not yet implemented.
+
+Please check the public issue tracker to check whether this problem is
+already tracked. If you cannot find it there, please report the error
+with details by creating a new issue.
+
+If you would rather not post publicly, please contact us directly
+using the support form.
+
+We appreciate your feedback.
+
 SET enable_bitmapscan = ON;
+ERROR:  unimplemented: the configuration setting "enable_bitmapscan" is not supported
+HINT:  You have attempted to use a feature that is not yet implemented.
+
+Please check the public issue tracker to check whether this problem is
+already tracked. If you cannot find it there, please report the error
+with details by creating a new issue.
+
+If you would rather not post publicly, please contact us directly
+using the support form.
+
+We appreciate your feedback.
+
 SELECT count(*) FROM onek_with_null WHERE unique1 IS NULL;
  count 
 -------
@@ -1661,6 +1618,8 @@
 (1 row)
 
 DROP INDEX onek_nulltest;
+NOTICE:  the data for dropped indexes is reclaimed asynchronously
+HINT:  The reclamation delay can be customized in the zone configuration for the table.
 CREATE UNIQUE INDEX onek_nulltest ON onek_with_null (unique2 desc,unique1);
 SELECT count(*) FROM onek_with_null WHERE unique1 IS NULL;
  count 
@@ -1699,6 +1658,8 @@
 (1 row)
 
 DROP INDEX onek_nulltest;
+NOTICE:  the data for dropped indexes is reclaimed asynchronously
+HINT:  The reclamation delay can be customized in the zone configuration for the table.
 CREATE UNIQUE INDEX onek_nulltest ON onek_with_null (unique2 desc nulls last,unique1);
 SELECT count(*) FROM onek_with_null WHERE unique1 IS NULL;
  count 
@@ -1737,6 +1698,8 @@
 (1 row)
 
 DROP INDEX onek_nulltest;
+NOTICE:  the data for dropped indexes is reclaimed asynchronously
+HINT:  The reclamation delay can be customized in the zone configuration for the table.
 CREATE UNIQUE INDEX onek_nulltest ON onek_with_null (unique2  nulls first,unique1);
 SELECT count(*) FROM onek_with_null WHERE unique1 IS NULL;
  count 
@@ -1775,17 +1738,44 @@
 (1 row)
 
 DROP INDEX onek_nulltest;
+NOTICE:  the data for dropped indexes is reclaimed asynchronously
+HINT:  The reclamation delay can be customized in the zone configuration for the table.
 -- Check initial-positioning logic too
 CREATE UNIQUE INDEX onek_nulltest ON onek_with_null (unique2);
 SET enable_seqscan = OFF;
+WARNING:  setting session var "enable_seqscan" is a no-op
 SET enable_indexscan = ON;
+ERROR:  unimplemented: the configuration setting "enable_indexscan" is not supported
+HINT:  You have attempted to use a feature that is not yet implemented.
+
+Please check the public issue tracker to check whether this problem is
+already tracked. If you cannot find it there, please report the error
+with details by creating a new issue.
+
+If you would rather not post publicly, please contact us directly
+using the support form.
+
+We appreciate your feedback.
+
 SET enable_bitmapscan = OFF;
+ERROR:  unimplemented: the configuration setting "enable_bitmapscan" is not supported
+HINT:  You have attempted to use a feature that is not yet implemented.
+
+Please check the public issue tracker to check whether this problem is
+already tracked. If you cannot find it there, please report the error
+with details by creating a new issue.
+
+If you would rather not post publicly, please contact us directly
+using the support form.
+
+We appreciate your feedback.
+
 SELECT unique1, unique2 FROM onek_with_null
   ORDER BY unique2 LIMIT 2;
  unique1 | unique2 
 ---------+---------
+         |        
          |      -1
-     147 |       0
 (2 rows)
 
 SELECT unique1, unique2 FROM onek_with_null WHERE unique2 >= -1
@@ -1808,8 +1798,8 @@
   ORDER BY unique2 DESC LIMIT 2;
  unique1 | unique2 
 ---------+---------
-         |        
      278 |     999
+       0 |     998
 (2 rows)
 
 SELECT unique1, unique2 FROM onek_with_null WHERE unique2 >= -1
@@ -1829,8 +1819,33 @@
 (2 rows)
 
 RESET enable_seqscan;
+WARNING:  setting session var "enable_seqscan" is a no-op
 RESET enable_indexscan;
+ERROR:  unimplemented: the configuration setting "enable_indexscan" is not supported
+HINT:  You have attempted to use a feature that is not yet implemented.
+
+Please check the public issue tracker to check whether this problem is
+already tracked. If you cannot find it there, please report the error
+with details by creating a new issue.
+
+If you would rather not post publicly, please contact us directly
+using the support form.
+
+We appreciate your feedback.
+
 RESET enable_bitmapscan;
+ERROR:  unimplemented: the configuration setting "enable_bitmapscan" is not supported
+HINT:  You have attempted to use a feature that is not yet implemented.
+
+Please check the public issue tracker to check whether this problem is
+already tracked. If you cannot find it there, please report the error
+with details by creating a new issue.
+
+If you would rather not post publicly, please contact us directly
+using the support form.
+
+We appreciate your feedback.
+
 DROP TABLE onek_with_null;
 --
 -- Check bitmap index path planning
@@ -1838,19 +1853,11 @@
 EXPLAIN (COSTS OFF)
 SELECT * FROM tenk1
   WHERE thousand = 42 AND (tenthous = 1 OR tenthous = 3 OR tenthous = 42);
-                                                               QUERY PLAN                                                                
------------------------------------------------------------------------------------------------------------------------------------------
- Bitmap Heap Scan on tenk1
-   Recheck Cond: (((thousand = 42) AND (tenthous = 1)) OR ((thousand = 42) AND (tenthous = 3)) OR ((thousand = 42) AND (tenthous = 42)))
-   ->  BitmapOr
-         ->  Bitmap Index Scan on tenk1_thous_tenthous
-               Index Cond: ((thousand = 42) AND (tenthous = 1))
-         ->  Bitmap Index Scan on tenk1_thous_tenthous
-               Index Cond: ((thousand = 42) AND (tenthous = 3))
-         ->  Bitmap Index Scan on tenk1_thous_tenthous
-               Index Cond: ((thousand = 42) AND (tenthous = 42))
-(9 rows)
-
+ERROR:  at or near "off": syntax error
+DETAIL:  source SQL:
+EXPLAIN (COSTS OFF)
+               ^
+HINT:  try \h <SELECTCLAUSE>
 SELECT * FROM tenk1
   WHERE thousand = 42 AND (tenthous = 1 OR tenthous = 3 OR tenthous = 42);
  unique1 | unique2 | two | four | ten | twenty | hundred | thousand | twothousand | fivethous | tenthous | odd | even | stringu1 | stringu2 | string4 
@@ -1861,21 +1868,11 @@
 EXPLAIN (COSTS OFF)
 SELECT count(*) FROM tenk1
   WHERE hundred = 42 AND (thousand = 42 OR thousand = 99);
-                                   QUERY PLAN                                    
----------------------------------------------------------------------------------
- Aggregate
-   ->  Bitmap Heap Scan on tenk1
-         Recheck Cond: ((hundred = 42) AND ((thousand = 42) OR (thousand = 99)))
-         ->  BitmapAnd
-               ->  Bitmap Index Scan on tenk1_hundred
-                     Index Cond: (hundred = 42)
-               ->  BitmapOr
-                     ->  Bitmap Index Scan on tenk1_thous_tenthous
-                           Index Cond: (thousand = 42)
-                     ->  Bitmap Index Scan on tenk1_thous_tenthous
-                           Index Cond: (thousand = 99)
-(11 rows)
-
+ERROR:  at or near "off": syntax error
+DETAIL:  source SQL:
+EXPLAIN (COSTS OFF)
+               ^
+HINT:  try \h <SELECTCLAUSE>
 SELECT count(*) FROM tenk1
   WHERE hundred = 42 AND (thousand = 42 OR thousand = 99);
  count 
@@ -1888,27 +1885,25 @@
 --
 CREATE TABLE dupindexcols AS
   SELECT unique1 as id, stringu2::text as f1 FROM tenk1;
+NOTICE:  CREATE TABLE ... AS does not copy over indexes, default expressions, or constraints; the new table has a hidden rowid primary key column
 CREATE INDEX dupindexcols_i ON dupindexcols (f1, id, f1 text_pattern_ops);
+ERROR:  index "dupindexcols_i" contains duplicate column "f1"
 ANALYZE dupindexcols;
 EXPLAIN (COSTS OFF)
   SELECT count(*) FROM dupindexcols
     WHERE f1 BETWEEN 'WA' AND 'ZZZ' and id < 1000 and f1 ~<~ 'YX';
-                                                   QUERY PLAN                                                   
-----------------------------------------------------------------------------------------------------------------
- Aggregate
-   ->  Bitmap Heap Scan on dupindexcols
-         Recheck Cond: ((f1 >= 'WA'::text) AND (f1 <= 'ZZZ'::text) AND (id < 1000) AND (f1 ~<~ 'YX'::text))
-         ->  Bitmap Index Scan on dupindexcols_i
-               Index Cond: ((f1 >= 'WA'::text) AND (f1 <= 'ZZZ'::text) AND (id < 1000) AND (f1 ~<~ 'YX'::text))
-(5 rows)
-
+ERROR:  at or near "off": syntax error
+DETAIL:  source SQL:
+EXPLAIN (COSTS OFF)
+               ^
+HINT:  try \h <SELECTCLAUSE>
 SELECT count(*) FROM dupindexcols
   WHERE f1 BETWEEN 'WA' AND 'ZZZ' and id < 1000 and f1 ~<~ 'YX';
- count 
--------
-    97
-(1 row)
-
+ERROR:  at or near "<": syntax error
+DETAIL:  source SQL:
+SELECT count(*) FROM dupindexcols
+  WHERE f1 BETWEEN 'WA' AND 'ZZZ' and id < 1000 and f1 ~<~ 'YX'
+                                                        ^
 --
 -- Check ordering of =ANY indexqual results (bug in 9.2.0)
 --
@@ -1916,12 +1911,11 @@
 SELECT unique1 FROM tenk1
 WHERE unique1 IN (1,42,7)
 ORDER BY unique1;
-                      QUERY PLAN                       
--------------------------------------------------------
- Index Only Scan using tenk1_unique1 on tenk1
-   Index Cond: (unique1 = ANY ('{1,42,7}'::integer[]))
-(2 rows)
-
+ERROR:  at or near "off": syntax error
+DETAIL:  source SQL:
+explain (costs off)
+               ^
+HINT:  try \h <SELECTCLAUSE>
 SELECT unique1 FROM tenk1
 WHERE unique1 IN (1,42,7)
 ORDER BY unique1;
@@ -1936,13 +1930,11 @@
 SELECT thousand, tenthous FROM tenk1
 WHERE thousand < 2 AND tenthous IN (1001,3000)
 ORDER BY thousand;
-                      QUERY PLAN                       
--------------------------------------------------------
- Index Only Scan using tenk1_thous_tenthous on tenk1
-   Index Cond: (thousand < 2)
-   Filter: (tenthous = ANY ('{1001,3000}'::integer[]))
-(3 rows)
-
+ERROR:  at or near "off": syntax error
+DETAIL:  source SQL:
+explain (costs off)
+               ^
+HINT:  try \h <SELECTCLAUSE>
 SELECT thousand, tenthous FROM tenk1
 WHERE thousand < 2 AND tenthous IN (1001,3000)
 ORDER BY thousand;
@@ -1953,18 +1945,27 @@
 (2 rows)
 
 SET enable_indexonlyscan = OFF;
+ERROR:  unimplemented: the configuration setting "enable_indexonlyscan" is not supported
+HINT:  You have attempted to use a feature that is not yet implemented.
+
+Please check the public issue tracker to check whether this problem is
+already tracked. If you cannot find it there, please report the error
+with details by creating a new issue.
+
+If you would rather not post publicly, please contact us directly
+using the support form.
+
+We appreciate your feedback.
+
 explain (costs off)
 SELECT thousand, tenthous FROM tenk1
 WHERE thousand < 2 AND tenthous IN (1001,3000)
 ORDER BY thousand;
-                                      QUERY PLAN                                      
---------------------------------------------------------------------------------------
- Sort
-   Sort Key: thousand
-   ->  Index Scan using tenk1_thous_tenthous on tenk1
-         Index Cond: ((thousand < 2) AND (tenthous = ANY ('{1001,3000}'::integer[])))
-(4 rows)
-
+ERROR:  at or near "off": syntax error
+DETAIL:  source SQL:
+explain (costs off)
+               ^
+HINT:  try \h <SELECTCLAUSE>
 SELECT thousand, tenthous FROM tenk1
 WHERE thousand < 2 AND tenthous IN (1001,3000)
 ORDER BY thousand;
@@ -1975,81 +1976,81 @@
 (2 rows)
 
 RESET enable_indexonlyscan;
+ERROR:  unimplemented: the configuration setting "enable_indexonlyscan" is not supported
+HINT:  You have attempted to use a feature that is not yet implemented.
+
+Please check the public issue tracker to check whether this problem is
+already tracked. If you cannot find it there, please report the error
+with details by creating a new issue.
+
+If you would rather not post publicly, please contact us directly
+using the support form.
+
+We appreciate your feedback.
+
 --
 -- Check elimination of constant-NULL subexpressions
 --
 explain (costs off)
   select * from tenk1 where (thousand, tenthous) in ((1,1001), (null,null));
-                      QUERY PLAN                      
-------------------------------------------------------
- Index Scan using tenk1_thous_tenthous on tenk1
-   Index Cond: ((thousand = 1) AND (tenthous = 1001))
-(2 rows)
-
+ERROR:  at or near "off": syntax error
+DETAIL:  source SQL:
+explain (costs off)
+               ^
+HINT:  try \h <SELECTCLAUSE>
 --
 -- Check matching of boolean index columns to WHERE conditions and sort keys
 --
 create temp table boolindex (b bool, i int, unique(b, i), junk float);
 explain (costs off)
   select * from boolindex order by b, i limit 10;
-                      QUERY PLAN                       
--------------------------------------------------------
- Limit
-   ->  Index Scan using boolindex_b_i_key on boolindex
-(2 rows)
-
+ERROR:  at or near "off": syntax error
+DETAIL:  source SQL:
+explain (costs off)
+               ^
+HINT:  try \h <SELECTCLAUSE>
 explain (costs off)
   select * from boolindex where b order by i limit 10;
-                      QUERY PLAN                       
--------------------------------------------------------
- Limit
-   ->  Index Scan using boolindex_b_i_key on boolindex
-         Index Cond: (b = true)
-(3 rows)
-
+ERROR:  at or near "off": syntax error
+DETAIL:  source SQL:
+explain (costs off)
+               ^
+HINT:  try \h <SELECTCLAUSE>
 explain (costs off)
   select * from boolindex where b = true order by i desc limit 10;
-                           QUERY PLAN                           
-----------------------------------------------------------------
- Limit
-   ->  Index Scan Backward using boolindex_b_i_key on boolindex
-         Index Cond: (b = true)
-(3 rows)
-
+ERROR:  at or near "off": syntax error
+DETAIL:  source SQL:
+explain (costs off)
+               ^
+HINT:  try \h <SELECTCLAUSE>
 explain (costs off)
   select * from boolindex where not b order by i limit 10;
-                      QUERY PLAN                       
--------------------------------------------------------
- Limit
-   ->  Index Scan using boolindex_b_i_key on boolindex
-         Index Cond: (b = false)
-(3 rows)
-
+ERROR:  at or near "off": syntax error
+DETAIL:  source SQL:
+explain (costs off)
+               ^
+HINT:  try \h <SELECTCLAUSE>
 explain (costs off)
   select * from boolindex where b is true order by i desc limit 10;
-                           QUERY PLAN                           
-----------------------------------------------------------------
- Limit
-   ->  Index Scan Backward using boolindex_b_i_key on boolindex
-         Index Cond: (b = true)
-(3 rows)
-
+ERROR:  at or near "off": syntax error
+DETAIL:  source SQL:
+explain (costs off)
+               ^
+HINT:  try \h <SELECTCLAUSE>
 explain (costs off)
   select * from boolindex where b is false order by i desc limit 10;
-                           QUERY PLAN                           
-----------------------------------------------------------------
- Limit
-   ->  Index Scan Backward using boolindex_b_i_key on boolindex
-         Index Cond: (b = false)
-(3 rows)
-
+ERROR:  at or near "off": syntax error
+DETAIL:  source SQL:
+explain (costs off)
+               ^
+HINT:  try \h <SELECTCLAUSE>
 --
 -- REINDEX (VERBOSE)
 --
 CREATE TABLE reindex_verbose(id integer primary key);
 \set VERBOSITY terse \\ -- suppress machine-dependent details
 REINDEX (VERBOSE) TABLE reindex_verbose;
-INFO:  index "reindex_verbose_pkey" was reindexed
+ERROR:  at or near "(": syntax error
 \set VERBOSITY default
 DROP TABLE reindex_verbose;
 --
@@ -2058,9 +2059,16 @@
 CREATE TABLE concur_reindex_tab (c1 int);
 -- REINDEX
 REINDEX TABLE concur_reindex_tab; -- notice
-NOTICE:  table "concur_reindex_tab" has no indexes to reindex
+ERROR:  at or near "concur_reindex_tab": syntax error: unimplemented: this syntax
+DETAIL:  source SQL:
+REINDEX TABLE concur_reindex_tab
+              ^
+HINT:  CockroachDB does not require reindexing.
 REINDEX (CONCURRENTLY) TABLE concur_reindex_tab; -- notice
-NOTICE:  table "concur_reindex_tab" has no indexes that can be reindexed concurrently
+ERROR:  at or near "(": syntax error
+DETAIL:  source SQL:
+REINDEX (CONCURRENTLY) TABLE concur_reindex_tab
+        ^
 ALTER TABLE concur_reindex_tab ADD COLUMN c2 text; -- add toast index
 -- Normal index with integer column
 CREATE UNIQUE INDEX concur_reindex_ind1 ON concur_reindex_tab(c1);
@@ -2070,21 +2078,41 @@
 CREATE UNIQUE INDEX concur_reindex_ind3 ON concur_reindex_tab(abs(c1));
 -- Duplicate column names
 CREATE INDEX concur_reindex_ind4 ON concur_reindex_tab(c1, c1, c2);
+ERROR:  index "concur_reindex_ind4" contains duplicate column "c1"
 -- Create table for check on foreign key dependence switch with indexes swapped
 ALTER TABLE concur_reindex_tab ADD PRIMARY KEY USING INDEX concur_reindex_ind1;
+ERROR:  at or near "using": syntax error
+DETAIL:  source SQL:
+ALTER TABLE concur_reindex_tab ADD PRIMARY KEY USING INDEX concur_reindex_ind1
+                                               ^
+HINT:  try \h ALTER TABLE
 CREATE TABLE concur_reindex_tab2 (c1 int REFERENCES concur_reindex_tab);
 INSERT INTO concur_reindex_tab VALUES  (1, 'a');
 INSERT INTO concur_reindex_tab VALUES  (2, 'a');
 -- Reindex concurrently of exclusion constraint currently not supported
 CREATE TABLE concur_reindex_tab3 (c1 int, c2 int4range, EXCLUDE USING gist (c2 WITH &&));
+ERROR:  at or near "gist": syntax error: unimplemented: this syntax
+DETAIL:  source SQL:
+CREATE TABLE concur_reindex_tab3 (c1 int, c2 int4range, EXCLUDE USING gist (c2 WITH &&))
+                                                                      ^
+HINT:  You have attempted to use a feature that is not yet implemented.
+See: https://go.crdb.dev/issue-v/46657/_version_
 INSERT INTO concur_reindex_tab3 VALUES  (3, '[1,2]');
+ERROR:  relation "concur_reindex_tab3" does not exist
 REINDEX INDEX CONCURRENTLY  concur_reindex_tab3_c2_excl;  -- error
-ERROR:  concurrent index creation for exclusion constraints is not supported
+ERROR:  at or near "concurrently": syntax error: unimplemented: this syntax
+DETAIL:  source SQL:
+REINDEX INDEX CONCURRENTLY  concur_reindex_tab3_c2_excl
+              ^
+HINT:  CockroachDB does not require reindexing.
 REINDEX TABLE CONCURRENTLY concur_reindex_tab3;  -- succeeds with warning
-WARNING:  cannot reindex exclusion constraint index "public.concur_reindex_tab3_c2_excl" concurrently, skipping
+ERROR:  at or near "concurrently": syntax error: unimplemented: this syntax
+DETAIL:  source SQL:
+REINDEX TABLE CONCURRENTLY concur_reindex_tab3
+              ^
+HINT:  CockroachDB does not require reindexing.
 INSERT INTO concur_reindex_tab3 VALUES  (4, '[2,4]');
-ERROR:  conflicting key value violates exclusion constraint "concur_reindex_tab3_c2_excl"
-DETAIL:  Key (c2)=([2,5)) conflicts with existing key (c2)=([1,3)).
+ERROR:  relation "concur_reindex_tab3" does not exist
 -- Check materialized views
 CREATE MATERIALIZED VIEW concur_reindex_matview AS SELECT * FROM concur_reindex_tab;
 -- Dependency lookup before and after the follow-up REINDEX commands.
@@ -2101,21 +2129,25 @@
 	    'concur_reindex_ind4'::regclass,
 	    'concur_reindex_matview'::regclass)
   ORDER BY 1, 2;
-                   obj                    |                           objref                           | deptype 
-------------------------------------------+------------------------------------------------------------+---------
- index concur_reindex_ind1                | constraint concur_reindex_ind1 on table concur_reindex_tab | i
- index concur_reindex_ind2                | column c2 of table concur_reindex_tab                      | a
- index concur_reindex_ind3                | column c1 of table concur_reindex_tab                      | a
- index concur_reindex_ind3                | table concur_reindex_tab                                   | a
- index concur_reindex_ind4                | column c1 of table concur_reindex_tab                      | a
- index concur_reindex_ind4                | column c2 of table concur_reindex_tab                      | a
- materialized view concur_reindex_matview | schema public                                              | n
- table concur_reindex_tab                 | schema public                                              | n
-(8 rows)
-
+ERROR:  unknown function: pg_describe_object()
 REINDEX INDEX CONCURRENTLY concur_reindex_ind1;
+ERROR:  at or near "concurrently": syntax error: unimplemented: this syntax
+DETAIL:  source SQL:
+REINDEX INDEX CONCURRENTLY concur_reindex_ind1
+              ^
+HINT:  CockroachDB does not require reindexing.
 REINDEX TABLE CONCURRENTLY concur_reindex_tab;
+ERROR:  at or near "concurrently": syntax error: unimplemented: this syntax
+DETAIL:  source SQL:
+REINDEX TABLE CONCURRENTLY concur_reindex_tab
+              ^
+HINT:  CockroachDB does not require reindexing.
 REINDEX TABLE CONCURRENTLY concur_reindex_matview;
+ERROR:  at or near "concurrently": syntax error: unimplemented: this syntax
+DETAIL:  source SQL:
+REINDEX TABLE CONCURRENTLY concur_reindex_matview
+              ^
+HINT:  CockroachDB does not require reindexing.
 SELECT pg_describe_object(classid, objid, objsubid) as obj,
        pg_describe_object(refclassid,refobjid,refobjsubid) as objref,
        deptype
@@ -2128,18 +2160,7 @@
 	    'concur_reindex_ind4'::regclass,
 	    'concur_reindex_matview'::regclass)
   ORDER BY 1, 2;
-                   obj                    |                           objref                           | deptype 
-------------------------------------------+------------------------------------------------------------+---------
- index concur_reindex_ind1                | constraint concur_reindex_ind1 on table concur_reindex_tab | i
- index concur_reindex_ind2                | column c2 of table concur_reindex_tab                      | a
- index concur_reindex_ind3                | column c1 of table concur_reindex_tab                      | a
- index concur_reindex_ind3                | table concur_reindex_tab                                   | a
- index concur_reindex_ind4                | column c1 of table concur_reindex_tab                      | a
- index concur_reindex_ind4                | column c2 of table concur_reindex_tab                      | a
- materialized view concur_reindex_matview | schema public                                              | n
- table concur_reindex_tab                 | schema public                                              | n
-(8 rows)
-
+ERROR:  unknown function: pg_describe_object()
 -- Check that comments are preserved
 CREATE TABLE testcomment (i int);
 CREATE INDEX testcomment_idx1 ON testcomment (i);
@@ -2151,6 +2172,11 @@
 (1 row)
 
 REINDEX TABLE testcomment;
+ERROR:  at or near "testcomment": syntax error: unimplemented: this syntax
+DETAIL:  source SQL:
+REINDEX TABLE testcomment
+              ^
+HINT:  CockroachDB does not require reindexing.
 SELECT obj_description('testcomment_idx1'::regclass, 'pg_class');
  obj_description 
 -----------------
@@ -2158,6 +2184,11 @@
 (1 row)
 
 REINDEX TABLE CONCURRENTLY testcomment ;
+ERROR:  at or near "concurrently": syntax error: unimplemented: this syntax
+DETAIL:  source SQL:
+REINDEX TABLE CONCURRENTLY testcomment 
+              ^
+HINT:  CockroachDB does not require reindexing.
 SELECT obj_description('testcomment_idx1'::regclass, 'pg_class');
  obj_description 
 -----------------
@@ -2169,13 +2200,24 @@
 CREATE TABLE concur_clustered(i int);
 CREATE INDEX concur_clustered_i_idx ON concur_clustered(i);
 ALTER TABLE concur_clustered CLUSTER ON concur_clustered_i_idx;
+ERROR:  at or near "cluster": syntax error
+DETAIL:  source SQL:
+ALTER TABLE concur_clustered CLUSTER ON concur_clustered_i_idx
+                             ^
+HINT:  try \h ALTER TABLE
 REINDEX TABLE CONCURRENTLY concur_clustered;
+ERROR:  at or near "concurrently": syntax error: unimplemented: this syntax
+DETAIL:  source SQL:
+REINDEX TABLE CONCURRENTLY concur_clustered
+              ^
+HINT:  CockroachDB does not require reindexing.
 SELECT indexrelid::regclass, indisclustered FROM pg_index
   WHERE indrelid = 'concur_clustered'::regclass;
        indexrelid       | indisclustered 
 ------------------------+----------------
- concur_clustered_i_idx | t
-(1 row)
+ concur_clustered_pkey  | f
+ concur_clustered_i_idx | f
+(2 rows)
 
 DROP TABLE concur_clustered;
 -- Check that indisreplident updates are preserved.
@@ -2183,86 +2225,168 @@
 CREATE UNIQUE INDEX concur_replident_i_idx ON concur_replident(i);
 ALTER TABLE concur_replident REPLICA IDENTITY
   USING INDEX concur_replident_i_idx;
+ERROR:  at or near "replica": syntax error
+DETAIL:  source SQL:
+ALTER TABLE concur_replident REPLICA IDENTITY
+                             ^
+HINT:  try \h ALTER TABLE
 SELECT indexrelid::regclass, indisreplident FROM pg_index
   WHERE indrelid = 'concur_replident'::regclass;
        indexrelid       | indisreplident 
 ------------------------+----------------
- concur_replident_i_idx | t
-(1 row)
+ concur_replident_pkey  | f
+ concur_replident_i_idx | f
+(2 rows)
 
 REINDEX TABLE CONCURRENTLY concur_replident;
+ERROR:  at or near "concurrently": syntax error: unimplemented: this syntax
+DETAIL:  source SQL:
+REINDEX TABLE CONCURRENTLY concur_replident
+              ^
+HINT:  CockroachDB does not require reindexing.
 SELECT indexrelid::regclass, indisreplident FROM pg_index
   WHERE indrelid = 'concur_replident'::regclass;
        indexrelid       | indisreplident 
 ------------------------+----------------
- concur_replident_i_idx | t
-(1 row)
+ concur_replident_pkey  | f
+ concur_replident_i_idx | f
+(2 rows)
 
 DROP TABLE concur_replident;
 -- Check that opclass parameters are preserved
 CREATE TABLE concur_appclass_tab(i tsvector, j tsvector, k tsvector);
 CREATE INDEX concur_appclass_ind on concur_appclass_tab
   USING gist (i tsvector_ops (siglen='1000'), j tsvector_ops (siglen='500'));
+ERROR:  at or near "(": syntax error
+DETAIL:  source SQL:
+CREATE INDEX concur_appclass_ind on concur_appclass_tab
+  USING gist (i tsvector_ops (siglen='1000'), j tsvector_ops (siglen='500'))
+                             ^
+HINT:  try \h CREATE INDEX
 CREATE INDEX concur_appclass_ind_2 on concur_appclass_tab
   USING gist (k tsvector_ops (siglen='300'), j tsvector_ops);
+ERROR:  at or near "(": syntax error
+DETAIL:  source SQL:
+CREATE INDEX concur_appclass_ind_2 on concur_appclass_tab
+  USING gist (k tsvector_ops (siglen='300'), j tsvector_ops)
+                             ^
+HINT:  try \h CREATE INDEX
 REINDEX TABLE CONCURRENTLY concur_appclass_tab;
+ERROR:  at or near "concurrently": syntax error: unimplemented: this syntax
+DETAIL:  source SQL:
+REINDEX TABLE CONCURRENTLY concur_appclass_tab
+              ^
+HINT:  CockroachDB does not require reindexing.
 \d concur_appclass_tab
-         Table "public.concur_appclass_tab"
- Column |   Type   | Collation | Nullable | Default 
---------+----------+-----------+----------+---------
- i      | tsvector |           |          | 
- j      | tsvector |           |          | 
- k      | tsvector |           |          | 
-Indexes:
-    "concur_appclass_ind" gist (i tsvector_ops (siglen='1000'), j tsvector_ops (siglen='500'))
-    "concur_appclass_ind_2" gist (k tsvector_ops (siglen='300'), j)
-
+ERROR:  at or near ".": syntax error
+DETAIL:  source SQL:
+SELECT c.oid,
+  n.nspname,
+  c.relname
+FROM pg_catalog.pg_class c
+     LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace
+WHERE c.relname OPERATOR(pg_catalog.~) '^(concur_appclass_tab)$' COLLATE pg_catalog.default
+                                                                                   ^
 DROP TABLE concur_appclass_tab;
 -- Partitions
 -- Create some partitioned tables
 CREATE TABLE concur_reindex_part (c1 int, c2 int) PARTITION BY RANGE (c1);
+ERROR:  at or near "EOF": syntax error
+DETAIL:  source SQL:
+CREATE TABLE concur_reindex_part (c1 int, c2 int) PARTITION BY RANGE (c1)
+                                                                         ^
+HINT:  try \h CREATE TABLE
 CREATE TABLE concur_reindex_part_0 PARTITION OF concur_reindex_part
   FOR VALUES FROM (0) TO (10) PARTITION BY list (c2);
+ERROR:  at or near "partition": syntax error
+DETAIL:  source SQL:
+CREATE TABLE concur_reindex_part_0 PARTITION OF concur_reindex_part
+                                   ^
+HINT:  try \h CREATE TABLE
 CREATE TABLE concur_reindex_part_0_1 PARTITION OF concur_reindex_part_0
   FOR VALUES IN (1);
+ERROR:  at or near "partition": syntax error
+DETAIL:  source SQL:
+CREATE TABLE concur_reindex_part_0_1 PARTITION OF concur_reindex_part_0
+                                     ^
+HINT:  try \h CREATE TABLE
 CREATE TABLE concur_reindex_part_0_2 PARTITION OF concur_reindex_part_0
   FOR VALUES IN (2);
+ERROR:  at or near "partition": syntax error
+DETAIL:  source SQL:
+CREATE TABLE concur_reindex_part_0_2 PARTITION OF concur_reindex_part_0
+                                     ^
+HINT:  try \h CREATE TABLE
 -- This partitioned table will have no partitions.
 CREATE TABLE concur_reindex_part_10 PARTITION OF concur_reindex_part
   FOR VALUES FROM (10) TO (20) PARTITION BY list (c2);
+ERROR:  at or near "partition": syntax error
+DETAIL:  source SQL:
+CREATE TABLE concur_reindex_part_10 PARTITION OF concur_reindex_part
+                                    ^
+HINT:  try \h CREATE TABLE
 -- Create some partitioned indexes
 CREATE INDEX concur_reindex_part_index ON ONLY concur_reindex_part (c1);
+ERROR:  at or near "only": syntax error
+DETAIL:  source SQL:
+CREATE INDEX concur_reindex_part_index ON ONLY concur_reindex_part (c1)
+                                          ^
+HINT:  try \h CREATE INDEX
 CREATE INDEX concur_reindex_part_index_0 ON ONLY concur_reindex_part_0 (c1);
+ERROR:  at or near "only": syntax error
+DETAIL:  source SQL:
+CREATE INDEX concur_reindex_part_index_0 ON ONLY concur_reindex_part_0 (c1)
+                                            ^
+HINT:  try \h CREATE INDEX
 ALTER INDEX concur_reindex_part_index ATTACH PARTITION concur_reindex_part_index_0;
+ERROR:  at or near "attach": syntax error
+DETAIL:  source SQL:
+ALTER INDEX concur_reindex_part_index ATTACH PARTITION concur_reindex_part_index_0
+                                      ^
+HINT:  try \h ALTER INDEX
 -- This partitioned index will have no partitions.
 CREATE INDEX concur_reindex_part_index_10 ON ONLY concur_reindex_part_10 (c1);
+ERROR:  at or near "only": syntax error
+DETAIL:  source SQL:
+CREATE INDEX concur_reindex_part_index_10 ON ONLY concur_reindex_part_10 (c1)
+                                             ^
+HINT:  try \h CREATE INDEX
 ALTER INDEX concur_reindex_part_index ATTACH PARTITION concur_reindex_part_index_10;
+ERROR:  at or near "attach": syntax error
+DETAIL:  source SQL:
+ALTER INDEX concur_reindex_part_index ATTACH PARTITION concur_reindex_part_index_10
+                                      ^
+HINT:  try \h ALTER INDEX
 CREATE INDEX concur_reindex_part_index_0_1 ON ONLY concur_reindex_part_0_1 (c1);
+ERROR:  at or near "only": syntax error
+DETAIL:  source SQL:
+CREATE INDEX concur_reindex_part_index_0_1 ON ONLY concur_reindex_part_0_1 (c1)
+                                              ^
+HINT:  try \h CREATE INDEX
 ALTER INDEX concur_reindex_part_index_0 ATTACH PARTITION concur_reindex_part_index_0_1;
+ERROR:  at or near "attach": syntax error
+DETAIL:  source SQL:
+ALTER INDEX concur_reindex_part_index_0 ATTACH PARTITION concur_reindex_part_index_0_1
+                                        ^
+HINT:  try \h ALTER INDEX
 CREATE INDEX concur_reindex_part_index_0_2 ON ONLY concur_reindex_part_0_2 (c1);
+ERROR:  at or near "only": syntax error
+DETAIL:  source SQL:
+CREATE INDEX concur_reindex_part_index_0_2 ON ONLY concur_reindex_part_0_2 (c1)
+                                              ^
+HINT:  try \h CREATE INDEX
 ALTER INDEX concur_reindex_part_index_0 ATTACH PARTITION concur_reindex_part_index_0_2;
+ERROR:  at or near "attach": syntax error
+DETAIL:  source SQL:
+ALTER INDEX concur_reindex_part_index_0 ATTACH PARTITION concur_reindex_part_index_0_2
+                                        ^
+HINT:  try \h ALTER INDEX
 SELECT relid, parentrelid, level FROM pg_partition_tree('concur_reindex_part_index')
   ORDER BY relid, level;
-             relid             |         parentrelid         | level 
--------------------------------+-----------------------------+-------
- concur_reindex_part_index     |                             |     0
- concur_reindex_part_index_0   | concur_reindex_part_index   |     1
- concur_reindex_part_index_10  | concur_reindex_part_index   |     1
- concur_reindex_part_index_0_1 | concur_reindex_part_index_0 |     2
- concur_reindex_part_index_0_2 | concur_reindex_part_index_0 |     2
-(5 rows)
-
+ERROR:  unknown function: pg_partition_tree()
 SELECT relid, parentrelid, level FROM pg_partition_tree('concur_reindex_part_index')
   ORDER BY relid, level;
-             relid             |         parentrelid         | level 
--------------------------------+-----------------------------+-------
- concur_reindex_part_index     |                             |     0
- concur_reindex_part_index_0   | concur_reindex_part_index   |     1
- concur_reindex_part_index_10  | concur_reindex_part_index   |     1
- concur_reindex_part_index_0_1 | concur_reindex_part_index_0 |     2
- concur_reindex_part_index_0_2 | concur_reindex_part_index_0 |     2
-(5 rows)
-
+ERROR:  unknown function: pg_partition_tree()
 -- REINDEX should preserve dependencies of partition tree.
 SELECT pg_describe_object(classid, objid, objsubid) as obj,
        pg_describe_object(refclassid,refobjid,refobjsubid) as objref,
@@ -2278,44 +2402,34 @@
             'concur_reindex_part_index_0_1'::regclass,
             'concur_reindex_part_index_0_2'::regclass)
   ORDER BY 1, 2;
-                   obj                    |                   objref                   | deptype 
-------------------------------------------+--------------------------------------------+---------
- column c1 of table concur_reindex_part   | table concur_reindex_part                  | i
- column c2 of table concur_reindex_part_0 | table concur_reindex_part_0                | i
- index concur_reindex_part_index          | column c1 of table concur_reindex_part     | a
- index concur_reindex_part_index_0        | column c1 of table concur_reindex_part_0   | a
- index concur_reindex_part_index_0        | index concur_reindex_part_index            | P
- index concur_reindex_part_index_0        | table concur_reindex_part_0                | S
- index concur_reindex_part_index_0_1      | column c1 of table concur_reindex_part_0_1 | a
- index concur_reindex_part_index_0_1      | index concur_reindex_part_index_0          | P
- index concur_reindex_part_index_0_1      | table concur_reindex_part_0_1              | S
- index concur_reindex_part_index_0_2      | column c1 of table concur_reindex_part_0_2 | a
- index concur_reindex_part_index_0_2      | index concur_reindex_part_index_0          | P
- index concur_reindex_part_index_0_2      | table concur_reindex_part_0_2              | S
- table concur_reindex_part                | schema public                              | n
- table concur_reindex_part_0              | schema public                              | n
- table concur_reindex_part_0              | table concur_reindex_part                  | a
- table concur_reindex_part_0_1            | schema public                              | n
- table concur_reindex_part_0_1            | table concur_reindex_part_0                | a
- table concur_reindex_part_0_2            | schema public                              | n
- table concur_reindex_part_0_2            | table concur_reindex_part_0                | a
-(19 rows)
-
+ERROR:  unknown function: pg_describe_object()
 REINDEX INDEX CONCURRENTLY concur_reindex_part_index_0_1;
+ERROR:  at or near "concurrently": syntax error: unimplemented: this syntax
+DETAIL:  source SQL:
+REINDEX INDEX CONCURRENTLY concur_reindex_part_index_0_1
+              ^
+HINT:  CockroachDB does not require reindexing.
 REINDEX INDEX CONCURRENTLY concur_reindex_part_index_0_2;
+ERROR:  at or near "concurrently": syntax error: unimplemented: this syntax
+DETAIL:  source SQL:
+REINDEX INDEX CONCURRENTLY concur_reindex_part_index_0_2
+              ^
+HINT:  CockroachDB does not require reindexing.
 SELECT relid, parentrelid, level FROM pg_partition_tree('concur_reindex_part_index')
   ORDER BY relid, level;
-             relid             |         parentrelid         | level 
--------------------------------+-----------------------------+-------
- concur_reindex_part_index     |                             |     0
- concur_reindex_part_index_0   | concur_reindex_part_index   |     1
- concur_reindex_part_index_10  | concur_reindex_part_index   |     1
- concur_reindex_part_index_0_1 | concur_reindex_part_index_0 |     2
- concur_reindex_part_index_0_2 | concur_reindex_part_index_0 |     2
-(5 rows)
-
+ERROR:  unknown function: pg_partition_tree()
 REINDEX TABLE CONCURRENTLY concur_reindex_part_0_1;
+ERROR:  at or near "concurrently": syntax error: unimplemented: this syntax
+DETAIL:  source SQL:
+REINDEX TABLE CONCURRENTLY concur_reindex_part_0_1
+              ^
+HINT:  CockroachDB does not require reindexing.
 REINDEX TABLE CONCURRENTLY concur_reindex_part_0_2;
+ERROR:  at or near "concurrently": syntax error: unimplemented: this syntax
+DETAIL:  source SQL:
+REINDEX TABLE CONCURRENTLY concur_reindex_part_0_2
+              ^
+HINT:  CockroachDB does not require reindexing.
 SELECT pg_describe_object(classid, objid, objsubid) as obj,
        pg_describe_object(refclassid,refobjid,refobjsubid) as objref,
        deptype
@@ -2330,57 +2444,46 @@
             'concur_reindex_part_index_0_1'::regclass,
             'concur_reindex_part_index_0_2'::regclass)
   ORDER BY 1, 2;
-                   obj                    |                   objref                   | deptype 
-------------------------------------------+--------------------------------------------+---------
- column c1 of table concur_reindex_part   | table concur_reindex_part                  | i
- column c2 of table concur_reindex_part_0 | table concur_reindex_part_0                | i
- index concur_reindex_part_index          | column c1 of table concur_reindex_part     | a
- index concur_reindex_part_index_0        | column c1 of table concur_reindex_part_0   | a
- index concur_reindex_part_index_0        | index concur_reindex_part_index            | P
- index concur_reindex_part_index_0        | table concur_reindex_part_0                | S
- index concur_reindex_part_index_0_1      | column c1 of table concur_reindex_part_0_1 | a
- index concur_reindex_part_index_0_1      | index concur_reindex_part_index_0          | P
- index concur_reindex_part_index_0_1      | table concur_reindex_part_0_1              | S
- index concur_reindex_part_index_0_2      | column c1 of table concur_reindex_part_0_2 | a
- index concur_reindex_part_index_0_2      | index concur_reindex_part_index_0          | P
- index concur_reindex_part_index_0_2      | table concur_reindex_part_0_2              | S
- table concur_reindex_part                | schema public                              | n
- table concur_reindex_part_0              | schema public                              | n
- table concur_reindex_part_0              | table concur_reindex_part                  | a
- table concur_reindex_part_0_1            | schema public                              | n
- table concur_reindex_part_0_1            | table concur_reindex_part_0                | a
- table concur_reindex_part_0_2            | schema public                              | n
- table concur_reindex_part_0_2            | table concur_reindex_part_0                | a
-(19 rows)
-
+ERROR:  unknown function: pg_describe_object()
 SELECT relid, parentrelid, level FROM pg_partition_tree('concur_reindex_part_index')
   ORDER BY relid, level;
-             relid             |         parentrelid         | level 
--------------------------------+-----------------------------+-------
- concur_reindex_part_index     |                             |     0
- concur_reindex_part_index_0   | concur_reindex_part_index   |     1
- concur_reindex_part_index_10  | concur_reindex_part_index   |     1
- concur_reindex_part_index_0_1 | concur_reindex_part_index_0 |     2
- concur_reindex_part_index_0_2 | concur_reindex_part_index_0 |     2
-(5 rows)
-
+ERROR:  unknown function: pg_partition_tree()
 -- REINDEX for partitioned indexes
 -- REINDEX TABLE fails for partitioned indexes
 -- Top-most parent index
 REINDEX TABLE concur_reindex_part_index; -- error
-ERROR:  "concur_reindex_part_index" is not a table or materialized view
+ERROR:  at or near "concur_reindex_part_index": syntax error: unimplemented: this syntax
+DETAIL:  source SQL:
+REINDEX TABLE concur_reindex_part_index
+              ^
+HINT:  CockroachDB does not require reindexing.
 REINDEX TABLE CONCURRENTLY concur_reindex_part_index; -- error
-ERROR:  "concur_reindex_part_index" is not a table or materialized view
+ERROR:  at or near "concurrently": syntax error: unimplemented: this syntax
+DETAIL:  source SQL:
+REINDEX TABLE CONCURRENTLY concur_reindex_part_index
+              ^
+HINT:  CockroachDB does not require reindexing.
 -- Partitioned index with no leaves
 REINDEX TABLE concur_reindex_part_index_10; -- error
-ERROR:  "concur_reindex_part_index_10" is not a table or materialized view
+ERROR:  at or near "concur_reindex_part_index_10": syntax error: unimplemented: this syntax
+DETAIL:  source SQL:
+REINDEX TABLE concur_reindex_part_index_10
+              ^
+HINT:  CockroachDB does not require reindexing.
 REINDEX TABLE CONCURRENTLY concur_reindex_part_index_10; -- error
-ERROR:  "concur_reindex_part_index_10" is not a table or materialized view
+ERROR:  at or near "concurrently": syntax error: unimplemented: this syntax
+DETAIL:  source SQL:
+REINDEX TABLE CONCURRENTLY concur_reindex_part_index_10
+              ^
+HINT:  CockroachDB does not require reindexing.
 -- Cannot run in a transaction block
 BEGIN;
 REINDEX INDEX concur_reindex_part_index;
-ERROR:  REINDEX INDEX cannot run inside a transaction block
-CONTEXT:  while reindexing partitioned index "public.concur_reindex_part_index"
+ERROR:  at or near "concur_reindex_part_index": syntax error: unimplemented: this syntax
+DETAIL:  source SQL:
+REINDEX INDEX concur_reindex_part_index
+              ^
+HINT:  CockroachDB does not require reindexing.
 ROLLBACK;
 -- Helper functions to track changes of relfilenodes in a partition tree.
 -- Create a table tracking the relfilenode state.
@@ -2397,6 +2500,19 @@
 	 relname, indname);
   END
   $func$ LANGUAGE plpgsql;
+ERROR:  unimplemented: attempted to use a PL/pgSQL statement that is not yet supported
+DETAIL:  stmt_dyn_exec is not yet supported
+HINT:  You have attempted to use a feature that is not yet implemented.
+
+Please check the public issue tracker to check whether this problem is
+already tracked. If you cannot find it there, please report the error
+with details by creating a new issue.
+
+If you would rather not post publicly, please contact us directly
+using the support form.
+
+We appreciate your feedback.
+
 CREATE OR REPLACE FUNCTION compare_relfilenode_part(tabname text)
   RETURNS TABLE (relname name, relkind "char", state text) AS
   $func$
@@ -2412,195 +2528,248 @@
            ORDER BY 1;', tabname);
   END
   $func$ LANGUAGE plpgsql;
+ERROR:  unimplemented: set-returning PL/pgSQL functions are not yet supported
+HINT:  You have attempted to use a feature that is not yet implemented.
+See: https://go.crdb.dev/issue-v/105240/_version_
 --  Check that expected relfilenodes are changed, non-concurrent case.
 SELECT create_relfilenode_part('reindex_index_status', 'concur_reindex_part_index');
- create_relfilenode_part 
--------------------------
- 
-(1 row)
-
+ERROR:  unknown function: create_relfilenode_part()
 REINDEX INDEX concur_reindex_part_index;
+ERROR:  at or near "concur_reindex_part_index": syntax error: unimplemented: this syntax
+DETAIL:  source SQL:
+REINDEX INDEX concur_reindex_part_index
+              ^
+HINT:  CockroachDB does not require reindexing.
 SELECT * FROM compare_relfilenode_part('reindex_index_status');
-            relname            | relkind |          state           
--------------------------------+---------+--------------------------
- concur_reindex_part_index     | I       | relfilenode is unchanged
- concur_reindex_part_index_0   | I       | relfilenode is unchanged
- concur_reindex_part_index_0_1 | i       | relfilenode has changed
- concur_reindex_part_index_0_2 | i       | relfilenode has changed
- concur_reindex_part_index_10  | I       | relfilenode is unchanged
-(5 rows)
-
+ERROR:  unknown function: compare_relfilenode_part()
 DROP TABLE reindex_index_status;
+ERROR:  relation "reindex_index_status" does not exist
 -- concurrent case.
 SELECT create_relfilenode_part('reindex_index_status', 'concur_reindex_part_index');
- create_relfilenode_part 
--------------------------
- 
-(1 row)
-
+ERROR:  unknown function: create_relfilenode_part()
 REINDEX INDEX CONCURRENTLY concur_reindex_part_index;
+ERROR:  at or near "concurrently": syntax error: unimplemented: this syntax
+DETAIL:  source SQL:
+REINDEX INDEX CONCURRENTLY concur_reindex_part_index
+              ^
+HINT:  CockroachDB does not require reindexing.
 SELECT * FROM compare_relfilenode_part('reindex_index_status');
-            relname            | relkind |          state           
--------------------------------+---------+--------------------------
- concur_reindex_part_index     | I       | relfilenode is unchanged
- concur_reindex_part_index_0   | I       | relfilenode is unchanged
- concur_reindex_part_index_0_1 | i       | relfilenode has changed
- concur_reindex_part_index_0_2 | i       | relfilenode has changed
- concur_reindex_part_index_10  | I       | relfilenode is unchanged
-(5 rows)
-
+ERROR:  unknown function: compare_relfilenode_part()
 DROP TABLE reindex_index_status;
+ERROR:  relation "reindex_index_status" does not exist
 -- REINDEX for partitioned tables
 -- REINDEX INDEX fails for partitioned tables
 -- Top-most parent
 REINDEX INDEX concur_reindex_part; -- error
-ERROR:  "concur_reindex_part" is not an index
+ERROR:  at or near "concur_reindex_part": syntax error: unimplemented: this syntax
+DETAIL:  source SQL:
+REINDEX INDEX concur_reindex_part
+              ^
+HINT:  CockroachDB does not require reindexing.
 REINDEX INDEX CONCURRENTLY concur_reindex_part; -- error
-ERROR:  "concur_reindex_part" is not an index
+ERROR:  at or near "concurrently": syntax error: unimplemented: this syntax
+DETAIL:  source SQL:
+REINDEX INDEX CONCURRENTLY concur_reindex_part
+              ^
+HINT:  CockroachDB does not require reindexing.
 -- Partitioned with no leaves
 REINDEX INDEX concur_reindex_part_10; -- error
-ERROR:  "concur_reindex_part_10" is not an index
+ERROR:  at or near "concur_reindex_part_10": syntax error: unimplemented: this syntax
+DETAIL:  source SQL:
+REINDEX INDEX concur_reindex_part_10
+              ^
+HINT:  CockroachDB does not require reindexing.
 REINDEX INDEX CONCURRENTLY concur_reindex_part_10; -- error
-ERROR:  "concur_reindex_part_10" is not an index
+ERROR:  at or near "concurrently": syntax error: unimplemented: this syntax
+DETAIL:  source SQL:
+REINDEX INDEX CONCURRENTLY concur_reindex_part_10
+              ^
+HINT:  CockroachDB does not require reindexing.
 -- Cannot run in a transaction block
 BEGIN;
 REINDEX TABLE concur_reindex_part;
-ERROR:  REINDEX TABLE cannot run inside a transaction block
-CONTEXT:  while reindexing partitioned table "public.concur_reindex_part"
+ERROR:  at or near "concur_reindex_part": syntax error: unimplemented: this syntax
+DETAIL:  source SQL:
+REINDEX TABLE concur_reindex_part
+              ^
+HINT:  CockroachDB does not require reindexing.
 ROLLBACK;
 -- Check that expected relfilenodes are changed, non-concurrent case.
 -- Note that the partition tree changes of the *indexes* need to be checked.
 SELECT create_relfilenode_part('reindex_index_status', 'concur_reindex_part_index');
- create_relfilenode_part 
--------------------------
- 
-(1 row)
-
+ERROR:  unknown function: create_relfilenode_part()
 REINDEX TABLE concur_reindex_part;
+ERROR:  at or near "concur_reindex_part": syntax error: unimplemented: this syntax
+DETAIL:  source SQL:
+REINDEX TABLE concur_reindex_part
+              ^
+HINT:  CockroachDB does not require reindexing.
 SELECT * FROM compare_relfilenode_part('reindex_index_status');
-            relname            | relkind |          state           
--------------------------------+---------+--------------------------
- concur_reindex_part_index     | I       | relfilenode is unchanged
- concur_reindex_part_index_0   | I       | relfilenode is unchanged
- concur_reindex_part_index_0_1 | i       | relfilenode has changed
- concur_reindex_part_index_0_2 | i       | relfilenode has changed
- concur_reindex_part_index_10  | I       | relfilenode is unchanged
-(5 rows)
-
+ERROR:  unknown function: compare_relfilenode_part()
 DROP TABLE reindex_index_status;
+ERROR:  relation "reindex_index_status" does not exist
 -- concurrent case.
 SELECT create_relfilenode_part('reindex_index_status', 'concur_reindex_part_index');
- create_relfilenode_part 
--------------------------
- 
-(1 row)
-
+ERROR:  unknown function: create_relfilenode_part()
 REINDEX TABLE CONCURRENTLY concur_reindex_part;
+ERROR:  at or near "concurrently": syntax error: unimplemented: this syntax
+DETAIL:  source SQL:
+REINDEX TABLE CONCURRENTLY concur_reindex_part
+              ^
+HINT:  CockroachDB does not require reindexing.
 SELECT * FROM compare_relfilenode_part('reindex_index_status');
-            relname            | relkind |          state           
--------------------------------+---------+--------------------------
- concur_reindex_part_index     | I       | relfilenode is unchanged
- concur_reindex_part_index_0   | I       | relfilenode is unchanged
- concur_reindex_part_index_0_1 | i       | relfilenode has changed
- concur_reindex_part_index_0_2 | i       | relfilenode has changed
- concur_reindex_part_index_10  | I       | relfilenode is unchanged
-(5 rows)
-
+ERROR:  unknown function: compare_relfilenode_part()
 DROP TABLE reindex_index_status;
+ERROR:  relation "reindex_index_status" does not exist
 DROP FUNCTION create_relfilenode_part;
+ERROR:  unknown function: create_relfilenode_part()
 DROP FUNCTION compare_relfilenode_part;
+ERROR:  unknown function: compare_relfilenode_part()
 -- Cleanup of partition tree used for REINDEX test.
 DROP TABLE concur_reindex_part;
+ERROR:  relation "concur_reindex_part" does not exist
 -- Check errors
 -- Cannot run inside a transaction block
 BEGIN;
 REINDEX TABLE CONCURRENTLY concur_reindex_tab;
-ERROR:  REINDEX CONCURRENTLY cannot run inside a transaction block
+ERROR:  at or near "concurrently": syntax error: unimplemented: this syntax
+DETAIL:  source SQL:
+REINDEX TABLE CONCURRENTLY concur_reindex_tab
+              ^
+HINT:  CockroachDB does not require reindexing.
 COMMIT;
 REINDEX TABLE CONCURRENTLY pg_class; -- no catalog relation
-ERROR:  cannot reindex system catalogs concurrently
+ERROR:  at or near "concurrently": syntax error: unimplemented: this syntax
+DETAIL:  source SQL:
+REINDEX TABLE CONCURRENTLY pg_class
+              ^
+HINT:  CockroachDB does not require reindexing.
 REINDEX INDEX CONCURRENTLY pg_class_oid_index; -- no catalog index
-ERROR:  cannot reindex system catalogs concurrently
+ERROR:  at or near "concurrently": syntax error: unimplemented: this syntax
+DETAIL:  source SQL:
+REINDEX INDEX CONCURRENTLY pg_class_oid_index
+              ^
+HINT:  CockroachDB does not require reindexing.
 -- These are the toast table and index of pg_authid.
 REINDEX TABLE CONCURRENTLY pg_toast.pg_toast_1260; -- no catalog toast table
-ERROR:  cannot reindex system catalogs concurrently
+ERROR:  at or near "concurrently": syntax error: unimplemented: this syntax
+DETAIL:  source SQL:
+REINDEX TABLE CONCURRENTLY pg_toast.pg_toast_1260
+              ^
+HINT:  CockroachDB does not require reindexing.
 REINDEX INDEX CONCURRENTLY pg_toast.pg_toast_1260_index; -- no catalog toast index
-ERROR:  cannot reindex system catalogs concurrently
+ERROR:  at or near "concurrently": syntax error: unimplemented: this syntax
+DETAIL:  source SQL:
+REINDEX INDEX CONCURRENTLY pg_toast.pg_toast_1260_index
+              ^
+HINT:  CockroachDB does not require reindexing.
 REINDEX SYSTEM CONCURRENTLY postgres; -- not allowed for SYSTEM
-ERROR:  cannot reindex system catalogs concurrently
+ERROR:  at or near "concurrently": syntax error: unimplemented: this syntax
+DETAIL:  source SQL:
+REINDEX SYSTEM CONCURRENTLY postgres
+               ^
+HINT:  CockroachDB does not require reindexing.
 REINDEX (CONCURRENTLY) SYSTEM postgres; -- ditto
-ERROR:  cannot reindex system catalogs concurrently
+ERROR:  at or near "(": syntax error
+DETAIL:  source SQL:
+REINDEX (CONCURRENTLY) SYSTEM postgres
+        ^
 REINDEX (CONCURRENTLY) SYSTEM;  -- ditto
-ERROR:  cannot reindex system catalogs concurrently
+ERROR:  at or near "(": syntax error
+DETAIL:  source SQL:
+REINDEX (CONCURRENTLY) SYSTEM
+        ^
 -- Warns about catalog relations
 REINDEX SCHEMA CONCURRENTLY pg_catalog;
-WARNING:  cannot reindex system catalogs concurrently, skipping all
+ERROR:  at or near "concurrently": syntax error: unimplemented: this syntax
+DETAIL:  source SQL:
+REINDEX SCHEMA CONCURRENTLY pg_catalog
+               ^
+HINT:  CockroachDB does not require reindexing.
 -- Not the current database
 REINDEX DATABASE not_current_database;
-ERROR:  can only reindex the currently open database
+ERROR:  at or near "not_current_database": syntax error: unimplemented: this syntax
+DETAIL:  source SQL:
+REINDEX DATABASE not_current_database
+                 ^
+HINT:  CockroachDB does not require reindexing.
 -- Check the relation status, there should not be invalid indexes
 \d concur_reindex_tab
-         Table "public.concur_reindex_tab"
- Column |  Type   | Collation | Nullable | Default 
---------+---------+-----------+----------+---------
- c1     | integer |           | not null | 
- c2     | text    |           |          | 
-Indexes:
-    "concur_reindex_ind1" PRIMARY KEY, btree (c1)
-    "concur_reindex_ind2" btree (c2)
-    "concur_reindex_ind3" UNIQUE, btree (abs(c1))
-    "concur_reindex_ind4" btree (c1, c1, c2)
-Referenced by:
-    TABLE "concur_reindex_tab2" CONSTRAINT "concur_reindex_tab2_c1_fkey" FOREIGN KEY (c1) REFERENCES concur_reindex_tab(c1)
-
+ERROR:  at or near ".": syntax error
+DETAIL:  source SQL:
+SELECT c.oid,
+  n.nspname,
+  c.relname
+FROM pg_catalog.pg_class c
+     LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace
+WHERE c.relname OPERATOR(pg_catalog.~) '^(concur_reindex_tab)$' COLLATE pg_catalog.default
+                                                                                  ^
 DROP MATERIALIZED VIEW concur_reindex_matview;
 DROP TABLE concur_reindex_tab, concur_reindex_tab2, concur_reindex_tab3;
+ERROR:  relation "concur_reindex_tab3" does not exist
 -- Check handling of invalid indexes
 CREATE TABLE concur_reindex_tab4 (c1 int);
 INSERT INTO concur_reindex_tab4 VALUES (1), (1), (2);
 -- This trick creates an invalid index.
 CREATE UNIQUE INDEX CONCURRENTLY concur_reindex_ind5 ON concur_reindex_tab4 (c1);
-ERROR:  could not create unique index "concur_reindex_ind5"
-DETAIL:  Key (c1)=(1) is duplicated.
+ERROR:  failed to ingest index entries during backfill: duplicate key value violates unique constraint "concur_reindex_ind5"
+DETAIL:  Key (c1)=(1) already exists.
 -- Reindexing concurrently this index fails with the same failure.
 -- The extra index created is itself invalid, and can be dropped.
 REINDEX INDEX CONCURRENTLY concur_reindex_ind5;
-ERROR:  could not create unique index "concur_reindex_ind5_ccnew"
-DETAIL:  Key (c1)=(1) is duplicated.
+ERROR:  at or near "concurrently": syntax error: unimplemented: this syntax
+DETAIL:  source SQL:
+REINDEX INDEX CONCURRENTLY concur_reindex_ind5
+              ^
+HINT:  CockroachDB does not require reindexing.
 \d concur_reindex_tab4
-        Table "public.concur_reindex_tab4"
- Column |  Type   | Collation | Nullable | Default 
---------+---------+-----------+----------+---------
- c1     | integer |           |          | 
-Indexes:
-    "concur_reindex_ind5" UNIQUE, btree (c1) INVALID
-    "concur_reindex_ind5_ccnew" UNIQUE, btree (c1) INVALID
-
+ERROR:  at or near ".": syntax error
+DETAIL:  source SQL:
+SELECT c.oid,
+  n.nspname,
+  c.relname
+FROM pg_catalog.pg_class c
+     LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace
+WHERE c.relname OPERATOR(pg_catalog.~) '^(concur_reindex_tab4)$' COLLATE pg_catalog.default
+                                                                                   ^
 DROP INDEX concur_reindex_ind5_ccnew;
+ERROR:  index "concur_reindex_ind5_ccnew" does not exist
 -- This makes the previous failure go away, so the index can become valid.
 DELETE FROM concur_reindex_tab4 WHERE c1 = 1;
 -- The invalid index is not processed when running REINDEX TABLE.
 REINDEX TABLE CONCURRENTLY concur_reindex_tab4;
-WARNING:  cannot reindex invalid index "public.concur_reindex_ind5" concurrently, skipping
-NOTICE:  table "concur_reindex_tab4" has no indexes that can be reindexed concurrently
+ERROR:  at or near "concurrently": syntax error: unimplemented: this syntax
+DETAIL:  source SQL:
+REINDEX TABLE CONCURRENTLY concur_reindex_tab4
+              ^
+HINT:  CockroachDB does not require reindexing.
 \d concur_reindex_tab4
-        Table "public.concur_reindex_tab4"
- Column |  Type   | Collation | Nullable | Default 
---------+---------+-----------+----------+---------
- c1     | integer |           |          | 
-Indexes:
-    "concur_reindex_ind5" UNIQUE, btree (c1) INVALID
-
+ERROR:  at or near ".": syntax error
+DETAIL:  source SQL:
+SELECT c.oid,
+  n.nspname,
+  c.relname
+FROM pg_catalog.pg_class c
+     LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace
+WHERE c.relname OPERATOR(pg_catalog.~) '^(concur_reindex_tab4)$' COLLATE pg_catalog.default
+                                                                                   ^
 -- But it is fixed with REINDEX INDEX.
 REINDEX INDEX CONCURRENTLY concur_reindex_ind5;
+ERROR:  at or near "concurrently": syntax error: unimplemented: this syntax
+DETAIL:  source SQL:
+REINDEX INDEX CONCURRENTLY concur_reindex_ind5
+              ^
+HINT:  CockroachDB does not require reindexing.
 \d concur_reindex_tab4
-        Table "public.concur_reindex_tab4"
- Column |  Type   | Collation | Nullable | Default 
---------+---------+-----------+----------+---------
- c1     | integer |           |          | 
-Indexes:
-    "concur_reindex_ind5" UNIQUE, btree (c1)
-
+ERROR:  at or near ".": syntax error
+DETAIL:  source SQL:
+SELECT c.oid,
+  n.nspname,
+  c.relname
+FROM pg_catalog.pg_class c
+     LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace
+WHERE c.relname OPERATOR(pg_catalog.~) '^(concur_reindex_tab4)$' COLLATE pg_catalog.default
+                                                                                   ^
 DROP TABLE concur_reindex_tab4;
 -- Check handling of indexes with expressions and predicates.  The
 -- definitions of the rebuilt indexes should match the original
@@ -2613,76 +2782,78 @@
   ON concur_exprs_tab ((c1::text COLLATE "C"));
 CREATE UNIQUE INDEX concur_exprs_index_pred ON concur_exprs_tab (c1)
   WHERE (c1::text > 500000000::text COLLATE "C");
+ERROR:  invalid locale c: language: tag is not well-formed
 CREATE UNIQUE INDEX concur_exprs_index_pred_2
   ON concur_exprs_tab ((1 / c1))
   WHERE ('-H') >= (c2::TEXT) COLLATE "C";
 ALTER INDEX concur_exprs_index_expr ALTER COLUMN 1 SET STATISTICS 100;
+ERROR:  at or near "alter": syntax error
+DETAIL:  source SQL:
+ALTER INDEX concur_exprs_index_expr ALTER COLUMN 1 SET STATISTICS 100
+                                    ^
+HINT:  try \h ALTER INDEX
 ANALYZE concur_exprs_tab;
 SELECT starelid::regclass, count(*) FROM pg_statistic WHERE starelid IN (
   'concur_exprs_index_expr'::regclass,
   'concur_exprs_index_pred'::regclass,
   'concur_exprs_index_pred_2'::regclass)
   GROUP BY starelid ORDER BY starelid::regclass::text;
-        starelid         | count 
--------------------------+-------
- concur_exprs_index_expr |     1
-(1 row)
+ starelid | count 
+----------+-------
+(0 rows)
 
 SELECT pg_get_indexdef('concur_exprs_index_expr'::regclass);
-                                                pg_get_indexdef                                                
----------------------------------------------------------------------------------------------------------------
- CREATE UNIQUE INDEX concur_exprs_index_expr ON public.concur_exprs_tab USING btree (((c1)::text) COLLATE "C")
+                                              pg_get_indexdef                                               
+------------------------------------------------------------------------------------------------------------
+ CREATE UNIQUE INDEX concur_exprs_index_expr ON root.public.concur_exprs_tab USING btree ((c1::STRING) ASC)
 (1 row)
 
 SELECT pg_get_indexdef('concur_exprs_index_pred'::regclass);
-                                                               pg_get_indexdef                                                                
-----------------------------------------------------------------------------------------------------------------------------------------------
- CREATE UNIQUE INDEX concur_exprs_index_pred ON public.concur_exprs_tab USING btree (c1) WHERE ((c1)::text > ((500000000)::text COLLATE "C"))
-(1 row)
-
+ERROR:  relation "concur_exprs_index_pred" does not exist
 SELECT pg_get_indexdef('concur_exprs_index_pred_2'::regclass);
-                                                                 pg_get_indexdef                                                                  
---------------------------------------------------------------------------------------------------------------------------------------------------
- CREATE UNIQUE INDEX concur_exprs_index_pred_2 ON public.concur_exprs_tab USING btree (((1 / c1))) WHERE ('-H'::text >= ((c2)::text COLLATE "C"))
+                                                               pg_get_indexdef                                                               
+---------------------------------------------------------------------------------------------------------------------------------------------
+ CREATE UNIQUE INDEX concur_exprs_index_pred_2 ON root.public.concur_exprs_tab USING btree ((1 / c1) ASC) WHERE ('-H'::STRING >= c2::STRING)
 (1 row)
 
 REINDEX TABLE CONCURRENTLY concur_exprs_tab;
+ERROR:  at or near "concurrently": syntax error: unimplemented: this syntax
+DETAIL:  source SQL:
+REINDEX TABLE CONCURRENTLY concur_exprs_tab
+              ^
+HINT:  CockroachDB does not require reindexing.
 SELECT pg_get_indexdef('concur_exprs_index_expr'::regclass);
-                                                pg_get_indexdef                                                
----------------------------------------------------------------------------------------------------------------
- CREATE UNIQUE INDEX concur_exprs_index_expr ON public.concur_exprs_tab USING btree (((c1)::text) COLLATE "C")
+                                              pg_get_indexdef                                               
+------------------------------------------------------------------------------------------------------------
+ CREATE UNIQUE INDEX concur_exprs_index_expr ON root.public.concur_exprs_tab USING btree ((c1::STRING) ASC)
 (1 row)
 
 SELECT pg_get_indexdef('concur_exprs_index_pred'::regclass);
-                                                               pg_get_indexdef                                                                
-----------------------------------------------------------------------------------------------------------------------------------------------
- CREATE UNIQUE INDEX concur_exprs_index_pred ON public.concur_exprs_tab USING btree (c1) WHERE ((c1)::text > ((500000000)::text COLLATE "C"))
-(1 row)
-
+ERROR:  relation "concur_exprs_index_pred" does not exist
 SELECT pg_get_indexdef('concur_exprs_index_pred_2'::regclass);
-                                                                 pg_get_indexdef                                                                  
---------------------------------------------------------------------------------------------------------------------------------------------------
- CREATE UNIQUE INDEX concur_exprs_index_pred_2 ON public.concur_exprs_tab USING btree (((1 / c1))) WHERE ('-H'::text >= ((c2)::text COLLATE "C"))
+                                                               pg_get_indexdef                                                               
+---------------------------------------------------------------------------------------------------------------------------------------------
+ CREATE UNIQUE INDEX concur_exprs_index_pred_2 ON root.public.concur_exprs_tab USING btree ((1 / c1) ASC) WHERE ('-H'::STRING >= c2::STRING)
 (1 row)
 
 -- ALTER TABLE recreates the indexes, which should keep their collations.
 ALTER TABLE concur_exprs_tab ALTER c2 TYPE TEXT;
+ERROR:  cannot alter type of column "c2" because it is referenced by partial index "concur_exprs_index_pred_2"
+HINT:  drop the partial index first, then alter type of the column
+--
+See: https://go.crdb.dev/issue-v/97372/_version_
 SELECT pg_get_indexdef('concur_exprs_index_expr'::regclass);
-                                                pg_get_indexdef                                                
----------------------------------------------------------------------------------------------------------------
- CREATE UNIQUE INDEX concur_exprs_index_expr ON public.concur_exprs_tab USING btree (((c1)::text) COLLATE "C")
+                                              pg_get_indexdef                                               
+------------------------------------------------------------------------------------------------------------
+ CREATE UNIQUE INDEX concur_exprs_index_expr ON root.public.concur_exprs_tab USING btree ((c1::STRING) ASC)
 (1 row)
 
 SELECT pg_get_indexdef('concur_exprs_index_pred'::regclass);
-                                                               pg_get_indexdef                                                                
-----------------------------------------------------------------------------------------------------------------------------------------------
- CREATE UNIQUE INDEX concur_exprs_index_pred ON public.concur_exprs_tab USING btree (c1) WHERE ((c1)::text > ((500000000)::text COLLATE "C"))
-(1 row)
-
+ERROR:  relation "concur_exprs_index_pred" does not exist
 SELECT pg_get_indexdef('concur_exprs_index_pred_2'::regclass);
-                                                             pg_get_indexdef                                                              
-------------------------------------------------------------------------------------------------------------------------------------------
- CREATE UNIQUE INDEX concur_exprs_index_pred_2 ON public.concur_exprs_tab USING btree (((1 / c1))) WHERE ('-H'::text >= (c2 COLLATE "C"))
+                                                               pg_get_indexdef                                                               
+---------------------------------------------------------------------------------------------------------------------------------------------
+ CREATE UNIQUE INDEX concur_exprs_index_pred_2 ON root.public.concur_exprs_tab USING btree ((1 / c1) ASC) WHERE ('-H'::STRING >= c2::STRING)
 (1 row)
 
 -- Statistics should remain intact.
@@ -2691,10 +2862,9 @@
   'concur_exprs_index_pred'::regclass,
   'concur_exprs_index_pred_2'::regclass)
   GROUP BY starelid ORDER BY starelid::regclass::text;
-        starelid         | count 
--------------------------+-------
- concur_exprs_index_expr |     1
-(1 row)
+ starelid | count 
+----------+-------
+(0 rows)
 
 -- attstattarget should remain intact
 SELECT attrelid::regclass, attnum, attstattarget
@@ -2703,13 +2873,7 @@
     'concur_exprs_index_pred'::regclass,
     'concur_exprs_index_pred_2'::regclass)
   ORDER BY attrelid::regclass::text, attnum;
-         attrelid          | attnum | attstattarget 
----------------------------+--------+---------------
- concur_exprs_index_expr   |      1 |           100
- concur_exprs_index_pred   |      1 |            -1
- concur_exprs_index_pred_2 |      1 |            -1
-(3 rows)
-
+ERROR:  relation "concur_exprs_index_pred" does not exist
 DROP TABLE concur_exprs_tab;
 -- Temporary tables and on-commit actions, where CONCURRENTLY is ignored.
 -- ON COMMIT PRESERVE ROWS, the default.
@@ -2718,58 +2882,103 @@
 INSERT INTO concur_temp_tab_1 VALUES (1, 'foo'), (2, 'bar');
 CREATE INDEX concur_temp_ind_1 ON concur_temp_tab_1(c2);
 REINDEX TABLE CONCURRENTLY concur_temp_tab_1;
+ERROR:  at or near "concurrently": syntax error: unimplemented: this syntax
+DETAIL:  source SQL:
+REINDEX TABLE CONCURRENTLY concur_temp_tab_1
+              ^
+HINT:  CockroachDB does not require reindexing.
 REINDEX INDEX CONCURRENTLY concur_temp_ind_1;
+ERROR:  at or near "concurrently": syntax error: unimplemented: this syntax
+DETAIL:  source SQL:
+REINDEX INDEX CONCURRENTLY concur_temp_ind_1
+              ^
+HINT:  CockroachDB does not require reindexing.
 -- Still fails in transaction blocks
 BEGIN;
 REINDEX INDEX CONCURRENTLY concur_temp_ind_1;
-ERROR:  REINDEX CONCURRENTLY cannot run inside a transaction block
+ERROR:  at or near "concurrently": syntax error: unimplemented: this syntax
+DETAIL:  source SQL:
+REINDEX INDEX CONCURRENTLY concur_temp_ind_1
+              ^
+HINT:  CockroachDB does not require reindexing.
 COMMIT;
 -- ON COMMIT DELETE ROWS
 CREATE TEMP TABLE concur_temp_tab_2 (c1 int, c2 text)
   ON COMMIT DELETE ROWS;
+ERROR:  at or near "EOF": syntax error: unimplemented: this syntax
+DETAIL:  source SQL:
+CREATE TEMP TABLE concur_temp_tab_2 (c1 int, c2 text)
+  ON COMMIT DELETE ROWS
+                       ^
+HINT:  You have attempted to use a feature that is not yet implemented.
+See: https://go.crdb.dev/issue-v/46556/_version_
 CREATE INDEX concur_temp_ind_2 ON concur_temp_tab_2(c2);
+ERROR:  relation "concur_temp_tab_2" does not exist
 REINDEX TABLE CONCURRENTLY concur_temp_tab_2;
+ERROR:  at or near "concurrently": syntax error: unimplemented: this syntax
+DETAIL:  source SQL:
+REINDEX TABLE CONCURRENTLY concur_temp_tab_2
+              ^
+HINT:  CockroachDB does not require reindexing.
 REINDEX INDEX CONCURRENTLY concur_temp_ind_2;
+ERROR:  at or near "concurrently": syntax error: unimplemented: this syntax
+DETAIL:  source SQL:
+REINDEX INDEX CONCURRENTLY concur_temp_ind_2
+              ^
+HINT:  CockroachDB does not require reindexing.
 -- ON COMMIT DROP
 BEGIN;
 CREATE TEMP TABLE concur_temp_tab_3 (c1 int, c2 text)
   ON COMMIT PRESERVE ROWS;
+NOTICE:  auto-committing transaction before processing DDL due to autocommit_before_ddl setting
 INSERT INTO concur_temp_tab_3 VALUES (1, 'foo'), (2, 'bar');
 CREATE INDEX concur_temp_ind_3 ON concur_temp_tab_3(c2);
 -- Fails when running in a transaction
 REINDEX INDEX CONCURRENTLY concur_temp_ind_3;
-ERROR:  REINDEX CONCURRENTLY cannot run inside a transaction block
+ERROR:  at or near "concurrently": syntax error: unimplemented: this syntax
+DETAIL:  source SQL:
+REINDEX INDEX CONCURRENTLY concur_temp_ind_3
+              ^
+HINT:  CockroachDB does not require reindexing.
 COMMIT;
+WARNING:  there is no transaction in progress
 -- REINDEX SCHEMA processes all temporary relations
 CREATE TABLE reindex_temp_before AS
 SELECT oid, relname, relfilenode, relkind, reltoastrelid
   FROM pg_class
   WHERE relname IN ('concur_temp_ind_1', 'concur_temp_ind_2');
+NOTICE:  CREATE TABLE ... AS does not copy over indexes, default expressions, or constraints; the new table has a hidden rowid primary key column
 SELECT pg_my_temp_schema()::regnamespace as temp_schema_name \gset
-REINDEX SCHEMA CONCURRENTLY :temp_schema_name;
+-- REINDEX SCHEMA CONCURRENTLY :temp_schema_name;
 SELECT  b.relname,
         b.relkind,
         CASE WHEN a.relfilenode = b.relfilenode THEN 'relfilenode is unchanged'
         ELSE 'relfilenode has changed' END
   FROM reindex_temp_before b JOIN pg_class a ON b.oid = a.oid
   ORDER BY 1;
-      relname      | relkind |          case           
--------------------+---------+-------------------------
- concur_temp_ind_1 | i       | relfilenode has changed
- concur_temp_ind_2 | i       | relfilenode has changed
-(2 rows)
+      relname      | relkind |           case           
+-------------------+---------+--------------------------
+ concur_temp_ind_1 | i       | relfilenode is unchanged
+(1 row)
 
 DROP TABLE concur_temp_tab_1, concur_temp_tab_2, reindex_temp_before;
+ERROR:  relation "concur_temp_tab_2" does not exist
 --
 -- REINDEX SCHEMA
 --
 REINDEX SCHEMA schema_to_reindex; -- failure, schema does not exist
-ERROR:  schema "schema_to_reindex" does not exist
+ERROR:  at or near "schema_to_reindex": syntax error: unimplemented: this syntax
+DETAIL:  source SQL:
+REINDEX SCHEMA schema_to_reindex
+               ^
+HINT:  CockroachDB does not require reindexing.
 CREATE SCHEMA schema_to_reindex;
 SET search_path = 'schema_to_reindex';
 CREATE TABLE table1(col1 SERIAL PRIMARY KEY);
+NOTICE:  using sequential values in a primary key does not perform as well as using random UUIDs. See https://www.cockroachlabs.com/docs/_version_/serial.html
 INSERT INTO table1 SELECT generate_series(1,400);
 CREATE TABLE table2(col1 SERIAL PRIMARY KEY, col2 TEXT NOT NULL);
+NOTICE:  using sequential values in a primary key does not perform as well as using random UUIDs. See https://www.cockroachlabs.com/docs/_version_/serial.html
 INSERT INTO table2 SELECT generate_series(1,400), 'abc';
 CREATE INDEX ON table2(col2);
 CREATE MATERIALIZED VIEW matview AS SELECT col1 FROM table2;
@@ -2779,6 +2988,7 @@
 SELECT oid, relname, relfilenode, relkind, reltoastrelid
 	FROM pg_class
 	where relnamespace = (SELECT oid FROM pg_namespace WHERE nspname = 'schema_to_reindex');
+NOTICE:  CREATE TABLE ... AS does not copy over indexes, default expressions, or constraints; the new table has a hidden rowid primary key column
 INSERT INTO reindex_before
 SELECT oid, 'pg_toast_TABLE', relfilenode, relkind, reltoastrelid
 FROM pg_class WHERE oid IN
@@ -2789,60 +2999,84 @@
 	(select indexrelid from pg_index where indrelid in
 		(select reltoastrelid from reindex_before where reltoastrelid > 0));
 REINDEX SCHEMA schema_to_reindex;
+ERROR:  at or near "schema_to_reindex": syntax error: unimplemented: this syntax
+DETAIL:  source SQL:
+REINDEX SCHEMA schema_to_reindex
+               ^
+HINT:  CockroachDB does not require reindexing.
 CREATE TABLE reindex_after AS SELECT oid, relname, relfilenode, relkind
 	FROM pg_class
 	where relnamespace = (SELECT oid FROM pg_namespace WHERE nspname = 'schema_to_reindex');
+NOTICE:  CREATE TABLE ... AS does not copy over indexes, default expressions, or constraints; the new table has a hidden rowid primary key column
 SELECT  b.relname,
         b.relkind,
         CASE WHEN a.relfilenode = b.relfilenode THEN 'relfilenode is unchanged'
         ELSE 'relfilenode has changed' END
   FROM reindex_before b JOIN pg_class a ON b.oid = a.oid
   ORDER BY 1;
-       relname        | relkind |           case           
-----------------------+---------+--------------------------
- matview              | m       | relfilenode is unchanged
- matview_col1_idx     | i       | relfilenode has changed
- pg_toast_TABLE       | t       | relfilenode is unchanged
- pg_toast_TABLE_index | i       | relfilenode has changed
- table1               | r       | relfilenode is unchanged
- table1_col1_seq      | S       | relfilenode is unchanged
- table1_pkey          | i       | relfilenode has changed
- table2               | r       | relfilenode is unchanged
- table2_col1_seq      | S       | relfilenode is unchanged
- table2_col2_idx      | i       | relfilenode has changed
- table2_pkey          | i       | relfilenode has changed
- view                 | v       | relfilenode is unchanged
-(12 rows)
+     relname      | relkind |           case           
+------------------+---------+--------------------------
+ matview          | m       | relfilenode is unchanged
+ matview_col1_idx | i       | relfilenode is unchanged
+ matview_pkey     | i       | relfilenode is unchanged
+ table1           | r       | relfilenode is unchanged
+ table1_pkey      | i       | relfilenode is unchanged
+ table2           | r       | relfilenode is unchanged
+ table2_col2_idx  | i       | relfilenode is unchanged
+ table2_pkey      | i       | relfilenode is unchanged
+ view             | v       | relfilenode is unchanged
+(9 rows)
 
 REINDEX SCHEMA schema_to_reindex;
+ERROR:  at or near "schema_to_reindex": syntax error: unimplemented: this syntax
+DETAIL:  source SQL:
+REINDEX SCHEMA schema_to_reindex
+               ^
+HINT:  CockroachDB does not require reindexing.
 BEGIN;
 REINDEX SCHEMA schema_to_reindex; -- failure, cannot run in a transaction
-ERROR:  REINDEX SCHEMA cannot run inside a transaction block
+ERROR:  at or near "schema_to_reindex": syntax error: unimplemented: this syntax
+DETAIL:  source SQL:
+REINDEX SCHEMA schema_to_reindex
+               ^
+HINT:  CockroachDB does not require reindexing.
 END;
 -- concurrently
 REINDEX SCHEMA CONCURRENTLY schema_to_reindex;
+ERROR:  at or near "concurrently": syntax error: unimplemented: this syntax
+DETAIL:  source SQL:
+REINDEX SCHEMA CONCURRENTLY schema_to_reindex
+               ^
+HINT:  CockroachDB does not require reindexing.
 -- Failure for unauthorized user
 CREATE ROLE regress_reindexuser NOLOGIN;
 SET SESSION ROLE regress_reindexuser;
 REINDEX SCHEMA schema_to_reindex;
-ERROR:  must be owner of schema schema_to_reindex
+ERROR:  at or near "schema_to_reindex": syntax error: unimplemented: this syntax
+DETAIL:  source SQL:
+REINDEX SCHEMA schema_to_reindex
+               ^
+HINT:  CockroachDB does not require reindexing.
 -- Permission failures with toast tables and indexes (pg_authid here)
 RESET ROLE;
 GRANT USAGE ON SCHEMA pg_toast TO regress_reindexuser;
+ERROR:  unknown schema "pg_toast"
 SET SESSION ROLE regress_reindexuser;
 REINDEX TABLE pg_toast.pg_toast_1260;
-ERROR:  must be owner of table pg_toast_1260
+ERROR:  at or near "pg_toast": syntax error: unimplemented: this syntax
+DETAIL:  source SQL:
+REINDEX TABLE pg_toast.pg_toast_1260
+              ^
+HINT:  CockroachDB does not require reindexing.
 REINDEX INDEX pg_toast.pg_toast_1260_index;
-ERROR:  must be owner of index pg_toast_1260_index
+ERROR:  at or near "pg_toast": syntax error: unimplemented: this syntax
+DETAIL:  source SQL:
+REINDEX INDEX pg_toast.pg_toast_1260_index
+              ^
+HINT:  CockroachDB does not require reindexing.
 -- Clean up
 RESET ROLE;
 REVOKE USAGE ON SCHEMA pg_toast FROM regress_reindexuser;
+ERROR:  unknown schema "pg_toast"
 DROP ROLE regress_reindexuser;
 DROP SCHEMA schema_to_reindex CASCADE;
-NOTICE:  drop cascades to 6 other objects
-DETAIL:  drop cascades to table table1
-drop cascades to table table2
-drop cascades to materialized view matview
-drop cascades to view view
-drop cascades to table reindex_before
-drop cascades to table reindex_after
