diff -U3 --label=/mnt/data1/postgres/src/test/regress/expected/triggers.out --label=/mnt/data1/postgres/src/test/regress/results/triggers.out /mnt/data1/postgres/src/test/regress/expected/triggers.out /mnt/data1/postgres/src/test/regress/results/triggers.out
--- /mnt/data1/postgres/src/test/regress/expected/triggers.out
+++ /mnt/data1/postgres/src/test/regress/results/triggers.out
@@ -3,7 +3,9 @@
 --
 -- directory paths and dlsuffix are passed to us in environment variables
 \getenv libdir PG_LIBDIR
+invalid command \getenv
 \getenv dlsuffix PG_DLSUFFIX
+invalid command \getenv
 \set autoinclib :libdir '/autoinc' :dlsuffix
 \set refintlib :libdir '/refint' :dlsuffix
 \set regresslib :libdir '/regress' :dlsuffix
@@ -11,22 +13,37 @@
 	RETURNS trigger
 	AS :'autoinclib'
 	LANGUAGE C;
+ERROR:  unimplemented: C is not yet supported
+HINT:  You have attempted to use a feature that is not yet implemented.
+See: https://go.crdb.dev/issue-v/102201/_version_
 CREATE FUNCTION check_primary_key ()
 	RETURNS trigger
 	AS :'refintlib'
 	LANGUAGE C;
+ERROR:  unimplemented: C is not yet supported
+HINT:  You have attempted to use a feature that is not yet implemented.
+See: https://go.crdb.dev/issue-v/102201/_version_
 CREATE FUNCTION check_foreign_key ()
 	RETURNS trigger
 	AS :'refintlib'
 	LANGUAGE C;
+ERROR:  unimplemented: C is not yet supported
+HINT:  You have attempted to use a feature that is not yet implemented.
+See: https://go.crdb.dev/issue-v/102201/_version_
 CREATE FUNCTION trigger_return_old ()
         RETURNS trigger
         AS :'regresslib'
         LANGUAGE C;
+ERROR:  unimplemented: C is not yet supported
+HINT:  You have attempted to use a feature that is not yet implemented.
+See: https://go.crdb.dev/issue-v/102201/_version_
 CREATE FUNCTION set_ttdummy (int4)
         RETURNS int4
         AS :'regresslib'
         LANGUAGE C STRICT;
+ERROR:  unimplemented: C is not yet supported
+HINT:  You have attempted to use a feature that is not yet implemented.
+See: https://go.crdb.dev/issue-v/102201/_version_
 create table pkeys (pkey1 int4 not null, pkey2 text not null);
 create table fkeys (fkey1 int4, fkey2 text, fkey3 int);
 create table fkeys2 (fkey21 int4, fkey22 text, pkey23 int not null);
@@ -50,10 +67,12 @@
 	for each row
 	execute function
 	check_primary_key ('fkey1', 'fkey2', 'pkeys', 'pkey1', 'pkey2');
+ERROR:  unknown function: check_primary_key()
 create trigger check_fkeys_pkey2_exist
 	before insert or update on fkeys
 	for each row
 	execute function check_primary_key ('fkey3', 'fkeys2', 'pkey23');
+ERROR:  unknown function: check_primary_key()
 --
 -- For fkeys2:
 -- 	(fkey21, fkey22)	--> pkeys (pkey1, pkey2)
@@ -63,11 +82,23 @@
 	for each row
 	execute procedure
 	check_primary_key ('fkey21', 'fkey22', 'pkeys', 'pkey1', 'pkey2');
+ERROR:  unknown function: check_primary_key()
 -- Test comments
 COMMENT ON TRIGGER check_fkeys2_pkey_bad ON fkeys2 IS 'wrong';
-ERROR:  trigger "check_fkeys2_pkey_bad" for table "fkeys2" does not exist
+ERROR:  at or near "trigger": syntax error
+DETAIL:  source SQL:
+COMMENT ON TRIGGER check_fkeys2_pkey_bad ON fkeys2 IS 'wrong'
+           ^
 COMMENT ON TRIGGER check_fkeys2_pkey_exist ON fkeys2 IS 'right';
+ERROR:  at or near "trigger": syntax error
+DETAIL:  source SQL:
+COMMENT ON TRIGGER check_fkeys2_pkey_exist ON fkeys2 IS 'right'
+           ^
 COMMENT ON TRIGGER check_fkeys2_pkey_exist ON fkeys2 IS NULL;
+ERROR:  at or near "trigger": syntax error
+DETAIL:  source SQL:
+COMMENT ON TRIGGER check_fkeys2_pkey_exist ON fkeys2 IS NULL
+           ^
 --
 -- For pkeys:
 -- 	ON DELETE/UPDATE (pkey1, pkey2) CASCADE:
@@ -79,6 +110,7 @@
 	execute procedure
 	check_foreign_key (2, 'cascade', 'pkey1', 'pkey2',
 	'fkeys', 'fkey1', 'fkey2', 'fkeys2', 'fkey21', 'fkey22');
+ERROR:  unknown function: check_foreign_key()
 --
 -- For fkeys2:
 -- 	ON DELETE/UPDATE (pkey23) RESTRICT:
@@ -88,59 +120,36 @@
 	before delete or update on fkeys2
 	for each row
 	execute procedure check_foreign_key (1, 'restrict', 'pkey23', 'fkeys', 'fkey3');
+ERROR:  unknown function: check_foreign_key()
 insert into fkeys2 values (10, '1', 1);
 insert into fkeys2 values (30, '3', 2);
 insert into fkeys2 values (40, '4', 5);
 insert into fkeys2 values (50, '5', 3);
 -- no key in pkeys
 insert into fkeys2 values (70, '5', 3);
-ERROR:  tuple references non-existent key
-DETAIL:  Trigger "check_fkeys2_pkey_exist" found tuple referencing non-existent key in "pkeys".
 insert into fkeys values (10, '1', 2);
 insert into fkeys values (30, '3', 3);
 insert into fkeys values (40, '4', 2);
 insert into fkeys values (50, '5', 2);
 -- no key in pkeys
 insert into fkeys values (70, '5', 1);
-ERROR:  tuple references non-existent key
-DETAIL:  Trigger "check_fkeys_pkey_exist" found tuple referencing non-existent key in "pkeys".
 -- no key in fkeys2
 insert into fkeys values (60, '6', 4);
-ERROR:  tuple references non-existent key
-DETAIL:  Trigger "check_fkeys_pkey2_exist" found tuple referencing non-existent key in "fkeys2".
 delete from pkeys where pkey1 = 30 and pkey2 = '3';
-NOTICE:  check_pkeys_fkey_cascade: 1 tuple(s) of fkeys are deleted
-ERROR:  "check_fkeys2_fkey_restrict": tuple is referenced in "fkeys"
-CONTEXT:  SQL statement "delete from fkeys2 where fkey21 = $1 and fkey22 = $2 "
 delete from pkeys where pkey1 = 40 and pkey2 = '4';
-NOTICE:  check_pkeys_fkey_cascade: 1 tuple(s) of fkeys are deleted
-NOTICE:  check_pkeys_fkey_cascade: 1 tuple(s) of fkeys2 are deleted
 update pkeys set pkey1 = 7, pkey2 = '70' where pkey1 = 50 and pkey2 = '5';
-NOTICE:  check_pkeys_fkey_cascade: 1 tuple(s) of fkeys are deleted
-ERROR:  "check_fkeys2_fkey_restrict": tuple is referenced in "fkeys"
-CONTEXT:  SQL statement "delete from fkeys2 where fkey21 = $1 and fkey22 = $2 "
 update pkeys set pkey1 = 7, pkey2 = '70' where pkey1 = 10 and pkey2 = '1';
-NOTICE:  check_pkeys_fkey_cascade: 1 tuple(s) of fkeys are deleted
-NOTICE:  check_pkeys_fkey_cascade: 1 tuple(s) of fkeys2 are deleted
+ERROR:  duplicate key value violates unique constraint "pkeys_i"
+DETAIL:  Key (pkey1, pkey2)=(7, '70') already exists.
 SELECT trigger_name, event_manipulation, event_object_schema, event_object_table,
        action_order, action_condition, action_orientation, action_timing,
        action_reference_old_table, action_reference_new_table
   FROM information_schema.triggers
   WHERE event_object_table in ('pkeys', 'fkeys', 'fkeys2')
   ORDER BY trigger_name COLLATE "C", 2;
-        trigger_name        | event_manipulation | event_object_schema | event_object_table | action_order | action_condition | action_orientation | action_timing | action_reference_old_table | action_reference_new_table 
-----------------------------+--------------------+---------------------+--------------------+--------------+------------------+--------------------+---------------+----------------------------+----------------------------
- check_fkeys2_fkey_restrict | DELETE             | public              | fkeys2             |            1 |                  | ROW                | BEFORE        |                            | 
- check_fkeys2_fkey_restrict | UPDATE             | public              | fkeys2             |            1 |                  | ROW                | BEFORE        |                            | 
- check_fkeys2_pkey_exist    | INSERT             | public              | fkeys2             |            1 |                  | ROW                | BEFORE        |                            | 
- check_fkeys2_pkey_exist    | UPDATE             | public              | fkeys2             |            2 |                  | ROW                | BEFORE        |                            | 
- check_fkeys_pkey2_exist    | INSERT             | public              | fkeys              |            1 |                  | ROW                | BEFORE        |                            | 
- check_fkeys_pkey2_exist    | UPDATE             | public              | fkeys              |            1 |                  | ROW                | BEFORE        |                            | 
- check_fkeys_pkey_exist     | INSERT             | public              | fkeys              |            2 |                  | ROW                | BEFORE        |                            | 
- check_fkeys_pkey_exist     | UPDATE             | public              | fkeys              |            2 |                  | ROW                | BEFORE        |                            | 
- check_pkeys_fkey_cascade   | DELETE             | public              | pkeys              |            1 |                  | ROW                | BEFORE        |                            | 
- check_pkeys_fkey_cascade   | UPDATE             | public              | pkeys              |            1 |                  | ROW                | BEFORE        |                            | 
-(10 rows)
+ trigger_name | event_manipulation | event_object_schema | event_object_table | action_order | action_condition | action_orientation | action_timing | action_reference_old_table | action_reference_new_table 
+--------------+--------------------+---------------------+--------------------+--------------+------------------+--------------------+---------------+----------------------------+----------------------------
+(0 rows)
 
 DROP TABLE pkeys;
 DROP TABLE fkeys;
@@ -150,6 +159,7 @@
 create trigger trigger_return_old
 	before insert or delete or update on trigtest
 	for each row execute procedure trigger_return_old();
+ERROR:  unknown function: trigger_return_old()
 insert into trigtest values(1, 'foo');
 select * from trigtest;
  f1 | f2  
@@ -159,9 +169,9 @@
 
 update trigtest set f2 = f2 || 'bar';
 select * from trigtest;
- f1 | f2  
-----+-----
-  1 | foo
+ f1 |   f2   
+----+--------
+  1 | foobar
 (1 row)
 
 delete from trigtest;
@@ -176,18 +186,22 @@
 create trigger trigger_alpha
 	before insert or update on trigtest
 	for each row execute procedure f1_times_10();
+ERROR:  no data source matches prefix: new in this context
+HINT:  to access a field of a composite-typed column or variable, surround the column/variable name in parentheses: (varName).fieldName
+--
+See: https://go.crdb.dev/issue-v/114687/_version_
 insert into trigtest values(1, 'foo');
 select * from trigtest;
  f1 | f2  
 ----+-----
- 10 | foo
+  1 | foo
 (1 row)
 
 update trigtest set f2 = f2 || 'bar';
 select * from trigtest;
- f1 | f2  
-----+-----
- 10 | foo
+ f1 |   f2   
+----+--------
+  1 | foobar
 (1 row)
 
 delete from trigtest;
@@ -199,18 +213,22 @@
 create trigger trigger_zed
 	before insert or update on trigtest
 	for each row execute procedure f1_times_10();
+ERROR:  no data source matches prefix: new in this context
+HINT:  to access a field of a composite-typed column or variable, surround the column/variable name in parentheses: (varName).fieldName
+--
+See: https://go.crdb.dev/issue-v/114687/_version_
 insert into trigtest values(1, 'foo');
 select * from trigtest;
- f1  | f2  
------+-----
- 100 | foo
+ f1 | f2  
+----+-----
+  1 | foo
 (1 row)
 
 update trigtest set f2 = f2 || 'bar';
 select * from trigtest;
-  f1  | f2  
-------+-----
- 1000 | foo
+ f1 |   f2   
+----+--------
+  1 | foobar
 (1 row)
 
 delete from trigtest;
@@ -220,18 +238,19 @@
 (0 rows)
 
 drop trigger trigger_alpha on trigtest;
+ERROR:  trigger "trigger_alpha" for table "trigtest" does not exist
 insert into trigtest values(1, 'foo');
 select * from trigtest;
  f1 | f2  
 ----+-----
- 10 | foo
+  1 | foo
 (1 row)
 
 update trigtest set f2 = f2 || 'bar';
 select * from trigtest;
- f1  | f2  
------+-----
- 100 | foo
+ f1 |   f2   
+----+--------
+  1 | foobar
 (1 row)
 
 delete from trigtest;
@@ -249,6 +268,7 @@
 create trigger trigger_return_old
 	before insert or delete or update on trigtest
 	for each row execute procedure trigger_return_old();
+ERROR:  unknown function: trigger_return_old()
 insert into trigtest values(1);
 select * from trigtest;
  a | b |   c   
@@ -266,32 +286,31 @@
 update trigtest set a = 2 where a = 1 returning *;
  a | b |   c   | d  
 ---+---+-------+----
- 1 | t | xyzzy | 42
+ 2 | t | xyzzy | 42
 (1 row)
 
 select * from trigtest;
  a | b |   c   | d  
 ---+---+-------+----
- 1 | t | xyzzy | 42
+ 2 | t | xyzzy | 42
 (1 row)
 
 alter table trigtest drop column b;
 select * from trigtest;
  a |   c   | d  
 ---+-------+----
- 1 | xyzzy | 42
+ 2 | xyzzy | 42
 (1 row)
 
 update trigtest set a = 2 where a = 1 returning *;
- a |   c   | d  
----+-------+----
- 1 | xyzzy | 42
-(1 row)
+ a | c | d 
+---+---+---
+(0 rows)
 
 select * from trigtest;
  a |   c   | d  
 ---+-------+----
- 1 | xyzzy | 42
+ 2 | xyzzy | 42
 (1 row)
 
 drop table trigtest;
@@ -307,38 +326,39 @@
 	for each row
 	execute procedure
 	ttdummy (price_on, price_off);
+ERROR:  unknown function: ttdummy()
 create trigger ttserial
 	before insert or update on tttest
 	for each row
 	execute procedure
 	autoinc (price_on, ttdummy_seq);
+ERROR:  unknown function: autoinc()
 insert into tttest values (1, 1, null);
 insert into tttest values (2, 2, null);
 insert into tttest values (3, 3, 0);
 select * from tttest;
  price_id | price_val | price_on | price_off 
 ----------+-----------+----------+-----------
-        1 |         1 |       10 |    999999
-        2 |         2 |       20 |    999999
-        3 |         3 |       30 |    999999
+        1 |         1 |          |    999999
+        2 |         2 |          |    999999
+        3 |         3 |        0 |    999999
 (3 rows)
 
 delete from tttest where price_id = 2;
 select * from tttest;
  price_id | price_val | price_on | price_off 
 ----------+-----------+----------+-----------
-        1 |         1 |       10 |    999999
-        3 |         3 |       30 |    999999
-        2 |         2 |       20 |        40
-(3 rows)
+        1 |         1 |          |    999999
+        3 |         3 |        0 |    999999
+(2 rows)
 
 -- what do we see ?
 -- get current prices
 select * from tttest where price_off = 999999;
  price_id | price_val | price_on | price_off 
 ----------+-----------+----------+-----------
-        1 |         1 |       10 |    999999
-        3 |         3 |       30 |    999999
+        1 |         1 |          |    999999
+        3 |         3 |        0 |    999999
 (2 rows)
 
 -- change price for price_id == 3
@@ -346,11 +366,9 @@
 select * from tttest;
  price_id | price_val | price_on | price_off 
 ----------+-----------+----------+-----------
-        1 |         1 |       10 |    999999
-        2 |         2 |       20 |        40
-        3 |        30 |       50 |    999999
-        3 |         3 |       30 |        50
-(4 rows)
+        1 |         1 |          |    999999
+        3 |        30 |        0 |    999999
+(2 rows)
 
 -- now we want to change pric_id in ALL tuples
 -- this gets us not what we need
@@ -358,77 +376,51 @@
 select * from tttest;
  price_id | price_val | price_on | price_off 
 ----------+-----------+----------+-----------
-        1 |         1 |       10 |    999999
-        2 |         2 |       20 |        40
-        3 |         3 |       30 |        50
-        5 |        30 |       60 |    999999
-        3 |        30 |       50 |        60
-(5 rows)
+        1 |         1 |          |    999999
+        5 |        30 |        0 |    999999
+(2 rows)
 
 -- restore data as before last update:
 select set_ttdummy(0);
- set_ttdummy 
--------------
-           1
-(1 row)
-
+ERROR:  unknown function: set_ttdummy()
 delete from tttest where price_id = 5;
 update tttest set price_off = 999999 where price_val = 30;
 select * from tttest;
  price_id | price_val | price_on | price_off 
 ----------+-----------+----------+-----------
-        1 |         1 |       10 |    999999
-        2 |         2 |       20 |        40
-        3 |         3 |       30 |        50
-        3 |        30 |       50 |    999999
-(4 rows)
+        1 |         1 |          |    999999
+(1 row)
 
 -- and try change price_id now!
 update tttest set price_id = 5 where price_id = 3;
 select * from tttest;
  price_id | price_val | price_on | price_off 
 ----------+-----------+----------+-----------
-        1 |         1 |       10 |    999999
-        2 |         2 |       20 |        40
-        5 |         3 |       30 |        50
-        5 |        30 |       50 |    999999
-(4 rows)
+        1 |         1 |          |    999999
+(1 row)
 
 -- isn't it what we need ?
 select set_ttdummy(1);
- set_ttdummy 
--------------
-           0
-(1 row)
-
+ERROR:  unknown function: set_ttdummy()
 -- we want to correct some "date"
 update tttest set price_on = -1 where price_id = 1;
-ERROR:  ttdummy (tttest): you cannot change price_on and/or price_off columns (use set_ttdummy)
 -- but this doesn't work
 -- try in this way
 select set_ttdummy(0);
- set_ttdummy 
--------------
-           1
-(1 row)
-
+ERROR:  unknown function: set_ttdummy()
 update tttest set price_on = -1 where price_id = 1;
 select * from tttest;
  price_id | price_val | price_on | price_off 
 ----------+-----------+----------+-----------
-        2 |         2 |       20 |        40
-        5 |         3 |       30 |        50
-        5 |        30 |       50 |    999999
         1 |         1 |       -1 |    999999
-(4 rows)
+(1 row)
 
 -- isn't it what we need ?
 -- get price for price_id == 5 as it was @ "date" 35
 select * from tttest where price_on <= 35 and price_off > 35 and price_id = 5;
  price_id | price_val | price_on | price_off 
 ----------+-----------+----------+-----------
-        5 |         3 |       30 |        50
-(1 row)
+(0 rows)
 
 drop table tttest;
 drop sequence ttdummy_seq;
@@ -445,147 +437,134 @@
 END;';
 CREATE TRIGGER before_ins_stmt_trig BEFORE INSERT ON main_table
 FOR EACH STATEMENT EXECUTE PROCEDURE trigger_func('before_ins_stmt');
+ERROR:  unimplemented: statement-level triggers are not yet supported
+HINT:  You have attempted to use a feature that is not yet implemented.
+See: https://go.crdb.dev/issue-v/126362/_version_
 CREATE TRIGGER after_ins_stmt_trig AFTER INSERT ON main_table
 FOR EACH STATEMENT EXECUTE PROCEDURE trigger_func('after_ins_stmt');
+ERROR:  unimplemented: statement-level triggers are not yet supported
+HINT:  You have attempted to use a feature that is not yet implemented.
+See: https://go.crdb.dev/issue-v/126362/_version_
 --
 -- if neither 'FOR EACH ROW' nor 'FOR EACH STATEMENT' was specified,
 -- CREATE TRIGGER should default to 'FOR EACH STATEMENT'
 --
 CREATE TRIGGER after_upd_stmt_trig AFTER UPDATE ON main_table
 EXECUTE PROCEDURE trigger_func('after_upd_stmt');
+ERROR:  unimplemented: statement-level triggers are not yet supported
+HINT:  You have attempted to use a feature that is not yet implemented.
+See: https://go.crdb.dev/issue-v/126362/_version_
 -- Both insert and update statement level triggers (before and after) should
 -- fire.  Doesn't fire UPDATE before trigger, but only because one isn't
 -- defined.
 INSERT INTO main_table (a, b) VALUES (5, 10) ON CONFLICT (a)
   DO UPDATE SET b = EXCLUDED.b;
-NOTICE:  trigger_func(before_ins_stmt) called: action = INSERT, when = BEFORE, level = STATEMENT
-NOTICE:  trigger_func(after_upd_stmt) called: action = UPDATE, when = AFTER, level = STATEMENT
-NOTICE:  trigger_func(after_ins_stmt) called: action = INSERT, when = AFTER, level = STATEMENT
 CREATE TRIGGER after_upd_row_trig AFTER UPDATE ON main_table
 FOR EACH ROW EXECUTE PROCEDURE trigger_func('after_upd_row');
+ERROR:  unimplemented: referencing the TG_ARGV trigger function parameter is not yet supported
+HINT:  You have attempted to use a feature that is not yet implemented.
+See: https://go.crdb.dev/issue-v/135311/_version_
 INSERT INTO main_table DEFAULT VALUES;
-NOTICE:  trigger_func(before_ins_stmt) called: action = INSERT, when = BEFORE, level = STATEMENT
-NOTICE:  trigger_func(after_ins_stmt) called: action = INSERT, when = AFTER, level = STATEMENT
 UPDATE main_table SET a = a + 1 WHERE b < 30;
-NOTICE:  trigger_func(after_upd_row) called: action = UPDATE, when = AFTER, level = ROW
-NOTICE:  trigger_func(after_upd_row) called: action = UPDATE, when = AFTER, level = ROW
-NOTICE:  trigger_func(after_upd_row) called: action = UPDATE, when = AFTER, level = ROW
-NOTICE:  trigger_func(after_upd_row) called: action = UPDATE, when = AFTER, level = ROW
-NOTICE:  trigger_func(after_upd_stmt) called: action = UPDATE, when = AFTER, level = STATEMENT
 -- UPDATE that effects zero rows should still call per-statement trigger
 UPDATE main_table SET a = a + 2 WHERE b > 100;
-NOTICE:  trigger_func(after_upd_stmt) called: action = UPDATE, when = AFTER, level = STATEMENT
 -- constraint now unneeded
 ALTER TABLE main_table DROP CONSTRAINT main_table_a_key;
+ERROR:  unimplemented: cannot drop UNIQUE constraint "main_table_a_key" using ALTER TABLE DROP CONSTRAINT, use DROP INDEX CASCADE instead
+HINT:  You have attempted to use a feature that is not yet implemented.
+See: https://go.crdb.dev/issue-v/42840/_version_
 -- COPY should fire per-row and per-statement INSERT triggers
 COPY main_table (a, b) FROM stdin;
-NOTICE:  trigger_func(before_ins_stmt) called: action = INSERT, when = BEFORE, level = STATEMENT
-NOTICE:  trigger_func(after_ins_stmt) called: action = INSERT, when = AFTER, level = STATEMENT
+ERROR:  duplicate key value violates unique constraint "main_table_a_key"
+DETAIL:  Key (a)=(50) already exists.
 SELECT * FROM main_table ORDER BY a, b;
  a  | b  
 ----+----
+    |   
   6 | 10
  21 | 20
- 30 | 40
  31 | 10
  50 | 35
- 50 | 60
  81 | 15
-    |   
-(8 rows)
+(6 rows)
 
 --
 -- test triggers with WHEN clause
 --
 CREATE TRIGGER modified_a BEFORE UPDATE OF a ON main_table
 FOR EACH ROW WHEN (OLD.a <> NEW.a) EXECUTE PROCEDURE trigger_func('modified_a');
+ERROR:  unimplemented: column lists are not yet supported for triggers
+HINT:  You have attempted to use a feature that is not yet implemented.
+See: https://go.crdb.dev/issue-v/135656/_version_
 CREATE TRIGGER modified_any BEFORE UPDATE OF a ON main_table
 FOR EACH ROW WHEN (OLD.* IS DISTINCT FROM NEW.*) EXECUTE PROCEDURE trigger_func('modified_any');
+ERROR:  unimplemented: column lists are not yet supported for triggers
+HINT:  You have attempted to use a feature that is not yet implemented.
+See: https://go.crdb.dev/issue-v/135656/_version_
 CREATE TRIGGER insert_a AFTER INSERT ON main_table
 FOR EACH ROW WHEN (NEW.a = 123) EXECUTE PROCEDURE trigger_func('insert_a');
+ERROR:  no data source matches prefix: new in this context
+HINT:  to access a field of a composite-typed column or variable, surround the column/variable name in parentheses: (varName).fieldName
+--
+See: https://go.crdb.dev/issue-v/114687/_version_
 CREATE TRIGGER delete_a AFTER DELETE ON main_table
 FOR EACH ROW WHEN (OLD.a = 123) EXECUTE PROCEDURE trigger_func('delete_a');
+ERROR:  no data source matches prefix: old in this context
+HINT:  to access a field of a composite-typed column or variable, surround the column/variable name in parentheses: (varName).fieldName
+--
+See: https://go.crdb.dev/issue-v/114687/_version_
 CREATE TRIGGER insert_when BEFORE INSERT ON main_table
 FOR EACH STATEMENT WHEN (true) EXECUTE PROCEDURE trigger_func('insert_when');
+ERROR:  unimplemented: statement-level triggers are not yet supported
+HINT:  You have attempted to use a feature that is not yet implemented.
+See: https://go.crdb.dev/issue-v/126362/_version_
 CREATE TRIGGER delete_when AFTER DELETE ON main_table
 FOR EACH STATEMENT WHEN (true) EXECUTE PROCEDURE trigger_func('delete_when');
+ERROR:  unimplemented: statement-level triggers are not yet supported
+HINT:  You have attempted to use a feature that is not yet implemented.
+See: https://go.crdb.dev/issue-v/126362/_version_
 SELECT trigger_name, event_manipulation, event_object_schema, event_object_table,
        action_order, action_condition, action_orientation, action_timing,
        action_reference_old_table, action_reference_new_table
   FROM information_schema.triggers
   WHERE event_object_table IN ('main_table')
   ORDER BY trigger_name COLLATE "C", 2;
-     trigger_name     | event_manipulation | event_object_schema | event_object_table | action_order |        action_condition        | action_orientation | action_timing | action_reference_old_table | action_reference_new_table 
-----------------------+--------------------+---------------------+--------------------+--------------+--------------------------------+--------------------+---------------+----------------------------+----------------------------
- after_ins_stmt_trig  | INSERT             | public              | main_table         |            1 |                                | STATEMENT          | AFTER         |                            | 
- after_upd_row_trig   | UPDATE             | public              | main_table         |            1 |                                | ROW                | AFTER         |                            | 
- after_upd_stmt_trig  | UPDATE             | public              | main_table         |            1 |                                | STATEMENT          | AFTER         |                            | 
- before_ins_stmt_trig | INSERT             | public              | main_table         |            1 |                                | STATEMENT          | BEFORE        |                            | 
- delete_a             | DELETE             | public              | main_table         |            1 | (old.a = 123)                  | ROW                | AFTER         |                            | 
- delete_when          | DELETE             | public              | main_table         |            1 | true                           | STATEMENT          | AFTER         |                            | 
- insert_a             | INSERT             | public              | main_table         |            1 | (new.a = 123)                  | ROW                | AFTER         |                            | 
- insert_when          | INSERT             | public              | main_table         |            2 | true                           | STATEMENT          | BEFORE        |                            | 
- modified_a           | UPDATE             | public              | main_table         |            1 | (old.a <> new.a)               | ROW                | BEFORE        |                            | 
- modified_any         | UPDATE             | public              | main_table         |            2 | (old.* IS DISTINCT FROM new.*) | ROW                | BEFORE        |                            | 
-(10 rows)
+ trigger_name | event_manipulation | event_object_schema | event_object_table | action_order | action_condition | action_orientation | action_timing | action_reference_old_table | action_reference_new_table 
+--------------+--------------------+---------------------+--------------------+--------------+------------------+--------------------+---------------+----------------------------+----------------------------
+(0 rows)
 
 INSERT INTO main_table (a) VALUES (123), (456);
-NOTICE:  trigger_func(before_ins_stmt) called: action = INSERT, when = BEFORE, level = STATEMENT
-NOTICE:  trigger_func(insert_when) called: action = INSERT, when = BEFORE, level = STATEMENT
-NOTICE:  trigger_func(insert_a) called: action = INSERT, when = AFTER, level = ROW
-NOTICE:  trigger_func(after_ins_stmt) called: action = INSERT, when = AFTER, level = STATEMENT
 COPY main_table FROM stdin;
-NOTICE:  trigger_func(before_ins_stmt) called: action = INSERT, when = BEFORE, level = STATEMENT
-NOTICE:  trigger_func(insert_when) called: action = INSERT, when = BEFORE, level = STATEMENT
-NOTICE:  trigger_func(insert_a) called: action = INSERT, when = AFTER, level = ROW
-NOTICE:  trigger_func(after_ins_stmt) called: action = INSERT, when = AFTER, level = STATEMENT
+ERROR:  duplicate key value violates unique constraint "main_table_a_key"
+DETAIL:  Key (a)=(123) already exists.
 DELETE FROM main_table WHERE a IN (123, 456);
-NOTICE:  trigger_func(delete_a) called: action = DELETE, when = AFTER, level = ROW
-NOTICE:  trigger_func(delete_a) called: action = DELETE, when = AFTER, level = ROW
-NOTICE:  trigger_func(delete_when) called: action = DELETE, when = AFTER, level = STATEMENT
 UPDATE main_table SET a = 50, b = 60;
-NOTICE:  trigger_func(modified_any) called: action = UPDATE, when = BEFORE, level = ROW
-NOTICE:  trigger_func(modified_any) called: action = UPDATE, when = BEFORE, level = ROW
-NOTICE:  trigger_func(modified_a) called: action = UPDATE, when = BEFORE, level = ROW
-NOTICE:  trigger_func(modified_a) called: action = UPDATE, when = BEFORE, level = ROW
-NOTICE:  trigger_func(modified_a) called: action = UPDATE, when = BEFORE, level = ROW
-NOTICE:  trigger_func(modified_a) called: action = UPDATE, when = BEFORE, level = ROW
-NOTICE:  trigger_func(modified_a) called: action = UPDATE, when = BEFORE, level = ROW
-NOTICE:  trigger_func(after_upd_row) called: action = UPDATE, when = AFTER, level = ROW
-NOTICE:  trigger_func(after_upd_stmt) called: action = UPDATE, when = AFTER, level = STATEMENT
+ERROR:  duplicate key value violates unique constraint "main_table_a_key"
+DETAIL:  Key (a)=(50) already exists.
 SELECT * FROM main_table ORDER BY a, b;
  a  | b  
 ----+----
+    |   
   6 | 10
  21 | 20
- 30 | 40
  31 | 10
  50 | 35
- 50 | 60
  81 | 15
-    |   
-(8 rows)
+(6 rows)
 
 SELECT pg_get_triggerdef(oid, true) FROM pg_trigger WHERE tgrelid = 'main_table'::regclass AND tgname = 'modified_a';
-                                                             pg_get_triggerdef                                                             
--------------------------------------------------------------------------------------------------------------------------------------------
- CREATE TRIGGER modified_a BEFORE UPDATE OF a ON main_table FOR EACH ROW WHEN (old.a <> new.a) EXECUTE FUNCTION trigger_func('modified_a')
-(1 row)
-
+ERROR:  unknown function: pg_get_triggerdef()
 SELECT pg_get_triggerdef(oid, false) FROM pg_trigger WHERE tgrelid = 'main_table'::regclass AND tgname = 'modified_a';
-                                                                 pg_get_triggerdef                                                                  
-----------------------------------------------------------------------------------------------------------------------------------------------------
- CREATE TRIGGER modified_a BEFORE UPDATE OF a ON public.main_table FOR EACH ROW WHEN ((old.a <> new.a)) EXECUTE FUNCTION trigger_func('modified_a')
-(1 row)
-
+ERROR:  unknown function: pg_get_triggerdef()
 SELECT pg_get_triggerdef(oid, true) FROM pg_trigger WHERE tgrelid = 'main_table'::regclass AND tgname = 'modified_any';
-                                                                      pg_get_triggerdef                                                                      
--------------------------------------------------------------------------------------------------------------------------------------------------------------
- CREATE TRIGGER modified_any BEFORE UPDATE OF a ON main_table FOR EACH ROW WHEN (old.* IS DISTINCT FROM new.*) EXECUTE FUNCTION trigger_func('modified_any')
-(1 row)
-
+ERROR:  unknown function: pg_get_triggerdef()
 -- Test RENAME TRIGGER
 ALTER TRIGGER modified_a ON main_table RENAME TO modified_modified_a;
+ERROR:  at or near "trigger": syntax error
+DETAIL:  source SQL:
+ALTER TRIGGER modified_a ON main_table RENAME TO modified_modified_a
+      ^
+HINT:  try \h ALTER
 SELECT count(*) FROM pg_trigger WHERE tgrelid = 'main_table'::regclass AND tgname = 'modified_a';
  count 
 -------
@@ -595,15 +574,21 @@
 SELECT count(*) FROM pg_trigger WHERE tgrelid = 'main_table'::regclass AND tgname = 'modified_modified_a';
  count 
 -------
-     1
+     0
 (1 row)
 
 DROP TRIGGER modified_modified_a ON main_table;
+ERROR:  trigger "modified_modified_a" for table "main_table" does not exist
 DROP TRIGGER modified_any ON main_table;
+ERROR:  trigger "modified_any" for table "main_table" does not exist
 DROP TRIGGER insert_a ON main_table;
+ERROR:  trigger "insert_a" for table "main_table" does not exist
 DROP TRIGGER delete_a ON main_table;
+ERROR:  trigger "delete_a" for table "main_table" does not exist
 DROP TRIGGER insert_when ON main_table;
+ERROR:  trigger "insert_when" for table "main_table" does not exist
 DROP TRIGGER delete_when ON main_table;
+ERROR:  trigger "delete_when" for table "main_table" does not exist
 -- Test WHEN condition accessing system columns.
 create table table_with_oids(a int);
 insert into table_with_oids values (1);
@@ -611,57 +596,46 @@
 	for each row
 	when (new.tableoid = old.tableoid AND new.tableoid <> 0)
 	execute procedure trigger_func('after_upd_oid_unchanged');
+ERROR:  no data source matches prefix: new in this context
+HINT:  to access a field of a composite-typed column or variable, surround the column/variable name in parentheses: (varName).fieldName
+--
+See: https://go.crdb.dev/issue-v/114687/_version_
 update table_with_oids set a = a + 1;
-NOTICE:  trigger_func(after_upd_oid_unchanged) called: action = UPDATE, when = AFTER, level = ROW
 drop table table_with_oids;
 -- Test column-level triggers
 DROP TRIGGER after_upd_row_trig ON main_table;
+ERROR:  trigger "after_upd_row_trig" for table "main_table" does not exist
 CREATE TRIGGER before_upd_a_row_trig BEFORE UPDATE OF a ON main_table
 FOR EACH ROW EXECUTE PROCEDURE trigger_func('before_upd_a_row');
+ERROR:  unimplemented: column lists are not yet supported for triggers
+HINT:  You have attempted to use a feature that is not yet implemented.
+See: https://go.crdb.dev/issue-v/135656/_version_
 CREATE TRIGGER after_upd_b_row_trig AFTER UPDATE OF b ON main_table
 FOR EACH ROW EXECUTE PROCEDURE trigger_func('after_upd_b_row');
+ERROR:  unimplemented: column lists are not yet supported for triggers
+HINT:  You have attempted to use a feature that is not yet implemented.
+See: https://go.crdb.dev/issue-v/135656/_version_
 CREATE TRIGGER after_upd_a_b_row_trig AFTER UPDATE OF a, b ON main_table
 FOR EACH ROW EXECUTE PROCEDURE trigger_func('after_upd_a_b_row');
+ERROR:  unimplemented: column lists are not yet supported for triggers
+HINT:  You have attempted to use a feature that is not yet implemented.
+See: https://go.crdb.dev/issue-v/135656/_version_
 CREATE TRIGGER before_upd_a_stmt_trig BEFORE UPDATE OF a ON main_table
 FOR EACH STATEMENT EXECUTE PROCEDURE trigger_func('before_upd_a_stmt');
+ERROR:  unimplemented: statement-level triggers are not yet supported
+HINT:  You have attempted to use a feature that is not yet implemented.
+See: https://go.crdb.dev/issue-v/126362/_version_
 CREATE TRIGGER after_upd_b_stmt_trig AFTER UPDATE OF b ON main_table
 FOR EACH STATEMENT EXECUTE PROCEDURE trigger_func('after_upd_b_stmt');
+ERROR:  unimplemented: statement-level triggers are not yet supported
+HINT:  You have attempted to use a feature that is not yet implemented.
+See: https://go.crdb.dev/issue-v/126362/_version_
 SELECT pg_get_triggerdef(oid) FROM pg_trigger WHERE tgrelid = 'main_table'::regclass AND tgname = 'after_upd_a_b_row_trig';
-                                                                pg_get_triggerdef                                                                
--------------------------------------------------------------------------------------------------------------------------------------------------
- CREATE TRIGGER after_upd_a_b_row_trig AFTER UPDATE OF a, b ON public.main_table FOR EACH ROW EXECUTE FUNCTION trigger_func('after_upd_a_b_row')
-(1 row)
-
+ERROR:  unknown function: pg_get_triggerdef()
 UPDATE main_table SET a = 50;
-NOTICE:  trigger_func(before_upd_a_stmt) called: action = UPDATE, when = BEFORE, level = STATEMENT
-NOTICE:  trigger_func(before_upd_a_row) called: action = UPDATE, when = BEFORE, level = ROW
-NOTICE:  trigger_func(before_upd_a_row) called: action = UPDATE, when = BEFORE, level = ROW
-NOTICE:  trigger_func(before_upd_a_row) called: action = UPDATE, when = BEFORE, level = ROW
-NOTICE:  trigger_func(before_upd_a_row) called: action = UPDATE, when = BEFORE, level = ROW
-NOTICE:  trigger_func(before_upd_a_row) called: action = UPDATE, when = BEFORE, level = ROW
-NOTICE:  trigger_func(before_upd_a_row) called: action = UPDATE, when = BEFORE, level = ROW
-NOTICE:  trigger_func(before_upd_a_row) called: action = UPDATE, when = BEFORE, level = ROW
-NOTICE:  trigger_func(before_upd_a_row) called: action = UPDATE, when = BEFORE, level = ROW
-NOTICE:  trigger_func(after_upd_stmt) called: action = UPDATE, when = AFTER, level = STATEMENT
+ERROR:  duplicate key value violates unique constraint "main_table_a_key"
+DETAIL:  Key (a)=(50) already exists.
 UPDATE main_table SET b = 10;
-NOTICE:  trigger_func(after_upd_a_b_row) called: action = UPDATE, when = AFTER, level = ROW
-NOTICE:  trigger_func(after_upd_b_row) called: action = UPDATE, when = AFTER, level = ROW
-NOTICE:  trigger_func(after_upd_a_b_row) called: action = UPDATE, when = AFTER, level = ROW
-NOTICE:  trigger_func(after_upd_b_row) called: action = UPDATE, when = AFTER, level = ROW
-NOTICE:  trigger_func(after_upd_a_b_row) called: action = UPDATE, when = AFTER, level = ROW
-NOTICE:  trigger_func(after_upd_b_row) called: action = UPDATE, when = AFTER, level = ROW
-NOTICE:  trigger_func(after_upd_a_b_row) called: action = UPDATE, when = AFTER, level = ROW
-NOTICE:  trigger_func(after_upd_b_row) called: action = UPDATE, when = AFTER, level = ROW
-NOTICE:  trigger_func(after_upd_a_b_row) called: action = UPDATE, when = AFTER, level = ROW
-NOTICE:  trigger_func(after_upd_b_row) called: action = UPDATE, when = AFTER, level = ROW
-NOTICE:  trigger_func(after_upd_a_b_row) called: action = UPDATE, when = AFTER, level = ROW
-NOTICE:  trigger_func(after_upd_b_row) called: action = UPDATE, when = AFTER, level = ROW
-NOTICE:  trigger_func(after_upd_a_b_row) called: action = UPDATE, when = AFTER, level = ROW
-NOTICE:  trigger_func(after_upd_b_row) called: action = UPDATE, when = AFTER, level = ROW
-NOTICE:  trigger_func(after_upd_a_b_row) called: action = UPDATE, when = AFTER, level = ROW
-NOTICE:  trigger_func(after_upd_b_row) called: action = UPDATE, when = AFTER, level = ROW
-NOTICE:  trigger_func(after_upd_b_stmt) called: action = UPDATE, when = AFTER, level = STATEMENT
-NOTICE:  trigger_func(after_upd_stmt) called: action = UPDATE, when = AFTER, level = STATEMENT
 --
 -- Test case for bug with BEFORE trigger followed by AFTER trigger with WHEN
 --
@@ -675,76 +649,93 @@
 $$ LANGUAGE plpgsql;
 CREATE TRIGGER some_trig_before BEFORE UPDATE ON some_t FOR EACH ROW
   EXECUTE PROCEDURE dummy_update_func('before');
+ERROR:  unimplemented: referencing the TG_ARGV trigger function parameter is not yet supported
+HINT:  You have attempted to use a feature that is not yet implemented.
+See: https://go.crdb.dev/issue-v/135311/_version_
 CREATE TRIGGER some_trig_aftera AFTER UPDATE ON some_t FOR EACH ROW
   WHEN (NOT OLD.some_col AND NEW.some_col)
   EXECUTE PROCEDURE dummy_update_func('aftera');
+ERROR:  no data source matches prefix: old in this context
+HINT:  to access a field of a composite-typed column or variable, surround the column/variable name in parentheses: (varName).fieldName
+--
+See: https://go.crdb.dev/issue-v/114687/_version_
 CREATE TRIGGER some_trig_afterb AFTER UPDATE ON some_t FOR EACH ROW
   WHEN (NOT NEW.some_col)
   EXECUTE PROCEDURE dummy_update_func('afterb');
+ERROR:  no data source matches prefix: new in this context
+HINT:  to access a field of a composite-typed column or variable, surround the column/variable name in parentheses: (varName).fieldName
+--
+See: https://go.crdb.dev/issue-v/114687/_version_
 INSERT INTO some_t VALUES (TRUE);
 UPDATE some_t SET some_col = TRUE;
-NOTICE:  dummy_update_func(before) called: action = UPDATE, old = (t), new = (t)
 UPDATE some_t SET some_col = FALSE;
-NOTICE:  dummy_update_func(before) called: action = UPDATE, old = (t), new = (f)
-NOTICE:  dummy_update_func(afterb) called: action = UPDATE, old = (t), new = (f)
 UPDATE some_t SET some_col = TRUE;
-NOTICE:  dummy_update_func(before) called: action = UPDATE, old = (f), new = (t)
-NOTICE:  dummy_update_func(aftera) called: action = UPDATE, old = (f), new = (t)
 DROP TABLE some_t;
 -- bogus cases
 CREATE TRIGGER error_upd_and_col BEFORE UPDATE OR UPDATE OF a ON main_table
 FOR EACH ROW EXECUTE PROCEDURE trigger_func('error_upd_and_col');
-ERROR:  duplicate trigger events specified at or near "ON"
-LINE 1: ...ER error_upd_and_col BEFORE UPDATE OR UPDATE OF a ON main_ta...
-                                                             ^
+ERROR:  at or near "on": syntax error: duplicate trigger events specified
+DETAIL:  source SQL:
+CREATE TRIGGER error_upd_and_col BEFORE UPDATE OR UPDATE OF a ON main_table
+                                                              ^
 CREATE TRIGGER error_upd_a_a BEFORE UPDATE OF a, a ON main_table
 FOR EACH ROW EXECUTE PROCEDURE trigger_func('error_upd_a_a');
-ERROR:  column "a" specified more than once
+ERROR:  unimplemented: column lists are not yet supported for triggers
+HINT:  You have attempted to use a feature that is not yet implemented.
+See: https://go.crdb.dev/issue-v/135656/_version_
 CREATE TRIGGER error_ins_a BEFORE INSERT OF a ON main_table
 FOR EACH ROW EXECUTE PROCEDURE trigger_func('error_ins_a');
-ERROR:  syntax error at or near "OF"
-LINE 1: CREATE TRIGGER error_ins_a BEFORE INSERT OF a ON main_table
-                                                 ^
+ERROR:  at or near "of": syntax error
+DETAIL:  source SQL:
+CREATE TRIGGER error_ins_a BEFORE INSERT OF a ON main_table
+                                         ^
+HINT:  try \h CREATE TRIGGER
 CREATE TRIGGER error_ins_when BEFORE INSERT OR UPDATE ON main_table
 FOR EACH ROW WHEN (OLD.a <> NEW.a)
 EXECUTE PROCEDURE trigger_func('error_ins_old');
-ERROR:  INSERT trigger's WHEN condition cannot reference OLD values
-LINE 2: FOR EACH ROW WHEN (OLD.a <> NEW.a)
-                           ^
+ERROR:  no data source matches prefix: old in this context
+HINT:  to access a field of a composite-typed column or variable, surround the column/variable name in parentheses: (varName).fieldName
+--
+See: https://go.crdb.dev/issue-v/114687/_version_
 CREATE TRIGGER error_del_when BEFORE DELETE OR UPDATE ON main_table
 FOR EACH ROW WHEN (OLD.a <> NEW.a)
 EXECUTE PROCEDURE trigger_func('error_del_new');
-ERROR:  DELETE trigger's WHEN condition cannot reference NEW values
-LINE 2: FOR EACH ROW WHEN (OLD.a <> NEW.a)
-                                    ^
+ERROR:  no data source matches prefix: old in this context
+HINT:  to access a field of a composite-typed column or variable, surround the column/variable name in parentheses: (varName).fieldName
+--
+See: https://go.crdb.dev/issue-v/114687/_version_
 CREATE TRIGGER error_del_when BEFORE INSERT OR UPDATE ON main_table
 FOR EACH ROW WHEN (NEW.tableoid <> 0)
 EXECUTE PROCEDURE trigger_func('error_when_sys_column');
-ERROR:  BEFORE trigger's WHEN condition cannot reference NEW system columns
-LINE 2: FOR EACH ROW WHEN (NEW.tableoid <> 0)
-                           ^
+ERROR:  no data source matches prefix: new in this context
+HINT:  to access a field of a composite-typed column or variable, surround the column/variable name in parentheses: (varName).fieldName
+--
+See: https://go.crdb.dev/issue-v/114687/_version_
 CREATE TRIGGER error_stmt_when BEFORE UPDATE OF a ON main_table
 FOR EACH STATEMENT WHEN (OLD.* IS DISTINCT FROM NEW.*)
 EXECUTE PROCEDURE trigger_func('error_stmt_when');
-ERROR:  statement trigger's WHEN condition cannot reference column values
-LINE 2: FOR EACH STATEMENT WHEN (OLD.* IS DISTINCT FROM NEW.*)
-                                 ^
+ERROR:  unimplemented: statement-level triggers are not yet supported
+HINT:  You have attempted to use a feature that is not yet implemented.
+See: https://go.crdb.dev/issue-v/126362/_version_
 -- check dependency restrictions
 ALTER TABLE main_table DROP COLUMN b;
-ERROR:  cannot drop column b of table main_table because other objects depend on it
-DETAIL:  trigger after_upd_b_row_trig on table main_table depends on column b of table main_table
-trigger after_upd_a_b_row_trig on table main_table depends on column b of table main_table
-trigger after_upd_b_stmt_trig on table main_table depends on column b of table main_table
-HINT:  Use DROP ... CASCADE to drop the dependent objects too.
 -- this should succeed, but we'll roll it back to keep the triggers around
 begin;
 DROP TRIGGER after_upd_a_b_row_trig ON main_table;
+NOTICE:  auto-committing transaction before processing DDL due to autocommit_before_ddl setting
+ERROR:  trigger "after_upd_a_b_row_trig" for table "main_table" does not exist
 DROP TRIGGER after_upd_b_row_trig ON main_table;
+ERROR:  trigger "after_upd_b_row_trig" for table "main_table" does not exist
 DROP TRIGGER after_upd_b_stmt_trig ON main_table;
+ERROR:  trigger "after_upd_b_stmt_trig" for table "main_table" does not exist
 ALTER TABLE main_table DROP COLUMN b;
+ERROR:  column "b" does not exist
 rollback;
+WARNING:  there is no transaction in progress
 -- Test enable/disable triggers
-create table trigtest (i serial primary key);
+create sequence trigtestseq;
+create table trigtest (i int primary key default nextval('trigtestseq'));
+NOTICE:  using sequential values in a primary key does not perform as well as using random UUIDs. See https://www.cockroachlabs.com/docs/_version_/serial.html
 -- test that disabling RI triggers works
 create table trigtest2 (i int references trigtest(i) on delete cascade);
 create function trigtest() returns trigger as $$
@@ -758,58 +749,123 @@
 for each row execute procedure trigtest();
 create trigger trigtest_b_stmt_tg before insert or update or delete on trigtest
 for each statement execute procedure trigtest();
+ERROR:  unimplemented: statement-level triggers are not yet supported
+HINT:  You have attempted to use a feature that is not yet implemented.
+See: https://go.crdb.dev/issue-v/126362/_version_
 create trigger trigtest_a_stmt_tg after insert or update or delete on trigtest
 for each statement execute procedure trigtest();
+ERROR:  unimplemented: statement-level triggers are not yet supported
+HINT:  You have attempted to use a feature that is not yet implemented.
+See: https://go.crdb.dev/issue-v/126362/_version_
 insert into trigtest default values;
-NOTICE:  trigtest INSERT BEFORE STATEMENT
 NOTICE:  trigtest INSERT BEFORE ROW
 NOTICE:  trigtest INSERT AFTER ROW
-NOTICE:  trigtest INSERT AFTER STATEMENT
 alter table trigtest disable trigger trigtest_b_row_tg;
+ERROR:  at or near "trigger": syntax error
+DETAIL:  source SQL:
+alter table trigtest disable trigger trigtest_b_row_tg
+                             ^
+HINT:  try \h ALTER TABLE
 insert into trigtest default values;
-NOTICE:  trigtest INSERT BEFORE STATEMENT
+NOTICE:  trigtest INSERT BEFORE ROW
 NOTICE:  trigtest INSERT AFTER ROW
-NOTICE:  trigtest INSERT AFTER STATEMENT
 alter table trigtest disable trigger user;
+ERROR:  at or near "trigger": syntax error
+DETAIL:  source SQL:
+alter table trigtest disable trigger user
+                             ^
+HINT:  try \h ALTER TABLE
 insert into trigtest default values;
+NOTICE:  trigtest INSERT BEFORE ROW
+NOTICE:  trigtest INSERT AFTER ROW
 alter table trigtest enable trigger trigtest_a_stmt_tg;
+ERROR:  at or near "trigger": syntax error
+DETAIL:  source SQL:
+alter table trigtest enable trigger trigtest_a_stmt_tg
+                            ^
+HINT:  try \h ALTER TABLE
 insert into trigtest default values;
-NOTICE:  trigtest INSERT AFTER STATEMENT
+NOTICE:  trigtest INSERT BEFORE ROW
+NOTICE:  trigtest INSERT AFTER ROW
 set session_replication_role = replica;
+ERROR:  unimplemented: the configuration setting "session_replication_role" is not supported
+HINT:  You have attempted to use a feature that is not yet implemented.
+
+Please check the public issue tracker to check whether this problem is
+already tracked. If you cannot find it there, please report the error
+with details by creating a new issue.
+
+If you would rather not post publicly, please contact us directly
+using the support form.
+
+We appreciate your feedback.
+
 insert into trigtest default values;  -- does not trigger
+NOTICE:  trigtest INSERT BEFORE ROW
+NOTICE:  trigtest INSERT AFTER ROW
 alter table trigtest enable always trigger trigtest_a_stmt_tg;
+ERROR:  at or near "always": syntax error
+DETAIL:  source SQL:
+alter table trigtest enable always trigger trigtest_a_stmt_tg
+                            ^
+HINT:  try \h ALTER TABLE
 insert into trigtest default values;  -- now it does
-NOTICE:  trigtest INSERT AFTER STATEMENT
+NOTICE:  trigtest INSERT BEFORE ROW
+NOTICE:  trigtest INSERT AFTER ROW
 reset session_replication_role;
+ERROR:  unimplemented: the configuration setting "session_replication_role" is not supported
+HINT:  You have attempted to use a feature that is not yet implemented.
+
+Please check the public issue tracker to check whether this problem is
+already tracked. If you cannot find it there, please report the error
+with details by creating a new issue.
+
+If you would rather not post publicly, please contact us directly
+using the support form.
+
+We appreciate your feedback.
+
 insert into trigtest2 values(1);
 insert into trigtest2 values(2);
 delete from trigtest where i=2;
-NOTICE:  trigtest DELETE AFTER STATEMENT
+NOTICE:  trigtest DELETE BEFORE ROW
 select * from trigtest2;
  i 
 ---
  1
-(1 row)
+ 2
+(2 rows)
 
 alter table trigtest disable trigger all;
+ERROR:  at or near "trigger": syntax error
+DETAIL:  source SQL:
+alter table trigtest disable trigger all
+                             ^
+HINT:  try \h ALTER TABLE
 delete from trigtest where i=1;
+NOTICE:  trigtest DELETE BEFORE ROW
 select * from trigtest2;
  i 
 ---
  1
-(1 row)
+ 2
+(2 rows)
 
 -- ensure we still insert, even when all triggers are disabled
 insert into trigtest default values;
+NOTICE:  trigtest INSERT BEFORE ROW
+NOTICE:  trigtest INSERT AFTER ROW
 select *  from trigtest;
  i 
 ---
+ 1
+ 2
  3
  4
  5
  6
  7
-(5 rows)
+(7 rows)
 
 drop table trigtest2;
 drop table trigtest;
@@ -872,44 +928,14 @@
 CREATE TRIGGER show_trigger_data_trig
 BEFORE INSERT OR UPDATE OR DELETE ON trigger_test
 FOR EACH ROW EXECUTE PROCEDURE trigger_data(23,'skidoo');
+ERROR:  unimplemented: referencing the TG_ARGV trigger function parameter is not yet supported
+HINT:  You have attempted to use a feature that is not yet implemented.
+See: https://go.crdb.dev/issue-v/135311/_version_
 insert into trigger_test values(1,'insert');
-NOTICE:  TG_NAME: show_trigger_data_trig
-NOTICE:  TG_WHEN: BEFORE
-NOTICE:  TG_LEVEL: ROW
-NOTICE:  TG_OP: INSERT
-NOTICE:  TG_RELID::regclass: trigger_test
-NOTICE:  TG_RELNAME: trigger_test
-NOTICE:  TG_TABLE_NAME: trigger_test
-NOTICE:  TG_TABLE_SCHEMA: public
-NOTICE:  TG_NARGS: 2
-NOTICE:  TG_ARGV: [23, skidoo]
-NOTICE:  NEW: (1,insert)
 update trigger_test set v = 'update' where i = 1;
-NOTICE:  TG_NAME: show_trigger_data_trig
-NOTICE:  TG_WHEN: BEFORE
-NOTICE:  TG_LEVEL: ROW
-NOTICE:  TG_OP: UPDATE
-NOTICE:  TG_RELID::regclass: trigger_test
-NOTICE:  TG_RELNAME: trigger_test
-NOTICE:  TG_TABLE_NAME: trigger_test
-NOTICE:  TG_TABLE_SCHEMA: public
-NOTICE:  TG_NARGS: 2
-NOTICE:  TG_ARGV: [23, skidoo]
-NOTICE:  OLD: (1,insert)
-NOTICE:  NEW: (1,update)
 delete from trigger_test;
-NOTICE:  TG_NAME: show_trigger_data_trig
-NOTICE:  TG_WHEN: BEFORE
-NOTICE:  TG_LEVEL: ROW
-NOTICE:  TG_OP: DELETE
-NOTICE:  TG_RELID::regclass: trigger_test
-NOTICE:  TG_RELNAME: trigger_test
-NOTICE:  TG_TABLE_NAME: trigger_test
-NOTICE:  TG_TABLE_SCHEMA: public
-NOTICE:  TG_NARGS: 2
-NOTICE:  TG_ARGV: [23, skidoo]
-NOTICE:  OLD: (1,update)
 DROP TRIGGER show_trigger_data_trig on trigger_test;
+ERROR:  trigger "show_trigger_data_trig" for table "trigger_test" does not exist
 DROP FUNCTION trigger_data();
 DROP TABLE trigger_test;
 --
@@ -929,18 +955,16 @@
 CREATE TRIGGER t
 BEFORE UPDATE ON trigger_test
 FOR EACH ROW EXECUTE PROCEDURE mytrigger();
+ERROR:  no data source matches prefix: new in this context
+HINT:  to access a field of a composite-typed column or variable, surround the column/variable name in parentheses: (varName).fieldName
+--
+See: https://go.crdb.dev/issue-v/114687/_version_
 INSERT INTO trigger_test VALUES(1, 'foo', 'bar');
 INSERT INTO trigger_test VALUES(2, 'baz', 'quux');
 UPDATE trigger_test SET f3 = 'bar';
-NOTICE:  row 1 not changed
-NOTICE:  row 2 changed
 UPDATE trigger_test SET f3 = NULL;
-NOTICE:  row 1 changed
-NOTICE:  row 2 changed
 -- this demonstrates that the above isn't really working as desired:
 UPDATE trigger_test SET f3 = NULL;
-NOTICE:  row 1 changed
-NOTICE:  row 2 changed
 -- the right way when considering nulls is
 CREATE OR REPLACE FUNCTION mytrigger() RETURNS trigger LANGUAGE plpgsql as $$
 begin
@@ -952,14 +976,8 @@
 	return new;
 end$$;
 UPDATE trigger_test SET f3 = 'bar';
-NOTICE:  row 1 changed
-NOTICE:  row 2 changed
 UPDATE trigger_test SET f3 = NULL;
-NOTICE:  row 1 changed
-NOTICE:  row 2 changed
 UPDATE trigger_test SET f3 = NULL;
-NOTICE:  row 1 not changed
-NOTICE:  row 2 not changed
 DROP TABLE trigger_test;
 DROP FUNCTION mytrigger();
 -- Test snapshot management in serializable transactions involving triggers
@@ -973,6 +991,9 @@
 	return new;
 end;
 $$;
+ERROR:  unimplemented: RECORD type for PL/pgSQL variables is not yet supported
+HINT:  You have attempted to use a feature that is not yet implemented.
+See: https://go.crdb.dev/issue-v/114874/_version_
 CREATE TABLE serializable_update_tab (
 	id int,
 	filler  text,
@@ -980,6 +1001,7 @@
 );
 CREATE TRIGGER serializable_update_trig BEFORE UPDATE ON serializable_update_tab
 	FOR EACH ROW EXECUTE PROCEDURE serializable_update_trig();
+ERROR:  unknown function: serializable_update_trig()
 INSERT INTO serializable_update_tab SELECT a, repeat('xyzxz', 100), 'new'
 	FROM generate_series(1, 50) a;
 BEGIN;
@@ -987,9 +1009,9 @@
 UPDATE serializable_update_tab SET description = 'no no', id = 1 WHERE id = 1;
 COMMIT;
 SELECT description FROM serializable_update_tab WHERE id = 1;
-    description     
---------------------
- updated in trigger
+ description 
+-------------
+ no no
 (1 row)
 
 DROP TABLE serializable_update_tab;
@@ -1002,9 +1024,10 @@
 CREATE TRIGGER z_min_update
 BEFORE UPDATE ON min_updates_test
 FOR EACH ROW EXECUTE PROCEDURE suppress_redundant_updates_trigger();
+ERROR:  unknown function: suppress_redundant_updates_trigger()
 \set QUIET false
 UPDATE min_updates_test SET f1 = f1;
-UPDATE 0
+UPDATE 2
 UPDATE min_updates_test SET f2 = f2 + 1;
 UPDATE 2
 UPDATE min_updates_test SET f3 = 2 WHERE f3 is null;
@@ -1022,6 +1045,7 @@
 -- Test triggers on views
 --
 CREATE VIEW main_view AS SELECT a, b FROM main_table;
+ERROR:  column "b" does not exist
 -- VIEW trigger function
 CREATE OR REPLACE FUNCTION view_trigger() RETURNS trigger
 LANGUAGE plpgsql AS $$
@@ -1065,38 +1089,30 @@
 -- Before row triggers aren't allowed on views
 CREATE TRIGGER invalid_trig BEFORE INSERT ON main_view
 FOR EACH ROW EXECUTE PROCEDURE trigger_func('before_ins_row');
-ERROR:  "main_view" is a view
-DETAIL:  Views cannot have row-level BEFORE or AFTER triggers.
+ERROR:  relation "main_view" does not exist
 CREATE TRIGGER invalid_trig BEFORE UPDATE ON main_view
 FOR EACH ROW EXECUTE PROCEDURE trigger_func('before_upd_row');
-ERROR:  "main_view" is a view
-DETAIL:  Views cannot have row-level BEFORE or AFTER triggers.
+ERROR:  relation "main_view" does not exist
 CREATE TRIGGER invalid_trig BEFORE DELETE ON main_view
 FOR EACH ROW EXECUTE PROCEDURE trigger_func('before_del_row');
-ERROR:  "main_view" is a view
-DETAIL:  Views cannot have row-level BEFORE or AFTER triggers.
+ERROR:  relation "main_view" does not exist
 -- After row triggers aren't allowed on views
 CREATE TRIGGER invalid_trig AFTER INSERT ON main_view
 FOR EACH ROW EXECUTE PROCEDURE trigger_func('before_ins_row');
-ERROR:  "main_view" is a view
-DETAIL:  Views cannot have row-level BEFORE or AFTER triggers.
+ERROR:  relation "main_view" does not exist
 CREATE TRIGGER invalid_trig AFTER UPDATE ON main_view
 FOR EACH ROW EXECUTE PROCEDURE trigger_func('before_upd_row');
-ERROR:  "main_view" is a view
-DETAIL:  Views cannot have row-level BEFORE or AFTER triggers.
+ERROR:  relation "main_view" does not exist
 CREATE TRIGGER invalid_trig AFTER DELETE ON main_view
 FOR EACH ROW EXECUTE PROCEDURE trigger_func('before_del_row');
-ERROR:  "main_view" is a view
-DETAIL:  Views cannot have row-level BEFORE or AFTER triggers.
+ERROR:  relation "main_view" does not exist
 -- Truncate triggers aren't allowed on views
 CREATE TRIGGER invalid_trig BEFORE TRUNCATE ON main_view
 EXECUTE PROCEDURE trigger_func('before_tru_row');
-ERROR:  "main_view" is a view
-DETAIL:  Views cannot have TRUNCATE triggers.
+ERROR:  relation "main_view" does not exist
 CREATE TRIGGER invalid_trig AFTER TRUNCATE ON main_view
 EXECUTE PROCEDURE trigger_func('before_tru_row');
-ERROR:  "main_view" is a view
-DETAIL:  Views cannot have TRUNCATE triggers.
+ERROR:  relation "main_view" does not exist
 -- INSTEAD OF triggers aren't allowed on tables
 CREATE TRIGGER invalid_trig INSTEAD OF INSERT ON main_table
 FOR EACH ROW EXECUTE PROCEDURE view_trigger('instead_of_ins');
@@ -1113,191 +1129,110 @@
 -- Don't support WHEN clauses with INSTEAD OF triggers
 CREATE TRIGGER invalid_trig INSTEAD OF UPDATE ON main_view
 FOR EACH ROW WHEN (OLD.a <> NEW.a) EXECUTE PROCEDURE view_trigger('instead_of_upd');
-ERROR:  INSTEAD OF triggers cannot have WHEN conditions
+ERROR:  relation "main_view" does not exist
 -- Don't support column-level INSTEAD OF triggers
 CREATE TRIGGER invalid_trig INSTEAD OF UPDATE OF a ON main_view
 FOR EACH ROW EXECUTE PROCEDURE view_trigger('instead_of_upd');
-ERROR:  INSTEAD OF triggers cannot have column lists
+ERROR:  relation "main_view" does not exist
 -- Don't support statement-level INSTEAD OF triggers
 CREATE TRIGGER invalid_trig INSTEAD OF UPDATE ON main_view
 EXECUTE PROCEDURE view_trigger('instead_of_upd');
-ERROR:  INSTEAD OF triggers must be FOR EACH ROW
+ERROR:  relation "main_view" does not exist
 -- Valid INSTEAD OF triggers
 CREATE TRIGGER instead_of_insert_trig INSTEAD OF INSERT ON main_view
 FOR EACH ROW EXECUTE PROCEDURE view_trigger('instead_of_ins');
+ERROR:  relation "main_view" does not exist
 CREATE TRIGGER instead_of_update_trig INSTEAD OF UPDATE ON main_view
 FOR EACH ROW EXECUTE PROCEDURE view_trigger('instead_of_upd');
+ERROR:  relation "main_view" does not exist
 CREATE TRIGGER instead_of_delete_trig INSTEAD OF DELETE ON main_view
 FOR EACH ROW EXECUTE PROCEDURE view_trigger('instead_of_del');
+ERROR:  relation "main_view" does not exist
 -- Valid BEFORE statement VIEW triggers
 CREATE TRIGGER before_ins_stmt_trig BEFORE INSERT ON main_view
 FOR EACH STATEMENT EXECUTE PROCEDURE view_trigger('before_view_ins_stmt');
+ERROR:  relation "main_view" does not exist
 CREATE TRIGGER before_upd_stmt_trig BEFORE UPDATE ON main_view
 FOR EACH STATEMENT EXECUTE PROCEDURE view_trigger('before_view_upd_stmt');
+ERROR:  relation "main_view" does not exist
 CREATE TRIGGER before_del_stmt_trig BEFORE DELETE ON main_view
 FOR EACH STATEMENT EXECUTE PROCEDURE view_trigger('before_view_del_stmt');
+ERROR:  relation "main_view" does not exist
 -- Valid AFTER statement VIEW triggers
 CREATE TRIGGER after_ins_stmt_trig AFTER INSERT ON main_view
 FOR EACH STATEMENT EXECUTE PROCEDURE view_trigger('after_view_ins_stmt');
+ERROR:  relation "main_view" does not exist
 CREATE TRIGGER after_upd_stmt_trig AFTER UPDATE ON main_view
 FOR EACH STATEMENT EXECUTE PROCEDURE view_trigger('after_view_upd_stmt');
+ERROR:  relation "main_view" does not exist
 CREATE TRIGGER after_del_stmt_trig AFTER DELETE ON main_view
 FOR EACH STATEMENT EXECUTE PROCEDURE view_trigger('after_view_del_stmt');
+ERROR:  relation "main_view" does not exist
 \set QUIET false
 -- Insert into view using trigger
 INSERT INTO main_view VALUES (20, 30);
-NOTICE:  main_view BEFORE INSERT STATEMENT (before_view_ins_stmt)
-NOTICE:  main_view INSTEAD OF INSERT ROW (instead_of_ins)
-NOTICE:  NEW: (20,30)
-NOTICE:  trigger_func(before_ins_stmt) called: action = INSERT, when = BEFORE, level = STATEMENT
-NOTICE:  trigger_func(after_ins_stmt) called: action = INSERT, when = AFTER, level = STATEMENT
-NOTICE:  main_view AFTER INSERT STATEMENT (after_view_ins_stmt)
-INSERT 0 1
+ERROR:  relation "main_view" does not exist
 INSERT INTO main_view VALUES (21, 31) RETURNING a, b;
-NOTICE:  main_view BEFORE INSERT STATEMENT (before_view_ins_stmt)
-NOTICE:  main_view INSTEAD OF INSERT ROW (instead_of_ins)
-NOTICE:  NEW: (21,31)
-NOTICE:  trigger_func(before_ins_stmt) called: action = INSERT, when = BEFORE, level = STATEMENT
-NOTICE:  trigger_func(after_ins_stmt) called: action = INSERT, when = AFTER, level = STATEMENT
-NOTICE:  main_view AFTER INSERT STATEMENT (after_view_ins_stmt)
- a  | b  
-----+----
- 21 | 31
-(1 row)
-
-INSERT 0 1
+ERROR:  relation "main_view" does not exist
 -- Table trigger will prevent updates
 UPDATE main_view SET b = 31 WHERE a = 20;
-NOTICE:  main_view BEFORE UPDATE STATEMENT (before_view_upd_stmt)
-NOTICE:  main_view INSTEAD OF UPDATE ROW (instead_of_upd)
-NOTICE:  OLD: (20,30), NEW: (20,31)
-NOTICE:  trigger_func(before_upd_a_stmt) called: action = UPDATE, when = BEFORE, level = STATEMENT
-NOTICE:  trigger_func(before_upd_a_row) called: action = UPDATE, when = BEFORE, level = ROW
-NOTICE:  trigger_func(after_upd_b_stmt) called: action = UPDATE, when = AFTER, level = STATEMENT
-NOTICE:  trigger_func(after_upd_stmt) called: action = UPDATE, when = AFTER, level = STATEMENT
-NOTICE:  main_view AFTER UPDATE STATEMENT (after_view_upd_stmt)
-UPDATE 0
+ERROR:  relation "main_view" does not exist
 UPDATE main_view SET b = 32 WHERE a = 21 AND b = 31 RETURNING a, b;
-NOTICE:  main_view BEFORE UPDATE STATEMENT (before_view_upd_stmt)
-NOTICE:  main_view INSTEAD OF UPDATE ROW (instead_of_upd)
-NOTICE:  OLD: (21,31), NEW: (21,32)
-NOTICE:  trigger_func(before_upd_a_stmt) called: action = UPDATE, when = BEFORE, level = STATEMENT
-NOTICE:  trigger_func(before_upd_a_row) called: action = UPDATE, when = BEFORE, level = ROW
-NOTICE:  trigger_func(after_upd_b_stmt) called: action = UPDATE, when = AFTER, level = STATEMENT
-NOTICE:  trigger_func(after_upd_stmt) called: action = UPDATE, when = AFTER, level = STATEMENT
-NOTICE:  main_view AFTER UPDATE STATEMENT (after_view_upd_stmt)
- a | b 
----+---
-(0 rows)
-
-UPDATE 0
+ERROR:  relation "main_view" does not exist
 -- Remove table trigger to allow updates
 DROP TRIGGER before_upd_a_row_trig ON main_table;
-DROP TRIGGER
+ERROR:  trigger "before_upd_a_row_trig" for table "main_table" does not exist
 UPDATE main_view SET b = 31 WHERE a = 20;
-NOTICE:  main_view BEFORE UPDATE STATEMENT (before_view_upd_stmt)
-NOTICE:  main_view INSTEAD OF UPDATE ROW (instead_of_upd)
-NOTICE:  OLD: (20,30), NEW: (20,31)
-NOTICE:  trigger_func(before_upd_a_stmt) called: action = UPDATE, when = BEFORE, level = STATEMENT
-NOTICE:  trigger_func(after_upd_a_b_row) called: action = UPDATE, when = AFTER, level = ROW
-NOTICE:  trigger_func(after_upd_b_row) called: action = UPDATE, when = AFTER, level = ROW
-NOTICE:  trigger_func(after_upd_b_stmt) called: action = UPDATE, when = AFTER, level = STATEMENT
-NOTICE:  trigger_func(after_upd_stmt) called: action = UPDATE, when = AFTER, level = STATEMENT
-NOTICE:  main_view AFTER UPDATE STATEMENT (after_view_upd_stmt)
-UPDATE 1
+ERROR:  relation "main_view" does not exist
 UPDATE main_view SET b = 32 WHERE a = 21 AND b = 31 RETURNING a, b;
-NOTICE:  main_view BEFORE UPDATE STATEMENT (before_view_upd_stmt)
-NOTICE:  main_view INSTEAD OF UPDATE ROW (instead_of_upd)
-NOTICE:  OLD: (21,31), NEW: (21,32)
-NOTICE:  trigger_func(before_upd_a_stmt) called: action = UPDATE, when = BEFORE, level = STATEMENT
-NOTICE:  trigger_func(after_upd_a_b_row) called: action = UPDATE, when = AFTER, level = ROW
-NOTICE:  trigger_func(after_upd_b_row) called: action = UPDATE, when = AFTER, level = ROW
-NOTICE:  trigger_func(after_upd_b_stmt) called: action = UPDATE, when = AFTER, level = STATEMENT
-NOTICE:  trigger_func(after_upd_stmt) called: action = UPDATE, when = AFTER, level = STATEMENT
-NOTICE:  main_view AFTER UPDATE STATEMENT (after_view_upd_stmt)
- a  | b  
-----+----
- 21 | 32
-(1 row)
-
-UPDATE 1
+ERROR:  relation "main_view" does not exist
 -- Before and after stmt triggers should fire even when no rows are affected
 UPDATE main_view SET b = 0 WHERE false;
-NOTICE:  main_view BEFORE UPDATE STATEMENT (before_view_upd_stmt)
-NOTICE:  main_view AFTER UPDATE STATEMENT (after_view_upd_stmt)
-UPDATE 0
+ERROR:  relation "main_view" does not exist
 -- Delete from view using trigger
 DELETE FROM main_view WHERE a IN (20,21);
-NOTICE:  main_view BEFORE DELETE STATEMENT (before_view_del_stmt)
-NOTICE:  main_view INSTEAD OF DELETE ROW (instead_of_del)
-NOTICE:  OLD: (21,10)
-NOTICE:  main_view INSTEAD OF DELETE ROW (instead_of_del)
-NOTICE:  OLD: (20,31)
-NOTICE:  main_view INSTEAD OF DELETE ROW (instead_of_del)
-NOTICE:  OLD: (21,32)
-NOTICE:  main_view AFTER DELETE STATEMENT (after_view_del_stmt)
-DELETE 3
+ERROR:  relation "main_view" does not exist
 DELETE FROM main_view WHERE a = 31 RETURNING a, b;
-NOTICE:  main_view BEFORE DELETE STATEMENT (before_view_del_stmt)
-NOTICE:  main_view INSTEAD OF DELETE ROW (instead_of_del)
-NOTICE:  OLD: (31,10)
-NOTICE:  main_view AFTER DELETE STATEMENT (after_view_del_stmt)
- a  | b  
-----+----
- 31 | 10
-(1 row)
-
-DELETE 1
+ERROR:  relation "main_view" does not exist
 \set QUIET true
 -- Describe view should list triggers
 \d main_view
-              View "public.main_view"
- Column |  Type   | Collation | Nullable | Default 
---------+---------+-----------+----------+---------
- a      | integer |           |          | 
- b      | integer |           |          | 
-Triggers:
-    after_del_stmt_trig AFTER DELETE ON main_view FOR EACH STATEMENT EXECUTE FUNCTION view_trigger('after_view_del_stmt')
-    after_ins_stmt_trig AFTER INSERT ON main_view FOR EACH STATEMENT EXECUTE FUNCTION view_trigger('after_view_ins_stmt')
-    after_upd_stmt_trig AFTER UPDATE ON main_view FOR EACH STATEMENT EXECUTE FUNCTION view_trigger('after_view_upd_stmt')
-    before_del_stmt_trig BEFORE DELETE ON main_view FOR EACH STATEMENT EXECUTE FUNCTION view_trigger('before_view_del_stmt')
-    before_ins_stmt_trig BEFORE INSERT ON main_view FOR EACH STATEMENT EXECUTE FUNCTION view_trigger('before_view_ins_stmt')
-    before_upd_stmt_trig BEFORE UPDATE ON main_view FOR EACH STATEMENT EXECUTE FUNCTION view_trigger('before_view_upd_stmt')
-    instead_of_delete_trig INSTEAD OF DELETE ON main_view FOR EACH ROW EXECUTE FUNCTION view_trigger('instead_of_del')
-    instead_of_insert_trig INSTEAD OF INSERT ON main_view FOR EACH ROW EXECUTE FUNCTION view_trigger('instead_of_ins')
-    instead_of_update_trig INSTEAD OF UPDATE ON main_view FOR EACH ROW EXECUTE FUNCTION view_trigger('instead_of_upd')
-
+ERROR:  at or near ".": syntax error
+DETAIL:  source SQL:
+SELECT c.oid,
+  n.nspname,
+  c.relname
+FROM pg_catalog.pg_class c
+     LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace
+WHERE c.relname OPERATOR(pg_catalog.~) '^(main_view)$' COLLATE pg_catalog.default
+                                                                         ^
 -- Test dropping view triggers
 DROP TRIGGER instead_of_insert_trig ON main_view;
+ERROR:  relation "main_view" does not exist
 DROP TRIGGER instead_of_delete_trig ON main_view;
+ERROR:  relation "main_view" does not exist
 \d+ main_view
-                          View "public.main_view"
- Column |  Type   | Collation | Nullable | Default | Storage | Description 
---------+---------+-----------+----------+---------+---------+-------------
- a      | integer |           |          |         | plain   | 
- b      | integer |           |          |         | plain   | 
-View definition:
- SELECT a,
-    b
-   FROM main_table;
-Triggers:
-    after_del_stmt_trig AFTER DELETE ON main_view FOR EACH STATEMENT EXECUTE FUNCTION view_trigger('after_view_del_stmt')
-    after_ins_stmt_trig AFTER INSERT ON main_view FOR EACH STATEMENT EXECUTE FUNCTION view_trigger('after_view_ins_stmt')
-    after_upd_stmt_trig AFTER UPDATE ON main_view FOR EACH STATEMENT EXECUTE FUNCTION view_trigger('after_view_upd_stmt')
-    before_del_stmt_trig BEFORE DELETE ON main_view FOR EACH STATEMENT EXECUTE FUNCTION view_trigger('before_view_del_stmt')
-    before_ins_stmt_trig BEFORE INSERT ON main_view FOR EACH STATEMENT EXECUTE FUNCTION view_trigger('before_view_ins_stmt')
-    before_upd_stmt_trig BEFORE UPDATE ON main_view FOR EACH STATEMENT EXECUTE FUNCTION view_trigger('before_view_upd_stmt')
-    instead_of_update_trig INSTEAD OF UPDATE ON main_view FOR EACH ROW EXECUTE FUNCTION view_trigger('instead_of_upd')
-
+ERROR:  at or near ".": syntax error
+DETAIL:  source SQL:
+SELECT c.oid,
+  n.nspname,
+  c.relname
+FROM pg_catalog.pg_class c
+     LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace
+WHERE c.relname OPERATOR(pg_catalog.~) '^(main_view)$' COLLATE pg_catalog.default
+                                                                         ^
 DROP VIEW main_view;
+ERROR:  relation "main_view" does not exist
 --
 -- Test triggers on a join view
 --
+CREATE SEQUENCE country_id_seq;
 CREATE TABLE country_table (
-    country_id        serial primary key,
+    country_id        int primary key default nextval('country_id_seq'),
     country_name    text unique not null,
     continent        text not null
 );
+NOTICE:  using sequential values in a primary key does not perform as well as using random UUIDs. See https://www.cockroachlabs.com/docs/_version_/serial.html
 INSERT INTO country_table (country_name, continent)
     VALUES ('Japan', 'Asia'),
            ('UK', 'Europe'),
@@ -1316,6 +1251,7 @@
     population    bigint,
     country_id    int references country_table
 );
+NOTICE:  using sequential values in a primary key does not perform as well as using random UUIDs. See https://www.cockroachlabs.com/docs/_version_/serial.html
 CREATE VIEW city_view AS
     SELECT city_id, city_name, population, country_name, continent
     FROM city_table ci
@@ -1346,8 +1282,10 @@
     RETURN NEW;
 end;
 $$;
+ERROR:  "NEW" is not a known variable
 CREATE TRIGGER city_insert_trig INSTEAD OF INSERT ON city_view
 FOR EACH ROW EXECUTE PROCEDURE city_insert();
+ERROR:  unknown function: city_insert()
 CREATE FUNCTION city_delete() RETURNS trigger LANGUAGE plpgsql AS $$
 begin
     DELETE FROM city_table WHERE city_id = OLD.city_id;
@@ -1357,6 +1295,9 @@
 $$;
 CREATE TRIGGER city_delete_trig INSTEAD OF DELETE ON city_view
 FOR EACH ROW EXECUTE PROCEDURE city_delete();
+ERROR:  unimplemented: INSTEAD OF triggers are not yet supported
+HINT:  You have attempted to use a feature that is not yet implemented.
+See: https://go.crdb.dev/issue-v/126363/_version_
 CREATE FUNCTION city_update() RETURNS trigger LANGUAGE plpgsql AS $$
 declare
     ctry_id int;
@@ -1383,102 +1324,43 @@
     RETURN NEW;
 end;
 $$;
+ERROR:  "NEW" is not a known variable
 CREATE TRIGGER city_update_trig INSTEAD OF UPDATE ON city_view
 FOR EACH ROW EXECUTE PROCEDURE city_update();
+ERROR:  unknown function: city_update()
 \set QUIET false
 -- INSERT .. RETURNING
 INSERT INTO city_view(city_name) VALUES('Tokyo') RETURNING *;
- city_id | city_name | population | country_name | continent 
----------+-----------+------------+--------------+-----------
-       1 | Tokyo     |            |              | 
-(1 row)
-
-INSERT 0 1
+ERROR:  "city_view" is not a table
 INSERT INTO city_view(city_name, population) VALUES('London', 7556900) RETURNING *;
- city_id | city_name | population | country_name | continent 
----------+-----------+------------+--------------+-----------
-       2 | London    |    7556900 |              | 
-(1 row)
-
-INSERT 0 1
+ERROR:  "city_view" is not a table
 INSERT INTO city_view(city_name, country_name) VALUES('Washington DC', 'USA') RETURNING *;
- city_id |   city_name   | population | country_name |   continent   
----------+---------------+------------+--------------+---------------
-       3 | Washington DC |            | USA          | North America
-(1 row)
-
-INSERT 0 1
+ERROR:  "city_view" is not a table
 INSERT INTO city_view(city_id, city_name) VALUES(123456, 'New York') RETURNING *;
- city_id | city_name | population | country_name | continent 
----------+-----------+------------+--------------+-----------
-  123456 | New York  |            |              | 
-(1 row)
-
-INSERT 0 1
+ERROR:  "city_view" is not a table
 INSERT INTO city_view VALUES(234567, 'Birmingham', 1016800, 'UK', 'EU') RETURNING *;
- city_id | city_name  | population | country_name | continent 
----------+------------+------------+--------------+-----------
-  234567 | Birmingham |    1016800 | UK           | Europe
-(1 row)
-
-INSERT 0 1
+ERROR:  "city_view" is not a table
 -- UPDATE .. RETURNING
 UPDATE city_view SET country_name = 'Japon' WHERE city_name = 'Tokyo'; -- error
-ERROR:  No such country: "Japon"
-CONTEXT:  PL/pgSQL function city_update() line 9 at RAISE
+ERROR:  "city_view" is not a table
 UPDATE city_view SET country_name = 'Japan' WHERE city_name = 'Takyo'; -- no match
-UPDATE 0
+ERROR:  "city_view" is not a table
 UPDATE city_view SET country_name = 'Japan' WHERE city_name = 'Tokyo' RETURNING *; -- OK
- city_id | city_name | population | country_name | continent 
----------+-----------+------------+--------------+-----------
-       1 | Tokyo     |            | Japan        | Asia
-(1 row)
-
-UPDATE 1
+ERROR:  "city_view" is not a table
 UPDATE city_view SET population = 13010279 WHERE city_name = 'Tokyo' RETURNING *;
- city_id | city_name | population | country_name | continent 
----------+-----------+------------+--------------+-----------
-       1 | Tokyo     |   13010279 | Japan        | Asia
-(1 row)
-
-UPDATE 1
+ERROR:  "city_view" is not a table
 UPDATE city_view SET country_name = 'UK' WHERE city_name = 'New York' RETURNING *;
- city_id | city_name | population | country_name | continent 
----------+-----------+------------+--------------+-----------
-  123456 | New York  |            | UK           | Europe
-(1 row)
-
-UPDATE 1
+ERROR:  "city_view" is not a table
 UPDATE city_view SET country_name = 'USA', population = 8391881 WHERE city_name = 'New York' RETURNING *;
- city_id | city_name | population | country_name |   continent   
----------+-----------+------------+--------------+---------------
-  123456 | New York  |    8391881 | USA          | North America
-(1 row)
-
-UPDATE 1
+ERROR:  "city_view" is not a table
 UPDATE city_view SET continent = 'EU' WHERE continent = 'Europe' RETURNING *;
- city_id | city_name  | population | country_name | continent 
----------+------------+------------+--------------+-----------
-  234567 | Birmingham |    1016800 | UK           | Europe
-(1 row)
-
-UPDATE 1
+ERROR:  "city_view" is not a table
 UPDATE city_view v1 SET country_name = v2.country_name FROM city_view v2
     WHERE v2.city_name = 'Birmingham' AND v1.city_name = 'London' RETURNING *;
- city_id | city_name | population | country_name | continent | city_id | city_name  | population | country_name | continent 
----------+-----------+------------+--------------+-----------+---------+------------+------------+--------------+-----------
-       2 | London    |    7556900 | UK           | Europe    |  234567 | Birmingham |    1016800 | UK           | Europe
-(1 row)
-
-UPDATE 1
+ERROR:  "city_view" is not a table
 -- DELETE .. RETURNING
 DELETE FROM city_view WHERE city_name = 'Birmingham' RETURNING *;
- city_id | city_name  | population | country_name | continent 
----------+------------+------------+--------------+-----------
-  234567 | Birmingham |    1016800 | UK           | Europe
-(1 row)
-
-DELETE 1
+ERROR:  "city_view" is not a table
 \set QUIET true
 -- read-only view with WHERE clause
 CREATE VIEW european_city_view AS
@@ -1486,26 +1368,44 @@
 SELECT count(*) FROM european_city_view;
  count 
 -------
-     1
+     0
 (1 row)
 
 CREATE FUNCTION no_op_trig_fn() RETURNS trigger LANGUAGE plpgsql
 AS 'begin RETURN NULL; end';
 CREATE TRIGGER no_op_trig INSTEAD OF INSERT OR UPDATE OR DELETE
 ON european_city_view FOR EACH ROW EXECUTE PROCEDURE no_op_trig_fn();
+ERROR:  unimplemented: INSTEAD OF triggers are not yet supported
+HINT:  You have attempted to use a feature that is not yet implemented.
+See: https://go.crdb.dev/issue-v/126363/_version_
 \set QUIET false
 INSERT INTO european_city_view VALUES (0, 'x', 10000, 'y', 'z');
-INSERT 0 0
+ERROR:  "european_city_view" is not a table
 UPDATE european_city_view SET population = 10000;
-UPDATE 0
+ERROR:  "european_city_view" is not a table
 DELETE FROM european_city_view;
-DELETE 0
+ERROR:  "european_city_view" is not a table
 \set QUIET true
 -- rules bypassing no-op triggers
 CREATE RULE european_city_insert_rule AS ON INSERT TO european_city_view
 DO INSTEAD INSERT INTO city_view
 VALUES (NEW.city_id, NEW.city_name, NEW.population, NEW.country_name, NEW.continent)
 RETURNING *;
+ERROR:  at or near "european_city_insert_rule": syntax error: unimplemented: this syntax
+DETAIL:  source SQL:
+CREATE RULE european_city_insert_rule AS ON INSERT TO european_city_view
+            ^
+HINT:  You have attempted to use a feature that is not yet implemented.
+
+Please check the public issue tracker to check whether this problem is
+already tracked. If you cannot find it there, please report the error
+with details by creating a new issue.
+
+If you would rather not post publicly, please contact us directly
+using the support form.
+
+We appreciate your feedback.
+
 CREATE RULE european_city_update_rule AS ON UPDATE TO european_city_view
 DO INSTEAD UPDATE city_view SET
     city_name = NEW.city_name,
@@ -1513,47 +1413,57 @@
     country_name = NEW.country_name
 WHERE city_id = OLD.city_id
 RETURNING NEW.*;
+ERROR:  at or near "european_city_update_rule": syntax error: unimplemented: this syntax
+DETAIL:  source SQL:
+CREATE RULE european_city_update_rule AS ON UPDATE TO european_city_view
+            ^
+HINT:  You have attempted to use a feature that is not yet implemented.
+
+Please check the public issue tracker to check whether this problem is
+already tracked. If you cannot find it there, please report the error
+with details by creating a new issue.
+
+If you would rather not post publicly, please contact us directly
+using the support form.
+
+We appreciate your feedback.
+
 CREATE RULE european_city_delete_rule AS ON DELETE TO european_city_view
 DO INSTEAD DELETE FROM city_view WHERE city_id = OLD.city_id RETURNING *;
+ERROR:  at or near "european_city_delete_rule": syntax error: unimplemented: this syntax
+DETAIL:  source SQL:
+CREATE RULE european_city_delete_rule AS ON DELETE TO european_city_view
+            ^
+HINT:  You have attempted to use a feature that is not yet implemented.
+
+Please check the public issue tracker to check whether this problem is
+already tracked. If you cannot find it there, please report the error
+with details by creating a new issue.
+
+If you would rather not post publicly, please contact us directly
+using the support form.
+
+We appreciate your feedback.
+
 \set QUIET false
 -- INSERT not limited by view's WHERE clause, but UPDATE AND DELETE are
 INSERT INTO european_city_view(city_name, country_name)
     VALUES ('Cambridge', 'USA') RETURNING *;
- city_id | city_name | population | country_name |   continent   
----------+-----------+------------+--------------+---------------
-       4 | Cambridge |            | USA          | North America
-(1 row)
-
-INSERT 0 1
+ERROR:  "european_city_view" is not a table
 UPDATE european_city_view SET country_name = 'UK'
     WHERE city_name = 'Cambridge';
-UPDATE 0
+ERROR:  "european_city_view" is not a table
 DELETE FROM european_city_view WHERE city_name = 'Cambridge';
-DELETE 0
+ERROR:  "european_city_view" is not a table
 -- UPDATE and DELETE via rule and trigger
 UPDATE city_view SET country_name = 'UK'
     WHERE city_name = 'Cambridge' RETURNING *;
- city_id | city_name | population | country_name | continent 
----------+-----------+------------+--------------+-----------
-       4 | Cambridge |            | UK           | Europe
-(1 row)
-
-UPDATE 1
+ERROR:  "city_view" is not a table
 UPDATE european_city_view SET population = 122800
     WHERE city_name = 'Cambridge' RETURNING *;
- city_id | city_name | population | country_name | continent 
----------+-----------+------------+--------------+-----------
-       4 | Cambridge |     122800 | UK           | Europe
-(1 row)
-
-UPDATE 1
+ERROR:  "european_city_view" is not a table
 DELETE FROM european_city_view WHERE city_name = 'Cambridge' RETURNING *;
- city_id | city_name | population | country_name | continent 
----------+-----------+------------+--------------+-----------
-       4 | Cambridge |     122800 | UK           | Europe
-(1 row)
-
-DELETE 1
+ERROR:  "european_city_view" is not a table
 -- join UPDATE test
 UPDATE city_view v SET population = 599657
     FROM city_table ci, country_table co
@@ -1561,26 +1471,14 @@
     AND v.city_id = ci.city_id AND v.country_name = co.country_name
     RETURNING co.country_id, v.country_name,
               v.city_id, v.city_name, v.population;
- country_id | country_name | city_id |   city_name   | population 
-------------+--------------+---------+---------------+------------
-          3 | USA          |       3 | Washington DC |     599657
-(1 row)
-
-UPDATE 1
+ERROR:  "city_view" is not a table
 \set QUIET true
 SELECT * FROM city_view;
- city_id |   city_name   | population | country_name |   continent   
----------+---------------+------------+--------------+---------------
-       1 | Tokyo         |   13010279 | Japan        | Asia
-  123456 | New York      |    8391881 | USA          | North America
-       2 | London        |    7556900 | UK           | Europe
-       3 | Washington DC |     599657 | USA          | North America
-(4 rows)
+ city_id | city_name | population | country_name | continent 
+---------+-----------+------------+--------------+-----------
+(0 rows)
 
 DROP TABLE city_table CASCADE;
-NOTICE:  drop cascades to 2 other objects
-DETAIL:  drop cascades to view city_view
-drop cascades to view european_city_view
 DROP TABLE country_table;
 -- Test pg_trigger_depth()
 create table depth_a (id int not null primary key);
@@ -1597,6 +1495,7 @@
 $$;
 create trigger depth_a_tr before insert on depth_a
   for each row execute procedure depth_a_tf();
+ERROR:  unknown function: pg_trigger_depth()
 create function depth_b_tf() returns trigger
   language plpgsql as $$
 begin
@@ -1614,8 +1513,22 @@
   return new;
 end;
 $$;
+ERROR:  unimplemented: attempted to use a PL/pgSQL statement that is not yet supported
+DETAIL:  stmt_dyn_exec is not yet supported
+HINT:  You have attempted to use a feature that is not yet implemented.
+
+Please check the public issue tracker to check whether this problem is
+already tracked. If you cannot find it there, please report the error
+with details by creating a new issue.
+
+If you would rather not post publicly, please contact us directly
+using the support form.
+
+We appreciate your feedback.
+
 create trigger depth_b_tr before insert on depth_b
   for each row execute procedure depth_b_tf();
+ERROR:  unknown function: depth_b_tf()
 create function depth_c_tf() returns trigger
   language plpgsql as $$
 begin
@@ -1629,47 +1542,19 @@
 $$;
 create trigger depth_c_tr before insert on depth_c
   for each row execute procedure depth_c_tf();
+ERROR:  unknown function: pg_trigger_depth()
 select pg_trigger_depth();
- pg_trigger_depth 
-------------------
-                0
-(1 row)
-
+ERROR:  unknown function: pg_trigger_depth()
 insert into depth_a values (1);
-NOTICE:  depth_a_tr: depth = 1
-NOTICE:  depth_b_tr: depth = 2
-NOTICE:  depth_c_tr: depth = 3
-NOTICE:  SQLSTATE = U9999: depth = 2
-NOTICE:  depth_b_tr: depth = 2
-NOTICE:  depth_c_tr: depth = 3
-ERROR:  U9999
-CONTEXT:  PL/pgSQL function depth_c_tf() line 5 at RAISE
-SQL statement "insert into depth_c values (1)"
-PL/pgSQL function depth_b_tf() line 12 at EXECUTE
-SQL statement "insert into depth_b values (new.id)"
-PL/pgSQL function depth_a_tf() line 4 at SQL statement
 select pg_trigger_depth();
- pg_trigger_depth 
-------------------
-                0
-(1 row)
-
+ERROR:  unknown function: pg_trigger_depth()
 insert into depth_a values (2);
-NOTICE:  depth_a_tr: depth = 1
-NOTICE:  depth_b_tr: depth = 2
-NOTICE:  depth_c_tr: depth = 3
-NOTICE:  depth_c_tr: depth = 3
-NOTICE:  depth_b_tr: depth = 2
-NOTICE:  depth_a_tr: depth = 1
 select pg_trigger_depth();
- pg_trigger_depth 
-------------------
-                0
-(1 row)
-
+ERROR:  unknown function: pg_trigger_depth()
 drop table depth_a, depth_b, depth_c;
 drop function depth_a_tf();
 drop function depth_b_tf();
+ERROR:  unknown function: depth_b_tf()
 drop function depth_c_tf();
 --
 -- Test updates to rows during firing of BEFORE ROW triggers.
@@ -1699,6 +1584,10 @@
 $$;
 create trigger parent_upd_trig before update on parent
   for each row execute procedure parent_upd_func();
+ERROR:  no data source matches prefix: new in this context
+HINT:  to access a field of a composite-typed column or variable, surround the column/variable name in parentheses: (varName).fieldName
+--
+See: https://go.crdb.dev/issue-v/114687/_version_
 create function parent_del_func()
   returns trigger language plpgsql as
 $$
@@ -1709,6 +1598,10 @@
 $$;
 create trigger parent_del_trig before delete on parent
   for each row execute procedure parent_del_func();
+ERROR:  no data source matches prefix: old in this context
+HINT:  to access a field of a composite-typed column or variable, surround the column/variable name in parentheses: (varName).fieldName
+--
+See: https://go.crdb.dev/issue-v/114687/_version_
 create function child_ins_func()
   returns trigger language plpgsql as
 $$
@@ -1719,6 +1612,10 @@
 $$;
 create trigger child_ins_trig after insert on child
   for each row execute procedure child_ins_func();
+ERROR:  no data source matches prefix: new in this context
+HINT:  to access a field of a composite-typed column or variable, surround the column/variable name in parentheses: (varName).fieldName
+--
+See: https://go.crdb.dev/issue-v/114687/_version_
 create function child_del_func()
   returns trigger language plpgsql as
 $$
@@ -1729,12 +1626,16 @@
 $$;
 create trigger child_del_trig after delete on child
   for each row execute procedure child_del_func();
+ERROR:  no data source matches prefix: old in this context
+HINT:  to access a field of a composite-typed column or variable, surround the column/variable name in parentheses: (varName).fieldName
+--
+See: https://go.crdb.dev/issue-v/114687/_version_
 insert into parent values (1, 'a', 'a', 'a', 'a', 0);
 insert into child values (10, 1, 'b');
 select * from parent; select * from child;
  aid | val1 | val2 | val3 | val4 | bcnt 
 -----+------+------+------+------+------
-   1 | a    | a    | a    | a    |    1
+   1 | a    | a    | a    | a    |    0
 (1 row)
 
  bid | aid | val1 
@@ -1743,12 +1644,10 @@
 (1 row)
 
 update parent set val1 = 'b' where aid = 1; -- should fail
-ERROR:  tuple to be updated was already modified by an operation triggered by the current command
-HINT:  Consider using an AFTER trigger instead of a BEFORE trigger to propagate changes to other rows.
 select * from parent; select * from child;
  aid | val1 | val2 | val3 | val4 | bcnt 
 -----+------+------+------+------+------
-   1 | a    | a    | a    | a    |    1
+   1 | b    | a    | a    | a    |    0
 (1 row)
 
  bid | aid | val1 
@@ -1757,13 +1656,10 @@
 (1 row)
 
 delete from parent where aid = 1; -- should fail
-ERROR:  tuple to be deleted was already modified by an operation triggered by the current command
-HINT:  Consider using an AFTER trigger instead of a BEFORE trigger to propagate changes to other rows.
 select * from parent; select * from child;
  aid | val1 | val2 | val3 | val4 | bcnt 
 -----+------+------+------+------+------
-   1 | a    | a    | a    | a    |    1
-(1 row)
+(0 rows)
 
  bid | aid | val1 
 -----+-----+------
@@ -1792,7 +1688,8 @@
 
  bid | aid | val1 
 -----+-----+------
-(0 rows)
+  10 |   1 | b
+(1 row)
 
 drop table parent, child;
 drop function parent_upd_func();
@@ -1820,6 +1717,10 @@
 $$;
 create trigger self_ref_trigger_ins_trig before insert on self_ref_trigger
   for each row execute procedure self_ref_trigger_ins_func();
+ERROR:  no data source matches prefix: new in this context
+HINT:  to access a field of a composite-typed column or variable, surround the column/variable name in parentheses: (varName).fieldName
+--
+See: https://go.crdb.dev/issue-v/114687/_version_
 create function self_ref_trigger_del_func()
   returns trigger language plpgsql as
 $$
@@ -1833,6 +1734,10 @@
 $$;
 create trigger self_ref_trigger_del_trig before delete on self_ref_trigger
   for each row execute procedure self_ref_trigger_del_func();
+ERROR:  no data source matches prefix: old in this context
+HINT:  to access a field of a composite-typed column or variable, surround the column/variable name in parentheses: (varName).fieldName
+--
+See: https://go.crdb.dev/issue-v/114687/_version_
 insert into self_ref_trigger values (1, null, 'root');
 insert into self_ref_trigger values (2, 1, 'root child A');
 insert into self_ref_trigger values (3, 1, 'root child B');
@@ -1842,25 +1747,18 @@
 select * from self_ref_trigger;
  id | parent |     data     | nchildren 
 ----+--------+--------------+-----------
-  2 |      1 | root child A |         1
+  1 |        | root!        |         0
+  2 |      1 | root child A |         0
+  3 |      1 | root child B |         0
   4 |      2 | grandchild 1 |         0
-  3 |      1 | root child B |         1
   5 |      3 | grandchild 2 |         0
-  1 |        | root!        |         2
 (5 rows)
 
 delete from self_ref_trigger;
-ERROR:  tuple to be updated was already modified by an operation triggered by the current command
-HINT:  Consider using an AFTER trigger instead of a BEFORE trigger to propagate changes to other rows.
 select * from self_ref_trigger;
- id | parent |     data     | nchildren 
-----+--------+--------------+-----------
-  2 |      1 | root child A |         1
-  4 |      2 | grandchild 1 |         0
-  3 |      1 | root child B |         1
-  5 |      3 | grandchild 2 |         0
-  1 |        | root!        |         2
-(5 rows)
+ id | parent | data | nchildren 
+----+--------+------+-----------
+(0 rows)
 
 drop table self_ref_trigger;
 drop function self_ref_trigger_ins_func();
@@ -1870,6 +1768,12 @@
 --
 create table stmt_trig_on_empty_upd (a int);
 create table stmt_trig_on_empty_upd1 () inherits (stmt_trig_on_empty_upd);
+ERROR:  at or near "(": syntax error: unimplemented: this syntax
+DETAIL:  source SQL:
+create table stmt_trig_on_empty_upd1 () inherits (stmt_trig_on_empty_upd)
+                                                 ^
+HINT:  You have attempted to use a feature that is not yet implemented.
+See: https://go.crdb.dev/issue-v/22456/_version_
 create function update_stmt_notice() returns trigger as $$
 begin
 	raise notice 'updating %', TG_TABLE_NAME;
@@ -1879,25 +1783,23 @@
 create trigger before_stmt_trigger
 	before update on stmt_trig_on_empty_upd
 	execute procedure update_stmt_notice();
+ERROR:  unimplemented: statement-level triggers are not yet supported
+HINT:  You have attempted to use a feature that is not yet implemented.
+See: https://go.crdb.dev/issue-v/126362/_version_
 create trigger before_stmt_trigger
 	before update on stmt_trig_on_empty_upd1
 	execute procedure update_stmt_notice();
+ERROR:  relation "stmt_trig_on_empty_upd1" does not exist
 -- inherited no-op update
 update stmt_trig_on_empty_upd set a = a where false returning a+1 as aa;
-NOTICE:  updating stmt_trig_on_empty_upd
  aa 
 ----
 (0 rows)
 
 -- simple no-op update
 update stmt_trig_on_empty_upd1 set a = a where false returning a+1 as aa;
-NOTICE:  updating stmt_trig_on_empty_upd1
- aa 
-----
-(0 rows)
-
+ERROR:  relation "stmt_trig_on_empty_upd1" does not exist
 drop table stmt_trig_on_empty_upd cascade;
-NOTICE:  drop cascades to table stmt_trig_on_empty_upd1
 drop function update_stmt_notice();
 --
 -- Check that index creation (or DDL in general) is prohibited in a trigger
@@ -1913,19 +1815,16 @@
 end$$ language plpgsql;
 create trigger trigger_ddl_func before insert on trigger_ddl_table for each row
   execute procedure trigger_ddl_func();
+ERROR:  unimplemented: ALTER TABLE usage inside a function definition is not supported
+HINT:  You have attempted to use a feature that is not yet implemented.
+See: https://go.crdb.dev/issue-v/110080/_version_
 insert into trigger_ddl_table values (1, 42);  -- fail
-ERROR:  cannot ALTER TABLE "trigger_ddl_table" because it is being used by active queries in this session
-CONTEXT:  SQL statement "alter table trigger_ddl_table add primary key (col1)"
-PL/pgSQL function trigger_ddl_func() line 3 at SQL statement
 create or replace function trigger_ddl_func() returns trigger as $$
 begin
   create index on trigger_ddl_table (col2);
   return new;
 end$$ language plpgsql;
 insert into trigger_ddl_table values (1, 42);  -- fail
-ERROR:  cannot CREATE INDEX "trigger_ddl_table" because it is being used by active queries in this session
-CONTEXT:  SQL statement "create index on trigger_ddl_table (col2)"
-PL/pgSQL function trigger_ddl_func() line 3 at SQL statement
 drop table trigger_ddl_table;
 drop function trigger_ddl_func();
 --
@@ -1953,6 +1852,7 @@
 $$;
 create trigger upsert_before_trig before insert or update on upsert
   for each row execute procedure upsert_before_func();
+ERROR:  no data source matches pattern: old.*
 create function upsert_after_func()
   returns trigger language plpgsql as
 $$
@@ -1968,52 +1868,27 @@
 $$;
 create trigger upsert_after_trig after insert or update on upsert
   for each row execute procedure upsert_after_func();
+ERROR:  no data source matches pattern: old.*
 insert into upsert values(1, 'black') on conflict (key) do update set color = 'updated ' || upsert.color;
-WARNING:  before insert (new): (1,black)
-WARNING:  after insert (new): (1,black)
 insert into upsert values(2, 'red') on conflict (key) do update set color = 'updated ' || upsert.color;
-WARNING:  before insert (new): (2,red)
-WARNING:  before insert (new, modified): (3,"red trig modified")
-WARNING:  after insert (new): (3,"red trig modified")
 insert into upsert values(3, 'orange') on conflict (key) do update set color = 'updated ' || upsert.color;
-WARNING:  before insert (new): (3,orange)
-WARNING:  before update (old): (3,"red trig modified")
-WARNING:  before update (new): (3,"updated red trig modified")
-WARNING:  after update (old): (3,"red trig modified")
-WARNING:  after update (new): (3,"updated red trig modified")
 insert into upsert values(4, 'green') on conflict (key) do update set color = 'updated ' || upsert.color;
-WARNING:  before insert (new): (4,green)
-WARNING:  before insert (new, modified): (5,"green trig modified")
-WARNING:  after insert (new): (5,"green trig modified")
 insert into upsert values(5, 'purple') on conflict (key) do update set color = 'updated ' || upsert.color;
-WARNING:  before insert (new): (5,purple)
-WARNING:  before update (old): (5,"green trig modified")
-WARNING:  before update (new): (5,"updated green trig modified")
-WARNING:  after update (old): (5,"green trig modified")
-WARNING:  after update (new): (5,"updated green trig modified")
 insert into upsert values(6, 'white') on conflict (key) do update set color = 'updated ' || upsert.color;
-WARNING:  before insert (new): (6,white)
-WARNING:  before insert (new, modified): (7,"white trig modified")
-WARNING:  after insert (new): (7,"white trig modified")
 insert into upsert values(7, 'pink') on conflict (key) do update set color = 'updated ' || upsert.color;
-WARNING:  before insert (new): (7,pink)
-WARNING:  before update (old): (7,"white trig modified")
-WARNING:  before update (new): (7,"updated white trig modified")
-WARNING:  after update (old): (7,"white trig modified")
-WARNING:  after update (new): (7,"updated white trig modified")
 insert into upsert values(8, 'yellow') on conflict (key) do update set color = 'updated ' || upsert.color;
-WARNING:  before insert (new): (8,yellow)
-WARNING:  before insert (new, modified): (9,"yellow trig modified")
-WARNING:  after insert (new): (9,"yellow trig modified")
 select * from upsert;
- key |            color            
------+-----------------------------
+ key | color  
+-----+--------
    1 | black
-   3 | updated red trig modified
-   5 | updated green trig modified
-   7 | updated white trig modified
-   9 | yellow trig modified
-(5 rows)
+   2 | red
+   3 | orange
+   4 | green
+   5 | purple
+   6 | white
+   7 | pink
+   8 | yellow
+(8 rows)
 
 drop table upsert;
 drop function upsert_before_func();
@@ -2027,8 +1902,9 @@
 create function my_trigger_function() returns trigger as $$ begin end; $$ language plpgsql;
 create trigger my_trigger after update on my_view referencing old table as old_table
    for each statement execute procedure my_trigger_function();
-ERROR:  "my_view" is a view
-DETAIL:  Triggers on views cannot have transition tables.
+ERROR:  unimplemented: statement-level triggers are not yet supported
+HINT:  You have attempted to use a feature that is not yet implemented.
+See: https://go.crdb.dev/issue-v/126362/_version_
 drop function my_trigger_function();
 drop view my_view;
 drop table my_table;
@@ -2036,67 +1912,95 @@
 -- Verify cases that are unsupported with partitioned tables
 --
 create table parted_trig (a int) partition by list (a);
+ERROR:  at or near "EOF": syntax error
+DETAIL:  source SQL:
+create table parted_trig (a int) partition by list (a)
+                                                      ^
+HINT:  try \h CREATE TABLE
 create function trigger_nothing() returns trigger
   language plpgsql as $$ begin end; $$;
 create trigger failed instead of update on parted_trig
   for each row execute procedure trigger_nothing();
-ERROR:  "parted_trig" is a table
-DETAIL:  Tables cannot have INSTEAD OF triggers.
+ERROR:  relation "parted_trig" does not exist
 create trigger failed after update on parted_trig
   referencing old table as old_table
   for each row execute procedure trigger_nothing();
-ERROR:  "parted_trig" is a partitioned table
-DETAIL:  ROW triggers with transition tables are not supported on partitioned tables.
+ERROR:  relation "parted_trig" does not exist
 drop table parted_trig;
+ERROR:  relation "parted_trig" does not exist
 --
 -- Verify trigger creation for partitioned tables, and drop behavior
 --
 create table trigpart (a int, b int) partition by range (a);
+ERROR:  at or near "EOF": syntax error
+DETAIL:  source SQL:
+create table trigpart (a int, b int) partition by range (a)
+                                                           ^
+HINT:  try \h CREATE TABLE
 create table trigpart1 partition of trigpart for values from (0) to (1000);
+ERROR:  at or near "partition": syntax error
+DETAIL:  source SQL:
+create table trigpart1 partition of trigpart for values from (0) to (1000)
+                       ^
+HINT:  try \h CREATE TABLE
 create trigger trg1 after insert on trigpart for each row execute procedure trigger_nothing();
+ERROR:  relation "trigpart" does not exist
 create table trigpart2 partition of trigpart for values from (1000) to (2000);
+ERROR:  at or near "partition": syntax error
+DETAIL:  source SQL:
+create table trigpart2 partition of trigpart for values from (1000) to (2000)
+                       ^
+HINT:  try \h CREATE TABLE
 create table trigpart3 (like trigpart);
+ERROR:  relation "trigpart" does not exist
 alter table trigpart attach partition trigpart3 for values from (2000) to (3000);
+ERROR:  at or near "attach": syntax error
+DETAIL:  source SQL:
+alter table trigpart attach partition trigpart3 for values from (2000) to (3000)
+                     ^
+HINT:  try \h ALTER TABLE
 create table trigpart4 partition of trigpart for values from (3000) to (4000) partition by range (a);
+ERROR:  at or near "partition": syntax error
+DETAIL:  source SQL:
+create table trigpart4 partition of trigpart for values from (3000) to (4000) partition by range (a)
+                       ^
+HINT:  try \h CREATE TABLE
 create table trigpart41 partition of trigpart4 for values from (3000) to (3500);
+ERROR:  at or near "partition": syntax error
+DETAIL:  source SQL:
+create table trigpart41 partition of trigpart4 for values from (3000) to (3500)
+                        ^
+HINT:  try \h CREATE TABLE
 create table trigpart42 (like trigpart);
+ERROR:  relation "trigpart" does not exist
 alter table trigpart4 attach partition trigpart42 for values from (3500) to (4000);
+ERROR:  at or near "attach": syntax error
+DETAIL:  source SQL:
+alter table trigpart4 attach partition trigpart42 for values from (3500) to (4000)
+                      ^
+HINT:  try \h ALTER TABLE
 select tgrelid::regclass, tgname, tgfoid::regproc from pg_trigger
   where tgrelid::regclass::text like 'trigpart%' order by tgrelid::regclass::text;
-  tgrelid   | tgname |     tgfoid      
-------------+--------+-----------------
- trigpart   | trg1   | trigger_nothing
- trigpart1  | trg1   | trigger_nothing
- trigpart2  | trg1   | trigger_nothing
- trigpart3  | trg1   | trigger_nothing
- trigpart4  | trg1   | trigger_nothing
- trigpart41 | trg1   | trigger_nothing
- trigpart42 | trg1   | trigger_nothing
-(7 rows)
+ tgrelid | tgname | tgfoid 
+---------+--------+--------
+(0 rows)
 
 drop trigger trg1 on trigpart1;	-- fail
-ERROR:  cannot drop trigger trg1 on table trigpart1 because trigger trg1 on table trigpart requires it
-HINT:  You can drop trigger trg1 on table trigpart instead.
+ERROR:  relation "trigpart1" does not exist
 drop trigger trg1 on trigpart2;	-- fail
-ERROR:  cannot drop trigger trg1 on table trigpart2 because trigger trg1 on table trigpart requires it
-HINT:  You can drop trigger trg1 on table trigpart instead.
+ERROR:  relation "trigpart2" does not exist
 drop trigger trg1 on trigpart3;	-- fail
-ERROR:  cannot drop trigger trg1 on table trigpart3 because trigger trg1 on table trigpart requires it
-HINT:  You can drop trigger trg1 on table trigpart instead.
+ERROR:  relation "trigpart3" does not exist
 drop table trigpart2;			-- ok, trigger should be gone in that partition
+ERROR:  relation "trigpart2" does not exist
 select tgrelid::regclass, tgname, tgfoid::regproc from pg_trigger
   where tgrelid::regclass::text like 'trigpart%' order by tgrelid::regclass::text;
-  tgrelid   | tgname |     tgfoid      
-------------+--------+-----------------
- trigpart   | trg1   | trigger_nothing
- trigpart1  | trg1   | trigger_nothing
- trigpart3  | trg1   | trigger_nothing
- trigpart4  | trg1   | trigger_nothing
- trigpart41 | trg1   | trigger_nothing
- trigpart42 | trg1   | trigger_nothing
-(6 rows)
+ tgrelid | tgname | tgfoid 
+---------+--------+--------
+(0 rows)
 
 drop trigger trg1 on trigpart;		-- ok, all gone
+ERROR:  relation "trigpart" does not exist
 select tgrelid::regclass, tgname, tgfoid::regproc from pg_trigger
   where tgrelid::regclass::text like 'trigpart%' order by tgrelid::regclass::text;
  tgrelid | tgname | tgfoid 
@@ -2105,74 +2009,140 @@
 
 -- check detach behavior
 create trigger trg1 after insert on trigpart for each row execute procedure trigger_nothing();
+ERROR:  relation "trigpart" does not exist
 \d trigpart3
-             Table "public.trigpart3"
- Column |  Type   | Collation | Nullable | Default 
---------+---------+-----------+----------+---------
- a      | integer |           |          | 
- b      | integer |           |          | 
-Partition of: trigpart FOR VALUES FROM (2000) TO (3000)
-Triggers:
-    trg1 AFTER INSERT ON trigpart3 FOR EACH ROW EXECUTE FUNCTION trigger_nothing(), ON TABLE trigpart
-
+ERROR:  at or near ".": syntax error
+DETAIL:  source SQL:
+SELECT c.oid,
+  n.nspname,
+  c.relname
+FROM pg_catalog.pg_class c
+     LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace
+WHERE c.relname OPERATOR(pg_catalog.~) '^(trigpart3)$' COLLATE pg_catalog.default
+                                                                         ^
 alter table trigpart detach partition trigpart3;
+ERROR:  at or near "detach": syntax error
+DETAIL:  source SQL:
+alter table trigpart detach partition trigpart3
+                     ^
+HINT:  try \h ALTER TABLE
 drop trigger trg1 on trigpart3; -- fail due to "does not exist"
-ERROR:  trigger "trg1" for table "trigpart3" does not exist
+ERROR:  relation "trigpart3" does not exist
 alter table trigpart detach partition trigpart4;
+ERROR:  at or near "detach": syntax error
+DETAIL:  source SQL:
+alter table trigpart detach partition trigpart4
+                     ^
+HINT:  try \h ALTER TABLE
 drop trigger trg1 on trigpart41; -- fail due to "does not exist"
-ERROR:  trigger "trg1" for table "trigpart41" does not exist
+ERROR:  relation "trigpart41" does not exist
 drop table trigpart4;
+ERROR:  relation "trigpart4" does not exist
 alter table trigpart attach partition trigpart3 for values from (2000) to (3000);
+ERROR:  at or near "attach": syntax error
+DETAIL:  source SQL:
+alter table trigpart attach partition trigpart3 for values from (2000) to (3000)
+                     ^
+HINT:  try \h ALTER TABLE
 alter table trigpart detach partition trigpart3;
+ERROR:  at or near "detach": syntax error
+DETAIL:  source SQL:
+alter table trigpart detach partition trigpart3
+                     ^
+HINT:  try \h ALTER TABLE
 alter table trigpart attach partition trigpart3 for values from (2000) to (3000);
+ERROR:  at or near "attach": syntax error
+DETAIL:  source SQL:
+alter table trigpart attach partition trigpart3 for values from (2000) to (3000)
+                     ^
+HINT:  try \h ALTER TABLE
 drop table trigpart3;
+ERROR:  relation "trigpart3" does not exist
 select tgrelid::regclass::text, tgname, tgfoid::regproc, tgenabled, tgisinternal from pg_trigger
   where tgname ~ '^trg1' order by 1;
-  tgrelid  | tgname |     tgfoid      | tgenabled | tgisinternal 
------------+--------+-----------------+-----------+--------------
- trigpart  | trg1   | trigger_nothing | O         | f
- trigpart1 | trg1   | trigger_nothing | O         | f
-(2 rows)
+ tgrelid | tgname | tgfoid | tgenabled | tgisinternal 
+---------+--------+--------+-----------+--------------
+(0 rows)
 
 create table trigpart3 (like trigpart);
+ERROR:  relation "trigpart" does not exist
 create trigger trg1 after insert on trigpart3 for each row execute procedure trigger_nothing();
+ERROR:  relation "trigpart3" does not exist
 \d trigpart3
-             Table "public.trigpart3"
- Column |  Type   | Collation | Nullable | Default 
---------+---------+-----------+----------+---------
- a      | integer |           |          | 
- b      | integer |           |          | 
-Triggers:
-    trg1 AFTER INSERT ON trigpart3 FOR EACH ROW EXECUTE FUNCTION trigger_nothing()
-
+ERROR:  at or near ".": syntax error
+DETAIL:  source SQL:
+SELECT c.oid,
+  n.nspname,
+  c.relname
+FROM pg_catalog.pg_class c
+     LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace
+WHERE c.relname OPERATOR(pg_catalog.~) '^(trigpart3)$' COLLATE pg_catalog.default
+                                                                         ^
 alter table trigpart attach partition trigpart3 FOR VALUES FROM (2000) to (3000); -- fail
-ERROR:  trigger "trg1" for relation "trigpart3" already exists
+ERROR:  at or near "attach": syntax error
+DETAIL:  source SQL:
+alter table trigpart attach partition trigpart3 FOR VALUES FROM (2000) to (3000)
+                     ^
+HINT:  try \h ALTER TABLE
 drop table trigpart3;
+ERROR:  relation "trigpart3" does not exist
 -- check display of unrelated triggers
 create trigger samename after delete on trigpart execute function trigger_nothing();
+ERROR:  relation "trigpart" does not exist
 create trigger samename after delete on trigpart1 execute function trigger_nothing();
+ERROR:  relation "trigpart1" does not exist
 \d trigpart1
-             Table "public.trigpart1"
- Column |  Type   | Collation | Nullable | Default 
---------+---------+-----------+----------+---------
- a      | integer |           |          | 
- b      | integer |           |          | 
-Partition of: trigpart FOR VALUES FROM (0) TO (1000)
-Triggers:
-    samename AFTER DELETE ON trigpart1 FOR EACH STATEMENT EXECUTE FUNCTION trigger_nothing()
-    trg1 AFTER INSERT ON trigpart1 FOR EACH ROW EXECUTE FUNCTION trigger_nothing(), ON TABLE trigpart
-
+ERROR:  at or near ".": syntax error
+DETAIL:  source SQL:
+SELECT c.oid,
+  n.nspname,
+  c.relname
+FROM pg_catalog.pg_class c
+     LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace
+WHERE c.relname OPERATOR(pg_catalog.~) '^(trigpart1)$' COLLATE pg_catalog.default
+                                                                         ^
 drop table trigpart;
+ERROR:  relation "trigpart" does not exist
 drop function trigger_nothing();
 --
 -- Verify that triggers are fired for partitioned tables
 --
 create table parted_stmt_trig (a int) partition by list (a);
+ERROR:  at or near "EOF": syntax error
+DETAIL:  source SQL:
+create table parted_stmt_trig (a int) partition by list (a)
+                                                           ^
+HINT:  try \h CREATE TABLE
 create table parted_stmt_trig1 partition of parted_stmt_trig for values in (1);
+ERROR:  at or near "partition": syntax error
+DETAIL:  source SQL:
+create table parted_stmt_trig1 partition of parted_stmt_trig for values in (1)
+                               ^
+HINT:  try \h CREATE TABLE
 create table parted_stmt_trig2 partition of parted_stmt_trig for values in (2);
+ERROR:  at or near "partition": syntax error
+DETAIL:  source SQL:
+create table parted_stmt_trig2 partition of parted_stmt_trig for values in (2)
+                               ^
+HINT:  try \h CREATE TABLE
 create table parted2_stmt_trig (a int) partition by list (a);
+ERROR:  at or near "EOF": syntax error
+DETAIL:  source SQL:
+create table parted2_stmt_trig (a int) partition by list (a)
+                                                            ^
+HINT:  try \h CREATE TABLE
 create table parted2_stmt_trig1 partition of parted2_stmt_trig for values in (1);
+ERROR:  at or near "partition": syntax error
+DETAIL:  source SQL:
+create table parted2_stmt_trig1 partition of parted2_stmt_trig for values in (1)
+                                ^
+HINT:  try \h CREATE TABLE
 create table parted2_stmt_trig2 partition of parted2_stmt_trig for values in (2);
+ERROR:  at or near "partition": syntax error
+DETAIL:  source SQL:
+create table parted2_stmt_trig2 partition of parted2_stmt_trig for values in (2)
+                                ^
+HINT:  try \h CREATE TABLE
 create or replace function trigger_notice() returns trigger as $$
   begin
     raise notice 'trigger % on % % % for %', TG_NAME, TG_TABLE_NAME, TG_WHEN, TG_OP, TG_LEVEL;
@@ -2185,133 +2155,167 @@
 -- insert/update/delete statement-level triggers on the parent
 create trigger trig_ins_before before insert on parted_stmt_trig
   for each statement execute procedure trigger_notice();
+ERROR:  relation "parted_stmt_trig" does not exist
 create trigger trig_ins_after after insert on parted_stmt_trig
   for each statement execute procedure trigger_notice();
+ERROR:  relation "parted_stmt_trig" does not exist
 create trigger trig_upd_before before update on parted_stmt_trig
   for each statement execute procedure trigger_notice();
+ERROR:  relation "parted_stmt_trig" does not exist
 create trigger trig_upd_after after update on parted_stmt_trig
   for each statement execute procedure trigger_notice();
+ERROR:  relation "parted_stmt_trig" does not exist
 create trigger trig_del_before before delete on parted_stmt_trig
   for each statement execute procedure trigger_notice();
+ERROR:  relation "parted_stmt_trig" does not exist
 create trigger trig_del_after after delete on parted_stmt_trig
   for each statement execute procedure trigger_notice();
+ERROR:  relation "parted_stmt_trig" does not exist
 -- insert/update/delete row-level triggers on the parent
 create trigger trig_ins_after_parent after insert on parted_stmt_trig
   for each row execute procedure trigger_notice();
+ERROR:  relation "parted_stmt_trig" does not exist
 create trigger trig_upd_after_parent after update on parted_stmt_trig
   for each row execute procedure trigger_notice();
+ERROR:  relation "parted_stmt_trig" does not exist
 create trigger trig_del_after_parent after delete on parted_stmt_trig
   for each row execute procedure trigger_notice();
+ERROR:  relation "parted_stmt_trig" does not exist
 -- insert/update/delete row-level triggers on the first partition
 create trigger trig_ins_before_child before insert on parted_stmt_trig1
   for each row execute procedure trigger_notice();
+ERROR:  relation "parted_stmt_trig1" does not exist
 create trigger trig_ins_after_child after insert on parted_stmt_trig1
   for each row execute procedure trigger_notice();
+ERROR:  relation "parted_stmt_trig1" does not exist
 create trigger trig_upd_before_child before update on parted_stmt_trig1
   for each row execute procedure trigger_notice();
+ERROR:  relation "parted_stmt_trig1" does not exist
 create trigger trig_upd_after_child after update on parted_stmt_trig1
   for each row execute procedure trigger_notice();
+ERROR:  relation "parted_stmt_trig1" does not exist
 create trigger trig_del_before_child before delete on parted_stmt_trig1
   for each row execute procedure trigger_notice();
+ERROR:  relation "parted_stmt_trig1" does not exist
 create trigger trig_del_after_child after delete on parted_stmt_trig1
   for each row execute procedure trigger_notice();
+ERROR:  relation "parted_stmt_trig1" does not exist
 -- insert/update/delete statement-level triggers on the parent
 create trigger trig_ins_before_3 before insert on parted2_stmt_trig
   for each statement execute procedure trigger_notice();
+ERROR:  relation "parted2_stmt_trig" does not exist
 create trigger trig_ins_after_3 after insert on parted2_stmt_trig
   for each statement execute procedure trigger_notice();
+ERROR:  relation "parted2_stmt_trig" does not exist
 create trigger trig_upd_before_3 before update on parted2_stmt_trig
   for each statement execute procedure trigger_notice();
+ERROR:  relation "parted2_stmt_trig" does not exist
 create trigger trig_upd_after_3 after update on parted2_stmt_trig
   for each statement execute procedure trigger_notice();
+ERROR:  relation "parted2_stmt_trig" does not exist
 create trigger trig_del_before_3 before delete on parted2_stmt_trig
   for each statement execute procedure trigger_notice();
+ERROR:  relation "parted2_stmt_trig" does not exist
 create trigger trig_del_after_3 after delete on parted2_stmt_trig
   for each statement execute procedure trigger_notice();
+ERROR:  relation "parted2_stmt_trig" does not exist
 with ins (a) as (
   insert into parted2_stmt_trig values (1), (2) returning a
 ) insert into parted_stmt_trig select a from ins returning tableoid::regclass, a;
-NOTICE:  trigger trig_ins_before on parted_stmt_trig BEFORE INSERT for STATEMENT
-NOTICE:  trigger trig_ins_before_3 on parted2_stmt_trig BEFORE INSERT for STATEMENT
-NOTICE:  trigger trig_ins_before_child on parted_stmt_trig1 BEFORE INSERT for ROW
-NOTICE:  trigger trig_ins_after_child on parted_stmt_trig1 AFTER INSERT for ROW
-NOTICE:  trigger trig_ins_after_parent on parted_stmt_trig1 AFTER INSERT for ROW
-NOTICE:  trigger trig_ins_after_parent on parted_stmt_trig2 AFTER INSERT for ROW
-NOTICE:  trigger trig_ins_after_3 on parted2_stmt_trig AFTER INSERT for STATEMENT
-NOTICE:  trigger trig_ins_after on parted_stmt_trig AFTER INSERT for STATEMENT
-     tableoid      | a 
--------------------+---
- parted_stmt_trig1 | 1
- parted_stmt_trig2 | 2
-(2 rows)
-
+ERROR:  relation "parted2_stmt_trig" does not exist
 with upd as (
   update parted2_stmt_trig set a = a
 ) update parted_stmt_trig  set a = a;
-NOTICE:  trigger trig_upd_before on parted_stmt_trig BEFORE UPDATE for STATEMENT
-NOTICE:  trigger trig_upd_before_child on parted_stmt_trig1 BEFORE UPDATE for ROW
-NOTICE:  trigger trig_upd_before_3 on parted2_stmt_trig BEFORE UPDATE for STATEMENT
-NOTICE:  trigger trig_upd_after_child on parted_stmt_trig1 AFTER UPDATE for ROW
-NOTICE:  trigger trig_upd_after_parent on parted_stmt_trig1 AFTER UPDATE for ROW
-NOTICE:  trigger trig_upd_after_parent on parted_stmt_trig2 AFTER UPDATE for ROW
-NOTICE:  trigger trig_upd_after on parted_stmt_trig AFTER UPDATE for STATEMENT
-NOTICE:  trigger trig_upd_after_3 on parted2_stmt_trig AFTER UPDATE for STATEMENT
+ERROR:  relation "parted2_stmt_trig" does not exist
 delete from parted_stmt_trig;
-NOTICE:  trigger trig_del_before on parted_stmt_trig BEFORE DELETE for STATEMENT
-NOTICE:  trigger trig_del_before_child on parted_stmt_trig1 BEFORE DELETE for ROW
-NOTICE:  trigger trig_del_after_parent on parted_stmt_trig2 AFTER DELETE for ROW
-NOTICE:  trigger trig_del_after on parted_stmt_trig AFTER DELETE for STATEMENT
+ERROR:  relation "parted_stmt_trig" does not exist
 -- insert via copy on the parent
 copy parted_stmt_trig(a) from stdin;
-NOTICE:  trigger trig_ins_before on parted_stmt_trig BEFORE INSERT for STATEMENT
-NOTICE:  trigger trig_ins_before_child on parted_stmt_trig1 BEFORE INSERT for ROW
-NOTICE:  trigger trig_ins_after_child on parted_stmt_trig1 AFTER INSERT for ROW
-NOTICE:  trigger trig_ins_after_parent on parted_stmt_trig1 AFTER INSERT for ROW
-NOTICE:  trigger trig_ins_after_parent on parted_stmt_trig2 AFTER INSERT for ROW
-NOTICE:  trigger trig_ins_after on parted_stmt_trig AFTER INSERT for STATEMENT
+ERROR:  relation "parted_stmt_trig" does not exist
+1
+2
+\.
+invalid command \.
 -- insert via copy on the first partition
 copy parted_stmt_trig1(a) from stdin;
-NOTICE:  trigger trig_ins_before_child on parted_stmt_trig1 BEFORE INSERT for ROW
-NOTICE:  trigger trig_ins_after_child on parted_stmt_trig1 AFTER INSERT for ROW
-NOTICE:  trigger trig_ins_after_parent on parted_stmt_trig1 AFTER INSERT for ROW
+ERROR:  at or near "1": syntax error
+DETAIL:  source SQL:
+1
+^
+1
+\.
+invalid command \.
 -- Disabling a trigger in the parent table should disable children triggers too
 alter table parted_stmt_trig disable trigger trig_ins_after_parent;
+ERROR:  at or near "1": syntax error
+DETAIL:  source SQL:
+1
+^
 insert into parted_stmt_trig values (1);
-NOTICE:  trigger trig_ins_before on parted_stmt_trig BEFORE INSERT for STATEMENT
-NOTICE:  trigger trig_ins_before_child on parted_stmt_trig1 BEFORE INSERT for ROW
-NOTICE:  trigger trig_ins_after_child on parted_stmt_trig1 AFTER INSERT for ROW
-NOTICE:  trigger trig_ins_after on parted_stmt_trig AFTER INSERT for STATEMENT
+ERROR:  relation "parted_stmt_trig" does not exist
 alter table parted_stmt_trig enable trigger trig_ins_after_parent;
+ERROR:  at or near "trigger": syntax error
+DETAIL:  source SQL:
+alter table parted_stmt_trig enable trigger trig_ins_after_parent
+                                    ^
+HINT:  try \h ALTER TABLE
 insert into parted_stmt_trig values (1);
-NOTICE:  trigger trig_ins_before on parted_stmt_trig BEFORE INSERT for STATEMENT
-NOTICE:  trigger trig_ins_before_child on parted_stmt_trig1 BEFORE INSERT for ROW
-NOTICE:  trigger trig_ins_after_child on parted_stmt_trig1 AFTER INSERT for ROW
-NOTICE:  trigger trig_ins_after_parent on parted_stmt_trig1 AFTER INSERT for ROW
-NOTICE:  trigger trig_ins_after on parted_stmt_trig AFTER INSERT for STATEMENT
+ERROR:  relation "parted_stmt_trig" does not exist
 drop table parted_stmt_trig, parted2_stmt_trig;
+ERROR:  relation "parted_stmt_trig" does not exist
 -- Verify that triggers fire in alphabetical order
 create table parted_trig (a int) partition by range (a);
+ERROR:  at or near "EOF": syntax error
+DETAIL:  source SQL:
+create table parted_trig (a int) partition by range (a)
+                                                       ^
+HINT:  try \h CREATE TABLE
 create table parted_trig_1 partition of parted_trig for values from (0) to (1000)
    partition by range (a);
+ERROR:  at or near "partition": syntax error
+DETAIL:  source SQL:
+create table parted_trig_1 partition of parted_trig for values from (0) to (1000)
+                           ^
+HINT:  try \h CREATE TABLE
 create table parted_trig_1_1 partition of parted_trig_1 for values from (0) to (100);
+ERROR:  at or near "partition": syntax error
+DETAIL:  source SQL:
+create table parted_trig_1_1 partition of parted_trig_1 for values from (0) to (100)
+                             ^
+HINT:  try \h CREATE TABLE
 create table parted_trig_2 partition of parted_trig for values from (1000) to (2000);
+ERROR:  at or near "partition": syntax error
+DETAIL:  source SQL:
+create table parted_trig_2 partition of parted_trig for values from (1000) to (2000)
+                           ^
+HINT:  try \h CREATE TABLE
 create trigger zzz after insert on parted_trig for each row execute procedure trigger_notice();
+ERROR:  relation "parted_trig" does not exist
 create trigger mmm after insert on parted_trig_1_1 for each row execute procedure trigger_notice();
+ERROR:  relation "parted_trig_1_1" does not exist
 create trigger aaa after insert on parted_trig_1 for each row execute procedure trigger_notice();
+ERROR:  relation "parted_trig_1" does not exist
 create trigger bbb after insert on parted_trig for each row execute procedure trigger_notice();
+ERROR:  relation "parted_trig" does not exist
 create trigger qqq after insert on parted_trig_1_1 for each row execute procedure trigger_notice();
+ERROR:  relation "parted_trig_1_1" does not exist
 insert into parted_trig values (50), (1500);
-NOTICE:  trigger aaa on parted_trig_1_1 AFTER INSERT for ROW
-NOTICE:  trigger bbb on parted_trig_1_1 AFTER INSERT for ROW
-NOTICE:  trigger mmm on parted_trig_1_1 AFTER INSERT for ROW
-NOTICE:  trigger qqq on parted_trig_1_1 AFTER INSERT for ROW
-NOTICE:  trigger zzz on parted_trig_1_1 AFTER INSERT for ROW
-NOTICE:  trigger bbb on parted_trig_2 AFTER INSERT for ROW
-NOTICE:  trigger zzz on parted_trig_2 AFTER INSERT for ROW
+ERROR:  relation "parted_trig" does not exist
 drop table parted_trig;
+ERROR:  relation "parted_trig" does not exist
 -- Verify propagation of trigger arguments to partitions
 create table parted_trig (a int) partition by list (a);
+ERROR:  at or near "EOF": syntax error
+DETAIL:  source SQL:
+create table parted_trig (a int) partition by list (a)
+                                                      ^
+HINT:  try \h CREATE TABLE
 create table parted_trig1 partition of parted_trig for values in (1);
+ERROR:  at or near "partition": syntax error
+DETAIL:  source SQL:
+create table parted_trig1 partition of parted_trig for values in (1)
+                          ^
+HINT:  try \h CREATE TABLE
 create or replace function trigger_notice() returns trigger as $$
   declare
     arg1 text = TG_ARGV[0];
@@ -2324,19 +2328,31 @@
   $$ language plpgsql;
 create trigger aaa after insert on parted_trig
    for each row execute procedure trigger_notice('quirky', 1);
+ERROR:  relation "parted_trig" does not exist
 -- Verify propagation of trigger arguments to partitions attached after creating trigger
 create table parted_trig2 partition of parted_trig for values in (2);
+ERROR:  at or near "partition": syntax error
+DETAIL:  source SQL:
+create table parted_trig2 partition of parted_trig for values in (2)
+                          ^
+HINT:  try \h CREATE TABLE
 create table parted_trig3 (like parted_trig);
+ERROR:  relation "parted_trig" does not exist
 alter table parted_trig attach partition parted_trig3 for values in (3);
+ERROR:  at or near "attach": syntax error
+DETAIL:  source SQL:
+alter table parted_trig attach partition parted_trig3 for values in (3)
+                        ^
+HINT:  try \h ALTER TABLE
 insert into parted_trig values (1), (2), (3);
-NOTICE:  trigger aaa on parted_trig1 AFTER INSERT for ROW args quirky 1
-NOTICE:  trigger aaa on parted_trig2 AFTER INSERT for ROW args quirky 1
-NOTICE:  trigger aaa on parted_trig3 AFTER INSERT for ROW args quirky 1
+ERROR:  relation "parted_trig" does not exist
 drop table parted_trig;
+ERROR:  relation "parted_trig" does not exist
 -- test irregular partitions (i.e., different column definitions),
 -- including that the WHEN clause works
 create function bark(text) returns bool language plpgsql immutable
   as $$ begin raise notice '% <- woof!', $1; return true; end; $$;
+ERROR:  no value provided for placeholder: $1
 create or replace function trigger_notice_ab() returns trigger as $$
   begin
     raise notice 'trigger % on % % % for %: (a,b)=(%,%)',
@@ -2350,42 +2366,76 @@
   $$ language plpgsql;
 create table parted_irreg_ancestor (fd text, b text, fd2 int, fd3 int, a int)
   partition by range (b);
+ERROR:  at or near "EOF": syntax error
+DETAIL:  source SQL:
+create table parted_irreg_ancestor (fd text, b text, fd2 int, fd3 int, a int)
+  partition by range (b)
+                        ^
+HINT:  try \h CREATE TABLE
 alter table parted_irreg_ancestor drop column fd,
   drop column fd2, drop column fd3;
+ERROR:  relation "parted_irreg_ancestor" does not exist
 create table parted_irreg (fd int, a int, fd2 int, b text)
   partition by range (b);
+ERROR:  at or near "EOF": syntax error
+DETAIL:  source SQL:
+create table parted_irreg (fd int, a int, fd2 int, b text)
+  partition by range (b)
+                        ^
+HINT:  try \h CREATE TABLE
 alter table parted_irreg drop column fd, drop column fd2;
+ERROR:  relation "parted_irreg" does not exist
 alter table parted_irreg_ancestor attach partition parted_irreg
   for values from ('aaaa') to ('zzzz');
+ERROR:  at or near "attach": syntax error
+DETAIL:  source SQL:
+alter table parted_irreg_ancestor attach partition parted_irreg
+                                  ^
+HINT:  try \h ALTER TABLE
 create table parted1_irreg (b text, fd int, a int);
 alter table parted1_irreg drop column fd;
 alter table parted_irreg attach partition parted1_irreg
   for values from ('aaaa') to ('bbbb');
+ERROR:  at or near "attach": syntax error
+DETAIL:  source SQL:
+alter table parted_irreg attach partition parted1_irreg
+                         ^
+HINT:  try \h ALTER TABLE
 create trigger parted_trig after insert on parted_irreg
   for each row execute procedure trigger_notice_ab();
+ERROR:  relation "parted_irreg" does not exist
 create trigger parted_trig_odd after insert on parted_irreg for each row
   when (bark(new.b) AND new.a % 2 = 1) execute procedure trigger_notice_ab();
+ERROR:  relation "parted_irreg" does not exist
 -- we should hear barking for every insert, but parted_trig_odd only emits
 -- noise for odd values of a. parted_trig does it for all inserts.
 insert into parted_irreg values (1, 'aardvark'), (2, 'aanimals');
-NOTICE:  aardvark <- woof!
-NOTICE:  aanimals <- woof!
-NOTICE:  trigger parted_trig on parted1_irreg AFTER INSERT for ROW: (a,b)=(1,aardvark)
-NOTICE:  trigger parted_trig_odd on parted1_irreg AFTER INSERT for ROW: (a,b)=(1,aardvark)
-NOTICE:  trigger parted_trig on parted1_irreg AFTER INSERT for ROW: (a,b)=(2,aanimals)
+ERROR:  relation "parted_irreg" does not exist
 insert into parted1_irreg values ('aardwolf', 2);
-NOTICE:  aardwolf <- woof!
-NOTICE:  trigger parted_trig on parted1_irreg AFTER INSERT for ROW: (a,b)=(2,aardwolf)
 insert into parted_irreg_ancestor values ('aasvogel', 3);
-NOTICE:  aasvogel <- woof!
-NOTICE:  trigger parted_trig on parted1_irreg AFTER INSERT for ROW: (a,b)=(3,aasvogel)
-NOTICE:  trigger parted_trig_odd on parted1_irreg AFTER INSERT for ROW: (a,b)=(3,aasvogel)
+ERROR:  relation "parted_irreg_ancestor" does not exist
 drop table parted_irreg_ancestor;
+ERROR:  relation "parted_irreg_ancestor" does not exist
 -- Before triggers and partitions
 create table parted (a int, b int, c text) partition by list (a);
+ERROR:  at or near "EOF": syntax error
+DETAIL:  source SQL:
+create table parted (a int, b int, c text) partition by list (a)
+                                                                ^
+HINT:  try \h CREATE TABLE
 create table parted_1 partition of parted for values in (1)
   partition by list (b);
+ERROR:  at or near "partition": syntax error
+DETAIL:  source SQL:
+create table parted_1 partition of parted for values in (1)
+                      ^
+HINT:  try \h CREATE TABLE
 create table parted_1_1 partition of parted_1 for values in (1);
+ERROR:  at or near "partition": syntax error
+DETAIL:  source SQL:
+create table parted_1_1 partition of parted_1 for values in (1)
+                        ^
+HINT:  try \h CREATE TABLE
 create function parted_trigfunc() returns trigger language plpgsql as $$
 begin
   new.a = new.a + 1;
@@ -2393,14 +2443,14 @@
 end;
 $$;
 insert into parted values (1, 1, 'uno uno v1');    -- works
+ERROR:  relation "parted" does not exist
 create trigger t before insert or update or delete on parted
   for each row execute function parted_trigfunc();
+ERROR:  relation "parted" does not exist
 insert into parted values (1, 1, 'uno uno v2');    -- fail
-ERROR:  moving row to another partition during a BEFORE FOR EACH ROW trigger is not supported
-DETAIL:  Before executing trigger "t", the row was to be in partition "public.parted_1_1".
+ERROR:  relation "parted" does not exist
 update parted set c = c || 'v3';                   -- fail
-ERROR:  no partition of relation "parted" found for row
-DETAIL:  Partition key of the failing row contains (a) = (2).
+ERROR:  relation "parted" does not exist
 create or replace function parted_trigfunc() returns trigger language plpgsql as $$
 begin
   new.b = new.b + 1;
@@ -2408,11 +2458,9 @@
 end;
 $$;
 insert into parted values (1, 1, 'uno uno v4');    -- fail
-ERROR:  moving row to another partition during a BEFORE FOR EACH ROW trigger is not supported
-DETAIL:  Before executing trigger "t", the row was to be in partition "public.parted_1_1".
+ERROR:  relation "parted" does not exist
 update parted set c = c || 'v5';                   -- fail
-ERROR:  no partition of relation "parted_1" found for row
-DETAIL:  Partition key of the failing row contains (b) = (2).
+ERROR:  relation "parted" does not exist
 create or replace function parted_trigfunc() returns trigger language plpgsql as $$
 begin
   new.c = new.c || ' did '|| TG_OP;
@@ -2420,25 +2468,26 @@
 end;
 $$;
 insert into parted values (1, 1, 'uno uno');       -- works
+ERROR:  relation "parted" does not exist
 update parted set c = c || ' v6';                   -- works
+ERROR:  relation "parted" does not exist
 select tableoid::regclass, * from parted;
-  tableoid  | a | b |                c                 
-------------+---+---+----------------------------------
- parted_1_1 | 1 | 1 | uno uno v1 v6 did UPDATE
- parted_1_1 | 1 | 1 | uno uno did INSERT v6 did UPDATE
-(2 rows)
-
+ERROR:  relation "parted" does not exist
 -- update itself moves tuple to new partition; trigger still works
 truncate table parted;
+ERROR:  relation "parted" does not exist
 create table parted_2 partition of parted for values in (2);
+ERROR:  at or near "partition": syntax error
+DETAIL:  source SQL:
+create table parted_2 partition of parted for values in (2)
+                      ^
+HINT:  try \h CREATE TABLE
 insert into parted values (1, 1, 'uno uno v5');
+ERROR:  relation "parted" does not exist
 update parted set a = 2;
+ERROR:  relation "parted" does not exist
 select tableoid::regclass, * from parted;
- tableoid | a | b |                      c                      
-----------+---+---+---------------------------------------------
- parted_2 | 2 | 1 | uno uno v5 did INSERT did UPDATE did INSERT
-(1 row)
-
+ERROR:  relation "parted" does not exist
 -- both trigger and update change the partition
 create or replace function parted_trigfunc2() returns trigger language plpgsql as $$
 begin
@@ -2448,27 +2497,35 @@
 $$;
 create trigger t2 before update on parted
   for each row execute function parted_trigfunc2();
+ERROR:  relation "parted" does not exist
 truncate table parted;
+ERROR:  relation "parted" does not exist
 insert into parted values (1, 1, 'uno uno v6');
+ERROR:  relation "parted" does not exist
 create table parted_3 partition of parted for values in (3);
+ERROR:  at or near "partition": syntax error
+DETAIL:  source SQL:
+create table parted_3 partition of parted for values in (3)
+                      ^
+HINT:  try \h CREATE TABLE
 update parted set a = a + 1;
+ERROR:  relation "parted" does not exist
 select tableoid::regclass, * from parted;
- tableoid | a | b |                      c                      
-----------+---+---+---------------------------------------------
- parted_3 | 3 | 1 | uno uno v6 did INSERT did UPDATE did INSERT
-(1 row)
-
+ERROR:  relation "parted" does not exist
 -- there's no partition for a=0, but this update works anyway because
 -- the trigger causes the tuple to be routed to another partition
 update parted set a = 0;
+ERROR:  relation "parted" does not exist
 select tableoid::regclass, * from parted;
-  tableoid  | a | b |                                 c                                 
-------------+---+---+-------------------------------------------------------------------
- parted_1_1 | 1 | 1 | uno uno v6 did INSERT did UPDATE did INSERT did UPDATE did INSERT
-(1 row)
-
+ERROR:  relation "parted" does not exist
 drop table parted;
+ERROR:  relation "parted" does not exist
 create table parted (a int, b int, c text) partition by list ((a + b));
+ERROR:  at or near "(": syntax error
+DETAIL:  source SQL:
+create table parted (a int, b int, c text) partition by list ((a + b))
+                                                              ^
+HINT:  try \h CREATE TABLE
 create or replace function parted_trigfunc() returns trigger language plpgsql as $$
 begin
   new.a = new.a + new.b;
@@ -2476,350 +2533,605 @@
 end;
 $$;
 create table parted_1 partition of parted for values in (1, 2);
+ERROR:  at or near "partition": syntax error
+DETAIL:  source SQL:
+create table parted_1 partition of parted for values in (1, 2)
+                      ^
+HINT:  try \h CREATE TABLE
 create table parted_2 partition of parted for values in (3, 4);
+ERROR:  at or near "partition": syntax error
+DETAIL:  source SQL:
+create table parted_2 partition of parted for values in (3, 4)
+                      ^
+HINT:  try \h CREATE TABLE
 create trigger t before insert or update on parted
   for each row execute function parted_trigfunc();
+ERROR:  relation "parted" does not exist
 insert into parted values (0, 1, 'zero win');
+ERROR:  relation "parted" does not exist
 insert into parted values (1, 1, 'one fail');
-ERROR:  moving row to another partition during a BEFORE FOR EACH ROW trigger is not supported
-DETAIL:  Before executing trigger "t", the row was to be in partition "public.parted_1".
+ERROR:  relation "parted" does not exist
 insert into parted values (1, 2, 'two fail');
-ERROR:  moving row to another partition during a BEFORE FOR EACH ROW trigger is not supported
-DETAIL:  Before executing trigger "t", the row was to be in partition "public.parted_2".
+ERROR:  relation "parted" does not exist
 select * from parted;
- a | b |    c     
----+---+----------
- 1 | 1 | zero win
-(1 row)
-
+ERROR:  relation "parted" does not exist
 drop table parted;
+ERROR:  relation "parted" does not exist
 drop function parted_trigfunc();
 --
 -- Constraint triggers and partitioned tables
 create table parted_constr_ancestor (a int, b text)
   partition by range (b);
+ERROR:  at or near "EOF": syntax error
+DETAIL:  source SQL:
+create table parted_constr_ancestor (a int, b text)
+  partition by range (b)
+                        ^
+HINT:  try \h CREATE TABLE
 create table parted_constr (a int, b text)
   partition by range (b);
+ERROR:  at or near "EOF": syntax error
+DETAIL:  source SQL:
+create table parted_constr (a int, b text)
+  partition by range (b)
+                        ^
+HINT:  try \h CREATE TABLE
 alter table parted_constr_ancestor attach partition parted_constr
   for values from ('aaaa') to ('zzzz');
+ERROR:  at or near "attach": syntax error
+DETAIL:  source SQL:
+alter table parted_constr_ancestor attach partition parted_constr
+                                   ^
+HINT:  try \h ALTER TABLE
 create table parted1_constr (a int, b text);
 alter table parted_constr attach partition parted1_constr
   for values from ('aaaa') to ('bbbb');
+ERROR:  at or near "attach": syntax error
+DETAIL:  source SQL:
+alter table parted_constr attach partition parted1_constr
+                          ^
+HINT:  try \h ALTER TABLE
 create constraint trigger parted_trig after insert on parted_constr_ancestor
   deferrable
   for each row execute procedure trigger_notice_ab();
+ERROR:  at or near "parted_trig": syntax error: unimplemented: this syntax
+DETAIL:  source SQL:
+create constraint trigger parted_trig after insert on parted_constr_ancestor
+                          ^
+HINT:  You have attempted to use a feature that is not yet implemented.
+See: https://go.crdb.dev/issue-v/28296/_version_
 create constraint trigger parted_trig_two after insert on parted_constr
   deferrable initially deferred
   for each row when (bark(new.b) AND new.a % 2 = 1)
   execute procedure trigger_notice_ab();
+ERROR:  at or near "parted_trig_two": syntax error: unimplemented: this syntax
+DETAIL:  source SQL:
+create constraint trigger parted_trig_two after insert on parted_constr
+                          ^
+HINT:  You have attempted to use a feature that is not yet implemented.
+See: https://go.crdb.dev/issue-v/28296/_version_
 -- The immediate constraint is fired immediately; the WHEN clause of the
 -- deferred constraint is also called immediately.  The deferred constraint
 -- is fired at commit time.
 begin;
 insert into parted_constr values (1, 'aardvark');
-NOTICE:  aardvark <- woof!
-NOTICE:  trigger parted_trig on parted1_constr AFTER INSERT for ROW: (a,b)=(1,aardvark)
+ERROR:  relation "parted_constr" does not exist
 insert into parted1_constr values (2, 'aardwolf');
-NOTICE:  aardwolf <- woof!
-NOTICE:  trigger parted_trig on parted1_constr AFTER INSERT for ROW: (a,b)=(2,aardwolf)
+ERROR:  current transaction is aborted, commands ignored until end of transaction block
 insert into parted_constr_ancestor values (3, 'aasvogel');
-NOTICE:  aasvogel <- woof!
-NOTICE:  trigger parted_trig on parted1_constr AFTER INSERT for ROW: (a,b)=(3,aasvogel)
+ERROR:  current transaction is aborted, commands ignored until end of transaction block
 commit;
-NOTICE:  trigger parted_trig_two on parted1_constr AFTER INSERT for ROW: (a,b)=(1,aardvark)
-NOTICE:  trigger parted_trig_two on parted1_constr AFTER INSERT for ROW: (a,b)=(3,aasvogel)
 -- The WHEN clause is immediate, and both constraint triggers are fired at
 -- commit time.
 begin;
 set constraints parted_trig deferred;
+ERROR:  at or near "parted_trig": syntax error: unimplemented: this syntax
+DETAIL:  source SQL:
+set constraints parted_trig deferred
+                ^
+HINT:  You have attempted to use a feature that is not yet implemented.
+
+Please check the public issue tracker to check whether this problem is
+already tracked. If you cannot find it there, please report the error
+with details by creating a new issue.
+
+If you would rather not post publicly, please contact us directly
+using the support form.
+
+We appreciate your feedback.
+
 insert into parted_constr values (1, 'aardvark');
-NOTICE:  aardvark <- woof!
+ERROR:  current transaction is aborted, commands ignored until end of transaction block
 insert into parted1_constr values (2, 'aardwolf'), (3, 'aasvogel');
-NOTICE:  aardwolf <- woof!
-NOTICE:  aasvogel <- woof!
+ERROR:  current transaction is aborted, commands ignored until end of transaction block
 commit;
-NOTICE:  trigger parted_trig on parted1_constr AFTER INSERT for ROW: (a,b)=(1,aardvark)
-NOTICE:  trigger parted_trig_two on parted1_constr AFTER INSERT for ROW: (a,b)=(1,aardvark)
-NOTICE:  trigger parted_trig on parted1_constr AFTER INSERT for ROW: (a,b)=(2,aardwolf)
-NOTICE:  trigger parted_trig on parted1_constr AFTER INSERT for ROW: (a,b)=(3,aasvogel)
-NOTICE:  trigger parted_trig_two on parted1_constr AFTER INSERT for ROW: (a,b)=(3,aasvogel)
 drop table parted_constr_ancestor;
+ERROR:  relation "parted_constr_ancestor" does not exist
 drop function bark(text);
+ERROR:  unknown function: bark()
 -- Test that the WHEN clause is set properly to partitions
 create table parted_trigger (a int, b text) partition by range (a);
+ERROR:  at or near "EOF": syntax error
+DETAIL:  source SQL:
+create table parted_trigger (a int, b text) partition by range (a)
+                                                                  ^
+HINT:  try \h CREATE TABLE
 create table parted_trigger_1 partition of parted_trigger for values from (0) to (1000);
+ERROR:  at or near "partition": syntax error
+DETAIL:  source SQL:
+create table parted_trigger_1 partition of parted_trigger for values from (0) to (1000)
+                              ^
+HINT:  try \h CREATE TABLE
 create table parted_trigger_2 (drp int, a int, b text);
 alter table parted_trigger_2 drop column drp;
 alter table parted_trigger attach partition parted_trigger_2 for values from (1000) to (2000);
+ERROR:  at or near "attach": syntax error
+DETAIL:  source SQL:
+alter table parted_trigger attach partition parted_trigger_2 for values from (1000) to (2000)
+                           ^
+HINT:  try \h ALTER TABLE
 create trigger parted_trigger after update on parted_trigger
   for each row when (new.a % 2 = 1 and length(old.b) >= 2) execute procedure trigger_notice_ab();
+ERROR:  relation "parted_trigger" does not exist
 create table parted_trigger_3 (b text, a int) partition by range (length(b));
+ERROR:  at or near "(": syntax error
+DETAIL:  source SQL:
+create table parted_trigger_3 (b text, a int) partition by range (length(b))
+                                                                        ^
+HINT:  try \h CREATE TABLE
 create table parted_trigger_3_1 partition of parted_trigger_3 for values from (1) to (3);
+ERROR:  at or near "partition": syntax error
+DETAIL:  source SQL:
+create table parted_trigger_3_1 partition of parted_trigger_3 for values from (1) to (3)
+                                ^
+HINT:  try \h CREATE TABLE
 create table parted_trigger_3_2 partition of parted_trigger_3 for values from (3) to (5);
+ERROR:  at or near "partition": syntax error
+DETAIL:  source SQL:
+create table parted_trigger_3_2 partition of parted_trigger_3 for values from (3) to (5)
+                                ^
+HINT:  try \h CREATE TABLE
 alter table parted_trigger attach partition parted_trigger_3 for values from (2000) to (3000);
+ERROR:  at or near "attach": syntax error
+DETAIL:  source SQL:
+alter table parted_trigger attach partition parted_trigger_3 for values from (2000) to (3000)
+                           ^
+HINT:  try \h ALTER TABLE
 insert into parted_trigger values
     (0, 'a'), (1, 'bbb'), (2, 'bcd'), (3, 'c'),
 	(1000, 'c'), (1001, 'ddd'), (1002, 'efg'), (1003, 'f'),
 	(2000, 'e'), (2001, 'fff'), (2002, 'ghi'), (2003, 'h');
+ERROR:  relation "parted_trigger" does not exist
 update parted_trigger set a = a + 2; -- notice for odd 'a' values, long 'b' values
-NOTICE:  trigger parted_trigger on parted_trigger_1 AFTER UPDATE for ROW: (a,b)=(3,bbb)
-NOTICE:  trigger parted_trigger on parted_trigger_2 AFTER UPDATE for ROW: (a,b)=(1003,ddd)
-NOTICE:  trigger parted_trigger on parted_trigger_3_2 AFTER UPDATE for ROW: (a,b)=(2003,fff)
+ERROR:  relation "parted_trigger" does not exist
 drop table parted_trigger;
+ERROR:  relation "parted_trigger" does not exist
 -- try a constraint trigger, also
 create table parted_referenced (a int);
 create table unparted_trigger (a int, b text);	-- for comparison purposes
 create table parted_trigger (a int, b text) partition by range (a);
+ERROR:  at or near "EOF": syntax error
+DETAIL:  source SQL:
+create table parted_trigger (a int, b text) partition by range (a)
+                                                                  ^
+HINT:  try \h CREATE TABLE
 create table parted_trigger_1 partition of parted_trigger for values from (0) to (1000);
+ERROR:  at or near "partition": syntax error
+DETAIL:  source SQL:
+create table parted_trigger_1 partition of parted_trigger for values from (0) to (1000)
+                              ^
+HINT:  try \h CREATE TABLE
 create table parted_trigger_2 (drp int, a int, b text);
+ERROR:  relation "root.public.parted_trigger_2" already exists
 alter table parted_trigger_2 drop column drp;
+ERROR:  column "drp" does not exist
 alter table parted_trigger attach partition parted_trigger_2 for values from (1000) to (2000);
+ERROR:  at or near "attach": syntax error
+DETAIL:  source SQL:
+alter table parted_trigger attach partition parted_trigger_2 for values from (1000) to (2000)
+                           ^
+HINT:  try \h ALTER TABLE
 create constraint trigger parted_trigger after update on parted_trigger
   from parted_referenced
   for each row execute procedure trigger_notice_ab();
+ERROR:  at or near "parted_trigger": syntax error: unimplemented: this syntax
+DETAIL:  source SQL:
+create constraint trigger parted_trigger after update on parted_trigger
+                          ^
+HINT:  You have attempted to use a feature that is not yet implemented.
+See: https://go.crdb.dev/issue-v/28296/_version_
 create constraint trigger parted_trigger after update on unparted_trigger
   from parted_referenced
   for each row execute procedure trigger_notice_ab();
+ERROR:  at or near "parted_trigger": syntax error: unimplemented: this syntax
+DETAIL:  source SQL:
+create constraint trigger parted_trigger after update on unparted_trigger
+                          ^
+HINT:  You have attempted to use a feature that is not yet implemented.
+See: https://go.crdb.dev/issue-v/28296/_version_
 create table parted_trigger_3 (b text, a int) partition by range (length(b));
+ERROR:  at or near "(": syntax error
+DETAIL:  source SQL:
+create table parted_trigger_3 (b text, a int) partition by range (length(b))
+                                                                        ^
+HINT:  try \h CREATE TABLE
 create table parted_trigger_3_1 partition of parted_trigger_3 for values from (1) to (3);
+ERROR:  at or near "partition": syntax error
+DETAIL:  source SQL:
+create table parted_trigger_3_1 partition of parted_trigger_3 for values from (1) to (3)
+                                ^
+HINT:  try \h CREATE TABLE
 create table parted_trigger_3_2 partition of parted_trigger_3 for values from (3) to (5);
+ERROR:  at or near "partition": syntax error
+DETAIL:  source SQL:
+create table parted_trigger_3_2 partition of parted_trigger_3 for values from (3) to (5)
+                                ^
+HINT:  try \h CREATE TABLE
 alter table parted_trigger attach partition parted_trigger_3 for values from (2000) to (3000);
+ERROR:  at or near "attach": syntax error
+DETAIL:  source SQL:
+alter table parted_trigger attach partition parted_trigger_3 for values from (2000) to (3000)
+                           ^
+HINT:  try \h ALTER TABLE
 select tgname, conname, t.tgrelid::regclass, t.tgconstrrelid::regclass,
   c.conrelid::regclass, c.confrelid::regclass
   from pg_trigger t join pg_constraint c on (t.tgconstraint = c.oid)
   where tgname = 'parted_trigger'
   order by t.tgrelid::regclass::text;
-     tgname     |    conname     |      tgrelid       |   tgconstrrelid   |      conrelid      | confrelid 
-----------------+----------------+--------------------+-------------------+--------------------+-----------
- parted_trigger | parted_trigger | parted_trigger     | parted_referenced | parted_trigger     | -
- parted_trigger | parted_trigger | parted_trigger_1   | parted_referenced | parted_trigger_1   | -
- parted_trigger | parted_trigger | parted_trigger_2   | parted_referenced | parted_trigger_2   | -
- parted_trigger | parted_trigger | parted_trigger_3   | parted_referenced | parted_trigger_3   | -
- parted_trigger | parted_trigger | parted_trigger_3_1 | parted_referenced | parted_trigger_3_1 | -
- parted_trigger | parted_trigger | parted_trigger_3_2 | parted_referenced | parted_trigger_3_2 | -
- parted_trigger | parted_trigger | unparted_trigger   | parted_referenced | unparted_trigger   | -
-(7 rows)
+ tgname | conname | tgrelid | tgconstrrelid | conrelid | confrelid 
+--------+---------+---------+---------------+----------+-----------
+(0 rows)
 
 drop table parted_referenced, parted_trigger, unparted_trigger;
+ERROR:  relation "parted_trigger" does not exist
 -- verify that the "AFTER UPDATE OF columns" event is propagated correctly
 create table parted_trigger (a int, b text) partition by range (a);
+ERROR:  at or near "EOF": syntax error
+DETAIL:  source SQL:
+create table parted_trigger (a int, b text) partition by range (a)
+                                                                  ^
+HINT:  try \h CREATE TABLE
 create table parted_trigger_1 partition of parted_trigger for values from (0) to (1000);
+ERROR:  at or near "partition": syntax error
+DETAIL:  source SQL:
+create table parted_trigger_1 partition of parted_trigger for values from (0) to (1000)
+                              ^
+HINT:  try \h CREATE TABLE
 create table parted_trigger_2 (drp int, a int, b text);
+ERROR:  relation "root.public.parted_trigger_2" already exists
 alter table parted_trigger_2 drop column drp;
+ERROR:  column "drp" does not exist
 alter table parted_trigger attach partition parted_trigger_2 for values from (1000) to (2000);
+ERROR:  at or near "attach": syntax error
+DETAIL:  source SQL:
+alter table parted_trigger attach partition parted_trigger_2 for values from (1000) to (2000)
+                           ^
+HINT:  try \h ALTER TABLE
 create trigger parted_trigger after update of b on parted_trigger
   for each row execute procedure trigger_notice_ab();
+ERROR:  relation "parted_trigger" does not exist
 create table parted_trigger_3 (b text, a int) partition by range (length(b));
+ERROR:  at or near "(": syntax error
+DETAIL:  source SQL:
+create table parted_trigger_3 (b text, a int) partition by range (length(b))
+                                                                        ^
+HINT:  try \h CREATE TABLE
 create table parted_trigger_3_1 partition of parted_trigger_3 for values from (1) to (4);
+ERROR:  at or near "partition": syntax error
+DETAIL:  source SQL:
+create table parted_trigger_3_1 partition of parted_trigger_3 for values from (1) to (4)
+                                ^
+HINT:  try \h CREATE TABLE
 create table parted_trigger_3_2 partition of parted_trigger_3 for values from (4) to (8);
+ERROR:  at or near "partition": syntax error
+DETAIL:  source SQL:
+create table parted_trigger_3_2 partition of parted_trigger_3 for values from (4) to (8)
+                                ^
+HINT:  try \h CREATE TABLE
 alter table parted_trigger attach partition parted_trigger_3 for values from (2000) to (3000);
+ERROR:  at or near "attach": syntax error
+DETAIL:  source SQL:
+alter table parted_trigger attach partition parted_trigger_3 for values from (2000) to (3000)
+                           ^
+HINT:  try \h ALTER TABLE
 insert into parted_trigger values (0, 'a'), (1000, 'c'), (2000, 'e'), (2001, 'eeee');
+ERROR:  relation "parted_trigger" does not exist
 update parted_trigger set a = a + 2;	-- no notices here
+ERROR:  relation "parted_trigger" does not exist
 update parted_trigger set b = b || 'b';	-- all triggers should fire
-NOTICE:  trigger parted_trigger on parted_trigger_1 AFTER UPDATE for ROW: (a,b)=(2,ab)
-NOTICE:  trigger parted_trigger on parted_trigger_2 AFTER UPDATE for ROW: (a,b)=(1002,cb)
-NOTICE:  trigger parted_trigger on parted_trigger_3_1 AFTER UPDATE for ROW: (a,b)=(2002,eb)
-NOTICE:  trigger parted_trigger on parted_trigger_3_2 AFTER UPDATE for ROW: (a,b)=(2003,eeeeb)
+ERROR:  relation "parted_trigger" does not exist
 drop table parted_trigger;
+ERROR:  relation "parted_trigger" does not exist
 drop function trigger_notice_ab();
 -- Make sure we don't end up with unnecessary copies of triggers, when
 -- cloning them.
 create table trg_clone (a int) partition by range (a);
+ERROR:  at or near "EOF": syntax error
+DETAIL:  source SQL:
+create table trg_clone (a int) partition by range (a)
+                                                     ^
+HINT:  try \h CREATE TABLE
 create table trg_clone1 partition of trg_clone for values from (0) to (1000);
+ERROR:  at or near "partition": syntax error
+DETAIL:  source SQL:
+create table trg_clone1 partition of trg_clone for values from (0) to (1000)
+                        ^
+HINT:  try \h CREATE TABLE
 alter table trg_clone add constraint uniq unique (a) deferrable;
+ERROR:  at or near "EOF": syntax error: unimplemented: this syntax
+DETAIL:  source SQL:
+alter table trg_clone add constraint uniq unique (a) deferrable
+                                                               ^
+HINT:  You have attempted to use a feature that is not yet implemented.
+See: https://go.crdb.dev/issue-v/31632/_version_
 create table trg_clone2 partition of trg_clone for values from (1000) to (2000);
+ERROR:  at or near "partition": syntax error
+DETAIL:  source SQL:
+create table trg_clone2 partition of trg_clone for values from (1000) to (2000)
+                        ^
+HINT:  try \h CREATE TABLE
 create table trg_clone3 partition of trg_clone for values from (2000) to (3000)
   partition by range (a);
+ERROR:  at or near "partition": syntax error
+DETAIL:  source SQL:
+create table trg_clone3 partition of trg_clone for values from (2000) to (3000)
+                        ^
+HINT:  try \h CREATE TABLE
 create table trg_clone_3_3 partition of trg_clone3 for values from (2000) to (2100);
+ERROR:  at or near "partition": syntax error
+DETAIL:  source SQL:
+create table trg_clone_3_3 partition of trg_clone3 for values from (2000) to (2100)
+                           ^
+HINT:  try \h CREATE TABLE
 select tgrelid::regclass, count(*) from pg_trigger
   where tgrelid::regclass in ('trg_clone', 'trg_clone1', 'trg_clone2',
 	'trg_clone3', 'trg_clone_3_3')
   group by tgrelid::regclass order by tgrelid::regclass;
-    tgrelid    | count 
----------------+-------
- trg_clone     |     1
- trg_clone1    |     1
- trg_clone2    |     1
- trg_clone3    |     1
- trg_clone_3_3 |     1
-(5 rows)
-
+ERROR:  unsupported comparison operator: tgrelid::REGCLASS IN ('trg_clone', 'trg_clone1', 'trg_clone2', 'trg_clone3', 'trg_clone_3_3'): expected 'trg_clone' to be of type regclass, found type string
 drop table trg_clone;
+ERROR:  relation "trg_clone" does not exist
 -- Test the interaction between ALTER TABLE .. DISABLE TRIGGER and
 -- both kinds of inheritance.  Historically, legacy inheritance has
 -- not recursed to children, so that behavior is preserved.
 create table parent (a int);
 create table child1 () inherits (parent);
+ERROR:  at or near "(": syntax error: unimplemented: this syntax
+DETAIL:  source SQL:
+create table child1 () inherits (parent)
+                                ^
+HINT:  You have attempted to use a feature that is not yet implemented.
+See: https://go.crdb.dev/issue-v/22456/_version_
 create function trig_nothing() returns trigger language plpgsql
   as $$ begin return null; end $$;
 create trigger tg after insert on parent
   for each row execute function trig_nothing();
 create trigger tg after insert on child1
   for each row execute function trig_nothing();
+ERROR:  relation "child1" does not exist
 alter table parent disable trigger tg;
+ERROR:  at or near "trigger": syntax error
+DETAIL:  source SQL:
+alter table parent disable trigger tg
+                           ^
+HINT:  try \h ALTER TABLE
 select tgrelid::regclass, tgname, tgenabled from pg_trigger
   where tgrelid in ('parent'::regclass, 'child1'::regclass)
   order by tgrelid::regclass::text;
- tgrelid | tgname | tgenabled 
----------+--------+-----------
- child1  | tg     | O
- parent  | tg     | D
-(2 rows)
-
+ERROR:  relation "child1" does not exist
 alter table only parent enable always trigger tg;
+ERROR:  at or near "always": syntax error
+DETAIL:  source SQL:
+alter table only parent enable always trigger tg
+                               ^
+HINT:  try \h ALTER TABLE
 select tgrelid::regclass, tgname, tgenabled from pg_trigger
   where tgrelid in ('parent'::regclass, 'child1'::regclass)
   order by tgrelid::regclass::text;
- tgrelid | tgname | tgenabled 
----------+--------+-----------
- child1  | tg     | O
- parent  | tg     | A
-(2 rows)
-
+ERROR:  relation "child1" does not exist
 drop table parent, child1;
+ERROR:  relation "child1" does not exist
 create table parent (a int) partition by list (a);
+ERROR:  at or near "EOF": syntax error
+DETAIL:  source SQL:
+create table parent (a int) partition by list (a)
+                                                 ^
+HINT:  try \h CREATE TABLE
 create table child1 partition of parent for values in (1);
+ERROR:  at or near "partition": syntax error
+DETAIL:  source SQL:
+create table child1 partition of parent for values in (1)
+                    ^
+HINT:  try \h CREATE TABLE
 create trigger tg after insert on parent
   for each row execute procedure trig_nothing();
+ERROR:  trigger "tg" for relation "parent" already exists
 create trigger tg_stmt after insert on parent
   for statement execute procedure trig_nothing();
+ERROR:  unimplemented: statement-level triggers are not yet supported
+HINT:  You have attempted to use a feature that is not yet implemented.
+See: https://go.crdb.dev/issue-v/126362/_version_
 select tgrelid::regclass, tgname, tgenabled from pg_trigger
   where tgrelid in ('parent'::regclass, 'child1'::regclass)
   order by tgrelid::regclass::text, tgname;
- tgrelid | tgname  | tgenabled 
----------+---------+-----------
- child1  | tg      | O
- parent  | tg      | O
- parent  | tg_stmt | O
-(3 rows)
-
+ERROR:  relation "child1" does not exist
 alter table only parent enable always trigger tg;	-- no recursion because ONLY
+ERROR:  at or near "always": syntax error
+DETAIL:  source SQL:
+alter table only parent enable always trigger tg
+                               ^
+HINT:  try \h ALTER TABLE
 alter table parent enable always trigger tg_stmt;	-- no recursion because statement trigger
+ERROR:  at or near "always": syntax error
+DETAIL:  source SQL:
+alter table parent enable always trigger tg_stmt
+                          ^
+HINT:  try \h ALTER TABLE
 select tgrelid::regclass, tgname, tgenabled from pg_trigger
   where tgrelid in ('parent'::regclass, 'child1'::regclass)
   order by tgrelid::regclass::text, tgname;
- tgrelid | tgname  | tgenabled 
----------+---------+-----------
- child1  | tg      | O
- parent  | tg      | A
- parent  | tg_stmt | A
-(3 rows)
-
+ERROR:  relation "child1" does not exist
 -- The following is a no-op for the parent trigger but not so
 -- for the child trigger, so recursion should be applied.
 alter table parent enable always trigger tg;
+ERROR:  at or near "always": syntax error
+DETAIL:  source SQL:
+alter table parent enable always trigger tg
+                          ^
+HINT:  try \h ALTER TABLE
 select tgrelid::regclass, tgname, tgenabled from pg_trigger
   where tgrelid in ('parent'::regclass, 'child1'::regclass)
   order by tgrelid::regclass::text, tgname;
- tgrelid | tgname  | tgenabled 
----------+---------+-----------
- child1  | tg      | A
- parent  | tg      | A
- parent  | tg_stmt | A
-(3 rows)
-
+ERROR:  relation "child1" does not exist
 -- This variant malfunctioned in some releases.
 alter table parent disable trigger user;
+ERROR:  at or near "trigger": syntax error
+DETAIL:  source SQL:
+alter table parent disable trigger user
+                           ^
+HINT:  try \h ALTER TABLE
 select tgrelid::regclass, tgname, tgenabled from pg_trigger
   where tgrelid in ('parent'::regclass, 'child1'::regclass)
   order by tgrelid::regclass::text, tgname;
- tgrelid | tgname  | tgenabled 
----------+---------+-----------
- child1  | tg      | D
- parent  | tg      | D
- parent  | tg_stmt | D
-(3 rows)
-
+ERROR:  relation "child1" does not exist
 drop table parent, child1;
+ERROR:  relation "child1" does not exist
 -- Check processing of foreign key triggers
 create table parent (a int primary key, f int references parent)
   partition by list (a);
+ERROR:  at or near "EOF": syntax error
+DETAIL:  source SQL:
+create table parent (a int primary key, f int references parent)
+  partition by list (a)
+                       ^
+HINT:  try \h CREATE TABLE
 create table child1 partition of parent for values in (1);
+ERROR:  at or near "partition": syntax error
+DETAIL:  source SQL:
+create table child1 partition of parent for values in (1)
+                    ^
+HINT:  try \h CREATE TABLE
 select tgrelid::regclass, rtrim(tgname, '0123456789') as tgname,
   tgfoid::regproc, tgenabled
   from pg_trigger where tgrelid in ('parent'::regclass, 'child1'::regclass)
   order by tgrelid::regclass::text, tgfoid;
- tgrelid |         tgname          |         tgfoid         | tgenabled 
----------+-------------------------+------------------------+-----------
- child1  | RI_ConstraintTrigger_c_ | "RI_FKey_check_ins"    | O
- child1  | RI_ConstraintTrigger_c_ | "RI_FKey_check_upd"    | O
- parent  | RI_ConstraintTrigger_c_ | "RI_FKey_check_ins"    | O
- parent  | RI_ConstraintTrigger_c_ | "RI_FKey_check_upd"    | O
- parent  | RI_ConstraintTrigger_a_ | "RI_FKey_noaction_del" | O
- parent  | RI_ConstraintTrigger_a_ | "RI_FKey_noaction_upd" | O
-(6 rows)
-
+ERROR:  relation "child1" does not exist
 alter table parent disable trigger all;
+ERROR:  at or near "trigger": syntax error
+DETAIL:  source SQL:
+alter table parent disable trigger all
+                           ^
+HINT:  try \h ALTER TABLE
 select tgrelid::regclass, rtrim(tgname, '0123456789') as tgname,
   tgfoid::regproc, tgenabled
   from pg_trigger where tgrelid in ('parent'::regclass, 'child1'::regclass)
   order by tgrelid::regclass::text, tgfoid;
- tgrelid |         tgname          |         tgfoid         | tgenabled 
----------+-------------------------+------------------------+-----------
- child1  | RI_ConstraintTrigger_c_ | "RI_FKey_check_ins"    | D
- child1  | RI_ConstraintTrigger_c_ | "RI_FKey_check_upd"    | D
- parent  | RI_ConstraintTrigger_c_ | "RI_FKey_check_ins"    | D
- parent  | RI_ConstraintTrigger_c_ | "RI_FKey_check_upd"    | D
- parent  | RI_ConstraintTrigger_a_ | "RI_FKey_noaction_del" | D
- parent  | RI_ConstraintTrigger_a_ | "RI_FKey_noaction_upd" | D
-(6 rows)
-
+ERROR:  relation "child1" does not exist
 drop table parent, child1;
+ERROR:  relation "child1" does not exist
 -- Verify that firing state propagates correctly on creation, too
 CREATE TABLE trgfire (i int) PARTITION BY RANGE (i);
+ERROR:  at or near "EOF": syntax error
+DETAIL:  source SQL:
+CREATE TABLE trgfire (i int) PARTITION BY RANGE (i)
+                                                   ^
+HINT:  try \h CREATE TABLE
 CREATE TABLE trgfire1 PARTITION OF trgfire FOR VALUES FROM (1) TO (10);
+ERROR:  at or near "partition": syntax error
+DETAIL:  source SQL:
+CREATE TABLE trgfire1 PARTITION OF trgfire FOR VALUES FROM (1) TO (10)
+                      ^
+HINT:  try \h CREATE TABLE
 CREATE OR REPLACE FUNCTION tgf() RETURNS trigger LANGUAGE plpgsql
   AS $$ begin raise exception 'except'; end $$;
 CREATE TRIGGER tg AFTER INSERT ON trgfire FOR EACH ROW EXECUTE FUNCTION tgf();
+ERROR:  relation "trgfire" does not exist
 INSERT INTO trgfire VALUES (1);
-ERROR:  except
-CONTEXT:  PL/pgSQL function tgf() line 1 at RAISE
+ERROR:  relation "trgfire" does not exist
 ALTER TABLE trgfire DISABLE TRIGGER tg;
+ERROR:  at or near "trigger": syntax error
+DETAIL:  source SQL:
+ALTER TABLE trgfire DISABLE TRIGGER tg
+                            ^
+HINT:  try \h ALTER TABLE
 INSERT INTO trgfire VALUES (1);
+ERROR:  relation "trgfire" does not exist
 CREATE TABLE trgfire2 PARTITION OF trgfire FOR VALUES FROM (10) TO (20);
+ERROR:  at or near "partition": syntax error
+DETAIL:  source SQL:
+CREATE TABLE trgfire2 PARTITION OF trgfire FOR VALUES FROM (10) TO (20)
+                      ^
+HINT:  try \h CREATE TABLE
 INSERT INTO trgfire VALUES (11);
+ERROR:  relation "trgfire" does not exist
 CREATE TABLE trgfire3 (LIKE trgfire);
+ERROR:  relation "trgfire" does not exist
 ALTER TABLE trgfire ATTACH PARTITION trgfire3 FOR VALUES FROM (20) TO (30);
+ERROR:  at or near "attach": syntax error
+DETAIL:  source SQL:
+ALTER TABLE trgfire ATTACH PARTITION trgfire3 FOR VALUES FROM (20) TO (30)
+                    ^
+HINT:  try \h ALTER TABLE
 INSERT INTO trgfire VALUES (21);
+ERROR:  relation "trgfire" does not exist
 CREATE TABLE trgfire4 PARTITION OF trgfire FOR VALUES FROM (30) TO (40) PARTITION BY LIST (i);
+ERROR:  at or near "partition": syntax error
+DETAIL:  source SQL:
+CREATE TABLE trgfire4 PARTITION OF trgfire FOR VALUES FROM (30) TO (40) PARTITION BY LIST (i)
+                      ^
+HINT:  try \h CREATE TABLE
 CREATE TABLE trgfire4_30 PARTITION OF trgfire4 FOR VALUES IN (30);
+ERROR:  at or near "partition": syntax error
+DETAIL:  source SQL:
+CREATE TABLE trgfire4_30 PARTITION OF trgfire4 FOR VALUES IN (30)
+                         ^
+HINT:  try \h CREATE TABLE
 INSERT INTO trgfire VALUES (30);
+ERROR:  relation "trgfire" does not exist
 CREATE TABLE trgfire5 (LIKE trgfire) PARTITION BY LIST (i);
+ERROR:  at or near "EOF": syntax error
+DETAIL:  source SQL:
+CREATE TABLE trgfire5 (LIKE trgfire) PARTITION BY LIST (i)
+                                                          ^
+HINT:  try \h CREATE TABLE
 CREATE TABLE trgfire5_40 PARTITION OF trgfire5 FOR VALUES IN (40);
+ERROR:  at or near "partition": syntax error
+DETAIL:  source SQL:
+CREATE TABLE trgfire5_40 PARTITION OF trgfire5 FOR VALUES IN (40)
+                         ^
+HINT:  try \h CREATE TABLE
 ALTER TABLE trgfire ATTACH PARTITION trgfire5 FOR VALUES FROM (40) TO (50);
+ERROR:  at or near "attach": syntax error
+DETAIL:  source SQL:
+ALTER TABLE trgfire ATTACH PARTITION trgfire5 FOR VALUES FROM (40) TO (50)
+                    ^
+HINT:  try \h ALTER TABLE
 INSERT INTO trgfire VALUES (40);
+ERROR:  relation "trgfire" does not exist
 SELECT tgrelid::regclass, tgenabled FROM pg_trigger
   WHERE tgrelid::regclass IN (SELECT oid from pg_class where relname LIKE 'trgfire%')
   ORDER BY tgrelid::regclass::text;
-   tgrelid   | tgenabled 
--------------+-----------
- trgfire     | D
- trgfire1    | D
- trgfire2    | D
- trgfire3    | D
- trgfire4    | D
- trgfire4_30 | D
- trgfire5    | D
- trgfire5_40 | D
-(8 rows)
+ tgrelid | tgenabled 
+---------+-----------
+(0 rows)
 
 ALTER TABLE trgfire ENABLE TRIGGER tg;
+ERROR:  at or near "trigger": syntax error
+DETAIL:  source SQL:
+ALTER TABLE trgfire ENABLE TRIGGER tg
+                           ^
+HINT:  try \h ALTER TABLE
 INSERT INTO trgfire VALUES (1);
-ERROR:  except
-CONTEXT:  PL/pgSQL function tgf() line 1 at RAISE
+ERROR:  relation "trgfire" does not exist
 INSERT INTO trgfire VALUES (11);
-ERROR:  except
-CONTEXT:  PL/pgSQL function tgf() line 1 at RAISE
+ERROR:  relation "trgfire" does not exist
 INSERT INTO trgfire VALUES (21);
-ERROR:  except
-CONTEXT:  PL/pgSQL function tgf() line 1 at RAISE
+ERROR:  relation "trgfire" does not exist
 INSERT INTO trgfire VALUES (30);
-ERROR:  except
-CONTEXT:  PL/pgSQL function tgf() line 1 at RAISE
+ERROR:  relation "trgfire" does not exist
 INSERT INTO trgfire VALUES (40);
-ERROR:  except
-CONTEXT:  PL/pgSQL function tgf() line 1 at RAISE
+ERROR:  relation "trgfire" does not exist
 DROP TABLE trgfire;
+ERROR:  relation "trgfire" does not exist
 DROP FUNCTION tgf();
 --
 -- Test the interaction between transition tables and both kinds of
@@ -2862,120 +3174,175 @@
 --
 -- set up a partition hierarchy with some different TupleDescriptors
 create table parent (a text, b int) partition by list (a);
+ERROR:  at or near "EOF": syntax error
+DETAIL:  source SQL:
+create table parent (a text, b int) partition by list (a)
+                                                         ^
+HINT:  try \h CREATE TABLE
 -- a child matching parent
 create table child1 partition of parent for values in ('AAA');
+ERROR:  at or near "partition": syntax error
+DETAIL:  source SQL:
+create table child1 partition of parent for values in ('AAA')
+                    ^
+HINT:  try \h CREATE TABLE
 -- a child with a dropped column
 create table child2 (x int, a text, b int);
 alter table child2 drop column x;
 alter table parent attach partition child2 for values in ('BBB');
+ERROR:  at or near "attach": syntax error
+DETAIL:  source SQL:
+alter table parent attach partition child2 for values in ('BBB')
+                   ^
+HINT:  try \h ALTER TABLE
 -- a child with a different column order
 create table child3 (b int, a text);
 alter table parent attach partition child3 for values in ('CCC');
+ERROR:  at or near "attach": syntax error
+DETAIL:  source SQL:
+alter table parent attach partition child3 for values in ('CCC')
+                   ^
+HINT:  try \h ALTER TABLE
 create trigger parent_insert_trig
   after insert on parent referencing new table as new_table
   for each statement execute procedure dump_insert();
+ERROR:  unimplemented: statement-level triggers are not yet supported
+HINT:  You have attempted to use a feature that is not yet implemented.
+See: https://go.crdb.dev/issue-v/126362/_version_
 create trigger parent_update_trig
   after update on parent referencing old table as old_table new table as new_table
   for each statement execute procedure dump_update();
+ERROR:  unimplemented: statement-level triggers are not yet supported
+HINT:  You have attempted to use a feature that is not yet implemented.
+See: https://go.crdb.dev/issue-v/126362/_version_
 create trigger parent_delete_trig
   after delete on parent referencing old table as old_table
   for each statement execute procedure dump_delete();
+ERROR:  unimplemented: statement-level triggers are not yet supported
+HINT:  You have attempted to use a feature that is not yet implemented.
+See: https://go.crdb.dev/issue-v/126362/_version_
 create trigger child1_insert_trig
   after insert on child1 referencing new table as new_table
   for each statement execute procedure dump_insert();
+ERROR:  relation "child1" does not exist
 create trigger child1_update_trig
   after update on child1 referencing old table as old_table new table as new_table
   for each statement execute procedure dump_update();
+ERROR:  relation "child1" does not exist
 create trigger child1_delete_trig
   after delete on child1 referencing old table as old_table
   for each statement execute procedure dump_delete();
+ERROR:  relation "child1" does not exist
 create trigger child2_insert_trig
   after insert on child2 referencing new table as new_table
   for each statement execute procedure dump_insert();
+ERROR:  unimplemented: statement-level triggers are not yet supported
+HINT:  You have attempted to use a feature that is not yet implemented.
+See: https://go.crdb.dev/issue-v/126362/_version_
 create trigger child2_update_trig
   after update on child2 referencing old table as old_table new table as new_table
   for each statement execute procedure dump_update();
+ERROR:  unimplemented: statement-level triggers are not yet supported
+HINT:  You have attempted to use a feature that is not yet implemented.
+See: https://go.crdb.dev/issue-v/126362/_version_
 create trigger child2_delete_trig
   after delete on child2 referencing old table as old_table
   for each statement execute procedure dump_delete();
+ERROR:  unimplemented: statement-level triggers are not yet supported
+HINT:  You have attempted to use a feature that is not yet implemented.
+See: https://go.crdb.dev/issue-v/126362/_version_
 create trigger child3_insert_trig
   after insert on child3 referencing new table as new_table
   for each statement execute procedure dump_insert();
+ERROR:  unimplemented: statement-level triggers are not yet supported
+HINT:  You have attempted to use a feature that is not yet implemented.
+See: https://go.crdb.dev/issue-v/126362/_version_
 create trigger child3_update_trig
   after update on child3 referencing old table as old_table new table as new_table
   for each statement execute procedure dump_update();
+ERROR:  unimplemented: statement-level triggers are not yet supported
+HINT:  You have attempted to use a feature that is not yet implemented.
+See: https://go.crdb.dev/issue-v/126362/_version_
 create trigger child3_delete_trig
   after delete on child3 referencing old table as old_table
   for each statement execute procedure dump_delete();
+ERROR:  unimplemented: statement-level triggers are not yet supported
+HINT:  You have attempted to use a feature that is not yet implemented.
+See: https://go.crdb.dev/issue-v/126362/_version_
 SELECT trigger_name, event_manipulation, event_object_schema, event_object_table,
        action_order, action_condition, action_orientation, action_timing,
        action_reference_old_table, action_reference_new_table
   FROM information_schema.triggers
   WHERE event_object_table IN ('parent', 'child1', 'child2', 'child3')
   ORDER BY trigger_name COLLATE "C", 2;
-    trigger_name    | event_manipulation | event_object_schema | event_object_table | action_order | action_condition | action_orientation | action_timing | action_reference_old_table | action_reference_new_table 
---------------------+--------------------+---------------------+--------------------+--------------+------------------+--------------------+---------------+----------------------------+----------------------------
- child1_delete_trig | DELETE             | public              | child1             |            1 |                  | STATEMENT          | AFTER         | old_table                  | 
- child1_insert_trig | INSERT             | public              | child1             |            1 |                  | STATEMENT          | AFTER         |                            | new_table
- child1_update_trig | UPDATE             | public              | child1             |            1 |                  | STATEMENT          | AFTER         | old_table                  | new_table
- child2_delete_trig | DELETE             | public              | child2             |            1 |                  | STATEMENT          | AFTER         | old_table                  | 
- child2_insert_trig | INSERT             | public              | child2             |            1 |                  | STATEMENT          | AFTER         |                            | new_table
- child2_update_trig | UPDATE             | public              | child2             |            1 |                  | STATEMENT          | AFTER         | old_table                  | new_table
- child3_delete_trig | DELETE             | public              | child3             |            1 |                  | STATEMENT          | AFTER         | old_table                  | 
- child3_insert_trig | INSERT             | public              | child3             |            1 |                  | STATEMENT          | AFTER         |                            | new_table
- child3_update_trig | UPDATE             | public              | child3             |            1 |                  | STATEMENT          | AFTER         | old_table                  | new_table
- parent_delete_trig | DELETE             | public              | parent             |            1 |                  | STATEMENT          | AFTER         | old_table                  | 
- parent_insert_trig | INSERT             | public              | parent             |            1 |                  | STATEMENT          | AFTER         |                            | new_table
- parent_update_trig | UPDATE             | public              | parent             |            1 |                  | STATEMENT          | AFTER         | old_table                  | new_table
-(12 rows)
+ trigger_name | event_manipulation | event_object_schema | event_object_table | action_order | action_condition | action_orientation | action_timing | action_reference_old_table | action_reference_new_table 
+--------------+--------------------+---------------------+--------------------+--------------+------------------+--------------------+---------------+----------------------------+----------------------------
+ tg           | INSERT             | public              | parent             |              |                  | ROW                | AFTER         |                            | 
+(1 row)
 
 -- insert directly into children sees respective child-format tuples
 insert into child1 values ('AAA', 42);
-NOTICE:  trigger = child1_insert_trig, new table = (AAA,42)
+ERROR:  relation "child1" does not exist
 insert into child2 values ('BBB', 42);
-NOTICE:  trigger = child2_insert_trig, new table = (BBB,42)
 insert into child3 values (42, 'CCC');
-NOTICE:  trigger = child3_insert_trig, new table = (42,CCC)
 -- update via parent sees parent-format tuples
 update parent set b = b + 1;
-NOTICE:  trigger = parent_update_trig, old table = (AAA,42), (BBB,42), (CCC,42), new table = (AAA,43), (BBB,43), (CCC,43)
+ERROR:  column "b" does not exist
 -- delete via parent sees parent-format tuples
 delete from parent;
-NOTICE:  trigger = parent_delete_trig, old table = (AAA,43), (BBB,43), (CCC,43)
 -- insert into parent sees parent-format tuples
 insert into parent values ('AAA', 42);
-NOTICE:  trigger = parent_insert_trig, new table = (AAA,42)
+ERROR:  INSERT has more expressions than target columns, 2 expressions for 1 targets
 insert into parent values ('BBB', 42);
-NOTICE:  trigger = parent_insert_trig, new table = (BBB,42)
+ERROR:  INSERT has more expressions than target columns, 2 expressions for 1 targets
 insert into parent values ('CCC', 42);
-NOTICE:  trigger = parent_insert_trig, new table = (CCC,42)
+ERROR:  INSERT has more expressions than target columns, 2 expressions for 1 targets
 -- delete from children sees respective child-format tuples
 delete from child1;
-NOTICE:  trigger = child1_delete_trig, old table = (AAA,42)
+ERROR:  relation "child1" does not exist
 delete from child2;
-NOTICE:  trigger = child2_delete_trig, old table = (BBB,42)
 delete from child3;
-NOTICE:  trigger = child3_delete_trig, old table = (42,CCC)
 -- copy into parent sees parent-format tuples
 copy parent (a, b) from stdin;
-NOTICE:  trigger = parent_insert_trig, new table = (AAA,42), (BBB,42), (CCC,42)
+ERROR:  column "b" does not exist
+AAA	42
+BBB	42
+CCC	42
+\.
+invalid command \.
 -- DML affecting parent sees tuples collected from children even if
 -- there is no transition table trigger on the children
 drop trigger child1_insert_trig on child1;
+ERROR:  at or near "aaa": syntax error
+DETAIL:  source SQL:
+AAA	42
+^
 drop trigger child1_update_trig on child1;
+ERROR:  relation "child1" does not exist
 drop trigger child1_delete_trig on child1;
+ERROR:  relation "child1" does not exist
 drop trigger child2_insert_trig on child2;
+ERROR:  trigger "child2_insert_trig" for table "child2" does not exist
 drop trigger child2_update_trig on child2;
+ERROR:  trigger "child2_update_trig" for table "child2" does not exist
 drop trigger child2_delete_trig on child2;
+ERROR:  trigger "child2_delete_trig" for table "child2" does not exist
 drop trigger child3_insert_trig on child3;
+ERROR:  trigger "child3_insert_trig" for table "child3" does not exist
 drop trigger child3_update_trig on child3;
+ERROR:  trigger "child3_update_trig" for table "child3" does not exist
 drop trigger child3_delete_trig on child3;
+ERROR:  trigger "child3_delete_trig" for table "child3" does not exist
 delete from parent;
-NOTICE:  trigger = parent_delete_trig, old table = (AAA,42), (BBB,42), (CCC,42)
 -- copy into parent sees tuples collected from children even if there
 -- is no transition-table trigger on the children
 copy parent (a, b) from stdin;
-NOTICE:  trigger = parent_insert_trig, new table = (AAA,42), (BBB,42), (CCC,42)
+ERROR:  column "b" does not exist
+AAA	42
+BBB	42
+CCC	42
+\.
+invalid command \.
 -- insert into parent with a before trigger on a child tuple before
 -- insertion, and we capture the newly modified row in parent format
 create or replace function intercept_insert() returns trigger language plpgsql as
@@ -2985,41 +3352,82 @@
     return new;
   end;
 $$;
+ERROR:  at or near "aaa": syntax error
+DETAIL:  source SQL:
+AAA	42
+^
 create trigger intercept_insert_child3
   before insert on child3
   for each row execute procedure intercept_insert();
+ERROR:  unknown function: intercept_insert()
 -- insert, parent trigger sees post-modification parent-format tuple
 insert into parent values ('AAA', 42), ('BBB', 42), ('CCC', 66);
-NOTICE:  trigger = parent_insert_trig, new table = (AAA,42), (BBB,42), (CCC,1066)
+ERROR:  INSERT has more expressions than target columns, 2 expressions for 1 targets
 -- copy, parent trigger sees post-modification parent-format tuple
 copy parent (a, b) from stdin;
-NOTICE:  trigger = parent_insert_trig, new table = (AAA,42), (BBB,42), (CCC,1234)
+ERROR:  column "b" does not exist
+AAA	42
+BBB	42
+CCC	234
+\.
+invalid command \.
 drop table child1, child2, child3, parent;
+ERROR:  at or near "aaa": syntax error
+DETAIL:  source SQL:
+AAA	42
+^
 drop function intercept_insert();
+ERROR:  unknown function: intercept_insert()
 --
 -- Verify prohibition of row triggers with transition triggers on
 -- partitions
 --
 create table parent (a text, b int) partition by list (a);
+ERROR:  at or near "EOF": syntax error
+DETAIL:  source SQL:
+create table parent (a text, b int) partition by list (a)
+                                                         ^
+HINT:  try \h CREATE TABLE
 create table child partition of parent for values in ('AAA');
+ERROR:  at or near "partition": syntax error
+DETAIL:  source SQL:
+create table child partition of parent for values in ('AAA')
+                   ^
+HINT:  try \h CREATE TABLE
 -- adding row trigger with transition table fails
 create trigger child_row_trig
   after insert on child referencing new table as new_table
   for each row execute procedure dump_insert();
-ERROR:  ROW triggers with transition tables are not supported on partitions
+ERROR:  relation "child" does not exist
 -- detaching it first works
 alter table parent detach partition child;
+ERROR:  at or near "detach": syntax error
+DETAIL:  source SQL:
+alter table parent detach partition child
+                   ^
+HINT:  try \h ALTER TABLE
 create trigger child_row_trig
   after insert on child referencing new table as new_table
   for each row execute procedure dump_insert();
+ERROR:  relation "child" does not exist
 -- but now we're not allowed to reattach it
 alter table parent attach partition child for values in ('AAA');
-ERROR:  trigger "child_row_trig" prevents table "child" from becoming a partition
-DETAIL:  ROW triggers with transition tables are not supported on partitions.
+ERROR:  at or near "attach": syntax error
+DETAIL:  source SQL:
+alter table parent attach partition child for values in ('AAA')
+                   ^
+HINT:  try \h ALTER TABLE
 -- drop the trigger, and now we're allowed to attach it again
 drop trigger child_row_trig on child;
+ERROR:  relation "child" does not exist
 alter table parent attach partition child for values in ('AAA');
+ERROR:  at or near "attach": syntax error
+DETAIL:  source SQL:
+alter table parent attach partition child for values in ('AAA')
+                   ^
+HINT:  try \h ALTER TABLE
 drop table child, parent;
+ERROR:  relation "child" does not exist
 --
 -- Verify behavior of statement triggers on (non-partition)
 -- inheritance hierarchy with transition tables; similar to the
@@ -3028,123 +3436,216 @@
 --
 -- set up inheritance hierarchy with different TupleDescriptors
 create table parent (a text, b int);
+ERROR:  relation "root.public.parent" already exists
 -- a child matching parent
 create table child1 () inherits (parent);
+ERROR:  at or near "(": syntax error: unimplemented: this syntax
+DETAIL:  source SQL:
+create table child1 () inherits (parent)
+                                ^
+HINT:  You have attempted to use a feature that is not yet implemented.
+See: https://go.crdb.dev/issue-v/22456/_version_
 -- a child with a different column order
 create table child2 (b int, a text);
+ERROR:  relation "root.public.child2" already exists
 alter table child2 inherit parent;
+ERROR:  at or near "inherit": syntax error
+DETAIL:  source SQL:
+alter table child2 inherit parent
+                   ^
+HINT:  try \h ALTER TABLE
 -- a child with an extra column
 create table child3 (c text) inherits (parent);
+ERROR:  at or near "(": syntax error: unimplemented: this syntax
+DETAIL:  source SQL:
+create table child3 (c text) inherits (parent)
+                                      ^
+HINT:  You have attempted to use a feature that is not yet implemented.
+See: https://go.crdb.dev/issue-v/22456/_version_
 create trigger parent_insert_trig
   after insert on parent referencing new table as new_table
   for each statement execute procedure dump_insert();
+ERROR:  unimplemented: statement-level triggers are not yet supported
+HINT:  You have attempted to use a feature that is not yet implemented.
+See: https://go.crdb.dev/issue-v/126362/_version_
 create trigger parent_update_trig
   after update on parent referencing old table as old_table new table as new_table
   for each statement execute procedure dump_update();
+ERROR:  unimplemented: statement-level triggers are not yet supported
+HINT:  You have attempted to use a feature that is not yet implemented.
+See: https://go.crdb.dev/issue-v/126362/_version_
 create trigger parent_delete_trig
   after delete on parent referencing old table as old_table
   for each statement execute procedure dump_delete();
+ERROR:  unimplemented: statement-level triggers are not yet supported
+HINT:  You have attempted to use a feature that is not yet implemented.
+See: https://go.crdb.dev/issue-v/126362/_version_
 create trigger child1_insert_trig
   after insert on child1 referencing new table as new_table
   for each statement execute procedure dump_insert();
+ERROR:  relation "child1" does not exist
 create trigger child1_update_trig
   after update on child1 referencing old table as old_table new table as new_table
   for each statement execute procedure dump_update();
+ERROR:  relation "child1" does not exist
 create trigger child1_delete_trig
   after delete on child1 referencing old table as old_table
   for each statement execute procedure dump_delete();
+ERROR:  relation "child1" does not exist
 create trigger child2_insert_trig
   after insert on child2 referencing new table as new_table
   for each statement execute procedure dump_insert();
+ERROR:  unimplemented: statement-level triggers are not yet supported
+HINT:  You have attempted to use a feature that is not yet implemented.
+See: https://go.crdb.dev/issue-v/126362/_version_
 create trigger child2_update_trig
   after update on child2 referencing old table as old_table new table as new_table
   for each statement execute procedure dump_update();
+ERROR:  unimplemented: statement-level triggers are not yet supported
+HINT:  You have attempted to use a feature that is not yet implemented.
+See: https://go.crdb.dev/issue-v/126362/_version_
 create trigger child2_delete_trig
   after delete on child2 referencing old table as old_table
   for each statement execute procedure dump_delete();
+ERROR:  unimplemented: statement-level triggers are not yet supported
+HINT:  You have attempted to use a feature that is not yet implemented.
+See: https://go.crdb.dev/issue-v/126362/_version_
 create trigger child3_insert_trig
   after insert on child3 referencing new table as new_table
   for each statement execute procedure dump_insert();
+ERROR:  unimplemented: statement-level triggers are not yet supported
+HINT:  You have attempted to use a feature that is not yet implemented.
+See: https://go.crdb.dev/issue-v/126362/_version_
 create trigger child3_update_trig
   after update on child3 referencing old table as old_table new table as new_table
   for each statement execute procedure dump_update();
+ERROR:  unimplemented: statement-level triggers are not yet supported
+HINT:  You have attempted to use a feature that is not yet implemented.
+See: https://go.crdb.dev/issue-v/126362/_version_
 create trigger child3_delete_trig
   after delete on child3 referencing old table as old_table
   for each statement execute procedure dump_delete();
+ERROR:  unimplemented: statement-level triggers are not yet supported
+HINT:  You have attempted to use a feature that is not yet implemented.
+See: https://go.crdb.dev/issue-v/126362/_version_
 -- insert directly into children sees respective child-format tuples
 insert into child1 values ('AAA', 42);
-NOTICE:  trigger = child1_insert_trig, new table = (AAA,42)
+ERROR:  relation "child1" does not exist
 insert into child2 values (42, 'BBB');
-NOTICE:  trigger = child2_insert_trig, new table = (42,BBB)
+ERROR:  could not parse "BBB" as type int: strconv.ParseInt: parsing "BBB": invalid syntax
 insert into child3 values ('CCC', 42, 'foo');
-NOTICE:  trigger = child3_insert_trig, new table = (CCC,42,foo)
+ERROR:  INSERT has more expressions than target columns, 3 expressions for 2 targets
 -- update via parent sees parent-format tuples
 update parent set b = b + 1;
-NOTICE:  trigger = parent_update_trig, old table = (AAA,42), (BBB,42), (CCC,42), new table = (AAA,43), (BBB,43), (CCC,43)
+ERROR:  column "b" does not exist
 -- delete via parent sees parent-format tuples
 delete from parent;
-NOTICE:  trigger = parent_delete_trig, old table = (AAA,43), (BBB,43), (CCC,43)
 -- reinsert values into children for next test...
 insert into child1 values ('AAA', 42);
-NOTICE:  trigger = child1_insert_trig, new table = (AAA,42)
+ERROR:  relation "child1" does not exist
 insert into child2 values (42, 'BBB');
-NOTICE:  trigger = child2_insert_trig, new table = (42,BBB)
+ERROR:  could not parse "BBB" as type int: strconv.ParseInt: parsing "BBB": invalid syntax
 insert into child3 values ('CCC', 42, 'foo');
-NOTICE:  trigger = child3_insert_trig, new table = (CCC,42,foo)
+ERROR:  INSERT has more expressions than target columns, 3 expressions for 2 targets
 -- delete from children sees respective child-format tuples
 delete from child1;
-NOTICE:  trigger = child1_delete_trig, old table = (AAA,42)
+ERROR:  relation "child1" does not exist
 delete from child2;
-NOTICE:  trigger = child2_delete_trig, old table = (42,BBB)
 delete from child3;
-NOTICE:  trigger = child3_delete_trig, old table = (CCC,42,foo)
 -- copy into parent sees parent-format tuples (no rerouting, so these
 -- are really inserted into the parent)
 copy parent (a, b) from stdin;
-NOTICE:  trigger = parent_insert_trig, new table = (AAA,42), (BBB,42), (CCC,42)
+ERROR:  column "b" does not exist
+AAA	42
+BBB	42
+CCC	42
+\.
+invalid command \.
 -- same behavior for copy if there is an index (interesting because rows are
 -- captured by a different code path in copyfrom.c if there are indexes)
 create index on parent(b);
+ERROR:  at or near "aaa": syntax error
+DETAIL:  source SQL:
+AAA	42
+^
 copy parent (a, b) from stdin;
-NOTICE:  trigger = parent_insert_trig, new table = (DDD,42)
+ERROR:  column "b" does not exist
+DDD	42
+\.
+invalid command \.
 -- DML affecting parent sees tuples collected from children even if
 -- there is no transition table trigger on the children
 drop trigger child1_insert_trig on child1;
+ERROR:  at or near "ddd": syntax error
+DETAIL:  source SQL:
+DDD	42
+^
 drop trigger child1_update_trig on child1;
+ERROR:  relation "child1" does not exist
 drop trigger child1_delete_trig on child1;
+ERROR:  relation "child1" does not exist
 drop trigger child2_insert_trig on child2;
+ERROR:  trigger "child2_insert_trig" for table "child2" does not exist
 drop trigger child2_update_trig on child2;
+ERROR:  trigger "child2_update_trig" for table "child2" does not exist
 drop trigger child2_delete_trig on child2;
+ERROR:  trigger "child2_delete_trig" for table "child2" does not exist
 drop trigger child3_insert_trig on child3;
+ERROR:  trigger "child3_insert_trig" for table "child3" does not exist
 drop trigger child3_update_trig on child3;
+ERROR:  trigger "child3_update_trig" for table "child3" does not exist
 drop trigger child3_delete_trig on child3;
+ERROR:  trigger "child3_delete_trig" for table "child3" does not exist
 delete from parent;
-NOTICE:  trigger = parent_delete_trig, old table = (AAA,42), (BBB,42), (CCC,42), (DDD,42)
 drop table child1, child2, child3, parent;
+ERROR:  relation "child1" does not exist
 --
 -- Verify prohibition of row triggers with transition triggers on
 -- inheritance children
 --
 create table parent (a text, b int);
+ERROR:  relation "root.public.parent" already exists
 create table child () inherits (parent);
+ERROR:  at or near "(": syntax error: unimplemented: this syntax
+DETAIL:  source SQL:
+create table child () inherits (parent)
+                               ^
+HINT:  You have attempted to use a feature that is not yet implemented.
+See: https://go.crdb.dev/issue-v/22456/_version_
 -- adding row trigger with transition table fails
 create trigger child_row_trig
   after insert on child referencing new table as new_table
   for each row execute procedure dump_insert();
-ERROR:  ROW triggers with transition tables are not supported on inheritance children
+ERROR:  relation "child" does not exist
 -- disinheriting it first works
 alter table child no inherit parent;
+ERROR:  at or near "inherit": syntax error
+DETAIL:  source SQL:
+alter table child no inherit parent
+                     ^
+HINT:  try \h ALTER TABLE
 create trigger child_row_trig
   after insert on child referencing new table as new_table
   for each row execute procedure dump_insert();
+ERROR:  relation "child" does not exist
 -- but now we're not allowed to make it inherit anymore
 alter table child inherit parent;
-ERROR:  trigger "child_row_trig" prevents table "child" from becoming an inheritance child
-DETAIL:  ROW triggers with transition tables are not supported in inheritance hierarchies.
+ERROR:  at or near "inherit": syntax error
+DETAIL:  source SQL:
+alter table child inherit parent
+                  ^
+HINT:  try \h ALTER TABLE
 -- drop the trigger, and now we're allowed to make it inherit again
 drop trigger child_row_trig on child;
+ERROR:  relation "child" does not exist
 alter table child inherit parent;
+ERROR:  at or near "inherit": syntax error
+DETAIL:  source SQL:
+alter table child inherit parent
+                  ^
+HINT:  try \h ALTER TABLE
 drop table child, parent;
+ERROR:  relation "child" does not exist
 --
 -- Verify behavior of queries with wCTEs, where multiple transition
 -- tuplestores can be active at the same time because there are
@@ -3156,29 +3657,32 @@
 create trigger table1_trig
   after insert on table1 referencing new table as new_table
   for each statement execute procedure dump_insert();
+ERROR:  unimplemented: statement-level triggers are not yet supported
+HINT:  You have attempted to use a feature that is not yet implemented.
+See: https://go.crdb.dev/issue-v/126362/_version_
 create trigger table2_trig
   after insert on table2 referencing new table as new_table
   for each statement execute procedure dump_insert();
+ERROR:  unimplemented: statement-level triggers are not yet supported
+HINT:  You have attempted to use a feature that is not yet implemented.
+See: https://go.crdb.dev/issue-v/126362/_version_
 with wcte as (insert into table1 values (42))
   insert into table2 values ('hello world');
-NOTICE:  trigger = table2_trig, new table = ("hello world")
-NOTICE:  trigger = table1_trig, new table = (42)
+ERROR:  WITH clause "wcte" does not return any columns
+HINT:  missing RETURNING clause?
 with wcte as (insert into table1 values (43))
   insert into table1 values (44);
-NOTICE:  trigger = table1_trig, new table = (43), (44)
+ERROR:  WITH clause "wcte" does not return any columns
+HINT:  missing RETURNING clause?
 select * from table1;
- a  
-----
- 42
- 44
- 43
-(3 rows)
+ a 
+---
+(0 rows)
 
 select * from table2;
-      a      
--------------
- hello world
-(1 row)
+ a 
+---
+(0 rows)
 
 drop table table1;
 drop table table2;
@@ -3190,60 +3694,85 @@
 create trigger my_table_insert_trig
   after insert on my_table referencing new table as new_table
   for each statement execute procedure dump_insert();
+ERROR:  unimplemented: statement-level triggers are not yet supported
+HINT:  You have attempted to use a feature that is not yet implemented.
+See: https://go.crdb.dev/issue-v/126362/_version_
 create trigger my_table_update_trig
   after update on my_table referencing old table as old_table new table as new_table
   for each statement execute procedure dump_update();
+ERROR:  unimplemented: statement-level triggers are not yet supported
+HINT:  You have attempted to use a feature that is not yet implemented.
+See: https://go.crdb.dev/issue-v/126362/_version_
 -- inserts only
 insert into my_table values (1, 'AAA'), (2, 'BBB')
   on conflict (a) do
   update set b = my_table.b || ':' || excluded.b;
-NOTICE:  trigger = my_table_update_trig, old table = <NULL>, new table = <NULL>
-NOTICE:  trigger = my_table_insert_trig, new table = (1,AAA), (2,BBB)
 -- mixture of inserts and updates
 insert into my_table values (1, 'AAA'), (2, 'BBB'), (3, 'CCC'), (4, 'DDD')
   on conflict (a) do
   update set b = my_table.b || ':' || excluded.b;
-NOTICE:  trigger = my_table_update_trig, old table = (1,AAA), (2,BBB), new table = (1,AAA:AAA), (2,BBB:BBB)
-NOTICE:  trigger = my_table_insert_trig, new table = (3,CCC), (4,DDD)
 -- updates only
 insert into my_table values (3, 'CCC'), (4, 'DDD')
   on conflict (a) do
   update set b = my_table.b || ':' || excluded.b;
-NOTICE:  trigger = my_table_update_trig, old table = (3,CCC), (4,DDD), new table = (3,CCC:CCC), (4,DDD:DDD)
-NOTICE:  trigger = my_table_insert_trig, new table = <NULL>
 --
 -- now using a partitioned table
 --
 create table iocdu_tt_parted (a int primary key, b text) partition by list (a);
+ERROR:  at or near "EOF": syntax error
+DETAIL:  source SQL:
+create table iocdu_tt_parted (a int primary key, b text) partition by list (a)
+                                                                              ^
+HINT:  try \h CREATE TABLE
 create table iocdu_tt_parted1 partition of iocdu_tt_parted for values in (1);
+ERROR:  at or near "partition": syntax error
+DETAIL:  source SQL:
+create table iocdu_tt_parted1 partition of iocdu_tt_parted for values in (1)
+                              ^
+HINT:  try \h CREATE TABLE
 create table iocdu_tt_parted2 partition of iocdu_tt_parted for values in (2);
+ERROR:  at or near "partition": syntax error
+DETAIL:  source SQL:
+create table iocdu_tt_parted2 partition of iocdu_tt_parted for values in (2)
+                              ^
+HINT:  try \h CREATE TABLE
 create table iocdu_tt_parted3 partition of iocdu_tt_parted for values in (3);
+ERROR:  at or near "partition": syntax error
+DETAIL:  source SQL:
+create table iocdu_tt_parted3 partition of iocdu_tt_parted for values in (3)
+                              ^
+HINT:  try \h CREATE TABLE
 create table iocdu_tt_parted4 partition of iocdu_tt_parted for values in (4);
+ERROR:  at or near "partition": syntax error
+DETAIL:  source SQL:
+create table iocdu_tt_parted4 partition of iocdu_tt_parted for values in (4)
+                              ^
+HINT:  try \h CREATE TABLE
 create trigger iocdu_tt_parted_insert_trig
   after insert on iocdu_tt_parted referencing new table as new_table
   for each statement execute procedure dump_insert();
+ERROR:  relation "iocdu_tt_parted" does not exist
 create trigger iocdu_tt_parted_update_trig
   after update on iocdu_tt_parted referencing old table as old_table new table as new_table
   for each statement execute procedure dump_update();
+ERROR:  relation "iocdu_tt_parted" does not exist
 -- inserts only
 insert into iocdu_tt_parted values (1, 'AAA'), (2, 'BBB')
   on conflict (a) do
   update set b = iocdu_tt_parted.b || ':' || excluded.b;
-NOTICE:  trigger = iocdu_tt_parted_update_trig, old table = <NULL>, new table = <NULL>
-NOTICE:  trigger = iocdu_tt_parted_insert_trig, new table = (1,AAA), (2,BBB)
+ERROR:  relation "iocdu_tt_parted" does not exist
 -- mixture of inserts and updates
 insert into iocdu_tt_parted values (1, 'AAA'), (2, 'BBB'), (3, 'CCC'), (4, 'DDD')
   on conflict (a) do
   update set b = iocdu_tt_parted.b || ':' || excluded.b;
-NOTICE:  trigger = iocdu_tt_parted_update_trig, old table = (1,AAA), (2,BBB), new table = (1,AAA:AAA), (2,BBB:BBB)
-NOTICE:  trigger = iocdu_tt_parted_insert_trig, new table = (3,CCC), (4,DDD)
+ERROR:  relation "iocdu_tt_parted" does not exist
 -- updates only
 insert into iocdu_tt_parted values (3, 'CCC'), (4, 'DDD')
   on conflict (a) do
   update set b = iocdu_tt_parted.b || ':' || excluded.b;
-NOTICE:  trigger = iocdu_tt_parted_update_trig, old table = (3,CCC), (4,DDD), new table = (3,CCC:CCC), (4,DDD:DDD)
-NOTICE:  trigger = iocdu_tt_parted_insert_trig, new table = <NULL>
+ERROR:  relation "iocdu_tt_parted" does not exist
 drop table iocdu_tt_parted;
+ERROR:  relation "iocdu_tt_parted" does not exist
 --
 -- Verify that you can't create a trigger with transition tables for
 -- more than one event.
@@ -3271,15 +3800,27 @@
 create trigger trig_table_before_trig
   before insert or update or delete on trig_table
   for each statement execute procedure trigger_func('trig_table');
+ERROR:  unimplemented: statement-level triggers are not yet supported
+HINT:  You have attempted to use a feature that is not yet implemented.
+See: https://go.crdb.dev/issue-v/126362/_version_
 create trigger trig_table_insert_trig
   after insert on trig_table referencing new table as new_table
   for each statement execute procedure dump_insert();
+ERROR:  unimplemented: statement-level triggers are not yet supported
+HINT:  You have attempted to use a feature that is not yet implemented.
+See: https://go.crdb.dev/issue-v/126362/_version_
 create trigger trig_table_update_trig
   after update on trig_table referencing old table as old_table new table as new_table
   for each statement execute procedure dump_update();
+ERROR:  unimplemented: statement-level triggers are not yet supported
+HINT:  You have attempted to use a feature that is not yet implemented.
+See: https://go.crdb.dev/issue-v/126362/_version_
 create trigger trig_table_delete_trig
   after delete on trig_table referencing old table as old_table
   for each statement execute procedure dump_delete();
+ERROR:  unimplemented: statement-level triggers are not yet supported
+HINT:  You have attempted to use a feature that is not yet implemented.
+See: https://go.crdb.dev/issue-v/126362/_version_
 insert into refd_table values
   (1, 'one'),
   (2, 'two'),
@@ -3291,25 +3832,19 @@
   (2, 'two b'),
   (3, 'three a'),
   (3, 'three b');
-NOTICE:  trigger_func(trig_table) called: action = INSERT, when = BEFORE, level = STATEMENT
-NOTICE:  trigger = trig_table_insert_trig, new table = (1,"one a"), (1,"one b"), (2,"two a"), (2,"two b"), (3,"three a"), (3,"three b")
 update refd_table set a = 11 where b = 'one';
-NOTICE:  trigger_func(trig_table) called: action = UPDATE, when = BEFORE, level = STATEMENT
-NOTICE:  trigger = trig_table_update_trig, old table = (1,"one a"), (1,"one b"), new table = (11,"one a"), (11,"one b")
 select * from trig_table;
  a  |    b    
 ----+---------
+ 11 | one a
+ 11 | one b
   2 | two a
   2 | two b
   3 | three a
   3 | three b
- 11 | one a
- 11 | one b
 (6 rows)
 
 delete from refd_table where length(b) = 3;
-NOTICE:  trigger_func(trig_table) called: action = DELETE, when = BEFORE, level = STATEMENT
-NOTICE:  trigger = trig_table_delete_trig, old table = (2,"two a"), (2,"two b"), (11,"one a"), (11,"one b")
 select * from trig_table;
  a |    b    
 ---+---------
@@ -3326,27 +3861,28 @@
 create trigger self_ref_before_trig
   before delete on self_ref
   for each statement execute procedure trigger_func('self_ref');
+ERROR:  unimplemented: statement-level triggers are not yet supported
+HINT:  You have attempted to use a feature that is not yet implemented.
+See: https://go.crdb.dev/issue-v/126362/_version_
 create trigger self_ref_r_trig
   after delete on self_ref referencing old table as old_table
   for each row execute procedure dump_delete();
+ERROR:  unimplemented: REFERENCING clause is not yet supported for triggers
+HINT:  You have attempted to use a feature that is not yet implemented.
+See: https://go.crdb.dev/issue-v/135655/_version_
 create trigger self_ref_s_trig
   after delete on self_ref referencing old table as old_table
   for each statement execute procedure dump_delete();
+ERROR:  unimplemented: statement-level triggers are not yet supported
+HINT:  You have attempted to use a feature that is not yet implemented.
+See: https://go.crdb.dev/issue-v/126362/_version_
 insert into self_ref values (1, null), (2, 1), (3, 2);
 delete from self_ref where a = 1;
-NOTICE:  trigger_func(self_ref) called: action = DELETE, when = BEFORE, level = STATEMENT
-NOTICE:  trigger = self_ref_r_trig, old table = (1,), (2,1)
-NOTICE:  trigger_func(self_ref) called: action = DELETE, when = BEFORE, level = STATEMENT
-NOTICE:  trigger = self_ref_r_trig, old table = (1,), (2,1)
-NOTICE:  trigger = self_ref_s_trig, old table = (1,), (2,1)
-NOTICE:  trigger = self_ref_r_trig, old table = (3,2)
-NOTICE:  trigger = self_ref_s_trig, old table = (3,2)
 -- without AR trigger, cascaded deletes all end up in one transition table
 drop trigger self_ref_r_trig on self_ref;
+ERROR:  trigger "self_ref_r_trig" for table "self_ref" does not exist
 insert into self_ref values (1, null), (2, 1), (3, 2), (4, 3);
 delete from self_ref where a = 1;
-NOTICE:  trigger_func(self_ref) called: action = DELETE, when = BEFORE, level = STATEMENT
-NOTICE:  trigger = self_ref_s_trig, old table = (1,), (2,1), (3,2), (4,3)
 drop table self_ref;
 --
 -- test transition tables with MERGE
@@ -3355,12 +3891,21 @@
 create trigger merge_target_table_insert_trig
   after insert on merge_target_table referencing new table as new_table
   for each statement execute procedure dump_insert();
+ERROR:  unimplemented: statement-level triggers are not yet supported
+HINT:  You have attempted to use a feature that is not yet implemented.
+See: https://go.crdb.dev/issue-v/126362/_version_
 create trigger merge_target_table_update_trig
   after update on merge_target_table referencing old table as old_table new table as new_table
   for each statement execute procedure dump_update();
+ERROR:  unimplemented: statement-level triggers are not yet supported
+HINT:  You have attempted to use a feature that is not yet implemented.
+See: https://go.crdb.dev/issue-v/126362/_version_
 create trigger merge_target_table_delete_trig
   after delete on merge_target_table referencing old table as old_table
   for each statement execute procedure dump_delete();
+ERROR:  unimplemented: statement-level triggers are not yet supported
+HINT:  You have attempted to use a feature that is not yet implemented.
+See: https://go.crdb.dev/issue-v/126362/_version_
 create table merge_source_table (a int, b text);
 insert into merge_source_table
   values (1, 'initial1'), (2, 'initial2'),
@@ -3370,7 +3915,10 @@
 on t.a = s.a
 when not matched then
   insert values (a, b);
-NOTICE:  trigger = merge_target_table_insert_trig, new table = (1,initial1), (2,initial2), (3,initial3), (4,initial4)
+ERROR:  at or near "merge": syntax error
+DETAIL:  source SQL:
+merge into merge_target_table t
+^
 merge into merge_target_table t
 using merge_source_table s
 on t.a = s.a
@@ -3380,9 +3928,10 @@
 	delete
 when not matched then
   insert values (a, b);
-NOTICE:  trigger = merge_target_table_delete_trig, old table = (3,initial3), (4,initial4)
-NOTICE:  trigger = merge_target_table_update_trig, old table = (1,initial1), (2,initial2), new table = (1,"initial1 updated by merge"), (2,"initial2 updated by merge")
-NOTICE:  trigger = merge_target_table_insert_trig, new table = <NULL>
+ERROR:  at or near "merge": syntax error
+DETAIL:  source SQL:
+merge into merge_target_table t
+^
 merge into merge_target_table t
 using merge_source_table s
 on t.a = s.a
@@ -3392,9 +3941,10 @@
 	delete
 when not matched then
   insert values (a, b);
-NOTICE:  trigger = merge_target_table_delete_trig, old table = <NULL>
-NOTICE:  trigger = merge_target_table_update_trig, old table = (1,"initial1 updated by merge"), (2,"initial2 updated by merge"), new table = (1,"initial1 updated by merge updated again by merge"), (2,"initial2 updated by merge updated again by merge")
-NOTICE:  trigger = merge_target_table_insert_trig, new table = (3,initial3), (4,initial4)
+ERROR:  at or near "merge": syntax error
+DETAIL:  source SQL:
+merge into merge_target_table t
+^
 drop table merge_source_table, merge_target_table;
 -- cleanup
 drop function dump_insert();
@@ -3426,83 +3976,156 @@
 create or replace trigger my_trig
   before insert on my_table
   for each row execute procedure funcB();  -- OK
+ERROR:  unimplemented: CREATE OR REPLACE TRIGGER is not supported
+HINT:  You have attempted to use a feature that is not yet implemented.
+See: https://go.crdb.dev/issue-v/128422/_version_
 insert into my_table values (2);  -- this insert should become a no-op
-NOTICE:  hello from funcB
+NOTICE:  hello from funcA
 table my_table;
  id 
 ----
   1
-(1 row)
+  2
+(2 rows)
 
 drop table my_table;
 -- test CREATE OR REPLACE TRIGGER on partition table
 create table parted_trig (a int) partition by range (a);
+ERROR:  at or near "EOF": syntax error
+DETAIL:  source SQL:
+create table parted_trig (a int) partition by range (a)
+                                                       ^
+HINT:  try \h CREATE TABLE
 create table parted_trig_1 partition of parted_trig
        for values from (0) to (1000) partition by range (a);
+ERROR:  at or near "partition": syntax error
+DETAIL:  source SQL:
+create table parted_trig_1 partition of parted_trig
+                           ^
+HINT:  try \h CREATE TABLE
 create table parted_trig_1_1 partition of parted_trig_1 for values from (0) to (100);
+ERROR:  at or near "partition": syntax error
+DETAIL:  source SQL:
+create table parted_trig_1_1 partition of parted_trig_1 for values from (0) to (100)
+                             ^
+HINT:  try \h CREATE TABLE
 create table parted_trig_2 partition of parted_trig for values from (1000) to (2000);
+ERROR:  at or near "partition": syntax error
+DETAIL:  source SQL:
+create table parted_trig_2 partition of parted_trig for values from (1000) to (2000)
+                           ^
+HINT:  try \h CREATE TABLE
 create table default_parted_trig partition of parted_trig default;
+ERROR:  at or near "partition": syntax error
+DETAIL:  source SQL:
+create table default_parted_trig partition of parted_trig default
+                                 ^
+HINT:  try \h CREATE TABLE
 -- test that trigger can be replaced by another one
 -- at the same level of partition table
 create or replace trigger my_trig
   after insert on parted_trig
   for each row execute procedure funcA();
+ERROR:  relation "parted_trig" does not exist
 insert into parted_trig (a) values (50);
-NOTICE:  hello from funcA
+ERROR:  relation "parted_trig" does not exist
 create or replace trigger my_trig
   after insert on parted_trig
   for each row execute procedure funcB();
+ERROR:  relation "parted_trig" does not exist
 insert into parted_trig (a) values (50);
-NOTICE:  hello from funcB
+ERROR:  relation "parted_trig" does not exist
 -- test that child trigger cannot be replaced directly
 create or replace trigger my_trig
   after insert on parted_trig
   for each row execute procedure funcA();
+ERROR:  relation "parted_trig" does not exist
 insert into parted_trig (a) values (50);
-NOTICE:  hello from funcA
+ERROR:  relation "parted_trig" does not exist
 create or replace trigger my_trig
   after insert on parted_trig_1
   for each row execute procedure funcB();  -- should fail
-ERROR:  trigger "my_trig" for relation "parted_trig_1" is an internal or a child trigger
+ERROR:  relation "parted_trig_1" does not exist
 insert into parted_trig (a) values (50);
-NOTICE:  hello from funcA
+ERROR:  relation "parted_trig" does not exist
 drop trigger my_trig on parted_trig;
+ERROR:  relation "parted_trig" does not exist
 insert into parted_trig (a) values (50);
+ERROR:  relation "parted_trig" does not exist
 -- test that user trigger can be overwritten by one defined at upper level
 create trigger my_trig
   after insert on parted_trig_1
   for each row execute procedure funcA();
+ERROR:  relation "parted_trig_1" does not exist
 insert into parted_trig (a) values (50);
-NOTICE:  hello from funcA
+ERROR:  relation "parted_trig" does not exist
 create trigger my_trig
   after insert on parted_trig
   for each row execute procedure funcB();  -- should fail
-ERROR:  trigger "my_trig" for relation "parted_trig_1" already exists
+ERROR:  relation "parted_trig" does not exist
 insert into parted_trig (a) values (50);
-NOTICE:  hello from funcA
+ERROR:  relation "parted_trig" does not exist
 create or replace trigger my_trig
   after insert on parted_trig
   for each row execute procedure funcB();
+ERROR:  relation "parted_trig" does not exist
 insert into parted_trig (a) values (50);
-NOTICE:  hello from funcB
+ERROR:  relation "parted_trig" does not exist
 -- cleanup
 drop table parted_trig;
+ERROR:  relation "parted_trig" does not exist
 drop function funcA();
 drop function funcB();
 -- Leave around some objects for other tests
 create table trigger_parted (a int primary key) partition by list (a);
+ERROR:  at or near "EOF": syntax error
+DETAIL:  source SQL:
+create table trigger_parted (a int primary key) partition by list (a)
+                                                                     ^
+HINT:  try \h CREATE TABLE
 create function trigger_parted_trigfunc() returns trigger language plpgsql as
   $$ begin end; $$;
 create trigger aft_row after insert or update on trigger_parted
   for each row execute function trigger_parted_trigfunc();
+ERROR:  relation "trigger_parted" does not exist
 create table trigger_parted_p1 partition of trigger_parted for values in (1)
   partition by list (a);
+ERROR:  at or near "partition": syntax error
+DETAIL:  source SQL:
+create table trigger_parted_p1 partition of trigger_parted for values in (1)
+                               ^
+HINT:  try \h CREATE TABLE
 create table trigger_parted_p1_1 partition of trigger_parted_p1 for values in (1);
+ERROR:  at or near "partition": syntax error
+DETAIL:  source SQL:
+create table trigger_parted_p1_1 partition of trigger_parted_p1 for values in (1)
+                                 ^
+HINT:  try \h CREATE TABLE
 create table trigger_parted_p2 partition of trigger_parted for values in (2)
   partition by list (a);
+ERROR:  at or near "partition": syntax error
+DETAIL:  source SQL:
+create table trigger_parted_p2 partition of trigger_parted for values in (2)
+                               ^
+HINT:  try \h CREATE TABLE
 create table trigger_parted_p2_2 partition of trigger_parted_p2 for values in (2);
+ERROR:  at or near "partition": syntax error
+DETAIL:  source SQL:
+create table trigger_parted_p2_2 partition of trigger_parted_p2 for values in (2)
+                                 ^
+HINT:  try \h CREATE TABLE
 alter table only trigger_parted_p2 disable trigger aft_row;
+ERROR:  at or near "trigger": syntax error
+DETAIL:  source SQL:
+alter table only trigger_parted_p2 disable trigger aft_row
+                                           ^
+HINT:  try \h ALTER TABLE
 alter table trigger_parted_p2_2 enable always trigger aft_row;
+ERROR:  at or near "always": syntax error
+DETAIL:  source SQL:
+alter table trigger_parted_p2_2 enable always trigger aft_row
+                                       ^
+HINT:  try \h ALTER TABLE
 -- verify transition table conversion slot's lifetime
 -- https://postgr.es/m/39a71864-b120-5a5c-8cc5-c632b6f16761@amazon.com
 create table convslot_test_parent (col1 text primary key);
@@ -3537,8 +4160,10 @@
 create trigger but_trigger after update on convslot_test_child
 referencing new table as new_table
 for each statement execute function convslot_trig2();
+ERROR:  unimplemented: statement-level triggers are not yet supported
+HINT:  You have attempted to use a feature that is not yet implemented.
+See: https://go.crdb.dev/issue-v/126362/_version_
 update convslot_test_parent set col1 = col1 || '1';
-NOTICE:  trigger = but_trigger, new table = (11,tutu), (31,tutu)
 create function convslot_trig3()
 returns trigger
 language plpgsql
@@ -3553,14 +4178,17 @@
 create trigger but_trigger2 after update on convslot_test_child
 referencing old table as old_table new table as new_table
 for each statement execute function convslot_trig3();
+ERROR:  unimplemented: statement-level triggers are not yet supported
+HINT:  You have attempted to use a feature that is not yet implemented.
+See: https://go.crdb.dev/issue-v/126362/_version_
 update convslot_test_parent set col1 = col1 || '1';
-NOTICE:  trigger = but_trigger, new table = (111,tutu), (311,tutu)
-NOTICE:  trigger = but_trigger2, old_table = (11,tutu), (31,tutu), new table = (111,tutu), (311,tutu)
 create trigger bdt_trigger after delete on convslot_test_child
 referencing old table as old_table
 for each statement execute function convslot_trig1();
+ERROR:  unimplemented: statement-level triggers are not yet supported
+HINT:  You have attempted to use a feature that is not yet implemented.
+See: https://go.crdb.dev/issue-v/126362/_version_
 delete from convslot_test_parent;
-NOTICE:  trigger = bdt_trigger, old_table = (111,tutu), (311,tutu)
 drop table convslot_test_child, convslot_test_parent;
 drop function convslot_trig1();
 drop function convslot_trig2();
@@ -3569,98 +4197,153 @@
 -- we don't see any ill effects unless trigger tuple requires mapping
 create table convslot_test_parent (id int primary key, val int)
 partition by range (id);
+ERROR:  at or near "EOF": syntax error
+DETAIL:  source SQL:
+create table convslot_test_parent (id int primary key, val int)
+partition by range (id)
+                       ^
+HINT:  try \h CREATE TABLE
 create table convslot_test_part (val int, id int not null);
 alter table convslot_test_parent
   attach partition convslot_test_part for values from (1) to (1000);
+ERROR:  at or near "attach": syntax error
+DETAIL:  source SQL:
+alter table convslot_test_parent
+  attach partition convslot_test_part for values from (1) to (1000)
+  ^
+HINT:  try \h ALTER TABLE
 create function convslot_trig4() returns trigger as
 $$begin raise exception 'BOOM!'; end$$ language plpgsql;
 create trigger convslot_test_parent_update
     after update on convslot_test_parent
     referencing old table as old_rows new table as new_rows
     for each statement execute procedure convslot_trig4();
+ERROR:  relation "convslot_test_parent" does not exist
 insert into convslot_test_parent (id, val) values (1, 2);
+ERROR:  relation "convslot_test_parent" does not exist
 begin;
 savepoint svp;
 update convslot_test_parent set val = 3;  -- error expected
-ERROR:  BOOM!
-CONTEXT:  PL/pgSQL function convslot_trig4() line 1 at RAISE
+ERROR:  relation "convslot_test_parent" does not exist
 rollback to savepoint svp;
 rollback;
 drop table convslot_test_parent;
+ERROR:  relation "convslot_test_parent" does not exist
 drop function convslot_trig4();
 -- Test trigger renaming on partitioned tables
 create table grandparent (id int, primary key (id)) partition by range (id);
+ERROR:  at or near "EOF": syntax error
+DETAIL:  source SQL:
+create table grandparent (id int, primary key (id)) partition by range (id)
+                                                                           ^
+HINT:  try \h CREATE TABLE
 create table middle partition of grandparent for values from (1) to (10)
 partition by range (id);
+ERROR:  at or near "partition": syntax error
+DETAIL:  source SQL:
+create table middle partition of grandparent for values from (1) to (10)
+                    ^
+HINT:  try \h CREATE TABLE
 create table chi partition of middle for values from (1) to (5);
+ERROR:  at or near "partition": syntax error
+DETAIL:  source SQL:
+create table chi partition of middle for values from (1) to (5)
+                 ^
+HINT:  try \h CREATE TABLE
 create table cho partition of middle for values from (6) to (10);
+ERROR:  at or near "partition": syntax error
+DETAIL:  source SQL:
+create table cho partition of middle for values from (6) to (10)
+                 ^
+HINT:  try \h CREATE TABLE
 create function f () returns trigger as
 $$ begin return new; end; $$
 language plpgsql;
 create trigger a after insert on grandparent
 for each row execute procedure f();
+ERROR:  relation "grandparent" does not exist
 alter trigger a on grandparent rename to b;
+ERROR:  at or near "trigger": syntax error
+DETAIL:  source SQL:
+alter trigger a on grandparent rename to b
+      ^
+HINT:  try \h ALTER
 select tgrelid::regclass, tgname,
 (select tgname from pg_trigger tr where tr.oid = pg_trigger.tgparentid) parent_tgname
 from pg_trigger where tgrelid in (select relid from pg_partition_tree('grandparent'))
 order by tgname, tgrelid::regclass::text COLLATE "C";
-   tgrelid   | tgname | parent_tgname 
--------------+--------+---------------
- chi         | b      | b
- cho         | b      | b
- grandparent | b      | 
- middle      | b      | b
-(4 rows)
-
+ERROR:  unknown function: pg_partition_tree()
 alter trigger a on only grandparent rename to b;	-- ONLY not supported
-ERROR:  syntax error at or near "only"
-LINE 1: alter trigger a on only grandparent rename to b;
-                           ^
+ERROR:  at or near "trigger": syntax error
+DETAIL:  source SQL:
+alter trigger a on only grandparent rename to b
+      ^
+HINT:  try \h ALTER
 alter trigger b on middle rename to c;	-- can't rename trigger on partition
-ERROR:  cannot rename trigger "b" on table "middle"
-HINT:  Rename the trigger on the partitioned table "grandparent" instead.
+ERROR:  at or near "trigger": syntax error
+DETAIL:  source SQL:
+alter trigger b on middle rename to c
+      ^
+HINT:  try \h ALTER
 create trigger c after insert on middle
 for each row execute procedure f();
+ERROR:  relation "middle" does not exist
 alter trigger b on grandparent rename to c;
-ERROR:  trigger "c" for relation "middle" already exists
+ERROR:  at or near "trigger": syntax error
+DETAIL:  source SQL:
+alter trigger b on grandparent rename to c
+      ^
+HINT:  try \h ALTER
 -- Rename cascading does not affect statement triggers
 create trigger p after insert on grandparent for each statement execute function f();
+ERROR:  relation "grandparent" does not exist
 create trigger p after insert on middle for each statement execute function f();
+ERROR:  relation "middle" does not exist
 alter trigger p on grandparent rename to q;
+ERROR:  at or near "trigger": syntax error
+DETAIL:  source SQL:
+alter trigger p on grandparent rename to q
+      ^
+HINT:  try \h ALTER
 select tgrelid::regclass, tgname,
 (select tgname from pg_trigger tr where tr.oid = pg_trigger.tgparentid) parent_tgname
 from pg_trigger where tgrelid in (select relid from pg_partition_tree('grandparent'))
 order by tgname, tgrelid::regclass::text COLLATE "C";
-   tgrelid   | tgname | parent_tgname 
--------------+--------+---------------
- chi         | b      | b
- cho         | b      | b
- grandparent | b      | 
- middle      | b      | b
- chi         | c      | c
- cho         | c      | c
- middle      | c      | 
- middle      | p      | 
- grandparent | q      | 
-(9 rows)
-
+ERROR:  unknown function: pg_partition_tree()
 drop table grandparent;
+ERROR:  relation "grandparent" does not exist
 -- Trigger renaming does not recurse on legacy inheritance
 create table parent (a int);
+ERROR:  relation "root.public.parent" already exists
 create table child () inherits (parent);
+ERROR:  at or near "(": syntax error: unimplemented: this syntax
+DETAIL:  source SQL:
+create table child () inherits (parent)
+                               ^
+HINT:  You have attempted to use a feature that is not yet implemented.
+See: https://go.crdb.dev/issue-v/22456/_version_
 create trigger parenttrig after insert on parent
 for each row execute procedure f();
 create trigger parenttrig after insert on child
 for each row execute procedure f();
+ERROR:  relation "child" does not exist
 alter trigger parenttrig on parent rename to anothertrig;
+ERROR:  at or near "trigger": syntax error
+DETAIL:  source SQL:
+alter trigger parenttrig on parent rename to anothertrig
+      ^
+HINT:  try \h ALTER
 \d+ child
-                                   Table "public.child"
- Column |  Type   | Collation | Nullable | Default | Storage | Stats target | Description 
---------+---------+-----------+----------+---------+---------+--------------+-------------
- a      | integer |           |          |         | plain   |              | 
-Triggers:
-    parenttrig AFTER INSERT ON child FOR EACH ROW EXECUTE FUNCTION f()
-Inherits: parent
-
+ERROR:  at or near ".": syntax error
+DETAIL:  source SQL:
+SELECT c.oid,
+  n.nspname,
+  c.relname
+FROM pg_catalog.pg_class c
+     LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace
+WHERE c.relname OPERATOR(pg_catalog.~) '^(child)$' COLLATE pg_catalog.default
+                                                                     ^
 drop table parent, child;
+ERROR:  relation "child" does not exist
 drop function f();
+ERROR:  cannot drop function "f" because other objects ([root.public.parent]) still depend on it
