// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: server/serverpb/status.proto

package serverpb

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import build "github.com/cockroachdb/cockroach/pkg/build"
import raftpb "go.etcd.io/etcd/raft/v3/raftpb"
import gossip "github.com/cockroachdb/cockroach/pkg/gossip"
import jobspb "github.com/cockroachdb/cockroach/pkg/jobs/jobspb"
import kvserverpb "github.com/cockroachdb/cockroach/pkg/kv/kvserver/kvserverpb"
import roachpb "github.com/cockroachdb/cockroach/pkg/roachpb"
import diagnosticspb "github.com/cockroachdb/cockroach/pkg/server/diagnosticspb"
import statuspb "github.com/cockroachdb/cockroach/pkg/server/status/statuspb"
import enginepb "github.com/cockroachdb/cockroach/pkg/storage/enginepb"
import util "github.com/cockroachdb/cockroach/pkg/util"
import log "github.com/cockroachdb/cockroach/pkg/util/log"

import github_com_cockroachdb_cockroach_pkg_roachpb "github.com/cockroachdb/cockroach/pkg/roachpb"
import time "time"
import github_com_cockroachdb_cockroach_pkg_util_uuid "github.com/cockroachdb/cockroach/pkg/util/uuid"

import (
	context "context"
	grpc "google.golang.org/grpc"
)

import github_com_gogo_protobuf_sortkeys "github.com/gogo/protobuf/sortkeys"
import encoding_binary "encoding/binary"
import github_com_gogo_protobuf_types "github.com/gogo/protobuf/types"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf
var _ = time.Kitchen

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

type StacksType int32

const (
	StacksType_GOROUTINE_STACKS StacksType = 0
	StacksType_THREAD_STACKS    StacksType = 1
)

var StacksType_name = map[int32]string{
	0: "GOROUTINE_STACKS",
	1: "THREAD_STACKS",
}
var StacksType_value = map[string]int32{
	"GOROUTINE_STACKS": 0,
	"THREAD_STACKS":    1,
}

func (x StacksType) String() string {
	return proto.EnumName(StacksType_name, int32(x))
}
func (StacksType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_status_c872ae209e16bf4e, []int{0}
}

// Represents the type of file.
// TODO(ridwanmsharif): Add support for log files. They're currently served
// by an endpoint that parses the log messages, which is not what the
// debug zip client wants.
type FileType int32

const (
	FileType_HEAP       FileType = 0
	FileType_GOROUTINES FileType = 1
)

var FileType_name = map[int32]string{
	0: "HEAP",
	1: "GOROUTINES",
}
var FileType_value = map[string]int32{
	"HEAP":       0,
	"GOROUTINES": 1,
}

func (x FileType) String() string {
	return proto.EnumName(FileType_name, int32(x))
}
func (FileType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_status_c872ae209e16bf4e, []int{1}
}

// We use an enum to allow reporting of client certs and potential others (eg:
// UI).
type CertificateDetails_CertificateType int32

const (
	CertificateDetails_CA        CertificateDetails_CertificateType = 0
	CertificateDetails_NODE      CertificateDetails_CertificateType = 1
	CertificateDetails_CLIENT_CA CertificateDetails_CertificateType = 2
	CertificateDetails_CLIENT    CertificateDetails_CertificateType = 3
	CertificateDetails_UI_CA     CertificateDetails_CertificateType = 4
	CertificateDetails_UI        CertificateDetails_CertificateType = 5
)

var CertificateDetails_CertificateType_name = map[int32]string{
	0: "CA",
	1: "NODE",
	2: "CLIENT_CA",
	3: "CLIENT",
	4: "UI_CA",
	5: "UI",
}
var CertificateDetails_CertificateType_value = map[string]int32{
	"CA":        0,
	"NODE":      1,
	"CLIENT_CA": 2,
	"CLIENT":    3,
	"UI_CA":     4,
	"UI":        5,
}

func (x CertificateDetails_CertificateType) String() string {
	return proto.EnumName(CertificateDetails_CertificateType_name, int32(x))
}
func (CertificateDetails_CertificateType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_status_c872ae209e16bf4e, []int{1, 0}
}

type ProfileRequest_Type int32

const (
	ProfileRequest_HEAP ProfileRequest_Type = 0
	ProfileRequest_CPU  ProfileRequest_Type = 1
)

var ProfileRequest_Type_name = map[int32]string{
	0: "HEAP",
	1: "CPU",
}
var ProfileRequest_Type_value = map[string]int32{
	"HEAP": 0,
	"CPU":  1,
}

func (x ProfileRequest_Type) String() string {
	return proto.EnumName(ProfileRequest_Type_name, int32(x))
}
func (ProfileRequest_Type) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_status_c872ae209e16bf4e, []int{48, 0}
}

// Enum for phase of execution.
type ActiveQuery_Phase int32

const (
	ActiveQuery_PREPARING ActiveQuery_Phase = 0
	ActiveQuery_EXECUTING ActiveQuery_Phase = 1
)

var ActiveQuery_Phase_name = map[int32]string{
	0: "PREPARING",
	1: "EXECUTING",
}
var ActiveQuery_Phase_value = map[string]int32{
	"PREPARING": 0,
	"EXECUTING": 1,
}

func (x ActiveQuery_Phase) String() string {
	return proto.EnumName(ActiveQuery_Phase_name, int32(x))
}
func (ActiveQuery_Phase) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_status_c872ae209e16bf4e, []int{56, 0}
}

type CertificatesRequest struct {
	// node_id is a string so that "local" can be used to specify that no
	// forwarding is necessary.
	NodeId string `protobuf:"bytes,1,opt,name=node_id,json=nodeId,proto3" json:"node_id,omitempty"`
}

func (m *CertificatesRequest) Reset()         { *m = CertificatesRequest{} }
func (m *CertificatesRequest) String() string { return proto.CompactTextString(m) }
func (*CertificatesRequest) ProtoMessage()    {}
func (*CertificatesRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_status_c872ae209e16bf4e, []int{0}
}
func (m *CertificatesRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CertificatesRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *CertificatesRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CertificatesRequest.Merge(dst, src)
}
func (m *CertificatesRequest) XXX_Size() int {
	return m.Size()
}
func (m *CertificatesRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_CertificatesRequest.DiscardUnknown(m)
}

var xxx_messageInfo_CertificatesRequest proto.InternalMessageInfo

type CertificateDetails struct {
	Type CertificateDetails_CertificateType `protobuf:"varint,1,opt,name=type,proto3,enum=cockroach.server.serverpb.CertificateDetails_CertificateType" json:"type,omitempty"`
	// "error_message" and "data" are mutually exclusive.
	ErrorMessage string `protobuf:"bytes,2,opt,name=error_message,json=errorMessage,proto3" json:"error_message,omitempty"`
	// data is the raw file contents of the certificate. This means PEM-encoded
	// DER data.
	Data   []byte                      `protobuf:"bytes,3,opt,name=data,proto3" json:"data,omitempty"`
	Fields []CertificateDetails_Fields `protobuf:"bytes,4,rep,name=fields,proto3" json:"fields"`
}

func (m *CertificateDetails) Reset()         { *m = CertificateDetails{} }
func (m *CertificateDetails) String() string { return proto.CompactTextString(m) }
func (*CertificateDetails) ProtoMessage()    {}
func (*CertificateDetails) Descriptor() ([]byte, []int) {
	return fileDescriptor_status_c872ae209e16bf4e, []int{1}
}
func (m *CertificateDetails) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CertificateDetails) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *CertificateDetails) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CertificateDetails.Merge(dst, src)
}
func (m *CertificateDetails) XXX_Size() int {
	return m.Size()
}
func (m *CertificateDetails) XXX_DiscardUnknown() {
	xxx_messageInfo_CertificateDetails.DiscardUnknown(m)
}

var xxx_messageInfo_CertificateDetails proto.InternalMessageInfo

type CertificateDetails_Fields struct {
	Issuer             string   `protobuf:"bytes,1,opt,name=issuer,proto3" json:"issuer,omitempty"`
	Subject            string   `protobuf:"bytes,2,opt,name=subject,proto3" json:"subject,omitempty"`
	ValidFrom          int64    `protobuf:"varint,3,opt,name=valid_from,json=validFrom,proto3" json:"valid_from,omitempty"`
	ValidUntil         int64    `protobuf:"varint,4,opt,name=valid_until,json=validUntil,proto3" json:"valid_until,omitempty"`
	Addresses          []string `protobuf:"bytes,5,rep,name=addresses,proto3" json:"addresses,omitempty"`
	SignatureAlgorithm string   `protobuf:"bytes,6,opt,name=signature_algorithm,json=signatureAlgorithm,proto3" json:"signature_algorithm,omitempty"`
	PublicKey          string   `protobuf:"bytes,7,opt,name=public_key,json=publicKey,proto3" json:"public_key,omitempty"`
	KeyUsage           []string `protobuf:"bytes,8,rep,name=key_usage,json=keyUsage,proto3" json:"key_usage,omitempty"`
	ExtendedKeyUsage   []string `protobuf:"bytes,9,rep,name=extended_key_usage,json=extendedKeyUsage,proto3" json:"extended_key_usage,omitempty"`
}

func (m *CertificateDetails_Fields) Reset()         { *m = CertificateDetails_Fields{} }
func (m *CertificateDetails_Fields) String() string { return proto.CompactTextString(m) }
func (*CertificateDetails_Fields) ProtoMessage()    {}
func (*CertificateDetails_Fields) Descriptor() ([]byte, []int) {
	return fileDescriptor_status_c872ae209e16bf4e, []int{1, 0}
}
func (m *CertificateDetails_Fields) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CertificateDetails_Fields) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *CertificateDetails_Fields) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CertificateDetails_Fields.Merge(dst, src)
}
func (m *CertificateDetails_Fields) XXX_Size() int {
	return m.Size()
}
func (m *CertificateDetails_Fields) XXX_DiscardUnknown() {
	xxx_messageInfo_CertificateDetails_Fields.DiscardUnknown(m)
}

var xxx_messageInfo_CertificateDetails_Fields proto.InternalMessageInfo

type CertificatesResponse struct {
	Certificates []CertificateDetails `protobuf:"bytes,1,rep,name=certificates,proto3" json:"certificates"`
}

func (m *CertificatesResponse) Reset()         { *m = CertificatesResponse{} }
func (m *CertificatesResponse) String() string { return proto.CompactTextString(m) }
func (*CertificatesResponse) ProtoMessage()    {}
func (*CertificatesResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_status_c872ae209e16bf4e, []int{2}
}
func (m *CertificatesResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CertificatesResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *CertificatesResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CertificatesResponse.Merge(dst, src)
}
func (m *CertificatesResponse) XXX_Size() int {
	return m.Size()
}
func (m *CertificatesResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_CertificatesResponse.DiscardUnknown(m)
}

var xxx_messageInfo_CertificatesResponse proto.InternalMessageInfo

// DetailsRequest requests a nodes details.
// Note: this does *not* check readiness. Use the Health RPC for that purpose.
type DetailsRequest struct {
	// node_id is a string so that "local" can be used to specify that no
	// forwarding is necessary.
	NodeId string `protobuf:"bytes,1,opt,name=node_id,json=nodeId,proto3" json:"node_id,omitempty"`
}

func (m *DetailsRequest) Reset()         { *m = DetailsRequest{} }
func (m *DetailsRequest) String() string { return proto.CompactTextString(m) }
func (*DetailsRequest) ProtoMessage()    {}
func (*DetailsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_status_c872ae209e16bf4e, []int{3}
}
func (m *DetailsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DetailsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *DetailsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DetailsRequest.Merge(dst, src)
}
func (m *DetailsRequest) XXX_Size() int {
	return m.Size()
}
func (m *DetailsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_DetailsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_DetailsRequest proto.InternalMessageInfo

// SystemInfo contains information about the host system.
type SystemInfo struct {
	// system_info is the output from `uname -a`
	SystemInfo string `protobuf:"bytes,1,opt,name=system_info,json=systemInfo,proto3" json:"system_info,omitempty"`
	// kernel_info is the output from `uname -r`.
	KernelInfo string `protobuf:"bytes,2,opt,name=kernel_info,json=kernelInfo,proto3" json:"kernel_info,omitempty"`
}

func (m *SystemInfo) Reset()         { *m = SystemInfo{} }
func (m *SystemInfo) String() string { return proto.CompactTextString(m) }
func (*SystemInfo) ProtoMessage()    {}
func (*SystemInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_status_c872ae209e16bf4e, []int{4}
}
func (m *SystemInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SystemInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *SystemInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SystemInfo.Merge(dst, src)
}
func (m *SystemInfo) XXX_Size() int {
	return m.Size()
}
func (m *SystemInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_SystemInfo.DiscardUnknown(m)
}

var xxx_messageInfo_SystemInfo proto.InternalMessageInfo

type DetailsResponse struct {
	NodeID     github_com_cockroachdb_cockroach_pkg_roachpb.NodeID `protobuf:"varint,1,opt,name=node_id,json=nodeId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/roachpb.NodeID" json:"node_id,omitempty"`
	Address    util.UnresolvedAddr                                 `protobuf:"bytes,2,opt,name=address,proto3" json:"address"`
	BuildInfo  build.Info                                          `protobuf:"bytes,3,opt,name=build_info,json=buildInfo,proto3" json:"build_info"`
	SystemInfo SystemInfo                                          `protobuf:"bytes,4,opt,name=system_info,json=systemInfo,proto3" json:"system_info"`
	SQLAddress util.UnresolvedAddr                                 `protobuf:"bytes,5,opt,name=sql_address,json=sqlAddress,proto3" json:"sql_address"`
}

func (m *DetailsResponse) Reset()         { *m = DetailsResponse{} }
func (m *DetailsResponse) String() string { return proto.CompactTextString(m) }
func (*DetailsResponse) ProtoMessage()    {}
func (*DetailsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_status_c872ae209e16bf4e, []int{5}
}
func (m *DetailsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DetailsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *DetailsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DetailsResponse.Merge(dst, src)
}
func (m *DetailsResponse) XXX_Size() int {
	return m.Size()
}
func (m *DetailsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_DetailsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_DetailsResponse proto.InternalMessageInfo

type NodesRequest struct {
}

func (m *NodesRequest) Reset()         { *m = NodesRequest{} }
func (m *NodesRequest) String() string { return proto.CompactTextString(m) }
func (*NodesRequest) ProtoMessage()    {}
func (*NodesRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_status_c872ae209e16bf4e, []int{6}
}
func (m *NodesRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NodesRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *NodesRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NodesRequest.Merge(dst, src)
}
func (m *NodesRequest) XXX_Size() int {
	return m.Size()
}
func (m *NodesRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_NodesRequest.DiscardUnknown(m)
}

var xxx_messageInfo_NodesRequest proto.InternalMessageInfo

type NodesResponse struct {
	Nodes            []statuspb.NodeStatus                                                                 `protobuf:"bytes,1,rep,name=nodes,proto3" json:"nodes"`
	LivenessByNodeID map[github_com_cockroachdb_cockroach_pkg_roachpb.NodeID]kvserverpb.NodeLivenessStatus `protobuf:"bytes,2,rep,name=liveness_by_node_id,json=livenessByNodeId,proto3,castkey=github.com/cockroachdb/cockroach/pkg/roachpb.NodeID" json:"liveness_by_node_id" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3,enum=cockroach.kv.kvserver.storagepb.NodeLivenessStatus"`
}

func (m *NodesResponse) Reset()         { *m = NodesResponse{} }
func (m *NodesResponse) String() string { return proto.CompactTextString(m) }
func (*NodesResponse) ProtoMessage()    {}
func (*NodesResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_status_c872ae209e16bf4e, []int{7}
}
func (m *NodesResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NodesResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *NodesResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NodesResponse.Merge(dst, src)
}
func (m *NodesResponse) XXX_Size() int {
	return m.Size()
}
func (m *NodesResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_NodesResponse.DiscardUnknown(m)
}

var xxx_messageInfo_NodesResponse proto.InternalMessageInfo

// NodesResponse describe the nodes in the cluster.
// API: PUBLIC ALPHA
type NodesResponseExternal struct {
	// nodes carries the status payloads for all nodes in the cluster.
	// API: PUBLIC ALPHA
	Nodes []NodeResponse `protobuf:"bytes,1,rep,name=nodes,proto3" json:"nodes"`
	// liveness_by_node_id maps each node ID to a liveness status.
	LivenessByNodeID map[github_com_cockroachdb_cockroach_pkg_roachpb.NodeID]kvserverpb.NodeLivenessStatus `protobuf:"bytes,2,rep,name=liveness_by_node_id,json=livenessByNodeId,proto3,castkey=github.com/cockroachdb/cockroach/pkg/roachpb.NodeID" json:"liveness_by_node_id" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3,enum=cockroach.kv.kvserver.storagepb.NodeLivenessStatus"`
}

func (m *NodesResponseExternal) Reset()         { *m = NodesResponseExternal{} }
func (m *NodesResponseExternal) String() string { return proto.CompactTextString(m) }
func (*NodesResponseExternal) ProtoMessage()    {}
func (*NodesResponseExternal) Descriptor() ([]byte, []int) {
	return fileDescriptor_status_c872ae209e16bf4e, []int{8}
}
func (m *NodesResponseExternal) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NodesResponseExternal) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *NodesResponseExternal) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NodesResponseExternal.Merge(dst, src)
}
func (m *NodesResponseExternal) XXX_Size() int {
	return m.Size()
}
func (m *NodesResponseExternal) XXX_DiscardUnknown() {
	xxx_messageInfo_NodesResponseExternal.DiscardUnknown(m)
}

var xxx_messageInfo_NodesResponseExternal proto.InternalMessageInfo

// Locality is an ordered set of key value Tiers that describe a node's
// location. The tier keys should be the same across all nodes.
type Locality struct {
	Tiers []Tier `protobuf:"bytes,1,rep,name=tiers,proto3" json:"tiers"`
}

func (m *Locality) Reset()         { *m = Locality{} }
func (m *Locality) String() string { return proto.CompactTextString(m) }
func (*Locality) ProtoMessage()    {}
func (*Locality) Descriptor() ([]byte, []int) {
	return fileDescriptor_status_c872ae209e16bf4e, []int{9}
}
func (m *Locality) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Locality) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *Locality) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Locality.Merge(dst, src)
}
func (m *Locality) XXX_Size() int {
	return m.Size()
}
func (m *Locality) XXX_DiscardUnknown() {
	xxx_messageInfo_Locality.DiscardUnknown(m)
}

var xxx_messageInfo_Locality proto.InternalMessageInfo

// Tier represents one level of the locality hierarchy.
type Tier struct {
	// Key is the name of tier and should match all other nodes.
	Key string `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
	// Value is node specific value corresponding to the key.
	Value string `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
}

func (m *Tier) Reset()         { *m = Tier{} }
func (m *Tier) String() string { return proto.CompactTextString(m) }
func (*Tier) ProtoMessage()    {}
func (*Tier) Descriptor() ([]byte, []int) {
	return fileDescriptor_status_c872ae209e16bf4e, []int{10}
}
func (m *Tier) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Tier) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *Tier) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Tier.Merge(dst, src)
}
func (m *Tier) XXX_Size() int {
	return m.Size()
}
func (m *Tier) XXX_DiscardUnknown() {
	xxx_messageInfo_Tier.DiscardUnknown(m)
}

var xxx_messageInfo_Tier proto.InternalMessageInfo

type Version struct {
	// The names "major" and "minor" are reserved in C in
	// some platforms (e.g. FreeBSD).
	Major int32 `protobuf:"varint,1,opt,name=major_val,json=majorVal,proto3" json:"major_val,omitempty"`
	Minor int32 `protobuf:"varint,2,opt,name=minor_val,json=minorVal,proto3" json:"minor_val,omitempty"`
	// Note that patch is a placeholder and will always be zero.
	Patch int32 `protobuf:"varint,3,opt,name=patch,proto3" json:"patch,omitempty"`
	// The internal version is used to introduce migrations during the development
	// cycle. They are subversions that are never the end versions of a release,
	// i.e. users of stable, public release will only use binaries with the
	// internal version set to 0.
	Internal int32 `protobuf:"varint,4,opt,name=internal,proto3" json:"internal,omitempty"`
}

func (m *Version) Reset()         { *m = Version{} }
func (m *Version) String() string { return proto.CompactTextString(m) }
func (*Version) ProtoMessage()    {}
func (*Version) Descriptor() ([]byte, []int) {
	return fileDescriptor_status_c872ae209e16bf4e, []int{11}
}
func (m *Version) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Version) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *Version) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Version.Merge(dst, src)
}
func (m *Version) XXX_Size() int {
	return m.Size()
}
func (m *Version) XXX_DiscardUnknown() {
	xxx_messageInfo_Version.DiscardUnknown(m)
}

var xxx_messageInfo_Version proto.InternalMessageInfo

// NodeDescriptor holds details on node physical/network topology.
type NodeDescriptor struct {
	NodeID github_com_cockroachdb_cockroach_pkg_roachpb.NodeID `protobuf:"varint,1,opt,name=node_id,json=nodeId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/roachpb.NodeID" json:"node_id,omitempty"`
	// address should only be visible by the Admin role.
	Address util.UnresolvedAddr `protobuf:"bytes,2,opt,name=address,proto3" json:"address"`
	// attrs should only be visible by the Admin role.
	Attrs         roachpb.Attributes `protobuf:"bytes,3,opt,name=attrs,proto3" json:"attrs"`
	Locality      Locality           `protobuf:"bytes,4,opt,name=locality,proto3" json:"locality"`
	ServerVersion Version            `protobuf:"bytes,5,opt,name=ServerVersion,proto3" json:"ServerVersion"`
	BuildTag      string             `protobuf:"bytes,6,opt,name=build_tag,json=buildTag,proto3" json:"build_tag,omitempty"`
	StartedAt     int64              `protobuf:"varint,7,opt,name=started_at,json=startedAt,proto3" json:"started_at,omitempty"`
	// locality_address should only be visible by the Admin role.
	LocalityAddress []roachpb.LocalityAddress `protobuf:"bytes,8,rep,name=locality_address,json=localityAddress,proto3" json:"locality_address"`
	ClusterName     string                    `protobuf:"bytes,9,opt,name=cluster_name,json=clusterName,proto3" json:"cluster_name,omitempty"`
	// The SQL address. If empty, indicates that the base address field
	// is also used to accept SQL connections.
	// sql_address should only be visible by the Admin role.
	SQLAddress util.UnresolvedAddr `protobuf:"bytes,10,opt,name=sql_address,json=sqlAddress,proto3" json:"sql_address"`
}

func (m *NodeDescriptor) Reset()         { *m = NodeDescriptor{} }
func (m *NodeDescriptor) String() string { return proto.CompactTextString(m) }
func (*NodeDescriptor) ProtoMessage()    {}
func (*NodeDescriptor) Descriptor() ([]byte, []int) {
	return fileDescriptor_status_c872ae209e16bf4e, []int{12}
}
func (m *NodeDescriptor) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NodeDescriptor) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *NodeDescriptor) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NodeDescriptor.Merge(dst, src)
}
func (m *NodeDescriptor) XXX_Size() int {
	return m.Size()
}
func (m *NodeDescriptor) XXX_DiscardUnknown() {
	xxx_messageInfo_NodeDescriptor.DiscardUnknown(m)
}

var xxx_messageInfo_NodeDescriptor proto.InternalMessageInfo

// Percentiles contains a handful of hard-coded percentiles meant to summarize
// a distribution.
type Percentiles struct {
	P10  float64 `protobuf:"fixed64,1,opt,name=p10,proto3" json:"p10,omitempty"`
	P25  float64 `protobuf:"fixed64,2,opt,name=p25,proto3" json:"p25,omitempty"`
	P50  float64 `protobuf:"fixed64,3,opt,name=p50,proto3" json:"p50,omitempty"`
	P75  float64 `protobuf:"fixed64,4,opt,name=p75,proto3" json:"p75,omitempty"`
	P90  float64 `protobuf:"fixed64,5,opt,name=p90,proto3" json:"p90,omitempty"`
	PMax float64 `protobuf:"fixed64,6,opt,name=pMax,proto3" json:"pMax,omitempty"`
}

func (m *Percentiles) Reset()         { *m = Percentiles{} }
func (m *Percentiles) String() string { return proto.CompactTextString(m) }
func (*Percentiles) ProtoMessage()    {}
func (*Percentiles) Descriptor() ([]byte, []int) {
	return fileDescriptor_status_c872ae209e16bf4e, []int{13}
}
func (m *Percentiles) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Percentiles) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *Percentiles) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Percentiles.Merge(dst, src)
}
func (m *Percentiles) XXX_Size() int {
	return m.Size()
}
func (m *Percentiles) XXX_DiscardUnknown() {
	xxx_messageInfo_Percentiles.DiscardUnknown(m)
}

var xxx_messageInfo_Percentiles proto.InternalMessageInfo

// StoreDescriptor holds store information including store attributes, node
// descriptor and store capacity.
type StoreDescriptor struct {
	StoreID  github_com_cockroachdb_cockroach_pkg_roachpb.StoreID `protobuf:"varint,1,opt,name=store_id,json=storeId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/roachpb.StoreID" json:"store_id,omitempty"`
	Attrs    roachpb.Attributes                                   `protobuf:"bytes,2,opt,name=attrs,proto3" json:"attrs"`
	Node     NodeDescriptor                                       `protobuf:"bytes,3,opt,name=node,proto3" json:"node"`
	Capacity roachpb.StoreCapacity                                `protobuf:"bytes,4,opt,name=capacity,proto3" json:"capacity"`
}

func (m *StoreDescriptor) Reset()         { *m = StoreDescriptor{} }
func (m *StoreDescriptor) String() string { return proto.CompactTextString(m) }
func (*StoreDescriptor) ProtoMessage()    {}
func (*StoreDescriptor) Descriptor() ([]byte, []int) {
	return fileDescriptor_status_c872ae209e16bf4e, []int{14}
}
func (m *StoreDescriptor) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StoreDescriptor) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *StoreDescriptor) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StoreDescriptor.Merge(dst, src)
}
func (m *StoreDescriptor) XXX_Size() int {
	return m.Size()
}
func (m *StoreDescriptor) XXX_DiscardUnknown() {
	xxx_messageInfo_StoreDescriptor.DiscardUnknown(m)
}

var xxx_messageInfo_StoreDescriptor proto.InternalMessageInfo

// StoreStatus records the most recent values of metrics for a store.
type StoreStatus struct {
	// desc is the store descriptor.
	Desc StoreDescriptor `protobuf:"bytes,1,opt,name=desc,proto3" json:"desc"`
	// metrics contains the last sampled values for the node metrics.
	Metrics map[string]float64 `protobuf:"bytes,2,rep,name=metrics,proto3" json:"metrics,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"fixed64,2,opt,name=value,proto3"`
}

func (m *StoreStatus) Reset()         { *m = StoreStatus{} }
func (m *StoreStatus) String() string { return proto.CompactTextString(m) }
func (*StoreStatus) ProtoMessage()    {}
func (*StoreStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_status_c872ae209e16bf4e, []int{15}
}
func (m *StoreStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StoreStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *StoreStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StoreStatus.Merge(dst, src)
}
func (m *StoreStatus) XXX_Size() int {
	return m.Size()
}
func (m *StoreStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_StoreStatus.DiscardUnknown(m)
}

var xxx_messageInfo_StoreStatus proto.InternalMessageInfo

// NodeStatus records the most recent values of metrics for a node.
// API: PUBLIC ALPHA
type NodeResponse struct {
	// desc is the node descriptor.
	Desc NodeDescriptor `protobuf:"bytes,1,opt,name=desc,proto3" json:"desc"`
	// build_info describes the `cockroach` executable file.
	// API: PUBLIC ALPHA
	BuildInfo build.Info `protobuf:"bytes,2,opt,name=build_info,json=buildInfo,proto3" json:"build_info"`
	// started_at is the unix timestamp at which the node process was
	// last started.
	// API: PUBLIC ALPHA
	StartedAt int64 `protobuf:"varint,3,opt,name=started_at,json=startedAt,proto3" json:"started_at,omitempty"`
	// updated_at is the unix timestamp at which the node status record
	// was last updated.
	// API: PUBLIC ALPHA
	UpdatedAt int64 `protobuf:"varint,4,opt,name=updated_at,json=updatedAt,proto3" json:"updated_at,omitempty"`
	// metrics contains the last sampled values for the node metrics.
	Metrics map[string]float64 `protobuf:"bytes,5,rep,name=metrics,proto3" json:"metrics,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"fixed64,2,opt,name=value,proto3"`
	// store_statuses provides the store status payloads for all
	// the stores on that node.
	StoreStatuses []StoreStatus `protobuf:"bytes,6,rep,name=store_statuses,json=storeStatuses,proto3" json:"store_statuses"`
	// args is the list of command-line arguments used to last start the node.
	// args should only be visible by the Admin role.
	Args []string `protobuf:"bytes,7,rep,name=args,proto3" json:"args,omitempty"`
	// env is the list of environment variables that influenced
	// the node's configuration.
	// env should only be visible by the Admin role.
	Env []string `protobuf:"bytes,8,rep,name=env,proto3" json:"env,omitempty"`
	// latencies is a map of nodeIDs to nanoseconds which is the latency
	// between this node and the other node.
	//
	// NOTE: this is deprecated and is only set if the min supported
	//       cluster version is >= VersionRPCNetworkStats.
	Latencies map[github_com_cockroachdb_cockroach_pkg_roachpb.NodeID]int64 `protobuf:"bytes,9,rep,name=latencies,proto3,castkey=github.com/cockroachdb/cockroach/pkg/roachpb.NodeID" json:"latencies" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	// activity is a map of nodeIDs to network statistics from this node
	// to other nodes.
	Activity map[github_com_cockroachdb_cockroach_pkg_roachpb.NodeID]NodeResponse_NetworkActivity `protobuf:"bytes,10,rep,name=activity,proto3,castkey=github.com/cockroachdb/cockroach/pkg/roachpb.NodeID" json:"activity" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// total_system_memory is the total RAM available to the system
	// (or, if detected, the memory available to the cgroup this process is in)
	// in bytes.
	// API: PUBLIC ALPHA
	TotalSystemMemory int64 `protobuf:"varint,11,opt,name=total_system_memory,json=totalSystemMemory,proto3" json:"total_system_memory,omitempty"`
	// num_cpus is the number of logical CPUs as reported by the operating system
	// on the host where the `cockroach` process is running. Note that
	// this does not report the number of CPUs actually used by `cockroach`;
	// this parameter is controlled separately.
	// API: PUBLIC ALPHA
	NumCpus int32 `protobuf:"varint,12,opt,name=num_cpus,json=numCpus,proto3" json:"num_cpus,omitempty"`
}

func (m *NodeResponse) Reset()         { *m = NodeResponse{} }
func (m *NodeResponse) String() string { return proto.CompactTextString(m) }
func (*NodeResponse) ProtoMessage()    {}
func (*NodeResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_status_c872ae209e16bf4e, []int{16}
}
func (m *NodeResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NodeResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *NodeResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NodeResponse.Merge(dst, src)
}
func (m *NodeResponse) XXX_Size() int {
	return m.Size()
}
func (m *NodeResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_NodeResponse.DiscardUnknown(m)
}

var xxx_messageInfo_NodeResponse proto.InternalMessageInfo

type NodeResponse_NetworkActivity struct {
	Incoming int64 `protobuf:"varint,1,opt,name=incoming,proto3" json:"incoming,omitempty"`
	Outgoing int64 `protobuf:"varint,2,opt,name=outgoing,proto3" json:"outgoing,omitempty"`
	Latency  int64 `protobuf:"varint,3,opt,name=latency,proto3" json:"latency,omitempty"`
}

func (m *NodeResponse_NetworkActivity) Reset()         { *m = NodeResponse_NetworkActivity{} }
func (m *NodeResponse_NetworkActivity) String() string { return proto.CompactTextString(m) }
func (*NodeResponse_NetworkActivity) ProtoMessage()    {}
func (*NodeResponse_NetworkActivity) Descriptor() ([]byte, []int) {
	return fileDescriptor_status_c872ae209e16bf4e, []int{16, 2}
}
func (m *NodeResponse_NetworkActivity) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NodeResponse_NetworkActivity) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *NodeResponse_NetworkActivity) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NodeResponse_NetworkActivity.Merge(dst, src)
}
func (m *NodeResponse_NetworkActivity) XXX_Size() int {
	return m.Size()
}
func (m *NodeResponse_NetworkActivity) XXX_DiscardUnknown() {
	xxx_messageInfo_NodeResponse_NetworkActivity.DiscardUnknown(m)
}

var xxx_messageInfo_NodeResponse_NetworkActivity proto.InternalMessageInfo

// RegionsRequest requests all available regions.
type RegionsRequest struct {
}

func (m *RegionsRequest) Reset()         { *m = RegionsRequest{} }
func (m *RegionsRequest) String() string { return proto.CompactTextString(m) }
func (*RegionsRequest) ProtoMessage()    {}
func (*RegionsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_status_c872ae209e16bf4e, []int{17}
}
func (m *RegionsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RegionsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *RegionsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RegionsRequest.Merge(dst, src)
}
func (m *RegionsRequest) XXX_Size() int {
	return m.Size()
}
func (m *RegionsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_RegionsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_RegionsRequest proto.InternalMessageInfo

// RegionsResponse describes the available regions.
type RegionsResponse struct {
	Regions map[string]*RegionsResponse_Region `protobuf:"bytes,1,rep,name=regions,proto3" json:"regions,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *RegionsResponse) Reset()         { *m = RegionsResponse{} }
func (m *RegionsResponse) String() string { return proto.CompactTextString(m) }
func (*RegionsResponse) ProtoMessage()    {}
func (*RegionsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_status_c872ae209e16bf4e, []int{18}
}
func (m *RegionsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RegionsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *RegionsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RegionsResponse.Merge(dst, src)
}
func (m *RegionsResponse) XXX_Size() int {
	return m.Size()
}
func (m *RegionsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_RegionsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_RegionsResponse proto.InternalMessageInfo

type RegionsResponse_Region struct {
	Zones []string `protobuf:"bytes,1,rep,name=zones,proto3" json:"zones,omitempty"`
}

func (m *RegionsResponse_Region) Reset()         { *m = RegionsResponse_Region{} }
func (m *RegionsResponse_Region) String() string { return proto.CompactTextString(m) }
func (*RegionsResponse_Region) ProtoMessage()    {}
func (*RegionsResponse_Region) Descriptor() ([]byte, []int) {
	return fileDescriptor_status_c872ae209e16bf4e, []int{18, 0}
}
func (m *RegionsResponse_Region) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RegionsResponse_Region) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *RegionsResponse_Region) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RegionsResponse_Region.Merge(dst, src)
}
func (m *RegionsResponse_Region) XXX_Size() int {
	return m.Size()
}
func (m *RegionsResponse_Region) XXX_DiscardUnknown() {
	xxx_messageInfo_RegionsResponse_Region.DiscardUnknown(m)
}

var xxx_messageInfo_RegionsResponse_Region proto.InternalMessageInfo

type NodeRequest struct {
	// node_id is a string so that "local" can be used to specify that no
	// forwarding is necessary.
	NodeId string `protobuf:"bytes,1,opt,name=node_id,json=nodeId,proto3" json:"node_id,omitempty"`
}

func (m *NodeRequest) Reset()         { *m = NodeRequest{} }
func (m *NodeRequest) String() string { return proto.CompactTextString(m) }
func (*NodeRequest) ProtoMessage()    {}
func (*NodeRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_status_c872ae209e16bf4e, []int{19}
}
func (m *NodeRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NodeRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *NodeRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NodeRequest.Merge(dst, src)
}
func (m *NodeRequest) XXX_Size() int {
	return m.Size()
}
func (m *NodeRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_NodeRequest.DiscardUnknown(m)
}

var xxx_messageInfo_NodeRequest proto.InternalMessageInfo

// RaftState gives internal details about a Raft group's state.
// Closely mirrors the upstream definitions in github.com/etcd-io/etcd/raft.
type RaftState struct {
	ReplicaID uint64           `protobuf:"varint,1,opt,name=replica_id,json=replicaId,proto3" json:"replica_id,omitempty"`
	HardState raftpb.HardState `protobuf:"bytes,2,opt,name=hard_state,json=hardState,proto3" json:"hard_state"`
	// Lead is part of Raft's SoftState.
	Lead uint64 `protobuf:"varint,3,opt,name=lead,proto3" json:"lead,omitempty"`
	// State is part of Raft's SoftState.
	// It's not an enum because this is primarily for ui consumption and there
	// are issues associated with them.
	State          string                        `protobuf:"bytes,4,opt,name=state,proto3" json:"state,omitempty"`
	Applied        uint64                        `protobuf:"varint,5,opt,name=applied,proto3" json:"applied,omitempty"`
	Progress       map[uint64]RaftState_Progress `protobuf:"bytes,6,rep,name=progress,proto3" json:"progress" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	LeadTransferee uint64                        `protobuf:"varint,7,opt,name=lead_transferee,json=leadTransferee,proto3" json:"lead_transferee,omitempty"`
}

func (m *RaftState) Reset()         { *m = RaftState{} }
func (m *RaftState) String() string { return proto.CompactTextString(m) }
func (*RaftState) ProtoMessage()    {}
func (*RaftState) Descriptor() ([]byte, []int) {
	return fileDescriptor_status_c872ae209e16bf4e, []int{20}
}
func (m *RaftState) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RaftState) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *RaftState) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RaftState.Merge(dst, src)
}
func (m *RaftState) XXX_Size() int {
	return m.Size()
}
func (m *RaftState) XXX_DiscardUnknown() {
	xxx_messageInfo_RaftState.DiscardUnknown(m)
}

var xxx_messageInfo_RaftState proto.InternalMessageInfo

type RaftState_Progress struct {
	Match           uint64 `protobuf:"varint,1,opt,name=match,proto3" json:"match,omitempty"`
	Next            uint64 `protobuf:"varint,2,opt,name=next,proto3" json:"next,omitempty"`
	State           string `protobuf:"bytes,3,opt,name=state,proto3" json:"state,omitempty"`
	Paused          bool   `protobuf:"varint,4,opt,name=paused,proto3" json:"paused,omitempty"`
	PendingSnapshot uint64 `protobuf:"varint,5,opt,name=pending_snapshot,json=pendingSnapshot,proto3" json:"pending_snapshot,omitempty"`
}

func (m *RaftState_Progress) Reset()         { *m = RaftState_Progress{} }
func (m *RaftState_Progress) String() string { return proto.CompactTextString(m) }
func (*RaftState_Progress) ProtoMessage()    {}
func (*RaftState_Progress) Descriptor() ([]byte, []int) {
	return fileDescriptor_status_c872ae209e16bf4e, []int{20, 0}
}
func (m *RaftState_Progress) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RaftState_Progress) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *RaftState_Progress) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RaftState_Progress.Merge(dst, src)
}
func (m *RaftState_Progress) XXX_Size() int {
	return m.Size()
}
func (m *RaftState_Progress) XXX_DiscardUnknown() {
	xxx_messageInfo_RaftState_Progress.DiscardUnknown(m)
}

var xxx_messageInfo_RaftState_Progress proto.InternalMessageInfo

type RangeProblems struct {
	Unavailable          bool `protobuf:"varint,1,opt,name=unavailable,proto3" json:"unavailable,omitempty"`
	LeaderNotLeaseHolder bool `protobuf:"varint,2,opt,name=leader_not_lease_holder,json=leaderNotLeaseHolder,proto3" json:"leader_not_lease_holder,omitempty"`
	NoRaftLeader         bool `protobuf:"varint,3,opt,name=no_raft_leader,json=noRaftLeader,proto3" json:"no_raft_leader,omitempty"`
	Underreplicated      bool `protobuf:"varint,4,opt,name=underreplicated,proto3" json:"underreplicated,omitempty"`
	Overreplicated       bool `protobuf:"varint,8,opt,name=overreplicated,proto3" json:"overreplicated,omitempty"`
	NoLease              bool `protobuf:"varint,5,opt,name=no_lease,json=noLease,proto3" json:"no_lease,omitempty"`
	// Quiescent ranges do not tick by definition, but we track this in
	// two different ways and suspect that they're getting out of sync.
	// If the replica's quiescent flag doesn't agree with the store's
	// list of replicas that are ticking, warn about it.
	QuiescentEqualsTicking bool `protobuf:"varint,6,opt,name=quiescent_equals_ticking,json=quiescentEqualsTicking,proto3" json:"quiescent_equals_ticking,omitempty"`
	// When the raft log is too large, it can be a symptom of other issues.
	RaftLogTooLarge bool `protobuf:"varint,7,opt,name=raft_log_too_large,json=raftLogTooLarge,proto3" json:"raft_log_too_large,omitempty"`
}

func (m *RangeProblems) Reset()         { *m = RangeProblems{} }
func (m *RangeProblems) String() string { return proto.CompactTextString(m) }
func (*RangeProblems) ProtoMessage()    {}
func (*RangeProblems) Descriptor() ([]byte, []int) {
	return fileDescriptor_status_c872ae209e16bf4e, []int{21}
}
func (m *RangeProblems) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RangeProblems) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *RangeProblems) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RangeProblems.Merge(dst, src)
}
func (m *RangeProblems) XXX_Size() int {
	return m.Size()
}
func (m *RangeProblems) XXX_DiscardUnknown() {
	xxx_messageInfo_RangeProblems.DiscardUnknown(m)
}

var xxx_messageInfo_RangeProblems proto.InternalMessageInfo

type RangeStatistics struct {
	// Note that queries per second will only be known by the leaseholder.
	// All other replicas will report it as 0.
	QueriesPerSecond float64 `protobuf:"fixed64,1,opt,name=queries_per_second,json=queriesPerSecond,proto3" json:"queries_per_second,omitempty"`
	WritesPerSecond  float64 `protobuf:"fixed64,2,opt,name=writes_per_second,json=writesPerSecond,proto3" json:"writes_per_second,omitempty"`
}

func (m *RangeStatistics) Reset()         { *m = RangeStatistics{} }
func (m *RangeStatistics) String() string { return proto.CompactTextString(m) }
func (*RangeStatistics) ProtoMessage()    {}
func (*RangeStatistics) Descriptor() ([]byte, []int) {
	return fileDescriptor_status_c872ae209e16bf4e, []int{22}
}
func (m *RangeStatistics) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RangeStatistics) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *RangeStatistics) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RangeStatistics.Merge(dst, src)
}
func (m *RangeStatistics) XXX_Size() int {
	return m.Size()
}
func (m *RangeStatistics) XXX_DiscardUnknown() {
	xxx_messageInfo_RangeStatistics.DiscardUnknown(m)
}

var xxx_messageInfo_RangeStatistics proto.InternalMessageInfo

type PrettySpan struct {
	StartKey string `protobuf:"bytes,1,opt,name=start_key,json=startKey,proto3" json:"start_key,omitempty"`
	EndKey   string `protobuf:"bytes,2,opt,name=end_key,json=endKey,proto3" json:"end_key,omitempty"`
}

func (m *PrettySpan) Reset()         { *m = PrettySpan{} }
func (m *PrettySpan) String() string { return proto.CompactTextString(m) }
func (*PrettySpan) ProtoMessage()    {}
func (*PrettySpan) Descriptor() ([]byte, []int) {
	return fileDescriptor_status_c872ae209e16bf4e, []int{23}
}
func (m *PrettySpan) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PrettySpan) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *PrettySpan) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PrettySpan.Merge(dst, src)
}
func (m *PrettySpan) XXX_Size() int {
	return m.Size()
}
func (m *PrettySpan) XXX_DiscardUnknown() {
	xxx_messageInfo_PrettySpan.DiscardUnknown(m)
}

var xxx_messageInfo_PrettySpan proto.InternalMessageInfo

type RangeInfo struct {
	Span          PrettySpan                                           `protobuf:"bytes,1,opt,name=span,proto3" json:"span"`
	RaftState     RaftState                                            `protobuf:"bytes,2,opt,name=raft_state,json=raftState,proto3" json:"raft_state"`
	State         kvserverpb.RangeInfo                                 `protobuf:"bytes,4,opt,name=state,proto3" json:"state"`
	SourceNodeID  github_com_cockroachdb_cockroach_pkg_roachpb.NodeID  `protobuf:"varint,5,opt,name=source_node_id,json=sourceNodeId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/roachpb.NodeID" json:"source_node_id,omitempty"`
	SourceStoreID github_com_cockroachdb_cockroach_pkg_roachpb.StoreID `protobuf:"varint,6,opt,name=source_store_id,json=sourceStoreId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/roachpb.StoreID" json:"source_store_id,omitempty"`
	ErrorMessage  string                                               `protobuf:"bytes,7,opt,name=error_message,json=errorMessage,proto3" json:"error_message,omitempty"`
	LeaseHistory  []roachpb.Lease                                      `protobuf:"bytes,8,rep,name=lease_history,json=leaseHistory,proto3" json:"lease_history"`
	Problems      RangeProblems                                        `protobuf:"bytes,9,opt,name=problems,proto3" json:"problems"`
	Stats         RangeStatistics                                      `protobuf:"bytes,10,opt,name=stats,proto3" json:"stats"`
	LatchesLocal  kvserverpb.LatchManagerInfo                          `protobuf:"bytes,11,opt,name=latches_local,json=latchesLocal,proto3" json:"latches_local"`
	LatchesGlobal kvserverpb.LatchManagerInfo                          `protobuf:"bytes,12,opt,name=latches_global,json=latchesGlobal,proto3" json:"latches_global"`
	LeaseStatus   kvserverpb.LeaseStatus                               `protobuf:"bytes,13,opt,name=lease_status,json=leaseStatus,proto3" json:"lease_status"`
	Quiescent     bool                                                 `protobuf:"varint,14,opt,name=quiescent,proto3" json:"quiescent,omitempty"`
	Ticking       bool                                                 `protobuf:"varint,15,opt,name=ticking,proto3" json:"ticking,omitempty"`
}

func (m *RangeInfo) Reset()         { *m = RangeInfo{} }
func (m *RangeInfo) String() string { return proto.CompactTextString(m) }
func (*RangeInfo) ProtoMessage()    {}
func (*RangeInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_status_c872ae209e16bf4e, []int{24}
}
func (m *RangeInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RangeInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *RangeInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RangeInfo.Merge(dst, src)
}
func (m *RangeInfo) XXX_Size() int {
	return m.Size()
}
func (m *RangeInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_RangeInfo.DiscardUnknown(m)
}

var xxx_messageInfo_RangeInfo proto.InternalMessageInfo

type RangesRequest struct {
	// node_id is a string so that "local" can be used to specify that no
	// forwarding is necessary.
	NodeId   string                                                 `protobuf:"bytes,1,opt,name=node_id,json=nodeId,proto3" json:"node_id,omitempty"`
	RangeIDs []github_com_cockroachdb_cockroach_pkg_roachpb.RangeID `protobuf:"varint,2,rep,packed,name=range_ids,json=rangeIds,proto3,casttype=github.com/cockroachdb/cockroach/pkg/roachpb.RangeID" json:"range_ids,omitempty"`
}

func (m *RangesRequest) Reset()         { *m = RangesRequest{} }
func (m *RangesRequest) String() string { return proto.CompactTextString(m) }
func (*RangesRequest) ProtoMessage()    {}
func (*RangesRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_status_c872ae209e16bf4e, []int{25}
}
func (m *RangesRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RangesRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *RangesRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RangesRequest.Merge(dst, src)
}
func (m *RangesRequest) XXX_Size() int {
	return m.Size()
}
func (m *RangesRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_RangesRequest.DiscardUnknown(m)
}

var xxx_messageInfo_RangesRequest proto.InternalMessageInfo

type RangesResponse struct {
	Ranges []RangeInfo `protobuf:"bytes,1,rep,name=ranges,proto3" json:"ranges"`
}

func (m *RangesResponse) Reset()         { *m = RangesResponse{} }
func (m *RangesResponse) String() string { return proto.CompactTextString(m) }
func (*RangesResponse) ProtoMessage()    {}
func (*RangesResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_status_c872ae209e16bf4e, []int{26}
}
func (m *RangesResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RangesResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *RangesResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RangesResponse.Merge(dst, src)
}
func (m *RangesResponse) XXX_Size() int {
	return m.Size()
}
func (m *RangesResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_RangesResponse.DiscardUnknown(m)
}

var xxx_messageInfo_RangesResponse proto.InternalMessageInfo

type GossipRequest struct {
	// node_id is a string so that "local" can be used to specify that no
	// forwarding is necessary.
	NodeId string `protobuf:"bytes,1,opt,name=node_id,json=nodeId,proto3" json:"node_id,omitempty"`
}

func (m *GossipRequest) Reset()         { *m = GossipRequest{} }
func (m *GossipRequest) String() string { return proto.CompactTextString(m) }
func (*GossipRequest) ProtoMessage()    {}
func (*GossipRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_status_c872ae209e16bf4e, []int{27}
}
func (m *GossipRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GossipRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *GossipRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GossipRequest.Merge(dst, src)
}
func (m *GossipRequest) XXX_Size() int {
	return m.Size()
}
func (m *GossipRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GossipRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GossipRequest proto.InternalMessageInfo

type EngineStatsInfo struct {
	StoreID              github_com_cockroachdb_cockroach_pkg_roachpb.StoreID `protobuf:"varint,1,opt,name=store_id,json=storeId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/roachpb.StoreID" json:"store_id,omitempty"`
	TickersAndHistograms *enginepb.TickersAndHistograms                       `protobuf:"bytes,2,opt,name=tickers_and_histograms,json=tickersAndHistograms,proto3" json:"tickers_and_histograms,omitempty"`
	EngineType           enginepb.EngineType                                  `protobuf:"varint,3,opt,name=engine_type,json=engineType,proto3,enum=cockroach.storage.enginepb.EngineType" json:"engine_type,omitempty"`
}

func (m *EngineStatsInfo) Reset()         { *m = EngineStatsInfo{} }
func (m *EngineStatsInfo) String() string { return proto.CompactTextString(m) }
func (*EngineStatsInfo) ProtoMessage()    {}
func (*EngineStatsInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_status_c872ae209e16bf4e, []int{28}
}
func (m *EngineStatsInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EngineStatsInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *EngineStatsInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EngineStatsInfo.Merge(dst, src)
}
func (m *EngineStatsInfo) XXX_Size() int {
	return m.Size()
}
func (m *EngineStatsInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_EngineStatsInfo.DiscardUnknown(m)
}

var xxx_messageInfo_EngineStatsInfo proto.InternalMessageInfo

type EngineStatsRequest struct {
	// node_id is a string so that "local" can be used to specify that no
	// forwarding is necessary.
	NodeId string `protobuf:"bytes,1,opt,name=node_id,json=nodeId,proto3" json:"node_id,omitempty"`
}

func (m *EngineStatsRequest) Reset()         { *m = EngineStatsRequest{} }
func (m *EngineStatsRequest) String() string { return proto.CompactTextString(m) }
func (*EngineStatsRequest) ProtoMessage()    {}
func (*EngineStatsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_status_c872ae209e16bf4e, []int{29}
}
func (m *EngineStatsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EngineStatsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *EngineStatsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EngineStatsRequest.Merge(dst, src)
}
func (m *EngineStatsRequest) XXX_Size() int {
	return m.Size()
}
func (m *EngineStatsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_EngineStatsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_EngineStatsRequest proto.InternalMessageInfo

type EngineStatsResponse struct {
	Stats []EngineStatsInfo `protobuf:"bytes,1,rep,name=stats,proto3" json:"stats"`
}

func (m *EngineStatsResponse) Reset()         { *m = EngineStatsResponse{} }
func (m *EngineStatsResponse) String() string { return proto.CompactTextString(m) }
func (*EngineStatsResponse) ProtoMessage()    {}
func (*EngineStatsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_status_c872ae209e16bf4e, []int{30}
}
func (m *EngineStatsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EngineStatsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *EngineStatsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EngineStatsResponse.Merge(dst, src)
}
func (m *EngineStatsResponse) XXX_Size() int {
	return m.Size()
}
func (m *EngineStatsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_EngineStatsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_EngineStatsResponse proto.InternalMessageInfo

type TraceEvent struct {
	Time    time.Time `protobuf:"bytes,1,opt,name=time,proto3,stdtime" json:"time"`
	Message string    `protobuf:"bytes,2,opt,name=message,proto3" json:"message,omitempty"`
}

func (m *TraceEvent) Reset()         { *m = TraceEvent{} }
func (m *TraceEvent) String() string { return proto.CompactTextString(m) }
func (*TraceEvent) ProtoMessage()    {}
func (*TraceEvent) Descriptor() ([]byte, []int) {
	return fileDescriptor_status_c872ae209e16bf4e, []int{31}
}
func (m *TraceEvent) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TraceEvent) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *TraceEvent) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TraceEvent.Merge(dst, src)
}
func (m *TraceEvent) XXX_Size() int {
	return m.Size()
}
func (m *TraceEvent) XXX_DiscardUnknown() {
	xxx_messageInfo_TraceEvent.DiscardUnknown(m)
}

var xxx_messageInfo_TraceEvent proto.InternalMessageInfo

type AllocatorDryRun struct {
	RangeID github_com_cockroachdb_cockroach_pkg_roachpb.RangeID `protobuf:"varint,1,opt,name=range_id,json=rangeId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/roachpb.RangeID" json:"range_id,omitempty"`
	Events  []*TraceEvent                                        `protobuf:"bytes,2,rep,name=events,proto3" json:"events,omitempty"`
}

func (m *AllocatorDryRun) Reset()         { *m = AllocatorDryRun{} }
func (m *AllocatorDryRun) String() string { return proto.CompactTextString(m) }
func (*AllocatorDryRun) ProtoMessage()    {}
func (*AllocatorDryRun) Descriptor() ([]byte, []int) {
	return fileDescriptor_status_c872ae209e16bf4e, []int{32}
}
func (m *AllocatorDryRun) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AllocatorDryRun) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *AllocatorDryRun) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AllocatorDryRun.Merge(dst, src)
}
func (m *AllocatorDryRun) XXX_Size() int {
	return m.Size()
}
func (m *AllocatorDryRun) XXX_DiscardUnknown() {
	xxx_messageInfo_AllocatorDryRun.DiscardUnknown(m)
}

var xxx_messageInfo_AllocatorDryRun proto.InternalMessageInfo

type AllocatorRangeRequest struct {
	RangeId int64 `protobuf:"varint,1,opt,name=range_id,json=rangeId,proto3" json:"range_id,omitempty"`
}

func (m *AllocatorRangeRequest) Reset()         { *m = AllocatorRangeRequest{} }
func (m *AllocatorRangeRequest) String() string { return proto.CompactTextString(m) }
func (*AllocatorRangeRequest) ProtoMessage()    {}
func (*AllocatorRangeRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_status_c872ae209e16bf4e, []int{33}
}
func (m *AllocatorRangeRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AllocatorRangeRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *AllocatorRangeRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AllocatorRangeRequest.Merge(dst, src)
}
func (m *AllocatorRangeRequest) XXX_Size() int {
	return m.Size()
}
func (m *AllocatorRangeRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_AllocatorRangeRequest.DiscardUnknown(m)
}

var xxx_messageInfo_AllocatorRangeRequest proto.InternalMessageInfo

type AllocatorRangeResponse struct {
	// The NodeID of the store whose dry run is returned. Only the leaseholder
	// for a given range will do an allocator dry run for it.
	NodeID github_com_cockroachdb_cockroach_pkg_roachpb.NodeID `protobuf:"varint,1,opt,name=node_id,json=nodeId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/roachpb.NodeID" json:"node_id,omitempty"`
	DryRun *AllocatorDryRun                                    `protobuf:"bytes,2,opt,name=dry_run,json=dryRun,proto3" json:"dry_run,omitempty"`
}

func (m *AllocatorRangeResponse) Reset()         { *m = AllocatorRangeResponse{} }
func (m *AllocatorRangeResponse) String() string { return proto.CompactTextString(m) }
func (*AllocatorRangeResponse) ProtoMessage()    {}
func (*AllocatorRangeResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_status_c872ae209e16bf4e, []int{34}
}
func (m *AllocatorRangeResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AllocatorRangeResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *AllocatorRangeResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AllocatorRangeResponse.Merge(dst, src)
}
func (m *AllocatorRangeResponse) XXX_Size() int {
	return m.Size()
}
func (m *AllocatorRangeResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_AllocatorRangeResponse.DiscardUnknown(m)
}

var xxx_messageInfo_AllocatorRangeResponse proto.InternalMessageInfo

type AllocatorRequest struct {
	NodeId   string                                                 `protobuf:"bytes,1,opt,name=node_id,json=nodeId,proto3" json:"node_id,omitempty"`
	RangeIDs []github_com_cockroachdb_cockroach_pkg_roachpb.RangeID `protobuf:"varint,2,rep,packed,name=range_ids,json=rangeIds,proto3,casttype=github.com/cockroachdb/cockroach/pkg/roachpb.RangeID" json:"range_ids,omitempty"`
}

func (m *AllocatorRequest) Reset()         { *m = AllocatorRequest{} }
func (m *AllocatorRequest) String() string { return proto.CompactTextString(m) }
func (*AllocatorRequest) ProtoMessage()    {}
func (*AllocatorRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_status_c872ae209e16bf4e, []int{35}
}
func (m *AllocatorRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AllocatorRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *AllocatorRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AllocatorRequest.Merge(dst, src)
}
func (m *AllocatorRequest) XXX_Size() int {
	return m.Size()
}
func (m *AllocatorRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_AllocatorRequest.DiscardUnknown(m)
}

var xxx_messageInfo_AllocatorRequest proto.InternalMessageInfo

type AllocatorResponse struct {
	DryRuns []*AllocatorDryRun `protobuf:"bytes,1,rep,name=dry_runs,json=dryRuns,proto3" json:"dry_runs,omitempty"`
}

func (m *AllocatorResponse) Reset()         { *m = AllocatorResponse{} }
func (m *AllocatorResponse) String() string { return proto.CompactTextString(m) }
func (*AllocatorResponse) ProtoMessage()    {}
func (*AllocatorResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_status_c872ae209e16bf4e, []int{36}
}
func (m *AllocatorResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AllocatorResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *AllocatorResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AllocatorResponse.Merge(dst, src)
}
func (m *AllocatorResponse) XXX_Size() int {
	return m.Size()
}
func (m *AllocatorResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_AllocatorResponse.DiscardUnknown(m)
}

var xxx_messageInfo_AllocatorResponse proto.InternalMessageInfo

type JSONResponse struct {
	Data []byte `protobuf:"bytes,1,opt,name=data,proto3" json:"data,omitempty"`
}

func (m *JSONResponse) Reset()         { *m = JSONResponse{} }
func (m *JSONResponse) String() string { return proto.CompactTextString(m) }
func (*JSONResponse) ProtoMessage()    {}
func (*JSONResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_status_c872ae209e16bf4e, []int{37}
}
func (m *JSONResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *JSONResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *JSONResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_JSONResponse.Merge(dst, src)
}
func (m *JSONResponse) XXX_Size() int {
	return m.Size()
}
func (m *JSONResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_JSONResponse.DiscardUnknown(m)
}

var xxx_messageInfo_JSONResponse proto.InternalMessageInfo

type ResponseError struct {
	Error   string   `protobuf:"bytes,1,opt,name=error,proto3" json:"error,omitempty"`
	Code    int32    `protobuf:"varint,2,opt,name=code,proto3" json:"code,omitempty"`
	Message string   `protobuf:"bytes,3,opt,name=message,proto3" json:"message,omitempty"`
	Details []string `protobuf:"bytes,4,rep,name=details,proto3" json:"details,omitempty"`
}

func (m *ResponseError) Reset()         { *m = ResponseError{} }
func (m *ResponseError) String() string { return proto.CompactTextString(m) }
func (*ResponseError) ProtoMessage()    {}
func (*ResponseError) Descriptor() ([]byte, []int) {
	return fileDescriptor_status_c872ae209e16bf4e, []int{38}
}
func (m *ResponseError) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ResponseError) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *ResponseError) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ResponseError.Merge(dst, src)
}
func (m *ResponseError) XXX_Size() int {
	return m.Size()
}
func (m *ResponseError) XXX_DiscardUnknown() {
	xxx_messageInfo_ResponseError.DiscardUnknown(m)
}

var xxx_messageInfo_ResponseError proto.InternalMessageInfo

type LogsRequest struct {
	// node_id is a string so that "local" can be used to specify that no
	// forwarding is necessary.
	NodeId    string `protobuf:"bytes,1,opt,name=node_id,json=nodeId,proto3" json:"node_id,omitempty"`
	Level     string `protobuf:"bytes,2,opt,name=level,proto3" json:"level,omitempty"`
	StartTime string `protobuf:"bytes,3,opt,name=start_time,json=startTime,proto3" json:"start_time,omitempty"`
	EndTime   string `protobuf:"bytes,4,opt,name=end_time,json=endTime,proto3" json:"end_time,omitempty"`
	Max       string `protobuf:"bytes,5,opt,name=max,proto3" json:"max,omitempty"`
	Pattern   string `protobuf:"bytes,6,opt,name=pattern,proto3" json:"pattern,omitempty"`
	// redact, if true, requests redaction of sensitive data away
	// from the retrieved log entries.
	// Only admin users can send a request with redact = false.
	Redact bool `protobuf:"varint,7,opt,name=redact,proto3" json:"redact,omitempty"`
	// keep_redactable, if true, requests that retrieved entries preserve
	// the redaction markers if any were present in the log files.
	// If false, redaction markers are stripped away.
	// Note that redact = false && redactable = false implies
	// "flat" entries with all sensitive information enclosed and
	// no markers; this is suitable for backward-compatibility with
	// RPC clients from prior the introduction of redactable logs.
	KeepRedactable bool `protobuf:"varint,8,opt,name=keep_redactable,json=keepRedactable,proto3" json:"keep_redactable,omitempty"`
}

func (m *LogsRequest) Reset()         { *m = LogsRequest{} }
func (m *LogsRequest) String() string { return proto.CompactTextString(m) }
func (*LogsRequest) ProtoMessage()    {}
func (*LogsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_status_c872ae209e16bf4e, []int{39}
}
func (m *LogsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LogsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *LogsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LogsRequest.Merge(dst, src)
}
func (m *LogsRequest) XXX_Size() int {
	return m.Size()
}
func (m *LogsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_LogsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_LogsRequest proto.InternalMessageInfo

type LogEntriesResponse struct {
	Entries []log.Entry `protobuf:"bytes,1,rep,name=entries,proto3" json:"entries"`
}

func (m *LogEntriesResponse) Reset()         { *m = LogEntriesResponse{} }
func (m *LogEntriesResponse) String() string { return proto.CompactTextString(m) }
func (*LogEntriesResponse) ProtoMessage()    {}
func (*LogEntriesResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_status_c872ae209e16bf4e, []int{40}
}
func (m *LogEntriesResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LogEntriesResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *LogEntriesResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LogEntriesResponse.Merge(dst, src)
}
func (m *LogEntriesResponse) XXX_Size() int {
	return m.Size()
}
func (m *LogEntriesResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_LogEntriesResponse.DiscardUnknown(m)
}

var xxx_messageInfo_LogEntriesResponse proto.InternalMessageInfo

type LogFilesListRequest struct {
	// node_id is a string so that "local" can be used to specify that no
	// forwarding is necessary.
	NodeId string `protobuf:"bytes,1,opt,name=node_id,json=nodeId,proto3" json:"node_id,omitempty"`
}

func (m *LogFilesListRequest) Reset()         { *m = LogFilesListRequest{} }
func (m *LogFilesListRequest) String() string { return proto.CompactTextString(m) }
func (*LogFilesListRequest) ProtoMessage()    {}
func (*LogFilesListRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_status_c872ae209e16bf4e, []int{41}
}
func (m *LogFilesListRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LogFilesListRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *LogFilesListRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LogFilesListRequest.Merge(dst, src)
}
func (m *LogFilesListRequest) XXX_Size() int {
	return m.Size()
}
func (m *LogFilesListRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_LogFilesListRequest.DiscardUnknown(m)
}

var xxx_messageInfo_LogFilesListRequest proto.InternalMessageInfo

type LogFilesListResponse struct {
	Files []log.FileInfo `protobuf:"bytes,1,rep,name=files,proto3" json:"files"`
}

func (m *LogFilesListResponse) Reset()         { *m = LogFilesListResponse{} }
func (m *LogFilesListResponse) String() string { return proto.CompactTextString(m) }
func (*LogFilesListResponse) ProtoMessage()    {}
func (*LogFilesListResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_status_c872ae209e16bf4e, []int{42}
}
func (m *LogFilesListResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LogFilesListResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *LogFilesListResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LogFilesListResponse.Merge(dst, src)
}
func (m *LogFilesListResponse) XXX_Size() int {
	return m.Size()
}
func (m *LogFilesListResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_LogFilesListResponse.DiscardUnknown(m)
}

var xxx_messageInfo_LogFilesListResponse proto.InternalMessageInfo

type LogFileRequest struct {
	// node_id is a string so that "local" can be used to specify that no
	// forwarding is necessary.
	NodeId string `protobuf:"bytes,1,opt,name=node_id,json=nodeId,proto3" json:"node_id,omitempty"`
	File   string `protobuf:"bytes,2,opt,name=file,proto3" json:"file,omitempty"`
	// redact, if true, requests redaction of sensitive data away
	// from the retrieved log entries.
	// Only admin users can send a request with redact = false.
	Redact bool `protobuf:"varint,3,opt,name=redact,proto3" json:"redact,omitempty"`
	// keep_redactable, if true, requests that retrieved entries preserve
	// the redaction markers if any were present in the log files.
	// If false, redaction markers are stripped away.
	// Note that redact = false && redactable = false implies
	// "flat" entries with all sensitive information enclosed and
	// no markers; this is suitable for backward-compatibility with
	// RPC clients from prior the introduction of redactable logs.
	KeepRedactable bool `protobuf:"varint,4,opt,name=keep_redactable,json=keepRedactable,proto3" json:"keep_redactable,omitempty"`
}

func (m *LogFileRequest) Reset()         { *m = LogFileRequest{} }
func (m *LogFileRequest) String() string { return proto.CompactTextString(m) }
func (*LogFileRequest) ProtoMessage()    {}
func (*LogFileRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_status_c872ae209e16bf4e, []int{43}
}
func (m *LogFileRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LogFileRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *LogFileRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LogFileRequest.Merge(dst, src)
}
func (m *LogFileRequest) XXX_Size() int {
	return m.Size()
}
func (m *LogFileRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_LogFileRequest.DiscardUnknown(m)
}

var xxx_messageInfo_LogFileRequest proto.InternalMessageInfo

type StacksRequest struct {
	// node_id is a string so that "local" can be used to specify that no
	// forwarding is necessary.
	NodeId string     `protobuf:"bytes,1,opt,name=node_id,json=nodeId,proto3" json:"node_id,omitempty"`
	Type   StacksType `protobuf:"varint,2,opt,name=type,proto3,enum=cockroach.server.serverpb.StacksType" json:"type,omitempty"`
}

func (m *StacksRequest) Reset()         { *m = StacksRequest{} }
func (m *StacksRequest) String() string { return proto.CompactTextString(m) }
func (*StacksRequest) ProtoMessage()    {}
func (*StacksRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_status_c872ae209e16bf4e, []int{44}
}
func (m *StacksRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StacksRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *StacksRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StacksRequest.Merge(dst, src)
}
func (m *StacksRequest) XXX_Size() int {
	return m.Size()
}
func (m *StacksRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_StacksRequest.DiscardUnknown(m)
}

var xxx_messageInfo_StacksRequest proto.InternalMessageInfo

type File struct {
	Name     string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	FileSize int64  `protobuf:"varint,2,opt,name=file_size,json=fileSize,proto3" json:"file_size,omitempty"`
	// Contents may not be populated if only a list of Files are requested.
	Contents []byte `protobuf:"bytes,3,opt,name=contents,proto3" json:"contents,omitempty"`
}

func (m *File) Reset()         { *m = File{} }
func (m *File) String() string { return proto.CompactTextString(m) }
func (*File) ProtoMessage()    {}
func (*File) Descriptor() ([]byte, []int) {
	return fileDescriptor_status_c872ae209e16bf4e, []int{45}
}
func (m *File) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *File) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *File) XXX_Merge(src proto.Message) {
	xxx_messageInfo_File.Merge(dst, src)
}
func (m *File) XXX_Size() int {
	return m.Size()
}
func (m *File) XXX_DiscardUnknown() {
	xxx_messageInfo_File.DiscardUnknown(m)
}

var xxx_messageInfo_File proto.InternalMessageInfo

type GetFilesRequest struct {
	// node_id is a string so that "local" can be used to specify that no
	// forwarding is necessary.
	NodeId string `protobuf:"bytes,1,opt,name=node_id,json=nodeId,proto3" json:"node_id,omitempty"`
	// If list_only is true then the contents of the files will not be populated
	// in the response. Only filenames and sizes will be returned.
	ListOnly bool     `protobuf:"varint,2,opt,name=list_only,json=listOnly,proto3" json:"list_only,omitempty"`
	Type     FileType `protobuf:"varint,5,opt,name=type,proto3,enum=cockroach.server.serverpb.FileType" json:"type,omitempty"`
	// Each pattern given is matched with Files of the above type in the node
	// using filepath.Glob(). The patterns only match to filenames and so path
	// separators cannot be used.
	// Example: * will match all files of requested type.
	Patterns []string `protobuf:"bytes,6,rep,name=patterns,proto3" json:"patterns,omitempty"`
}

func (m *GetFilesRequest) Reset()         { *m = GetFilesRequest{} }
func (m *GetFilesRequest) String() string { return proto.CompactTextString(m) }
func (*GetFilesRequest) ProtoMessage()    {}
func (*GetFilesRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_status_c872ae209e16bf4e, []int{46}
}
func (m *GetFilesRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetFilesRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *GetFilesRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetFilesRequest.Merge(dst, src)
}
func (m *GetFilesRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetFilesRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetFilesRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetFilesRequest proto.InternalMessageInfo

type GetFilesResponse struct {
	Files []*File `protobuf:"bytes,1,rep,name=files,proto3" json:"files,omitempty"`
}

func (m *GetFilesResponse) Reset()         { *m = GetFilesResponse{} }
func (m *GetFilesResponse) String() string { return proto.CompactTextString(m) }
func (*GetFilesResponse) ProtoMessage()    {}
func (*GetFilesResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_status_c872ae209e16bf4e, []int{47}
}
func (m *GetFilesResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetFilesResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *GetFilesResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetFilesResponse.Merge(dst, src)
}
func (m *GetFilesResponse) XXX_Size() int {
	return m.Size()
}
func (m *GetFilesResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetFilesResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetFilesResponse proto.InternalMessageInfo

type ProfileRequest struct {
	// node_id is a string so that "local" can be used to specify that no
	// forwarding is necessary.
	NodeId string `protobuf:"bytes,1,opt,name=node_id,json=nodeId,proto3" json:"node_id,omitempty"`
	// The type of profile to retrieve.
	Type    ProfileRequest_Type `protobuf:"varint,5,opt,name=type,proto3,enum=cockroach.server.serverpb.ProfileRequest_Type" json:"type,omitempty"`
	Seconds int32               `protobuf:"varint,6,opt,name=seconds,proto3" json:"seconds,omitempty"`
}

func (m *ProfileRequest) Reset()         { *m = ProfileRequest{} }
func (m *ProfileRequest) String() string { return proto.CompactTextString(m) }
func (*ProfileRequest) ProtoMessage()    {}
func (*ProfileRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_status_c872ae209e16bf4e, []int{48}
}
func (m *ProfileRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ProfileRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *ProfileRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProfileRequest.Merge(dst, src)
}
func (m *ProfileRequest) XXX_Size() int {
	return m.Size()
}
func (m *ProfileRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ProfileRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ProfileRequest proto.InternalMessageInfo

type MetricsRequest struct {
	// node_id is a string so that "local" can be used to specify that no
	// forwarding is necessary.
	NodeId string `protobuf:"bytes,1,opt,name=node_id,json=nodeId,proto3" json:"node_id,omitempty"`
}

func (m *MetricsRequest) Reset()         { *m = MetricsRequest{} }
func (m *MetricsRequest) String() string { return proto.CompactTextString(m) }
func (*MetricsRequest) ProtoMessage()    {}
func (*MetricsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_status_c872ae209e16bf4e, []int{49}
}
func (m *MetricsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MetricsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *MetricsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MetricsRequest.Merge(dst, src)
}
func (m *MetricsRequest) XXX_Size() int {
	return m.Size()
}
func (m *MetricsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_MetricsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_MetricsRequest proto.InternalMessageInfo

type RaftRangeNode struct {
	NodeID github_com_cockroachdb_cockroach_pkg_roachpb.NodeID `protobuf:"varint,1,opt,name=node_id,json=nodeId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/roachpb.NodeID" json:"node_id,omitempty"`
	Range  RangeInfo                                           `protobuf:"bytes,2,opt,name=range,proto3" json:"range"`
}

func (m *RaftRangeNode) Reset()         { *m = RaftRangeNode{} }
func (m *RaftRangeNode) String() string { return proto.CompactTextString(m) }
func (*RaftRangeNode) ProtoMessage()    {}
func (*RaftRangeNode) Descriptor() ([]byte, []int) {
	return fileDescriptor_status_c872ae209e16bf4e, []int{50}
}
func (m *RaftRangeNode) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RaftRangeNode) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *RaftRangeNode) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RaftRangeNode.Merge(dst, src)
}
func (m *RaftRangeNode) XXX_Size() int {
	return m.Size()
}
func (m *RaftRangeNode) XXX_DiscardUnknown() {
	xxx_messageInfo_RaftRangeNode.DiscardUnknown(m)
}

var xxx_messageInfo_RaftRangeNode proto.InternalMessageInfo

type RaftRangeError struct {
	Message string `protobuf:"bytes,1,opt,name=message,proto3" json:"message,omitempty"`
}

func (m *RaftRangeError) Reset()         { *m = RaftRangeError{} }
func (m *RaftRangeError) String() string { return proto.CompactTextString(m) }
func (*RaftRangeError) ProtoMessage()    {}
func (*RaftRangeError) Descriptor() ([]byte, []int) {
	return fileDescriptor_status_c872ae209e16bf4e, []int{51}
}
func (m *RaftRangeError) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RaftRangeError) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *RaftRangeError) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RaftRangeError.Merge(dst, src)
}
func (m *RaftRangeError) XXX_Size() int {
	return m.Size()
}
func (m *RaftRangeError) XXX_DiscardUnknown() {
	xxx_messageInfo_RaftRangeError.DiscardUnknown(m)
}

var xxx_messageInfo_RaftRangeError proto.InternalMessageInfo

type RaftRangeStatus struct {
	RangeID github_com_cockroachdb_cockroach_pkg_roachpb.RangeID `protobuf:"varint,1,opt,name=range_id,json=rangeId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/roachpb.RangeID" json:"range_id,omitempty"`
	Errors  []RaftRangeError                                     `protobuf:"bytes,2,rep,name=errors,proto3" json:"errors"`
	Nodes   []RaftRangeNode                                      `protobuf:"bytes,3,rep,name=nodes,proto3" json:"nodes"`
}

func (m *RaftRangeStatus) Reset()         { *m = RaftRangeStatus{} }
func (m *RaftRangeStatus) String() string { return proto.CompactTextString(m) }
func (*RaftRangeStatus) ProtoMessage()    {}
func (*RaftRangeStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_status_c872ae209e16bf4e, []int{52}
}
func (m *RaftRangeStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RaftRangeStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *RaftRangeStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RaftRangeStatus.Merge(dst, src)
}
func (m *RaftRangeStatus) XXX_Size() int {
	return m.Size()
}
func (m *RaftRangeStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_RaftRangeStatus.DiscardUnknown(m)
}

var xxx_messageInfo_RaftRangeStatus proto.InternalMessageInfo

type RaftDebugRequest struct {
	RangeIDs []github_com_cockroachdb_cockroach_pkg_roachpb.RangeID `protobuf:"varint,1,rep,packed,name=range_ids,json=rangeIds,proto3,casttype=github.com/cockroachdb/cockroach/pkg/roachpb.RangeID" json:"range_ids,omitempty"`
}

func (m *RaftDebugRequest) Reset()         { *m = RaftDebugRequest{} }
func (m *RaftDebugRequest) String() string { return proto.CompactTextString(m) }
func (*RaftDebugRequest) ProtoMessage()    {}
func (*RaftDebugRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_status_c872ae209e16bf4e, []int{53}
}
func (m *RaftDebugRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RaftDebugRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *RaftDebugRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RaftDebugRequest.Merge(dst, src)
}
func (m *RaftDebugRequest) XXX_Size() int {
	return m.Size()
}
func (m *RaftDebugRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_RaftDebugRequest.DiscardUnknown(m)
}

var xxx_messageInfo_RaftDebugRequest proto.InternalMessageInfo

type RaftDebugResponse struct {
	Ranges map[github_com_cockroachdb_cockroach_pkg_roachpb.RangeID]RaftRangeStatus `protobuf:"bytes,1,rep,name=ranges,proto3,castkey=github.com/cockroachdb/cockroach/pkg/roachpb.RangeID" json:"ranges" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	Errors []RaftRangeError                                                         `protobuf:"bytes,2,rep,name=errors,proto3" json:"errors"`
}

func (m *RaftDebugResponse) Reset()         { *m = RaftDebugResponse{} }
func (m *RaftDebugResponse) String() string { return proto.CompactTextString(m) }
func (*RaftDebugResponse) ProtoMessage()    {}
func (*RaftDebugResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_status_c872ae209e16bf4e, []int{54}
}
func (m *RaftDebugResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RaftDebugResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *RaftDebugResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RaftDebugResponse.Merge(dst, src)
}
func (m *RaftDebugResponse) XXX_Size() int {
	return m.Size()
}
func (m *RaftDebugResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_RaftDebugResponse.DiscardUnknown(m)
}

var xxx_messageInfo_RaftDebugResponse proto.InternalMessageInfo

// TxnInfo represents an in flight user transaction on some Session.
type TxnInfo struct {
	ID github_com_cockroachdb_cockroach_pkg_util_uuid.UUID `protobuf:"bytes,1,opt,name=id,proto3,customtype=github.com/cockroachdb/cockroach/pkg/util/uuid.UUID" json:"id"`
	// The start timestamp of the transaction.
	Start time.Time `protobuf:"bytes,2,opt,name=start,proto3,stdtime" json:"start"`
	// txn_description is a text description of the underlying kv.Txn, intended
	// for troubleshooting purposes.
	TxnDescription string `protobuf:"bytes,3,opt,name=txn_description,json=txnDescription,proto3" json:"txn_description,omitempty"`
	// num_statements_executed is the number of statements that were executed so
	// far on this transaction.
	NumStatementsExecuted int32 `protobuf:"varint,4,opt,name=num_statements_executed,json=numStatementsExecuted,proto3" json:"num_statements_executed,omitempty"`
	// num_retries is the number of times that this transaction was retried.
	NumRetries int32 `protobuf:"varint,5,opt,name=num_retries,json=numRetries,proto3" json:"num_retries,omitempty"`
	// num_retries is the number of times that this transaction was automatically
	// retried by the SQL executor.
	NumAutoRetries int32 `protobuf:"varint,6,opt,name=num_auto_retries,json=numAutoRetries,proto3" json:"num_auto_retries,omitempty"`
	// The deadline by which the transaction must be committed.
	Deadline time.Time `protobuf:"bytes,7,opt,name=deadline,proto3,stdtime" json:"deadline"`
	// implicit is true if this transaction was an implicit SQL transaction.
	Implicit bool `protobuf:"varint,8,opt,name=implicit,proto3" json:"implicit,omitempty"`
	// Number of currently allocated bytes in the txn memory monitor.
	AllocBytes int64 `protobuf:"varint,9,opt,name=alloc_bytes,json=allocBytes,proto3" json:"alloc_bytes,omitempty"`
	// High water mark of allocated bytes in the txn memory monitor.
	MaxAllocBytes int64  `protobuf:"varint,10,opt,name=max_alloc_bytes,json=maxAllocBytes,proto3" json:"max_alloc_bytes,omitempty"`
	ReadOnly      bool   `protobuf:"varint,11,opt,name=read_only,json=readOnly,proto3" json:"read_only,omitempty"`
	IsHistorical  bool   `protobuf:"varint,12,opt,name=is_historical,json=isHistorical,proto3" json:"is_historical,omitempty"`
	Priority      string `protobuf:"bytes,13,opt,name=priority,proto3" json:"priority,omitempty"`
}

func (m *TxnInfo) Reset()         { *m = TxnInfo{} }
func (m *TxnInfo) String() string { return proto.CompactTextString(m) }
func (*TxnInfo) ProtoMessage()    {}
func (*TxnInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_status_c872ae209e16bf4e, []int{55}
}
func (m *TxnInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TxnInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *TxnInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TxnInfo.Merge(dst, src)
}
func (m *TxnInfo) XXX_Size() int {
	return m.Size()
}
func (m *TxnInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_TxnInfo.DiscardUnknown(m)
}

var xxx_messageInfo_TxnInfo proto.InternalMessageInfo

// ActiveQuery represents a query in flight on some Session.
type ActiveQuery struct {
	// ID of the query (uint128 presented as a hexadecimal string).
	ID string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// The UUID of the transaction this query is running in.
	TxnID github_com_cockroachdb_cockroach_pkg_util_uuid.UUID `protobuf:"bytes,7,opt,name=txn_id,json=txnId,proto3,customtype=github.com/cockroachdb/cockroach/pkg/util/uuid.UUID" json:"txn_id"`
	// SQL query string specified by the user.
	Sql string `protobuf:"bytes,2,opt,name=sql,proto3" json:"sql,omitempty"`
	// Start timestamp of this query.
	Start time.Time `protobuf:"bytes,3,opt,name=start,proto3,stdtime" json:"start"`
	// True if this query is distributed.
	IsDistributed bool `protobuf:"varint,4,opt,name=is_distributed,json=isDistributed,proto3" json:"is_distributed,omitempty"`
	// phase stores the current phase of execution for this query.
	Phase    ActiveQuery_Phase `protobuf:"varint,5,opt,name=phase,proto3,enum=cockroach.server.serverpb.ActiveQuery_Phase" json:"phase,omitempty"`
	Progress float32           `protobuf:"fixed32,6,opt,name=progress,proto3" json:"progress,omitempty"`
	// The SQL statement fingerprint, compatible with StatementStatisticsKey.
	SqlAnon string `protobuf:"bytes,8,opt,name=sql_anon,json=sqlAnon,proto3" json:"sql_anon,omitempty"`
}

func (m *ActiveQuery) Reset()         { *m = ActiveQuery{} }
func (m *ActiveQuery) String() string { return proto.CompactTextString(m) }
func (*ActiveQuery) ProtoMessage()    {}
func (*ActiveQuery) Descriptor() ([]byte, []int) {
	return fileDescriptor_status_c872ae209e16bf4e, []int{56}
}
func (m *ActiveQuery) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ActiveQuery) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *ActiveQuery) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ActiveQuery.Merge(dst, src)
}
func (m *ActiveQuery) XXX_Size() int {
	return m.Size()
}
func (m *ActiveQuery) XXX_DiscardUnknown() {
	xxx_messageInfo_ActiveQuery.DiscardUnknown(m)
}

var xxx_messageInfo_ActiveQuery proto.InternalMessageInfo

// Request object for ListSessions and ListLocalSessions.
type ListSessionsRequest struct {
	// Username of the user making this request.
	Username string `protobuf:"bytes,1,opt,name=username,proto3" json:"username,omitempty"`
}

func (m *ListSessionsRequest) Reset()         { *m = ListSessionsRequest{} }
func (m *ListSessionsRequest) String() string { return proto.CompactTextString(m) }
func (*ListSessionsRequest) ProtoMessage()    {}
func (*ListSessionsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_status_c872ae209e16bf4e, []int{57}
}
func (m *ListSessionsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListSessionsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *ListSessionsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListSessionsRequest.Merge(dst, src)
}
func (m *ListSessionsRequest) XXX_Size() int {
	return m.Size()
}
func (m *ListSessionsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ListSessionsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ListSessionsRequest proto.InternalMessageInfo

// Session represents one SQL session.
type Session struct {
	// ID of node where this session exists.
	NodeID github_com_cockroachdb_cockroach_pkg_roachpb.NodeID `protobuf:"varint,1,opt,name=node_id,json=nodeId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/roachpb.NodeID" json:"node_id,omitempty"`
	// Username of the user for this session.
	Username string `protobuf:"bytes,2,opt,name=username,proto3" json:"username,omitempty"`
	// Connected client's IP address and port.
	ClientAddress string `protobuf:"bytes,3,opt,name=client_address,json=clientAddress,proto3" json:"client_address,omitempty"`
	// Application name specified by the client.
	ApplicationName string `protobuf:"bytes,4,opt,name=application_name,json=applicationName,proto3" json:"application_name,omitempty"`
	// Queries in progress on this session.
	ActiveQueries []ActiveQuery `protobuf:"bytes,5,rep,name=active_queries,json=activeQueries,proto3" json:"active_queries"`
	// Timestamp of session's start.
	Start time.Time `protobuf:"bytes,6,opt,name=start,proto3,stdtime" json:"start"`
	// SQL string of the last query executed on this session.
	LastActiveQuery string `protobuf:"bytes,8,opt,name=last_active_query,json=lastActiveQuery,proto3" json:"last_active_query,omitempty"`
	// ID of the session (uint128 represented as raw bytes).
	ID []byte `protobuf:"bytes,9,opt,name=id,proto3" json:"id,omitempty"`
	// Number of currently allocated bytes in the session memory monitor.
	AllocBytes int64 `protobuf:"varint,10,opt,name=alloc_bytes,json=allocBytes,proto3" json:"alloc_bytes,omitempty"`
	// High water mark of allocated bytes in the session memory monitor.
	MaxAllocBytes int64 `protobuf:"varint,11,opt,name=max_alloc_bytes,json=maxAllocBytes,proto3" json:"max_alloc_bytes,omitempty"`
	// Information about the txn in progress on this session. Nil if the
	// session doesn't currently have a transaction.
	ActiveTxn *TxnInfo `protobuf:"bytes,12,opt,name=active_txn,json=activeTxn,proto3" json:"active_txn,omitempty"`
	// The SQL statement fingerprint of the last query executed on this session,
	// compatible with StatementStatisticsKey.
	LastActiveQueryAnon string `protobuf:"bytes,13,opt,name=last_active_query_anon,json=lastActiveQueryAnon,proto3" json:"last_active_query_anon,omitempty"`
}

func (m *Session) Reset()         { *m = Session{} }
func (m *Session) String() string { return proto.CompactTextString(m) }
func (*Session) ProtoMessage()    {}
func (*Session) Descriptor() ([]byte, []int) {
	return fileDescriptor_status_c872ae209e16bf4e, []int{58}
}
func (m *Session) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Session) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *Session) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Session.Merge(dst, src)
}
func (m *Session) XXX_Size() int {
	return m.Size()
}
func (m *Session) XXX_DiscardUnknown() {
	xxx_messageInfo_Session.DiscardUnknown(m)
}

var xxx_messageInfo_Session proto.InternalMessageInfo

// An error wrapper object for ListSessionsResponse.
type ListSessionsError struct {
	// ID of node that was being contacted when this error occurred
	NodeID github_com_cockroachdb_cockroach_pkg_roachpb.NodeID `protobuf:"varint,1,opt,name=node_id,json=nodeId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/roachpb.NodeID" json:"node_id,omitempty"`
	// Error message.
	Message string `protobuf:"bytes,2,opt,name=message,proto3" json:"message,omitempty"`
}

func (m *ListSessionsError) Reset()         { *m = ListSessionsError{} }
func (m *ListSessionsError) String() string { return proto.CompactTextString(m) }
func (*ListSessionsError) ProtoMessage()    {}
func (*ListSessionsError) Descriptor() ([]byte, []int) {
	return fileDescriptor_status_c872ae209e16bf4e, []int{59}
}
func (m *ListSessionsError) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListSessionsError) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *ListSessionsError) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListSessionsError.Merge(dst, src)
}
func (m *ListSessionsError) XXX_Size() int {
	return m.Size()
}
func (m *ListSessionsError) XXX_DiscardUnknown() {
	xxx_messageInfo_ListSessionsError.DiscardUnknown(m)
}

var xxx_messageInfo_ListSessionsError proto.InternalMessageInfo

// Response object for ListSessions and ListLocalSessions.
type ListSessionsResponse struct {
	// A list of sessions on this node or cluster.
	Sessions []Session `protobuf:"bytes,1,rep,name=sessions,proto3" json:"sessions"`
	// Any errors that occurred during fan-out calls to other nodes.
	Errors []ListSessionsError `protobuf:"bytes,2,rep,name=errors,proto3" json:"errors"`
}

func (m *ListSessionsResponse) Reset()         { *m = ListSessionsResponse{} }
func (m *ListSessionsResponse) String() string { return proto.CompactTextString(m) }
func (*ListSessionsResponse) ProtoMessage()    {}
func (*ListSessionsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_status_c872ae209e16bf4e, []int{60}
}
func (m *ListSessionsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListSessionsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *ListSessionsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListSessionsResponse.Merge(dst, src)
}
func (m *ListSessionsResponse) XXX_Size() int {
	return m.Size()
}
func (m *ListSessionsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ListSessionsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ListSessionsResponse proto.InternalMessageInfo

// Request object for issing a query cancel request.
type CancelQueryRequest struct {
	// ID of gateway node for the query to be canceled.
	//
	// TODO(itsbilal): use [(gogoproto.customname) = "NodeID"] below. Need to
	// figure out how to teach grpc-gateway about custom names.
	//
	// node_id is a string so that "local" can be used to specify that no
	// forwarding is necessary.
	NodeId string `protobuf:"bytes,1,opt,name=node_id,json=nodeId,proto3" json:"node_id,omitempty"`
	// ID of query to be canceled (converted to string).
	QueryID string `protobuf:"bytes,2,opt,name=query_id,json=queryId,proto3" json:"query_id,omitempty"`
	// Username of the user making this cancellation request. This may be omitted
	// if the user is the same as the one issuing the CancelQueryRequest.
	Username string `protobuf:"bytes,3,opt,name=username,proto3" json:"username,omitempty"`
}

func (m *CancelQueryRequest) Reset()         { *m = CancelQueryRequest{} }
func (m *CancelQueryRequest) String() string { return proto.CompactTextString(m) }
func (*CancelQueryRequest) ProtoMessage()    {}
func (*CancelQueryRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_status_c872ae209e16bf4e, []int{61}
}
func (m *CancelQueryRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CancelQueryRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *CancelQueryRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CancelQueryRequest.Merge(dst, src)
}
func (m *CancelQueryRequest) XXX_Size() int {
	return m.Size()
}
func (m *CancelQueryRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_CancelQueryRequest.DiscardUnknown(m)
}

var xxx_messageInfo_CancelQueryRequest proto.InternalMessageInfo

// Response returned by target query's gateway node.
type CancelQueryResponse struct {
	// Whether the cancellation request succeeded and the query was canceled.
	Canceled bool `protobuf:"varint,1,opt,name=canceled,proto3" json:"canceled,omitempty"`
	// Error message (accompanied with canceled = false).
	Error string `protobuf:"bytes,2,opt,name=error,proto3" json:"error,omitempty"`
}

func (m *CancelQueryResponse) Reset()         { *m = CancelQueryResponse{} }
func (m *CancelQueryResponse) String() string { return proto.CompactTextString(m) }
func (*CancelQueryResponse) ProtoMessage()    {}
func (*CancelQueryResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_status_c872ae209e16bf4e, []int{62}
}
func (m *CancelQueryResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CancelQueryResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *CancelQueryResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CancelQueryResponse.Merge(dst, src)
}
func (m *CancelQueryResponse) XXX_Size() int {
	return m.Size()
}
func (m *CancelQueryResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_CancelQueryResponse.DiscardUnknown(m)
}

var xxx_messageInfo_CancelQueryResponse proto.InternalMessageInfo

type CancelSessionRequest struct {
	// TODO(abhimadan): use [(gogoproto.customname) = "NodeID"] below. Need to
	// figure out how to teach grpc-gateway about custom names.
	//
	// node_id is a string so that "local" can be used to specify that no
	// forwarding is necessary.
	NodeId    string `protobuf:"bytes,1,opt,name=node_id,json=nodeId,proto3" json:"node_id,omitempty"`
	SessionID []byte `protobuf:"bytes,2,opt,name=session_id,json=sessionId,proto3" json:"session_id,omitempty"`
	// Username of the user making this cancellation request. This may be omitted
	// if the user is the same as the one issuing the CancelSessionRequest.
	Username string `protobuf:"bytes,3,opt,name=username,proto3" json:"username,omitempty"`
}

func (m *CancelSessionRequest) Reset()         { *m = CancelSessionRequest{} }
func (m *CancelSessionRequest) String() string { return proto.CompactTextString(m) }
func (*CancelSessionRequest) ProtoMessage()    {}
func (*CancelSessionRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_status_c872ae209e16bf4e, []int{63}
}
func (m *CancelSessionRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CancelSessionRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *CancelSessionRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CancelSessionRequest.Merge(dst, src)
}
func (m *CancelSessionRequest) XXX_Size() int {
	return m.Size()
}
func (m *CancelSessionRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_CancelSessionRequest.DiscardUnknown(m)
}

var xxx_messageInfo_CancelSessionRequest proto.InternalMessageInfo

type CancelSessionResponse struct {
	Canceled bool   `protobuf:"varint,1,opt,name=canceled,proto3" json:"canceled,omitempty"`
	Error    string `protobuf:"bytes,2,opt,name=error,proto3" json:"error,omitempty"`
}

func (m *CancelSessionResponse) Reset()         { *m = CancelSessionResponse{} }
func (m *CancelSessionResponse) String() string { return proto.CompactTextString(m) }
func (*CancelSessionResponse) ProtoMessage()    {}
func (*CancelSessionResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_status_c872ae209e16bf4e, []int{64}
}
func (m *CancelSessionResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CancelSessionResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *CancelSessionResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CancelSessionResponse.Merge(dst, src)
}
func (m *CancelSessionResponse) XXX_Size() int {
	return m.Size()
}
func (m *CancelSessionResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_CancelSessionResponse.DiscardUnknown(m)
}

var xxx_messageInfo_CancelSessionResponse proto.InternalMessageInfo

type SpanStatsRequest struct {
	NodeID   string                                            `protobuf:"bytes,1,opt,name=node_id,json=nodeId,proto3" json:"node_id,omitempty"`
	StartKey github_com_cockroachdb_cockroach_pkg_roachpb.RKey `protobuf:"bytes,2,opt,name=start_key,json=startKey,proto3,casttype=github.com/cockroachdb/cockroach/pkg/roachpb.RKey" json:"start_key,omitempty"`
	EndKey   github_com_cockroachdb_cockroach_pkg_roachpb.RKey `protobuf:"bytes,3,opt,name=end_key,json=endKey,proto3,casttype=github.com/cockroachdb/cockroach/pkg/roachpb.RKey" json:"end_key,omitempty"`
}

func (m *SpanStatsRequest) Reset()         { *m = SpanStatsRequest{} }
func (m *SpanStatsRequest) String() string { return proto.CompactTextString(m) }
func (*SpanStatsRequest) ProtoMessage()    {}
func (*SpanStatsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_status_c872ae209e16bf4e, []int{65}
}
func (m *SpanStatsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SpanStatsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *SpanStatsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SpanStatsRequest.Merge(dst, src)
}
func (m *SpanStatsRequest) XXX_Size() int {
	return m.Size()
}
func (m *SpanStatsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SpanStatsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SpanStatsRequest proto.InternalMessageInfo

type SpanStatsResponse struct {
	RangeCount           int32              `protobuf:"varint,2,opt,name=range_count,json=rangeCount,proto3" json:"range_count,omitempty"`
	ApproximateDiskBytes uint64             `protobuf:"varint,3,opt,name=approximate_disk_bytes,json=approximateDiskBytes,proto3" json:"approximate_disk_bytes,omitempty"`
	TotalStats           enginepb.MVCCStats `protobuf:"bytes,1,opt,name=total_stats,json=totalStats,proto3" json:"total_stats"`
}

func (m *SpanStatsResponse) Reset()         { *m = SpanStatsResponse{} }
func (m *SpanStatsResponse) String() string { return proto.CompactTextString(m) }
func (*SpanStatsResponse) ProtoMessage()    {}
func (*SpanStatsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_status_c872ae209e16bf4e, []int{66}
}
func (m *SpanStatsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SpanStatsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *SpanStatsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SpanStatsResponse.Merge(dst, src)
}
func (m *SpanStatsResponse) XXX_Size() int {
	return m.Size()
}
func (m *SpanStatsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_SpanStatsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_SpanStatsResponse proto.InternalMessageInfo

type ProblemRangesRequest struct {
	// If left empty, problem ranges for all nodes/stores will be returned.
	NodeID string `protobuf:"bytes,1,opt,name=node_id,json=nodeId,proto3" json:"node_id,omitempty"`
}

func (m *ProblemRangesRequest) Reset()         { *m = ProblemRangesRequest{} }
func (m *ProblemRangesRequest) String() string { return proto.CompactTextString(m) }
func (*ProblemRangesRequest) ProtoMessage()    {}
func (*ProblemRangesRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_status_c872ae209e16bf4e, []int{67}
}
func (m *ProblemRangesRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ProblemRangesRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *ProblemRangesRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProblemRangesRequest.Merge(dst, src)
}
func (m *ProblemRangesRequest) XXX_Size() int {
	return m.Size()
}
func (m *ProblemRangesRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ProblemRangesRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ProblemRangesRequest proto.InternalMessageInfo

type ProblemRangesResponse struct {
	// NodeID is the node that submitted all the requests.
	NodeID           github_com_cockroachdb_cockroach_pkg_roachpb.NodeID                                        `protobuf:"varint,8,opt,name=node_id,json=nodeId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/roachpb.NodeID" json:"node_id,omitempty"`
	ProblemsByNodeID map[github_com_cockroachdb_cockroach_pkg_roachpb.NodeID]ProblemRangesResponse_NodeProblems `protobuf:"bytes,9,rep,name=problems_by_node_id,json=problemsByNodeId,proto3,castkey=github.com/cockroachdb/cockroach/pkg/roachpb.NodeID" json:"problems_by_node_id" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *ProblemRangesResponse) Reset()         { *m = ProblemRangesResponse{} }
func (m *ProblemRangesResponse) String() string { return proto.CompactTextString(m) }
func (*ProblemRangesResponse) ProtoMessage()    {}
func (*ProblemRangesResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_status_c872ae209e16bf4e, []int{68}
}
func (m *ProblemRangesResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ProblemRangesResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *ProblemRangesResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProblemRangesResponse.Merge(dst, src)
}
func (m *ProblemRangesResponse) XXX_Size() int {
	return m.Size()
}
func (m *ProblemRangesResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ProblemRangesResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ProblemRangesResponse proto.InternalMessageInfo

type ProblemRangesResponse_NodeProblems struct {
	ErrorMessage                     string                                                 `protobuf:"bytes,1,opt,name=error_message,json=errorMessage,proto3" json:"error_message,omitempty"`
	UnavailableRangeIDs              []github_com_cockroachdb_cockroach_pkg_roachpb.RangeID `protobuf:"varint,2,rep,packed,name=unavailable_range_ids,json=unavailableRangeIds,proto3,casttype=github.com/cockroachdb/cockroach/pkg/roachpb.RangeID" json:"unavailable_range_ids,omitempty"`
	RaftLeaderNotLeaseHolderRangeIDs []github_com_cockroachdb_cockroach_pkg_roachpb.RangeID `protobuf:"varint,3,rep,packed,name=raft_leader_not_lease_holder_range_ids,json=raftLeaderNotLeaseHolderRangeIds,proto3,casttype=github.com/cockroachdb/cockroach/pkg/roachpb.RangeID" json:"raft_leader_not_lease_holder_range_ids,omitempty"`
	NoRaftLeaderRangeIDs             []github_com_cockroachdb_cockroach_pkg_roachpb.RangeID `protobuf:"varint,4,rep,packed,name=no_raft_leader_range_ids,json=noRaftLeaderRangeIds,proto3,casttype=github.com/cockroachdb/cockroach/pkg/roachpb.RangeID" json:"no_raft_leader_range_ids,omitempty"`
	NoLeaseRangeIDs                  []github_com_cockroachdb_cockroach_pkg_roachpb.RangeID `protobuf:"varint,5,rep,packed,name=no_lease_range_ids,json=noLeaseRangeIds,proto3,casttype=github.com/cockroachdb/cockroach/pkg/roachpb.RangeID" json:"no_lease_range_ids,omitempty"`
	UnderreplicatedRangeIDs          []github_com_cockroachdb_cockroach_pkg_roachpb.RangeID `protobuf:"varint,6,rep,packed,name=underreplicated_range_ids,json=underreplicatedRangeIds,proto3,casttype=github.com/cockroachdb/cockroach/pkg/roachpb.RangeID" json:"underreplicated_range_ids,omitempty"`
	OverreplicatedRangeIDs           []github_com_cockroachdb_cockroach_pkg_roachpb.RangeID `protobuf:"varint,9,rep,packed,name=overreplicated_range_ids,json=overreplicatedRangeIds,proto3,casttype=github.com/cockroachdb/cockroach/pkg/roachpb.RangeID" json:"overreplicated_range_ids,omitempty"`
	QuiescentEqualsTickingRangeIDs   []github_com_cockroachdb_cockroach_pkg_roachpb.RangeID `protobuf:"varint,7,rep,packed,name=quiescent_equals_ticking_range_ids,json=quiescentEqualsTickingRangeIds,proto3,casttype=github.com/cockroachdb/cockroach/pkg/roachpb.RangeID" json:"quiescent_equals_ticking_range_ids,omitempty"`
	RaftLogTooLargeRangeIDs          []github_com_cockroachdb_cockroach_pkg_roachpb.RangeID `protobuf:"varint,8,rep,packed,name=raft_log_too_large_range_ids,json=raftLogTooLargeRangeIds,proto3,casttype=github.com/cockroachdb/cockroach/pkg/roachpb.RangeID" json:"raft_log_too_large_range_ids,omitempty"`
}

func (m *ProblemRangesResponse_NodeProblems) Reset()         { *m = ProblemRangesResponse_NodeProblems{} }
func (m *ProblemRangesResponse_NodeProblems) String() string { return proto.CompactTextString(m) }
func (*ProblemRangesResponse_NodeProblems) ProtoMessage()    {}
func (*ProblemRangesResponse_NodeProblems) Descriptor() ([]byte, []int) {
	return fileDescriptor_status_c872ae209e16bf4e, []int{68, 0}
}
func (m *ProblemRangesResponse_NodeProblems) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ProblemRangesResponse_NodeProblems) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *ProblemRangesResponse_NodeProblems) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProblemRangesResponse_NodeProblems.Merge(dst, src)
}
func (m *ProblemRangesResponse_NodeProblems) XXX_Size() int {
	return m.Size()
}
func (m *ProblemRangesResponse_NodeProblems) XXX_DiscardUnknown() {
	xxx_messageInfo_ProblemRangesResponse_NodeProblems.DiscardUnknown(m)
}

var xxx_messageInfo_ProblemRangesResponse_NodeProblems proto.InternalMessageInfo

// HotRangesRequest queries one or more cluster nodes for a list
// of ranges currently considered “hot” by the node(s).
//
// The server responds with a HotRangesResponse payload.
type HotRangesRequest struct {
	// NodeID indicates which node to query for a hot range report.
	// It is posssible to populate any node ID; if the node receiving
	// the request is not the target node, it will forward the
	// request to the target node.
	//
	// If left empty, the request is forwarded to every node
	// in the cluster.
	NodeID string `protobuf:"bytes,1,opt,name=node_id,json=nodeId,proto3" json:"node_id,omitempty"`
}

func (m *HotRangesRequest) Reset()         { *m = HotRangesRequest{} }
func (m *HotRangesRequest) String() string { return proto.CompactTextString(m) }
func (*HotRangesRequest) ProtoMessage()    {}
func (*HotRangesRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_status_c872ae209e16bf4e, []int{69}
}
func (m *HotRangesRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HotRangesRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *HotRangesRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HotRangesRequest.Merge(dst, src)
}
func (m *HotRangesRequest) XXX_Size() int {
	return m.Size()
}
func (m *HotRangesRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_HotRangesRequest.DiscardUnknown(m)
}

var xxx_messageInfo_HotRangesRequest proto.InternalMessageInfo

// HotRangesResponse is the payload produced in response
// to a HotRangesRequest.
type HotRangesResponse struct {
	// NodeID is the node that received the HotRangesRequest and
	// forwarded requests to the selected target node(s).
	NodeID github_com_cockroachdb_cockroach_pkg_roachpb.NodeID `protobuf:"varint,1,opt,name=node_id,json=nodeId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/roachpb.NodeID" json:"node_id,omitempty"`
	// HotRangesByNodeID contains a hot range report for each selected
	// target node ID in the HotRangesRequest.
	HotRangesByNodeID map[github_com_cockroachdb_cockroach_pkg_roachpb.NodeID]HotRangesResponse_NodeResponse `protobuf:"bytes,2,rep,name=hot_ranges_by_node_id,json=hotRangesByNodeId,proto3,castkey=github.com/cockroachdb/cockroach/pkg/roachpb.NodeID" json:"hot_ranges_by_node_id" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *HotRangesResponse) Reset()         { *m = HotRangesResponse{} }
func (m *HotRangesResponse) String() string { return proto.CompactTextString(m) }
func (*HotRangesResponse) ProtoMessage()    {}
func (*HotRangesResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_status_c872ae209e16bf4e, []int{70}
}
func (m *HotRangesResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HotRangesResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *HotRangesResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HotRangesResponse.Merge(dst, src)
}
func (m *HotRangesResponse) XXX_Size() int {
	return m.Size()
}
func (m *HotRangesResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_HotRangesResponse.DiscardUnknown(m)
}

var xxx_messageInfo_HotRangesResponse proto.InternalMessageInfo

// HotRange is a hot range report for a single store on one of the
// target node(s) selected in a HotRangesRequest.
type HotRangesResponse_HotRange struct {
	// Desc is the descriptor of the range for which the report
	// was produced.
	//
	// Note: this field is generally RESERVED and will likely be removed
	// or replaced in a later version.
	// See: https://github.com/cockroachdb/cockroach/issues/53212
	Desc roachpb.RangeDescriptor `protobuf:"bytes,1,opt,name=desc,proto3" json:"desc"`
	// QueriesPerSecond is the recent number of queries per second
	// on this range.
	QueriesPerSecond float64 `protobuf:"fixed64,2,opt,name=queries_per_second,json=queriesPerSecond,proto3" json:"queries_per_second,omitempty"`
}

func (m *HotRangesResponse_HotRange) Reset()         { *m = HotRangesResponse_HotRange{} }
func (m *HotRangesResponse_HotRange) String() string { return proto.CompactTextString(m) }
func (*HotRangesResponse_HotRange) ProtoMessage()    {}
func (*HotRangesResponse_HotRange) Descriptor() ([]byte, []int) {
	return fileDescriptor_status_c872ae209e16bf4e, []int{70, 0}
}
func (m *HotRangesResponse_HotRange) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HotRangesResponse_HotRange) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *HotRangesResponse_HotRange) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HotRangesResponse_HotRange.Merge(dst, src)
}
func (m *HotRangesResponse_HotRange) XXX_Size() int {
	return m.Size()
}
func (m *HotRangesResponse_HotRange) XXX_DiscardUnknown() {
	xxx_messageInfo_HotRangesResponse_HotRange.DiscardUnknown(m)
}

var xxx_messageInfo_HotRangesResponse_HotRange proto.InternalMessageInfo

// StoreResponse contains the part of a hot ranges report that
// pertains to a single store on a target node.
type HotRangesResponse_StoreResponse struct {
	// StoreID identifies the store for which the report was
	// produced.
	StoreID github_com_cockroachdb_cockroach_pkg_roachpb.StoreID `protobuf:"varint,1,opt,name=store_id,json=storeId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/roachpb.StoreID" json:"store_id,omitempty"`
	// HotRanges is the hot ranges report for this store
	// on the target node.
	HotRanges []HotRangesResponse_HotRange `protobuf:"bytes,2,rep,name=hot_ranges,json=hotRanges,proto3" json:"hot_ranges"`
}

func (m *HotRangesResponse_StoreResponse) Reset()         { *m = HotRangesResponse_StoreResponse{} }
func (m *HotRangesResponse_StoreResponse) String() string { return proto.CompactTextString(m) }
func (*HotRangesResponse_StoreResponse) ProtoMessage()    {}
func (*HotRangesResponse_StoreResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_status_c872ae209e16bf4e, []int{70, 1}
}
func (m *HotRangesResponse_StoreResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HotRangesResponse_StoreResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *HotRangesResponse_StoreResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HotRangesResponse_StoreResponse.Merge(dst, src)
}
func (m *HotRangesResponse_StoreResponse) XXX_Size() int {
	return m.Size()
}
func (m *HotRangesResponse_StoreResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_HotRangesResponse_StoreResponse.DiscardUnknown(m)
}

var xxx_messageInfo_HotRangesResponse_StoreResponse proto.InternalMessageInfo

// NodeResponse is a hot range report for a single target node.
type HotRangesResponse_NodeResponse struct {
	// ErrorMessage is set to a non-empty string if this target
	// node was unable to produce a hot range report.
	//
	// The contents of this string indicates the cause of the failure.
	ErrorMessage string `protobuf:"bytes,1,opt,name=error_message,json=errorMessage,proto3" json:"error_message,omitempty"`
	// Stores contains the hot ranges report if no error was encountered.
	// There is one part to the report for each store in the
	// target node.
	Stores []*HotRangesResponse_StoreResponse `protobuf:"bytes,2,rep,name=stores,proto3" json:"stores,omitempty"`
}

func (m *HotRangesResponse_NodeResponse) Reset()         { *m = HotRangesResponse_NodeResponse{} }
func (m *HotRangesResponse_NodeResponse) String() string { return proto.CompactTextString(m) }
func (*HotRangesResponse_NodeResponse) ProtoMessage()    {}
func (*HotRangesResponse_NodeResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_status_c872ae209e16bf4e, []int{70, 2}
}
func (m *HotRangesResponse_NodeResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HotRangesResponse_NodeResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *HotRangesResponse_NodeResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HotRangesResponse_NodeResponse.Merge(dst, src)
}
func (m *HotRangesResponse_NodeResponse) XXX_Size() int {
	return m.Size()
}
func (m *HotRangesResponse_NodeResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_HotRangesResponse_NodeResponse.DiscardUnknown(m)
}

var xxx_messageInfo_HotRangesResponse_NodeResponse proto.InternalMessageInfo

type RangeRequest struct {
	RangeId int64 `protobuf:"varint,1,opt,name=range_id,json=rangeId,proto3" json:"range_id,omitempty"`
}

func (m *RangeRequest) Reset()         { *m = RangeRequest{} }
func (m *RangeRequest) String() string { return proto.CompactTextString(m) }
func (*RangeRequest) ProtoMessage()    {}
func (*RangeRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_status_c872ae209e16bf4e, []int{71}
}
func (m *RangeRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RangeRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *RangeRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RangeRequest.Merge(dst, src)
}
func (m *RangeRequest) XXX_Size() int {
	return m.Size()
}
func (m *RangeRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_RangeRequest.DiscardUnknown(m)
}

var xxx_messageInfo_RangeRequest proto.InternalMessageInfo

type RangeResponse struct {
	// NodeID is the node that submitted all the requests.
	NodeID            github_com_cockroachdb_cockroach_pkg_roachpb.NodeID                                `protobuf:"varint,1,opt,name=node_id,json=nodeId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/roachpb.NodeID" json:"node_id,omitempty"`
	RangeID           github_com_cockroachdb_cockroach_pkg_roachpb.RangeID                               `protobuf:"varint,2,opt,name=range_id,json=rangeId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/roachpb.RangeID" json:"range_id,omitempty"`
	ResponsesByNodeID map[github_com_cockroachdb_cockroach_pkg_roachpb.NodeID]RangeResponse_NodeResponse `protobuf:"bytes,3,rep,name=responses_by_node_id,json=responsesByNodeId,proto3,castkey=github.com/cockroachdb/cockroach/pkg/roachpb.NodeID" json:"responses_by_node_id" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *RangeResponse) Reset()         { *m = RangeResponse{} }
func (m *RangeResponse) String() string { return proto.CompactTextString(m) }
func (*RangeResponse) ProtoMessage()    {}
func (*RangeResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_status_c872ae209e16bf4e, []int{72}
}
func (m *RangeResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RangeResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *RangeResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RangeResponse.Merge(dst, src)
}
func (m *RangeResponse) XXX_Size() int {
	return m.Size()
}
func (m *RangeResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_RangeResponse.DiscardUnknown(m)
}

var xxx_messageInfo_RangeResponse proto.InternalMessageInfo

type RangeResponse_NodeResponse struct {
	Response     bool        `protobuf:"varint,1,opt,name=response,proto3" json:"response,omitempty"`
	ErrorMessage string      `protobuf:"bytes,2,opt,name=error_message,json=errorMessage,proto3" json:"error_message,omitempty"`
	Infos        []RangeInfo `protobuf:"bytes,3,rep,name=infos,proto3" json:"infos"`
}

func (m *RangeResponse_NodeResponse) Reset()         { *m = RangeResponse_NodeResponse{} }
func (m *RangeResponse_NodeResponse) String() string { return proto.CompactTextString(m) }
func (*RangeResponse_NodeResponse) ProtoMessage()    {}
func (*RangeResponse_NodeResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_status_c872ae209e16bf4e, []int{72, 0}
}
func (m *RangeResponse_NodeResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RangeResponse_NodeResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *RangeResponse_NodeResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RangeResponse_NodeResponse.Merge(dst, src)
}
func (m *RangeResponse_NodeResponse) XXX_Size() int {
	return m.Size()
}
func (m *RangeResponse_NodeResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_RangeResponse_NodeResponse.DiscardUnknown(m)
}

var xxx_messageInfo_RangeResponse_NodeResponse proto.InternalMessageInfo

// DiagnosticsRequest requests a diagnostics report.
type DiagnosticsRequest struct {
	// node_id is a string so that "local" can be used to specify that no
	// forwarding is necessary.
	NodeId string `protobuf:"bytes,1,opt,name=node_id,json=nodeId,proto3" json:"node_id,omitempty"`
}

func (m *DiagnosticsRequest) Reset()         { *m = DiagnosticsRequest{} }
func (m *DiagnosticsRequest) String() string { return proto.CompactTextString(m) }
func (*DiagnosticsRequest) ProtoMessage()    {}
func (*DiagnosticsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_status_c872ae209e16bf4e, []int{73}
}
func (m *DiagnosticsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DiagnosticsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *DiagnosticsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DiagnosticsRequest.Merge(dst, src)
}
func (m *DiagnosticsRequest) XXX_Size() int {
	return m.Size()
}
func (m *DiagnosticsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_DiagnosticsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_DiagnosticsRequest proto.InternalMessageInfo

type StoresRequest struct {
	// node_id is a string so that "local" can be used to specify that no
	// forwarding is necessary.
	NodeId string `protobuf:"bytes,1,opt,name=node_id,json=nodeId,proto3" json:"node_id,omitempty"`
}

func (m *StoresRequest) Reset()         { *m = StoresRequest{} }
func (m *StoresRequest) String() string { return proto.CompactTextString(m) }
func (*StoresRequest) ProtoMessage()    {}
func (*StoresRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_status_c872ae209e16bf4e, []int{74}
}
func (m *StoresRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StoresRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *StoresRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StoresRequest.Merge(dst, src)
}
func (m *StoresRequest) XXX_Size() int {
	return m.Size()
}
func (m *StoresRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_StoresRequest.DiscardUnknown(m)
}

var xxx_messageInfo_StoresRequest proto.InternalMessageInfo

type StoreDetails struct {
	StoreID github_com_cockroachdb_cockroach_pkg_roachpb.StoreID `protobuf:"varint,1,opt,name=store_id,json=storeId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/roachpb.StoreID" json:"store_id,omitempty"`
	// encryption_status is a serialized
	// ccl/storageccl/engineccl/enginepbccl/stats.go::EncryptionStatus protobuf.
	EncryptionStatus []byte `protobuf:"bytes,2,opt,name=encryption_status,json=encryptionStatus,proto3" json:"encryption_status,omitempty"`
	// Basic file stats when encryption is enabled.
	// Total files/bytes.
	TotalFiles uint64 `protobuf:"varint,3,opt,name=total_files,json=totalFiles,proto3" json:"total_files,omitempty"`
	TotalBytes uint64 `protobuf:"varint,4,opt,name=total_bytes,json=totalBytes,proto3" json:"total_bytes,omitempty"`
	// Files/bytes using the active data key.
	ActiveKeyFiles uint64 `protobuf:"varint,5,opt,name=active_key_files,json=activeKeyFiles,proto3" json:"active_key_files,omitempty"`
	ActiveKeyBytes uint64 `protobuf:"varint,6,opt,name=active_key_bytes,json=activeKeyBytes,proto3" json:"active_key_bytes,omitempty"`
}

func (m *StoreDetails) Reset()         { *m = StoreDetails{} }
func (m *StoreDetails) String() string { return proto.CompactTextString(m) }
func (*StoreDetails) ProtoMessage()    {}
func (*StoreDetails) Descriptor() ([]byte, []int) {
	return fileDescriptor_status_c872ae209e16bf4e, []int{75}
}
func (m *StoreDetails) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StoreDetails) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *StoreDetails) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StoreDetails.Merge(dst, src)
}
func (m *StoreDetails) XXX_Size() int {
	return m.Size()
}
func (m *StoreDetails) XXX_DiscardUnknown() {
	xxx_messageInfo_StoreDetails.DiscardUnknown(m)
}

var xxx_messageInfo_StoreDetails proto.InternalMessageInfo

type StoresResponse struct {
	Stores []StoreDetails `protobuf:"bytes,1,rep,name=stores,proto3" json:"stores"`
}

func (m *StoresResponse) Reset()         { *m = StoresResponse{} }
func (m *StoresResponse) String() string { return proto.CompactTextString(m) }
func (*StoresResponse) ProtoMessage()    {}
func (*StoresResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_status_c872ae209e16bf4e, []int{76}
}
func (m *StoresResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StoresResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *StoresResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StoresResponse.Merge(dst, src)
}
func (m *StoresResponse) XXX_Size() int {
	return m.Size()
}
func (m *StoresResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_StoresResponse.DiscardUnknown(m)
}

var xxx_messageInfo_StoresResponse proto.InternalMessageInfo

type StatementsRequest struct {
	NodeID string `protobuf:"bytes,1,opt,name=node_id,json=nodeId,proto3" json:"node_id,omitempty"`
}

func (m *StatementsRequest) Reset()         { *m = StatementsRequest{} }
func (m *StatementsRequest) String() string { return proto.CompactTextString(m) }
func (*StatementsRequest) ProtoMessage()    {}
func (*StatementsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_status_c872ae209e16bf4e, []int{77}
}
func (m *StatementsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StatementsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *StatementsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StatementsRequest.Merge(dst, src)
}
func (m *StatementsRequest) XXX_Size() int {
	return m.Size()
}
func (m *StatementsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_StatementsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_StatementsRequest proto.InternalMessageInfo

type StatementsResponse struct {
	Statements []StatementsResponse_CollectedStatementStatistics `protobuf:"bytes,1,rep,name=statements,proto3" json:"statements"`
	// Timestamp of the last stats reset.
	LastReset time.Time `protobuf:"bytes,3,opt,name=last_reset,json=lastReset,proto3,stdtime" json:"last_reset"`
	// If set and non-empty, indicates the prefix to application_name
	// used for statements/queries issued internally by CockroachDB.
	InternalAppNamePrefix string `protobuf:"bytes,4,opt,name=internal_app_name_prefix,json=internalAppNamePrefix,proto3" json:"internal_app_name_prefix,omitempty"`
	// Transactions is transaction-level statistics for the collection of
	// statements in this response.
	Transactions []StatementsResponse_ExtendedCollectedTransactionStatistics `protobuf:"bytes,5,rep,name=transactions,proto3" json:"transactions"`
}

func (m *StatementsResponse) Reset()         { *m = StatementsResponse{} }
func (m *StatementsResponse) String() string { return proto.CompactTextString(m) }
func (*StatementsResponse) ProtoMessage()    {}
func (*StatementsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_status_c872ae209e16bf4e, []int{78}
}
func (m *StatementsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StatementsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *StatementsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StatementsResponse.Merge(dst, src)
}
func (m *StatementsResponse) XXX_Size() int {
	return m.Size()
}
func (m *StatementsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_StatementsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_StatementsResponse proto.InternalMessageInfo

type StatementsResponse_ExtendedStatementStatisticsKey struct {
	KeyData roachpb.StatementStatisticsKey                      `protobuf:"bytes,1,opt,name=key_data,json=keyData,proto3" json:"key_data"`
	NodeID  github_com_cockroachdb_cockroach_pkg_roachpb.NodeID `protobuf:"varint,2,opt,name=node_id,json=nodeId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/roachpb.NodeID" json:"node_id,omitempty"`
}

func (m *StatementsResponse_ExtendedStatementStatisticsKey) Reset() {
	*m = StatementsResponse_ExtendedStatementStatisticsKey{}
}
func (m *StatementsResponse_ExtendedStatementStatisticsKey) String() string {
	return proto.CompactTextString(m)
}
func (*StatementsResponse_ExtendedStatementStatisticsKey) ProtoMessage() {}
func (*StatementsResponse_ExtendedStatementStatisticsKey) Descriptor() ([]byte, []int) {
	return fileDescriptor_status_c872ae209e16bf4e, []int{78, 0}
}
func (m *StatementsResponse_ExtendedStatementStatisticsKey) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StatementsResponse_ExtendedStatementStatisticsKey) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *StatementsResponse_ExtendedStatementStatisticsKey) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StatementsResponse_ExtendedStatementStatisticsKey.Merge(dst, src)
}
func (m *StatementsResponse_ExtendedStatementStatisticsKey) XXX_Size() int {
	return m.Size()
}
func (m *StatementsResponse_ExtendedStatementStatisticsKey) XXX_DiscardUnknown() {
	xxx_messageInfo_StatementsResponse_ExtendedStatementStatisticsKey.DiscardUnknown(m)
}

var xxx_messageInfo_StatementsResponse_ExtendedStatementStatisticsKey proto.InternalMessageInfo

type StatementsResponse_CollectedStatementStatistics struct {
	Key   StatementsResponse_ExtendedStatementStatisticsKey   `protobuf:"bytes,1,opt,name=key,proto3" json:"key"`
	ID    github_com_cockroachdb_cockroach_pkg_roachpb.StmtID `protobuf:"varint,3,opt,name=id,proto3,casttype=github.com/cockroachdb/cockroach/pkg/roachpb.StmtID" json:"id,omitempty"`
	Stats roachpb.StatementStatistics                         `protobuf:"bytes,2,opt,name=stats,proto3" json:"stats"`
}

func (m *StatementsResponse_CollectedStatementStatistics) Reset() {
	*m = StatementsResponse_CollectedStatementStatistics{}
}
func (m *StatementsResponse_CollectedStatementStatistics) String() string {
	return proto.CompactTextString(m)
}
func (*StatementsResponse_CollectedStatementStatistics) ProtoMessage() {}
func (*StatementsResponse_CollectedStatementStatistics) Descriptor() ([]byte, []int) {
	return fileDescriptor_status_c872ae209e16bf4e, []int{78, 1}
}
func (m *StatementsResponse_CollectedStatementStatistics) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StatementsResponse_CollectedStatementStatistics) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *StatementsResponse_CollectedStatementStatistics) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StatementsResponse_CollectedStatementStatistics.Merge(dst, src)
}
func (m *StatementsResponse_CollectedStatementStatistics) XXX_Size() int {
	return m.Size()
}
func (m *StatementsResponse_CollectedStatementStatistics) XXX_DiscardUnknown() {
	xxx_messageInfo_StatementsResponse_CollectedStatementStatistics.DiscardUnknown(m)
}

var xxx_messageInfo_StatementsResponse_CollectedStatementStatistics proto.InternalMessageInfo

type StatementsResponse_ExtendedCollectedTransactionStatistics struct {
	StatsData roachpb.CollectedTransactionStatistics              `protobuf:"bytes,1,opt,name=stats_data,json=statsData,proto3" json:"stats_data"`
	NodeID    github_com_cockroachdb_cockroach_pkg_roachpb.NodeID `protobuf:"varint,2,opt,name=node_id,json=nodeId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/roachpb.NodeID" json:"node_id,omitempty"`
}

func (m *StatementsResponse_ExtendedCollectedTransactionStatistics) Reset() {
	*m = StatementsResponse_ExtendedCollectedTransactionStatistics{}
}
func (m *StatementsResponse_ExtendedCollectedTransactionStatistics) String() string {
	return proto.CompactTextString(m)
}
func (*StatementsResponse_ExtendedCollectedTransactionStatistics) ProtoMessage() {}
func (*StatementsResponse_ExtendedCollectedTransactionStatistics) Descriptor() ([]byte, []int) {
	return fileDescriptor_status_c872ae209e16bf4e, []int{78, 2}
}
func (m *StatementsResponse_ExtendedCollectedTransactionStatistics) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StatementsResponse_ExtendedCollectedTransactionStatistics) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *StatementsResponse_ExtendedCollectedTransactionStatistics) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StatementsResponse_ExtendedCollectedTransactionStatistics.Merge(dst, src)
}
func (m *StatementsResponse_ExtendedCollectedTransactionStatistics) XXX_Size() int {
	return m.Size()
}
func (m *StatementsResponse_ExtendedCollectedTransactionStatistics) XXX_DiscardUnknown() {
	xxx_messageInfo_StatementsResponse_ExtendedCollectedTransactionStatistics.DiscardUnknown(m)
}

var xxx_messageInfo_StatementsResponse_ExtendedCollectedTransactionStatistics proto.InternalMessageInfo

type StatementDiagnosticsReport struct {
	Id                     int64     `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Completed              bool      `protobuf:"varint,2,opt,name=completed,proto3" json:"completed,omitempty"`
	StatementFingerprint   string    `protobuf:"bytes,3,opt,name=statement_fingerprint,json=statementFingerprint,proto3" json:"statement_fingerprint,omitempty"`
	StatementDiagnosticsId int64     `protobuf:"varint,4,opt,name=statement_diagnostics_id,json=statementDiagnosticsId,proto3" json:"statement_diagnostics_id,omitempty"`
	RequestedAt            time.Time `protobuf:"bytes,5,opt,name=requested_at,json=requestedAt,proto3,stdtime" json:"requested_at"`
}

func (m *StatementDiagnosticsReport) Reset()         { *m = StatementDiagnosticsReport{} }
func (m *StatementDiagnosticsReport) String() string { return proto.CompactTextString(m) }
func (*StatementDiagnosticsReport) ProtoMessage()    {}
func (*StatementDiagnosticsReport) Descriptor() ([]byte, []int) {
	return fileDescriptor_status_c872ae209e16bf4e, []int{79}
}
func (m *StatementDiagnosticsReport) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StatementDiagnosticsReport) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *StatementDiagnosticsReport) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StatementDiagnosticsReport.Merge(dst, src)
}
func (m *StatementDiagnosticsReport) XXX_Size() int {
	return m.Size()
}
func (m *StatementDiagnosticsReport) XXX_DiscardUnknown() {
	xxx_messageInfo_StatementDiagnosticsReport.DiscardUnknown(m)
}

var xxx_messageInfo_StatementDiagnosticsReport proto.InternalMessageInfo

type CreateStatementDiagnosticsReportRequest struct {
	StatementFingerprint string `protobuf:"bytes,1,opt,name=statement_fingerprint,json=statementFingerprint,proto3" json:"statement_fingerprint,omitempty"`
}

func (m *CreateStatementDiagnosticsReportRequest) Reset() {
	*m = CreateStatementDiagnosticsReportRequest{}
}
func (m *CreateStatementDiagnosticsReportRequest) String() string { return proto.CompactTextString(m) }
func (*CreateStatementDiagnosticsReportRequest) ProtoMessage()    {}
func (*CreateStatementDiagnosticsReportRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_status_c872ae209e16bf4e, []int{80}
}
func (m *CreateStatementDiagnosticsReportRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CreateStatementDiagnosticsReportRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *CreateStatementDiagnosticsReportRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateStatementDiagnosticsReportRequest.Merge(dst, src)
}
func (m *CreateStatementDiagnosticsReportRequest) XXX_Size() int {
	return m.Size()
}
func (m *CreateStatementDiagnosticsReportRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateStatementDiagnosticsReportRequest.DiscardUnknown(m)
}

var xxx_messageInfo_CreateStatementDiagnosticsReportRequest proto.InternalMessageInfo

type CreateStatementDiagnosticsReportResponse struct {
	Report *StatementDiagnosticsReport `protobuf:"bytes,1,opt,name=report,proto3" json:"report,omitempty"`
}

func (m *CreateStatementDiagnosticsReportResponse) Reset() {
	*m = CreateStatementDiagnosticsReportResponse{}
}
func (m *CreateStatementDiagnosticsReportResponse) String() string { return proto.CompactTextString(m) }
func (*CreateStatementDiagnosticsReportResponse) ProtoMessage()    {}
func (*CreateStatementDiagnosticsReportResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_status_c872ae209e16bf4e, []int{81}
}
func (m *CreateStatementDiagnosticsReportResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CreateStatementDiagnosticsReportResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *CreateStatementDiagnosticsReportResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateStatementDiagnosticsReportResponse.Merge(dst, src)
}
func (m *CreateStatementDiagnosticsReportResponse) XXX_Size() int {
	return m.Size()
}
func (m *CreateStatementDiagnosticsReportResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateStatementDiagnosticsReportResponse.DiscardUnknown(m)
}

var xxx_messageInfo_CreateStatementDiagnosticsReportResponse proto.InternalMessageInfo

type StatementDiagnosticsReportsRequest struct {
}

func (m *StatementDiagnosticsReportsRequest) Reset()         { *m = StatementDiagnosticsReportsRequest{} }
func (m *StatementDiagnosticsReportsRequest) String() string { return proto.CompactTextString(m) }
func (*StatementDiagnosticsReportsRequest) ProtoMessage()    {}
func (*StatementDiagnosticsReportsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_status_c872ae209e16bf4e, []int{82}
}
func (m *StatementDiagnosticsReportsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StatementDiagnosticsReportsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *StatementDiagnosticsReportsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StatementDiagnosticsReportsRequest.Merge(dst, src)
}
func (m *StatementDiagnosticsReportsRequest) XXX_Size() int {
	return m.Size()
}
func (m *StatementDiagnosticsReportsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_StatementDiagnosticsReportsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_StatementDiagnosticsReportsRequest proto.InternalMessageInfo

type StatementDiagnosticsReportsResponse struct {
	Reports []StatementDiagnosticsReport `protobuf:"bytes,1,rep,name=reports,proto3" json:"reports"`
}

func (m *StatementDiagnosticsReportsResponse) Reset()         { *m = StatementDiagnosticsReportsResponse{} }
func (m *StatementDiagnosticsReportsResponse) String() string { return proto.CompactTextString(m) }
func (*StatementDiagnosticsReportsResponse) ProtoMessage()    {}
func (*StatementDiagnosticsReportsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_status_c872ae209e16bf4e, []int{83}
}
func (m *StatementDiagnosticsReportsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StatementDiagnosticsReportsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *StatementDiagnosticsReportsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StatementDiagnosticsReportsResponse.Merge(dst, src)
}
func (m *StatementDiagnosticsReportsResponse) XXX_Size() int {
	return m.Size()
}
func (m *StatementDiagnosticsReportsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_StatementDiagnosticsReportsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_StatementDiagnosticsReportsResponse proto.InternalMessageInfo

type StatementDiagnostics struct {
	Id                   int64     `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	StatementFingerprint string    `protobuf:"bytes,2,opt,name=statement_fingerprint,json=statementFingerprint,proto3" json:"statement_fingerprint,omitempty"`
	CollectedAt          time.Time `protobuf:"bytes,3,opt,name=collected_at,json=collectedAt,proto3,stdtime" json:"collected_at"`
}

func (m *StatementDiagnostics) Reset()         { *m = StatementDiagnostics{} }
func (m *StatementDiagnostics) String() string { return proto.CompactTextString(m) }
func (*StatementDiagnostics) ProtoMessage()    {}
func (*StatementDiagnostics) Descriptor() ([]byte, []int) {
	return fileDescriptor_status_c872ae209e16bf4e, []int{84}
}
func (m *StatementDiagnostics) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StatementDiagnostics) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *StatementDiagnostics) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StatementDiagnostics.Merge(dst, src)
}
func (m *StatementDiagnostics) XXX_Size() int {
	return m.Size()
}
func (m *StatementDiagnostics) XXX_DiscardUnknown() {
	xxx_messageInfo_StatementDiagnostics.DiscardUnknown(m)
}

var xxx_messageInfo_StatementDiagnostics proto.InternalMessageInfo

type StatementDiagnosticsRequest struct {
	StatementDiagnosticsId int64 `protobuf:"varint,1,opt,name=statement_diagnostics_id,json=statementDiagnosticsId,proto3" json:"statement_diagnostics_id,omitempty"`
}

func (m *StatementDiagnosticsRequest) Reset()         { *m = StatementDiagnosticsRequest{} }
func (m *StatementDiagnosticsRequest) String() string { return proto.CompactTextString(m) }
func (*StatementDiagnosticsRequest) ProtoMessage()    {}
func (*StatementDiagnosticsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_status_c872ae209e16bf4e, []int{85}
}
func (m *StatementDiagnosticsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StatementDiagnosticsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *StatementDiagnosticsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StatementDiagnosticsRequest.Merge(dst, src)
}
func (m *StatementDiagnosticsRequest) XXX_Size() int {
	return m.Size()
}
func (m *StatementDiagnosticsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_StatementDiagnosticsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_StatementDiagnosticsRequest proto.InternalMessageInfo

type StatementDiagnosticsResponse struct {
	Diagnostics *StatementDiagnostics `protobuf:"bytes,2,opt,name=diagnostics,proto3" json:"diagnostics,omitempty"`
}

func (m *StatementDiagnosticsResponse) Reset()         { *m = StatementDiagnosticsResponse{} }
func (m *StatementDiagnosticsResponse) String() string { return proto.CompactTextString(m) }
func (*StatementDiagnosticsResponse) ProtoMessage()    {}
func (*StatementDiagnosticsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_status_c872ae209e16bf4e, []int{86}
}
func (m *StatementDiagnosticsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StatementDiagnosticsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *StatementDiagnosticsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StatementDiagnosticsResponse.Merge(dst, src)
}
func (m *StatementDiagnosticsResponse) XXX_Size() int {
	return m.Size()
}
func (m *StatementDiagnosticsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_StatementDiagnosticsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_StatementDiagnosticsResponse proto.InternalMessageInfo

type JobRegistryStatusRequest struct {
	NodeId string `protobuf:"bytes,1,opt,name=node_id,json=nodeId,proto3" json:"node_id,omitempty"`
}

func (m *JobRegistryStatusRequest) Reset()         { *m = JobRegistryStatusRequest{} }
func (m *JobRegistryStatusRequest) String() string { return proto.CompactTextString(m) }
func (*JobRegistryStatusRequest) ProtoMessage()    {}
func (*JobRegistryStatusRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_status_c872ae209e16bf4e, []int{87}
}
func (m *JobRegistryStatusRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *JobRegistryStatusRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *JobRegistryStatusRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_JobRegistryStatusRequest.Merge(dst, src)
}
func (m *JobRegistryStatusRequest) XXX_Size() int {
	return m.Size()
}
func (m *JobRegistryStatusRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_JobRegistryStatusRequest.DiscardUnknown(m)
}

var xxx_messageInfo_JobRegistryStatusRequest proto.InternalMessageInfo

type JobRegistryStatusResponse struct {
	NodeID      github_com_cockroachdb_cockroach_pkg_roachpb.NodeID `protobuf:"varint,1,opt,name=node_id,json=nodeId,proto3,casttype=github.com/cockroachdb/cockroach/pkg/roachpb.NodeID" json:"node_id,omitempty"`
	RunningJobs []*JobRegistryStatusResponse_Job                    `protobuf:"bytes,2,rep,name=running_jobs,json=runningJobs,proto3" json:"running_jobs,omitempty"`
}

func (m *JobRegistryStatusResponse) Reset()         { *m = JobRegistryStatusResponse{} }
func (m *JobRegistryStatusResponse) String() string { return proto.CompactTextString(m) }
func (*JobRegistryStatusResponse) ProtoMessage()    {}
func (*JobRegistryStatusResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_status_c872ae209e16bf4e, []int{88}
}
func (m *JobRegistryStatusResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *JobRegistryStatusResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *JobRegistryStatusResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_JobRegistryStatusResponse.Merge(dst, src)
}
func (m *JobRegistryStatusResponse) XXX_Size() int {
	return m.Size()
}
func (m *JobRegistryStatusResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_JobRegistryStatusResponse.DiscardUnknown(m)
}

var xxx_messageInfo_JobRegistryStatusResponse proto.InternalMessageInfo

type JobRegistryStatusResponse_Job struct {
	Id int64 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
}

func (m *JobRegistryStatusResponse_Job) Reset()         { *m = JobRegistryStatusResponse_Job{} }
func (m *JobRegistryStatusResponse_Job) String() string { return proto.CompactTextString(m) }
func (*JobRegistryStatusResponse_Job) ProtoMessage()    {}
func (*JobRegistryStatusResponse_Job) Descriptor() ([]byte, []int) {
	return fileDescriptor_status_c872ae209e16bf4e, []int{88, 0}
}
func (m *JobRegistryStatusResponse_Job) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *JobRegistryStatusResponse_Job) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *JobRegistryStatusResponse_Job) XXX_Merge(src proto.Message) {
	xxx_messageInfo_JobRegistryStatusResponse_Job.Merge(dst, src)
}
func (m *JobRegistryStatusResponse_Job) XXX_Size() int {
	return m.Size()
}
func (m *JobRegistryStatusResponse_Job) XXX_DiscardUnknown() {
	xxx_messageInfo_JobRegistryStatusResponse_Job.DiscardUnknown(m)
}

var xxx_messageInfo_JobRegistryStatusResponse_Job proto.InternalMessageInfo

type JobStatusRequest struct {
	JobId int64 `protobuf:"varint,1,opt,name=job_id,json=jobId,proto3" json:"job_id,omitempty"`
}

func (m *JobStatusRequest) Reset()         { *m = JobStatusRequest{} }
func (m *JobStatusRequest) String() string { return proto.CompactTextString(m) }
func (*JobStatusRequest) ProtoMessage()    {}
func (*JobStatusRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_status_c872ae209e16bf4e, []int{89}
}
func (m *JobStatusRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *JobStatusRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *JobStatusRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_JobStatusRequest.Merge(dst, src)
}
func (m *JobStatusRequest) XXX_Size() int {
	return m.Size()
}
func (m *JobStatusRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_JobStatusRequest.DiscardUnknown(m)
}

var xxx_messageInfo_JobStatusRequest proto.InternalMessageInfo

type JobStatusResponse struct {
	Job *jobspb.Job `protobuf:"bytes,1,opt,name=job,proto3" json:"job,omitempty"`
}

func (m *JobStatusResponse) Reset()         { *m = JobStatusResponse{} }
func (m *JobStatusResponse) String() string { return proto.CompactTextString(m) }
func (*JobStatusResponse) ProtoMessage()    {}
func (*JobStatusResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_status_c872ae209e16bf4e, []int{90}
}
func (m *JobStatusResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *JobStatusResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *JobStatusResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_JobStatusResponse.Merge(dst, src)
}
func (m *JobStatusResponse) XXX_Size() int {
	return m.Size()
}
func (m *JobStatusResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_JobStatusResponse.DiscardUnknown(m)
}

var xxx_messageInfo_JobStatusResponse proto.InternalMessageInfo

func init() {
	proto.RegisterType((*CertificatesRequest)(nil), "cockroach.server.serverpb.CertificatesRequest")
	proto.RegisterType((*CertificateDetails)(nil), "cockroach.server.serverpb.CertificateDetails")
	proto.RegisterType((*CertificateDetails_Fields)(nil), "cockroach.server.serverpb.CertificateDetails.Fields")
	proto.RegisterType((*CertificatesResponse)(nil), "cockroach.server.serverpb.CertificatesResponse")
	proto.RegisterType((*DetailsRequest)(nil), "cockroach.server.serverpb.DetailsRequest")
	proto.RegisterType((*SystemInfo)(nil), "cockroach.server.serverpb.SystemInfo")
	proto.RegisterType((*DetailsResponse)(nil), "cockroach.server.serverpb.DetailsResponse")
	proto.RegisterType((*NodesRequest)(nil), "cockroach.server.serverpb.NodesRequest")
	proto.RegisterType((*NodesResponse)(nil), "cockroach.server.serverpb.NodesResponse")
	proto.RegisterMapType((map[github_com_cockroachdb_cockroach_pkg_roachpb.NodeID]kvserverpb.NodeLivenessStatus)(nil), "cockroach.server.serverpb.NodesResponse.LivenessByNodeIdEntry")
	proto.RegisterType((*NodesResponseExternal)(nil), "cockroach.server.serverpb.NodesResponseExternal")
	proto.RegisterMapType((map[github_com_cockroachdb_cockroach_pkg_roachpb.NodeID]kvserverpb.NodeLivenessStatus)(nil), "cockroach.server.serverpb.NodesResponseExternal.LivenessByNodeIdEntry")
	proto.RegisterType((*Locality)(nil), "cockroach.server.serverpb.Locality")
	proto.RegisterType((*Tier)(nil), "cockroach.server.serverpb.Tier")
	proto.RegisterType((*Version)(nil), "cockroach.server.serverpb.Version")
	proto.RegisterType((*NodeDescriptor)(nil), "cockroach.server.serverpb.NodeDescriptor")
	proto.RegisterType((*Percentiles)(nil), "cockroach.server.serverpb.Percentiles")
	proto.RegisterType((*StoreDescriptor)(nil), "cockroach.server.serverpb.StoreDescriptor")
	proto.RegisterType((*StoreStatus)(nil), "cockroach.server.serverpb.StoreStatus")
	proto.RegisterMapType((map[string]float64)(nil), "cockroach.server.serverpb.StoreStatus.MetricsEntry")
	proto.RegisterType((*NodeResponse)(nil), "cockroach.server.serverpb.NodeResponse")
	proto.RegisterMapType((map[github_com_cockroachdb_cockroach_pkg_roachpb.NodeID]NodeResponse_NetworkActivity)(nil), "cockroach.server.serverpb.NodeResponse.ActivityEntry")
	proto.RegisterMapType((map[github_com_cockroachdb_cockroach_pkg_roachpb.NodeID]int64)(nil), "cockroach.server.serverpb.NodeResponse.LatenciesEntry")
	proto.RegisterMapType((map[string]float64)(nil), "cockroach.server.serverpb.NodeResponse.MetricsEntry")
	proto.RegisterType((*NodeResponse_NetworkActivity)(nil), "cockroach.server.serverpb.NodeResponse.NetworkActivity")
	proto.RegisterType((*RegionsRequest)(nil), "cockroach.server.serverpb.RegionsRequest")
	proto.RegisterType((*RegionsResponse)(nil), "cockroach.server.serverpb.RegionsResponse")
	proto.RegisterMapType((map[string]*RegionsResponse_Region)(nil), "cockroach.server.serverpb.RegionsResponse.RegionsEntry")
	proto.RegisterType((*RegionsResponse_Region)(nil), "cockroach.server.serverpb.RegionsResponse.Region")
	proto.RegisterType((*NodeRequest)(nil), "cockroach.server.serverpb.NodeRequest")
	proto.RegisterType((*RaftState)(nil), "cockroach.server.serverpb.RaftState")
	proto.RegisterMapType((map[uint64]RaftState_Progress)(nil), "cockroach.server.serverpb.RaftState.ProgressEntry")
	proto.RegisterType((*RaftState_Progress)(nil), "cockroach.server.serverpb.RaftState.Progress")
	proto.RegisterType((*RangeProblems)(nil), "cockroach.server.serverpb.RangeProblems")
	proto.RegisterType((*RangeStatistics)(nil), "cockroach.server.serverpb.RangeStatistics")
	proto.RegisterType((*PrettySpan)(nil), "cockroach.server.serverpb.PrettySpan")
	proto.RegisterType((*RangeInfo)(nil), "cockroach.server.serverpb.RangeInfo")
	proto.RegisterType((*RangesRequest)(nil), "cockroach.server.serverpb.RangesRequest")
	proto.RegisterType((*RangesResponse)(nil), "cockroach.server.serverpb.RangesResponse")
	proto.RegisterType((*GossipRequest)(nil), "cockroach.server.serverpb.GossipRequest")
	proto.RegisterType((*EngineStatsInfo)(nil), "cockroach.server.serverpb.EngineStatsInfo")
	proto.RegisterType((*EngineStatsRequest)(nil), "cockroach.server.serverpb.EngineStatsRequest")
	proto.RegisterType((*EngineStatsResponse)(nil), "cockroach.server.serverpb.EngineStatsResponse")
	proto.RegisterType((*TraceEvent)(nil), "cockroach.server.serverpb.TraceEvent")
	proto.RegisterType((*AllocatorDryRun)(nil), "cockroach.server.serverpb.AllocatorDryRun")
	proto.RegisterType((*AllocatorRangeRequest)(nil), "cockroach.server.serverpb.AllocatorRangeRequest")
	proto.RegisterType((*AllocatorRangeResponse)(nil), "cockroach.server.serverpb.AllocatorRangeResponse")
	proto.RegisterType((*AllocatorRequest)(nil), "cockroach.server.serverpb.AllocatorRequest")
	proto.RegisterType((*AllocatorResponse)(nil), "cockroach.server.serverpb.AllocatorResponse")
	proto.RegisterType((*JSONResponse)(nil), "cockroach.server.serverpb.JSONResponse")
	proto.RegisterType((*ResponseError)(nil), "cockroach.server.serverpb.ResponseError")
	proto.RegisterType((*LogsRequest)(nil), "cockroach.server.serverpb.LogsRequest")
	proto.RegisterType((*LogEntriesResponse)(nil), "cockroach.server.serverpb.LogEntriesResponse")
	proto.RegisterType((*LogFilesListRequest)(nil), "cockroach.server.serverpb.LogFilesListRequest")
	proto.RegisterType((*LogFilesListResponse)(nil), "cockroach.server.serverpb.LogFilesListResponse")
	proto.RegisterType((*LogFileRequest)(nil), "cockroach.server.serverpb.LogFileRequest")
	proto.RegisterType((*StacksRequest)(nil), "cockroach.server.serverpb.StacksRequest")
	proto.RegisterType((*File)(nil), "cockroach.server.serverpb.File")
	proto.RegisterType((*GetFilesRequest)(nil), "cockroach.server.serverpb.GetFilesRequest")
	proto.RegisterType((*GetFilesResponse)(nil), "cockroach.server.serverpb.GetFilesResponse")
	proto.RegisterType((*ProfileRequest)(nil), "cockroach.server.serverpb.ProfileRequest")
	proto.RegisterType((*MetricsRequest)(nil), "cockroach.server.serverpb.MetricsRequest")
	proto.RegisterType((*RaftRangeNode)(nil), "cockroach.server.serverpb.RaftRangeNode")
	proto.RegisterType((*RaftRangeError)(nil), "cockroach.server.serverpb.RaftRangeError")
	proto.RegisterType((*RaftRangeStatus)(nil), "cockroach.server.serverpb.RaftRangeStatus")
	proto.RegisterType((*RaftDebugRequest)(nil), "cockroach.server.serverpb.RaftDebugRequest")
	proto.RegisterType((*RaftDebugResponse)(nil), "cockroach.server.serverpb.RaftDebugResponse")
	proto.RegisterMapType((map[github_com_cockroachdb_cockroach_pkg_roachpb.RangeID]RaftRangeStatus)(nil), "cockroach.server.serverpb.RaftDebugResponse.RangesEntry")
	proto.RegisterType((*TxnInfo)(nil), "cockroach.server.serverpb.TxnInfo")
	proto.RegisterType((*ActiveQuery)(nil), "cockroach.server.serverpb.ActiveQuery")
	proto.RegisterType((*ListSessionsRequest)(nil), "cockroach.server.serverpb.ListSessionsRequest")
	proto.RegisterType((*Session)(nil), "cockroach.server.serverpb.Session")
	proto.RegisterType((*ListSessionsError)(nil), "cockroach.server.serverpb.ListSessionsError")
	proto.RegisterType((*ListSessionsResponse)(nil), "cockroach.server.serverpb.ListSessionsResponse")
	proto.RegisterType((*CancelQueryRequest)(nil), "cockroach.server.serverpb.CancelQueryRequest")
	proto.RegisterType((*CancelQueryResponse)(nil), "cockroach.server.serverpb.CancelQueryResponse")
	proto.RegisterType((*CancelSessionRequest)(nil), "cockroach.server.serverpb.CancelSessionRequest")
	proto.RegisterType((*CancelSessionResponse)(nil), "cockroach.server.serverpb.CancelSessionResponse")
	proto.RegisterType((*SpanStatsRequest)(nil), "cockroach.server.serverpb.SpanStatsRequest")
	proto.RegisterType((*SpanStatsResponse)(nil), "cockroach.server.serverpb.SpanStatsResponse")
	proto.RegisterType((*ProblemRangesRequest)(nil), "cockroach.server.serverpb.ProblemRangesRequest")
	proto.RegisterType((*ProblemRangesResponse)(nil), "cockroach.server.serverpb.ProblemRangesResponse")
	proto.RegisterMapType((map[github_com_cockroachdb_cockroach_pkg_roachpb.NodeID]ProblemRangesResponse_NodeProblems)(nil), "cockroach.server.serverpb.ProblemRangesResponse.ProblemsByNodeIdEntry")
	proto.RegisterType((*ProblemRangesResponse_NodeProblems)(nil), "cockroach.server.serverpb.ProblemRangesResponse.NodeProblems")
	proto.RegisterType((*HotRangesRequest)(nil), "cockroach.server.serverpb.HotRangesRequest")
	proto.RegisterType((*HotRangesResponse)(nil), "cockroach.server.serverpb.HotRangesResponse")
	proto.RegisterMapType((map[github_com_cockroachdb_cockroach_pkg_roachpb.NodeID]HotRangesResponse_NodeResponse)(nil), "cockroach.server.serverpb.HotRangesResponse.HotRangesByNodeIdEntry")
	proto.RegisterType((*HotRangesResponse_HotRange)(nil), "cockroach.server.serverpb.HotRangesResponse.HotRange")
	proto.RegisterType((*HotRangesResponse_StoreResponse)(nil), "cockroach.server.serverpb.HotRangesResponse.StoreResponse")
	proto.RegisterType((*HotRangesResponse_NodeResponse)(nil), "cockroach.server.serverpb.HotRangesResponse.NodeResponse")
	proto.RegisterType((*RangeRequest)(nil), "cockroach.server.serverpb.RangeRequest")
	proto.RegisterType((*RangeResponse)(nil), "cockroach.server.serverpb.RangeResponse")
	proto.RegisterMapType((map[github_com_cockroachdb_cockroach_pkg_roachpb.NodeID]RangeResponse_NodeResponse)(nil), "cockroach.server.serverpb.RangeResponse.ResponsesByNodeIdEntry")
	proto.RegisterType((*RangeResponse_NodeResponse)(nil), "cockroach.server.serverpb.RangeResponse.NodeResponse")
	proto.RegisterType((*DiagnosticsRequest)(nil), "cockroach.server.serverpb.DiagnosticsRequest")
	proto.RegisterType((*StoresRequest)(nil), "cockroach.server.serverpb.StoresRequest")
	proto.RegisterType((*StoreDetails)(nil), "cockroach.server.serverpb.StoreDetails")
	proto.RegisterType((*StoresResponse)(nil), "cockroach.server.serverpb.StoresResponse")
	proto.RegisterType((*StatementsRequest)(nil), "cockroach.server.serverpb.StatementsRequest")
	proto.RegisterType((*StatementsResponse)(nil), "cockroach.server.serverpb.StatementsResponse")
	proto.RegisterType((*StatementsResponse_ExtendedStatementStatisticsKey)(nil), "cockroach.server.serverpb.StatementsResponse.ExtendedStatementStatisticsKey")
	proto.RegisterType((*StatementsResponse_CollectedStatementStatistics)(nil), "cockroach.server.serverpb.StatementsResponse.CollectedStatementStatistics")
	proto.RegisterType((*StatementsResponse_ExtendedCollectedTransactionStatistics)(nil), "cockroach.server.serverpb.StatementsResponse.ExtendedCollectedTransactionStatistics")
	proto.RegisterType((*StatementDiagnosticsReport)(nil), "cockroach.server.serverpb.StatementDiagnosticsReport")
	proto.RegisterType((*CreateStatementDiagnosticsReportRequest)(nil), "cockroach.server.serverpb.CreateStatementDiagnosticsReportRequest")
	proto.RegisterType((*CreateStatementDiagnosticsReportResponse)(nil), "cockroach.server.serverpb.CreateStatementDiagnosticsReportResponse")
	proto.RegisterType((*StatementDiagnosticsReportsRequest)(nil), "cockroach.server.serverpb.StatementDiagnosticsReportsRequest")
	proto.RegisterType((*StatementDiagnosticsReportsResponse)(nil), "cockroach.server.serverpb.StatementDiagnosticsReportsResponse")
	proto.RegisterType((*StatementDiagnostics)(nil), "cockroach.server.serverpb.StatementDiagnostics")
	proto.RegisterType((*StatementDiagnosticsRequest)(nil), "cockroach.server.serverpb.StatementDiagnosticsRequest")
	proto.RegisterType((*StatementDiagnosticsResponse)(nil), "cockroach.server.serverpb.StatementDiagnosticsResponse")
	proto.RegisterType((*JobRegistryStatusRequest)(nil), "cockroach.server.serverpb.JobRegistryStatusRequest")
	proto.RegisterType((*JobRegistryStatusResponse)(nil), "cockroach.server.serverpb.JobRegistryStatusResponse")
	proto.RegisterType((*JobRegistryStatusResponse_Job)(nil), "cockroach.server.serverpb.JobRegistryStatusResponse.Job")
	proto.RegisterType((*JobStatusRequest)(nil), "cockroach.server.serverpb.JobStatusRequest")
	proto.RegisterType((*JobStatusResponse)(nil), "cockroach.server.serverpb.JobStatusResponse")
	proto.RegisterEnum("cockroach.server.serverpb.StacksType", StacksType_name, StacksType_value)
	proto.RegisterEnum("cockroach.server.serverpb.FileType", FileType_name, FileType_value)
	proto.RegisterEnum("cockroach.server.serverpb.CertificateDetails_CertificateType", CertificateDetails_CertificateType_name, CertificateDetails_CertificateType_value)
	proto.RegisterEnum("cockroach.server.serverpb.ProfileRequest_Type", ProfileRequest_Type_name, ProfileRequest_Type_value)
	proto.RegisterEnum("cockroach.server.serverpb.ActiveQuery_Phase", ActiveQuery_Phase_name, ActiveQuery_Phase_value)
}
func (this *PrettySpan) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PrettySpan)
	if !ok {
		that2, ok := that.(PrettySpan)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.StartKey != that1.StartKey {
		return false
	}
	if this.EndKey != that1.EndKey {
		return false
	}
	return true
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// StatusClient is the client API for Status service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type StatusClient interface {
	Certificates(ctx context.Context, in *CertificatesRequest, opts ...grpc.CallOption) (*CertificatesResponse, error)
	Details(ctx context.Context, in *DetailsRequest, opts ...grpc.CallOption) (*DetailsResponse, error)
	// Don't introduce additional usages of this RPC. See #50707 for more details.
	// The underlying response type is something we're looking to get rid of.
	Nodes(ctx context.Context, in *NodesRequest, opts ...grpc.CallOption) (*NodesResponse, error)
	Node(ctx context.Context, in *NodeRequest, opts ...grpc.CallOption) (*statuspb.NodeStatus, error)
	NodesUI(ctx context.Context, in *NodesRequest, opts ...grpc.CallOption) (*NodesResponseExternal, error)
	NodeUI(ctx context.Context, in *NodeRequest, opts ...grpc.CallOption) (*NodeResponse, error)
	// RaftDebug requests internal details about Raft.
	RaftDebug(ctx context.Context, in *RaftDebugRequest, opts ...grpc.CallOption) (*RaftDebugResponse, error)
	Ranges(ctx context.Context, in *RangesRequest, opts ...grpc.CallOption) (*RangesResponse, error)
	Gossip(ctx context.Context, in *GossipRequest, opts ...grpc.CallOption) (*gossip.InfoStatus, error)
	EngineStats(ctx context.Context, in *EngineStatsRequest, opts ...grpc.CallOption) (*EngineStatsResponse, error)
	Allocator(ctx context.Context, in *AllocatorRequest, opts ...grpc.CallOption) (*AllocatorResponse, error)
	AllocatorRange(ctx context.Context, in *AllocatorRangeRequest, opts ...grpc.CallOption) (*AllocatorRangeResponse, error)
	ListSessions(ctx context.Context, in *ListSessionsRequest, opts ...grpc.CallOption) (*ListSessionsResponse, error)
	ListLocalSessions(ctx context.Context, in *ListSessionsRequest, opts ...grpc.CallOption) (*ListSessionsResponse, error)
	CancelQuery(ctx context.Context, in *CancelQueryRequest, opts ...grpc.CallOption) (*CancelQueryResponse, error)
	CancelSession(ctx context.Context, in *CancelSessionRequest, opts ...grpc.CallOption) (*CancelSessionResponse, error)
	// SpanStats accepts a key span and node ID, and returns a set of stats
	// summed from all ranges on the stores on that node which contain keys
	// in that span. This is designed to compute stats specific to a SQL table:
	// it will be called with the highest/lowest key for a SQL table, and return
	// information about the resources on a node used by that table.
	SpanStats(ctx context.Context, in *SpanStatsRequest, opts ...grpc.CallOption) (*SpanStatsResponse, error)
	Stacks(ctx context.Context, in *StacksRequest, opts ...grpc.CallOption) (*JSONResponse, error)
	Profile(ctx context.Context, in *ProfileRequest, opts ...grpc.CallOption) (*JSONResponse, error)
	Metrics(ctx context.Context, in *MetricsRequest, opts ...grpc.CallOption) (*JSONResponse, error)
	GetFiles(ctx context.Context, in *GetFilesRequest, opts ...grpc.CallOption) (*GetFilesResponse, error)
	LogFilesList(ctx context.Context, in *LogFilesListRequest, opts ...grpc.CallOption) (*LogFilesListResponse, error)
	LogFile(ctx context.Context, in *LogFileRequest, opts ...grpc.CallOption) (*LogEntriesResponse, error)
	Logs(ctx context.Context, in *LogsRequest, opts ...grpc.CallOption) (*LogEntriesResponse, error)
	ProblemRanges(ctx context.Context, in *ProblemRangesRequest, opts ...grpc.CallOption) (*ProblemRangesResponse, error)
	HotRanges(ctx context.Context, in *HotRangesRequest, opts ...grpc.CallOption) (*HotRangesResponse, error)
	Range(ctx context.Context, in *RangeRequest, opts ...grpc.CallOption) (*RangeResponse, error)
	Diagnostics(ctx context.Context, in *DiagnosticsRequest, opts ...grpc.CallOption) (*diagnosticspb.DiagnosticReport, error)
	Stores(ctx context.Context, in *StoresRequest, opts ...grpc.CallOption) (*StoresResponse, error)
	Statements(ctx context.Context, in *StatementsRequest, opts ...grpc.CallOption) (*StatementsResponse, error)
	CreateStatementDiagnosticsReport(ctx context.Context, in *CreateStatementDiagnosticsReportRequest, opts ...grpc.CallOption) (*CreateStatementDiagnosticsReportResponse, error)
	StatementDiagnosticsRequests(ctx context.Context, in *StatementDiagnosticsReportsRequest, opts ...grpc.CallOption) (*StatementDiagnosticsReportsResponse, error)
	StatementDiagnostics(ctx context.Context, in *StatementDiagnosticsRequest, opts ...grpc.CallOption) (*StatementDiagnosticsResponse, error)
	JobRegistryStatus(ctx context.Context, in *JobRegistryStatusRequest, opts ...grpc.CallOption) (*JobRegistryStatusResponse, error)
	JobStatus(ctx context.Context, in *JobStatusRequest, opts ...grpc.CallOption) (*JobStatusResponse, error)
}

type statusClient struct {
	cc *grpc.ClientConn
}

func NewStatusClient(cc *grpc.ClientConn) StatusClient {
	return &statusClient{cc}
}

func (c *statusClient) Certificates(ctx context.Context, in *CertificatesRequest, opts ...grpc.CallOption) (*CertificatesResponse, error) {
	out := new(CertificatesResponse)
	err := c.cc.Invoke(ctx, "/cockroach.server.serverpb.Status/Certificates", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *statusClient) Details(ctx context.Context, in *DetailsRequest, opts ...grpc.CallOption) (*DetailsResponse, error) {
	out := new(DetailsResponse)
	err := c.cc.Invoke(ctx, "/cockroach.server.serverpb.Status/Details", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *statusClient) Nodes(ctx context.Context, in *NodesRequest, opts ...grpc.CallOption) (*NodesResponse, error) {
	out := new(NodesResponse)
	err := c.cc.Invoke(ctx, "/cockroach.server.serverpb.Status/Nodes", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *statusClient) Node(ctx context.Context, in *NodeRequest, opts ...grpc.CallOption) (*statuspb.NodeStatus, error) {
	out := new(statuspb.NodeStatus)
	err := c.cc.Invoke(ctx, "/cockroach.server.serverpb.Status/Node", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *statusClient) NodesUI(ctx context.Context, in *NodesRequest, opts ...grpc.CallOption) (*NodesResponseExternal, error) {
	out := new(NodesResponseExternal)
	err := c.cc.Invoke(ctx, "/cockroach.server.serverpb.Status/NodesUI", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *statusClient) NodeUI(ctx context.Context, in *NodeRequest, opts ...grpc.CallOption) (*NodeResponse, error) {
	out := new(NodeResponse)
	err := c.cc.Invoke(ctx, "/cockroach.server.serverpb.Status/NodeUI", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *statusClient) RaftDebug(ctx context.Context, in *RaftDebugRequest, opts ...grpc.CallOption) (*RaftDebugResponse, error) {
	out := new(RaftDebugResponse)
	err := c.cc.Invoke(ctx, "/cockroach.server.serverpb.Status/RaftDebug", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *statusClient) Ranges(ctx context.Context, in *RangesRequest, opts ...grpc.CallOption) (*RangesResponse, error) {
	out := new(RangesResponse)
	err := c.cc.Invoke(ctx, "/cockroach.server.serverpb.Status/Ranges", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *statusClient) Gossip(ctx context.Context, in *GossipRequest, opts ...grpc.CallOption) (*gossip.InfoStatus, error) {
	out := new(gossip.InfoStatus)
	err := c.cc.Invoke(ctx, "/cockroach.server.serverpb.Status/Gossip", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *statusClient) EngineStats(ctx context.Context, in *EngineStatsRequest, opts ...grpc.CallOption) (*EngineStatsResponse, error) {
	out := new(EngineStatsResponse)
	err := c.cc.Invoke(ctx, "/cockroach.server.serverpb.Status/EngineStats", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *statusClient) Allocator(ctx context.Context, in *AllocatorRequest, opts ...grpc.CallOption) (*AllocatorResponse, error) {
	out := new(AllocatorResponse)
	err := c.cc.Invoke(ctx, "/cockroach.server.serverpb.Status/Allocator", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *statusClient) AllocatorRange(ctx context.Context, in *AllocatorRangeRequest, opts ...grpc.CallOption) (*AllocatorRangeResponse, error) {
	out := new(AllocatorRangeResponse)
	err := c.cc.Invoke(ctx, "/cockroach.server.serverpb.Status/AllocatorRange", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *statusClient) ListSessions(ctx context.Context, in *ListSessionsRequest, opts ...grpc.CallOption) (*ListSessionsResponse, error) {
	out := new(ListSessionsResponse)
	err := c.cc.Invoke(ctx, "/cockroach.server.serverpb.Status/ListSessions", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *statusClient) ListLocalSessions(ctx context.Context, in *ListSessionsRequest, opts ...grpc.CallOption) (*ListSessionsResponse, error) {
	out := new(ListSessionsResponse)
	err := c.cc.Invoke(ctx, "/cockroach.server.serverpb.Status/ListLocalSessions", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *statusClient) CancelQuery(ctx context.Context, in *CancelQueryRequest, opts ...grpc.CallOption) (*CancelQueryResponse, error) {
	out := new(CancelQueryResponse)
	err := c.cc.Invoke(ctx, "/cockroach.server.serverpb.Status/CancelQuery", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *statusClient) CancelSession(ctx context.Context, in *CancelSessionRequest, opts ...grpc.CallOption) (*CancelSessionResponse, error) {
	out := new(CancelSessionResponse)
	err := c.cc.Invoke(ctx, "/cockroach.server.serverpb.Status/CancelSession", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *statusClient) SpanStats(ctx context.Context, in *SpanStatsRequest, opts ...grpc.CallOption) (*SpanStatsResponse, error) {
	out := new(SpanStatsResponse)
	err := c.cc.Invoke(ctx, "/cockroach.server.serverpb.Status/SpanStats", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *statusClient) Stacks(ctx context.Context, in *StacksRequest, opts ...grpc.CallOption) (*JSONResponse, error) {
	out := new(JSONResponse)
	err := c.cc.Invoke(ctx, "/cockroach.server.serverpb.Status/Stacks", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *statusClient) Profile(ctx context.Context, in *ProfileRequest, opts ...grpc.CallOption) (*JSONResponse, error) {
	out := new(JSONResponse)
	err := c.cc.Invoke(ctx, "/cockroach.server.serverpb.Status/Profile", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *statusClient) Metrics(ctx context.Context, in *MetricsRequest, opts ...grpc.CallOption) (*JSONResponse, error) {
	out := new(JSONResponse)
	err := c.cc.Invoke(ctx, "/cockroach.server.serverpb.Status/Metrics", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *statusClient) GetFiles(ctx context.Context, in *GetFilesRequest, opts ...grpc.CallOption) (*GetFilesResponse, error) {
	out := new(GetFilesResponse)
	err := c.cc.Invoke(ctx, "/cockroach.server.serverpb.Status/GetFiles", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *statusClient) LogFilesList(ctx context.Context, in *LogFilesListRequest, opts ...grpc.CallOption) (*LogFilesListResponse, error) {
	out := new(LogFilesListResponse)
	err := c.cc.Invoke(ctx, "/cockroach.server.serverpb.Status/LogFilesList", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *statusClient) LogFile(ctx context.Context, in *LogFileRequest, opts ...grpc.CallOption) (*LogEntriesResponse, error) {
	out := new(LogEntriesResponse)
	err := c.cc.Invoke(ctx, "/cockroach.server.serverpb.Status/LogFile", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *statusClient) Logs(ctx context.Context, in *LogsRequest, opts ...grpc.CallOption) (*LogEntriesResponse, error) {
	out := new(LogEntriesResponse)
	err := c.cc.Invoke(ctx, "/cockroach.server.serverpb.Status/Logs", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *statusClient) ProblemRanges(ctx context.Context, in *ProblemRangesRequest, opts ...grpc.CallOption) (*ProblemRangesResponse, error) {
	out := new(ProblemRangesResponse)
	err := c.cc.Invoke(ctx, "/cockroach.server.serverpb.Status/ProblemRanges", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *statusClient) HotRanges(ctx context.Context, in *HotRangesRequest, opts ...grpc.CallOption) (*HotRangesResponse, error) {
	out := new(HotRangesResponse)
	err := c.cc.Invoke(ctx, "/cockroach.server.serverpb.Status/HotRanges", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *statusClient) Range(ctx context.Context, in *RangeRequest, opts ...grpc.CallOption) (*RangeResponse, error) {
	out := new(RangeResponse)
	err := c.cc.Invoke(ctx, "/cockroach.server.serverpb.Status/Range", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *statusClient) Diagnostics(ctx context.Context, in *DiagnosticsRequest, opts ...grpc.CallOption) (*diagnosticspb.DiagnosticReport, error) {
	out := new(diagnosticspb.DiagnosticReport)
	err := c.cc.Invoke(ctx, "/cockroach.server.serverpb.Status/Diagnostics", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *statusClient) Stores(ctx context.Context, in *StoresRequest, opts ...grpc.CallOption) (*StoresResponse, error) {
	out := new(StoresResponse)
	err := c.cc.Invoke(ctx, "/cockroach.server.serverpb.Status/Stores", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *statusClient) Statements(ctx context.Context, in *StatementsRequest, opts ...grpc.CallOption) (*StatementsResponse, error) {
	out := new(StatementsResponse)
	err := c.cc.Invoke(ctx, "/cockroach.server.serverpb.Status/Statements", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *statusClient) CreateStatementDiagnosticsReport(ctx context.Context, in *CreateStatementDiagnosticsReportRequest, opts ...grpc.CallOption) (*CreateStatementDiagnosticsReportResponse, error) {
	out := new(CreateStatementDiagnosticsReportResponse)
	err := c.cc.Invoke(ctx, "/cockroach.server.serverpb.Status/CreateStatementDiagnosticsReport", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *statusClient) StatementDiagnosticsRequests(ctx context.Context, in *StatementDiagnosticsReportsRequest, opts ...grpc.CallOption) (*StatementDiagnosticsReportsResponse, error) {
	out := new(StatementDiagnosticsReportsResponse)
	err := c.cc.Invoke(ctx, "/cockroach.server.serverpb.Status/StatementDiagnosticsRequests", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *statusClient) StatementDiagnostics(ctx context.Context, in *StatementDiagnosticsRequest, opts ...grpc.CallOption) (*StatementDiagnosticsResponse, error) {
	out := new(StatementDiagnosticsResponse)
	err := c.cc.Invoke(ctx, "/cockroach.server.serverpb.Status/StatementDiagnostics", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *statusClient) JobRegistryStatus(ctx context.Context, in *JobRegistryStatusRequest, opts ...grpc.CallOption) (*JobRegistryStatusResponse, error) {
	out := new(JobRegistryStatusResponse)
	err := c.cc.Invoke(ctx, "/cockroach.server.serverpb.Status/JobRegistryStatus", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *statusClient) JobStatus(ctx context.Context, in *JobStatusRequest, opts ...grpc.CallOption) (*JobStatusResponse, error) {
	out := new(JobStatusResponse)
	err := c.cc.Invoke(ctx, "/cockroach.server.serverpb.Status/JobStatus", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// StatusServer is the server API for Status service.
type StatusServer interface {
	Certificates(context.Context, *CertificatesRequest) (*CertificatesResponse, error)
	Details(context.Context, *DetailsRequest) (*DetailsResponse, error)
	// Don't introduce additional usages of this RPC. See #50707 for more details.
	// The underlying response type is something we're looking to get rid of.
	Nodes(context.Context, *NodesRequest) (*NodesResponse, error)
	Node(context.Context, *NodeRequest) (*statuspb.NodeStatus, error)
	NodesUI(context.Context, *NodesRequest) (*NodesResponseExternal, error)
	NodeUI(context.Context, *NodeRequest) (*NodeResponse, error)
	// RaftDebug requests internal details about Raft.
	RaftDebug(context.Context, *RaftDebugRequest) (*RaftDebugResponse, error)
	Ranges(context.Context, *RangesRequest) (*RangesResponse, error)
	Gossip(context.Context, *GossipRequest) (*gossip.InfoStatus, error)
	EngineStats(context.Context, *EngineStatsRequest) (*EngineStatsResponse, error)
	Allocator(context.Context, *AllocatorRequest) (*AllocatorResponse, error)
	AllocatorRange(context.Context, *AllocatorRangeRequest) (*AllocatorRangeResponse, error)
	ListSessions(context.Context, *ListSessionsRequest) (*ListSessionsResponse, error)
	ListLocalSessions(context.Context, *ListSessionsRequest) (*ListSessionsResponse, error)
	CancelQuery(context.Context, *CancelQueryRequest) (*CancelQueryResponse, error)
	CancelSession(context.Context, *CancelSessionRequest) (*CancelSessionResponse, error)
	// SpanStats accepts a key span and node ID, and returns a set of stats
	// summed from all ranges on the stores on that node which contain keys
	// in that span. This is designed to compute stats specific to a SQL table:
	// it will be called with the highest/lowest key for a SQL table, and return
	// information about the resources on a node used by that table.
	SpanStats(context.Context, *SpanStatsRequest) (*SpanStatsResponse, error)
	Stacks(context.Context, *StacksRequest) (*JSONResponse, error)
	Profile(context.Context, *ProfileRequest) (*JSONResponse, error)
	Metrics(context.Context, *MetricsRequest) (*JSONResponse, error)
	GetFiles(context.Context, *GetFilesRequest) (*GetFilesResponse, error)
	LogFilesList(context.Context, *LogFilesListRequest) (*LogFilesListResponse, error)
	LogFile(context.Context, *LogFileRequest) (*LogEntriesResponse, error)
	Logs(context.Context, *LogsRequest) (*LogEntriesResponse, error)
	ProblemRanges(context.Context, *ProblemRangesRequest) (*ProblemRangesResponse, error)
	HotRanges(context.Context, *HotRangesRequest) (*HotRangesResponse, error)
	Range(context.Context, *RangeRequest) (*RangeResponse, error)
	Diagnostics(context.Context, *DiagnosticsRequest) (*diagnosticspb.DiagnosticReport, error)
	Stores(context.Context, *StoresRequest) (*StoresResponse, error)
	Statements(context.Context, *StatementsRequest) (*StatementsResponse, error)
	CreateStatementDiagnosticsReport(context.Context, *CreateStatementDiagnosticsReportRequest) (*CreateStatementDiagnosticsReportResponse, error)
	StatementDiagnosticsRequests(context.Context, *StatementDiagnosticsReportsRequest) (*StatementDiagnosticsReportsResponse, error)
	StatementDiagnostics(context.Context, *StatementDiagnosticsRequest) (*StatementDiagnosticsResponse, error)
	JobRegistryStatus(context.Context, *JobRegistryStatusRequest) (*JobRegistryStatusResponse, error)
	JobStatus(context.Context, *JobStatusRequest) (*JobStatusResponse, error)
}

func RegisterStatusServer(s *grpc.Server, srv StatusServer) {
	s.RegisterService(&_Status_serviceDesc, srv)
}

func _Status_Certificates_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CertificatesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StatusServer).Certificates(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cockroach.server.serverpb.Status/Certificates",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StatusServer).Certificates(ctx, req.(*CertificatesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Status_Details_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DetailsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StatusServer).Details(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cockroach.server.serverpb.Status/Details",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StatusServer).Details(ctx, req.(*DetailsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Status_Nodes_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NodesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StatusServer).Nodes(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cockroach.server.serverpb.Status/Nodes",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StatusServer).Nodes(ctx, req.(*NodesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Status_Node_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NodeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StatusServer).Node(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cockroach.server.serverpb.Status/Node",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StatusServer).Node(ctx, req.(*NodeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Status_NodesUI_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NodesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StatusServer).NodesUI(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cockroach.server.serverpb.Status/NodesUI",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StatusServer).NodesUI(ctx, req.(*NodesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Status_NodeUI_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NodeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StatusServer).NodeUI(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cockroach.server.serverpb.Status/NodeUI",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StatusServer).NodeUI(ctx, req.(*NodeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Status_RaftDebug_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RaftDebugRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StatusServer).RaftDebug(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cockroach.server.serverpb.Status/RaftDebug",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StatusServer).RaftDebug(ctx, req.(*RaftDebugRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Status_Ranges_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RangesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StatusServer).Ranges(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cockroach.server.serverpb.Status/Ranges",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StatusServer).Ranges(ctx, req.(*RangesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Status_Gossip_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GossipRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StatusServer).Gossip(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cockroach.server.serverpb.Status/Gossip",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StatusServer).Gossip(ctx, req.(*GossipRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Status_EngineStats_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EngineStatsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StatusServer).EngineStats(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cockroach.server.serverpb.Status/EngineStats",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StatusServer).EngineStats(ctx, req.(*EngineStatsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Status_Allocator_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AllocatorRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StatusServer).Allocator(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cockroach.server.serverpb.Status/Allocator",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StatusServer).Allocator(ctx, req.(*AllocatorRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Status_AllocatorRange_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AllocatorRangeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StatusServer).AllocatorRange(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cockroach.server.serverpb.Status/AllocatorRange",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StatusServer).AllocatorRange(ctx, req.(*AllocatorRangeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Status_ListSessions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListSessionsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StatusServer).ListSessions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cockroach.server.serverpb.Status/ListSessions",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StatusServer).ListSessions(ctx, req.(*ListSessionsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Status_ListLocalSessions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListSessionsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StatusServer).ListLocalSessions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cockroach.server.serverpb.Status/ListLocalSessions",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StatusServer).ListLocalSessions(ctx, req.(*ListSessionsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Status_CancelQuery_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CancelQueryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StatusServer).CancelQuery(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cockroach.server.serverpb.Status/CancelQuery",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StatusServer).CancelQuery(ctx, req.(*CancelQueryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Status_CancelSession_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CancelSessionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StatusServer).CancelSession(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cockroach.server.serverpb.Status/CancelSession",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StatusServer).CancelSession(ctx, req.(*CancelSessionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Status_SpanStats_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SpanStatsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StatusServer).SpanStats(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cockroach.server.serverpb.Status/SpanStats",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StatusServer).SpanStats(ctx, req.(*SpanStatsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Status_Stacks_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StacksRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StatusServer).Stacks(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cockroach.server.serverpb.Status/Stacks",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StatusServer).Stacks(ctx, req.(*StacksRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Status_Profile_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ProfileRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StatusServer).Profile(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cockroach.server.serverpb.Status/Profile",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StatusServer).Profile(ctx, req.(*ProfileRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Status_Metrics_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MetricsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StatusServer).Metrics(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cockroach.server.serverpb.Status/Metrics",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StatusServer).Metrics(ctx, req.(*MetricsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Status_GetFiles_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetFilesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StatusServer).GetFiles(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cockroach.server.serverpb.Status/GetFiles",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StatusServer).GetFiles(ctx, req.(*GetFilesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Status_LogFilesList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LogFilesListRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StatusServer).LogFilesList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cockroach.server.serverpb.Status/LogFilesList",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StatusServer).LogFilesList(ctx, req.(*LogFilesListRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Status_LogFile_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LogFileRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StatusServer).LogFile(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cockroach.server.serverpb.Status/LogFile",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StatusServer).LogFile(ctx, req.(*LogFileRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Status_Logs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LogsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StatusServer).Logs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cockroach.server.serverpb.Status/Logs",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StatusServer).Logs(ctx, req.(*LogsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Status_ProblemRanges_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ProblemRangesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StatusServer).ProblemRanges(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cockroach.server.serverpb.Status/ProblemRanges",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StatusServer).ProblemRanges(ctx, req.(*ProblemRangesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Status_HotRanges_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HotRangesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StatusServer).HotRanges(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cockroach.server.serverpb.Status/HotRanges",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StatusServer).HotRanges(ctx, req.(*HotRangesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Status_Range_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RangeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StatusServer).Range(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cockroach.server.serverpb.Status/Range",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StatusServer).Range(ctx, req.(*RangeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Status_Diagnostics_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DiagnosticsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StatusServer).Diagnostics(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cockroach.server.serverpb.Status/Diagnostics",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StatusServer).Diagnostics(ctx, req.(*DiagnosticsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Status_Stores_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StoresRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StatusServer).Stores(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cockroach.server.serverpb.Status/Stores",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StatusServer).Stores(ctx, req.(*StoresRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Status_Statements_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StatementsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StatusServer).Statements(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cockroach.server.serverpb.Status/Statements",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StatusServer).Statements(ctx, req.(*StatementsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Status_CreateStatementDiagnosticsReport_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateStatementDiagnosticsReportRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StatusServer).CreateStatementDiagnosticsReport(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cockroach.server.serverpb.Status/CreateStatementDiagnosticsReport",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StatusServer).CreateStatementDiagnosticsReport(ctx, req.(*CreateStatementDiagnosticsReportRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Status_StatementDiagnosticsRequests_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StatementDiagnosticsReportsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StatusServer).StatementDiagnosticsRequests(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cockroach.server.serverpb.Status/StatementDiagnosticsRequests",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StatusServer).StatementDiagnosticsRequests(ctx, req.(*StatementDiagnosticsReportsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Status_StatementDiagnostics_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StatementDiagnosticsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StatusServer).StatementDiagnostics(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cockroach.server.serverpb.Status/StatementDiagnostics",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StatusServer).StatementDiagnostics(ctx, req.(*StatementDiagnosticsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Status_JobRegistryStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(JobRegistryStatusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StatusServer).JobRegistryStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cockroach.server.serverpb.Status/JobRegistryStatus",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StatusServer).JobRegistryStatus(ctx, req.(*JobRegistryStatusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Status_JobStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(JobStatusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StatusServer).JobStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cockroach.server.serverpb.Status/JobStatus",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StatusServer).JobStatus(ctx, req.(*JobStatusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _Status_serviceDesc = grpc.ServiceDesc{
	ServiceName: "cockroach.server.serverpb.Status",
	HandlerType: (*StatusServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Certificates",
			Handler:    _Status_Certificates_Handler,
		},
		{
			MethodName: "Details",
			Handler:    _Status_Details_Handler,
		},
		{
			MethodName: "Nodes",
			Handler:    _Status_Nodes_Handler,
		},
		{
			MethodName: "Node",
			Handler:    _Status_Node_Handler,
		},
		{
			MethodName: "NodesUI",
			Handler:    _Status_NodesUI_Handler,
		},
		{
			MethodName: "NodeUI",
			Handler:    _Status_NodeUI_Handler,
		},
		{
			MethodName: "RaftDebug",
			Handler:    _Status_RaftDebug_Handler,
		},
		{
			MethodName: "Ranges",
			Handler:    _Status_Ranges_Handler,
		},
		{
			MethodName: "Gossip",
			Handler:    _Status_Gossip_Handler,
		},
		{
			MethodName: "EngineStats",
			Handler:    _Status_EngineStats_Handler,
		},
		{
			MethodName: "Allocator",
			Handler:    _Status_Allocator_Handler,
		},
		{
			MethodName: "AllocatorRange",
			Handler:    _Status_AllocatorRange_Handler,
		},
		{
			MethodName: "ListSessions",
			Handler:    _Status_ListSessions_Handler,
		},
		{
			MethodName: "ListLocalSessions",
			Handler:    _Status_ListLocalSessions_Handler,
		},
		{
			MethodName: "CancelQuery",
			Handler:    _Status_CancelQuery_Handler,
		},
		{
			MethodName: "CancelSession",
			Handler:    _Status_CancelSession_Handler,
		},
		{
			MethodName: "SpanStats",
			Handler:    _Status_SpanStats_Handler,
		},
		{
			MethodName: "Stacks",
			Handler:    _Status_Stacks_Handler,
		},
		{
			MethodName: "Profile",
			Handler:    _Status_Profile_Handler,
		},
		{
			MethodName: "Metrics",
			Handler:    _Status_Metrics_Handler,
		},
		{
			MethodName: "GetFiles",
			Handler:    _Status_GetFiles_Handler,
		},
		{
			MethodName: "LogFilesList",
			Handler:    _Status_LogFilesList_Handler,
		},
		{
			MethodName: "LogFile",
			Handler:    _Status_LogFile_Handler,
		},
		{
			MethodName: "Logs",
			Handler:    _Status_Logs_Handler,
		},
		{
			MethodName: "ProblemRanges",
			Handler:    _Status_ProblemRanges_Handler,
		},
		{
			MethodName: "HotRanges",
			Handler:    _Status_HotRanges_Handler,
		},
		{
			MethodName: "Range",
			Handler:    _Status_Range_Handler,
		},
		{
			MethodName: "Diagnostics",
			Handler:    _Status_Diagnostics_Handler,
		},
		{
			MethodName: "Stores",
			Handler:    _Status_Stores_Handler,
		},
		{
			MethodName: "Statements",
			Handler:    _Status_Statements_Handler,
		},
		{
			MethodName: "CreateStatementDiagnosticsReport",
			Handler:    _Status_CreateStatementDiagnosticsReport_Handler,
		},
		{
			MethodName: "StatementDiagnosticsRequests",
			Handler:    _Status_StatementDiagnosticsRequests_Handler,
		},
		{
			MethodName: "StatementDiagnostics",
			Handler:    _Status_StatementDiagnostics_Handler,
		},
		{
			MethodName: "JobRegistryStatus",
			Handler:    _Status_JobRegistryStatus_Handler,
		},
		{
			MethodName: "JobStatus",
			Handler:    _Status_JobStatus_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "server/serverpb/status.proto",
}

func (m *CertificatesRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CertificatesRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.NodeId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintStatus(dAtA, i, uint64(len(m.NodeId)))
		i += copy(dAtA[i:], m.NodeId)
	}
	return i, nil
}

func (m *CertificateDetails) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CertificateDetails) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Type != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintStatus(dAtA, i, uint64(m.Type))
	}
	if len(m.ErrorMessage) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintStatus(dAtA, i, uint64(len(m.ErrorMessage)))
		i += copy(dAtA[i:], m.ErrorMessage)
	}
	if len(m.Data) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintStatus(dAtA, i, uint64(len(m.Data)))
		i += copy(dAtA[i:], m.Data)
	}
	if len(m.Fields) > 0 {
		for _, msg := range m.Fields {
			dAtA[i] = 0x22
			i++
			i = encodeVarintStatus(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *CertificateDetails_Fields) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CertificateDetails_Fields) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Issuer) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintStatus(dAtA, i, uint64(len(m.Issuer)))
		i += copy(dAtA[i:], m.Issuer)
	}
	if len(m.Subject) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintStatus(dAtA, i, uint64(len(m.Subject)))
		i += copy(dAtA[i:], m.Subject)
	}
	if m.ValidFrom != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintStatus(dAtA, i, uint64(m.ValidFrom))
	}
	if m.ValidUntil != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintStatus(dAtA, i, uint64(m.ValidUntil))
	}
	if len(m.Addresses) > 0 {
		for _, s := range m.Addresses {
			dAtA[i] = 0x2a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.SignatureAlgorithm) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintStatus(dAtA, i, uint64(len(m.SignatureAlgorithm)))
		i += copy(dAtA[i:], m.SignatureAlgorithm)
	}
	if len(m.PublicKey) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintStatus(dAtA, i, uint64(len(m.PublicKey)))
		i += copy(dAtA[i:], m.PublicKey)
	}
	if len(m.KeyUsage) > 0 {
		for _, s := range m.KeyUsage {
			dAtA[i] = 0x42
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.ExtendedKeyUsage) > 0 {
		for _, s := range m.ExtendedKeyUsage {
			dAtA[i] = 0x4a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	return i, nil
}

func (m *CertificatesResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CertificatesResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Certificates) > 0 {
		for _, msg := range m.Certificates {
			dAtA[i] = 0xa
			i++
			i = encodeVarintStatus(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *DetailsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DetailsRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.NodeId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintStatus(dAtA, i, uint64(len(m.NodeId)))
		i += copy(dAtA[i:], m.NodeId)
	}
	return i, nil
}

func (m *SystemInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SystemInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.SystemInfo) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintStatus(dAtA, i, uint64(len(m.SystemInfo)))
		i += copy(dAtA[i:], m.SystemInfo)
	}
	if len(m.KernelInfo) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintStatus(dAtA, i, uint64(len(m.KernelInfo)))
		i += copy(dAtA[i:], m.KernelInfo)
	}
	return i, nil
}

func (m *DetailsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DetailsResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.NodeID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintStatus(dAtA, i, uint64(m.NodeID))
	}
	dAtA[i] = 0x12
	i++
	i = encodeVarintStatus(dAtA, i, uint64(m.Address.Size()))
	n1, err := m.Address.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n1
	dAtA[i] = 0x1a
	i++
	i = encodeVarintStatus(dAtA, i, uint64(m.BuildInfo.Size()))
	n2, err := m.BuildInfo.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n2
	dAtA[i] = 0x22
	i++
	i = encodeVarintStatus(dAtA, i, uint64(m.SystemInfo.Size()))
	n3, err := m.SystemInfo.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n3
	dAtA[i] = 0x2a
	i++
	i = encodeVarintStatus(dAtA, i, uint64(m.SQLAddress.Size()))
	n4, err := m.SQLAddress.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n4
	return i, nil
}

func (m *NodesRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NodesRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *NodesResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NodesResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Nodes) > 0 {
		for _, msg := range m.Nodes {
			dAtA[i] = 0xa
			i++
			i = encodeVarintStatus(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.LivenessByNodeID) > 0 {
		keysForLivenessByNodeID := make([]int32, 0, len(m.LivenessByNodeID))
		for k := range m.LivenessByNodeID {
			keysForLivenessByNodeID = append(keysForLivenessByNodeID, int32(k))
		}
		github_com_gogo_protobuf_sortkeys.Int32s(keysForLivenessByNodeID)
		for _, k := range keysForLivenessByNodeID {
			dAtA[i] = 0x12
			i++
			v := m.LivenessByNodeID[github_com_cockroachdb_cockroach_pkg_roachpb.NodeID(k)]
			mapSize := 1 + sovStatus(uint64(k)) + 1 + sovStatus(uint64(v))
			i = encodeVarintStatus(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintStatus(dAtA, i, uint64(k))
			dAtA[i] = 0x10
			i++
			i = encodeVarintStatus(dAtA, i, uint64(v))
		}
	}
	return i, nil
}

func (m *NodesResponseExternal) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NodesResponseExternal) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Nodes) > 0 {
		for _, msg := range m.Nodes {
			dAtA[i] = 0xa
			i++
			i = encodeVarintStatus(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.LivenessByNodeID) > 0 {
		keysForLivenessByNodeID := make([]int32, 0, len(m.LivenessByNodeID))
		for k := range m.LivenessByNodeID {
			keysForLivenessByNodeID = append(keysForLivenessByNodeID, int32(k))
		}
		github_com_gogo_protobuf_sortkeys.Int32s(keysForLivenessByNodeID)
		for _, k := range keysForLivenessByNodeID {
			dAtA[i] = 0x12
			i++
			v := m.LivenessByNodeID[github_com_cockroachdb_cockroach_pkg_roachpb.NodeID(k)]
			mapSize := 1 + sovStatus(uint64(k)) + 1 + sovStatus(uint64(v))
			i = encodeVarintStatus(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintStatus(dAtA, i, uint64(k))
			dAtA[i] = 0x10
			i++
			i = encodeVarintStatus(dAtA, i, uint64(v))
		}
	}
	return i, nil
}

func (m *Locality) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Locality) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Tiers) > 0 {
		for _, msg := range m.Tiers {
			dAtA[i] = 0xa
			i++
			i = encodeVarintStatus(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *Tier) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Tier) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Key) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintStatus(dAtA, i, uint64(len(m.Key)))
		i += copy(dAtA[i:], m.Key)
	}
	if len(m.Value) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintStatus(dAtA, i, uint64(len(m.Value)))
		i += copy(dAtA[i:], m.Value)
	}
	return i, nil
}

func (m *Version) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Version) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Major != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintStatus(dAtA, i, uint64(m.Major))
	}
	if m.Minor != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintStatus(dAtA, i, uint64(m.Minor))
	}
	if m.Patch != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintStatus(dAtA, i, uint64(m.Patch))
	}
	if m.Internal != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintStatus(dAtA, i, uint64(m.Internal))
	}
	return i, nil
}

func (m *NodeDescriptor) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NodeDescriptor) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.NodeID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintStatus(dAtA, i, uint64(m.NodeID))
	}
	dAtA[i] = 0x12
	i++
	i = encodeVarintStatus(dAtA, i, uint64(m.Address.Size()))
	n5, err := m.Address.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n5
	dAtA[i] = 0x1a
	i++
	i = encodeVarintStatus(dAtA, i, uint64(m.Attrs.Size()))
	n6, err := m.Attrs.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n6
	dAtA[i] = 0x22
	i++
	i = encodeVarintStatus(dAtA, i, uint64(m.Locality.Size()))
	n7, err := m.Locality.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n7
	dAtA[i] = 0x2a
	i++
	i = encodeVarintStatus(dAtA, i, uint64(m.ServerVersion.Size()))
	n8, err := m.ServerVersion.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n8
	if len(m.BuildTag) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintStatus(dAtA, i, uint64(len(m.BuildTag)))
		i += copy(dAtA[i:], m.BuildTag)
	}
	if m.StartedAt != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintStatus(dAtA, i, uint64(m.StartedAt))
	}
	if len(m.LocalityAddress) > 0 {
		for _, msg := range m.LocalityAddress {
			dAtA[i] = 0x42
			i++
			i = encodeVarintStatus(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.ClusterName) > 0 {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintStatus(dAtA, i, uint64(len(m.ClusterName)))
		i += copy(dAtA[i:], m.ClusterName)
	}
	dAtA[i] = 0x52
	i++
	i = encodeVarintStatus(dAtA, i, uint64(m.SQLAddress.Size()))
	n9, err := m.SQLAddress.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n9
	return i, nil
}

func (m *Percentiles) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Percentiles) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.P10 != 0 {
		dAtA[i] = 0x9
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.P10))))
		i += 8
	}
	if m.P25 != 0 {
		dAtA[i] = 0x11
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.P25))))
		i += 8
	}
	if m.P50 != 0 {
		dAtA[i] = 0x19
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.P50))))
		i += 8
	}
	if m.P75 != 0 {
		dAtA[i] = 0x21
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.P75))))
		i += 8
	}
	if m.P90 != 0 {
		dAtA[i] = 0x29
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.P90))))
		i += 8
	}
	if m.PMax != 0 {
		dAtA[i] = 0x31
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.PMax))))
		i += 8
	}
	return i, nil
}

func (m *StoreDescriptor) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StoreDescriptor) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.StoreID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintStatus(dAtA, i, uint64(m.StoreID))
	}
	dAtA[i] = 0x12
	i++
	i = encodeVarintStatus(dAtA, i, uint64(m.Attrs.Size()))
	n10, err := m.Attrs.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n10
	dAtA[i] = 0x1a
	i++
	i = encodeVarintStatus(dAtA, i, uint64(m.Node.Size()))
	n11, err := m.Node.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n11
	dAtA[i] = 0x22
	i++
	i = encodeVarintStatus(dAtA, i, uint64(m.Capacity.Size()))
	n12, err := m.Capacity.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n12
	return i, nil
}

func (m *StoreStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StoreStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintStatus(dAtA, i, uint64(m.Desc.Size()))
	n13, err := m.Desc.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n13
	if len(m.Metrics) > 0 {
		keysForMetrics := make([]string, 0, len(m.Metrics))
		for k := range m.Metrics {
			keysForMetrics = append(keysForMetrics, string(k))
		}
		github_com_gogo_protobuf_sortkeys.Strings(keysForMetrics)
		for _, k := range keysForMetrics {
			dAtA[i] = 0x12
			i++
			v := m.Metrics[string(k)]
			mapSize := 1 + len(k) + sovStatus(uint64(len(k))) + 1 + 8
			i = encodeVarintStatus(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintStatus(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x11
			i++
			encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(v))))
			i += 8
		}
	}
	return i, nil
}

func (m *NodeResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NodeResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintStatus(dAtA, i, uint64(m.Desc.Size()))
	n14, err := m.Desc.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n14
	dAtA[i] = 0x12
	i++
	i = encodeVarintStatus(dAtA, i, uint64(m.BuildInfo.Size()))
	n15, err := m.BuildInfo.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n15
	if m.StartedAt != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintStatus(dAtA, i, uint64(m.StartedAt))
	}
	if m.UpdatedAt != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintStatus(dAtA, i, uint64(m.UpdatedAt))
	}
	if len(m.Metrics) > 0 {
		keysForMetrics := make([]string, 0, len(m.Metrics))
		for k := range m.Metrics {
			keysForMetrics = append(keysForMetrics, string(k))
		}
		github_com_gogo_protobuf_sortkeys.Strings(keysForMetrics)
		for _, k := range keysForMetrics {
			dAtA[i] = 0x2a
			i++
			v := m.Metrics[string(k)]
			mapSize := 1 + len(k) + sovStatus(uint64(len(k))) + 1 + 8
			i = encodeVarintStatus(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintStatus(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x11
			i++
			encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(v))))
			i += 8
		}
	}
	if len(m.StoreStatuses) > 0 {
		for _, msg := range m.StoreStatuses {
			dAtA[i] = 0x32
			i++
			i = encodeVarintStatus(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Args) > 0 {
		for _, s := range m.Args {
			dAtA[i] = 0x3a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.Env) > 0 {
		for _, s := range m.Env {
			dAtA[i] = 0x42
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.Latencies) > 0 {
		keysForLatencies := make([]int32, 0, len(m.Latencies))
		for k := range m.Latencies {
			keysForLatencies = append(keysForLatencies, int32(k))
		}
		github_com_gogo_protobuf_sortkeys.Int32s(keysForLatencies)
		for _, k := range keysForLatencies {
			dAtA[i] = 0x4a
			i++
			v := m.Latencies[github_com_cockroachdb_cockroach_pkg_roachpb.NodeID(k)]
			mapSize := 1 + sovStatus(uint64(k)) + 1 + sovStatus(uint64(v))
			i = encodeVarintStatus(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintStatus(dAtA, i, uint64(k))
			dAtA[i] = 0x10
			i++
			i = encodeVarintStatus(dAtA, i, uint64(v))
		}
	}
	if len(m.Activity) > 0 {
		keysForActivity := make([]int32, 0, len(m.Activity))
		for k := range m.Activity {
			keysForActivity = append(keysForActivity, int32(k))
		}
		github_com_gogo_protobuf_sortkeys.Int32s(keysForActivity)
		for _, k := range keysForActivity {
			dAtA[i] = 0x52
			i++
			v := m.Activity[github_com_cockroachdb_cockroach_pkg_roachpb.NodeID(k)]
			msgSize := 0
			if (&v) != nil {
				msgSize = (&v).Size()
				msgSize += 1 + sovStatus(uint64(msgSize))
			}
			mapSize := 1 + sovStatus(uint64(k)) + msgSize
			i = encodeVarintStatus(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintStatus(dAtA, i, uint64(k))
			dAtA[i] = 0x12
			i++
			i = encodeVarintStatus(dAtA, i, uint64((&v).Size()))
			n16, err := (&v).MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n16
		}
	}
	if m.TotalSystemMemory != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintStatus(dAtA, i, uint64(m.TotalSystemMemory))
	}
	if m.NumCpus != 0 {
		dAtA[i] = 0x60
		i++
		i = encodeVarintStatus(dAtA, i, uint64(m.NumCpus))
	}
	return i, nil
}

func (m *NodeResponse_NetworkActivity) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NodeResponse_NetworkActivity) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Incoming != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintStatus(dAtA, i, uint64(m.Incoming))
	}
	if m.Outgoing != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintStatus(dAtA, i, uint64(m.Outgoing))
	}
	if m.Latency != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintStatus(dAtA, i, uint64(m.Latency))
	}
	return i, nil
}

func (m *RegionsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RegionsRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *RegionsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RegionsResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Regions) > 0 {
		keysForRegions := make([]string, 0, len(m.Regions))
		for k := range m.Regions {
			keysForRegions = append(keysForRegions, string(k))
		}
		github_com_gogo_protobuf_sortkeys.Strings(keysForRegions)
		for _, k := range keysForRegions {
			dAtA[i] = 0xa
			i++
			v := m.Regions[string(k)]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovStatus(uint64(msgSize))
			}
			mapSize := 1 + len(k) + sovStatus(uint64(len(k))) + msgSize
			i = encodeVarintStatus(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintStatus(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintStatus(dAtA, i, uint64(v.Size()))
				n17, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n17
			}
		}
	}
	return i, nil
}

func (m *RegionsResponse_Region) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RegionsResponse_Region) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Zones) > 0 {
		for _, s := range m.Zones {
			dAtA[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	return i, nil
}

func (m *NodeRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NodeRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.NodeId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintStatus(dAtA, i, uint64(len(m.NodeId)))
		i += copy(dAtA[i:], m.NodeId)
	}
	return i, nil
}

func (m *RaftState) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RaftState) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ReplicaID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintStatus(dAtA, i, uint64(m.ReplicaID))
	}
	dAtA[i] = 0x12
	i++
	i = encodeVarintStatus(dAtA, i, uint64(m.HardState.Size()))
	n18, err := m.HardState.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n18
	if m.Lead != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintStatus(dAtA, i, uint64(m.Lead))
	}
	if len(m.State) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintStatus(dAtA, i, uint64(len(m.State)))
		i += copy(dAtA[i:], m.State)
	}
	if m.Applied != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintStatus(dAtA, i, uint64(m.Applied))
	}
	if len(m.Progress) > 0 {
		keysForProgress := make([]uint64, 0, len(m.Progress))
		for k := range m.Progress {
			keysForProgress = append(keysForProgress, uint64(k))
		}
		github_com_gogo_protobuf_sortkeys.Uint64s(keysForProgress)
		for _, k := range keysForProgress {
			dAtA[i] = 0x32
			i++
			v := m.Progress[uint64(k)]
			msgSize := 0
			if (&v) != nil {
				msgSize = (&v).Size()
				msgSize += 1 + sovStatus(uint64(msgSize))
			}
			mapSize := 1 + sovStatus(uint64(k)) + msgSize
			i = encodeVarintStatus(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintStatus(dAtA, i, uint64(k))
			dAtA[i] = 0x12
			i++
			i = encodeVarintStatus(dAtA, i, uint64((&v).Size()))
			n19, err := (&v).MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n19
		}
	}
	if m.LeadTransferee != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintStatus(dAtA, i, uint64(m.LeadTransferee))
	}
	return i, nil
}

func (m *RaftState_Progress) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RaftState_Progress) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Match != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintStatus(dAtA, i, uint64(m.Match))
	}
	if m.Next != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintStatus(dAtA, i, uint64(m.Next))
	}
	if len(m.State) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintStatus(dAtA, i, uint64(len(m.State)))
		i += copy(dAtA[i:], m.State)
	}
	if m.Paused {
		dAtA[i] = 0x20
		i++
		if m.Paused {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.PendingSnapshot != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintStatus(dAtA, i, uint64(m.PendingSnapshot))
	}
	return i, nil
}

func (m *RangeProblems) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RangeProblems) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Unavailable {
		dAtA[i] = 0x8
		i++
		if m.Unavailable {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.LeaderNotLeaseHolder {
		dAtA[i] = 0x10
		i++
		if m.LeaderNotLeaseHolder {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.NoRaftLeader {
		dAtA[i] = 0x18
		i++
		if m.NoRaftLeader {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Underreplicated {
		dAtA[i] = 0x20
		i++
		if m.Underreplicated {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.NoLease {
		dAtA[i] = 0x28
		i++
		if m.NoLease {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.QuiescentEqualsTicking {
		dAtA[i] = 0x30
		i++
		if m.QuiescentEqualsTicking {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.RaftLogTooLarge {
		dAtA[i] = 0x38
		i++
		if m.RaftLogTooLarge {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Overreplicated {
		dAtA[i] = 0x40
		i++
		if m.Overreplicated {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *RangeStatistics) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RangeStatistics) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.QueriesPerSecond != 0 {
		dAtA[i] = 0x9
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.QueriesPerSecond))))
		i += 8
	}
	if m.WritesPerSecond != 0 {
		dAtA[i] = 0x11
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.WritesPerSecond))))
		i += 8
	}
	return i, nil
}

func (m *PrettySpan) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PrettySpan) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.StartKey) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintStatus(dAtA, i, uint64(len(m.StartKey)))
		i += copy(dAtA[i:], m.StartKey)
	}
	if len(m.EndKey) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintStatus(dAtA, i, uint64(len(m.EndKey)))
		i += copy(dAtA[i:], m.EndKey)
	}
	return i, nil
}

func (m *RangeInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RangeInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintStatus(dAtA, i, uint64(m.Span.Size()))
	n20, err := m.Span.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n20
	dAtA[i] = 0x12
	i++
	i = encodeVarintStatus(dAtA, i, uint64(m.RaftState.Size()))
	n21, err := m.RaftState.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n21
	dAtA[i] = 0x22
	i++
	i = encodeVarintStatus(dAtA, i, uint64(m.State.Size()))
	n22, err := m.State.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n22
	if m.SourceNodeID != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintStatus(dAtA, i, uint64(m.SourceNodeID))
	}
	if m.SourceStoreID != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintStatus(dAtA, i, uint64(m.SourceStoreID))
	}
	if len(m.ErrorMessage) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintStatus(dAtA, i, uint64(len(m.ErrorMessage)))
		i += copy(dAtA[i:], m.ErrorMessage)
	}
	if len(m.LeaseHistory) > 0 {
		for _, msg := range m.LeaseHistory {
			dAtA[i] = 0x42
			i++
			i = encodeVarintStatus(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	dAtA[i] = 0x4a
	i++
	i = encodeVarintStatus(dAtA, i, uint64(m.Problems.Size()))
	n23, err := m.Problems.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n23
	dAtA[i] = 0x52
	i++
	i = encodeVarintStatus(dAtA, i, uint64(m.Stats.Size()))
	n24, err := m.Stats.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n24
	dAtA[i] = 0x5a
	i++
	i = encodeVarintStatus(dAtA, i, uint64(m.LatchesLocal.Size()))
	n25, err := m.LatchesLocal.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n25
	dAtA[i] = 0x62
	i++
	i = encodeVarintStatus(dAtA, i, uint64(m.LatchesGlobal.Size()))
	n26, err := m.LatchesGlobal.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n26
	dAtA[i] = 0x6a
	i++
	i = encodeVarintStatus(dAtA, i, uint64(m.LeaseStatus.Size()))
	n27, err := m.LeaseStatus.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n27
	if m.Quiescent {
		dAtA[i] = 0x70
		i++
		if m.Quiescent {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Ticking {
		dAtA[i] = 0x78
		i++
		if m.Ticking {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *RangesRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RangesRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.NodeId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintStatus(dAtA, i, uint64(len(m.NodeId)))
		i += copy(dAtA[i:], m.NodeId)
	}
	if len(m.RangeIDs) > 0 {
		dAtA29 := make([]byte, len(m.RangeIDs)*10)
		var j28 int
		for _, num1 := range m.RangeIDs {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA29[j28] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j28++
			}
			dAtA29[j28] = uint8(num)
			j28++
		}
		dAtA[i] = 0x12
		i++
		i = encodeVarintStatus(dAtA, i, uint64(j28))
		i += copy(dAtA[i:], dAtA29[:j28])
	}
	return i, nil
}

func (m *RangesResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RangesResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Ranges) > 0 {
		for _, msg := range m.Ranges {
			dAtA[i] = 0xa
			i++
			i = encodeVarintStatus(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *GossipRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GossipRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.NodeId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintStatus(dAtA, i, uint64(len(m.NodeId)))
		i += copy(dAtA[i:], m.NodeId)
	}
	return i, nil
}

func (m *EngineStatsInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EngineStatsInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.StoreID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintStatus(dAtA, i, uint64(m.StoreID))
	}
	if m.TickersAndHistograms != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintStatus(dAtA, i, uint64(m.TickersAndHistograms.Size()))
		n30, err := m.TickersAndHistograms.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n30
	}
	if m.EngineType != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintStatus(dAtA, i, uint64(m.EngineType))
	}
	return i, nil
}

func (m *EngineStatsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EngineStatsRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.NodeId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintStatus(dAtA, i, uint64(len(m.NodeId)))
		i += copy(dAtA[i:], m.NodeId)
	}
	return i, nil
}

func (m *EngineStatsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EngineStatsResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Stats) > 0 {
		for _, msg := range m.Stats {
			dAtA[i] = 0xa
			i++
			i = encodeVarintStatus(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *TraceEvent) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TraceEvent) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintStatus(dAtA, i, uint64(github_com_gogo_protobuf_types.SizeOfStdTime(m.Time)))
	n31, err := github_com_gogo_protobuf_types.StdTimeMarshalTo(m.Time, dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n31
	if len(m.Message) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintStatus(dAtA, i, uint64(len(m.Message)))
		i += copy(dAtA[i:], m.Message)
	}
	return i, nil
}

func (m *AllocatorDryRun) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AllocatorDryRun) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.RangeID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintStatus(dAtA, i, uint64(m.RangeID))
	}
	if len(m.Events) > 0 {
		for _, msg := range m.Events {
			dAtA[i] = 0x12
			i++
			i = encodeVarintStatus(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *AllocatorRangeRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AllocatorRangeRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.RangeId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintStatus(dAtA, i, uint64(m.RangeId))
	}
	return i, nil
}

func (m *AllocatorRangeResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AllocatorRangeResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.NodeID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintStatus(dAtA, i, uint64(m.NodeID))
	}
	if m.DryRun != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintStatus(dAtA, i, uint64(m.DryRun.Size()))
		n32, err := m.DryRun.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n32
	}
	return i, nil
}

func (m *AllocatorRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AllocatorRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.NodeId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintStatus(dAtA, i, uint64(len(m.NodeId)))
		i += copy(dAtA[i:], m.NodeId)
	}
	if len(m.RangeIDs) > 0 {
		dAtA34 := make([]byte, len(m.RangeIDs)*10)
		var j33 int
		for _, num1 := range m.RangeIDs {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA34[j33] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j33++
			}
			dAtA34[j33] = uint8(num)
			j33++
		}
		dAtA[i] = 0x12
		i++
		i = encodeVarintStatus(dAtA, i, uint64(j33))
		i += copy(dAtA[i:], dAtA34[:j33])
	}
	return i, nil
}

func (m *AllocatorResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AllocatorResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.DryRuns) > 0 {
		for _, msg := range m.DryRuns {
			dAtA[i] = 0xa
			i++
			i = encodeVarintStatus(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *JSONResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *JSONResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Data) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintStatus(dAtA, i, uint64(len(m.Data)))
		i += copy(dAtA[i:], m.Data)
	}
	return i, nil
}

func (m *ResponseError) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResponseError) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Error) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintStatus(dAtA, i, uint64(len(m.Error)))
		i += copy(dAtA[i:], m.Error)
	}
	if m.Code != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintStatus(dAtA, i, uint64(m.Code))
	}
	if len(m.Message) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintStatus(dAtA, i, uint64(len(m.Message)))
		i += copy(dAtA[i:], m.Message)
	}
	if len(m.Details) > 0 {
		for _, s := range m.Details {
			dAtA[i] = 0x22
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	return i, nil
}

func (m *LogsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LogsRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.NodeId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintStatus(dAtA, i, uint64(len(m.NodeId)))
		i += copy(dAtA[i:], m.NodeId)
	}
	if len(m.Level) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintStatus(dAtA, i, uint64(len(m.Level)))
		i += copy(dAtA[i:], m.Level)
	}
	if len(m.StartTime) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintStatus(dAtA, i, uint64(len(m.StartTime)))
		i += copy(dAtA[i:], m.StartTime)
	}
	if len(m.EndTime) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintStatus(dAtA, i, uint64(len(m.EndTime)))
		i += copy(dAtA[i:], m.EndTime)
	}
	if len(m.Max) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintStatus(dAtA, i, uint64(len(m.Max)))
		i += copy(dAtA[i:], m.Max)
	}
	if len(m.Pattern) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintStatus(dAtA, i, uint64(len(m.Pattern)))
		i += copy(dAtA[i:], m.Pattern)
	}
	if m.Redact {
		dAtA[i] = 0x38
		i++
		if m.Redact {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.KeepRedactable {
		dAtA[i] = 0x40
		i++
		if m.KeepRedactable {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *LogEntriesResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LogEntriesResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Entries) > 0 {
		for _, msg := range m.Entries {
			dAtA[i] = 0xa
			i++
			i = encodeVarintStatus(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *LogFilesListRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LogFilesListRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.NodeId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintStatus(dAtA, i, uint64(len(m.NodeId)))
		i += copy(dAtA[i:], m.NodeId)
	}
	return i, nil
}

func (m *LogFilesListResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LogFilesListResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Files) > 0 {
		for _, msg := range m.Files {
			dAtA[i] = 0xa
			i++
			i = encodeVarintStatus(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *LogFileRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LogFileRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.NodeId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintStatus(dAtA, i, uint64(len(m.NodeId)))
		i += copy(dAtA[i:], m.NodeId)
	}
	if len(m.File) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintStatus(dAtA, i, uint64(len(m.File)))
		i += copy(dAtA[i:], m.File)
	}
	if m.Redact {
		dAtA[i] = 0x18
		i++
		if m.Redact {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.KeepRedactable {
		dAtA[i] = 0x20
		i++
		if m.KeepRedactable {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *StacksRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StacksRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.NodeId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintStatus(dAtA, i, uint64(len(m.NodeId)))
		i += copy(dAtA[i:], m.NodeId)
	}
	if m.Type != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintStatus(dAtA, i, uint64(m.Type))
	}
	return i, nil
}

func (m *File) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *File) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintStatus(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if m.FileSize != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintStatus(dAtA, i, uint64(m.FileSize))
	}
	if len(m.Contents) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintStatus(dAtA, i, uint64(len(m.Contents)))
		i += copy(dAtA[i:], m.Contents)
	}
	return i, nil
}

func (m *GetFilesRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetFilesRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.NodeId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintStatus(dAtA, i, uint64(len(m.NodeId)))
		i += copy(dAtA[i:], m.NodeId)
	}
	if m.ListOnly {
		dAtA[i] = 0x10
		i++
		if m.ListOnly {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Type != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintStatus(dAtA, i, uint64(m.Type))
	}
	if len(m.Patterns) > 0 {
		for _, s := range m.Patterns {
			dAtA[i] = 0x32
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	return i, nil
}

func (m *GetFilesResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetFilesResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Files) > 0 {
		for _, msg := range m.Files {
			dAtA[i] = 0xa
			i++
			i = encodeVarintStatus(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *ProfileRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProfileRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.NodeId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintStatus(dAtA, i, uint64(len(m.NodeId)))
		i += copy(dAtA[i:], m.NodeId)
	}
	if m.Type != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintStatus(dAtA, i, uint64(m.Type))
	}
	if m.Seconds != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintStatus(dAtA, i, uint64(m.Seconds))
	}
	return i, nil
}

func (m *MetricsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MetricsRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.NodeId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintStatus(dAtA, i, uint64(len(m.NodeId)))
		i += copy(dAtA[i:], m.NodeId)
	}
	return i, nil
}

func (m *RaftRangeNode) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RaftRangeNode) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.NodeID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintStatus(dAtA, i, uint64(m.NodeID))
	}
	dAtA[i] = 0x12
	i++
	i = encodeVarintStatus(dAtA, i, uint64(m.Range.Size()))
	n35, err := m.Range.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n35
	return i, nil
}

func (m *RaftRangeError) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RaftRangeError) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Message) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintStatus(dAtA, i, uint64(len(m.Message)))
		i += copy(dAtA[i:], m.Message)
	}
	return i, nil
}

func (m *RaftRangeStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RaftRangeStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.RangeID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintStatus(dAtA, i, uint64(m.RangeID))
	}
	if len(m.Errors) > 0 {
		for _, msg := range m.Errors {
			dAtA[i] = 0x12
			i++
			i = encodeVarintStatus(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Nodes) > 0 {
		for _, msg := range m.Nodes {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintStatus(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *RaftDebugRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RaftDebugRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.RangeIDs) > 0 {
		dAtA37 := make([]byte, len(m.RangeIDs)*10)
		var j36 int
		for _, num1 := range m.RangeIDs {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA37[j36] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j36++
			}
			dAtA37[j36] = uint8(num)
			j36++
		}
		dAtA[i] = 0xa
		i++
		i = encodeVarintStatus(dAtA, i, uint64(j36))
		i += copy(dAtA[i:], dAtA37[:j36])
	}
	return i, nil
}

func (m *RaftDebugResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RaftDebugResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Ranges) > 0 {
		keysForRanges := make([]int64, 0, len(m.Ranges))
		for k := range m.Ranges {
			keysForRanges = append(keysForRanges, int64(k))
		}
		github_com_gogo_protobuf_sortkeys.Int64s(keysForRanges)
		for _, k := range keysForRanges {
			dAtA[i] = 0xa
			i++
			v := m.Ranges[github_com_cockroachdb_cockroach_pkg_roachpb.RangeID(k)]
			msgSize := 0
			if (&v) != nil {
				msgSize = (&v).Size()
				msgSize += 1 + sovStatus(uint64(msgSize))
			}
			mapSize := 1 + sovStatus(uint64(k)) + msgSize
			i = encodeVarintStatus(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintStatus(dAtA, i, uint64(k))
			dAtA[i] = 0x12
			i++
			i = encodeVarintStatus(dAtA, i, uint64((&v).Size()))
			n38, err := (&v).MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n38
		}
	}
	if len(m.Errors) > 0 {
		for _, msg := range m.Errors {
			dAtA[i] = 0x12
			i++
			i = encodeVarintStatus(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *TxnInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TxnInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintStatus(dAtA, i, uint64(m.ID.Size()))
	n39, err := m.ID.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n39
	dAtA[i] = 0x12
	i++
	i = encodeVarintStatus(dAtA, i, uint64(github_com_gogo_protobuf_types.SizeOfStdTime(m.Start)))
	n40, err := github_com_gogo_protobuf_types.StdTimeMarshalTo(m.Start, dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n40
	if len(m.TxnDescription) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintStatus(dAtA, i, uint64(len(m.TxnDescription)))
		i += copy(dAtA[i:], m.TxnDescription)
	}
	if m.NumStatementsExecuted != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintStatus(dAtA, i, uint64(m.NumStatementsExecuted))
	}
	if m.NumRetries != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintStatus(dAtA, i, uint64(m.NumRetries))
	}
	if m.NumAutoRetries != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintStatus(dAtA, i, uint64(m.NumAutoRetries))
	}
	dAtA[i] = 0x3a
	i++
	i = encodeVarintStatus(dAtA, i, uint64(github_com_gogo_protobuf_types.SizeOfStdTime(m.Deadline)))
	n41, err := github_com_gogo_protobuf_types.StdTimeMarshalTo(m.Deadline, dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n41
	if m.Implicit {
		dAtA[i] = 0x40
		i++
		if m.Implicit {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.AllocBytes != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintStatus(dAtA, i, uint64(m.AllocBytes))
	}
	if m.MaxAllocBytes != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintStatus(dAtA, i, uint64(m.MaxAllocBytes))
	}
	if m.ReadOnly {
		dAtA[i] = 0x58
		i++
		if m.ReadOnly {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.IsHistorical {
		dAtA[i] = 0x60
		i++
		if m.IsHistorical {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Priority) > 0 {
		dAtA[i] = 0x6a
		i++
		i = encodeVarintStatus(dAtA, i, uint64(len(m.Priority)))
		i += copy(dAtA[i:], m.Priority)
	}
	return i, nil
}

func (m *ActiveQuery) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ActiveQuery) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ID) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintStatus(dAtA, i, uint64(len(m.ID)))
		i += copy(dAtA[i:], m.ID)
	}
	if len(m.Sql) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintStatus(dAtA, i, uint64(len(m.Sql)))
		i += copy(dAtA[i:], m.Sql)
	}
	dAtA[i] = 0x1a
	i++
	i = encodeVarintStatus(dAtA, i, uint64(github_com_gogo_protobuf_types.SizeOfStdTime(m.Start)))
	n42, err := github_com_gogo_protobuf_types.StdTimeMarshalTo(m.Start, dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n42
	if m.IsDistributed {
		dAtA[i] = 0x20
		i++
		if m.IsDistributed {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Phase != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintStatus(dAtA, i, uint64(m.Phase))
	}
	if m.Progress != 0 {
		dAtA[i] = 0x35
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Progress))))
		i += 4
	}
	dAtA[i] = 0x3a
	i++
	i = encodeVarintStatus(dAtA, i, uint64(m.TxnID.Size()))
	n43, err := m.TxnID.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n43
	if len(m.SqlAnon) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintStatus(dAtA, i, uint64(len(m.SqlAnon)))
		i += copy(dAtA[i:], m.SqlAnon)
	}
	return i, nil
}

func (m *ListSessionsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListSessionsRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Username) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintStatus(dAtA, i, uint64(len(m.Username)))
		i += copy(dAtA[i:], m.Username)
	}
	return i, nil
}

func (m *Session) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Session) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.NodeID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintStatus(dAtA, i, uint64(m.NodeID))
	}
	if len(m.Username) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintStatus(dAtA, i, uint64(len(m.Username)))
		i += copy(dAtA[i:], m.Username)
	}
	if len(m.ClientAddress) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintStatus(dAtA, i, uint64(len(m.ClientAddress)))
		i += copy(dAtA[i:], m.ClientAddress)
	}
	if len(m.ApplicationName) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintStatus(dAtA, i, uint64(len(m.ApplicationName)))
		i += copy(dAtA[i:], m.ApplicationName)
	}
	if len(m.ActiveQueries) > 0 {
		for _, msg := range m.ActiveQueries {
			dAtA[i] = 0x2a
			i++
			i = encodeVarintStatus(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	dAtA[i] = 0x32
	i++
	i = encodeVarintStatus(dAtA, i, uint64(github_com_gogo_protobuf_types.SizeOfStdTime(m.Start)))
	n44, err := github_com_gogo_protobuf_types.StdTimeMarshalTo(m.Start, dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n44
	if len(m.LastActiveQuery) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintStatus(dAtA, i, uint64(len(m.LastActiveQuery)))
		i += copy(dAtA[i:], m.LastActiveQuery)
	}
	if len(m.ID) > 0 {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintStatus(dAtA, i, uint64(len(m.ID)))
		i += copy(dAtA[i:], m.ID)
	}
	if m.AllocBytes != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintStatus(dAtA, i, uint64(m.AllocBytes))
	}
	if m.MaxAllocBytes != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintStatus(dAtA, i, uint64(m.MaxAllocBytes))
	}
	if m.ActiveTxn != nil {
		dAtA[i] = 0x62
		i++
		i = encodeVarintStatus(dAtA, i, uint64(m.ActiveTxn.Size()))
		n45, err := m.ActiveTxn.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n45
	}
	if len(m.LastActiveQueryAnon) > 0 {
		dAtA[i] = 0x6a
		i++
		i = encodeVarintStatus(dAtA, i, uint64(len(m.LastActiveQueryAnon)))
		i += copy(dAtA[i:], m.LastActiveQueryAnon)
	}
	return i, nil
}

func (m *ListSessionsError) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListSessionsError) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.NodeID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintStatus(dAtA, i, uint64(m.NodeID))
	}
	if len(m.Message) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintStatus(dAtA, i, uint64(len(m.Message)))
		i += copy(dAtA[i:], m.Message)
	}
	return i, nil
}

func (m *ListSessionsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListSessionsResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Sessions) > 0 {
		for _, msg := range m.Sessions {
			dAtA[i] = 0xa
			i++
			i = encodeVarintStatus(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Errors) > 0 {
		for _, msg := range m.Errors {
			dAtA[i] = 0x12
			i++
			i = encodeVarintStatus(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *CancelQueryRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CancelQueryRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.NodeId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintStatus(dAtA, i, uint64(len(m.NodeId)))
		i += copy(dAtA[i:], m.NodeId)
	}
	if len(m.QueryID) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintStatus(dAtA, i, uint64(len(m.QueryID)))
		i += copy(dAtA[i:], m.QueryID)
	}
	if len(m.Username) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintStatus(dAtA, i, uint64(len(m.Username)))
		i += copy(dAtA[i:], m.Username)
	}
	return i, nil
}

func (m *CancelQueryResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CancelQueryResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Canceled {
		dAtA[i] = 0x8
		i++
		if m.Canceled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Error) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintStatus(dAtA, i, uint64(len(m.Error)))
		i += copy(dAtA[i:], m.Error)
	}
	return i, nil
}

func (m *CancelSessionRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CancelSessionRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.NodeId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintStatus(dAtA, i, uint64(len(m.NodeId)))
		i += copy(dAtA[i:], m.NodeId)
	}
	if len(m.SessionID) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintStatus(dAtA, i, uint64(len(m.SessionID)))
		i += copy(dAtA[i:], m.SessionID)
	}
	if len(m.Username) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintStatus(dAtA, i, uint64(len(m.Username)))
		i += copy(dAtA[i:], m.Username)
	}
	return i, nil
}

func (m *CancelSessionResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CancelSessionResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Canceled {
		dAtA[i] = 0x8
		i++
		if m.Canceled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Error) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintStatus(dAtA, i, uint64(len(m.Error)))
		i += copy(dAtA[i:], m.Error)
	}
	return i, nil
}

func (m *SpanStatsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SpanStatsRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.NodeID) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintStatus(dAtA, i, uint64(len(m.NodeID)))
		i += copy(dAtA[i:], m.NodeID)
	}
	if len(m.StartKey) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintStatus(dAtA, i, uint64(len(m.StartKey)))
		i += copy(dAtA[i:], m.StartKey)
	}
	if len(m.EndKey) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintStatus(dAtA, i, uint64(len(m.EndKey)))
		i += copy(dAtA[i:], m.EndKey)
	}
	return i, nil
}

func (m *SpanStatsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SpanStatsResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintStatus(dAtA, i, uint64(m.TotalStats.Size()))
	n46, err := m.TotalStats.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n46
	if m.RangeCount != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintStatus(dAtA, i, uint64(m.RangeCount))
	}
	if m.ApproximateDiskBytes != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintStatus(dAtA, i, uint64(m.ApproximateDiskBytes))
	}
	return i, nil
}

func (m *ProblemRangesRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProblemRangesRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.NodeID) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintStatus(dAtA, i, uint64(len(m.NodeID)))
		i += copy(dAtA[i:], m.NodeID)
	}
	return i, nil
}

func (m *ProblemRangesResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProblemRangesResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.NodeID != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintStatus(dAtA, i, uint64(m.NodeID))
	}
	if len(m.ProblemsByNodeID) > 0 {
		keysForProblemsByNodeID := make([]int32, 0, len(m.ProblemsByNodeID))
		for k := range m.ProblemsByNodeID {
			keysForProblemsByNodeID = append(keysForProblemsByNodeID, int32(k))
		}
		github_com_gogo_protobuf_sortkeys.Int32s(keysForProblemsByNodeID)
		for _, k := range keysForProblemsByNodeID {
			dAtA[i] = 0x4a
			i++
			v := m.ProblemsByNodeID[github_com_cockroachdb_cockroach_pkg_roachpb.NodeID(k)]
			msgSize := 0
			if (&v) != nil {
				msgSize = (&v).Size()
				msgSize += 1 + sovStatus(uint64(msgSize))
			}
			mapSize := 1 + sovStatus(uint64(k)) + msgSize
			i = encodeVarintStatus(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintStatus(dAtA, i, uint64(k))
			dAtA[i] = 0x12
			i++
			i = encodeVarintStatus(dAtA, i, uint64((&v).Size()))
			n47, err := (&v).MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n47
		}
	}
	return i, nil
}

func (m *ProblemRangesResponse_NodeProblems) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProblemRangesResponse_NodeProblems) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ErrorMessage) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintStatus(dAtA, i, uint64(len(m.ErrorMessage)))
		i += copy(dAtA[i:], m.ErrorMessage)
	}
	if len(m.UnavailableRangeIDs) > 0 {
		dAtA49 := make([]byte, len(m.UnavailableRangeIDs)*10)
		var j48 int
		for _, num1 := range m.UnavailableRangeIDs {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA49[j48] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j48++
			}
			dAtA49[j48] = uint8(num)
			j48++
		}
		dAtA[i] = 0x12
		i++
		i = encodeVarintStatus(dAtA, i, uint64(j48))
		i += copy(dAtA[i:], dAtA49[:j48])
	}
	if len(m.RaftLeaderNotLeaseHolderRangeIDs) > 0 {
		dAtA51 := make([]byte, len(m.RaftLeaderNotLeaseHolderRangeIDs)*10)
		var j50 int
		for _, num1 := range m.RaftLeaderNotLeaseHolderRangeIDs {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA51[j50] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j50++
			}
			dAtA51[j50] = uint8(num)
			j50++
		}
		dAtA[i] = 0x1a
		i++
		i = encodeVarintStatus(dAtA, i, uint64(j50))
		i += copy(dAtA[i:], dAtA51[:j50])
	}
	if len(m.NoRaftLeaderRangeIDs) > 0 {
		dAtA53 := make([]byte, len(m.NoRaftLeaderRangeIDs)*10)
		var j52 int
		for _, num1 := range m.NoRaftLeaderRangeIDs {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA53[j52] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j52++
			}
			dAtA53[j52] = uint8(num)
			j52++
		}
		dAtA[i] = 0x22
		i++
		i = encodeVarintStatus(dAtA, i, uint64(j52))
		i += copy(dAtA[i:], dAtA53[:j52])
	}
	if len(m.NoLeaseRangeIDs) > 0 {
		dAtA55 := make([]byte, len(m.NoLeaseRangeIDs)*10)
		var j54 int
		for _, num1 := range m.NoLeaseRangeIDs {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA55[j54] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j54++
			}
			dAtA55[j54] = uint8(num)
			j54++
		}
		dAtA[i] = 0x2a
		i++
		i = encodeVarintStatus(dAtA, i, uint64(j54))
		i += copy(dAtA[i:], dAtA55[:j54])
	}
	if len(m.UnderreplicatedRangeIDs) > 0 {
		dAtA57 := make([]byte, len(m.UnderreplicatedRangeIDs)*10)
		var j56 int
		for _, num1 := range m.UnderreplicatedRangeIDs {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA57[j56] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j56++
			}
			dAtA57[j56] = uint8(num)
			j56++
		}
		dAtA[i] = 0x32
		i++
		i = encodeVarintStatus(dAtA, i, uint64(j56))
		i += copy(dAtA[i:], dAtA57[:j56])
	}
	if len(m.QuiescentEqualsTickingRangeIDs) > 0 {
		dAtA59 := make([]byte, len(m.QuiescentEqualsTickingRangeIDs)*10)
		var j58 int
		for _, num1 := range m.QuiescentEqualsTickingRangeIDs {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA59[j58] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j58++
			}
			dAtA59[j58] = uint8(num)
			j58++
		}
		dAtA[i] = 0x3a
		i++
		i = encodeVarintStatus(dAtA, i, uint64(j58))
		i += copy(dAtA[i:], dAtA59[:j58])
	}
	if len(m.RaftLogTooLargeRangeIDs) > 0 {
		dAtA61 := make([]byte, len(m.RaftLogTooLargeRangeIDs)*10)
		var j60 int
		for _, num1 := range m.RaftLogTooLargeRangeIDs {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA61[j60] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j60++
			}
			dAtA61[j60] = uint8(num)
			j60++
		}
		dAtA[i] = 0x42
		i++
		i = encodeVarintStatus(dAtA, i, uint64(j60))
		i += copy(dAtA[i:], dAtA61[:j60])
	}
	if len(m.OverreplicatedRangeIDs) > 0 {
		dAtA63 := make([]byte, len(m.OverreplicatedRangeIDs)*10)
		var j62 int
		for _, num1 := range m.OverreplicatedRangeIDs {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA63[j62] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j62++
			}
			dAtA63[j62] = uint8(num)
			j62++
		}
		dAtA[i] = 0x4a
		i++
		i = encodeVarintStatus(dAtA, i, uint64(j62))
		i += copy(dAtA[i:], dAtA63[:j62])
	}
	return i, nil
}

func (m *HotRangesRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HotRangesRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.NodeID) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintStatus(dAtA, i, uint64(len(m.NodeID)))
		i += copy(dAtA[i:], m.NodeID)
	}
	return i, nil
}

func (m *HotRangesResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HotRangesResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.NodeID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintStatus(dAtA, i, uint64(m.NodeID))
	}
	if len(m.HotRangesByNodeID) > 0 {
		keysForHotRangesByNodeID := make([]int32, 0, len(m.HotRangesByNodeID))
		for k := range m.HotRangesByNodeID {
			keysForHotRangesByNodeID = append(keysForHotRangesByNodeID, int32(k))
		}
		github_com_gogo_protobuf_sortkeys.Int32s(keysForHotRangesByNodeID)
		for _, k := range keysForHotRangesByNodeID {
			dAtA[i] = 0x12
			i++
			v := m.HotRangesByNodeID[github_com_cockroachdb_cockroach_pkg_roachpb.NodeID(k)]
			msgSize := 0
			if (&v) != nil {
				msgSize = (&v).Size()
				msgSize += 1 + sovStatus(uint64(msgSize))
			}
			mapSize := 1 + sovStatus(uint64(k)) + msgSize
			i = encodeVarintStatus(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintStatus(dAtA, i, uint64(k))
			dAtA[i] = 0x12
			i++
			i = encodeVarintStatus(dAtA, i, uint64((&v).Size()))
			n64, err := (&v).MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n64
		}
	}
	return i, nil
}

func (m *HotRangesResponse_HotRange) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HotRangesResponse_HotRange) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintStatus(dAtA, i, uint64(m.Desc.Size()))
	n65, err := m.Desc.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n65
	if m.QueriesPerSecond != 0 {
		dAtA[i] = 0x11
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.QueriesPerSecond))))
		i += 8
	}
	return i, nil
}

func (m *HotRangesResponse_StoreResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HotRangesResponse_StoreResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.StoreID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintStatus(dAtA, i, uint64(m.StoreID))
	}
	if len(m.HotRanges) > 0 {
		for _, msg := range m.HotRanges {
			dAtA[i] = 0x12
			i++
			i = encodeVarintStatus(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *HotRangesResponse_NodeResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HotRangesResponse_NodeResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ErrorMessage) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintStatus(dAtA, i, uint64(len(m.ErrorMessage)))
		i += copy(dAtA[i:], m.ErrorMessage)
	}
	if len(m.Stores) > 0 {
		for _, msg := range m.Stores {
			dAtA[i] = 0x12
			i++
			i = encodeVarintStatus(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *RangeRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RangeRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.RangeId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintStatus(dAtA, i, uint64(m.RangeId))
	}
	return i, nil
}

func (m *RangeResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RangeResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.NodeID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintStatus(dAtA, i, uint64(m.NodeID))
	}
	if m.RangeID != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintStatus(dAtA, i, uint64(m.RangeID))
	}
	if len(m.ResponsesByNodeID) > 0 {
		keysForResponsesByNodeID := make([]int32, 0, len(m.ResponsesByNodeID))
		for k := range m.ResponsesByNodeID {
			keysForResponsesByNodeID = append(keysForResponsesByNodeID, int32(k))
		}
		github_com_gogo_protobuf_sortkeys.Int32s(keysForResponsesByNodeID)
		for _, k := range keysForResponsesByNodeID {
			dAtA[i] = 0x1a
			i++
			v := m.ResponsesByNodeID[github_com_cockroachdb_cockroach_pkg_roachpb.NodeID(k)]
			msgSize := 0
			if (&v) != nil {
				msgSize = (&v).Size()
				msgSize += 1 + sovStatus(uint64(msgSize))
			}
			mapSize := 1 + sovStatus(uint64(k)) + msgSize
			i = encodeVarintStatus(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintStatus(dAtA, i, uint64(k))
			dAtA[i] = 0x12
			i++
			i = encodeVarintStatus(dAtA, i, uint64((&v).Size()))
			n66, err := (&v).MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n66
		}
	}
	return i, nil
}

func (m *RangeResponse_NodeResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RangeResponse_NodeResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Response {
		dAtA[i] = 0x8
		i++
		if m.Response {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.ErrorMessage) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintStatus(dAtA, i, uint64(len(m.ErrorMessage)))
		i += copy(dAtA[i:], m.ErrorMessage)
	}
	if len(m.Infos) > 0 {
		for _, msg := range m.Infos {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintStatus(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *DiagnosticsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DiagnosticsRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.NodeId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintStatus(dAtA, i, uint64(len(m.NodeId)))
		i += copy(dAtA[i:], m.NodeId)
	}
	return i, nil
}

func (m *StoresRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StoresRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.NodeId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintStatus(dAtA, i, uint64(len(m.NodeId)))
		i += copy(dAtA[i:], m.NodeId)
	}
	return i, nil
}

func (m *StoreDetails) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StoreDetails) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.StoreID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintStatus(dAtA, i, uint64(m.StoreID))
	}
	if len(m.EncryptionStatus) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintStatus(dAtA, i, uint64(len(m.EncryptionStatus)))
		i += copy(dAtA[i:], m.EncryptionStatus)
	}
	if m.TotalFiles != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintStatus(dAtA, i, uint64(m.TotalFiles))
	}
	if m.TotalBytes != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintStatus(dAtA, i, uint64(m.TotalBytes))
	}
	if m.ActiveKeyFiles != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintStatus(dAtA, i, uint64(m.ActiveKeyFiles))
	}
	if m.ActiveKeyBytes != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintStatus(dAtA, i, uint64(m.ActiveKeyBytes))
	}
	return i, nil
}

func (m *StoresResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StoresResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Stores) > 0 {
		for _, msg := range m.Stores {
			dAtA[i] = 0xa
			i++
			i = encodeVarintStatus(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *StatementsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StatementsRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.NodeID) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintStatus(dAtA, i, uint64(len(m.NodeID)))
		i += copy(dAtA[i:], m.NodeID)
	}
	return i, nil
}

func (m *StatementsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StatementsResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Statements) > 0 {
		for _, msg := range m.Statements {
			dAtA[i] = 0xa
			i++
			i = encodeVarintStatus(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	dAtA[i] = 0x1a
	i++
	i = encodeVarintStatus(dAtA, i, uint64(github_com_gogo_protobuf_types.SizeOfStdTime(m.LastReset)))
	n67, err := github_com_gogo_protobuf_types.StdTimeMarshalTo(m.LastReset, dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n67
	if len(m.InternalAppNamePrefix) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintStatus(dAtA, i, uint64(len(m.InternalAppNamePrefix)))
		i += copy(dAtA[i:], m.InternalAppNamePrefix)
	}
	if len(m.Transactions) > 0 {
		for _, msg := range m.Transactions {
			dAtA[i] = 0x2a
			i++
			i = encodeVarintStatus(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *StatementsResponse_ExtendedStatementStatisticsKey) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StatementsResponse_ExtendedStatementStatisticsKey) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintStatus(dAtA, i, uint64(m.KeyData.Size()))
	n68, err := m.KeyData.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n68
	if m.NodeID != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintStatus(dAtA, i, uint64(m.NodeID))
	}
	return i, nil
}

func (m *StatementsResponse_CollectedStatementStatistics) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StatementsResponse_CollectedStatementStatistics) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintStatus(dAtA, i, uint64(m.Key.Size()))
	n69, err := m.Key.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n69
	dAtA[i] = 0x12
	i++
	i = encodeVarintStatus(dAtA, i, uint64(m.Stats.Size()))
	n70, err := m.Stats.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n70
	if m.ID != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintStatus(dAtA, i, uint64(m.ID))
	}
	return i, nil
}

func (m *StatementsResponse_ExtendedCollectedTransactionStatistics) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StatementsResponse_ExtendedCollectedTransactionStatistics) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintStatus(dAtA, i, uint64(m.StatsData.Size()))
	n71, err := m.StatsData.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n71
	if m.NodeID != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintStatus(dAtA, i, uint64(m.NodeID))
	}
	return i, nil
}

func (m *StatementDiagnosticsReport) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StatementDiagnosticsReport) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintStatus(dAtA, i, uint64(m.Id))
	}
	if m.Completed {
		dAtA[i] = 0x10
		i++
		if m.Completed {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.StatementFingerprint) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintStatus(dAtA, i, uint64(len(m.StatementFingerprint)))
		i += copy(dAtA[i:], m.StatementFingerprint)
	}
	if m.StatementDiagnosticsId != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintStatus(dAtA, i, uint64(m.StatementDiagnosticsId))
	}
	dAtA[i] = 0x2a
	i++
	i = encodeVarintStatus(dAtA, i, uint64(github_com_gogo_protobuf_types.SizeOfStdTime(m.RequestedAt)))
	n72, err := github_com_gogo_protobuf_types.StdTimeMarshalTo(m.RequestedAt, dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n72
	return i, nil
}

func (m *CreateStatementDiagnosticsReportRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateStatementDiagnosticsReportRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.StatementFingerprint) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintStatus(dAtA, i, uint64(len(m.StatementFingerprint)))
		i += copy(dAtA[i:], m.StatementFingerprint)
	}
	return i, nil
}

func (m *CreateStatementDiagnosticsReportResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateStatementDiagnosticsReportResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Report != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintStatus(dAtA, i, uint64(m.Report.Size()))
		n73, err := m.Report.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n73
	}
	return i, nil
}

func (m *StatementDiagnosticsReportsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StatementDiagnosticsReportsRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *StatementDiagnosticsReportsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StatementDiagnosticsReportsResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Reports) > 0 {
		for _, msg := range m.Reports {
			dAtA[i] = 0xa
			i++
			i = encodeVarintStatus(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *StatementDiagnostics) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StatementDiagnostics) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintStatus(dAtA, i, uint64(m.Id))
	}
	if len(m.StatementFingerprint) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintStatus(dAtA, i, uint64(len(m.StatementFingerprint)))
		i += copy(dAtA[i:], m.StatementFingerprint)
	}
	dAtA[i] = 0x1a
	i++
	i = encodeVarintStatus(dAtA, i, uint64(github_com_gogo_protobuf_types.SizeOfStdTime(m.CollectedAt)))
	n74, err := github_com_gogo_protobuf_types.StdTimeMarshalTo(m.CollectedAt, dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n74
	return i, nil
}

func (m *StatementDiagnosticsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StatementDiagnosticsRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.StatementDiagnosticsId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintStatus(dAtA, i, uint64(m.StatementDiagnosticsId))
	}
	return i, nil
}

func (m *StatementDiagnosticsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StatementDiagnosticsResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Diagnostics != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintStatus(dAtA, i, uint64(m.Diagnostics.Size()))
		n75, err := m.Diagnostics.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n75
	}
	return i, nil
}

func (m *JobRegistryStatusRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *JobRegistryStatusRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.NodeId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintStatus(dAtA, i, uint64(len(m.NodeId)))
		i += copy(dAtA[i:], m.NodeId)
	}
	return i, nil
}

func (m *JobRegistryStatusResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *JobRegistryStatusResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.NodeID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintStatus(dAtA, i, uint64(m.NodeID))
	}
	if len(m.RunningJobs) > 0 {
		for _, msg := range m.RunningJobs {
			dAtA[i] = 0x12
			i++
			i = encodeVarintStatus(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *JobRegistryStatusResponse_Job) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *JobRegistryStatusResponse_Job) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintStatus(dAtA, i, uint64(m.Id))
	}
	return i, nil
}

func (m *JobStatusRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *JobStatusRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.JobId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintStatus(dAtA, i, uint64(m.JobId))
	}
	return i, nil
}

func (m *JobStatusResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *JobStatusResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Job != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintStatus(dAtA, i, uint64(m.Job.Size()))
		n76, err := m.Job.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n76
	}
	return i, nil
}

func encodeVarintStatus(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *CertificatesRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.NodeId)
	if l > 0 {
		n += 1 + l + sovStatus(uint64(l))
	}
	return n
}

func (m *CertificateDetails) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovStatus(uint64(m.Type))
	}
	l = len(m.ErrorMessage)
	if l > 0 {
		n += 1 + l + sovStatus(uint64(l))
	}
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovStatus(uint64(l))
	}
	if len(m.Fields) > 0 {
		for _, e := range m.Fields {
			l = e.Size()
			n += 1 + l + sovStatus(uint64(l))
		}
	}
	return n
}

func (m *CertificateDetails_Fields) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Issuer)
	if l > 0 {
		n += 1 + l + sovStatus(uint64(l))
	}
	l = len(m.Subject)
	if l > 0 {
		n += 1 + l + sovStatus(uint64(l))
	}
	if m.ValidFrom != 0 {
		n += 1 + sovStatus(uint64(m.ValidFrom))
	}
	if m.ValidUntil != 0 {
		n += 1 + sovStatus(uint64(m.ValidUntil))
	}
	if len(m.Addresses) > 0 {
		for _, s := range m.Addresses {
			l = len(s)
			n += 1 + l + sovStatus(uint64(l))
		}
	}
	l = len(m.SignatureAlgorithm)
	if l > 0 {
		n += 1 + l + sovStatus(uint64(l))
	}
	l = len(m.PublicKey)
	if l > 0 {
		n += 1 + l + sovStatus(uint64(l))
	}
	if len(m.KeyUsage) > 0 {
		for _, s := range m.KeyUsage {
			l = len(s)
			n += 1 + l + sovStatus(uint64(l))
		}
	}
	if len(m.ExtendedKeyUsage) > 0 {
		for _, s := range m.ExtendedKeyUsage {
			l = len(s)
			n += 1 + l + sovStatus(uint64(l))
		}
	}
	return n
}

func (m *CertificatesResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Certificates) > 0 {
		for _, e := range m.Certificates {
			l = e.Size()
			n += 1 + l + sovStatus(uint64(l))
		}
	}
	return n
}

func (m *DetailsRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.NodeId)
	if l > 0 {
		n += 1 + l + sovStatus(uint64(l))
	}
	return n
}

func (m *SystemInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.SystemInfo)
	if l > 0 {
		n += 1 + l + sovStatus(uint64(l))
	}
	l = len(m.KernelInfo)
	if l > 0 {
		n += 1 + l + sovStatus(uint64(l))
	}
	return n
}

func (m *DetailsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NodeID != 0 {
		n += 1 + sovStatus(uint64(m.NodeID))
	}
	l = m.Address.Size()
	n += 1 + l + sovStatus(uint64(l))
	l = m.BuildInfo.Size()
	n += 1 + l + sovStatus(uint64(l))
	l = m.SystemInfo.Size()
	n += 1 + l + sovStatus(uint64(l))
	l = m.SQLAddress.Size()
	n += 1 + l + sovStatus(uint64(l))
	return n
}

func (m *NodesRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *NodesResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Nodes) > 0 {
		for _, e := range m.Nodes {
			l = e.Size()
			n += 1 + l + sovStatus(uint64(l))
		}
	}
	if len(m.LivenessByNodeID) > 0 {
		for k, v := range m.LivenessByNodeID {
			_ = k
			_ = v
			mapEntrySize := 1 + sovStatus(uint64(k)) + 1 + sovStatus(uint64(v))
			n += mapEntrySize + 1 + sovStatus(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *NodesResponseExternal) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Nodes) > 0 {
		for _, e := range m.Nodes {
			l = e.Size()
			n += 1 + l + sovStatus(uint64(l))
		}
	}
	if len(m.LivenessByNodeID) > 0 {
		for k, v := range m.LivenessByNodeID {
			_ = k
			_ = v
			mapEntrySize := 1 + sovStatus(uint64(k)) + 1 + sovStatus(uint64(v))
			n += mapEntrySize + 1 + sovStatus(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *Locality) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Tiers) > 0 {
		for _, e := range m.Tiers {
			l = e.Size()
			n += 1 + l + sovStatus(uint64(l))
		}
	}
	return n
}

func (m *Tier) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovStatus(uint64(l))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovStatus(uint64(l))
	}
	return n
}

func (m *Version) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Major != 0 {
		n += 1 + sovStatus(uint64(m.Major))
	}
	if m.Minor != 0 {
		n += 1 + sovStatus(uint64(m.Minor))
	}
	if m.Patch != 0 {
		n += 1 + sovStatus(uint64(m.Patch))
	}
	if m.Internal != 0 {
		n += 1 + sovStatus(uint64(m.Internal))
	}
	return n
}

func (m *NodeDescriptor) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NodeID != 0 {
		n += 1 + sovStatus(uint64(m.NodeID))
	}
	l = m.Address.Size()
	n += 1 + l + sovStatus(uint64(l))
	l = m.Attrs.Size()
	n += 1 + l + sovStatus(uint64(l))
	l = m.Locality.Size()
	n += 1 + l + sovStatus(uint64(l))
	l = m.ServerVersion.Size()
	n += 1 + l + sovStatus(uint64(l))
	l = len(m.BuildTag)
	if l > 0 {
		n += 1 + l + sovStatus(uint64(l))
	}
	if m.StartedAt != 0 {
		n += 1 + sovStatus(uint64(m.StartedAt))
	}
	if len(m.LocalityAddress) > 0 {
		for _, e := range m.LocalityAddress {
			l = e.Size()
			n += 1 + l + sovStatus(uint64(l))
		}
	}
	l = len(m.ClusterName)
	if l > 0 {
		n += 1 + l + sovStatus(uint64(l))
	}
	l = m.SQLAddress.Size()
	n += 1 + l + sovStatus(uint64(l))
	return n
}

func (m *Percentiles) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.P10 != 0 {
		n += 9
	}
	if m.P25 != 0 {
		n += 9
	}
	if m.P50 != 0 {
		n += 9
	}
	if m.P75 != 0 {
		n += 9
	}
	if m.P90 != 0 {
		n += 9
	}
	if m.PMax != 0 {
		n += 9
	}
	return n
}

func (m *StoreDescriptor) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.StoreID != 0 {
		n += 1 + sovStatus(uint64(m.StoreID))
	}
	l = m.Attrs.Size()
	n += 1 + l + sovStatus(uint64(l))
	l = m.Node.Size()
	n += 1 + l + sovStatus(uint64(l))
	l = m.Capacity.Size()
	n += 1 + l + sovStatus(uint64(l))
	return n
}

func (m *StoreStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Desc.Size()
	n += 1 + l + sovStatus(uint64(l))
	if len(m.Metrics) > 0 {
		for k, v := range m.Metrics {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovStatus(uint64(len(k))) + 1 + 8
			n += mapEntrySize + 1 + sovStatus(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *NodeResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Desc.Size()
	n += 1 + l + sovStatus(uint64(l))
	l = m.BuildInfo.Size()
	n += 1 + l + sovStatus(uint64(l))
	if m.StartedAt != 0 {
		n += 1 + sovStatus(uint64(m.StartedAt))
	}
	if m.UpdatedAt != 0 {
		n += 1 + sovStatus(uint64(m.UpdatedAt))
	}
	if len(m.Metrics) > 0 {
		for k, v := range m.Metrics {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovStatus(uint64(len(k))) + 1 + 8
			n += mapEntrySize + 1 + sovStatus(uint64(mapEntrySize))
		}
	}
	if len(m.StoreStatuses) > 0 {
		for _, e := range m.StoreStatuses {
			l = e.Size()
			n += 1 + l + sovStatus(uint64(l))
		}
	}
	if len(m.Args) > 0 {
		for _, s := range m.Args {
			l = len(s)
			n += 1 + l + sovStatus(uint64(l))
		}
	}
	if len(m.Env) > 0 {
		for _, s := range m.Env {
			l = len(s)
			n += 1 + l + sovStatus(uint64(l))
		}
	}
	if len(m.Latencies) > 0 {
		for k, v := range m.Latencies {
			_ = k
			_ = v
			mapEntrySize := 1 + sovStatus(uint64(k)) + 1 + sovStatus(uint64(v))
			n += mapEntrySize + 1 + sovStatus(uint64(mapEntrySize))
		}
	}
	if len(m.Activity) > 0 {
		for k, v := range m.Activity {
			_ = k
			_ = v
			l = v.Size()
			mapEntrySize := 1 + sovStatus(uint64(k)) + 1 + l + sovStatus(uint64(l))
			n += mapEntrySize + 1 + sovStatus(uint64(mapEntrySize))
		}
	}
	if m.TotalSystemMemory != 0 {
		n += 1 + sovStatus(uint64(m.TotalSystemMemory))
	}
	if m.NumCpus != 0 {
		n += 1 + sovStatus(uint64(m.NumCpus))
	}
	return n
}

func (m *NodeResponse_NetworkActivity) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Incoming != 0 {
		n += 1 + sovStatus(uint64(m.Incoming))
	}
	if m.Outgoing != 0 {
		n += 1 + sovStatus(uint64(m.Outgoing))
	}
	if m.Latency != 0 {
		n += 1 + sovStatus(uint64(m.Latency))
	}
	return n
}

func (m *RegionsRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *RegionsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Regions) > 0 {
		for k, v := range m.Regions {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovStatus(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovStatus(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovStatus(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *RegionsResponse_Region) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Zones) > 0 {
		for _, s := range m.Zones {
			l = len(s)
			n += 1 + l + sovStatus(uint64(l))
		}
	}
	return n
}

func (m *NodeRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.NodeId)
	if l > 0 {
		n += 1 + l + sovStatus(uint64(l))
	}
	return n
}

func (m *RaftState) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ReplicaID != 0 {
		n += 1 + sovStatus(uint64(m.ReplicaID))
	}
	l = m.HardState.Size()
	n += 1 + l + sovStatus(uint64(l))
	if m.Lead != 0 {
		n += 1 + sovStatus(uint64(m.Lead))
	}
	l = len(m.State)
	if l > 0 {
		n += 1 + l + sovStatus(uint64(l))
	}
	if m.Applied != 0 {
		n += 1 + sovStatus(uint64(m.Applied))
	}
	if len(m.Progress) > 0 {
		for k, v := range m.Progress {
			_ = k
			_ = v
			l = v.Size()
			mapEntrySize := 1 + sovStatus(uint64(k)) + 1 + l + sovStatus(uint64(l))
			n += mapEntrySize + 1 + sovStatus(uint64(mapEntrySize))
		}
	}
	if m.LeadTransferee != 0 {
		n += 1 + sovStatus(uint64(m.LeadTransferee))
	}
	return n
}

func (m *RaftState_Progress) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Match != 0 {
		n += 1 + sovStatus(uint64(m.Match))
	}
	if m.Next != 0 {
		n += 1 + sovStatus(uint64(m.Next))
	}
	l = len(m.State)
	if l > 0 {
		n += 1 + l + sovStatus(uint64(l))
	}
	if m.Paused {
		n += 2
	}
	if m.PendingSnapshot != 0 {
		n += 1 + sovStatus(uint64(m.PendingSnapshot))
	}
	return n
}

func (m *RangeProblems) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Unavailable {
		n += 2
	}
	if m.LeaderNotLeaseHolder {
		n += 2
	}
	if m.NoRaftLeader {
		n += 2
	}
	if m.Underreplicated {
		n += 2
	}
	if m.NoLease {
		n += 2
	}
	if m.QuiescentEqualsTicking {
		n += 2
	}
	if m.RaftLogTooLarge {
		n += 2
	}
	if m.Overreplicated {
		n += 2
	}
	return n
}

func (m *RangeStatistics) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.QueriesPerSecond != 0 {
		n += 9
	}
	if m.WritesPerSecond != 0 {
		n += 9
	}
	return n
}

func (m *PrettySpan) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.StartKey)
	if l > 0 {
		n += 1 + l + sovStatus(uint64(l))
	}
	l = len(m.EndKey)
	if l > 0 {
		n += 1 + l + sovStatus(uint64(l))
	}
	return n
}

func (m *RangeInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Span.Size()
	n += 1 + l + sovStatus(uint64(l))
	l = m.RaftState.Size()
	n += 1 + l + sovStatus(uint64(l))
	l = m.State.Size()
	n += 1 + l + sovStatus(uint64(l))
	if m.SourceNodeID != 0 {
		n += 1 + sovStatus(uint64(m.SourceNodeID))
	}
	if m.SourceStoreID != 0 {
		n += 1 + sovStatus(uint64(m.SourceStoreID))
	}
	l = len(m.ErrorMessage)
	if l > 0 {
		n += 1 + l + sovStatus(uint64(l))
	}
	if len(m.LeaseHistory) > 0 {
		for _, e := range m.LeaseHistory {
			l = e.Size()
			n += 1 + l + sovStatus(uint64(l))
		}
	}
	l = m.Problems.Size()
	n += 1 + l + sovStatus(uint64(l))
	l = m.Stats.Size()
	n += 1 + l + sovStatus(uint64(l))
	l = m.LatchesLocal.Size()
	n += 1 + l + sovStatus(uint64(l))
	l = m.LatchesGlobal.Size()
	n += 1 + l + sovStatus(uint64(l))
	l = m.LeaseStatus.Size()
	n += 1 + l + sovStatus(uint64(l))
	if m.Quiescent {
		n += 2
	}
	if m.Ticking {
		n += 2
	}
	return n
}

func (m *RangesRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.NodeId)
	if l > 0 {
		n += 1 + l + sovStatus(uint64(l))
	}
	if len(m.RangeIDs) > 0 {
		l = 0
		for _, e := range m.RangeIDs {
			l += sovStatus(uint64(e))
		}
		n += 1 + sovStatus(uint64(l)) + l
	}
	return n
}

func (m *RangesResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Ranges) > 0 {
		for _, e := range m.Ranges {
			l = e.Size()
			n += 1 + l + sovStatus(uint64(l))
		}
	}
	return n
}

func (m *GossipRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.NodeId)
	if l > 0 {
		n += 1 + l + sovStatus(uint64(l))
	}
	return n
}

func (m *EngineStatsInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.StoreID != 0 {
		n += 1 + sovStatus(uint64(m.StoreID))
	}
	if m.TickersAndHistograms != nil {
		l = m.TickersAndHistograms.Size()
		n += 1 + l + sovStatus(uint64(l))
	}
	if m.EngineType != 0 {
		n += 1 + sovStatus(uint64(m.EngineType))
	}
	return n
}

func (m *EngineStatsRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.NodeId)
	if l > 0 {
		n += 1 + l + sovStatus(uint64(l))
	}
	return n
}

func (m *EngineStatsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Stats) > 0 {
		for _, e := range m.Stats {
			l = e.Size()
			n += 1 + l + sovStatus(uint64(l))
		}
	}
	return n
}

func (m *TraceEvent) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = github_com_gogo_protobuf_types.SizeOfStdTime(m.Time)
	n += 1 + l + sovStatus(uint64(l))
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovStatus(uint64(l))
	}
	return n
}

func (m *AllocatorDryRun) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RangeID != 0 {
		n += 1 + sovStatus(uint64(m.RangeID))
	}
	if len(m.Events) > 0 {
		for _, e := range m.Events {
			l = e.Size()
			n += 1 + l + sovStatus(uint64(l))
		}
	}
	return n
}

func (m *AllocatorRangeRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RangeId != 0 {
		n += 1 + sovStatus(uint64(m.RangeId))
	}
	return n
}

func (m *AllocatorRangeResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NodeID != 0 {
		n += 1 + sovStatus(uint64(m.NodeID))
	}
	if m.DryRun != nil {
		l = m.DryRun.Size()
		n += 1 + l + sovStatus(uint64(l))
	}
	return n
}

func (m *AllocatorRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.NodeId)
	if l > 0 {
		n += 1 + l + sovStatus(uint64(l))
	}
	if len(m.RangeIDs) > 0 {
		l = 0
		for _, e := range m.RangeIDs {
			l += sovStatus(uint64(e))
		}
		n += 1 + sovStatus(uint64(l)) + l
	}
	return n
}

func (m *AllocatorResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.DryRuns) > 0 {
		for _, e := range m.DryRuns {
			l = e.Size()
			n += 1 + l + sovStatus(uint64(l))
		}
	}
	return n
}

func (m *JSONResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovStatus(uint64(l))
	}
	return n
}

func (m *ResponseError) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Error)
	if l > 0 {
		n += 1 + l + sovStatus(uint64(l))
	}
	if m.Code != 0 {
		n += 1 + sovStatus(uint64(m.Code))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovStatus(uint64(l))
	}
	if len(m.Details) > 0 {
		for _, s := range m.Details {
			l = len(s)
			n += 1 + l + sovStatus(uint64(l))
		}
	}
	return n
}

func (m *LogsRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.NodeId)
	if l > 0 {
		n += 1 + l + sovStatus(uint64(l))
	}
	l = len(m.Level)
	if l > 0 {
		n += 1 + l + sovStatus(uint64(l))
	}
	l = len(m.StartTime)
	if l > 0 {
		n += 1 + l + sovStatus(uint64(l))
	}
	l = len(m.EndTime)
	if l > 0 {
		n += 1 + l + sovStatus(uint64(l))
	}
	l = len(m.Max)
	if l > 0 {
		n += 1 + l + sovStatus(uint64(l))
	}
	l = len(m.Pattern)
	if l > 0 {
		n += 1 + l + sovStatus(uint64(l))
	}
	if m.Redact {
		n += 2
	}
	if m.KeepRedactable {
		n += 2
	}
	return n
}

func (m *LogEntriesResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Entries) > 0 {
		for _, e := range m.Entries {
			l = e.Size()
			n += 1 + l + sovStatus(uint64(l))
		}
	}
	return n
}

func (m *LogFilesListRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.NodeId)
	if l > 0 {
		n += 1 + l + sovStatus(uint64(l))
	}
	return n
}

func (m *LogFilesListResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Files) > 0 {
		for _, e := range m.Files {
			l = e.Size()
			n += 1 + l + sovStatus(uint64(l))
		}
	}
	return n
}

func (m *LogFileRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.NodeId)
	if l > 0 {
		n += 1 + l + sovStatus(uint64(l))
	}
	l = len(m.File)
	if l > 0 {
		n += 1 + l + sovStatus(uint64(l))
	}
	if m.Redact {
		n += 2
	}
	if m.KeepRedactable {
		n += 2
	}
	return n
}

func (m *StacksRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.NodeId)
	if l > 0 {
		n += 1 + l + sovStatus(uint64(l))
	}
	if m.Type != 0 {
		n += 1 + sovStatus(uint64(m.Type))
	}
	return n
}

func (m *File) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovStatus(uint64(l))
	}
	if m.FileSize != 0 {
		n += 1 + sovStatus(uint64(m.FileSize))
	}
	l = len(m.Contents)
	if l > 0 {
		n += 1 + l + sovStatus(uint64(l))
	}
	return n
}

func (m *GetFilesRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.NodeId)
	if l > 0 {
		n += 1 + l + sovStatus(uint64(l))
	}
	if m.ListOnly {
		n += 2
	}
	if m.Type != 0 {
		n += 1 + sovStatus(uint64(m.Type))
	}
	if len(m.Patterns) > 0 {
		for _, s := range m.Patterns {
			l = len(s)
			n += 1 + l + sovStatus(uint64(l))
		}
	}
	return n
}

func (m *GetFilesResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Files) > 0 {
		for _, e := range m.Files {
			l = e.Size()
			n += 1 + l + sovStatus(uint64(l))
		}
	}
	return n
}

func (m *ProfileRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.NodeId)
	if l > 0 {
		n += 1 + l + sovStatus(uint64(l))
	}
	if m.Type != 0 {
		n += 1 + sovStatus(uint64(m.Type))
	}
	if m.Seconds != 0 {
		n += 1 + sovStatus(uint64(m.Seconds))
	}
	return n
}

func (m *MetricsRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.NodeId)
	if l > 0 {
		n += 1 + l + sovStatus(uint64(l))
	}
	return n
}

func (m *RaftRangeNode) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NodeID != 0 {
		n += 1 + sovStatus(uint64(m.NodeID))
	}
	l = m.Range.Size()
	n += 1 + l + sovStatus(uint64(l))
	return n
}

func (m *RaftRangeError) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovStatus(uint64(l))
	}
	return n
}

func (m *RaftRangeStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RangeID != 0 {
		n += 1 + sovStatus(uint64(m.RangeID))
	}
	if len(m.Errors) > 0 {
		for _, e := range m.Errors {
			l = e.Size()
			n += 1 + l + sovStatus(uint64(l))
		}
	}
	if len(m.Nodes) > 0 {
		for _, e := range m.Nodes {
			l = e.Size()
			n += 1 + l + sovStatus(uint64(l))
		}
	}
	return n
}

func (m *RaftDebugRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.RangeIDs) > 0 {
		l = 0
		for _, e := range m.RangeIDs {
			l += sovStatus(uint64(e))
		}
		n += 1 + sovStatus(uint64(l)) + l
	}
	return n
}

func (m *RaftDebugResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Ranges) > 0 {
		for k, v := range m.Ranges {
			_ = k
			_ = v
			l = v.Size()
			mapEntrySize := 1 + sovStatus(uint64(k)) + 1 + l + sovStatus(uint64(l))
			n += mapEntrySize + 1 + sovStatus(uint64(mapEntrySize))
		}
	}
	if len(m.Errors) > 0 {
		for _, e := range m.Errors {
			l = e.Size()
			n += 1 + l + sovStatus(uint64(l))
		}
	}
	return n
}

func (m *TxnInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.ID.Size()
	n += 1 + l + sovStatus(uint64(l))
	l = github_com_gogo_protobuf_types.SizeOfStdTime(m.Start)
	n += 1 + l + sovStatus(uint64(l))
	l = len(m.TxnDescription)
	if l > 0 {
		n += 1 + l + sovStatus(uint64(l))
	}
	if m.NumStatementsExecuted != 0 {
		n += 1 + sovStatus(uint64(m.NumStatementsExecuted))
	}
	if m.NumRetries != 0 {
		n += 1 + sovStatus(uint64(m.NumRetries))
	}
	if m.NumAutoRetries != 0 {
		n += 1 + sovStatus(uint64(m.NumAutoRetries))
	}
	l = github_com_gogo_protobuf_types.SizeOfStdTime(m.Deadline)
	n += 1 + l + sovStatus(uint64(l))
	if m.Implicit {
		n += 2
	}
	if m.AllocBytes != 0 {
		n += 1 + sovStatus(uint64(m.AllocBytes))
	}
	if m.MaxAllocBytes != 0 {
		n += 1 + sovStatus(uint64(m.MaxAllocBytes))
	}
	if m.ReadOnly {
		n += 2
	}
	if m.IsHistorical {
		n += 2
	}
	l = len(m.Priority)
	if l > 0 {
		n += 1 + l + sovStatus(uint64(l))
	}
	return n
}

func (m *ActiveQuery) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ID)
	if l > 0 {
		n += 1 + l + sovStatus(uint64(l))
	}
	l = len(m.Sql)
	if l > 0 {
		n += 1 + l + sovStatus(uint64(l))
	}
	l = github_com_gogo_protobuf_types.SizeOfStdTime(m.Start)
	n += 1 + l + sovStatus(uint64(l))
	if m.IsDistributed {
		n += 2
	}
	if m.Phase != 0 {
		n += 1 + sovStatus(uint64(m.Phase))
	}
	if m.Progress != 0 {
		n += 5
	}
	l = m.TxnID.Size()
	n += 1 + l + sovStatus(uint64(l))
	l = len(m.SqlAnon)
	if l > 0 {
		n += 1 + l + sovStatus(uint64(l))
	}
	return n
}

func (m *ListSessionsRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Username)
	if l > 0 {
		n += 1 + l + sovStatus(uint64(l))
	}
	return n
}

func (m *Session) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NodeID != 0 {
		n += 1 + sovStatus(uint64(m.NodeID))
	}
	l = len(m.Username)
	if l > 0 {
		n += 1 + l + sovStatus(uint64(l))
	}
	l = len(m.ClientAddress)
	if l > 0 {
		n += 1 + l + sovStatus(uint64(l))
	}
	l = len(m.ApplicationName)
	if l > 0 {
		n += 1 + l + sovStatus(uint64(l))
	}
	if len(m.ActiveQueries) > 0 {
		for _, e := range m.ActiveQueries {
			l = e.Size()
			n += 1 + l + sovStatus(uint64(l))
		}
	}
	l = github_com_gogo_protobuf_types.SizeOfStdTime(m.Start)
	n += 1 + l + sovStatus(uint64(l))
	l = len(m.LastActiveQuery)
	if l > 0 {
		n += 1 + l + sovStatus(uint64(l))
	}
	l = len(m.ID)
	if l > 0 {
		n += 1 + l + sovStatus(uint64(l))
	}
	if m.AllocBytes != 0 {
		n += 1 + sovStatus(uint64(m.AllocBytes))
	}
	if m.MaxAllocBytes != 0 {
		n += 1 + sovStatus(uint64(m.MaxAllocBytes))
	}
	if m.ActiveTxn != nil {
		l = m.ActiveTxn.Size()
		n += 1 + l + sovStatus(uint64(l))
	}
	l = len(m.LastActiveQueryAnon)
	if l > 0 {
		n += 1 + l + sovStatus(uint64(l))
	}
	return n
}

func (m *ListSessionsError) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NodeID != 0 {
		n += 1 + sovStatus(uint64(m.NodeID))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovStatus(uint64(l))
	}
	return n
}

func (m *ListSessionsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Sessions) > 0 {
		for _, e := range m.Sessions {
			l = e.Size()
			n += 1 + l + sovStatus(uint64(l))
		}
	}
	if len(m.Errors) > 0 {
		for _, e := range m.Errors {
			l = e.Size()
			n += 1 + l + sovStatus(uint64(l))
		}
	}
	return n
}

func (m *CancelQueryRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.NodeId)
	if l > 0 {
		n += 1 + l + sovStatus(uint64(l))
	}
	l = len(m.QueryID)
	if l > 0 {
		n += 1 + l + sovStatus(uint64(l))
	}
	l = len(m.Username)
	if l > 0 {
		n += 1 + l + sovStatus(uint64(l))
	}
	return n
}

func (m *CancelQueryResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Canceled {
		n += 2
	}
	l = len(m.Error)
	if l > 0 {
		n += 1 + l + sovStatus(uint64(l))
	}
	return n
}

func (m *CancelSessionRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.NodeId)
	if l > 0 {
		n += 1 + l + sovStatus(uint64(l))
	}
	l = len(m.SessionID)
	if l > 0 {
		n += 1 + l + sovStatus(uint64(l))
	}
	l = len(m.Username)
	if l > 0 {
		n += 1 + l + sovStatus(uint64(l))
	}
	return n
}

func (m *CancelSessionResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Canceled {
		n += 2
	}
	l = len(m.Error)
	if l > 0 {
		n += 1 + l + sovStatus(uint64(l))
	}
	return n
}

func (m *SpanStatsRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.NodeID)
	if l > 0 {
		n += 1 + l + sovStatus(uint64(l))
	}
	l = len(m.StartKey)
	if l > 0 {
		n += 1 + l + sovStatus(uint64(l))
	}
	l = len(m.EndKey)
	if l > 0 {
		n += 1 + l + sovStatus(uint64(l))
	}
	return n
}

func (m *SpanStatsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.TotalStats.Size()
	n += 1 + l + sovStatus(uint64(l))
	if m.RangeCount != 0 {
		n += 1 + sovStatus(uint64(m.RangeCount))
	}
	if m.ApproximateDiskBytes != 0 {
		n += 1 + sovStatus(uint64(m.ApproximateDiskBytes))
	}
	return n
}

func (m *ProblemRangesRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.NodeID)
	if l > 0 {
		n += 1 + l + sovStatus(uint64(l))
	}
	return n
}

func (m *ProblemRangesResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NodeID != 0 {
		n += 1 + sovStatus(uint64(m.NodeID))
	}
	if len(m.ProblemsByNodeID) > 0 {
		for k, v := range m.ProblemsByNodeID {
			_ = k
			_ = v
			l = v.Size()
			mapEntrySize := 1 + sovStatus(uint64(k)) + 1 + l + sovStatus(uint64(l))
			n += mapEntrySize + 1 + sovStatus(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *ProblemRangesResponse_NodeProblems) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ErrorMessage)
	if l > 0 {
		n += 1 + l + sovStatus(uint64(l))
	}
	if len(m.UnavailableRangeIDs) > 0 {
		l = 0
		for _, e := range m.UnavailableRangeIDs {
			l += sovStatus(uint64(e))
		}
		n += 1 + sovStatus(uint64(l)) + l
	}
	if len(m.RaftLeaderNotLeaseHolderRangeIDs) > 0 {
		l = 0
		for _, e := range m.RaftLeaderNotLeaseHolderRangeIDs {
			l += sovStatus(uint64(e))
		}
		n += 1 + sovStatus(uint64(l)) + l
	}
	if len(m.NoRaftLeaderRangeIDs) > 0 {
		l = 0
		for _, e := range m.NoRaftLeaderRangeIDs {
			l += sovStatus(uint64(e))
		}
		n += 1 + sovStatus(uint64(l)) + l
	}
	if len(m.NoLeaseRangeIDs) > 0 {
		l = 0
		for _, e := range m.NoLeaseRangeIDs {
			l += sovStatus(uint64(e))
		}
		n += 1 + sovStatus(uint64(l)) + l
	}
	if len(m.UnderreplicatedRangeIDs) > 0 {
		l = 0
		for _, e := range m.UnderreplicatedRangeIDs {
			l += sovStatus(uint64(e))
		}
		n += 1 + sovStatus(uint64(l)) + l
	}
	if len(m.QuiescentEqualsTickingRangeIDs) > 0 {
		l = 0
		for _, e := range m.QuiescentEqualsTickingRangeIDs {
			l += sovStatus(uint64(e))
		}
		n += 1 + sovStatus(uint64(l)) + l
	}
	if len(m.RaftLogTooLargeRangeIDs) > 0 {
		l = 0
		for _, e := range m.RaftLogTooLargeRangeIDs {
			l += sovStatus(uint64(e))
		}
		n += 1 + sovStatus(uint64(l)) + l
	}
	if len(m.OverreplicatedRangeIDs) > 0 {
		l = 0
		for _, e := range m.OverreplicatedRangeIDs {
			l += sovStatus(uint64(e))
		}
		n += 1 + sovStatus(uint64(l)) + l
	}
	return n
}

func (m *HotRangesRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.NodeID)
	if l > 0 {
		n += 1 + l + sovStatus(uint64(l))
	}
	return n
}

func (m *HotRangesResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NodeID != 0 {
		n += 1 + sovStatus(uint64(m.NodeID))
	}
	if len(m.HotRangesByNodeID) > 0 {
		for k, v := range m.HotRangesByNodeID {
			_ = k
			_ = v
			l = v.Size()
			mapEntrySize := 1 + sovStatus(uint64(k)) + 1 + l + sovStatus(uint64(l))
			n += mapEntrySize + 1 + sovStatus(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *HotRangesResponse_HotRange) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Desc.Size()
	n += 1 + l + sovStatus(uint64(l))
	if m.QueriesPerSecond != 0 {
		n += 9
	}
	return n
}

func (m *HotRangesResponse_StoreResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.StoreID != 0 {
		n += 1 + sovStatus(uint64(m.StoreID))
	}
	if len(m.HotRanges) > 0 {
		for _, e := range m.HotRanges {
			l = e.Size()
			n += 1 + l + sovStatus(uint64(l))
		}
	}
	return n
}

func (m *HotRangesResponse_NodeResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ErrorMessage)
	if l > 0 {
		n += 1 + l + sovStatus(uint64(l))
	}
	if len(m.Stores) > 0 {
		for _, e := range m.Stores {
			l = e.Size()
			n += 1 + l + sovStatus(uint64(l))
		}
	}
	return n
}

func (m *RangeRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RangeId != 0 {
		n += 1 + sovStatus(uint64(m.RangeId))
	}
	return n
}

func (m *RangeResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NodeID != 0 {
		n += 1 + sovStatus(uint64(m.NodeID))
	}
	if m.RangeID != 0 {
		n += 1 + sovStatus(uint64(m.RangeID))
	}
	if len(m.ResponsesByNodeID) > 0 {
		for k, v := range m.ResponsesByNodeID {
			_ = k
			_ = v
			l = v.Size()
			mapEntrySize := 1 + sovStatus(uint64(k)) + 1 + l + sovStatus(uint64(l))
			n += mapEntrySize + 1 + sovStatus(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *RangeResponse_NodeResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Response {
		n += 2
	}
	l = len(m.ErrorMessage)
	if l > 0 {
		n += 1 + l + sovStatus(uint64(l))
	}
	if len(m.Infos) > 0 {
		for _, e := range m.Infos {
			l = e.Size()
			n += 1 + l + sovStatus(uint64(l))
		}
	}
	return n
}

func (m *DiagnosticsRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.NodeId)
	if l > 0 {
		n += 1 + l + sovStatus(uint64(l))
	}
	return n
}

func (m *StoresRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.NodeId)
	if l > 0 {
		n += 1 + l + sovStatus(uint64(l))
	}
	return n
}

func (m *StoreDetails) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.StoreID != 0 {
		n += 1 + sovStatus(uint64(m.StoreID))
	}
	l = len(m.EncryptionStatus)
	if l > 0 {
		n += 1 + l + sovStatus(uint64(l))
	}
	if m.TotalFiles != 0 {
		n += 1 + sovStatus(uint64(m.TotalFiles))
	}
	if m.TotalBytes != 0 {
		n += 1 + sovStatus(uint64(m.TotalBytes))
	}
	if m.ActiveKeyFiles != 0 {
		n += 1 + sovStatus(uint64(m.ActiveKeyFiles))
	}
	if m.ActiveKeyBytes != 0 {
		n += 1 + sovStatus(uint64(m.ActiveKeyBytes))
	}
	return n
}

func (m *StoresResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Stores) > 0 {
		for _, e := range m.Stores {
			l = e.Size()
			n += 1 + l + sovStatus(uint64(l))
		}
	}
	return n
}

func (m *StatementsRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.NodeID)
	if l > 0 {
		n += 1 + l + sovStatus(uint64(l))
	}
	return n
}

func (m *StatementsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Statements) > 0 {
		for _, e := range m.Statements {
			l = e.Size()
			n += 1 + l + sovStatus(uint64(l))
		}
	}
	l = github_com_gogo_protobuf_types.SizeOfStdTime(m.LastReset)
	n += 1 + l + sovStatus(uint64(l))
	l = len(m.InternalAppNamePrefix)
	if l > 0 {
		n += 1 + l + sovStatus(uint64(l))
	}
	if len(m.Transactions) > 0 {
		for _, e := range m.Transactions {
			l = e.Size()
			n += 1 + l + sovStatus(uint64(l))
		}
	}
	return n
}

func (m *StatementsResponse_ExtendedStatementStatisticsKey) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.KeyData.Size()
	n += 1 + l + sovStatus(uint64(l))
	if m.NodeID != 0 {
		n += 1 + sovStatus(uint64(m.NodeID))
	}
	return n
}

func (m *StatementsResponse_CollectedStatementStatistics) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Key.Size()
	n += 1 + l + sovStatus(uint64(l))
	l = m.Stats.Size()
	n += 1 + l + sovStatus(uint64(l))
	if m.ID != 0 {
		n += 1 + sovStatus(uint64(m.ID))
	}
	return n
}

func (m *StatementsResponse_ExtendedCollectedTransactionStatistics) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.StatsData.Size()
	n += 1 + l + sovStatus(uint64(l))
	if m.NodeID != 0 {
		n += 1 + sovStatus(uint64(m.NodeID))
	}
	return n
}

func (m *StatementDiagnosticsReport) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovStatus(uint64(m.Id))
	}
	if m.Completed {
		n += 2
	}
	l = len(m.StatementFingerprint)
	if l > 0 {
		n += 1 + l + sovStatus(uint64(l))
	}
	if m.StatementDiagnosticsId != 0 {
		n += 1 + sovStatus(uint64(m.StatementDiagnosticsId))
	}
	l = github_com_gogo_protobuf_types.SizeOfStdTime(m.RequestedAt)
	n += 1 + l + sovStatus(uint64(l))
	return n
}

func (m *CreateStatementDiagnosticsReportRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.StatementFingerprint)
	if l > 0 {
		n += 1 + l + sovStatus(uint64(l))
	}
	return n
}

func (m *CreateStatementDiagnosticsReportResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Report != nil {
		l = m.Report.Size()
		n += 1 + l + sovStatus(uint64(l))
	}
	return n
}

func (m *StatementDiagnosticsReportsRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *StatementDiagnosticsReportsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Reports) > 0 {
		for _, e := range m.Reports {
			l = e.Size()
			n += 1 + l + sovStatus(uint64(l))
		}
	}
	return n
}

func (m *StatementDiagnostics) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovStatus(uint64(m.Id))
	}
	l = len(m.StatementFingerprint)
	if l > 0 {
		n += 1 + l + sovStatus(uint64(l))
	}
	l = github_com_gogo_protobuf_types.SizeOfStdTime(m.CollectedAt)
	n += 1 + l + sovStatus(uint64(l))
	return n
}

func (m *StatementDiagnosticsRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.StatementDiagnosticsId != 0 {
		n += 1 + sovStatus(uint64(m.StatementDiagnosticsId))
	}
	return n
}

func (m *StatementDiagnosticsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Diagnostics != nil {
		l = m.Diagnostics.Size()
		n += 1 + l + sovStatus(uint64(l))
	}
	return n
}

func (m *JobRegistryStatusRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.NodeId)
	if l > 0 {
		n += 1 + l + sovStatus(uint64(l))
	}
	return n
}

func (m *JobRegistryStatusResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NodeID != 0 {
		n += 1 + sovStatus(uint64(m.NodeID))
	}
	if len(m.RunningJobs) > 0 {
		for _, e := range m.RunningJobs {
			l = e.Size()
			n += 1 + l + sovStatus(uint64(l))
		}
	}
	return n
}

func (m *JobRegistryStatusResponse_Job) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovStatus(uint64(m.Id))
	}
	return n
}

func (m *JobStatusRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.JobId != 0 {
		n += 1 + sovStatus(uint64(m.JobId))
	}
	return n
}

func (m *JobStatusResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Job != nil {
		l = m.Job.Size()
		n += 1 + l + sovStatus(uint64(l))
	}
	return n
}

func sovStatus(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozStatus(x uint64) (n int) {
	return sovStatus(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *CertificatesRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CertificatesRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CertificatesRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NodeId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStatus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStatus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CertificateDetails) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CertificateDetails: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CertificateDetails: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (CertificateDetails_CertificateType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorMessage", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ErrorMessage = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fields", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Fields = append(m.Fields, CertificateDetails_Fields{})
			if err := m.Fields[len(m.Fields)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStatus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStatus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CertificateDetails_Fields) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Fields: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Fields: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Issuer", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Issuer = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Subject", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Subject = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValidFrom", wireType)
			}
			m.ValidFrom = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ValidFrom |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValidUntil", wireType)
			}
			m.ValidUntil = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ValidUntil |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Addresses", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Addresses = append(m.Addresses, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SignatureAlgorithm", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SignatureAlgorithm = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PublicKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PublicKey = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyUsage", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.KeyUsage = append(m.KeyUsage, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExtendedKeyUsage", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExtendedKeyUsage = append(m.ExtendedKeyUsage, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStatus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStatus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CertificatesResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CertificatesResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CertificatesResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Certificates", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Certificates = append(m.Certificates, CertificateDetails{})
			if err := m.Certificates[len(m.Certificates)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStatus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStatus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DetailsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DetailsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DetailsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NodeId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStatus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStatus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SystemInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SystemInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SystemInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SystemInfo", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SystemInfo = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KernelInfo", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.KernelInfo = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStatus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStatus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DetailsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DetailsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DetailsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeID", wireType)
			}
			m.NodeID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NodeID |= (github_com_cockroachdb_cockroach_pkg_roachpb.NodeID(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Address.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BuildInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.BuildInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SystemInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.SystemInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SQLAddress", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.SQLAddress.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStatus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStatus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NodesRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NodesRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NodesRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipStatus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStatus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NodesResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NodesResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NodesResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nodes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Nodes = append(m.Nodes, statuspb.NodeStatus{})
			if err := m.Nodes[len(m.Nodes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LivenessByNodeID", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LivenessByNodeID == nil {
				m.LivenessByNodeID = make(map[github_com_cockroachdb_cockroach_pkg_roachpb.NodeID]kvserverpb.NodeLivenessStatus)
			}
			var mapkey int32
			var mapvalue kvserverpb.NodeLivenessStatus
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowStatus
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowStatus
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowStatus
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= (kvserverpb.NodeLivenessStatus(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipStatus(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthStatus
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.LivenessByNodeID[github_com_cockroachdb_cockroach_pkg_roachpb.NodeID(mapkey)] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStatus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStatus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NodesResponseExternal) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NodesResponseExternal: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NodesResponseExternal: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nodes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Nodes = append(m.Nodes, NodeResponse{})
			if err := m.Nodes[len(m.Nodes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LivenessByNodeID", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LivenessByNodeID == nil {
				m.LivenessByNodeID = make(map[github_com_cockroachdb_cockroach_pkg_roachpb.NodeID]kvserverpb.NodeLivenessStatus)
			}
			var mapkey int32
			var mapvalue kvserverpb.NodeLivenessStatus
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowStatus
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowStatus
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowStatus
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= (kvserverpb.NodeLivenessStatus(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipStatus(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthStatus
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.LivenessByNodeID[github_com_cockroachdb_cockroach_pkg_roachpb.NodeID(mapkey)] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStatus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStatus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Locality) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Locality: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Locality: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tiers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tiers = append(m.Tiers, Tier{})
			if err := m.Tiers[len(m.Tiers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStatus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStatus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Tier) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Tier: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Tier: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStatus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStatus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Version) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Version: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Version: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Major", wireType)
			}
			m.Major = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Major |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Minor", wireType)
			}
			m.Minor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Minor |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Patch", wireType)
			}
			m.Patch = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Patch |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Internal", wireType)
			}
			m.Internal = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Internal |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipStatus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStatus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NodeDescriptor) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NodeDescriptor: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NodeDescriptor: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeID", wireType)
			}
			m.NodeID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NodeID |= (github_com_cockroachdb_cockroach_pkg_roachpb.NodeID(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Address.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Attrs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Attrs.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Locality", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Locality.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerVersion", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ServerVersion.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BuildTag", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BuildTag = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartedAt", wireType)
			}
			m.StartedAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartedAt |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LocalityAddress", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LocalityAddress = append(m.LocalityAddress, roachpb.LocalityAddress{})
			if err := m.LocalityAddress[len(m.LocalityAddress)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClusterName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SQLAddress", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.SQLAddress.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStatus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStatus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Percentiles) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Percentiles: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Percentiles: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field P10", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.P10 = float64(math.Float64frombits(v))
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field P25", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.P25 = float64(math.Float64frombits(v))
		case 3:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field P50", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.P50 = float64(math.Float64frombits(v))
		case 4:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field P75", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.P75 = float64(math.Float64frombits(v))
		case 5:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field P90", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.P90 = float64(math.Float64frombits(v))
		case 6:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field PMax", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.PMax = float64(math.Float64frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipStatus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStatus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StoreDescriptor) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StoreDescriptor: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StoreDescriptor: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StoreID", wireType)
			}
			m.StoreID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StoreID |= (github_com_cockroachdb_cockroach_pkg_roachpb.StoreID(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Attrs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Attrs.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Node", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Node.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Capacity", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Capacity.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStatus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStatus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StoreStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StoreStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StoreStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Desc", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Desc.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metrics", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Metrics == nil {
				m.Metrics = make(map[string]float64)
			}
			var mapkey string
			var mapvalue float64
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowStatus
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowStatus
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthStatus
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapvaluetemp uint64
					if (iNdEx + 8) > l {
						return io.ErrUnexpectedEOF
					}
					mapvaluetemp = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
					iNdEx += 8
					mapvalue = math.Float64frombits(mapvaluetemp)
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipStatus(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthStatus
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Metrics[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStatus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStatus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NodeResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NodeResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NodeResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Desc", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Desc.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BuildInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.BuildInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartedAt", wireType)
			}
			m.StartedAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartedAt |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdatedAt", wireType)
			}
			m.UpdatedAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UpdatedAt |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metrics", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Metrics == nil {
				m.Metrics = make(map[string]float64)
			}
			var mapkey string
			var mapvalue float64
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowStatus
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowStatus
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthStatus
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapvaluetemp uint64
					if (iNdEx + 8) > l {
						return io.ErrUnexpectedEOF
					}
					mapvaluetemp = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
					iNdEx += 8
					mapvalue = math.Float64frombits(mapvaluetemp)
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipStatus(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthStatus
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Metrics[mapkey] = mapvalue
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StoreStatuses", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StoreStatuses = append(m.StoreStatuses, StoreStatus{})
			if err := m.StoreStatuses[len(m.StoreStatuses)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Args", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Args = append(m.Args, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Env", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Env = append(m.Env, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Latencies", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Latencies == nil {
				m.Latencies = make(map[github_com_cockroachdb_cockroach_pkg_roachpb.NodeID]int64)
			}
			var mapkey int32
			var mapvalue int64
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowStatus
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowStatus
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowStatus
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= (int64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipStatus(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthStatus
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Latencies[github_com_cockroachdb_cockroach_pkg_roachpb.NodeID(mapkey)] = mapvalue
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Activity", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Activity == nil {
				m.Activity = make(map[github_com_cockroachdb_cockroach_pkg_roachpb.NodeID]NodeResponse_NetworkActivity)
			}
			var mapkey int32
			mapvalue := &NodeResponse_NetworkActivity{}
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowStatus
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowStatus
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowStatus
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthStatus
					}
					postmsgIndex := iNdEx + mapmsglen
					if mapmsglen < 0 {
						return ErrInvalidLengthStatus
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &NodeResponse_NetworkActivity{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipStatus(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthStatus
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Activity[github_com_cockroachdb_cockroach_pkg_roachpb.NodeID(mapkey)] = *mapvalue
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalSystemMemory", wireType)
			}
			m.TotalSystemMemory = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalSystemMemory |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumCpus", wireType)
			}
			m.NumCpus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumCpus |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipStatus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStatus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NodeResponse_NetworkActivity) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NetworkActivity: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NetworkActivity: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Incoming", wireType)
			}
			m.Incoming = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Incoming |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Outgoing", wireType)
			}
			m.Outgoing = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Outgoing |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Latency", wireType)
			}
			m.Latency = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Latency |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipStatus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStatus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RegionsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RegionsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RegionsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipStatus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStatus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RegionsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RegionsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RegionsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Regions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Regions == nil {
				m.Regions = make(map[string]*RegionsResponse_Region)
			}
			var mapkey string
			var mapvalue *RegionsResponse_Region
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowStatus
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowStatus
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthStatus
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowStatus
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthStatus
					}
					postmsgIndex := iNdEx + mapmsglen
					if mapmsglen < 0 {
						return ErrInvalidLengthStatus
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &RegionsResponse_Region{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipStatus(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthStatus
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Regions[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStatus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStatus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RegionsResponse_Region) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Region: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Region: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Zones", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Zones = append(m.Zones, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStatus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStatus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NodeRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NodeRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NodeRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NodeId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStatus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStatus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RaftState) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RaftState: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RaftState: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplicaID", wireType)
			}
			m.ReplicaID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReplicaID |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HardState", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.HardState.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lead", wireType)
			}
			m.Lead = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Lead |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.State = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Applied", wireType)
			}
			m.Applied = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Applied |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Progress", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Progress == nil {
				m.Progress = make(map[uint64]RaftState_Progress)
			}
			var mapkey uint64
			mapvalue := &RaftState_Progress{}
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowStatus
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowStatus
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowStatus
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthStatus
					}
					postmsgIndex := iNdEx + mapmsglen
					if mapmsglen < 0 {
						return ErrInvalidLengthStatus
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &RaftState_Progress{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipStatus(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthStatus
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Progress[mapkey] = *mapvalue
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LeadTransferee", wireType)
			}
			m.LeadTransferee = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LeadTransferee |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipStatus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStatus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RaftState_Progress) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Progress: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Progress: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Match", wireType)
			}
			m.Match = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Match |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Next", wireType)
			}
			m.Next = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Next |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.State = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Paused", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Paused = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PendingSnapshot", wireType)
			}
			m.PendingSnapshot = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PendingSnapshot |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipStatus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStatus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RangeProblems) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RangeProblems: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RangeProblems: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Unavailable", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Unavailable = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LeaderNotLeaseHolder", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.LeaderNotLeaseHolder = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NoRaftLeader", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NoRaftLeader = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Underreplicated", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Underreplicated = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NoLease", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NoLease = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field QuiescentEqualsTicking", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.QuiescentEqualsTicking = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RaftLogTooLarge", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RaftLogTooLarge = bool(v != 0)
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Overreplicated", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Overreplicated = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipStatus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStatus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RangeStatistics) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RangeStatistics: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RangeStatistics: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field QueriesPerSecond", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.QueriesPerSecond = float64(math.Float64frombits(v))
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field WritesPerSecond", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.WritesPerSecond = float64(math.Float64frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipStatus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStatus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PrettySpan) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PrettySpan: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PrettySpan: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StartKey = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EndKey = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStatus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStatus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RangeInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RangeInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RangeInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Span", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Span.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RaftState", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RaftState.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.State.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SourceNodeID", wireType)
			}
			m.SourceNodeID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SourceNodeID |= (github_com_cockroachdb_cockroach_pkg_roachpb.NodeID(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SourceStoreID", wireType)
			}
			m.SourceStoreID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SourceStoreID |= (github_com_cockroachdb_cockroach_pkg_roachpb.StoreID(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorMessage", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ErrorMessage = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LeaseHistory", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LeaseHistory = append(m.LeaseHistory, roachpb.Lease{})
			if err := m.LeaseHistory[len(m.LeaseHistory)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Problems", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Problems.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Stats.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LatchesLocal", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.LatchesLocal.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LatchesGlobal", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.LatchesGlobal.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LeaseStatus", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.LeaseStatus.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Quiescent", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Quiescent = bool(v != 0)
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ticking", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Ticking = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipStatus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStatus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RangesRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RangesRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RangesRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NodeId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType == 0 {
				var v github_com_cockroachdb_cockroach_pkg_roachpb.RangeID
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowStatus
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (github_com_cockroachdb_cockroach_pkg_roachpb.RangeID(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.RangeIDs = append(m.RangeIDs, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowStatus
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthStatus
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.RangeIDs) == 0 {
					m.RangeIDs = make([]github_com_cockroachdb_cockroach_pkg_roachpb.RangeID, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v github_com_cockroachdb_cockroach_pkg_roachpb.RangeID
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowStatus
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (github_com_cockroachdb_cockroach_pkg_roachpb.RangeID(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.RangeIDs = append(m.RangeIDs, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field RangeIDs", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipStatus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStatus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RangesResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RangesResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RangesResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ranges", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ranges = append(m.Ranges, RangeInfo{})
			if err := m.Ranges[len(m.Ranges)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStatus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStatus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GossipRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GossipRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GossipRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NodeId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStatus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStatus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EngineStatsInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EngineStatsInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EngineStatsInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StoreID", wireType)
			}
			m.StoreID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StoreID |= (github_com_cockroachdb_cockroach_pkg_roachpb.StoreID(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TickersAndHistograms", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TickersAndHistograms == nil {
				m.TickersAndHistograms = &enginepb.TickersAndHistograms{}
			}
			if err := m.TickersAndHistograms.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EngineType", wireType)
			}
			m.EngineType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EngineType |= (enginepb.EngineType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipStatus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStatus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EngineStatsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EngineStatsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EngineStatsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NodeId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStatus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStatus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EngineStatsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EngineStatsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EngineStatsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Stats = append(m.Stats, EngineStatsInfo{})
			if err := m.Stats[len(m.Stats)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStatus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStatus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TraceEvent) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TraceEvent: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TraceEvent: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(&m.Time, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStatus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStatus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AllocatorDryRun) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AllocatorDryRun: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AllocatorDryRun: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RangeID", wireType)
			}
			m.RangeID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RangeID |= (github_com_cockroachdb_cockroach_pkg_roachpb.RangeID(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Events", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Events = append(m.Events, &TraceEvent{})
			if err := m.Events[len(m.Events)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStatus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStatus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AllocatorRangeRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AllocatorRangeRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AllocatorRangeRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RangeId", wireType)
			}
			m.RangeId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RangeId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipStatus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStatus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AllocatorRangeResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AllocatorRangeResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AllocatorRangeResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeID", wireType)
			}
			m.NodeID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NodeID |= (github_com_cockroachdb_cockroach_pkg_roachpb.NodeID(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DryRun", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DryRun == nil {
				m.DryRun = &AllocatorDryRun{}
			}
			if err := m.DryRun.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStatus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStatus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AllocatorRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AllocatorRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AllocatorRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NodeId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType == 0 {
				var v github_com_cockroachdb_cockroach_pkg_roachpb.RangeID
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowStatus
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (github_com_cockroachdb_cockroach_pkg_roachpb.RangeID(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.RangeIDs = append(m.RangeIDs, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowStatus
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthStatus
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.RangeIDs) == 0 {
					m.RangeIDs = make([]github_com_cockroachdb_cockroach_pkg_roachpb.RangeID, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v github_com_cockroachdb_cockroach_pkg_roachpb.RangeID
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowStatus
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (github_com_cockroachdb_cockroach_pkg_roachpb.RangeID(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.RangeIDs = append(m.RangeIDs, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field RangeIDs", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipStatus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStatus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AllocatorResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AllocatorResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AllocatorResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DryRuns", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DryRuns = append(m.DryRuns, &AllocatorDryRun{})
			if err := m.DryRuns[len(m.DryRuns)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStatus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStatus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *JSONResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: JSONResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: JSONResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStatus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStatus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResponseError) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResponseError: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResponseError: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Error = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Details", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Details = append(m.Details, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStatus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStatus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LogsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LogsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LogsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NodeId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Level", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Level = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartTime", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StartTime = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndTime", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EndTime = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Max", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Max = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pattern", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Pattern = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Redact", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Redact = bool(v != 0)
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeepRedactable", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.KeepRedactable = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipStatus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStatus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LogEntriesResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LogEntriesResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LogEntriesResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Entries", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Entries = append(m.Entries, log.Entry{})
			if err := m.Entries[len(m.Entries)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStatus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStatus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LogFilesListRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LogFilesListRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LogFilesListRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NodeId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStatus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStatus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LogFilesListResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LogFilesListResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LogFilesListResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Files", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Files = append(m.Files, log.FileInfo{})
			if err := m.Files[len(m.Files)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStatus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStatus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LogFileRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LogFileRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LogFileRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NodeId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field File", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.File = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Redact", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Redact = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeepRedactable", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.KeepRedactable = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipStatus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStatus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StacksRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StacksRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StacksRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NodeId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (StacksType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipStatus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStatus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *File) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: File: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: File: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileSize", wireType)
			}
			m.FileSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FileSize |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Contents", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Contents = append(m.Contents[:0], dAtA[iNdEx:postIndex]...)
			if m.Contents == nil {
				m.Contents = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStatus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStatus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetFilesRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetFilesRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetFilesRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NodeId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ListOnly", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ListOnly = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (FileType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Patterns", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Patterns = append(m.Patterns, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStatus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStatus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetFilesResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetFilesResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetFilesResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Files", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Files = append(m.Files, &File{})
			if err := m.Files[len(m.Files)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStatus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStatus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProfileRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProfileRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProfileRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NodeId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (ProfileRequest_Type(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Seconds", wireType)
			}
			m.Seconds = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Seconds |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipStatus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStatus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MetricsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MetricsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MetricsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NodeId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStatus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStatus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RaftRangeNode) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RaftRangeNode: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RaftRangeNode: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeID", wireType)
			}
			m.NodeID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NodeID |= (github_com_cockroachdb_cockroach_pkg_roachpb.NodeID(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Range", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Range.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStatus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStatus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RaftRangeError) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RaftRangeError: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RaftRangeError: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStatus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStatus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RaftRangeStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RaftRangeStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RaftRangeStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RangeID", wireType)
			}
			m.RangeID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RangeID |= (github_com_cockroachdb_cockroach_pkg_roachpb.RangeID(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Errors", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Errors = append(m.Errors, RaftRangeError{})
			if err := m.Errors[len(m.Errors)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nodes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Nodes = append(m.Nodes, RaftRangeNode{})
			if err := m.Nodes[len(m.Nodes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStatus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStatus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RaftDebugRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RaftDebugRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RaftDebugRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v github_com_cockroachdb_cockroach_pkg_roachpb.RangeID
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowStatus
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (github_com_cockroachdb_cockroach_pkg_roachpb.RangeID(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.RangeIDs = append(m.RangeIDs, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowStatus
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthStatus
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.RangeIDs) == 0 {
					m.RangeIDs = make([]github_com_cockroachdb_cockroach_pkg_roachpb.RangeID, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v github_com_cockroachdb_cockroach_pkg_roachpb.RangeID
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowStatus
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (github_com_cockroachdb_cockroach_pkg_roachpb.RangeID(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.RangeIDs = append(m.RangeIDs, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field RangeIDs", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipStatus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStatus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RaftDebugResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RaftDebugResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RaftDebugResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ranges", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Ranges == nil {
				m.Ranges = make(map[github_com_cockroachdb_cockroach_pkg_roachpb.RangeID]RaftRangeStatus)
			}
			var mapkey int64
			mapvalue := &RaftRangeStatus{}
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowStatus
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowStatus
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowStatus
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthStatus
					}
					postmsgIndex := iNdEx + mapmsglen
					if mapmsglen < 0 {
						return ErrInvalidLengthStatus
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &RaftRangeStatus{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipStatus(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthStatus
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Ranges[github_com_cockroachdb_cockroach_pkg_roachpb.RangeID(mapkey)] = *mapvalue
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Errors", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Errors = append(m.Errors, RaftRangeError{})
			if err := m.Errors[len(m.Errors)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStatus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStatus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TxnInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TxnInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TxnInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ID.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Start", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(&m.Start, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxnDescription", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TxnDescription = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumStatementsExecuted", wireType)
			}
			m.NumStatementsExecuted = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumStatementsExecuted |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumRetries", wireType)
			}
			m.NumRetries = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumRetries |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumAutoRetries", wireType)
			}
			m.NumAutoRetries = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumAutoRetries |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Deadline", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(&m.Deadline, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Implicit", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Implicit = bool(v != 0)
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllocBytes", wireType)
			}
			m.AllocBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AllocBytes |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxAllocBytes", wireType)
			}
			m.MaxAllocBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxAllocBytes |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadOnly", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ReadOnly = bool(v != 0)
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsHistorical", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsHistorical = bool(v != 0)
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Priority", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Priority = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStatus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStatus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ActiveQuery) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ActiveQuery: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ActiveQuery: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sql", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sql = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Start", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(&m.Start, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsDistributed", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsDistributed = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Phase", wireType)
			}
			m.Phase = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Phase |= (ActiveQuery_Phase(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Progress", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Progress = float32(math.Float32frombits(v))
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxnID", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TxnID.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SqlAnon", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SqlAnon = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStatus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStatus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListSessionsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListSessionsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListSessionsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Username", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Username = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStatus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStatus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Session) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Session: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Session: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeID", wireType)
			}
			m.NodeID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NodeID |= (github_com_cockroachdb_cockroach_pkg_roachpb.NodeID(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Username", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Username = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClientAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApplicationName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ApplicationName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActiveQueries", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ActiveQueries = append(m.ActiveQueries, ActiveQuery{})
			if err := m.ActiveQueries[len(m.ActiveQueries)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Start", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(&m.Start, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastActiveQuery", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LastActiveQuery = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ID = append(m.ID[:0], dAtA[iNdEx:postIndex]...)
			if m.ID == nil {
				m.ID = []byte{}
			}
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllocBytes", wireType)
			}
			m.AllocBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AllocBytes |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxAllocBytes", wireType)
			}
			m.MaxAllocBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxAllocBytes |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActiveTxn", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ActiveTxn == nil {
				m.ActiveTxn = &TxnInfo{}
			}
			if err := m.ActiveTxn.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastActiveQueryAnon", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LastActiveQueryAnon = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStatus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStatus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListSessionsError) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListSessionsError: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListSessionsError: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeID", wireType)
			}
			m.NodeID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NodeID |= (github_com_cockroachdb_cockroach_pkg_roachpb.NodeID(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStatus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStatus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListSessionsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListSessionsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListSessionsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sessions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sessions = append(m.Sessions, Session{})
			if err := m.Sessions[len(m.Sessions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Errors", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Errors = append(m.Errors, ListSessionsError{})
			if err := m.Errors[len(m.Errors)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStatus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStatus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CancelQueryRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CancelQueryRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CancelQueryRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NodeId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field QueryID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.QueryID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Username", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Username = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStatus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStatus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CancelQueryResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CancelQueryResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CancelQueryResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Canceled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Canceled = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Error = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStatus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStatus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CancelSessionRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CancelSessionRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CancelSessionRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NodeId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionID", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SessionID = append(m.SessionID[:0], dAtA[iNdEx:postIndex]...)
			if m.SessionID == nil {
				m.SessionID = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Username", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Username = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStatus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStatus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CancelSessionResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CancelSessionResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CancelSessionResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Canceled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Canceled = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Error = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStatus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStatus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SpanStatsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SpanStatsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SpanStatsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NodeID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StartKey = append(m.StartKey[:0], dAtA[iNdEx:postIndex]...)
			if m.StartKey == nil {
				m.StartKey = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EndKey = append(m.EndKey[:0], dAtA[iNdEx:postIndex]...)
			if m.EndKey == nil {
				m.EndKey = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStatus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStatus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SpanStatsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SpanStatsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SpanStatsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalStats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TotalStats.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RangeCount", wireType)
			}
			m.RangeCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RangeCount |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApproximateDiskBytes", wireType)
			}
			m.ApproximateDiskBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApproximateDiskBytes |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipStatus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStatus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProblemRangesRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProblemRangesRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProblemRangesRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NodeID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStatus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStatus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProblemRangesResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProblemRangesResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProblemRangesResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeID", wireType)
			}
			m.NodeID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NodeID |= (github_com_cockroachdb_cockroach_pkg_roachpb.NodeID(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProblemsByNodeID", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ProblemsByNodeID == nil {
				m.ProblemsByNodeID = make(map[github_com_cockroachdb_cockroach_pkg_roachpb.NodeID]ProblemRangesResponse_NodeProblems)
			}
			var mapkey int32
			mapvalue := &ProblemRangesResponse_NodeProblems{}
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowStatus
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowStatus
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowStatus
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthStatus
					}
					postmsgIndex := iNdEx + mapmsglen
					if mapmsglen < 0 {
						return ErrInvalidLengthStatus
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &ProblemRangesResponse_NodeProblems{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipStatus(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthStatus
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.ProblemsByNodeID[github_com_cockroachdb_cockroach_pkg_roachpb.NodeID(mapkey)] = *mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStatus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStatus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProblemRangesResponse_NodeProblems) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NodeProblems: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NodeProblems: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorMessage", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ErrorMessage = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType == 0 {
				var v github_com_cockroachdb_cockroach_pkg_roachpb.RangeID
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowStatus
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (github_com_cockroachdb_cockroach_pkg_roachpb.RangeID(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.UnavailableRangeIDs = append(m.UnavailableRangeIDs, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowStatus
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthStatus
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.UnavailableRangeIDs) == 0 {
					m.UnavailableRangeIDs = make([]github_com_cockroachdb_cockroach_pkg_roachpb.RangeID, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v github_com_cockroachdb_cockroach_pkg_roachpb.RangeID
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowStatus
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (github_com_cockroachdb_cockroach_pkg_roachpb.RangeID(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.UnavailableRangeIDs = append(m.UnavailableRangeIDs, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field UnavailableRangeIDs", wireType)
			}
		case 3:
			if wireType == 0 {
				var v github_com_cockroachdb_cockroach_pkg_roachpb.RangeID
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowStatus
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (github_com_cockroachdb_cockroach_pkg_roachpb.RangeID(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.RaftLeaderNotLeaseHolderRangeIDs = append(m.RaftLeaderNotLeaseHolderRangeIDs, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowStatus
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthStatus
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.RaftLeaderNotLeaseHolderRangeIDs) == 0 {
					m.RaftLeaderNotLeaseHolderRangeIDs = make([]github_com_cockroachdb_cockroach_pkg_roachpb.RangeID, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v github_com_cockroachdb_cockroach_pkg_roachpb.RangeID
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowStatus
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (github_com_cockroachdb_cockroach_pkg_roachpb.RangeID(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.RaftLeaderNotLeaseHolderRangeIDs = append(m.RaftLeaderNotLeaseHolderRangeIDs, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field RaftLeaderNotLeaseHolderRangeIDs", wireType)
			}
		case 4:
			if wireType == 0 {
				var v github_com_cockroachdb_cockroach_pkg_roachpb.RangeID
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowStatus
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (github_com_cockroachdb_cockroach_pkg_roachpb.RangeID(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.NoRaftLeaderRangeIDs = append(m.NoRaftLeaderRangeIDs, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowStatus
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthStatus
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.NoRaftLeaderRangeIDs) == 0 {
					m.NoRaftLeaderRangeIDs = make([]github_com_cockroachdb_cockroach_pkg_roachpb.RangeID, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v github_com_cockroachdb_cockroach_pkg_roachpb.RangeID
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowStatus
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (github_com_cockroachdb_cockroach_pkg_roachpb.RangeID(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.NoRaftLeaderRangeIDs = append(m.NoRaftLeaderRangeIDs, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field NoRaftLeaderRangeIDs", wireType)
			}
		case 5:
			if wireType == 0 {
				var v github_com_cockroachdb_cockroach_pkg_roachpb.RangeID
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowStatus
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (github_com_cockroachdb_cockroach_pkg_roachpb.RangeID(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.NoLeaseRangeIDs = append(m.NoLeaseRangeIDs, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowStatus
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthStatus
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.NoLeaseRangeIDs) == 0 {
					m.NoLeaseRangeIDs = make([]github_com_cockroachdb_cockroach_pkg_roachpb.RangeID, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v github_com_cockroachdb_cockroach_pkg_roachpb.RangeID
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowStatus
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (github_com_cockroachdb_cockroach_pkg_roachpb.RangeID(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.NoLeaseRangeIDs = append(m.NoLeaseRangeIDs, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field NoLeaseRangeIDs", wireType)
			}
		case 6:
			if wireType == 0 {
				var v github_com_cockroachdb_cockroach_pkg_roachpb.RangeID
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowStatus
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (github_com_cockroachdb_cockroach_pkg_roachpb.RangeID(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.UnderreplicatedRangeIDs = append(m.UnderreplicatedRangeIDs, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowStatus
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthStatus
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.UnderreplicatedRangeIDs) == 0 {
					m.UnderreplicatedRangeIDs = make([]github_com_cockroachdb_cockroach_pkg_roachpb.RangeID, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v github_com_cockroachdb_cockroach_pkg_roachpb.RangeID
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowStatus
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (github_com_cockroachdb_cockroach_pkg_roachpb.RangeID(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.UnderreplicatedRangeIDs = append(m.UnderreplicatedRangeIDs, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field UnderreplicatedRangeIDs", wireType)
			}
		case 7:
			if wireType == 0 {
				var v github_com_cockroachdb_cockroach_pkg_roachpb.RangeID
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowStatus
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (github_com_cockroachdb_cockroach_pkg_roachpb.RangeID(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.QuiescentEqualsTickingRangeIDs = append(m.QuiescentEqualsTickingRangeIDs, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowStatus
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthStatus
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.QuiescentEqualsTickingRangeIDs) == 0 {
					m.QuiescentEqualsTickingRangeIDs = make([]github_com_cockroachdb_cockroach_pkg_roachpb.RangeID, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v github_com_cockroachdb_cockroach_pkg_roachpb.RangeID
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowStatus
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (github_com_cockroachdb_cockroach_pkg_roachpb.RangeID(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.QuiescentEqualsTickingRangeIDs = append(m.QuiescentEqualsTickingRangeIDs, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field QuiescentEqualsTickingRangeIDs", wireType)
			}
		case 8:
			if wireType == 0 {
				var v github_com_cockroachdb_cockroach_pkg_roachpb.RangeID
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowStatus
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (github_com_cockroachdb_cockroach_pkg_roachpb.RangeID(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.RaftLogTooLargeRangeIDs = append(m.RaftLogTooLargeRangeIDs, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowStatus
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthStatus
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.RaftLogTooLargeRangeIDs) == 0 {
					m.RaftLogTooLargeRangeIDs = make([]github_com_cockroachdb_cockroach_pkg_roachpb.RangeID, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v github_com_cockroachdb_cockroach_pkg_roachpb.RangeID
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowStatus
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (github_com_cockroachdb_cockroach_pkg_roachpb.RangeID(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.RaftLogTooLargeRangeIDs = append(m.RaftLogTooLargeRangeIDs, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field RaftLogTooLargeRangeIDs", wireType)
			}
		case 9:
			if wireType == 0 {
				var v github_com_cockroachdb_cockroach_pkg_roachpb.RangeID
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowStatus
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (github_com_cockroachdb_cockroach_pkg_roachpb.RangeID(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.OverreplicatedRangeIDs = append(m.OverreplicatedRangeIDs, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowStatus
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthStatus
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.OverreplicatedRangeIDs) == 0 {
					m.OverreplicatedRangeIDs = make([]github_com_cockroachdb_cockroach_pkg_roachpb.RangeID, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v github_com_cockroachdb_cockroach_pkg_roachpb.RangeID
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowStatus
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (github_com_cockroachdb_cockroach_pkg_roachpb.RangeID(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.OverreplicatedRangeIDs = append(m.OverreplicatedRangeIDs, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field OverreplicatedRangeIDs", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipStatus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStatus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HotRangesRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HotRangesRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HotRangesRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NodeID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStatus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStatus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HotRangesResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HotRangesResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HotRangesResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeID", wireType)
			}
			m.NodeID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NodeID |= (github_com_cockroachdb_cockroach_pkg_roachpb.NodeID(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HotRangesByNodeID", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.HotRangesByNodeID == nil {
				m.HotRangesByNodeID = make(map[github_com_cockroachdb_cockroach_pkg_roachpb.NodeID]HotRangesResponse_NodeResponse)
			}
			var mapkey int32
			mapvalue := &HotRangesResponse_NodeResponse{}
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowStatus
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowStatus
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowStatus
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthStatus
					}
					postmsgIndex := iNdEx + mapmsglen
					if mapmsglen < 0 {
						return ErrInvalidLengthStatus
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &HotRangesResponse_NodeResponse{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipStatus(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthStatus
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.HotRangesByNodeID[github_com_cockroachdb_cockroach_pkg_roachpb.NodeID(mapkey)] = *mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStatus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStatus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HotRangesResponse_HotRange) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HotRange: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HotRange: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Desc", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Desc.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field QueriesPerSecond", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.QueriesPerSecond = float64(math.Float64frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipStatus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStatus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HotRangesResponse_StoreResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StoreResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StoreResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StoreID", wireType)
			}
			m.StoreID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StoreID |= (github_com_cockroachdb_cockroach_pkg_roachpb.StoreID(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HotRanges", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HotRanges = append(m.HotRanges, HotRangesResponse_HotRange{})
			if err := m.HotRanges[len(m.HotRanges)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStatus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStatus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HotRangesResponse_NodeResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NodeResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NodeResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorMessage", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ErrorMessage = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stores", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Stores = append(m.Stores, &HotRangesResponse_StoreResponse{})
			if err := m.Stores[len(m.Stores)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStatus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStatus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RangeRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RangeRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RangeRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RangeId", wireType)
			}
			m.RangeId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RangeId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipStatus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStatus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RangeResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RangeResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RangeResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeID", wireType)
			}
			m.NodeID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NodeID |= (github_com_cockroachdb_cockroach_pkg_roachpb.NodeID(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RangeID", wireType)
			}
			m.RangeID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RangeID |= (github_com_cockroachdb_cockroach_pkg_roachpb.RangeID(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResponsesByNodeID", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ResponsesByNodeID == nil {
				m.ResponsesByNodeID = make(map[github_com_cockroachdb_cockroach_pkg_roachpb.NodeID]RangeResponse_NodeResponse)
			}
			var mapkey int32
			mapvalue := &RangeResponse_NodeResponse{}
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowStatus
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowStatus
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowStatus
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthStatus
					}
					postmsgIndex := iNdEx + mapmsglen
					if mapmsglen < 0 {
						return ErrInvalidLengthStatus
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &RangeResponse_NodeResponse{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipStatus(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthStatus
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.ResponsesByNodeID[github_com_cockroachdb_cockroach_pkg_roachpb.NodeID(mapkey)] = *mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStatus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStatus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RangeResponse_NodeResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NodeResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NodeResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Response = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorMessage", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ErrorMessage = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Infos", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Infos = append(m.Infos, RangeInfo{})
			if err := m.Infos[len(m.Infos)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStatus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStatus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DiagnosticsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DiagnosticsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DiagnosticsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NodeId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStatus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStatus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StoresRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StoresRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StoresRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NodeId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStatus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStatus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StoreDetails) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StoreDetails: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StoreDetails: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StoreID", wireType)
			}
			m.StoreID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StoreID |= (github_com_cockroachdb_cockroach_pkg_roachpb.StoreID(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EncryptionStatus", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EncryptionStatus = append(m.EncryptionStatus[:0], dAtA[iNdEx:postIndex]...)
			if m.EncryptionStatus == nil {
				m.EncryptionStatus = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalFiles", wireType)
			}
			m.TotalFiles = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalFiles |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalBytes", wireType)
			}
			m.TotalBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalBytes |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActiveKeyFiles", wireType)
			}
			m.ActiveKeyFiles = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ActiveKeyFiles |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActiveKeyBytes", wireType)
			}
			m.ActiveKeyBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ActiveKeyBytes |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipStatus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStatus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StoresResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StoresResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StoresResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stores", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Stores = append(m.Stores, StoreDetails{})
			if err := m.Stores[len(m.Stores)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStatus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStatus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StatementsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StatementsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StatementsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NodeID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStatus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStatus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StatementsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StatementsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StatementsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Statements", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Statements = append(m.Statements, StatementsResponse_CollectedStatementStatistics{})
			if err := m.Statements[len(m.Statements)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastReset", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(&m.LastReset, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InternalAppNamePrefix", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InternalAppNamePrefix = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Transactions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Transactions = append(m.Transactions, StatementsResponse_ExtendedCollectedTransactionStatistics{})
			if err := m.Transactions[len(m.Transactions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStatus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStatus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StatementsResponse_ExtendedStatementStatisticsKey) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExtendedStatementStatisticsKey: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExtendedStatementStatisticsKey: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyData", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.KeyData.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeID", wireType)
			}
			m.NodeID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NodeID |= (github_com_cockroachdb_cockroach_pkg_roachpb.NodeID(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipStatus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStatus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StatementsResponse_CollectedStatementStatistics) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CollectedStatementStatistics: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CollectedStatementStatistics: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Key.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Stats.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= (github_com_cockroachdb_cockroach_pkg_roachpb.StmtID(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipStatus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStatus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StatementsResponse_ExtendedCollectedTransactionStatistics) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExtendedCollectedTransactionStatistics: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExtendedCollectedTransactionStatistics: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StatsData", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.StatsData.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeID", wireType)
			}
			m.NodeID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NodeID |= (github_com_cockroachdb_cockroach_pkg_roachpb.NodeID(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipStatus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStatus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StatementDiagnosticsReport) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StatementDiagnosticsReport: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StatementDiagnosticsReport: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Completed", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Completed = bool(v != 0)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StatementFingerprint", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StatementFingerprint = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StatementDiagnosticsId", wireType)
			}
			m.StatementDiagnosticsId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StatementDiagnosticsId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(&m.RequestedAt, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStatus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStatus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateStatementDiagnosticsReportRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateStatementDiagnosticsReportRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateStatementDiagnosticsReportRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StatementFingerprint", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StatementFingerprint = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStatus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStatus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateStatementDiagnosticsReportResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateStatementDiagnosticsReportResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateStatementDiagnosticsReportResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Report", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Report == nil {
				m.Report = &StatementDiagnosticsReport{}
			}
			if err := m.Report.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStatus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStatus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StatementDiagnosticsReportsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StatementDiagnosticsReportsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StatementDiagnosticsReportsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipStatus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStatus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StatementDiagnosticsReportsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StatementDiagnosticsReportsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StatementDiagnosticsReportsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reports", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reports = append(m.Reports, StatementDiagnosticsReport{})
			if err := m.Reports[len(m.Reports)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStatus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStatus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StatementDiagnostics) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StatementDiagnostics: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StatementDiagnostics: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StatementFingerprint", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StatementFingerprint = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollectedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(&m.CollectedAt, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStatus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStatus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StatementDiagnosticsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StatementDiagnosticsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StatementDiagnosticsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StatementDiagnosticsId", wireType)
			}
			m.StatementDiagnosticsId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StatementDiagnosticsId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipStatus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStatus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StatementDiagnosticsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StatementDiagnosticsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StatementDiagnosticsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Diagnostics", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Diagnostics == nil {
				m.Diagnostics = &StatementDiagnostics{}
			}
			if err := m.Diagnostics.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStatus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStatus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *JobRegistryStatusRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: JobRegistryStatusRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: JobRegistryStatusRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NodeId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStatus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStatus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *JobRegistryStatusResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: JobRegistryStatusResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: JobRegistryStatusResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeID", wireType)
			}
			m.NodeID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NodeID |= (github_com_cockroachdb_cockroach_pkg_roachpb.NodeID(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RunningJobs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RunningJobs = append(m.RunningJobs, &JobRegistryStatusResponse_Job{})
			if err := m.RunningJobs[len(m.RunningJobs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStatus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStatus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *JobRegistryStatusResponse_Job) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Job: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Job: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipStatus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStatus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *JobStatusRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: JobStatusRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: JobStatusRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field JobId", wireType)
			}
			m.JobId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.JobId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipStatus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStatus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *JobStatusResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: JobStatusResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: JobStatusResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Job", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Job == nil {
				m.Job = &jobspb.Job{}
			}
			if err := m.Job.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStatus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStatus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipStatus(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowStatus
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthStatus
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowStatus
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipStatus(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthStatus = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowStatus   = fmt.Errorf("proto: integer overflow")
)

func init() {
	proto.RegisterFile("server/serverpb/status.proto", fileDescriptor_status_c872ae209e16bf4e)
}

var fileDescriptor_status_c872ae209e16bf4e = []byte{
	// 7031 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xe4, 0x3d, 0x6d, 0x6c, 0x1c, 0xc7,
	0x75, 0x5a, 0xde, 0x1d, 0x79, 0xf7, 0x8e, 0x1f, 0xc7, 0x11, 0x49, 0x51, 0x27, 0x99, 0x94, 0x57,
	0xb6, 0x2c, 0xc9, 0xf2, 0x9d, 0x2c, 0x59, 0xfe, 0x4a, 0xec, 0x98, 0x5f, 0x96, 0x28, 0x51, 0x94,
	0xbc, 0x24, 0x93, 0xc2, 0x49, 0x73, 0x5d, 0xde, 0x0e, 0x4f, 0x2b, 0xde, 0xed, 0x9e, 0x76, 0xf7,
	0x18, 0x5e, 0x5c, 0x3b, 0xa9, 0xfb, 0x91, 0x34, 0x49, 0xf3, 0xdd, 0x22, 0x05, 0x0a, 0x34, 0xc8,
	0x8f, 0xa6, 0x28, 0xd0, 0x22, 0x45, 0x51, 0xa0, 0x05, 0xfa, 0x01, 0x14, 0x45, 0x9a, 0xb6, 0x40,
	0x11, 0xa0, 0xfd, 0x11, 0xb4, 0x28, 0xd3, 0xd2, 0xfd, 0x51, 0xa0, 0x3f, 0xfa, 0xa3, 0xff, 0x02,
	0x14, 0x28, 0xe6, 0xcd, 0xcc, 0xde, 0xec, 0xdd, 0x71, 0xef, 0x28, 0x5a, 0x46, 0x80, 0xfe, 0xb0,
	0x79, 0xf3, 0x66, 0xde, 0x9b, 0x37, 0x6f, 0xde, 0xbc, 0x79, 0xf3, 0xe6, 0xcd, 0x0a, 0x4e, 0xfb,
	0xd4, 0xdb, 0xa1, 0x5e, 0x91, 0xff, 0xa9, 0x6f, 0x16, 0xfd, 0xc0, 0x0c, 0x1a, 0x7e, 0xa1, 0xee,
	0xb9, 0x81, 0x4b, 0x4e, 0x96, 0xdd, 0xf2, 0xb6, 0xe7, 0x9a, 0xe5, 0x7b, 0x05, 0xde, 0xa0, 0x20,
	0xdb, 0xe5, 0x73, 0x9b, 0x0d, 0xbb, 0x6a, 0x15, 0x6d, 0x67, 0xcb, 0xe5, 0x8d, 0xf3, 0xc7, 0x2b,
	0xae, 0xef, 0xdb, 0xf5, 0x22, 0xff, 0x23, 0x80, 0x53, 0xf7, 0xdd, 0x4d, 0xbf, 0xc8, 0xfe, 0x57,
	0xdf, 0xc4, 0x3f, 0x02, 0x7e, 0x02, 0xa9, 0xd6, 0x37, 0x8b, 0x66, 0xbd, 0x5e, 0x62, 0x7d, 0xca,
	0x0a, 0x22, 0x2b, 0x2c, 0x33, 0x30, 0x25, 0x11, 0x09, 0xab, 0xd1, 0xc0, 0x54, 0xe0, 0xe7, 0x04,
	0xf3, 0x96, 0x6d, 0x56, 0x1c, 0xd7, 0x0f, 0xec, 0x32, 0xeb, 0x45, 0x29, 0x89, 0x76, 0x67, 0xe5,
	0x20, 0x71, 0x6c, 0xe2, 0x4f, 0xdb, 0x58, 0xf3, 0x8f, 0xf9, 0x81, 0xeb, 0x99, 0x15, 0x5a, 0xa4,
	0x4e, 0xc5, 0x76, 0x68, 0x7d, 0x53, 0xfc, 0x10, 0xd5, 0xa7, 0x3a, 0xaa, 0x6b, 0x3b, 0xe5, 0xb2,
	0xa8, 0x9c, 0xe9, 0xa8, 0xf4, 0xdc, 0xf2, 0xb6, 0x6f, 0x6d, 0x8a, 0xfa, 0x0b, 0xdb, 0x3b, 0xc5,
	0xed, 0x1d, 0xc1, 0x85, 0xfc, 0x51, 0xdf, 0x2c, 0x56, 0xa9, 0xe9, 0xd3, 0x52, 0x84, 0x0d, 0xfd,
	0x80, 0xa6, 0xac, 0x91, 0xe4, 0xe5, 0xc9, 0x83, 0xc8, 0xd9, 0x3b, 0xd4, 0xa1, 0x7e, 0x28, 0xca,
	0x46, 0x60, 0x57, 0x8b, 0x55, 0xb7, 0xc2, 0xfe, 0x13, 0xb0, 0x3c, 0xc2, 0x1a, 0x8e, 0x47, 0x7d,
	0xb7, 0xba, 0x43, 0xad, 0x92, 0x69, 0x59, 0x9e, 0x1c, 0x05, 0x0d, 0xca, 0x56, 0xd1, 0x33, 0xb7,
	0x82, 0xe2, 0xce, 0x55, 0xfc, 0xcb, 0x06, 0x62, 0x6e, 0x05, 0xa2, 0x7e, 0xa2, 0xe2, 0x56, 0x5c,
	0xfc, 0x59, 0x64, 0xbf, 0x04, 0xf4, 0x74, 0xc5, 0x75, 0x2b, 0x55, 0x5a, 0x34, 0xeb, 0x76, 0xd1,
	0x74, 0x1c, 0x37, 0x30, 0x03, 0xdb, 0x75, 0x24, 0x0f, 0xb3, 0xa2, 0x16, 0x4b, 0x9b, 0x8d, 0xad,
	0x62, 0x60, 0xd7, 0xa8, 0x1f, 0x98, 0x35, 0xa1, 0x20, 0x7a, 0x01, 0x8e, 0x2f, 0x50, 0x2f, 0xb0,
	0xb7, 0xec, 0xb2, 0x19, 0x50, 0xdf, 0xa0, 0x0f, 0x1a, 0xd4, 0x0f, 0xc8, 0x09, 0x18, 0x72, 0x5c,
	0x8b, 0x96, 0x6c, 0x6b, 0x5a, 0x3b, 0xa3, 0x9d, 0xcf, 0x18, 0x83, 0xac, 0xb8, 0x6c, 0xe9, 0xff,
	0x9b, 0x04, 0xa2, 0x20, 0x2c, 0xd2, 0xc0, 0xb4, 0xab, 0x3e, 0x79, 0x03, 0x92, 0x41, 0xb3, 0x4e,
	0xb1, 0xf1, 0xe8, 0x95, 0x57, 0x0a, 0x07, 0x2a, 0x6e, 0xa1, 0x13, 0x59, 0x05, 0xad, 0x37, 0xeb,
	0xd4, 0x40, 0x52, 0xe4, 0x2c, 0x8c, 0x50, 0xcf, 0x73, 0xbd, 0x52, 0x8d, 0xfa, 0xbe, 0x59, 0xa1,
	0xd3, 0x03, 0xc8, 0xc8, 0x30, 0x02, 0x6f, 0x73, 0x18, 0x21, 0x90, 0x64, 0x0a, 0x39, 0x9d, 0x38,
	0xa3, 0x9d, 0x1f, 0x36, 0xf0, 0x37, 0x31, 0x60, 0x70, 0xcb, 0xa6, 0x55, 0xcb, 0x9f, 0x4e, 0x9e,
	0x49, 0x9c, 0xcf, 0x5e, 0x79, 0xee, 0x70, 0xdc, 0xbc, 0x8e, 0xb8, 0xf3, 0xc9, 0x1f, 0xec, 0xcd,
	0x1e, 0x33, 0x04, 0xa5, 0xfc, 0x1f, 0x0d, 0xc0, 0x20, 0xaf, 0x20, 0x53, 0x30, 0x68, 0xfb, 0x7e,
	0x83, 0x7a, 0x52, 0x32, 0xbc, 0x44, 0xa6, 0x61, 0xc8, 0x6f, 0x6c, 0xde, 0xa7, 0xe5, 0x40, 0x70,
	0x2a, 0x8b, 0xe4, 0x31, 0x80, 0x1d, 0xb3, 0x6a, 0x5b, 0xa5, 0x2d, 0xcf, 0xad, 0x21, 0xab, 0x09,
	0x23, 0x83, 0x90, 0xd7, 0x3d, 0xb7, 0x46, 0x66, 0x21, 0xcb, 0xab, 0x1b, 0x4e, 0x60, 0x57, 0xa7,
	0x93, 0x58, 0xcf, 0x31, 0x36, 0x18, 0x84, 0x9c, 0x86, 0x0c, 0x53, 0x13, 0xea, 0xfb, 0xd4, 0x9f,
	0x4e, 0x9d, 0x49, 0x9c, 0xcf, 0x18, 0x2d, 0x00, 0x29, 0xc2, 0x71, 0xdf, 0xae, 0x38, 0x66, 0xd0,
	0xf0, 0x68, 0xc9, 0xac, 0x56, 0x5c, 0xcf, 0x0e, 0xee, 0xd5, 0xa6, 0x07, 0x91, 0x07, 0x12, 0x56,
	0xcd, 0xc9, 0x1a, 0xc6, 0x4e, 0xbd, 0xb1, 0x59, 0xb5, 0xcb, 0xa5, 0x6d, 0xda, 0x9c, 0x1e, 0xc2,
	0x76, 0x19, 0x0e, 0xb9, 0x45, 0x9b, 0xe4, 0x14, 0x64, 0xb6, 0x69, 0xb3, 0xd4, 0x40, 0x99, 0xa7,
	0xb1, 0xb7, 0xf4, 0x36, 0x6d, 0x6e, 0xa0, 0xbc, 0x2f, 0x01, 0xa1, 0xbb, 0x01, 0x75, 0x2c, 0x6a,
	0x95, 0x5a, 0xad, 0x32, 0xd8, 0x2a, 0x27, 0x6b, 0x6e, 0x89, 0xd6, 0xfa, 0x1b, 0x30, 0xd6, 0x36,
	0xb7, 0x64, 0x10, 0x06, 0x16, 0xe6, 0x72, 0xc7, 0x48, 0x1a, 0x92, 0xab, 0x77, 0x16, 0x97, 0x72,
	0x1a, 0x19, 0x81, 0xcc, 0xc2, 0xca, 0xf2, 0xd2, 0xea, 0x7a, 0x69, 0x61, 0x2e, 0x37, 0x40, 0x00,
	0x06, 0x79, 0x31, 0x97, 0x20, 0x19, 0x48, 0x6d, 0x2c, 0x33, 0x70, 0x92, 0xe1, 0x6d, 0x2c, 0xe7,
	0x52, 0xba, 0x0b, 0x13, 0x51, 0x7d, 0xf5, 0xeb, 0xae, 0xe3, 0x53, 0xf2, 0x31, 0x18, 0x2e, 0x2b,
	0xf0, 0x69, 0x0d, 0xa7, 0xfe, 0x99, 0x43, 0x4d, 0xbd, 0x98, 0xf3, 0x08, 0x21, 0xbd, 0x08, 0xa3,
	0xa2, 0xba, 0xd7, 0xda, 0xb8, 0x99, 0x4c, 0x0f, 0xe4, 0x12, 0xfa, 0x2a, 0xc0, 0x5a, 0xd3, 0x0f,
	0x68, 0x6d, 0xd9, 0xd9, 0x72, 0xd9, 0xe4, 0xfa, 0x58, 0x2a, 0x31, 0x53, 0x2d, 0x10, 0xc0, 0x8f,
	0x34, 0xd8, 0xa6, 0x9e, 0x43, 0xab, 0xbc, 0x01, 0x57, 0x1d, 0xe0, 0x20, 0xd6, 0x40, 0xff, 0x52,
	0x02, 0xc6, 0x42, 0x0e, 0xc4, 0x68, 0xdf, 0x8c, 0xb2, 0x90, 0x9a, 0x9f, 0xdb, 0xdf, 0x9b, 0x1d,
	0x5c, 0x65, 0x6c, 0x2c, 0xfe, 0x64, 0x6f, 0xf6, 0x6a, 0xc5, 0x0e, 0xee, 0x35, 0x36, 0x0b, 0x65,
	0xb7, 0x56, 0x0c, 0x05, 0x60, 0x6d, 0xb6, 0x7e, 0x17, 0xeb, 0xdb, 0x95, 0xa2, 0xb0, 0xea, 0x05,
	0x8e, 0x26, 0x47, 0x41, 0x5e, 0x85, 0x21, 0xa1, 0x5c, 0xc8, 0x4c, 0xf6, 0xca, 0x8c, 0x22, 0x44,
	0x66, 0xbe, 0x0a, 0x1b, 0xa1, 0xf9, 0x9a, 0xb3, 0x2c, 0x4f, 0x48, 0x4d, 0x22, 0x91, 0x97, 0x01,
	0x70, 0x6f, 0xe2, 0xe3, 0x49, 0x20, 0x89, 0x49, 0x85, 0x04, 0x56, 0x16, 0xd8, 0xd0, 0x04, 0x66,
	0x06, 0x21, 0x28, 0x8c, 0x95, 0xa8, 0xb4, 0x92, 0x88, 0xfc, 0x64, 0xcc, 0x24, 0xb6, 0x24, 0x2d,
	0x88, 0xa9, 0xa2, 0x5d, 0x83, 0xac, 0xff, 0xa0, 0x5a, 0x92, 0xa3, 0x49, 0xf5, 0x35, 0x1a, 0xc2,
	0xc8, 0xec, 0xef, 0xcd, 0xc2, 0xda, 0x1b, 0x2b, 0x73, 0x1c, 0xd3, 0x00, 0xff, 0x41, 0x55, 0xfc,
	0xd6, 0x47, 0x61, 0x98, 0x09, 0x4c, 0x6a, 0x83, 0xfe, 0xcd, 0x04, 0x8c, 0x08, 0x80, 0x98, 0x9c,
	0x1b, 0x90, 0x62, 0xa2, 0x94, 0x3a, 0x78, 0xa9, 0x0b, 0xfb, 0x7c, 0xc7, 0x91, 0x1b, 0x21, 0xce,
	0xc0, 0x1a, 0x16, 0xc4, 0x28, 0x38, 0x01, 0xf2, 0x17, 0x1a, 0x1c, 0x97, 0x9b, 0x4a, 0x69, 0xb3,
	0x59, 0x92, 0x73, 0x3e, 0x80, 0x84, 0x5f, 0x8d, 0x91, 0x4b, 0x84, 0xa3, 0xc2, 0x8a, 0xa0, 0x31,
	0xdf, 0xc4, 0xb9, 0xb6, 0x96, 0x9c, 0xc0, 0x6b, 0xce, 0xdf, 0x11, 0x23, 0xcd, 0xb5, 0x55, 0x2f,
	0xbe, 0xfb, 0xe3, 0x87, 0xd3, 0xa0, 0x5c, 0xb5, 0xad, 0x9f, 0xfc, 0x2e, 0x4c, 0x76, 0xed, 0x9b,
	0xe4, 0x20, 0xc1, 0x8c, 0x0f, 0x2a, 0xaf, 0xc1, 0x7e, 0x92, 0x65, 0x48, 0xed, 0x98, 0xd5, 0x06,
	0x37, 0xf3, 0xa3, 0x57, 0xae, 0x2a, 0x83, 0xdb, 0xde, 0x29, 0xc8, 0x5d, 0xb6, 0x20, 0x76, 0x7a,
	0xd1, 0xa9, 0x24, 0xce, 0x85, 0x67, 0x70, 0x0a, 0x2f, 0x0f, 0xbc, 0xa8, 0xe9, 0xbf, 0x9d, 0x80,
	0xc9, 0x88, 0x10, 0x96, 0x76, 0x03, 0xea, 0x39, 0x66, 0x95, 0x2c, 0x44, 0xa7, 0xe7, 0xa9, 0x1e,
	0x52, 0x94, 0xf8, 0xd1, 0x99, 0xf9, 0x7e, 0xec, 0xcc, 0xbc, 0xde, 0xef, 0xcc, 0x48, 0xa6, 0xfe,
	0x3f, 0xce, 0xd0, 0x75, 0x48, 0xaf, 0xb8, 0x65, 0xb3, 0x6a, 0x07, 0x4d, 0xf2, 0x21, 0x48, 0x05,
	0x36, 0xf5, 0xe4, 0x9c, 0xcc, 0xc6, 0xc8, 0x6f, 0xdd, 0xa6, 0xd2, 0xe4, 0x70, 0x1c, 0xbd, 0x00,
	0x49, 0x06, 0x54, 0x39, 0xce, 0x70, 0x8e, 0x27, 0x54, 0x8e, 0x33, 0xa2, 0x73, 0xfd, 0x8b, 0x1a,
	0x0c, 0x7d, 0x94, 0x7a, 0xbe, 0xed, 0x3a, 0xe4, 0x1c, 0x64, 0x6a, 0xe6, 0x7d, 0xd7, 0x2b, 0xed,
	0x98, 0x55, 0x61, 0x4a, 0x33, 0xfb, 0x7b, 0xb3, 0xa9, 0xdb, 0x0c, 0x68, 0xa4, 0xb1, 0xee, 0xa3,
	0x66, 0x15, 0xdb, 0xd9, 0x8e, 0x68, 0x37, 0xa0, 0xb4, 0x63, 0x40, 0x23, 0x8d, 0x75, 0xac, 0xdd,
	0x04, 0xa4, 0xea, 0x66, 0x50, 0xbe, 0x87, 0x76, 0x2f, 0x65, 0xf0, 0x02, 0xc9, 0x43, 0xda, 0x76,
	0xf8, 0x4c, 0xa3, 0x4d, 0x4b, 0x19, 0x61, 0x59, 0xff, 0x5c, 0x0a, 0x46, 0x99, 0xa0, 0x16, 0xa9,
	0x5f, 0xf6, 0xec, 0x7a, 0xe0, 0x7a, 0x3f, 0xd5, 0xd6, 0xfd, 0x25, 0x48, 0x99, 0x41, 0xe0, 0xf9,
	0xc2, 0xb0, 0x3f, 0xa6, 0x60, 0xcb, 0x1e, 0xe7, 0x82, 0xc0, 0xb3, 0x37, 0x1b, 0x01, 0x0d, 0xad,
	0x19, 0x62, 0x90, 0x25, 0x48, 0x57, 0xc5, 0x84, 0x0b, 0xcb, 0x7e, 0x36, 0x66, 0x9e, 0xa5, 0x6e,
	0x08, 0x1a, 0x21, 0x2a, 0x59, 0x85, 0x91, 0x35, 0x6c, 0x24, 0xe6, 0x50, 0xd8, 0x75, 0x3d, 0x86,
	0x96, 0x68, 0x29, 0x48, 0x45, 0xd1, 0x99, 0xbf, 0xc3, 0xf7, 0xab, 0xc0, 0xac, 0x08, 0xaf, 0x29,
	0x8d, 0x80, 0x75, 0xb3, 0xc2, 0x7c, 0x25, 0x3f, 0x30, 0xbd, 0x80, 0x79, 0xea, 0x01, 0xfa, 0x4a,
	0x09, 0x23, 0x23, 0x20, 0x73, 0x01, 0x59, 0x83, 0x9c, 0xe4, 0x2b, 0xdc, 0x66, 0xd2, 0xa8, 0xc2,
	0x7a, 0x17, 0xc1, 0xc8, 0x21, 0x89, 0xad, 0x44, 0xb0, 0x33, 0x56, 0x8d, 0x82, 0xc9, 0xe3, 0x30,
	0x5c, 0xae, 0x36, 0xfc, 0x80, 0x7a, 0x25, 0xc7, 0xac, 0x31, 0xef, 0x8a, 0xf1, 0x94, 0x15, 0xb0,
	0x55, 0xb3, 0x46, 0xdb, 0x77, 0x36, 0x78, 0x5f, 0x76, 0xb6, 0xb7, 0x20, 0x7b, 0x97, 0x7a, 0x65,
	0xca, 0x7c, 0x4e, 0xea, 0xb3, 0xe5, 0x54, 0x7f, 0xf6, 0x32, 0x6a, 0xa0, 0x66, 0xb0, 0x9f, 0x08,
	0xb9, 0x72, 0x0d, 0xf5, 0x86, 0x41, 0xae, 0x5c, 0x43, 0xc8, 0xb5, 0xcb, 0xa8, 0x0b, 0x0c, 0x72,
	0x8d, 0xb7, 0x79, 0xe1, 0x1a, 0xce, 0x2f, 0x83, 0xbc, 0xc0, 0xdb, 0xbc, 0x74, 0x19, 0x67, 0x89,
	0x41, 0x5e, 0xba, 0xcc, 0x9c, 0xf6, 0xfa, 0x6d, 0x73, 0x17, 0x85, 0xad, 0x19, 0xf8, 0x5b, 0xff,
	0xe3, 0x01, 0x18, 0x5b, 0x0b, 0x5c, 0x4f, 0x5d, 0x07, 0x9f, 0x84, 0x34, 0x33, 0x26, 0xca, 0x42,
	0x58, 0xd8, 0xdf, 0x9b, 0x1d, 0xc2, 0x66, 0xb8, 0x12, 0x9e, 0x3b, 0xd4, 0x4a, 0x10, 0x78, 0xc6,
	0x10, 0x12, 0x5d, 0xb6, 0x5a, 0xba, 0x3c, 0x70, 0x68, 0x5d, 0x5e, 0x80, 0x24, 0x5b, 0x50, 0x62,
	0x15, 0x5c, 0xe8, 0x61, 0xef, 0x5b, 0x63, 0x12, 0x54, 0x10, 0x99, 0xcc, 0x43, 0xba, 0x6c, 0xd6,
	0xcd, 0x72, 0x6b, 0x41, 0x9c, 0xe9, 0xc2, 0x02, 0xb2, 0xbd, 0x20, 0xda, 0xc9, 0xd5, 0x20, 0xf1,
	0xf4, 0x3d, 0x0d, 0xb2, 0xd8, 0x82, 0x1b, 0x58, 0xb2, 0x08, 0x49, 0x8b, 0xfa, 0x65, 0x94, 0x57,
	0xf6, 0xca, 0xc5, 0x38, 0xd7, 0x29, 0x2a, 0x6d, 0xc9, 0x19, 0xc3, 0x26, 0xb7, 0x61, 0xa8, 0x46,
	0x03, 0xcf, 0x2e, 0xfb, 0x62, 0x47, 0xbb, 0xda, 0x8b, 0x10, 0xef, 0xbe, 0x70, 0x9b, 0x63, 0xe1,
	0x16, 0x62, 0x48, 0x1a, 0xf9, 0x97, 0x61, 0x58, 0xad, 0xe8, 0x65, 0xa9, 0x35, 0x75, 0x9b, 0xf8,
	0xd7, 0x34, 0x77, 0xb8, 0x42, 0xf7, 0x6a, 0x21, 0x32, 0xc2, 0xc3, 0x8b, 0x1e, 0x07, 0x18, 0x75,
	0x52, 0x07, 0x0e, 0xe5, 0xa4, 0x46, 0x6d, 0x42, 0xa2, 0xdd, 0x26, 0x3c, 0x06, 0xd0, 0xa8, 0x5b,
	0xa6, 0xa8, 0xe6, 0xa7, 0xb9, 0x8c, 0x80, 0xcc, 0x05, 0x64, 0xb5, 0x25, 0xda, 0x54, 0xcf, 0xe3,
	0xa9, 0x3a, 0xf0, 0xee, 0xb2, 0x25, 0x6b, 0x30, 0xca, 0x17, 0x09, 0xf7, 0x26, 0xa9, 0x3f, 0x3d,
	0x88, 0x64, 0xcf, 0xf5, 0x37, 0x63, 0xd2, 0x26, 0xfa, 0x2d, 0x10, 0xf5, 0xd9, 0x0a, 0x35, 0xbd,
	0x8a, 0x3f, 0x3d, 0x84, 0x07, 0x3b, 0xfc, 0xcd, 0x26, 0x8d, 0x3a, 0x3b, 0xe2, 0x44, 0xc8, 0x7e,
	0x92, 0xaf, 0x69, 0x90, 0xa9, 0x9a, 0x01, 0x75, 0xca, 0x36, 0xf5, 0xf1, 0x10, 0x98, 0xbd, 0xf2,
	0x7c, 0xbf, 0xa3, 0x59, 0x91, 0x88, 0xdc, 0xd5, 0xf9, 0x10, 0x63, 0xe3, 0x61, 0xdd, 0x9a, 0x16,
	0x17, 0xe4, 0xcb, 0x1a, 0xa4, 0xcd, 0x72, 0x60, 0xef, 0xb0, 0x45, 0x05, 0xc8, 0xd2, 0xb5, 0x7e,
	0x59, 0x9a, 0x13, 0x78, 0xef, 0x03, 0x47, 0x21, 0x0f, 0xa4, 0x00, 0xc7, 0x03, 0x37, 0x30, 0xab,
	0x25, 0x71, 0xb0, 0xa9, 0xd1, 0x9a, 0xeb, 0x35, 0xa7, 0xb3, 0xa8, 0x17, 0xe3, 0x58, 0xc5, 0x0f,
	0x31, 0xb7, 0xb1, 0x82, 0x9c, 0x84, 0xb4, 0xd3, 0xa8, 0x95, 0xca, 0xf5, 0x86, 0x3f, 0x3d, 0x8c,
	0xbe, 0xc2, 0x90, 0xd3, 0xa8, 0x2d, 0xd4, 0x1b, 0x47, 0x5a, 0x46, 0xf9, 0x0f, 0xc3, 0x68, 0x54,
	0xe2, 0x5d, 0x1c, 0xbc, 0x08, 0x76, 0x42, 0xc5, 0x2e, 0xc3, 0xd8, 0x2a, 0x0d, 0x3e, 0xe5, 0x7a,
	0xdb, 0x52, 0x46, 0xdc, 0xa7, 0x29, 0xbb, 0x35, 0xdb, 0xa9, 0x20, 0x8d, 0x84, 0x11, 0x96, 0x59,
	0x9d, 0xdb, 0x08, 0x2a, 0x2e, 0xab, 0xe3, 0xb4, 0xc2, 0x32, 0x99, 0x86, 0x21, 0x3e, 0x5b, 0x4d,
	0xb1, 0x74, 0x64, 0x31, 0x1f, 0xc0, 0x48, 0x64, 0x06, 0xba, 0x70, 0x78, 0x5b, 0xe5, 0x30, 0x7b,
	0xe5, 0x85, 0x7e, 0x67, 0xb6, 0x8d, 0x79, 0xd5, 0xbe, 0xe4, 0x60, 0xd4, 0xa0, 0x15, 0xdb, 0x75,
	0xc2, 0x13, 0xdd, 0xff, 0x68, 0x30, 0x16, 0x82, 0x84, 0xd1, 0x79, 0x03, 0x86, 0x3c, 0x0e, 0x12,
	0x2e, 0x6a, 0x5c, 0xd7, 0x6d, 0xc8, 0xb2, 0x2c, 0x16, 0xae, 0xa0, 0x93, 0x9f, 0x81, 0x41, 0x5e,
	0xc1, 0xe4, 0xfe, 0x69, 0xd7, 0x11, 0x27, 0x92, 0x8c, 0xc1, 0x0b, 0xf9, 0x1a, 0x0c, 0xab, 0x88,
	0x5d, 0x66, 0xfb, 0x7a, 0x54, 0x1a, 0xcf, 0x1e, 0x9a, 0x25, 0x55, 0x0e, 0xe7, 0x20, 0xcb, 0x45,
	0xd6, 0x23, 0x00, 0xf8, 0xbd, 0x24, 0x64, 0x0c, 0x73, 0x2b, 0x60, 0xb6, 0x82, 0x92, 0x4b, 0x00,
	0x1e, 0xad, 0x57, 0xed, 0xb2, 0x29, 0x5b, 0x26, 0xe7, 0x47, 0xf6, 0xf7, 0x66, 0x33, 0x06, 0x87,
	0xb2, 0xc5, 0x29, 0x1a, 0x2c, 0x5b, 0xe4, 0x79, 0x80, 0x7b, 0xa6, 0x67, 0xa1, 0xa9, 0x92, 0x5c,
	0x8f, 0x17, 0x78, 0xa4, 0xb3, 0x70, 0xc3, 0xf4, 0x2c, 0x24, 0x2a, 0x2d, 0xee, 0x3d, 0x09, 0x60,
	0xe6, 0xa8, 0x4a, 0x4d, 0x0b, 0x15, 0x26, 0x69, 0xe0, 0x6f, 0x26, 0x34, 0x4e, 0x26, 0xc9, 0x7d,
	0x7b, 0x2c, 0x30, 0xed, 0x32, 0xeb, 0xf5, 0xaa, 0x4d, 0x2d, 0x74, 0x38, 0x92, 0x86, 0x2c, 0x92,
	0x75, 0x48, 0xd7, 0x3d, 0xb7, 0x82, 0xfe, 0x12, 0xb7, 0x90, 0x57, 0xe2, 0xe4, 0x25, 0x47, 0x58,
	0xb8, 0x2b, 0x90, 0xb8, 0x51, 0x10, 0xdb, 0xaf, 0xa4, 0x44, 0x9e, 0x82, 0x31, 0xc6, 0x4d, 0x29,
	0xf0, 0x4c, 0xc7, 0xdf, 0xa2, 0x1e, 0xa5, 0xe8, 0x24, 0x26, 0x8d, 0x51, 0x06, 0x5e, 0x0f, 0xa1,
	0xf9, 0x5f, 0xd3, 0x20, 0x2d, 0x49, 0x31, 0xde, 0x6b, 0x78, 0x4a, 0x40, 0x81, 0x19, 0xbc, 0xc0,
	0x46, 0xe9, 0xd0, 0x5d, 0x1e, 0x3d, 0x4c, 0x1a, 0xf8, 0xbb, 0x35, 0xca, 0x84, 0x3a, 0xca, 0x29,
	0x18, 0xac, 0x9b, 0x0d, 0x9f, 0x5a, 0x38, 0xf8, 0xb4, 0x21, 0x4a, 0xe4, 0x02, 0xe4, 0xea, 0xd4,
	0xb1, 0x6c, 0xa7, 0x52, 0xf2, 0x1d, 0xb3, 0xee, 0xdf, 0x73, 0x03, 0x21, 0x86, 0x31, 0x01, 0x5f,
	0x13, 0xe0, 0xfc, 0x7d, 0x18, 0x89, 0x8c, 0x4c, 0x55, 0xaf, 0x24, 0x57, 0xaf, 0x85, 0xa8, 0x7a,
	0x3d, 0x73, 0x28, 0x71, 0xa9, 0xaa, 0xb5, 0x3f, 0x00, 0x23, 0x86, 0xe9, 0x54, 0xe8, 0x5d, 0xcf,
	0xdd, 0xac, 0xd2, 0x9a, 0x4f, 0xce, 0x40, 0xb6, 0xe1, 0x98, 0x3b, 0xa6, 0x5d, 0x35, 0x37, 0xab,
	0x3c, 0x6a, 0x9c, 0x36, 0x54, 0x10, 0xb9, 0x06, 0x27, 0x98, 0x04, 0x99, 0x0f, 0xec, 0x06, 0x25,
	0x1e, 0xa8, 0xbf, 0xe7, 0x56, 0x2d, 0xea, 0x21, 0x3b, 0x69, 0x63, 0x82, 0x57, 0xaf, 0xba, 0xc1,
	0x0a, 0xab, 0xbc, 0x81, 0x75, 0xe4, 0x09, 0x18, 0x75, 0xdc, 0x12, 0xd3, 0xa8, 0x12, 0xaf, 0x47,
	0xc1, 0xa5, 0x8d, 0x61, 0xc7, 0x65, 0x3c, 0xae, 0x20, 0x8c, 0x9c, 0x87, 0xb1, 0x86, 0x63, 0x51,
	0x4f, 0x68, 0x66, 0x10, 0x0a, 0xb2, 0x1d, 0x8c, 0xd6, 0xd8, 0xe5, 0xdd, 0xa3, 0x24, 0xd3, 0xc6,
	0x90, 0xe3, 0x62, 0x87, 0xe4, 0x45, 0x98, 0x7e, 0xd0, 0xb0, 0xa9, 0xcf, 0x1c, 0xe6, 0x12, 0x7d,
	0xd0, 0x30, 0xab, 0x7e, 0x29, 0xb0, 0xcb, 0xdb, 0xcc, 0xe8, 0x0d, 0x62, 0xd3, 0xa9, 0xb0, 0x7e,
	0x09, 0xab, 0xd7, 0x79, 0x2d, 0x79, 0x1a, 0x08, 0xe7, 0xd0, 0xad, 0x94, 0x02, 0xd7, 0x2d, 0x55,
	0x4d, 0xaf, 0xc2, 0xf5, 0x26, 0x6d, 0x8c, 0xb1, 0x9a, 0x15, 0xb7, 0xb2, 0xee, 0xba, 0x2b, 0x0c,
	0x4c, 0xce, 0xc1, 0xa8, 0xbb, 0x13, 0x61, 0x35, 0x8d, 0x0d, 0xdb, 0xa0, 0xfa, 0x36, 0x8c, 0xa1,
	0x8c, 0xd9, 0x34, 0xd8, 0x78, 0xfb, 0x42, 0x2e, 0x01, 0x79, 0xd0, 0xa0, 0x9e, 0x4d, 0xfd, 0x52,
	0x9d, 0x7a, 0x25, 0x9f, 0x96, 0x5d, 0xc7, 0x12, 0x0e, 0x7d, 0x4e, 0xd4, 0xdc, 0xa5, 0xde, 0x1a,
	0xc2, 0xc9, 0x45, 0x18, 0xff, 0x94, 0x67, 0x07, 0xd1, 0xc6, 0x7c, 0x1f, 0x19, 0xe3, 0x15, 0x61,
	0x5b, 0xfd, 0x06, 0xc0, 0x5d, 0x8f, 0x06, 0x41, 0x73, 0xad, 0x6e, 0xe2, 0x09, 0x0a, 0xdd, 0x9f,
	0x52, 0xcb, 0x3e, 0xa5, 0x11, 0x70, 0x8b, 0x36, 0x99, 0x21, 0xa1, 0x0e, 0x06, 0x8b, 0xc5, 0x29,
	0x7c, 0x90, 0x3a, 0xd6, 0x2d, 0xda, 0x7c, 0x39, 0xf9, 0x9f, 0xdf, 0x9e, 0xd5, 0xf4, 0x2f, 0xa5,
	0x99, 0x39, 0x71, 0x2a, 0x14, 0x5d, 0xab, 0x8f, 0x40, 0xd2, 0xaf, 0x9b, 0x8e, 0xf0, 0xed, 0xe2,
	0x02, 0x7f, 0xad, 0xee, 0xa5, 0x5f, 0xc7, 0x10, 0xc9, 0x32, 0x00, 0x8a, 0x56, 0xb5, 0x30, 0x4f,
	0xf4, 0xa3, 0xb8, 0xd2, 0xe8, 0x78, 0xa1, 0x69, 0x7b, 0x5d, 0x35, 0x30, 0x51, 0x57, 0xba, 0x7b,
	0xb8, 0x23, 0x1c, 0x86, 0x3c, 0x2a, 0xf0, 0xc5, 0x5a, 0x83, 0x51, 0xdf, 0x6d, 0x78, 0x65, 0x1a,
	0x06, 0x89, 0x52, 0x78, 0x96, 0xb9, 0xbe, 0xbf, 0x37, 0x3b, 0xbc, 0x86, 0x35, 0x47, 0x3b, 0xda,
	0x0f, 0xfb, 0x2d, 0x22, 0x16, 0x79, 0x00, 0x63, 0xa2, 0xbb, 0xf0, 0xec, 0x34, 0x88, 0xfd, 0x2d,
	0xef, 0xef, 0xcd, 0x8e, 0xf0, 0xfe, 0x8e, 0x7a, 0x82, 0x1a, 0xf1, 0x15, 0x32, 0x56, 0xe7, 0x4d,
	0xcd, 0x50, 0x97, 0x9b, 0x9a, 0x05, 0x18, 0x11, 0xab, 0xd8, 0x66, 0x8c, 0x35, 0xc5, 0x39, 0x79,
	0xba, 0xdb, 0x39, 0x99, 0xb5, 0x93, 0xc1, 0x78, 0x44, 0xba, 0xc1, 0x71, 0xc8, 0x4d, 0x34, 0xe2,
	0x68, 0x43, 0xf0, 0x58, 0x9c, 0xbd, 0x72, 0x3e, 0x76, 0x72, 0x15, 0x9b, 0xa3, 0x98, 0x6e, 0x6e,
	0x83, 0xc4, 0xfc, 0xca, 0xd3, 0xf3, 0xc5, 0x5e, 0x84, 0x5a, 0x0b, 0x4b, 0x9d, 0x5f, 0x9f, 0x7c,
	0x02, 0x46, 0xaa, 0xcc, 0x7e, 0x53, 0xbf, 0x84, 0x27, 0x79, 0x74, 0xed, 0xa2, 0xbb, 0x71, 0x77,
	0x7d, 0x59, 0x61, 0x58, 0xb7, 0x4d, 0xc7, 0xac, 0x50, 0x4f, 0x51, 0x9b, 0x61, 0x41, 0x0d, 0xa3,
	0x05, 0xe4, 0x93, 0x30, 0x2a, 0xa9, 0x57, 0xaa, 0xee, 0xa6, 0x59, 0x45, 0xa7, 0xf0, 0x08, 0xe4,
	0x25, 0xb3, 0xd7, 0x91, 0x1a, 0xd9, 0x80, 0x61, 0xf5, 0x16, 0x74, 0x7a, 0x04, 0xa9, 0x5f, 0xea,
	0x4d, 0x9d, 0x21, 0x45, 0x8e, 0x10, 0xd9, 0x6a, 0x0b, 0x44, 0x4e, 0x43, 0x26, 0x34, 0x7e, 0xd3,
	0xa3, 0x68, 0xb0, 0x5a, 0x00, 0xb6, 0x4b, 0x4b, 0x4b, 0x39, 0xc6, 0x8d, 0xaa, 0x28, 0xea, 0x5f,
	0xd4, 0xc4, 0x56, 0xd1, 0xf3, 0xb6, 0x85, 0x98, 0x90, 0xf1, 0x58, 0xcb, 0x92, 0x6d, 0xf1, 0x53,
	0x6a, 0x62, 0x7e, 0x71, 0x7f, 0x6f, 0x36, 0xcd, 0x97, 0xe1, 0xa2, 0x7f, 0x68, 0xed, 0x16, 0x88,
	0x46, 0x1a, 0xc9, 0x2e, 0x5b, 0xbe, 0xbe, 0x0e, 0xa3, 0x92, 0x19, 0xe1, 0x07, 0xce, 0xc3, 0x20,
	0xd6, 0x4a, 0x37, 0xf0, 0x89, 0x5e, 0x5a, 0xa3, 0x48, 0x5e, 0x60, 0xea, 0xe7, 0x61, 0xe4, 0x3a,
	0xde, 0xd1, 0xf7, 0xf4, 0xb5, 0xbe, 0x33, 0x00, 0x63, 0x4b, 0x78, 0xa5, 0xcd, 0xc4, 0xea, 0xa3,
	0x89, 0x7c, 0xd4, 0x41, 0x91, 0x2d, 0x98, 0x62, 0x93, 0x41, 0x3d, 0xbf, 0x64, 0x3a, 0x16, 0x5f,
	0xad, 0x15, 0xcf, 0xac, 0xc9, 0x28, 0xc9, 0x65, 0x75, 0xc4, 0x5c, 0x1d, 0x0a, 0xf2, 0xda, 0xbd,
	0xb0, 0xce, 0x31, 0xe7, 0x1c, 0xeb, 0x46, 0x88, 0x67, 0x4c, 0x04, 0x5d, 0xa0, 0xe4, 0x3a, 0x64,
	0x39, 0x5a, 0x09, 0x2f, 0x8e, 0x13, 0x18, 0x53, 0x3e, 0x17, 0x47, 0x9c, 0x4b, 0x02, 0x6f, 0x88,
	0x81, 0x86, 0xbf, 0xf5, 0x67, 0x80, 0x28, 0x32, 0xea, 0x29, 0xd3, 0x9f, 0x85, 0xe3, 0x91, 0xe6,
	0x62, 0x62, 0x43, 0x6b, 0xc0, 0xe7, 0x35, 0xce, 0x1a, 0xb4, 0xcd, 0x48, 0xc4, 0x1a, 0xe8, 0x3f,
	0x07, 0xb0, 0xee, 0x99, 0x65, 0xba, 0xb4, 0xc3, 0x14, 0xfd, 0x45, 0x48, 0x06, 0x76, 0x8d, 0x8a,
	0xfd, 0x2c, 0x5f, 0xe0, 0xb7, 0xf1, 0x05, 0x79, 0x1b, 0x5f, 0x58, 0x97, 0xb7, 0xf1, 0xf3, 0x69,
	0x46, 0xe4, 0xab, 0x3f, 0x9e, 0xd5, 0x0c, 0xc4, 0x60, 0x4b, 0x24, 0x7a, 0xef, 0x2d, 0x8b, 0xfa,
	0xf7, 0x34, 0x18, 0x9b, 0xab, 0x32, 0x53, 0x13, 0xb8, 0xde, 0xa2, 0xd7, 0x34, 0x1a, 0x0e, 0x53,
	0x0a, 0xb9, 0x16, 0xf8, 0x61, 0x8c, 0x2b, 0x85, 0xd0, 0xe8, 0x87, 0x5e, 0x09, 0x43, 0x62, 0x25,
	0x90, 0x57, 0x60, 0x90, 0xb2, 0x01, 0xc9, 0x70, 0x50, 0xdc, 0xce, 0xdc, 0x1a, 0xbe, 0x21, 0x90,
	0xf4, 0x2b, 0x30, 0x19, 0x72, 0x8c, 0xb4, 0xe5, 0x2c, 0x9d, 0x6c, 0xe7, 0x3b, 0xec, 0x52, 0xff,
	0x53, 0x0d, 0xa6, 0xda, 0x91, 0xba, 0xdf, 0x7e, 0x26, 0xde, 0xcf, 0xf8, 0xf8, 0x02, 0x0c, 0x59,
	0x5e, 0xb3, 0xe4, 0x35, 0x1c, 0xa1, 0xef, 0x71, 0x9a, 0xd0, 0x36, 0x0d, 0xc6, 0xa0, 0x85, 0x7f,
	0xf5, 0x2f, 0x6b, 0x90, 0x6b, 0xf1, 0xfe, 0x53, 0x60, 0xc8, 0xde, 0x84, 0x71, 0x85, 0x1f, 0x21,
	0xc6, 0x25, 0x48, 0x8b, 0xa1, 0xf6, 0xa3, 0xf5, 0xed, 0x63, 0x1d, 0xe2, 0x63, 0xf5, 0x75, 0x1d,
	0x86, 0x6f, 0xae, 0xdd, 0x59, 0x0d, 0xc9, 0xca, 0x94, 0x0c, 0xad, 0x95, 0x92, 0xa1, 0xd7, 0x60,
	0x24, 0xbc, 0xf2, 0x62, 0x4e, 0x01, 0x3b, 0xd7, 0xa0, 0x77, 0x20, 0x44, 0xc1, 0x0b, 0x0c, 0xb5,
	0xec, 0x5a, 0x5c, 0xe3, 0x53, 0x06, 0xfe, 0x56, 0x17, 0x42, 0x22, 0xb2, 0x10, 0x58, 0x8d, 0xc5,
	0xef, 0xc5, 0x31, 0xd1, 0x23, 0x63, 0xc8, 0xa2, 0xfe, 0x9e, 0x06, 0xd9, 0x15, 0xb7, 0xd2, 0x7b,
	0x0f, 0x99, 0x80, 0x54, 0x95, 0xee, 0xd0, 0xaa, 0xbc, 0x20, 0xc2, 0x42, 0x18, 0xe0, 0x2b, 0xe1,
	0xda, 0xe5, 0xbd, 0x72, 0x0f, 0x97, 0xad, 0x57, 0xa6, 0xb4, 0xcc, 0xa3, 0xc5, 0x4a, 0x7e, 0xf8,
	0x64, 0x1e, 0x2e, 0x56, 0xe5, 0x20, 0x51, 0x33, 0x77, 0xd1, 0xc1, 0xcb, 0x18, 0xec, 0x27, 0x63,
	0xb2, 0x6e, 0x06, 0x01, 0xf5, 0x1c, 0x71, 0xb7, 0x20, 0x8b, 0xec, 0x10, 0xe7, 0x51, 0xcb, 0x2c,
	0x07, 0xc2, 0xf3, 0x17, 0x25, 0x76, 0xa4, 0xdc, 0xa6, 0xb4, 0x5e, 0xe2, 0x45, 0x3c, 0x1f, 0x09,
	0x8f, 0x9f, 0x81, 0x8d, 0x10, 0xaa, 0xdf, 0x01, 0xb2, 0xe2, 0x56, 0xd8, 0xe9, 0xcd, 0x56, 0x76,
	0xa8, 0x97, 0x98, 0xbf, 0x8d, 0x20, 0x31, 0xa9, 0x27, 0xdb, 0xaf, 0x05, 0xaa, 0x6e, 0xa5, 0xa0,
	0x9e, 0x66, 0x65, 0x7b, 0xbd, 0x00, 0xc7, 0x57, 0xdc, 0xca, 0xeb, 0x76, 0x95, 0xfa, 0x2b, 0xb6,
	0x1f, 0xf4, 0x34, 0xa5, 0x77, 0x61, 0x22, 0xda, 0x5e, 0xb0, 0xf0, 0x22, 0xa4, 0xb6, 0x18, 0x50,
	0x30, 0x70, 0xba, 0x1b, 0x03, 0x0c, 0x4b, 0xb5, 0x9e, 0x88, 0xa0, 0xbf, 0x03, 0xa3, 0x82, 0x62,
	0xcf, 0xa9, 0x23, 0x90, 0x64, 0x38, 0x62, 0xe6, 0xf0, 0xb7, 0x22, 0xd2, 0x44, 0x2f, 0x91, 0x26,
	0xbb, 0x8a, 0xb4, 0x0c, 0x23, 0x6b, 0x81, 0x59, 0xde, 0xee, 0xad, 0x39, 0x2f, 0x89, 0x84, 0x27,
	0x7e, 0x17, 0x1a, 0x9b, 0xa2, 0x80, 0x04, 0x5b, 0x89, 0x4d, 0xfa, 0x1a, 0x24, 0xd9, 0x08, 0xf1,
	0xbc, 0x6f, 0x8a, 0xcd, 0x21, 0x63, 0xe0, 0x6f, 0x76, 0x94, 0x62, 0x23, 0x29, 0xf9, 0xf6, 0xa7,
	0x65, 0x18, 0x2e, 0xcd, 0x00, 0x6b, 0xf6, 0xa7, 0x29, 0xc9, 0x43, 0xba, 0xec, 0x3a, 0x01, 0xda,
	0x61, 0x9e, 0xf0, 0x14, 0x96, 0xf5, 0xdf, 0xd2, 0x60, 0xec, 0x3a, 0x0d, 0x70, 0x32, 0x7a, 0x32,
	0x7f, 0x0a, 0x32, 0x55, 0xdb, 0x0f, 0x4a, 0xae, 0x53, 0x6d, 0x8a, 0xe3, 0x74, 0x9a, 0x01, 0xee,
	0x38, 0xd5, 0x26, 0x79, 0x41, 0x8c, 0x2c, 0x85, 0x23, 0x8b, 0xbb, 0xa2, 0x63, 0x9d, 0x29, 0x09,
	0x5b, 0x79, 0x48, 0x0b, 0xdd, 0xe6, 0x11, 0x96, 0x8c, 0x11, 0x96, 0xf5, 0x65, 0xc8, 0xb5, 0xb8,
	0x13, 0x6a, 0x72, 0x2d, 0xaa, 0x26, 0xb3, 0x3d, 0x7a, 0x92, 0x3a, 0xf2, 0x1d, 0x0d, 0x46, 0xef,
	0x7a, 0xee, 0x56, 0x3f, 0x4a, 0x32, 0x1f, 0x19, 0x4b, 0x21, 0xf6, 0x3c, 0xa9, 0x52, 0x2c, 0x28,
	0xc3, 0x9a, 0x86, 0x21, 0x7e, 0x18, 0xf6, 0xf9, 0x41, 0xca, 0x90, 0x45, 0xfd, 0x24, 0x24, 0x31,
	0xa7, 0x29, 0x0d, 0xc9, 0x1b, 0x4b, 0x73, 0x77, 0x73, 0xc7, 0xc8, 0x10, 0x24, 0x16, 0xee, 0x6e,
	0xe4, 0x34, 0xfd, 0x02, 0x8c, 0x8a, 0x50, 0x6d, 0xcf, 0x55, 0xf4, 0xfb, 0xe8, 0xf2, 0x6e, 0x05,
	0x68, 0xb5, 0xd9, 0x6e, 0xf4, 0x48, 0xef, 0x7f, 0x5f, 0x83, 0x14, 0xee, 0x0a, 0x7d, 0x9d, 0x8d,
	0xdb, 0xce, 0xb3, 0x88, 0xa8, 0x5f, 0x64, 0x4e, 0xb1, 0x60, 0x97, 0x1b, 0x73, 0xc5, 0x44, 0x6b,
	0x51, 0x5f, 0xe5, 0xb3, 0x03, 0x30, 0x16, 0x36, 0x16, 0x47, 0x83, 0x47, 0xed, 0xab, 0x5c, 0x87,
	0x41, 0xdc, 0x4d, 0xa4, 0xaf, 0x72, 0xa1, 0xc7, 0xf1, 0xbf, 0x35, 0x10, 0xe9, 0xa7, 0x73, 0x74,
	0xb2, 0x28, 0x13, 0x45, 0x12, 0x48, 0xe7, 0x7c, 0x3f, 0x74, 0x98, 0xb4, 0x23, 0x99, 0x22, 0x7a,
	0x03, 0x72, 0xac, 0x76, 0x91, 0x6e, 0x36, 0x2a, 0x52, 0x17, 0x22, 0x3b, 0xbe, 0xf6, 0x48, 0x76,
	0xfc, 0x7f, 0x1a, 0x80, 0x71, 0xa5, 0x5f, 0xb1, 0xe4, 0xbe, 0xac, 0xb5, 0x9d, 0x5f, 0x5e, 0xec,
	0x31, 0xa8, 0x08, 0x3a, 0xef, 0x46, 0x44, 0x42, 0x3f, 0x2c, 0xae, 0x47, 0x1e, 0x8e, 0x51, 0xc1,
	0xc5, 0xfb, 0x36, 0x59, 0x79, 0x0a, 0x59, 0x85, 0x3b, 0x35, 0x9a, 0x99, 0xe0, 0xd1, 0xcc, 0xd7,
	0xa2, 0xd1, 0xcc, 0x8b, 0xfd, 0x74, 0xd4, 0x99, 0xb4, 0xf2, 0xb7, 0x49, 0x18, 0x5a, 0xdf, 0x75,
	0xf0, 0x24, 0xf6, 0x06, 0x0c, 0x08, 0x15, 0x1e, 0x9e, 0x9f, 0x63, 0xcc, 0xfc, 0x73, 0xbf, 0x6b,
	0x93, 0x27, 0x01, 0x37, 0x6c, 0xab, 0xb0, 0xb1, 0xb1, 0xcc, 0x66, 0x7e, 0x60, 0x79, 0xd1, 0x18,
	0xb0, 0x2d, 0xf2, 0x32, 0x9e, 0x42, 0xbc, 0x40, 0x30, 0xd9, 0xdf, 0x81, 0x81, 0xa3, 0xb0, 0x4d,
	0x2e, 0xd8, 0x75, 0x4a, 0x96, 0xb8, 0xf0, 0xb4, 0x5d, 0x47, 0xb8, 0x2e, 0xa3, 0xc1, 0xae, 0xb3,
	0xd8, 0x82, 0x92, 0xe7, 0xe1, 0x84, 0xd3, 0xa8, 0xf1, 0x10, 0x59, 0x8d, 0x6d, 0x1e, 0x25, 0xba,
	0x4b, 0xcb, 0x0d, 0x19, 0x05, 0x4d, 0x19, 0x93, 0x4e, 0xa3, 0xb6, 0x16, 0xd6, 0x2e, 0x89, 0x4a,
	0x32, 0x0b, 0x59, 0x86, 0xe7, 0x51, 0xee, 0x5d, 0x60, 0x14, 0xcb, 0x00, 0xa7, 0x51, 0x33, 0x38,
	0x84, 0x9c, 0x87, 0x1c, 0x6b, 0x60, 0x36, 0x02, 0x37, 0x6c, 0xc5, 0x4d, 0xe6, 0xa8, 0xd3, 0xa8,
	0xcd, 0x35, 0x02, 0x57, 0xb6, 0x7c, 0x0d, 0xd2, 0x16, 0x35, 0xad, 0xaa, 0xed, 0xf0, 0x60, 0x51,
	0xbf, 0x43, 0x0d, 0xb1, 0xf0, 0xfa, 0xa9, 0x56, 0xaf, 0xda, 0x65, 0x3b, 0x10, 0xee, 0x51, 0x58,
	0x66, 0x8c, 0x9a, 0xcc, 0x5b, 0x2d, 0x6d, 0x36, 0x03, 0xca, 0x03, 0x45, 0x09, 0x03, 0x10, 0x34,
	0xcf, 0x20, 0xe4, 0x1c, 0x8c, 0xd5, 0xcc, 0xdd, 0x92, 0xda, 0x08, 0xb0, 0xd1, 0x48, 0xcd, 0xdc,
	0x9d, 0x6b, 0xb5, 0x3b, 0x05, 0x19, 0x8f, 0x9a, 0x16, 0xdf, 0x27, 0xb3, 0xbc, 0x17, 0x06, 0xc0,
	0x7d, 0xf2, 0x2c, 0x8c, 0xd8, 0xbe, 0x88, 0x66, 0xd9, 0x65, 0x11, 0x98, 0x49, 0x1b, 0xc3, 0xb6,
	0x7f, 0x23, 0x84, 0xe1, 0x9e, 0xe8, 0xd9, 0xae, 0x67, 0x07, 0x4d, 0x0c, 0xad, 0xb0, 0x3d, 0x51,
	0x94, 0xf5, 0xdf, 0x4c, 0x40, 0x16, 0x6f, 0xa4, 0xe8, 0x1b, 0x0d, 0xea, 0x35, 0xc9, 0x54, 0xa8,
	0x4f, 0x99, 0xf9, 0x41, 0x45, 0x29, 0x72, 0x90, 0xf0, 0x1f, 0x48, 0x17, 0x95, 0xfd, 0x6c, 0xa9,
	0x49, 0xe2, 0xf0, 0x6a, 0xf2, 0x24, 0x8c, 0xda, 0x7e, 0xc9, 0xb2, 0x7d, 0x91, 0xd8, 0x20, 0x43,
	0xdf, 0x23, 0xb6, 0xbf, 0xd8, 0x02, 0x92, 0x79, 0x48, 0xd5, 0xef, 0xc9, 0xa8, 0xf7, 0x68, 0xd7,
	0x24, 0xc6, 0xf0, 0x64, 0xd0, 0x1a, 0x43, 0xe1, 0x2e, 0xc3, 0x31, 0x38, 0x2a, 0x1f, 0x7c, 0x78,
	0xe5, 0xa2, 0x9d, 0x1f, 0x50, 0x2e, 0x4e, 0x3e, 0x0e, 0x83, 0x4c, 0x5b, 0x6d, 0x0b, 0xe7, 0x7f,
	0x78, 0x7e, 0xf1, 0x68, 0x0b, 0x28, 0xc5, 0x16, 0xe5, 0xa2, 0x91, 0x0a, 0x76, 0x9d, 0x65, 0x8c,
	0xda, 0x63, 0x7a, 0x8c, 0xe3, 0x3a, 0xa8, 0x1c, 0x19, 0x63, 0xc8, 0x7f, 0x50, 0x9d, 0x73, 0x5c,
	0x47, 0x7f, 0x12, 0x52, 0xc8, 0x23, 0x19, 0x81, 0xcc, 0x5d, 0x63, 0xe9, 0xee, 0x9c, 0xb1, 0xbc,
	0x7a, 0x3d, 0x77, 0x8c, 0x15, 0x97, 0x7e, 0x66, 0x69, 0x61, 0x63, 0x9d, 0x15, 0x35, 0xfd, 0x59,
	0x38, 0xce, 0x5c, 0xda, 0x35, 0xea, 0xfb, 0xca, 0xd5, 0x20, 0x1b, 0x51, 0xc3, 0xa7, 0x9e, 0xe2,
	0xb6, 0x85, 0x65, 0xfd, 0xbf, 0x93, 0x30, 0x24, 0xda, 0x3f, 0xd2, 0x1d, 0x5c, 0xe5, 0x61, 0x20,
	0xca, 0x03, 0x9b, 0xdc, 0x72, 0xd5, 0xa6, 0x4e, 0x10, 0xa6, 0x06, 0x71, 0x13, 0x30, 0xc2, 0xa1,
	0x32, 0xc3, 0xe8, 0x02, 0xe4, 0xf0, 0x5a, 0xac, 0x8c, 0x6f, 0x05, 0x78, 0x96, 0x11, 0x3f, 0xc9,
	0x8c, 0x29, 0x70, 0x91, 0x69, 0x34, 0x8a, 0x57, 0xd9, 0xb4, 0x24, 0x2e, 0x0c, 0x44, 0xd6, 0xc2,
	0xb9, 0xfe, 0x14, 0x42, 0x06, 0x1d, 0xcd, 0x10, 0xc4, 0x96, 0x7f, 0xa8, 0xbf, 0x83, 0x87, 0xd7,
	0xdf, 0x8b, 0x30, 0x5e, 0x35, 0xfd, 0xa0, 0xa4, 0x70, 0xd5, 0x14, 0x93, 0x3c, 0xc6, 0x2a, 0x3a,
	0x57, 0x54, 0x06, 0x15, 0x4c, 0x5d, 0x51, 0x6d, 0x06, 0x02, 0xfa, 0x31, 0x10, 0xd9, 0x6e, 0x06,
	0x62, 0x0e, 0x40, 0xf0, 0x11, 0xec, 0x3a, 0x22, 0x32, 0x1b, 0x97, 0x88, 0x26, 0xb6, 0x0e, 0x23,
	0xc3, 0xb1, 0xd6, 0x77, 0x1d, 0x72, 0x15, 0xa6, 0x3a, 0xc6, 0xc3, 0x35, 0x97, 0xdb, 0x8b, 0xe3,
	0x6d, 0x83, 0x62, 0x5a, 0x7c, 0x33, 0x99, 0x1e, 0xca, 0xa5, 0xf5, 0x5f, 0xd5, 0x60, 0x5c, 0xd5,
	0x52, 0xee, 0x8d, 0x3d, 0x4a, 0xdd, 0x3b, 0x38, 0x2a, 0xf5, 0xbb, 0x1a, 0x4c, 0x44, 0x57, 0x8c,
	0x70, 0x39, 0x16, 0x21, 0xed, 0x0b, 0x98, 0xf0, 0x39, 0xe2, 0x04, 0x24, 0xd0, 0x65, 0xb0, 0x5e,
	0x62, 0x92, 0x9b, 0x6d, 0x7e, 0x42, 0x9c, 0x3d, 0xea, 0x10, 0x49, 0xd4, 0x55, 0xd0, 0x1f, 0x00,
	0x59, 0x30, 0x9d, 0x32, 0xad, 0xa2, 0x3c, 0x7b, 0x9e, 0x21, 0xce, 0x41, 0x9a, 0x4f, 0x8a, 0xcd,
	0xaf, 0xc3, 0x32, 0xf3, 0x59, 0xe6, 0xaf, 0x22, 0x32, 0xf3, 0x3b, 0xb1, 0xb2, 0x6d, 0x5d, 0x26,
	0xda, 0x6c, 0xc3, 0x75, 0x38, 0x1e, 0xe9, 0x52, 0xc8, 0x86, 0x1d, 0xe8, 0x10, 0x4c, 0x2d, 0x71,
	0x07, 0x1a, 0x96, 0x5b, 0x11, 0x92, 0x01, 0x25, 0x42, 0xa2, 0x37, 0x61, 0x82, 0x13, 0x12, 0x03,
	0xec, 0xc9, 0xfd, 0x25, 0x00, 0x21, 0x44, 0xc9, 0xff, 0x30, 0xbf, 0xa0, 0x17, 0x04, 0x96, 0x17,
	0x8d, 0x8c, 0x68, 0xd0, 0x63, 0x0c, 0xcb, 0x30, 0xd9, 0xd6, 0xf5, 0x43, 0x8f, 0xe2, 0x5f, 0x34,
	0xc8, 0xad, 0xd5, 0x4d, 0x27, 0x12, 0xb1, 0x3d, 0xdb, 0x36, 0x84, 0x79, 0x68, 0xe9, 0x6d, 0x38,
	0x1c, 0x43, 0xbd, 0x6a, 0xe4, 0xa3, 0xb9, 0xf6, 0x93, 0xbd, 0xd9, 0x67, 0x0f, 0xe7, 0x84, 0xde,
	0xa2, 0x4d, 0xe5, 0x86, 0x72, 0xb5, 0x75, 0x43, 0x99, 0x38, 0x0a, 0x45, 0x71, 0xb1, 0xa9, 0xff,
	0x89, 0x06, 0xe3, 0xca, 0xe8, 0x84, 0x94, 0x56, 0x20, 0x2b, 0xf2, 0x80, 0x44, 0x98, 0xb9, 0xe3,
	0x86, 0xb3, 0x3d, 0xde, 0x7d, 0xfb, 0xa3, 0x0b, 0x0b, 0x48, 0x43, 0x3e, 0x6d, 0xe0, 0xc9, 0x42,
	0x78, 0xe9, 0x34, 0x0b, 0x59, 0x7e, 0x82, 0x28, 0xbb, 0x0d, 0x27, 0x10, 0x01, 0x33, 0x40, 0xd0,
	0x02, 0x83, 0x90, 0xe7, 0x60, 0xca, 0xac, 0xd7, 0x3d, 0x77, 0xd7, 0xae, 0x99, 0x01, 0x65, 0xfb,
	0xfd, 0xb6, 0x30, 0x64, 0x3c, 0x89, 0x62, 0x42, 0xa9, 0x5d, 0xb4, 0xfd, 0x6d, 0xb4, 0x67, 0xfa,
	0x87, 0x60, 0x42, 0xdc, 0x97, 0x45, 0x2f, 0x61, 0xfa, 0x99, 0x1b, 0xfd, 0x5b, 0x23, 0x30, 0xd9,
	0x86, 0xdd, 0x19, 0xb0, 0x4d, 0xbf, 0xdf, 0x26, 0xe9, 0xfb, 0x1a, 0x1c, 0x97, 0x77, 0x7a, 0x6a,
	0x26, 0x7e, 0xa6, 0x67, 0x26, 0x7e, 0x57, 0x5e, 0x0b, 0xe1, 0x7d, 0x61, 0xf7, 0x4c, 0xfc, 0xb6,
	0xea, 0x87, 0xcf, 0xc4, 0xaf, 0xb7, 0xf5, 0x93, 0xff, 0x87, 0x0c, 0x4f, 0x74, 0x0c, 0x93, 0x24,
	0x3a, 0xae, 0x55, 0xb5, 0x2e, 0xd7, 0xaa, 0xbf, 0xa8, 0xc1, 0xa4, 0x92, 0x37, 0x51, 0x6a, 0x8f,
	0x24, 0xdf, 0xd9, 0xdf, 0x9b, 0x3d, 0xbe, 0xd1, 0x6a, 0x70, 0xe4, 0x23, 0xe6, 0xf1, 0x46, 0x3b,
	0x31, 0xcb, 0x27, 0x7f, 0xa0, 0xc1, 0x39, 0x25, 0xe9, 0xa2, 0x23, 0x67, 0x43, 0x61, 0x2b, 0x81,
	0x6c, 0x7d, 0x62, 0x7f, 0x6f, 0xf6, 0x4c, 0x2b, 0x23, 0x23, 0x9a, 0xc5, 0x71, 0x64, 0x1e, 0xcf,
	0x78, 0xb1, 0x94, 0x2d, 0x9f, 0x7c, 0x5e, 0x83, 0xe9, 0x68, 0xa2, 0x88, 0xc2, 0x62, 0x12, 0x59,
	0xbc, 0xbb, 0xbf, 0x37, 0x3b, 0xb1, 0xaa, 0xa4, 0x8d, 0x1c, 0x99, 0xad, 0x09, 0xa7, 0x83, 0x9a,
	0xe5, 0x93, 0x5d, 0x20, 0x32, 0xc5, 0x44, 0xe1, 0x21, 0x85, 0x3c, 0xdc, 0xda, 0xdf, 0x9b, 0x1d,
	0x5b, 0xe5, 0x09, 0x27, 0x47, 0xee, 0x7e, 0xcc, 0x51, 0x09, 0x59, 0x3e, 0xf9, 0x8a, 0x06, 0x27,
	0xdb, 0x12, 0x5e, 0x14, 0x0e, 0x06, 0x91, 0x83, 0xb5, 0xfd, 0xbd, 0xd9, 0x13, 0x1b, 0xd1, 0x46,
	0x47, 0xe6, 0xe4, 0x44, 0xa3, 0x1b, 0x41, 0xcb, 0x27, 0xbf, 0xa3, 0x81, 0x7e, 0x50, 0x52, 0x8d,
	0xc2, 0xda, 0x10, 0xb2, 0xf6, 0xe6, 0xfe, 0xde, 0xec, 0xcc, 0x1b, 0x5d, 0x53, 0x6c, 0x8e, 0xcc,
	0xe1, 0xcc, 0x83, 0x18, 0xba, 0x96, 0x4f, 0xbe, 0xae, 0xc1, 0xe9, 0xce, 0x1c, 0x1e, 0x85, 0xc5,
	0x74, 0x4b, 0x7a, 0x46, 0x34, 0xa3, 0xe7, 0xe8, 0xd2, 0xf3, 0xba, 0x11, 0xb4, 0x7c, 0xf2, 0x25,
	0x0d, 0xa6, 0xa3, 0x59, 0x41, 0x0a, 0x43, 0x19, 0x64, 0xc8, 0xd8, 0xdf, 0x9b, 0x9d, 0xba, 0xb3,
	0xf3, 0xbe, 0xce, 0xe6, 0x94, 0xbb, 0xd3, 0x6d, 0x32, 0xf3, 0xef, 0x6a, 0xe1, 0x7e, 0xd0, 0xf3,
	0x6d, 0xd1, 0x5a, 0x34, 0x3a, 0xf3, 0xca, 0xa1, 0xcd, 0xb6, 0x6a, 0x39, 0x95, 0x80, 0xcd, 0xcd,
	0x64, 0x5a, 0xcb, 0xa5, 0xf5, 0x17, 0x20, 0x77, 0xc3, 0x0d, 0x1e, 0x62, 0x4f, 0xfb, 0xc2, 0x10,
	0x8c, 0x2b, 0x98, 0x1f, 0xc0, 0xf3, 0xcb, 0xbf, 0xd1, 0x60, 0xf2, 0x9e, 0x1b, 0xf0, 0x99, 0xeb,
	0xf2, 0xb6, 0x6c, 0x21, 0x46, 0x34, 0x1d, 0x9c, 0xb6, 0x20, 0xd1, 0xed, 0xec, 0xae, 0xd8, 0xce,
	0xc6, 0xdb, 0xeb, 0x1f, 0x7a, 0x3f, 0x1b, 0xbf, 0xd7, 0xde, 0x53, 0x7e, 0x07, 0xd2, 0x92, 0x3c,
	0xf9, 0x70, 0x24, 0x69, 0xbf, 0xdb, 0xe3, 0x18, 0x6c, 0x77, 0x40, 0xb6, 0x7e, 0xf7, 0x44, 0xb6,
	0x81, 0xee, 0x89, 0x6c, 0xf9, 0xbf, 0xd7, 0x60, 0x04, 0xd3, 0x1a, 0xc2, 0xf9, 0x7a, 0xd4, 0x39,
	0x13, 0x6f, 0x02, 0xb4, 0xa6, 0x4c, 0xcc, 0xd3, 0xb5, 0x87, 0x9a, 0xa7, 0x30, 0xf7, 0x55, 0xb6,
	0xc8, 0x7f, 0x4e, 0x6b, 0x7b, 0xff, 0xd0, 0x97, 0x5b, 0x60, 0xc0, 0x20, 0x32, 0x27, 0xb9, 0x79,
	0xf9, 0x50, 0xdc, 0x44, 0xa4, 0x67, 0x08, 0x4a, 0xf9, 0xcf, 0xc0, 0x54, 0x77, 0x75, 0xea, 0xb2,
	0x9e, 0xef, 0x44, 0xd7, 0xf3, 0x4b, 0x87, 0xea, 0x5e, 0x1d, 0xae, 0x1a, 0x7c, 0xbd, 0x00, 0xc3,
	0xfd, 0x66, 0x0f, 0x7c, 0x37, 0x25, 0xf2, 0x88, 0x3e, 0x90, 0x35, 0xab, 0x5e, 0x69, 0x0c, 0x3c,
	0x82, 0x2b, 0x8d, 0xbf, 0xd2, 0x60, 0xc2, 0x13, 0x03, 0x89, 0x98, 0x04, 0x7e, 0x33, 0xf1, 0x91,
	0x5e, 0x97, 0x38, 0x4a, 0xda, 0xb7, 0x20, 0x72, 0x80, 0x39, 0x68, 0xaf, 0x7f, 0x78, 0x73, 0xe0,
	0xb5, 0xf7, 0x94, 0xff, 0x5a, 0xbb, 0x22, 0xe7, 0x21, 0x2d, 0x5b, 0xc9, 0x73, 0xa3, 0x77, 0xa0,
	0x92, 0x77, 0xfb, 0xf8, 0xc3, 0x6b, 0x90, 0xb2, 0x9d, 0x2d, 0x57, 0x5e, 0xd0, 0x1c, 0xea, 0x2e,
	0x0b, 0x11, 0xf3, 0x6f, 0xc1, 0x54, 0x77, 0x91, 0x74, 0x51, 0xe9, 0x5b, 0x51, 0x95, 0xbe, 0xd6,
	0xb7, 0xd0, 0x0f, 0x50, 0xe7, 0x9b, 0xc9, 0x74, 0x32, 0x97, 0xd2, 0x9f, 0x01, 0xb2, 0xd8, 0xfa,
	0x62, 0x4a, 0xcf, 0xdb, 0xc2, 0xf3, 0xc2, 0xb6, 0xf5, 0x6e, 0xf9, 0x87, 0x03, 0x30, 0x2c, 0xde,
	0x78, 0xf1, 0x6f, 0x74, 0x3c, 0x6a, 0x2b, 0xf8, 0x34, 0x8c, 0x53, 0xa7, 0xec, 0x35, 0xf1, 0x96,
	0x41, 0xe6, 0x13, 0xe2, 0x19, 0xdd, 0xc8, 0xb5, 0x2a, 0xc4, 0x2d, 0xe0, 0xac, 0x3c, 0x0e, 0xf3,
	0x2b, 0x60, 0x7e, 0x28, 0xe5, 0x27, 0x5c, 0xbc, 0x25, 0x6e, 0x35, 0xe0, 0xa7, 0xd6, 0xa4, 0xd2,
	0x80, 0xc7, 0xde, 0xce, 0x43, 0x4e, 0xc4, 0xcc, 0xb6, 0x69, 0x53, 0x90, 0xe1, 0xc9, 0xee, 0x22,
	0x62, 0x79, 0x8b, 0x36, 0x39, 0xa9, 0x68, 0x4b, 0x4e, 0x6f, 0xb0, 0xad, 0x25, 0x3f, 0xff, 0x7e,
	0x0c, 0x46, 0xa5, 0x74, 0xc3, 0x24, 0x19, 0x69, 0x48, 0x7b, 0x3f, 0x17, 0x57, 0xa5, 0x2d, 0x63,
	0x4e, 0x1c, 0x59, 0x7f, 0x11, 0xc6, 0x5b, 0x37, 0x2a, 0x87, 0xf2, 0x40, 0xfe, 0x2c, 0x0d, 0x44,
	0x45, 0x15, 0x7c, 0xd5, 0x31, 0x47, 0x45, 0x40, 0x05, 0x6f, 0x37, 0xe3, 0xb3, 0x10, 0xda, 0x48,
	0x14, 0x16, 0xdc, 0x6a, 0x95, 0x96, 0x03, 0x6a, 0x85, 0x75, 0x1d, 0x29, 0xae, 0x4a, 0x1f, 0x64,
	0x01, 0x00, 0x03, 0x95, 0x1e, 0xf5, 0xe9, 0xe1, 0x6e, 0x1e, 0x32, 0x0c, 0xcf, 0x60, 0x68, 0xe4,
	0x05, 0x98, 0x96, 0x2f, 0x9f, 0x4b, 0x66, 0xbd, 0x8e, 0xa1, 0xe7, 0x52, 0xdd, 0xa3, 0x5b, 0xf6,
	0xae, 0x88, 0x40, 0x4f, 0xca, 0xfa, 0xb9, 0x7a, 0x7d, 0xd5, 0xac, 0xd1, 0xbb, 0x58, 0x49, 0xde,
	0x81, 0x61, 0x7c, 0x63, 0xc1, 0x26, 0xcc, 0x75, 0x64, 0x14, 0x7a, 0xfd, 0x70, 0x23, 0x5e, 0x12,
	0x1f, 0x28, 0x09, 0x47, 0xbe, 0xde, 0x22, 0xd9, 0x31, 0xf6, 0x48, 0x7f, 0xf9, 0xbf, 0xd6, 0x60,
	0x46, 0xa2, 0x77, 0x91, 0xd7, 0x2d, 0xda, 0x24, 0xaf, 0x43, 0x9a, 0xe9, 0x57, 0x98, 0xfc, 0xd4,
	0x16, 0xde, 0x79, 0x50, 0x2d, 0x74, 0x47, 0x94, 0x69, 0x38, 0xdb, 0xb4, 0xb9, 0x68, 0x06, 0xa6,
	0xba, 0x53, 0x0d, 0xbc, 0xcf, 0x3b, 0x55, 0xfe, 0x1b, 0x03, 0x70, 0x3a, 0x6e, 0xde, 0x89, 0xd5,
	0xb2, 0x7b, 0xd9, 0x2b, 0x2b, 0x0f, 0x27, 0xde, 0xd8, 0x61, 0xa2, 0x2d, 0x7d, 0x55, 0x66, 0x5b,
	0x0e, 0x74, 0x86, 0xcc, 0xbb, 0xcb, 0x29, 0x9a, 0x73, 0x7d, 0x1b, 0x03, 0xfb, 0x68, 0x34, 0xe6,
	0x5f, 0xe1, 0x81, 0xfd, 0x43, 0x4b, 0x66, 0x2d, 0xa8, 0x05, 0xfc, 0x3e, 0x20, 0xff, 0x23, 0x0d,
	0xce, 0xf5, 0xa7, 0x1b, 0xc4, 0xe0, 0xeb, 0xce, 0x57, 0xa7, 0xf9, 0x99, 0x36, 0xf6, 0xfb, 0x52,
	0xaf, 0x0c, 0x92, 0x79, 0xd4, 0x13, 0xae, 0x7f, 0x7e, 0x00, 0xf2, 0xa1, 0x38, 0x23, 0x1b, 0x4d,
	0xdd, 0xf5, 0x02, 0x32, 0x1a, 0xde, 0x39, 0x26, 0xf0, 0x66, 0xe4, 0x34, 0x64, 0xca, 0x6e, 0xad,
	0x5e, 0xa5, 0x01, 0xb5, 0x44, 0x66, 0x50, 0x0b, 0x40, 0xae, 0xc2, 0x64, 0x68, 0x10, 0x4a, 0x5b,
	0xb6, 0x53, 0xa1, 0x5e, 0xdd, 0xb3, 0x9d, 0x40, 0xc4, 0x8a, 0x27, 0xc2, 0xca, 0xd7, 0x5b, 0x75,
	0xe4, 0x55, 0x98, 0x6e, 0x21, 0x29, 0x1f, 0x07, 0x63, 0xc3, 0xc5, 0xd7, 0xb1, 0x28, 0x10, 0xcd,
	0x98, 0xf2, 0xbb, 0xb0, 0x89, 0xf9, 0x1c, 0xc3, 0x1e, 0x37, 0x98, 0xfc, 0x45, 0x6d, 0xea, 0x10,
	0x96, 0x27, 0x1b, 0x62, 0xce, 0x05, 0xfa, 0x27, 0xe1, 0xa9, 0x05, 0x8f, 0x9a, 0x01, 0x3d, 0x58,
	0x1e, 0xd2, 0x32, 0x1f, 0x38, 0x50, 0xed, 0xe0, 0x81, 0xea, 0x4d, 0x38, 0xdf, 0x9b, 0xbe, 0x30,
	0xdf, 0xb7, 0x61, 0xd0, 0x43, 0x88, 0x50, 0xa1, 0x6b, 0xfd, 0xac, 0xb4, 0x4e, 0x72, 0x82, 0x88,
	0xfe, 0x04, 0xe8, 0x07, 0xb7, 0x0a, 0x1f, 0x36, 0xfe, 0x3c, 0x9c, 0x8d, 0x6d, 0x25, 0x78, 0xdb,
	0x80, 0x21, 0x4e, 0x56, 0xee, 0x2b, 0x0f, 0xc7, 0x9c, 0x34, 0x6b, 0x82, 0x96, 0xfe, 0x7b, 0x1a,
	0x4c, 0x74, 0x6b, 0xdd, 0xa1, 0x83, 0x07, 0x0a, 0x7f, 0x20, 0x46, 0xcb, 0xae, 0xc3, 0x70, 0x59,
	0x2e, 0x3b, 0xf9, 0x2c, 0xbb, 0x6f, 0x2d, 0x09, 0x31, 0xe7, 0x02, 0xe1, 0x95, 0x7d, 0x0c, 0x4e,
	0x75, 0x1f, 0x19, 0xd7, 0x8f, 0x17, 0x63, 0x74, 0x9a, 0x0f, 0xe4, 0x00, 0x6d, 0xd6, 0x1f, 0xc0,
	0xe9, 0xee, 0x84, 0xc3, 0x87, 0xa6, 0x59, 0x85, 0x9e, 0xb0, 0x8f, 0xc5, 0xc3, 0x4e, 0x80, 0x4a,
	0x43, 0xbf, 0x0a, 0xd3, 0x37, 0xdd, 0x4d, 0x83, 0x56, 0x6c, 0x3f, 0xf0, 0x9a, 0x22, 0xa7, 0xa5,
	0x97, 0xf7, 0xf8, 0x5f, 0x1a, 0x9c, 0xec, 0x82, 0xf5, 0x01, 0x1c, 0xa6, 0x3e, 0x0e, 0xc3, 0x5e,
	0xc3, 0x71, 0x6c, 0xa7, 0x52, 0xba, 0xef, 0x6e, 0xca, 0x03, 0x6c, 0x5c, 0xa2, 0xd2, 0x81, 0x7c,
	0x62, 0x4d, 0x56, 0x50, 0xbb, 0xe9, 0x6e, 0xfa, 0xf9, 0x49, 0x48, 0xdc, 0x74, 0x37, 0xdb, 0x55,
	0x4e, 0xbf, 0x00, 0xb9, 0x9b, 0xee, 0x66, 0x54, 0x34, 0x93, 0x30, 0x78, 0xdf, 0xdd, 0x6c, 0xcd,
	0x68, 0xea, 0xbe, 0xbb, 0xb9, 0x6c, 0xe9, 0x4b, 0x30, 0xae, 0x34, 0x15, 0xf2, 0xb8, 0x0c, 0x89,
	0xfb, 0xee, 0xa6, 0x58, 0xcb, 0x33, 0x6d, 0xdb, 0x01, 0x7e, 0x76, 0x91, 0x7f, 0x82, 0x11, 0x19,
	0x62, 0x4d, 0x2f, 0x5e, 0x03, 0x68, 0x25, 0x86, 0x92, 0x09, 0xc8, 0x5d, 0xbf, 0x63, 0xdc, 0xd9,
	0x58, 0x5f, 0x5e, 0x5d, 0x2a, 0xad, 0xad, 0xcf, 0x2d, 0xdc, 0x5a, 0xcb, 0x1d, 0x23, 0xe3, 0x30,
	0xb2, 0x7e, 0xc3, 0x58, 0x9a, 0x5b, 0x94, 0x20, 0xed, 0xe2, 0x13, 0x90, 0x96, 0x59, 0x97, 0x4a,
	0xda, 0xe1, 0x28, 0x40, 0x88, 0xbe, 0x96, 0xd3, 0xae, 0xfc, 0xdd, 0x53, 0x30, 0x28, 0xfc, 0xec,
	0x6f, 0x69, 0x30, 0xac, 0x7e, 0x30, 0x8d, 0x14, 0xfa, 0xfb, 0x24, 0x9a, 0x14, 0x43, 0xbe, 0xd8,
	0x77, 0x7b, 0x2e, 0x0b, 0xfd, 0xa9, 0x77, 0xff, 0xf1, 0x3f, 0xbe, 0x31, 0xf0, 0x38, 0x99, 0x2d,
	0x8a, 0x33, 0x40, 0x51, 0xfd, 0x9e, 0x5a, 0xf1, 0x2d, 0xa1, 0x38, 0x6f, 0x93, 0x5f, 0xd2, 0x60,
	0x48, 0x9e, 0x4d, 0xe2, 0xf2, 0xbe, 0xa2, 0x9f, 0x5f, 0xcb, 0x5f, 0xec, 0xa7, 0xa9, 0xe0, 0x45,
	0x47, 0x5e, 0x4e, 0x93, 0x7c, 0xc8, 0x8b, 0x48, 0x11, 0x57, 0xd8, 0xf0, 0x20, 0x85, 0xdf, 0x64,
	0x22, 0x4f, 0xf5, 0xfe, 0x6a, 0x13, 0xe7, 0xe0, 0x7c, 0xbf, 0x9f, 0x77, 0xd2, 0xa7, 0xb0, 0xff,
	0x1c, 0x19, 0x0d, 0xfb, 0xe7, 0x9f, 0x8f, 0x7a, 0x07, 0x92, 0x98, 0xe9, 0x79, 0xae, 0xe7, 0x03,
	0x76, 0xde, 0xe3, 0xa1, 0xbe, 0x21, 0xa6, 0x9f, 0xc1, 0x5e, 0xf3, 0x64, 0x3a, 0xda, 0xab, 0x32,
	0xe6, 0xcf, 0xc0, 0x10, 0x32, 0xba, 0xb1, 0xdc, 0xff, 0xa8, 0x2f, 0x1f, 0xf6, 0xa3, 0x56, 0xfa,
	0x49, 0xe4, 0xe3, 0x38, 0x19, 0x8f, 0xf2, 0x51, 0x6a, 0xd8, 0xe4, 0x1d, 0x40, 0x6b, 0xb1, 0xb1,
	0xdc, 0xb7, 0x08, 0xfa, 0xfd, 0x4e, 0x97, 0x7e, 0x16, 0x7b, 0x7d, 0x8c, 0x9c, 0xea, 0xe8, 0x55,
	0x11, 0xc0, 0xdb, 0xfc, 0x11, 0x3b, 0xa6, 0x37, 0x92, 0xa7, 0xfb, 0x4b, 0x82, 0x3c, 0x78, 0x2a,
	0x0e, 0xcc, 0x98, 0xd4, 0x27, 0x91, 0x99, 0x31, 0x32, 0x12, 0x32, 0xe3, 0x99, 0x5b, 0x01, 0xf9,
	0xac, 0x06, 0x83, 0x3c, 0xe8, 0x45, 0x7a, 0x3e, 0x60, 0x0c, 0x27, 0xe0, 0x42, 0x1f, 0x2d, 0x45,
	0xb7, 0x8f, 0x63, 0xb7, 0xa7, 0xc8, 0x49, 0xa5, 0x5b, 0xd6, 0x40, 0x91, 0x80, 0x0f, 0x83, 0xfc,
	0x15, 0x5a, 0x2c, 0x07, 0x91, 0x87, 0x6a, 0x79, 0x35, 0x93, 0x5f, 0x7c, 0x66, 0x76, 0xd9, 0xd9,
	0x72, 0x85, 0xda, 0x75, 0x76, 0x2a, 0xbe, 0x48, 0xdb, 0xea, 0xf4, 0x9b, 0x1a, 0x64, 0x95, 0xe7,
	0x53, 0xe4, 0x99, 0xfe, 0x9e, 0x59, 0xc9, 0xfe, 0x0b, 0xfd, 0x36, 0x17, 0x62, 0x38, 0x87, 0x1c,
	0x9d, 0x21, 0x33, 0x21, 0x47, 0xfc, 0x72, 0x1d, 0x5d, 0x6f, 0x85, 0xad, 0xaf, 0x69, 0x90, 0x09,
	0xdf, 0xb7, 0xc4, 0xaa, 0x43, 0xfb, 0xab, 0x9e, 0x58, 0x75, 0xe8, 0x78, 0x72, 0xa3, 0x5f, 0x40,
	0x86, 0xce, 0x92, 0xc7, 0x43, 0x86, 0x4c, 0xd9, 0x06, 0xb5, 0x54, 0xe1, 0xe9, 0x3b, 0x1a, 0x8c,
	0x46, 0xdf, 0x3f, 0x91, 0xcb, 0x7d, 0xf5, 0xa5, 0x44, 0x48, 0xf3, 0xcf, 0x1e, 0x02, 0x43, 0xb0,
	0xf8, 0x34, 0xb2, 0xf8, 0x24, 0x39, 0xdb, 0x85, 0x45, 0x54, 0xa2, 0xe2, 0x5b, 0x32, 0xd6, 0xf9,
	0x36, 0xf9, 0x82, 0x06, 0xc3, 0x6a, 0xba, 0x4d, 0xec, 0xee, 0xd2, 0x25, 0xa1, 0x2e, 0x76, 0x77,
	0xe9, 0x96, 0x4e, 0xd4, 0xc5, 0xa6, 0x84, 0x39, 0x42, 0xbf, 0x2e, 0xd2, 0xa1, 0xf0, 0xe1, 0xec,
	0x07, 0xc7, 0xd1, 0x2c, 0x72, 0x74, 0x92, 0x9c, 0x08, 0x39, 0xc2, 0x67, 0xc0, 0xa5, 0x90, 0xaf,
	0x6f, 0x69, 0x90, 0x55, 0xb2, 0x7f, 0x62, 0x95, 0xbe, 0x33, 0x31, 0x29, 0x56, 0xe9, 0xbb, 0x24,
	0x15, 0xe9, 0x17, 0x91, 0x9f, 0x27, 0x74, 0x65, 0xff, 0xc5, 0x56, 0x3c, 0xb5, 0xac, 0xa5, 0x61,
	0x2f, 0x6b, 0x17, 0xc9, 0xb7, 0x35, 0x18, 0x89, 0x24, 0xf5, 0x90, 0x62, 0xcf, 0xde, 0xa2, 0x99,
	0x47, 0xb1, 0xdb, 0x42, 0xd7, 0x7c, 0x21, 0xfd, 0x12, 0x32, 0x78, 0x4e, 0x7f, 0xbc, 0x9d, 0x41,
	0x21, 0xb1, 0x28, 0x8b, 0x9f, 0xd5, 0x20, 0x13, 0x66, 0xd3, 0xc4, 0xae, 0xcd, 0xf6, 0x8c, 0xa2,
	0xd8, 0xb5, 0xd9, 0x91, 0xa0, 0xa3, 0x4f, 0x23, 0x5b, 0x44, 0x6f, 0x99, 0x6a, 0xbf, 0x6e, 0x3a,
	0x8c, 0x85, 0x77, 0xd0, 0x9b, 0x2a, 0x6f, 0xc7, 0x1b, 0xeb, 0xc8, 0xc3, 0xa1, 0xd8, 0xed, 0x4a,
	0x7d, 0x2e, 0xd7, 0xc5, 0x6a, 0xfa, 0x48, 0x48, 0x31, 0x05, 0xbf, 0xa0, 0xc1, 0x90, 0x78, 0x9f,
	0x12, 0xeb, 0x28, 0x45, 0xdf, 0xb0, 0xf4, 0xcf, 0x42, 0xa7, 0x97, 0x54, 0xe7, 0x94, 0xda, 0x78,
	0x10, 0x2f, 0x5a, 0x62, 0x79, 0x88, 0xbe, 0x7a, 0x39, 0x0a, 0x0f, 0xe2, 0x03, 0x57, 0x0a, 0x0f,
	0xbf, 0xac, 0x41, 0x5a, 0xbe, 0x22, 0x22, 0x71, 0x6e, 0x60, 0xdb, 0x43, 0xa8, 0xfc, 0xd3, 0x7d,
	0xb5, 0x15, 0x9c, 0x74, 0x7a, 0x4f, 0x18, 0x5b, 0x8e, 0xee, 0x62, 0xc3, 0xea, 0xc3, 0xb7, 0x78,
	0x1b, 0xd3, 0xf9, 0xa2, 0x2e, 0xde, 0xc6, 0x74, 0x79, 0x51, 0xd7, 0xc5, 0xa7, 0xa9, 0xba, 0x95,
	0x76, 0xb6, 0xbe, 0xa2, 0xc1, 0x90, 0xc0, 0x8e, 0x9d, 0xa2, 0xe8, 0x0b, 0xbb, 0xfc, 0x33, 0xf1,
	0x4d, 0xdb, 0xde, 0x17, 0x4a, 0xf3, 0x42, 0xf4, 0x18, 0x56, 0x8a, 0x6f, 0x31, 0xc0, 0xdb, 0xcc,
	0xcd, 0x5d, 0x71, 0x2b, 0x7e, 0xac, 0x8f, 0xa7, 0xbc, 0xd3, 0x3c, 0x2c, 0x2b, 0xdd, 0x2c, 0x6f,
	0x45, 0x95, 0xc8, 0xd7, 0x35, 0xfc, 0xca, 0x4d, 0x2b, 0x5d, 0x20, 0xd6, 0xbc, 0x75, 0xcb, 0x7c,
	0x8b, 0x35, 0x6f, 0x5d, 0x33, 0x11, 0xf4, 0x19, 0xe4, 0x6a, 0x9a, 0x4c, 0xa9, 0xab, 0x89, 0xb5,
	0x13, 0x4f, 0x5e, 0xde, 0xd5, 0x20, 0x13, 0xde, 0x79, 0xc6, 0x1a, 0xb4, 0xf6, 0x94, 0x85, 0x58,
	0x83, 0xd6, 0x71, 0x8d, 0xaa, 0xe7, 0x91, 0x91, 0x09, 0x42, 0x42, 0x46, 0xee, 0xb9, 0x81, 0x60,
	0xe2, 0x6d, 0x48, 0x71, 0x9f, 0xe2, 0xa9, 0xde, 0xd7, 0x58, 0xbd, 0x0f, 0x3d, 0x51, 0x0f, 0xe2,
	0x00, 0xe7, 0x53, 0xf5, 0x1b, 0x7e, 0x43, 0x83, 0xac, 0x1a, 0x02, 0x8a, 0x9b, 0xf8, 0xce, 0xf0,
	0x4b, 0xb7, 0x49, 0x89, 0xfc, 0x1b, 0x04, 0x0a, 0x0e, 0x8f, 0x45, 0x75, 0xf1, 0x04, 0x15, 0x04,
	0x45, 0x63, 0x98, 0x63, 0xce, 0x6f, 0x80, 0x7a, 0xd8, 0x7a, 0xe5, 0x0a, 0x2e, 0xd6, 0x31, 0x8f,
	0x5e, 0x27, 0x75, 0xb5, 0xf6, 0xac, 0x81, 0xc2, 0xc2, 0xaf, 0x68, 0x18, 0x1a, 0x90, 0xd7, 0x2e,
	0x97, 0xfa, 0x8c, 0xc1, 0xf7, 0x5e, 0x41, 0x9d, 0x11, 0x7b, 0xfd, 0x14, 0xb2, 0x33, 0x49, 0x8e,
	0xab, 0x9b, 0x8f, 0xec, 0xf9, 0x87, 0x1a, 0x9c, 0xe9, 0x15, 0xd0, 0x24, 0xf3, 0x71, 0xdb, 0x7f,
	0x7f, 0xd1, 0xd6, 0xfc, 0xc2, 0x91, 0x68, 0x44, 0x4d, 0xa4, 0x3e, 0xad, 0x0c, 0xa5, 0x16, 0xb0,
	0x59, 0x16, 0x01, 0x48, 0xb6, 0x93, 0xff, 0xa5, 0x76, 0x50, 0xf8, 0x0d, 0x39, 0xf1, 0xc9, 0x2b,
	0x0f, 0x15, 0xea, 0x0c, 0xc5, 0xff, 0xea, 0xc3, 0xa2, 0x1f, 0xb8, 0xf7, 0xb4, 0x0d, 0x82, 0xfc,
	0xf9, 0x41, 0x51, 0xd4, 0xe7, 0x0f, 0xdd, 0x35, 0x67, 0xf9, 0x85, 0x43, 0xe3, 0x09, 0x5e, 0x9f,
	0x43, 0x5e, 0x0b, 0xe4, 0x52, 0x07, 0xaf, 0xc5, 0xb7, 0x0e, 0x0a, 0x8e, 0xbe, 0x4d, 0xbe, 0xab,
	0x61, 0xfc, 0x2c, 0x1a, 0xaf, 0x23, 0x57, 0x0f, 0x17, 0xdd, 0xe3, 0x9c, 0x3f, 0xf7, 0x30, 0x21,
	0xc1, 0x2e, 0xe1, 0xa9, 0xfb, 0xee, 0x66, 0xc9, 0x13, 0x8d, 0xa3, 0xde, 0x46, 0x26, 0x8c, 0xf4,
	0xc5, 0xda, 0xe9, 0xf6, 0xd0, 0x61, 0xac, 0x9d, 0xee, 0x08, 0x1e, 0xea, 0x8f, 0x21, 0x47, 0x27,
	0xc8, 0xa4, 0xca, 0x51, 0xf1, 0x2d, 0x1e, 0x7c, 0x7c, 0x7b, 0xfe, 0xe2, 0x0f, 0xfe, 0x7d, 0xe6,
	0xd8, 0x0f, 0xf6, 0x67, 0xb4, 0x1f, 0xee, 0xcf, 0x68, 0x3f, 0xda, 0x9f, 0xd1, 0xfe, 0x6d, 0x7f,
	0x46, 0xfb, 0xea, 0x7b, 0x33, 0xc7, 0x7e, 0xf8, 0xde, 0xcc, 0xb1, 0x1f, 0xbd, 0x37, 0x73, 0xec,
	0xcd, 0xb4, 0x24, 0xbe, 0x39, 0x88, 0x71, 0xee, 0xab, 0xff, 0x17, 0x00, 0x00, 0xff, 0xff, 0xd6,
	0x76, 0x48, 0x96, 0x57, 0x66, 0x00, 0x00,
}
